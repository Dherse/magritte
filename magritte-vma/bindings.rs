/* automatically generated by rust-bindgen 0.59.2 */

pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __uint64_t = ::std::os::raw::c_ulong;
/// No intended memory usage specified.
///Use other members of VmaAllocationCreateInfo to specify your requirements.
pub const VmaMemoryUsage_VMA_MEMORY_USAGE_UNKNOWN: VmaMemoryUsage = 0;
///\deprecated Obsolete, preserved for backward compatibility.
///Prefers `VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT`.
pub const VmaMemoryUsage_VMA_MEMORY_USAGE_GPU_ONLY: VmaMemoryUsage = 1;
///\deprecated Obsolete, preserved for backward compatibility.
///Guarantees `VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT` and `VK_MEMORY_PROPERTY_HOST_COHERENT_BIT`.
pub const VmaMemoryUsage_VMA_MEMORY_USAGE_CPU_ONLY: VmaMemoryUsage = 2;
///\deprecated Obsolete, preserved for backward compatibility.
///Guarantees `VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT`, prefers `VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT`.
pub const VmaMemoryUsage_VMA_MEMORY_USAGE_CPU_TO_GPU: VmaMemoryUsage = 3;
///\deprecated Obsolete, preserved for backward compatibility.
///Guarantees `VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT`, prefers `VK_MEMORY_PROPERTY_HOST_CACHED_BIT`.
pub const VmaMemoryUsage_VMA_MEMORY_USAGE_GPU_TO_CPU: VmaMemoryUsage = 4;
///\deprecated Obsolete, preserved for backward compatibility.
///Prefers not `VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT`.
pub const VmaMemoryUsage_VMA_MEMORY_USAGE_CPU_COPY: VmaMemoryUsage = 5;
///Lazily allocated GPU memory having `VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT`.
///Exists mostly on mobile platforms. Using it on desktop PC or other GPUs with no such memory type
/// present will fail the allocation.
///
///Usage: Memory for transient attachment images (color attachments, depth attachments etc.),
/// created with `VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT`.
///
///Allocations with this usage are always created as dedicated - it implies
/// #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.
pub const VmaMemoryUsage_VMA_MEMORY_USAGE_GPU_LAZILY_ALLOCATED: VmaMemoryUsage = 6;
///Selects best memory type automatically.
///This flag is recommended for most common use cases.
///
///When using this flag, if you want to map the allocation (using vmaMapMemory() or
/// #VMA_ALLOCATION_CREATE_MAPPED_BIT),
///you must pass one of the flags: #VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT or
/// #VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT
///in VmaAllocationCreateInfo::flags.
///
///It can be used only with functions that let the library know `VkBufferCreateInfo` or
/// `VkImageCreateInfo`, e.g.
///vmaCreateBuffer(), vmaCreateImage(), vmaFindMemoryTypeIndexForBufferInfo(),
/// vmaFindMemoryTypeIndexForImageInfo()
///and not with generic memory allocation functions.
pub const VmaMemoryUsage_VMA_MEMORY_USAGE_AUTO: VmaMemoryUsage = 7;
///Selects best memory type automatically with preference for GPU (device) memory.
///
///When using this flag, if you want to map the allocation (using vmaMapMemory() or
/// #VMA_ALLOCATION_CREATE_MAPPED_BIT),
///you must pass one of the flags: #VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT or
/// #VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT
///in VmaAllocationCreateInfo::flags.
///
///It can be used only with functions that let the library know `VkBufferCreateInfo` or
/// `VkImageCreateInfo`, e.g.
///vmaCreateBuffer(), vmaCreateImage(), vmaFindMemoryTypeIndexForBufferInfo(),
/// vmaFindMemoryTypeIndexForImageInfo()
///and not with generic memory allocation functions.
pub const VmaMemoryUsage_VMA_MEMORY_USAGE_AUTO_PREFER_DEVICE: VmaMemoryUsage = 8;
///Selects best memory type automatically with preference for CPU (host) memory.
///
///When using this flag, if you want to map the allocation (using vmaMapMemory() or
/// #VMA_ALLOCATION_CREATE_MAPPED_BIT),
///you must pass one of the flags: #VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT or
/// #VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT
///in VmaAllocationCreateInfo::flags.
///
///It can be used only with functions that let the library know `VkBufferCreateInfo` or
/// `VkImageCreateInfo`, e.g.
///vmaCreateBuffer(), vmaCreateImage(), vmaFindMemoryTypeIndexForBufferInfo(),
/// vmaFindMemoryTypeIndexForImageInfo()
///and not with generic memory allocation functions.
pub const VmaMemoryUsage_VMA_MEMORY_USAGE_AUTO_PREFER_HOST: VmaMemoryUsage = 9;
///Selects best memory type automatically with preference for CPU (host) memory.
///
///When using this flag, if you want to map the allocation (using vmaMapMemory() or
/// #VMA_ALLOCATION_CREATE_MAPPED_BIT),
///you must pass one of the flags: #VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT or
/// #VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT
///in VmaAllocationCreateInfo::flags.
///
///It can be used only with functions that let the library know `VkBufferCreateInfo` or
/// `VkImageCreateInfo`, e.g.
///vmaCreateBuffer(), vmaCreateImage(), vmaFindMemoryTypeIndexForBufferInfo(),
/// vmaFindMemoryTypeIndexForImageInfo()
///and not with generic memory allocation functions.
pub const VmaMemoryUsage_VMA_MEMORY_USAGE_MAX_ENUM: VmaMemoryUsage = 2147483647;
/// \brief Intended usage of the allocated memory.
pub type VmaMemoryUsage = ::std::os::raw::c_uint;
/// Buffer/image has been recreated at `dstTmpAllocation`, data has been copied, old buffer/image
/// has been destroyed. `srcAllocation` should be changed to point to the new place. This is the
/// default value set by vmaBeginDefragmentationPass().
pub const VmaDefragmentationMoveOperation_VMA_DEFRAGMENTATION_MOVE_OPERATION_COPY: VmaDefragmentationMoveOperation = 0;
/// Set this value if you cannot move the allocation. New place reserved at `dstTmpAllocation` will
/// be freed. `srcAllocation` will remain unchanged.
pub const VmaDefragmentationMoveOperation_VMA_DEFRAGMENTATION_MOVE_OPERATION_IGNORE: VmaDefragmentationMoveOperation =
    1;
/// Set this value if you decide to abandon the allocation and you destroyed the buffer/image. New
/// place reserved at `dstTmpAllocation` will be freed, along with `srcAllocation`, which will be
/// destroyed.
pub const VmaDefragmentationMoveOperation_VMA_DEFRAGMENTATION_MOVE_OPERATION_DESTROY: VmaDefragmentationMoveOperation =
    2;
/// Operation performed on single defragmentation move. See structure #VmaDefragmentationMove.
pub type VmaDefragmentationMoveOperation = ::std::os::raw::c_uint;
/// Callback function called after successful vkAllocateMemory.
pub type PFN_vmaAllocateDeviceMemoryFunction = ::std::option::Option<
    unsafe extern "C" fn(
        allocator: VmaAllocator,
        memoryType: u32,
        memory: DeviceMemory,
        size: DeviceSize,
        pUserData: *mut ::std::os::raw::c_void,
    ),
>;
/// Callback function called before vkFreeMemory.
pub type PFN_vmaFreeDeviceMemoryFunction = ::std::option::Option<
    unsafe extern "C" fn(
        allocator: VmaAllocator,
        memoryType: u32,
        memory: DeviceMemory,
        size: DeviceSize,
        pUserData: *mut ::std::os::raw::c_void,
    ),
>;
/// \brief Set of callbacks that the library will call for `vkAllocateMemory` and `vkFreeMemory`.
///
///Provided for informative purpose, e.g. to gather statistics about number of
///allocations or total amount of memory allocated in Vulkan.
///
///Used in VmaAllocatorCreateInfo::pDeviceMemoryCallbacks.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VmaDeviceMemoryCallbacks {
    /// Optional, can be null.
    pub pfnAllocate: PFN_vmaAllocateDeviceMemoryFunction,
    /// Optional, can be null.
    pub pfnFree: PFN_vmaFreeDeviceMemoryFunction,
    /// Optional, can be null.
    pub pUserData: *mut ::std::os::raw::c_void,
}
/// Description of a Allocator to be created.
#[repr(C)]
pub struct VmaAllocatorCreateInfo {
    /// Flags for created allocator. Use #VmaAllocatorCreateFlagBits enum.
    pub flags: VmaAllocatorCreateFlags,
    /// Vulkan physical device.
    ///** It must be valid throughout whole lifetime of created allocator. */
    pub physicalDevice: PhysicalDevice,
    /// Vulkan device.
    ///** It must be valid throughout whole lifetime of created allocator. */
    pub device: Device,
    /// Preferred size of a single `VkDeviceMemory` block to be allocated from large heaps > 1 GiB.
    /// Optional.
    ///** Set to 0 to use default, which is currently 256 MiB. */
    pub preferredLargeHeapBlockSize: DeviceSize,
    /// Custom CPU memory allocation callbacks. Optional.
    ///** Optional, can be null. When specified, will also be used for all CPU-side memory
    /// allocations. */
    pub pAllocationCallbacks: *const AllocationCallbacks,
    /// Informative callbacks for `vkAllocateMemory`, `vkFreeMemory`. Optional.
    ///** Optional, can be null. */
    pub pDeviceMemoryCallbacks: *const VmaDeviceMemoryCallbacks,
    /// \brief Either null or a pointer to an array of limits on maximum number of bytes that can be
    /// allocated out of particular Vulkan memory heap.
    ///
    ///If not NULL, it must be a pointer to an array of
    ///`VkPhysicalDeviceMemoryProperties::memoryHeapCount` elements, defining limit on
    ///maximum number of bytes that can be allocated out of particular Vulkan memory
    ///heap.
    ///
    ///Any of the elements may be equal to `VK_WHOLE_SIZE`, which means no limit on that
    ///heap. This is also the default in case of `pHeapSizeLimit` = NULL.
    ///
    ///If there is a limit defined for a heap:
    ///
    /// - If user tries to allocate more memory from that heap using this allocator,
    ///the allocation fails with `VK_ERROR_OUT_OF_DEVICE_MEMORY`.
    /// - If the limit is smaller than heap size reported in `VkMemoryHeap::size`, the
    ///value of this limit will be reported instead when using vmaGetMemoryProperties().
    ///
    ///Warning! Using this feature may not be equivalent to installing a GPU with
    ///smaller amount of memory, because graphics driver doesn't necessary fail new
    ///allocations with `VK_ERROR_OUT_OF_DEVICE_MEMORY` result when memory capacity is
    ///exceeded. It may return success and just silently migrate some device memory
    ///blocks to system RAM. This driver behavior can also be controlled using
    ///VK_AMD_memory_overallocation_behavior extension.
    pub pHeapSizeLimit: *const DeviceSize,
    /// \brief Pointers to Vulkan functions. Can be null.
    ///
    ///For details see [Pointers to Vulkan functions](@ref config_Vulkan_functions).
    pub pVulkanFunctions: *const VmaVulkanFunctions,
    /// \brief Handle to Vulkan instance object.
    ///
    ///Starting from version 3.0.0 this member is no longer optional, it must be set!
    pub instance: Instance,
    /// \brief Optional. The highest version of Vulkan that the application is designed to use.
    ///
    ///It must be a value in the format as created by macro `VK_MAKE_VERSION` or a constant like:
    /// `VK_API_VERSION_1_1`, `VK_API_VERSION_1_0`.
    ///The patch version number specified is ignored. Only the major and minor versions are
    /// considered.
    ///It must be less or equal (preferably equal) to value as passed to `vkCreateInstance` as
    /// `VkApplicationInfo::apiVersion`.
    ///Only versions 1.0, 1.1, 1.2, 1.3 are supported by the current implementation.
    ///Leaving it initialized to zero is equivalent to `VK_API_VERSION_1_0`.
    pub vulkanApiVersion: u32,
    /// \brief Either null or a pointer to an array of external memory handle types for each Vulkan
    /// memory type.
    ///
    ///If not NULL, it must be a pointer to an array of
    /// `VkPhysicalDeviceMemoryProperties::memoryTypeCount`
    ///elements, defining external memory handle types of particular Vulkan memory type,
    ///to be passed using `VkExportMemoryAllocateInfoKHR`.
    ///
    ///Any of the elements may be equal to 0, which means not to use
    /// `VkExportMemoryAllocateInfoKHR` on this memory type.
    ///This is also the default in case of `pTypeExternalMemoryHandleTypes` = NULL.
    pub pTypeExternalMemoryHandleTypes: *const ExternalMemoryHandleTypeFlagsKHR,
}
/// Information about existing #VmaAllocator object.
#[repr(C)]
pub struct VmaAllocatorInfo {
    /// \brief Handle to Vulkan instance object.
    ///
    ///This is the same value as has been passed through VmaAllocatorCreateInfo::instance.
    pub instance: Instance,
    /// \brief Handle to Vulkan physical device object.
    ///
    ///This is the same value as has been passed through VmaAllocatorCreateInfo::physicalDevice.
    pub physicalDevice: PhysicalDevice,
    /// \brief Handle to Vulkan device object.
    ///
    ///This is the same value as has been passed through VmaAllocatorCreateInfo::device.
    pub device: Device,
}
/// \brief Calculated statistics of memory usage e.g. in a specific memory type, heap, custom pool,
/// or total.
///
///These are fast to calculate.
///See functions: vmaGetHeapBudgets(), vmaGetPoolStatistics().
#[repr(C)]
pub struct VmaStatistics {
    /// \brief Number of `VkDeviceMemory` objects - Vulkan memory blocks allocated.
    pub blockCount: u32,
    /// \brief Number of #VmaAllocation objects allocated.
    ///
    ///Dedicated allocations have their own blocks, so each one adds 1 to `allocationCount` as well
    /// as `blockCount`.
    pub allocationCount: u32,
    /// \brief Number of bytes allocated in `VkDeviceMemory` blocks.
    ///
    ///\note To avoid confusion, please be aware that what Vulkan calls an "allocation" - a whole
    /// `VkDeviceMemory` object
    ///(e.g. as in `VkPhysicalDeviceLimits::maxMemoryAllocationCount`) is called a "block" in VMA,
    /// while VMA calls
    ///"allocation" a #VmaAllocation object that represents a memory region sub-allocated from such
    /// block, usually for a single buffer or image.
    pub blockBytes: DeviceSize,
    /// \brief Total number of bytes occupied by all #VmaAllocation objects.
    ///
    ///Always less or equal than `blockBytes`.
    ///Difference `(blockBytes - allocationBytes)` is the amount of memory allocated from Vulkan
    ///but unused by any #VmaAllocation.
    pub allocationBytes: DeviceSize,
}
/// \brief More detailed statistics than #VmaStatistics.
///
///These are slower to calculate. Use for debugging purposes.
///See functions: vmaCalculateStatistics(), vmaCalculatePoolStatistics().
///
///Previous version of the statistics API provided averages, but they have been removed
///because they can be easily calculated as:
///
///\code
///VkDeviceSize allocationSizeAvg = detailedStats.statistics.allocationBytes /
/// detailedStats.statistics.allocationCount;
///VkDeviceSize unusedBytes = detailedStats.statistics.blockBytes -
/// detailedStats.statistics.allocationBytes;
///VkDeviceSize unusedRangeSizeAvg = unusedBytes / detailedStats.unusedRangeCount;
///\endcode
#[repr(C)]
pub struct VmaDetailedStatistics {
    /// Basic statistics.
    pub statistics: VmaStatistics,
    /// Number of free ranges of memory between allocations.
    pub unusedRangeCount: u32,
    /// Smallest allocation size. `VK_WHOLE_SIZE` if there are 0 allocations.
    pub allocationSizeMin: DeviceSize,
    /// Largest allocation size. 0 if there are 0 allocations.
    pub allocationSizeMax: DeviceSize,
    /// Smallest empty range size. `VK_WHOLE_SIZE` if there are 0 empty ranges.
    pub unusedRangeSizeMin: DeviceSize,
    /// Largest empty range size. 0 if there are 0 empty ranges.
    pub unusedRangeSizeMax: DeviceSize,
}
/// \brief  General statistics from current state of the Allocator -
///total memory usage across all memory heaps and types.
///
///These are slower to calculate. Use for debugging purposes.
///See function vmaCalculateStatistics().
#[repr(C)]
pub struct VmaTotalStatistics {
    pub memoryType: [VmaDetailedStatistics; 32usize],
    pub memoryHeap: [VmaDetailedStatistics; 16usize],
    pub total: VmaDetailedStatistics,
}
/// \brief Statistics of current memory usage and available budget for a specific memory heap.
///
///These are fast to calculate.
///See function vmaGetHeapBudgets().
#[repr(C)]
pub struct VmaBudget {
    /// \brief Statistics fetched from the library.
    pub statistics: VmaStatistics,
    /// \brief Estimated current memory usage of the program, in bytes.
    ///
    ///Fetched from system using VK_EXT_memory_budget extension if enabled.
    ///
    ///It might be different than `statistics.blockBytes` (usually higher) due to additional
    /// implicit objects
    ///also occupying the memory, like swapchain, pipelines, descriptor heaps, command buffers, or
    ///`VkDeviceMemory` blocks allocated outside of this library, if any.
    pub usage: DeviceSize,
    /// \brief Estimated amount of memory available to the program, in bytes.
    ///
    ///Fetched from system using VK_EXT_memory_budget extension if enabled.
    ///
    ///It might be different (most probably smaller) than `VkMemoryHeap::size[heapIndex]` due to
    /// factors
    ///external to the program, decided by the operating system.
    ///Difference `budget - usage` is the amount of additional memory that can probably
    ///be allocated without problems. Exceeding the budget may result in various problems.
    pub budget: DeviceSize,
}
/// \brief Parameters of new #VmaAllocation.
///
///To be used with functions like vmaCreateBuffer(), vmaCreateImage(), and many others.
#[repr(C)]
pub struct VmaAllocationCreateInfo {
    /// Use #VmaAllocationCreateFlagBits enum.
    pub flags: VmaAllocationCreateFlags,
    /// \brief Intended usage of memory.
    ///
    ///You can leave #VMA_MEMORY_USAGE_UNKNOWN if you specify memory requirements in other way. \n
    ///If `pool` is not null, this member is ignored.
    pub usage: VmaMemoryUsage,
    /// \brief Flags that must be set in a Memory Type chosen for an allocation.
    ///
    ///Leave 0 if you specify memory requirements in other way. \n
    ///If `pool` is not null, this member is ignored.
    pub requiredFlags: MemoryPropertyFlags,
    /// \brief Flags that preferably should be set in a memory type chosen for an allocation.
    ///
    ///Set to 0 if no additional flags are preferred. \n
    ///If `pool` is not null, this member is ignored.
    pub preferredFlags: MemoryPropertyFlags,
    /// \brief Bitmask containing one bit set for every memory type acceptable for this allocation.
    ///
    ///Value 0 is equivalent to `UINT32_MAX` - it means any memory type is accepted if
    ///it meets other requirements specified by this structure, with no further
    ///restrictions on memory type index. \n
    ///If `pool` is not null, this member is ignored.
    pub memoryTypeBits: u32,
    /// \brief Pool that this allocation should be created in.
    ///
    ///Leave `VK_NULL_HANDLE` to allocate from default pool. If not null, members:
    ///`usage`, `requiredFlags`, `preferredFlags`, `memoryTypeBits` are ignored.
    pub pool: VmaPool,
    /// \brief Custom general-purpose pointer that will be stored in #VmaAllocation, can be read as
    /// VmaAllocationInfo::pUserData and changed using vmaSetAllocationUserData().
    ///
    ///If #VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT is used, it must be either
    ///null or pointer to a null-terminated string. The string will be then copied to
    ///internal buffer, so it doesn't need to be valid after allocation call.
    pub pUserData: *mut ::std::os::raw::c_void,
    /// \brief A floating-point value between 0 and 1, indicating the priority of the allocation
    /// relative to other memory allocations.
    ///
    ///It is used only when #VMA_ALLOCATOR_CREATE_EXT_MEMORY_PRIORITY_BIT flag was used during
    /// creation of the #VmaAllocator object
    ///and this allocation ends up as dedicated or is explicitly forced as dedicated using
    /// #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.
    ///Otherwise, it has the priority of a memory block where it is placed and this variable is
    /// ignored.
    pub priority: f32,
}
/// Describes parameter of created #VmaPool.
#[repr(C)]
pub struct VmaPoolCreateInfo {
    /// \brief Vulkan memory type index to allocate this pool from.
    pub memoryTypeIndex: u32,
    /// \brief Use combination of #VmaPoolCreateFlagBits.
    pub flags: VmaPoolCreateFlags,
    /// \brief Size of a single `VkDeviceMemory` block to be allocated as part of this pool, in
    /// bytes. Optional.
    ///
    ///Specify nonzero to set explicit, constant size of memory blocks used by this
    ///pool.
    ///
    ///Leave 0 to use default and let the library manage block sizes automatically.
    ///Sizes of particular blocks may vary.
    ///In this case, the pool will also support dedicated allocations.
    pub blockSize: DeviceSize,
    /// \brief Minimum number of blocks to be always allocated in this pool, even if they stay
    /// empty.
    ///
    ///Set to 0 to have no preallocated blocks and allow the pool be completely empty.
    pub minBlockCount: usize,
    /// \brief Maximum number of blocks that can be allocated in this pool. Optional.
    ///
    ///Set to 0 to use default, which is `SIZE_MAX`, which means no limit.
    ///
    ///Set to same value as VmaPoolCreateInfo::minBlockCount to have fixed amount of memory
    /// allocated
    ///throughout whole lifetime of this pool.
    pub maxBlockCount: usize,
    /// \brief A floating-point value between 0 and 1, indicating the priority of the allocations in
    /// this pool relative to other memory allocations.
    ///
    ///It is used only when #VMA_ALLOCATOR_CREATE_EXT_MEMORY_PRIORITY_BIT flag was used during
    /// creation of the #VmaAllocator object.
    ///Otherwise, this variable is ignored.
    pub priority: f32,
    /// \brief Additional minimum alignment to be used for all allocations created from this pool.
    /// Can be 0.
    ///
    ///Leave 0 (default) not to impose any additional alignment. If not 0, it must be a power of
    /// two.
    ///It can be useful in cases where alignment returned by Vulkan by functions like
    /// `vkGetBufferMemoryRequirements` is not enough,
    ///e.g. when doing interop with OpenGL.
    pub minAllocationAlignment: DeviceSize,
    /// \brief Additional `pNext` chain to be attached to `VkMemoryAllocateInfo` used for every
    /// allocation made by this pool. Optional.
    ///
    ///Optional, can be null. If not null, it must point to a `pNext` chain of structures that can
    /// be attached to `VkMemoryAllocateInfo`.
    ///It can be useful for special needs such as adding `VkExportMemoryAllocateInfoKHR`.
    ///Structures pointed by this member must remain alive and unchanged for the whole lifetime of
    /// the custom pool.
    ///
    ///Please note that some structures, e.g. `VkMemoryPriorityAllocateInfoEXT`,
    /// `VkMemoryDedicatedAllocateInfoKHR`,
    ///can be attached automatically by this library when using other, more convenient of its
    /// features.
    pub pMemoryAllocateNext: *mut ::std::os::raw::c_void,
}
/// Parameters of #VmaAllocation objects, that can be retrieved using function
/// vmaGetAllocationInfo().
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VmaAllocationInfo {
    /// \brief Memory type index that this allocation was allocated from.
    ///
    ///It never changes.
    pub memoryType: u32,
    /// \brief Handle to Vulkan memory object.
    ///
    ///Same memory object can be shared by multiple allocations.
    ///
    ///It can change after the allocation is moved during \ref defragmentation.
    pub deviceMemory: DeviceMemory,
    /// \brief Offset in `VkDeviceMemory` object to the beginning of this allocation, in bytes.
    /// `(deviceMemory, offset)` pair is unique to this allocation.
    ///
    ///You usually don't need to use this offset. If you create a buffer or an image together with
    /// the allocation using e.g. function
    ///vmaCreateBuffer(), vmaCreateImage(), functions that operate on these resources refer to the
    /// beginning of the buffer or image,
    ///not entire device memory block. Functions like vmaMapMemory(), vmaBindBufferMemory() also
    /// refer to the beginning of the allocation
    ///and apply this offset automatically.
    ///
    ///It can change after the allocation is moved during \ref defragmentation.
    pub offset: DeviceSize,
    /// \brief Size of this allocation, in bytes.
    ///
    ///It never changes.
    ///
    ///\note Allocation size returned in this variable may be greater than the size
    ///requested for the resource e.g. as `VkBufferCreateInfo::size`. Whole size of the
    ///allocation is accessible for operations on memory e.g. using a pointer after
    ///mapping with vmaMapMemory(), but operations on the resource e.g. using
    ///`vkCmdCopyBuffer` must be limited to the size of the resource.
    pub size: DeviceSize,
    /// \brief Pointer to the beginning of this allocation as mapped data.
    ///
    ///If the allocation hasn't been mapped using vmaMapMemory() and hasn't been
    ///created with #VMA_ALLOCATION_CREATE_MAPPED_BIT flag, this value is null.
    ///
    ///It can change after call to vmaMapMemory(), vmaUnmapMemory().
    ///It can also change after the allocation is moved during \ref defragmentation.
    pub pMappedData: *mut ::std::os::raw::c_void,
    /// \brief Custom general-purpose pointer that was passed as VmaAllocationCreateInfo::pUserData
    /// or set using vmaSetAllocationUserData().
    ///
    ///It can change after call to vmaSetAllocationUserData() for this allocation.
    pub pUserData: *mut ::std::os::raw::c_void,
    /// \brief Custom allocation name that was set with vmaSetAllocationName().
    ///
    ///It can change after call to vmaSetAllocationName() for this allocation.
    ///
    ///Another way to set custom name is to pass it in VmaAllocationCreateInfo::pUserData with
    ///additional flag #VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT set [DEPRECATED].
    pub pName: *const ::std::os::raw::c_char,
}
/// \brief Parameters for defragmentation.
///
///To be used with function vmaBeginDefragmentation().
#[repr(C)]
pub struct VmaDefragmentationInfo {
    /// \brief Use combination of #VmaDefragmentationFlagBits.
    pub flags: VmaDefragmentationFlags,
    /// \brief Custom pool to be defragmented.
    ///
    ///If null then default pools will undergo defragmentation process.
    pub pool: VmaPool,
    /// \brief Maximum numbers of bytes that can be copied during single pass, while moving
    /// allocations to different places.
    ///
    ///`0` means no limit.
    pub maxBytesPerPass: DeviceSize,
    /// \brief Maximum number of allocations that can be moved during single pass to a different
    /// place.
    ///
    ///`0` means no limit.
    pub maxAllocationsPerPass: u32,
}
/// Single move of an allocation to be done for defragmentation.
#[repr(C)]
pub struct VmaDefragmentationMove {
    /// Operation to be performed on the allocation by vmaEndDefragmentationPass(). Default value is
    /// #VMA_DEFRAGMENTATION_MOVE_OPERATION_COPY. You can modify it.
    pub operation: VmaDefragmentationMoveOperation,
    /// Allocation that should be moved.
    pub srcAllocation: VmaAllocation,
    /// \brief Temporary allocation pointing to destination memory that will replace
    /// `srcAllocation`.
    ///
    ///\warning Do not store this allocation in your data structures! It exists only temporarily,
    /// for the duration of the defragmentation pass,
    ///to be used for binding new buffer/image to the destination memory using e.g.
    /// vmaBindBufferMemory().
    ///vmaEndDefragmentationPass() will destroy it and make `srcAllocation` point to this memory.
    pub dstTmpAllocation: VmaAllocation,
}
/// \brief Parameters for incremental defragmentation steps.
///
///To be used with function vmaBeginDefragmentationPass().
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VmaDefragmentationPassMoveInfo {
    /// Number of elements in the `pMoves` array.
    pub moveCount: u32,
    /// \brief Array of moves to be performed by the user in the current defragmentation pass.
    ///
    ///Pointer to an array of `moveCount` elements, owned by VMA, created in
    /// vmaBeginDefragmentationPass(), destroyed in vmaEndDefragmentationPass().
    ///
    ///For each element, you should:
    ///
    ///1. Create a new buffer/image in the place pointed by VmaDefragmentationMove::dstMemory +
    /// VmaDefragmentationMove::dstOffset.
    ///2. Copy data from the VmaDefragmentationMove::srcAllocation e.g. using `vkCmdCopyBuffer`,
    /// `vkCmdCopyImage`.
    ///3. Make sure these commands finished executing on the GPU.
    ///4. Destroy the old buffer/image.
    ///
    ///Only then you can finish defragmentation pass by calling vmaEndDefragmentationPass().
    ///After this call, the allocation will point to the new place in memory.
    ///
    ///Alternatively, if you cannot move specific allocation, you can set
    /// VmaDefragmentationMove::operation to #VMA_DEFRAGMENTATION_MOVE_OPERATION_IGNORE.
    ///
    ///Alternatively, if you decide you want to completely remove the allocation:
    ///
    ///1. Destroy its buffer/image.
    ///2. Set VmaDefragmentationMove::operation to #VMA_DEFRAGMENTATION_MOVE_OPERATION_DESTROY.
    ///
    ///Then, after vmaEndDefragmentationPass() the allocation will be freed.
    pub pMoves: *mut VmaDefragmentationMove,
}
/// Statistics returned for defragmentation process in function vmaEndDefragmentation().
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VmaDefragmentationStats {
    /// Total number of bytes that have been copied while moving allocations to different places.
    pub bytesMoved: DeviceSize,
    /// Total number of bytes that have been released to the system by freeing empty
    /// `VkDeviceMemory` objects.
    pub bytesFreed: DeviceSize,
    /// Number of allocations that have been moved to different places.
    pub allocationsMoved: u32,
    /// Number of empty `VkDeviceMemory` objects that have been released to the system.
    pub deviceMemoryBlocksFreed: u32,
}
/// Parameters of created #VmaVirtualBlock object to be passed to vmaCreateVirtualBlock().
#[repr(C)]
pub struct VmaVirtualBlockCreateInfo {
    /// \brief Total size of the virtual block.
    ///
    ///Sizes can be expressed in bytes or any units you want as long as you are consistent in using
    /// them.
    ///For example, if you allocate from some array of structures, 1 can mean single instance of
    /// entire structure.
    pub size: DeviceSize,
    /// \brief Use combination of #VmaVirtualBlockCreateFlagBits.
    pub flags: VmaVirtualBlockCreateFlags,
    /// \brief Custom CPU memory allocation callbacks. Optional.
    ///
    ///Optional, can be null. When specified, they will be used for all CPU-side memory
    /// allocations.
    pub pAllocationCallbacks: *const AllocationCallbacks,
}
/// Parameters of created virtual allocation to be passed to vmaVirtualAllocate().
#[repr(C)]
pub struct VmaVirtualAllocationCreateInfo {
    /// \brief Size of the allocation.
    ///
    ///Cannot be zero.
    pub size: DeviceSize,
    /// \brief Required alignment of the allocation. Optional.
    ///
    ///Must be power of two. Special value 0 has the same meaning as 1 - means no special alignment
    /// is required, so allocation can start at any offset.
    pub alignment: DeviceSize,
    /// \brief Use combination of #VmaVirtualAllocationCreateFlagBits.
    pub flags: VmaVirtualAllocationCreateFlags,
    /// \brief Custom pointer to be associated with the allocation. Optional.
    ///
    ///It can be any value and can be used for user-defined purposes. It can be fetched or changed
    /// later.
    pub pUserData: *mut ::std::os::raw::c_void,
}
/// Parameters of an existing virtual allocation, returned by vmaGetVirtualAllocationInfo().
#[repr(C)]
pub struct VmaVirtualAllocationInfo {
    /// \brief Offset of the allocation.
    ///
    ///Offset at which the allocation was made.
    pub offset: DeviceSize,
    /// \brief Size of the allocation.
    ///
    ///Same value as passed in VmaVirtualAllocationCreateInfo::size.
    pub size: DeviceSize,
    /// \brief Custom pointer associated with the allocation.
    ///
    ///Same value as passed in VmaVirtualAllocationCreateInfo::pUserData or to
    /// vmaSetVirtualAllocationUserData().
    pub pUserData: *mut ::std::os::raw::c_void,
}
extern "C" {
    /// Creates #VmaAllocator object.
    pub fn vmaCreateAllocator(pCreateInfo: *const VmaAllocatorCreateInfo, pAllocator: *mut VmaAllocator) -> Result;
}
extern "C" {
    /// Destroys allocator object.
    pub fn vmaDestroyAllocator(allocator: VmaAllocator);
}
extern "C" {
    /// \brief Returns information about existing #VmaAllocator object - handle to Vulkan device
    /// etc.
    ///
    ///It might be useful if you want to keep just the #VmaAllocator handle and fetch other
    /// required handles to
    ///`VkPhysicalDevice`, `VkDevice` etc. every time using this function.
    pub fn vmaGetAllocatorInfo(allocator: VmaAllocator, pAllocatorInfo: *mut VmaAllocatorInfo);
}
extern "C" {
    ///PhysicalDeviceProperties are fetched from physicalDevice by the allocator.
    ///You can access it here, without fetching it again on your own.
    pub fn vmaGetPhysicalDeviceProperties(
        allocator: VmaAllocator,
        ppPhysicalDeviceProperties: *mut *const PhysicalDeviceProperties,
    );
}
extern "C" {
    ///PhysicalDeviceMemoryProperties are fetched from physicalDevice by the allocator.
    ///You can access it here, without fetching it again on your own.
    pub fn vmaGetMemoryProperties(
        allocator: VmaAllocator,
        ppPhysicalDeviceMemoryProperties: *mut *const PhysicalDeviceMemoryProperties,
    );
}
extern "C" {
    ///\brief Given Memory Type Index, returns Property Flags of this memory type.
    ///
    ///This is just a convenience function. Same information can be obtained using
    ///vmaGetMemoryProperties().
    pub fn vmaGetMemoryTypeProperties(allocator: VmaAllocator, memoryTypeIndex: u32, pFlags: *mut MemoryPropertyFlags);
}
extern "C" {
    /// \brief Sets index of the current frame.
    pub fn vmaSetCurrentFrameIndex(allocator: VmaAllocator, frameIndex: u32);
}
extern "C" {
    /// \brief Retrieves statistics from current state of the Allocator.
    ///
    ///This function is called "calculate" not "get" because it has to traverse all
    ///internal data structures, so it may be quite slow. Use it for debugging purposes.
    ///For faster but more brief statistics suitable to be called every frame or every allocation,
    ///use vmaGetHeapBudgets().
    ///
    ///Note that when using allocator from multiple threads, returned information may immediately
    ///become outdated.
    pub fn vmaCalculateStatistics(allocator: VmaAllocator, pStats: *mut VmaTotalStatistics);
}
extern "C" {
    /// \brief Retrieves information about current memory usage and budget for all memory heaps.
    ///
    ///\param allocator
    ///\param[out] pBudgets Must point to array with number of elements at least equal to number of
    /// memory heaps in physical device used.
    ///
    ///This function is called "get" not "calculate" because it is very fast, suitable to be called
    ///every frame or every allocation. For more detailed statistics use vmaCalculateStatistics().
    ///
    ///Note that when using allocator from multiple threads, returned information may immediately
    ///become outdated.
    pub fn vmaGetHeapBudgets(allocator: VmaAllocator, pBudgets: *mut VmaBudget);
}
extern "C" {
    ///\brief Helps to find memoryTypeIndex, given memoryTypeBits and VmaAllocationCreateInfo.
    ///
    ///This algorithm tries to find a memory type that:
    ///
    /// - Is allowed by memoryTypeBits.
    /// - Contains all the flags from pAllocationCreateInfo->requiredFlags.
    /// - Matches intended usage.
    /// - Has as many flags from pAllocationCreateInfo->preferredFlags as possible.
    ///
    ///\return Returns VK_ERROR_FEATURE_NOT_PRESENT if not found. Receiving such result
    ///from this function or any other allocating function probably means that your
    ///device doesn't support any memory type with requested features for the specific
    ///type of resource you want to use it for. Please check parameters of your
    ///resource, like image layout (OPTIMAL versus LINEAR) or mip level count.
    pub fn vmaFindMemoryTypeIndex(
        allocator: VmaAllocator,
        memoryTypeBits: u32,
        pAllocationCreateInfo: *const VmaAllocationCreateInfo,
        pMemoryTypeIndex: *mut u32,
    ) -> Result;
}
extern "C" {
    ///\brief Helps to find memoryTypeIndex, given VkBufferCreateInfo and VmaAllocationCreateInfo.
    ///
    ///It can be useful e.g. to determine value to be used as VmaPoolCreateInfo::memoryTypeIndex.
    ///It internally creates a temporary, dummy buffer that never has memory bound.
    pub fn vmaFindMemoryTypeIndexForBufferInfo(
        allocator: VmaAllocator,
        pBufferCreateInfo: *const BufferCreateInfo,
        pAllocationCreateInfo: *const VmaAllocationCreateInfo,
        pMemoryTypeIndex: *mut u32,
    ) -> Result;
}
extern "C" {
    ///\brief Helps to find memoryTypeIndex, given VkImageCreateInfo and VmaAllocationCreateInfo.
    ///
    ///It can be useful e.g. to determine value to be used as VmaPoolCreateInfo::memoryTypeIndex.
    ///It internally creates a temporary, dummy image that never has memory bound.
    pub fn vmaFindMemoryTypeIndexForImageInfo(
        allocator: VmaAllocator,
        pImageCreateInfo: *const ImageCreateInfo,
        pAllocationCreateInfo: *const VmaAllocationCreateInfo,
        pMemoryTypeIndex: *mut u32,
    ) -> Result;
}
extern "C" {
    /// \brief Allocates Vulkan device memory and creates #VmaPool object.
    ///
    ///\param allocator Allocator object.
    ///\param pCreateInfo Parameters of pool to create.
    ///\param[out] pPool Handle to created pool.
    pub fn vmaCreatePool(allocator: VmaAllocator, pCreateInfo: *const VmaPoolCreateInfo, pPool: *mut VmaPool)
        -> Result;
}
extern "C" {
    /// \brief Destroys #VmaPool object and frees Vulkan device memory.
    pub fn vmaDestroyPool(allocator: VmaAllocator, pool: VmaPool);
}
extern "C" {
    /// \brief Retrieves statistics of existing #VmaPool object.
    ///
    ///\param allocator Allocator object.
    ///\param pool Pool object.
    ///\param[out] pPoolStats Statistics of specified pool.
    pub fn vmaGetPoolStatistics(allocator: VmaAllocator, pool: VmaPool, pPoolStats: *mut VmaStatistics);
}
extern "C" {
    /// \brief Retrieves detailed statistics of existing #VmaPool object.
    ///
    ///\param allocator Allocator object.
    ///\param pool Pool object.
    ///\param[out] pPoolStats Statistics of specified pool.
    pub fn vmaCalculatePoolStatistics(allocator: VmaAllocator, pool: VmaPool, pPoolStats: *mut VmaDetailedStatistics);
}
extern "C" {
    /// \brief Checks magic number in margins around all allocations in given memory pool in search
    /// for corruptions.
    ///
    ///Corruption detection is enabled only when `VMA_DEBUG_DETECT_CORRUPTION` macro is defined to
    /// nonzero,
    ///`VMA_DEBUG_MARGIN` is defined to nonzero and the pool is created in memory type that is
    ///`HOST_VISIBLE` and `HOST_COHERENT`. For more information, see [Corruption detection](@ref
    /// debugging_memory_usage_corruption_detection).
    ///
    ///Possible return values:
    ///
    /// - `VK_ERROR_FEATURE_NOT_PRESENT` - corruption detection is not enabled for specified pool.
    /// - `VK_SUCCESS` - corruption detection has been performed and succeeded.
    /// - `VK_ERROR_UNKNOWN` - corruption detection has been performed and found memory corruptions
    ///   around one of the allocations.
    ///`VMA_ASSERT` is also fired in that case.
    /// - Other value: Error returned by Vulkan, e.g. memory mapping failure.
    pub fn vmaCheckPoolCorruption(allocator: VmaAllocator, pool: VmaPool) -> Result;
}
extern "C" {
    /// \brief Retrieves name of a custom pool.
    ///
    ///After the call `ppName` is either null or points to an internally-owned null-terminated
    /// string
    ///containing name of the pool that was previously set. The pointer becomes invalid when the
    /// pool is
    ///destroyed or its name is changed using vmaSetPoolName().
    pub fn vmaGetPoolName(allocator: VmaAllocator, pool: VmaPool, ppName: *mut *const ::std::os::raw::c_char);
}
extern "C" {
    /// \brief Sets name of a custom pool.
    ///
    ///`pName` can be either null or pointer to a null-terminated string with new name for the
    /// pool.
    ///Function makes internal copy of the string, so it can be changed or freed immediately after
    /// this call.
    pub fn vmaSetPoolName(allocator: VmaAllocator, pool: VmaPool, pName: *const ::std::os::raw::c_char);
}
extern "C" {
    /// \brief General purpose memory allocation.
    ///
    ///\param allocator
    ///\param pVkMemoryRequirements
    ///\param pCreateInfo
    ///\param[out] pAllocation Handle to allocated memory.
    ///\param[out] pAllocationInfo Optional. Information about allocated memory. It can be later
    /// fetched using function vmaGetAllocationInfo().
    ///
    ///You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().
    ///
    ///It is recommended to use vmaAllocateMemoryForBuffer(), vmaAllocateMemoryForImage(),
    ///vmaCreateBuffer(), vmaCreateImage() instead whenever possible.
    pub fn vmaAllocateMemory(
        allocator: VmaAllocator,
        pVkMemoryRequirements: *const MemoryRequirements,
        pCreateInfo: *const VmaAllocationCreateInfo,
        pAllocation: *mut VmaAllocation,
        pAllocationInfo: *mut VmaAllocationInfo,
    ) -> Result;
}
extern "C" {
    /// \brief General purpose memory allocation for multiple allocation objects at once.
    ///
    ///\param allocator Allocator object.
    ///\param pVkMemoryRequirements Memory requirements for each allocation.
    ///\param pCreateInfo Creation parameters for each allocation.
    ///\param allocationCount Number of allocations to make.
    ///\param[out] pAllocations Pointer to array that will be filled with handles to created
    /// allocations.
    ///\param[out] pAllocationInfo Optional. Pointer to array that will be filled with parameters
    /// of created allocations.
    ///
    ///You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().
    ///
    ///Word "pages" is just a suggestion to use this function to allocate pieces of memory needed
    /// for sparse binding.
    ///It is just a general purpose allocation function able to make multiple allocations at once.
    ///It may be internally optimized to be more efficient than calling vmaAllocateMemory()
    /// `allocationCount` times.
    ///
    ///All allocations are made using same parameters. All of them are created out of the same
    /// memory pool and type.
    ///If any allocation fails, all allocations already made within this function call are also
    /// freed, so that when
    ///returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with
    /// `VK_NULL_HANDLE`.
    pub fn vmaAllocateMemoryPages(
        allocator: VmaAllocator,
        pVkMemoryRequirements: *const MemoryRequirements,
        pCreateInfo: *const VmaAllocationCreateInfo,
        allocationCount: usize,
        pAllocations: *mut VmaAllocation,
        pAllocationInfo: *mut VmaAllocationInfo,
    ) -> Result;
}
extern "C" {
    /// \brief Allocates memory suitable for given `VkBuffer`.
    ///
    ///\param allocator
    ///\param buffer
    ///\param pCreateInfo
    ///\param[out] pAllocation Handle to allocated memory.
    ///\param[out] pAllocationInfo Optional. Information about allocated memory. It can be later
    /// fetched using function vmaGetAllocationInfo().
    ///
    ///It only creates #VmaAllocation. To bind the memory to the buffer, use vmaBindBufferMemory().
    ///
    ///This is a special-purpose function. In most cases you should use vmaCreateBuffer().
    ///
    ///You must free the allocation using vmaFreeMemory() when no longer needed.
    pub fn vmaAllocateMemoryForBuffer(
        allocator: VmaAllocator,
        buffer: Buffer,
        pCreateInfo: *const VmaAllocationCreateInfo,
        pAllocation: *mut VmaAllocation,
        pAllocationInfo: *mut VmaAllocationInfo,
    ) -> Result;
}
extern "C" {
    /// \brief Allocates memory suitable for given `VkImage`.
    ///
    ///\param allocator
    ///\param image
    ///\param pCreateInfo
    ///\param[out] pAllocation Handle to allocated memory.
    ///\param[out] pAllocationInfo Optional. Information about allocated memory. It can be later
    /// fetched using function vmaGetAllocationInfo().
    ///
    ///It only creates #VmaAllocation. To bind the memory to the buffer, use vmaBindImageMemory().
    ///
    ///This is a special-purpose function. In most cases you should use vmaCreateImage().
    ///
    ///You must free the allocation using vmaFreeMemory() when no longer needed.
    pub fn vmaAllocateMemoryForImage(
        allocator: VmaAllocator,
        image: Image,
        pCreateInfo: *const VmaAllocationCreateInfo,
        pAllocation: *mut VmaAllocation,
        pAllocationInfo: *mut VmaAllocationInfo,
    ) -> Result;
}
extern "C" {
    /// \brief Frees memory previously allocated using vmaAllocateMemory(),
    /// vmaAllocateMemoryForBuffer(), or vmaAllocateMemoryForImage().
    ///
    ///Passing `VK_NULL_HANDLE` as `allocation` is valid. Such function call is just skipped.
    pub fn vmaFreeMemory(allocator: VmaAllocator, allocation: VmaAllocation);
}
extern "C" {
    /// \brief Frees memory and destroys multiple allocations.
    ///
    ///Word "pages" is just a suggestion to use this function to free pieces of memory used for
    /// sparse binding.
    ///It is just a general purpose function to free memory and destroy allocations made using e.g.
    /// vmaAllocateMemory(),
    ///vmaAllocateMemoryPages() and other functions.
    ///It may be internally optimized to be more efficient than calling vmaFreeMemory()
    /// `allocationCount` times.
    ///
    ///Allocations in `pAllocations` array can come from any memory pools and types.
    ///Passing `VK_NULL_HANDLE` as elements of `pAllocations` array is valid. Such entries are just
    /// skipped.
    pub fn vmaFreeMemoryPages(allocator: VmaAllocator, allocationCount: usize, pAllocations: *mut VmaAllocation);
}
extern "C" {
    /// \brief Returns current information about specified allocation.
    ///
    ///Current paramteres of given allocation are returned in `pAllocationInfo`.
    ///
    ///Although this function doesn't lock any mutex, so it should be quite efficient,
    ///you should avoid calling it too often.
    ///You can retrieve same VmaAllocationInfo structure while creating your resource, from
    /// function
    ///vmaCreateBuffer(), vmaCreateImage(). You can remember it if you are sure parameters don't
    /// change
    ///(e.g. due to defragmentation).
    pub fn vmaGetAllocationInfo(
        allocator: VmaAllocator,
        allocation: VmaAllocation,
        pAllocationInfo: *mut VmaAllocationInfo,
    );
}
extern "C" {
    /// \brief Sets pUserData in given allocation to new value.
    ///
    ///The value of pointer `pUserData` is copied to allocation's `pUserData`.
    ///It is opaque, so you can use it however you want - e.g.
    ///as a pointer, ordinal number or some handle to you own data.
    pub fn vmaSetAllocationUserData(
        allocator: VmaAllocator,
        allocation: VmaAllocation,
        pUserData: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    /// \brief Sets pName in given allocation to new value.
    ///
    ///`pName` must be either null, or pointer to a null-terminated string. The function
    ///makes local copy of the string and sets it as allocation's `pName`. String
    ///passed as pName doesn't need to be valid for whole lifetime of the allocation -
    ///you can free it after this call. String previously pointed by allocation's
    ///`pName` is freed from memory.
    pub fn vmaSetAllocationName(
        allocator: VmaAllocator,
        allocation: VmaAllocation,
        pName: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    ///\brief Given an allocation, returns Property Flags of its memory type.
    ///
    ///This is just a convenience function. Same information can be obtained using
    ///vmaGetAllocationInfo() + vmaGetMemoryProperties().
    pub fn vmaGetAllocationMemoryProperties(
        allocator: VmaAllocator,
        allocation: VmaAllocation,
        pFlags: *mut MemoryPropertyFlags,
    );
}
extern "C" {
    /// \brief Maps memory represented by given allocation and returns pointer to it.
    ///
    ///Maps memory represented by given allocation to make it accessible to CPU code.
    ///When succeeded, `*ppData` contains pointer to first byte of this memory.
    ///
    ///\warning
    ///If the allocation is part of a bigger `VkDeviceMemory` block, returned pointer is
    ///correctly offsetted to the beginning of region assigned to this particular allocation.
    ///Unlike the result of `vkMapMemory`, it points to the allocation, not to the beginning of the
    /// whole block.
    ///You should not add VmaAllocationInfo::offset to it!
    ///
    ///Mapping is internally reference-counted and synchronized, so despite raw Vulkan
    ///function `vkMapMemory()` cannot be used to map same block of `VkDeviceMemory`
    ///multiple times simultaneously, it is safe to call this function on allocations
    ///assigned to the same memory block. Actual Vulkan memory will be mapped on first
    ///mapping and unmapped on last unmapping.
    ///
    ///If the function succeeded, you must call vmaUnmapMemory() to unmap the
    ///allocation when mapping is no longer needed or before freeing the allocation, at
    ///the latest.
    ///
    ///It also safe to call this function multiple times on the same allocation. You
    ///must call vmaUnmapMemory() same number of times as you called vmaMapMemory().
    ///
    ///It is also safe to call this function on allocation created with
    ///#VMA_ALLOCATION_CREATE_MAPPED_BIT flag. Its memory stays mapped all the time.
    ///You must still call vmaUnmapMemory() same number of times as you called
    ///vmaMapMemory(). You must not call vmaUnmapMemory() additional time to free the
    ///"0-th" mapping made automatically due to #VMA_ALLOCATION_CREATE_MAPPED_BIT flag.
    ///
    ///This function fails when used on allocation made in memory type that is not
    ///`HOST_VISIBLE`.
    ///
    ///This function doesn't automatically flush or invalidate caches.
    ///If the allocation is made from a memory types that is not `HOST_COHERENT`,
    ///you also need to use vmaInvalidateAllocation() / vmaFlushAllocation(), as required by Vulkan
    /// specification.
    pub fn vmaMapMemory(
        allocator: VmaAllocator,
        allocation: VmaAllocation,
        ppData: *mut *mut ::std::os::raw::c_void,
    ) -> Result;
}
extern "C" {
    /// \brief Unmaps memory represented by given allocation, mapped previously using
    /// vmaMapMemory().
    ///
    ///For details, see description of vmaMapMemory().
    ///
    ///This function doesn't automatically flush or invalidate caches.
    ///If the allocation is made from a memory types that is not `HOST_COHERENT`,
    ///you also need to use vmaInvalidateAllocation() / vmaFlushAllocation(), as required by Vulkan
    /// specification.
    pub fn vmaUnmapMemory(allocator: VmaAllocator, allocation: VmaAllocation);
}
extern "C" {
    /// \brief Flushes memory of given allocation.
    ///
    ///Calls `vkFlushMappedMemoryRanges()` for memory associated with given range of given
    /// allocation.
    ///It needs to be called after writing to a mapped memory for memory types that are not
    /// `HOST_COHERENT`.
    ///Unmap operation doesn't do that automatically.
    ///
    /// - `offset` must be relative to the beginning of allocation.
    /// - `size` can be `VK_WHOLE_SIZE`. It means all memory from `offset` the the end of given
    ///   allocation.
    /// - `offset` and `size` don't have to be aligned.
    ///They are internally rounded down/up to multiply of `nonCoherentAtomSize`.
    /// - If `size` is 0, this call is ignored.
    /// - If memory type that the `allocation` belongs to is not `HOST_VISIBLE` or it is
    ///   `HOST_COHERENT`,
    ///this call is ignored.
    ///
    ///Warning! `offset` and `size` are relative to the contents of given `allocation`.
    ///If you mean whole allocation, you can pass 0 and `VK_WHOLE_SIZE`, respectively.
    ///Do not pass allocation's offset as `offset`!!!
    ///
    ///This function returns the `VkResult` from `vkFlushMappedMemoryRanges` if it is
    ///called, otherwise `VK_SUCCESS`.
    pub fn vmaFlushAllocation(
        allocator: VmaAllocator,
        allocation: VmaAllocation,
        offset: DeviceSize,
        size: DeviceSize,
    ) -> Result;
}
extern "C" {
    /// \brief Invalidates memory of given allocation.
    ///
    ///Calls `vkInvalidateMappedMemoryRanges()` for memory associated with given range of given
    /// allocation.
    ///It needs to be called before reading from a mapped memory for memory types that are not
    /// `HOST_COHERENT`.
    ///Map operation doesn't do that automatically.
    ///
    /// - `offset` must be relative to the beginning of allocation.
    /// - `size` can be `VK_WHOLE_SIZE`. It means all memory from `offset` the the end of given
    ///   allocation.
    /// - `offset` and `size` don't have to be aligned.
    ///They are internally rounded down/up to multiply of `nonCoherentAtomSize`.
    /// - If `size` is 0, this call is ignored.
    /// - If memory type that the `allocation` belongs to is not `HOST_VISIBLE` or it is
    ///   `HOST_COHERENT`,
    ///this call is ignored.
    ///
    ///Warning! `offset` and `size` are relative to the contents of given `allocation`.
    ///If you mean whole allocation, you can pass 0 and `VK_WHOLE_SIZE`, respectively.
    ///Do not pass allocation's offset as `offset`!!!
    ///
    ///This function returns the `VkResult` from `vkInvalidateMappedMemoryRanges` if
    ///it is called, otherwise `VK_SUCCESS`.
    pub fn vmaInvalidateAllocation(
        allocator: VmaAllocator,
        allocation: VmaAllocation,
        offset: DeviceSize,
        size: DeviceSize,
    ) -> Result;
}
extern "C" {
    /// \brief Flushes memory of given set of allocations.
    ///
    ///Calls `vkFlushMappedMemoryRanges()` for memory associated with given ranges of given
    /// allocations.
    ///For more information, see documentation of vmaFlushAllocation().
    ///
    ///\param allocator
    ///\param allocationCount
    ///\param allocations
    ///\param offsets If not null, it must point to an array of offsets of regions to flush,
    /// relative to the beginning of respective allocations. Null means all ofsets are zero.
    ///\param sizes If not null, it must point to an array of sizes of regions to flush in
    /// respective allocations. Null means `VK_WHOLE_SIZE` for all allocations.
    ///
    ///This function returns the `VkResult` from `vkFlushMappedMemoryRanges` if it is
    ///called, otherwise `VK_SUCCESS`.
    pub fn vmaFlushAllocations(
        allocator: VmaAllocator,
        allocationCount: u32,
        allocations: *mut VmaAllocation,
        offsets: *const DeviceSize,
        sizes: *const DeviceSize,
    ) -> Result;
}
extern "C" {
    /// \brief Invalidates memory of given set of allocations.
    ///
    ///Calls `vkInvalidateMappedMemoryRanges()` for memory associated with given ranges of given
    /// allocations.
    ///For more information, see documentation of vmaInvalidateAllocation().
    ///
    ///\param allocator
    ///\param allocationCount
    ///\param allocations
    ///\param offsets If not null, it must point to an array of offsets of regions to flush,
    /// relative to the beginning of respective allocations. Null means all ofsets are zero.
    ///\param sizes If not null, it must point to an array of sizes of regions to flush in
    /// respective allocations. Null means `VK_WHOLE_SIZE` for all allocations.
    ///
    ///This function returns the `VkResult` from `vkInvalidateMappedMemoryRanges` if it is
    ///called, otherwise `VK_SUCCESS`.
    pub fn vmaInvalidateAllocations(
        allocator: VmaAllocator,
        allocationCount: u32,
        allocations: *mut VmaAllocation,
        offsets: *const DeviceSize,
        sizes: *const DeviceSize,
    ) -> Result;
}
extern "C" {
    /// \brief Checks magic number in margins around all allocations in given memory types (in both
    /// default and custom pools) in search for corruptions.
    ///
    ///\param allocator
    ///\param memoryTypeBits Bit mask, where each bit set means that a memory type with that index
    /// should be checked.
    ///
    ///Corruption detection is enabled only when `VMA_DEBUG_DETECT_CORRUPTION` macro is defined to
    /// nonzero,
    ///`VMA_DEBUG_MARGIN` is defined to nonzero and only for memory types that are
    ///`HOST_VISIBLE` and `HOST_COHERENT`. For more information, see [Corruption detection](@ref
    /// debugging_memory_usage_corruption_detection).
    ///
    ///Possible return values:
    ///
    /// - `VK_ERROR_FEATURE_NOT_PRESENT` - corruption detection is not enabled for any of specified
    ///   memory types.
    /// - `VK_SUCCESS` - corruption detection has been performed and succeeded.
    /// - `VK_ERROR_UNKNOWN` - corruption detection has been performed and found memory corruptions
    ///   around one of the allocations.
    ///`VMA_ASSERT` is also fired in that case.
    /// - Other value: Error returned by Vulkan, e.g. memory mapping failure.
    pub fn vmaCheckCorruption(allocator: VmaAllocator, memoryTypeBits: u32) -> Result;
}
extern "C" {
    /// \brief Begins defragmentation process.
    ///
    ///\param allocator Allocator object.
    ///\param pInfo Structure filled with parameters of defragmentation.
    ///\param[out] pContext Context object that must be passed to vmaEndDefragmentation() to finish
    /// defragmentation.
    ///\returns
    /// - `VK_SUCCESS` if defragmentation can begin.
    /// - `VK_ERROR_FEATURE_NOT_PRESENT` if defragmentation is not supported.
    ///
    ///For more information about defragmentation, see documentation chapter:
    ///[Defragmentation](@ref defragmentation).
    pub fn vmaBeginDefragmentation(
        allocator: VmaAllocator,
        pInfo: *const VmaDefragmentationInfo,
        pContext: *mut VmaDefragmentationContext,
    ) -> Result;
}
extern "C" {
    /// \brief Ends defragmentation process.
    ///
    ///\param allocator Allocator object.
    ///\param context Context object that has been created by vmaBeginDefragmentation().
    ///\param[out] pStats Optional stats for the defragmentation. Can be null.
    ///
    ///Use this function to finish defragmentation started by vmaBeginDefragmentation().
    pub fn vmaEndDefragmentation(
        allocator: VmaAllocator,
        context: VmaDefragmentationContext,
        pStats: *mut VmaDefragmentationStats,
    );
}
extern "C" {
    /// \brief Starts single defragmentation pass.
    ///
    ///\param allocator Allocator object.
    ///\param context Context object that has been created by vmaBeginDefragmentation().
    ///\param[out] pPassInfo Computed informations for current pass.
    ///\returns
    /// - `VK_SUCCESS` if no more moves are possible. Then you can omit call to
    ///   vmaEndDefragmentationPass() and simply end whole defragmentation.
    /// - `VK_INCOMPLETE` if there are pending moves returned in `pPassInfo`. You need to perform
    ///   them, call vmaEndDefragmentationPass(),
    ///and then preferably try another pass with vmaBeginDefragmentationPass().
    pub fn vmaBeginDefragmentationPass(
        allocator: VmaAllocator,
        context: VmaDefragmentationContext,
        pPassInfo: *mut VmaDefragmentationPassMoveInfo,
    ) -> Result;
}
extern "C" {
    /// \brief Ends single defragmentation pass.
    ///
    ///\param allocator Allocator object.
    ///\param context Context object that has been created by vmaBeginDefragmentation().
    ///\param pPassInfo Computed informations for current pass filled by
    /// vmaBeginDefragmentationPass() and possibly modified by you.
    ///
    ///Returns `VK_SUCCESS` if no more moves are possible or `VK_INCOMPLETE` if more
    /// defragmentations are possible.
    ///
    ///Ends incremental defragmentation pass and commits all defragmentation moves from
    /// `pPassInfo`.
    ///After this call:
    ///
    /// - Allocations at `pPassInfo[i].srcAllocation` that had `pPassInfo[i].operation ==`
    ///   #VMA_DEFRAGMENTATION_MOVE_OPERATION_COPY
    ///(which is the default) will be pointing to the new destination place.
    /// - Allocation at `pPassInfo[i].srcAllocation` that had `pPassInfo[i].operation ==`
    ///   #VMA_DEFRAGMENTATION_MOVE_OPERATION_DESTROY
    ///will be freed.
    ///
    ///If no more moves are possible you can end whole defragmentation.
    pub fn vmaEndDefragmentationPass(
        allocator: VmaAllocator,
        context: VmaDefragmentationContext,
        pPassInfo: *mut VmaDefragmentationPassMoveInfo,
    ) -> Result;
}
extern "C" {
    /// \brief Binds buffer to allocation.
    ///
    ///Binds specified buffer to region of memory represented by specified allocation.
    ///Gets `VkDeviceMemory` handle and offset from the allocation.
    ///If you want to create a buffer, allocate memory for it and bind them together separately,
    ///you should use this function for binding instead of standard `vkBindBufferMemory()`,
    ///because it ensures proper synchronization so that when a `VkDeviceMemory` object is used by
    /// multiple
    ///allocations, calls to `vkBind*Memory()` or `vkMapMemory()` won't happen from multiple
    /// threads simultaneously
    ///(which is illegal in Vulkan).
    ///
    ///It is recommended to use function vmaCreateBuffer() instead of this one.
    pub fn vmaBindBufferMemory(allocator: VmaAllocator, allocation: VmaAllocation, buffer: Buffer) -> Result;
}
extern "C" {
    /// \brief Binds buffer to allocation with additional parameters.
    ///
    ///\param allocator
    ///\param allocation
    ///\param allocationLocalOffset Additional offset to be added while binding, relative to the
    /// beginning of the `allocation`. Normally it should be 0.
    ///\param buffer
    ///\param pNext A chain of structures to be attached to `VkBindBufferMemoryInfoKHR` structure
    /// used internally. Normally it should be null.
    ///
    ///This function is similar to vmaBindBufferMemory(), but it provides additional parameters.
    ///
    ///If `pNext` is not null, #VmaAllocator object must have been created with
    /// #VMA_ALLOCATOR_CREATE_KHR_BIND_MEMORY2_BIT flag
    ///or with VmaAllocatorCreateInfo::vulkanApiVersion `>= VK_API_VERSION_1_1`. Otherwise the call
    /// fails.
    pub fn vmaBindBufferMemory2(
        allocator: VmaAllocator,
        allocation: VmaAllocation,
        allocationLocalOffset: DeviceSize,
        buffer: Buffer,
        pNext: *const ::std::os::raw::c_void,
    ) -> Result;
}
extern "C" {
    /// \brief Binds image to allocation.
    ///
    ///Binds specified image to region of memory represented by specified allocation.
    ///Gets `VkDeviceMemory` handle and offset from the allocation.
    ///If you want to create an image, allocate memory for it and bind them together separately,
    ///you should use this function for binding instead of standard `vkBindImageMemory()`,
    ///because it ensures proper synchronization so that when a `VkDeviceMemory` object is used by
    /// multiple
    ///allocations, calls to `vkBind*Memory()` or `vkMapMemory()` won't happen from multiple
    /// threads simultaneously
    ///(which is illegal in Vulkan).
    ///
    ///It is recommended to use function vmaCreateImage() instead of this one.
    pub fn vmaBindImageMemory(allocator: VmaAllocator, allocation: VmaAllocation, image: Image) -> Result;
}
extern "C" {
    /// \brief Binds image to allocation with additional parameters.
    ///
    ///\param allocator
    ///\param allocation
    ///\param allocationLocalOffset Additional offset to be added while binding, relative to the
    /// beginning of the `allocation`. Normally it should be 0.
    ///\param image
    ///\param pNext A chain of structures to be attached to `VkBindImageMemoryInfoKHR` structure
    /// used internally. Normally it should be null.
    ///
    ///This function is similar to vmaBindImageMemory(), but it provides additional parameters.
    ///
    ///If `pNext` is not null, #VmaAllocator object must have been created with
    /// #VMA_ALLOCATOR_CREATE_KHR_BIND_MEMORY2_BIT flag
    ///or with VmaAllocatorCreateInfo::vulkanApiVersion `>= VK_API_VERSION_1_1`. Otherwise the call
    /// fails.
    pub fn vmaBindImageMemory2(
        allocator: VmaAllocator,
        allocation: VmaAllocation,
        allocationLocalOffset: DeviceSize,
        image: Image,
        pNext: *const ::std::os::raw::c_void,
    ) -> Result;
}
extern "C" {
    /// \brief Creates a new `VkBuffer`, allocates and binds memory for it.
    ///
    ///\param allocator
    ///\param pBufferCreateInfo
    ///\param pAllocationCreateInfo
    ///\param[out] pBuffer Buffer that was created.
    ///\param[out] pAllocation Allocation that was created.
    ///\param[out] pAllocationInfo Optional. Information about allocated memory. It can be later
    /// fetched using function vmaGetAllocationInfo().
    ///
    ///This function automatically:
    ///
    ///-# Creates buffer.
    ///-# Allocates appropriate memory for it.
    ///-# Binds the buffer with the memory.
    ///
    ///If any of these operations fail, buffer and allocation are not created,
    ///returned value is negative error code, `*pBuffer` and `*pAllocation` are null.
    ///
    ///If the function succeeded, you must destroy both buffer and allocation when you
    ///no longer need them using either convenience function vmaDestroyBuffer() or
    ///separately, using `vkDestroyBuffer()` and vmaFreeMemory().
    ///
    ///If #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,
    ///VK_KHR_dedicated_allocation extension is used internally to query driver whether
    ///it requires or prefers the new buffer to have dedicated allocation. If yes,
    ///and if dedicated allocation is possible
    ///(#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated
    ///allocation for this buffer, just like when using
    ///#VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.
    ///
    ///\note This function creates a new `VkBuffer`. Sub-allocation of parts of one large buffer,
    ///although recommended as a good practice, is out of scope of this library and could be
    /// implemented
    ///by the user as a higher-level logic on top of VMA.
    pub fn vmaCreateBuffer(
        allocator: VmaAllocator,
        pBufferCreateInfo: *const BufferCreateInfo,
        pAllocationCreateInfo: *const VmaAllocationCreateInfo,
        pBuffer: *mut Buffer,
        pAllocation: *mut VmaAllocation,
        pAllocationInfo: *mut VmaAllocationInfo,
    ) -> Result;
}
extern "C" {
    /// \brief Creates a buffer with additional minimum alignment.
    ///
    ///Similar to vmaCreateBuffer() but provides additional parameter `minAlignment` which allows
    /// to specify custom,
    ///minimum alignment to be used when placing the buffer inside a larger memory block, which may
    /// be needed e.g.
    ///for interop with OpenGL.
    pub fn vmaCreateBufferWithAlignment(
        allocator: VmaAllocator,
        pBufferCreateInfo: *const BufferCreateInfo,
        pAllocationCreateInfo: *const VmaAllocationCreateInfo,
        minAlignment: DeviceSize,
        pBuffer: *mut Buffer,
        pAllocation: *mut VmaAllocation,
        pAllocationInfo: *mut VmaAllocationInfo,
    ) -> Result;
}
extern "C" {
    /// \brief Creates a new `VkBuffer`, binds already created memory for it.
    ///
    ///\param allocator
    ///\param allocation Allocation that provides memory to be used for binding new buffer to it.
    ///\param pBufferCreateInfo
    ///\param[out] pBuffer Buffer that was created.
    ///
    ///This function automatically:
    ///
    ///-# Creates buffer.
    ///-# Binds the buffer with the supplied memory.
    ///
    ///If any of these operations fail, buffer is not created,
    ///returned value is negative error code and `*pBuffer` is null.
    ///
    ///If the function succeeded, you must destroy the buffer when you
    ///no longer need it using `vkDestroyBuffer()`. If you want to also destroy the corresponding
    ///allocation you can use convenience function vmaDestroyBuffer().
    pub fn vmaCreateAliasingBuffer(
        allocator: VmaAllocator,
        allocation: VmaAllocation,
        pBufferCreateInfo: *const BufferCreateInfo,
        pBuffer: *mut Buffer,
    ) -> Result;
}
extern "C" {
    /// \brief Destroys Vulkan buffer and frees allocated memory.
    ///
    ///This is just a convenience function equivalent to:
    ///
    ///\code
    ///vkDestroyBuffer(device, buffer, allocationCallbacks);
    ///vmaFreeMemory(allocator, allocation);
    ///\endcode
    ///
    ///It it safe to pass null as buffer and/or allocation.
    pub fn vmaDestroyBuffer(allocator: VmaAllocator, buffer: Buffer, allocation: VmaAllocation);
}
extern "C" {
    /// Function similar to vmaCreateBuffer().
    pub fn vmaCreateImage(
        allocator: VmaAllocator,
        pImageCreateInfo: *const ImageCreateInfo,
        pAllocationCreateInfo: *const VmaAllocationCreateInfo,
        pImage: *mut Image,
        pAllocation: *mut VmaAllocation,
        pAllocationInfo: *mut VmaAllocationInfo,
    ) -> Result;
}
extern "C" {
    /// Function similar to vmaCreateAliasingBuffer().
    pub fn vmaCreateAliasingImage(
        allocator: VmaAllocator,
        allocation: VmaAllocation,
        pImageCreateInfo: *const ImageCreateInfo,
        pImage: *mut Image,
    ) -> Result;
}
extern "C" {
    /// \brief Destroys Vulkan image and frees allocated memory.
    ///
    ///This is just a convenience function equivalent to:
    ///
    ///\code
    ///vkDestroyImage(device, image, allocationCallbacks);
    ///vmaFreeMemory(allocator, allocation);
    ///\endcode
    ///
    ///It it safe to pass null as image and/or allocation.
    pub fn vmaDestroyImage(allocator: VmaAllocator, image: Image, allocation: VmaAllocation);
}
extern "C" {
    /// \brief Creates new #VmaVirtualBlock object.
    ///
    ///\param pCreateInfo Parameters for creation.
    ///\param[out] pVirtualBlock Returned virtual block object or `VMA_NULL` if creation failed.
    pub fn vmaCreateVirtualBlock(
        pCreateInfo: *const VmaVirtualBlockCreateInfo,
        pVirtualBlock: *mut VmaVirtualBlock,
    ) -> Result;
}
extern "C" {
    /// \brief Destroys #VmaVirtualBlock object.
    ///
    ///Please note that you should consciously handle virtual allocations that could remain unfreed
    /// in the block.
    ///You should either free them individually using vmaVirtualFree() or call
    /// vmaClearVirtualBlock()
    ///if you are sure this is what you want. If you do neither, an assert is called.
    ///
    ///If you keep pointers to some additional metadata associated with your virtual allocations in
    /// their `pUserData`,
    ///don't forget to free them.
    pub fn vmaDestroyVirtualBlock(virtualBlock: VmaVirtualBlock);
}
extern "C" {
    /// \brief Returns true of the #VmaVirtualBlock is empty - contains 0 virtual allocations and
    /// has all its space available for new allocations.
    pub fn vmaIsVirtualBlockEmpty(virtualBlock: VmaVirtualBlock) -> Bool32;
}
extern "C" {
    /// \brief Returns information about a specific virtual allocation within a virtual block, like
    /// its size and `pUserData` pointer.
    pub fn vmaGetVirtualAllocationInfo(
        virtualBlock: VmaVirtualBlock,
        allocation: VmaVirtualAllocation,
        pVirtualAllocInfo: *mut VmaVirtualAllocationInfo,
    );
}
extern "C" {
    /// \brief Allocates new virtual allocation inside given #VmaVirtualBlock.
    ///
    ///If the allocation fails due to not enough free space available,
    /// `VK_ERROR_OUT_OF_DEVICE_MEMORY` is returned
    ///(despite the function doesn't ever allocate actual GPU memory).
    ///`pAllocation` is then set to `VK_NULL_HANDLE` and `pOffset`, if not null, it set to
    /// `UINT64_MAX`.
    ///
    ///\param virtualBlock Virtual block
    ///\param pCreateInfo Parameters for the allocation
    ///\param[out] pAllocation Returned handle of the new allocation
    ///\param[out] pOffset Returned offset of the new allocation. Optional, can be null.
    pub fn vmaVirtualAllocate(
        virtualBlock: VmaVirtualBlock,
        pCreateInfo: *const VmaVirtualAllocationCreateInfo,
        pAllocation: *mut VmaVirtualAllocation,
        pOffset: *mut DeviceSize,
    ) -> Result;
}
extern "C" {
    /// \brief Frees virtual allocation inside given #VmaVirtualBlock.
    ///
    ///It is correct to call this function with `allocation == VK_NULL_HANDLE` - it does nothing.
    pub fn vmaVirtualFree(virtualBlock: VmaVirtualBlock, allocation: VmaVirtualAllocation);
}
extern "C" {
    /// \brief Frees all virtual allocations inside given #VmaVirtualBlock.
    ///
    ///You must either call this function or free each virtual allocation individually with
    /// vmaVirtualFree()
    ///before destroying a virtual block. Otherwise, an assert is called.
    ///
    ///If you keep pointer to some additional metadata associated with your virtual allocation in
    /// its `pUserData`,
    ///don't forget to free it as well.
    pub fn vmaClearVirtualBlock(virtualBlock: VmaVirtualBlock);
}
extern "C" {
    /// \brief Changes custom pointer associated with given virtual allocation.
    pub fn vmaSetVirtualAllocationUserData(
        virtualBlock: VmaVirtualBlock,
        allocation: VmaVirtualAllocation,
        pUserData: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    /// \brief Calculates and returns statistics about virtual allocations and memory usage in given
    /// #VmaVirtualBlock.
    ///
    ///This function is fast to call. For more detailed statistics, see
    /// vmaCalculateVirtualBlockStatistics().
    pub fn vmaGetVirtualBlockStatistics(virtualBlock: VmaVirtualBlock, pStats: *mut VmaStatistics);
}
extern "C" {
    /// \brief Calculates and returns detailed statistics about virtual allocations and memory usage
    /// in given #VmaVirtualBlock.
    ///
    ///This function is slow to call. Use for debugging purposes.
    ///For less detailed statistics, see vmaGetVirtualBlockStatistics().
    pub fn vmaCalculateVirtualBlockStatistics(virtualBlock: VmaVirtualBlock, pStats: *mut VmaDetailedStatistics);
}
extern "C" {
    /// \brief Builds and returns a null-terminated string in JSON format with information about
    /// given #VmaVirtualBlock.
    ///\param virtualBlock Virtual block.
    ///\param[out] ppStatsString Returned string.
    ///\param detailedMap Pass `VK_FALSE` to only obtain statistics as returned by
    /// vmaCalculateVirtualBlockStatistics(). Pass `VK_TRUE` to also obtain full list of allocations
    /// and free spaces.
    ///
    ///Returned string must be freed using vmaFreeVirtualBlockStatsString().
    pub fn vmaBuildVirtualBlockStatsString(
        virtualBlock: VmaVirtualBlock,
        ppStatsString: *mut *mut ::std::os::raw::c_char,
        detailedMap: Bool32,
    );
}
extern "C" {
    /// Frees a string returned by vmaBuildVirtualBlockStatsString().
    pub fn vmaFreeVirtualBlockStatsString(virtualBlock: VmaVirtualBlock, pStatsString: *mut ::std::os::raw::c_char);
}
extern "C" {
    /// \brief Builds and returns statistics as a null-terminated string in JSON format.
    ///\param allocator
    ///\param[out] ppStatsString Must be freed using vmaFreeStatsString() function.
    ///\param detailedMap
    pub fn vmaBuildStatsString(
        allocator: VmaAllocator,
        ppStatsString: *mut *mut ::std::os::raw::c_char,
        detailedMap: Bool32,
    );
}
extern "C" {
    pub fn vmaFreeStatsString(allocator: VmaAllocator, pStatsString: *mut ::std::os::raw::c_char);
}
