# ! [doc = include_str ! ("../../../doc/VK_VERSION_1_0.md")]
#[cfg(feature = "VK_ARM_rasterization_order_attachment_access")]
use crate::extensions::arm_rasterization_order_attachment_access::PipelineColorBlendStateCreateFlagBits;
#[cfg(feature = "VK_ARM_rasterization_order_attachment_access")]
use crate::extensions::arm_rasterization_order_attachment_access::PipelineDepthStencilStateCreateFlagBits;
#[cfg(feature = "VK_EXT_pipeline_creation_cache_control")]
use crate::extensions::ext_pipeline_creation_cache_control::PipelineCacheCreateFlagBits;
use crate::vulkan1_1::DeviceQueueCreateFlagBits;
use std::ffi::CStr;
# [doc = include_str ! ("../../../doc/VkBaseOutStructure.md")]
#[doc(alias = "VkBaseOutStructure")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct BaseOutStructure {
    #[doc(alias = "sType")]
    s_type: StructureType,
    #[doc(alias = "pNext")]
    next: *mut BaseOutStructure,
}
# [doc = include_str ! ("../../../doc/VkBaseInStructure.md")]
#[doc(alias = "VkBaseInStructure")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct BaseInStructure {
    #[doc(alias = "sType")]
    s_type: StructureType,
    #[doc(alias = "pNext")]
    next: *const BaseInStructure,
}
# [doc = include_str ! ("../../../doc/VkOffset2D.md")]
#[doc(alias = "VkOffset2D")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct Offset2D {
    # [doc = include_str ! ("../../../doc/VkOffset2D$x.md")]
    x: i32,
    # [doc = include_str ! ("../../../doc/VkOffset2D$y.md")]
    y: i32,
}
# [doc = include_str ! ("../../../doc/VkOffset3D.md")]
#[doc(alias = "VkOffset3D")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct Offset3D {
    # [doc = include_str ! ("../../../doc/VkOffset3D$x.md")]
    x: i32,
    # [doc = include_str ! ("../../../doc/VkOffset3D$y.md")]
    y: i32,
    # [doc = include_str ! ("../../../doc/VkOffset3D$z.md")]
    z: i32,
}
# [doc = include_str ! ("../../../doc/VkExtent2D.md")]
#[doc(alias = "VkExtent2D")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct Extent2D {
    # [doc = include_str ! ("../../../doc/VkExtent2D$width.md")]
    width: u32,
    # [doc = include_str ! ("../../../doc/VkExtent2D$height.md")]
    height: u32,
}
# [doc = include_str ! ("../../../doc/VkExtent3D.md")]
#[doc(alias = "VkExtent3D")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct Extent3D {
    # [doc = include_str ! ("../../../doc/VkExtent3D$width.md")]
    width: u32,
    # [doc = include_str ! ("../../../doc/VkExtent3D$height.md")]
    height: u32,
    # [doc = include_str ! ("../../../doc/VkExtent3D$depth.md")]
    depth: u32,
}
# [doc = include_str ! ("../../../doc/VkViewport.md")]
#[doc(alias = "VkViewport")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct Viewport {
    # [doc = include_str ! ("../../../doc/VkViewport$x.md")]
    x: f32,
    y: f32,
    # [doc = include_str ! ("../../../doc/VkViewport$width.md")]
    width: f32,
    height: f32,
    #[doc(alias = "minDepth")]
    min_depth: f32,
    #[doc(alias = "maxDepth")]
    max_depth: f32,
}
# [doc = include_str ! ("../../../doc/VkRect2D.md")]
#[doc(alias = "VkRect2D")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct Rect2D {
    # [doc = include_str ! ("../../../doc/VkRect2D$offset.md")]
    offset: Offset2D,
    # [doc = include_str ! ("../../../doc/VkRect2D$extent.md")]
    extent: Extent2D,
}
# [doc = include_str ! ("../../../doc/VkClearRect.md")]
#[doc(alias = "VkClearRect")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct ClearRect {
    # [doc = include_str ! ("../../../doc/VkClearRect$rect.md")]
    rect: Rect2D,
    #[doc(alias = "baseArrayLayer")]
    base_array_layer: u32,
    #[doc(alias = "layerCount")]
    layer_count: u32,
}
# [doc = include_str ! ("../../../doc/VkComponentMapping.md")]
#[doc(alias = "VkComponentMapping")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct ComponentMapping {
    # [doc = include_str ! ("../../../doc/VkComponentMapping$r.md")]
    r: ComponentSwizzle,
    # [doc = include_str ! ("../../../doc/VkComponentMapping$g.md")]
    g: ComponentSwizzle,
    # [doc = include_str ! ("../../../doc/VkComponentMapping$b.md")]
    b: ComponentSwizzle,
    # [doc = include_str ! ("../../../doc/VkComponentMapping$a.md")]
    a: ComponentSwizzle,
}
# [doc = include_str ! ("../../../doc/VkPhysicalDeviceProperties.md")]
#[doc(alias = "VkPhysicalDeviceProperties")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PhysicalDeviceProperties {
    #[doc(alias = "apiVersion")]
    api_version: u32,
    #[doc(alias = "driverVersion")]
    driver_version: u32,
    #[doc(alias = "vendorID")]
    vendor_id: u32,
    #[doc(alias = "deviceID")]
    device_id: u32,
    #[doc(alias = "deviceType")]
    device_type: PhysicalDeviceType,
    #[doc(alias = "deviceName")]
    device_name: [std::ffi::c_char; MAX_PHYSICAL_DEVICE_NAME_SIZE as usize],
    #[doc(alias = "pipelineCacheUUID")]
    pipeline_cache_uuid: [u8; UUID_SIZE as usize],
    # [doc = include_str ! ("../../../doc/VkPhysicalDeviceProperties$limits.md")]
    limits: PhysicalDeviceLimits,
    #[doc(alias = "sparseProperties")]
    sparse_properties: PhysicalDeviceSparseProperties,
}
# [doc = include_str ! ("../../../doc/VkExtensionProperties.md")]
#[doc(alias = "VkExtensionProperties")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct ExtensionProperties {
    #[doc(alias = "extensionName")]
    extension_name: [std::ffi::c_char; MAX_EXTENSION_NAME_SIZE as usize],
    #[doc(alias = "specVersion")]
    spec_version: u32,
}
# [doc = include_str ! ("../../../doc/VkLayerProperties.md")]
#[doc(alias = "VkLayerProperties")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct LayerProperties {
    #[doc(alias = "layerName")]
    layer_name: [std::ffi::c_char; MAX_EXTENSION_NAME_SIZE as usize],
    #[doc(alias = "specVersion")]
    spec_version: u32,
    #[doc(alias = "implementationVersion")]
    implementation_version: u32,
    # [doc = include_str ! ("../../../doc/VkLayerProperties$description.md")]
    description: [std::ffi::c_char; MAX_DESCRIPTION_SIZE as usize],
}
# [doc = include_str ! ("../../../doc/VkApplicationInfo.md")]
#[doc(alias = "VkApplicationInfo")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct ApplicationInfo {
    #[doc(alias = "sType")]
    s_type: StructureType,
    #[doc(alias = "pNext")]
    p_next: *const BaseInStructure,
    #[doc(alias = "pApplicationName")]
    application_name: *const CStr,
    #[doc(alias = "applicationVersion")]
    application_version: u32,
    #[doc(alias = "pEngineName")]
    engine_name: *const CStr,
    #[doc(alias = "engineVersion")]
    engine_version: u32,
    #[doc(alias = "apiVersion")]
    api_version: u32,
}
# [doc = include_str ! ("../../../doc/VkAllocationCallbacks.md")]
#[doc(alias = "VkAllocationCallbacks")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct AllocationCallbacks {
    #[doc(alias = "pUserData")]
    user_data: *mut std::ffi::c_void,
    #[doc(alias = "pfnAllocation")]
    pfn_allocation: PFNAllocationFunction,
    #[doc(alias = "pfnReallocation")]
    pfn_reallocation: PFNReallocationFunction,
    #[doc(alias = "pfnFree")]
    pfn_free: PFNFreeFunction,
    #[doc(alias = "pfnInternalAllocation")]
    pfn_internal_allocation: PFNInternalAllocationNotification,
    #[doc(alias = "pfnInternalFree")]
    pfn_internal_free: PFNInternalFreeNotification,
}
# [doc = include_str ! ("../../../doc/VkDeviceQueueCreateInfo.md")]
#[doc(alias = "VkDeviceQueueCreateInfo")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct DeviceQueueCreateInfo {
    #[doc(alias = "sType")]
    s_type: StructureType,
    #[doc(alias = "pNext")]
    p_next: *const BaseInStructure,
    # [doc = include_str ! ("../../../doc/VkDeviceQueueCreateInfo$flags.md")]
    flags: DeviceQueueCreateFlags,
    #[doc(alias = "queueFamilyIndex")]
    queue_family_index: u32,
    #[doc(alias = "queueCount")]
    queue_count: u32,
    #[doc(alias = "pQueuePriorities")]
    queue_priorities: *const f32,
}
# [doc = include_str ! ("../../../doc/VkDeviceCreateInfo.md")]
#[doc(alias = "VkDeviceCreateInfo")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct DeviceCreateInfo {
    #[doc(alias = "sType")]
    s_type: StructureType,
    #[doc(alias = "pNext")]
    p_next: *const BaseInStructure,
    # [doc = include_str ! ("../../../doc/VkDeviceCreateInfo$flags.md")]
    flags: DeviceCreateFlags,
    #[doc(alias = "queueCreateInfoCount")]
    queue_create_info_count: u32,
    #[doc(alias = "pQueueCreateInfos")]
    queue_create_infos: *const DeviceQueueCreateInfo,
    #[doc(alias = "enabledLayerCount")]
    enabled_layer_count: u32,
    #[doc(alias = "ppEnabledLayerNames")]
    pp_enabled_layer_names: *const *const CStr,
    #[doc(alias = "enabledExtensionCount")]
    enabled_extension_count: u32,
    #[doc(alias = "ppEnabledExtensionNames")]
    pp_enabled_extension_names: *const *const CStr,
    #[doc(alias = "pEnabledFeatures")]
    enabled_features: *const PhysicalDeviceFeatures,
}
# [doc = include_str ! ("../../../doc/VkInstanceCreateInfo.md")]
#[doc(alias = "VkInstanceCreateInfo")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct InstanceCreateInfo {
    #[doc(alias = "sType")]
    s_type: StructureType,
    #[doc(alias = "pNext")]
    p_next: *const BaseInStructure,
    # [doc = include_str ! ("../../../doc/VkInstanceCreateInfo$flags.md")]
    flags: InstanceCreateFlags,
    #[doc(alias = "pApplicationInfo")]
    application_info: *const ApplicationInfo,
    #[doc(alias = "enabledLayerCount")]
    enabled_layer_count: u32,
    #[doc(alias = "ppEnabledLayerNames")]
    pp_enabled_layer_names: *const *const CStr,
    #[doc(alias = "enabledExtensionCount")]
    enabled_extension_count: u32,
    #[doc(alias = "ppEnabledExtensionNames")]
    pp_enabled_extension_names: *const *const CStr,
}
# [doc = include_str ! ("../../../doc/VkQueueFamilyProperties.md")]
#[doc(alias = "VkQueueFamilyProperties")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct QueueFamilyProperties {
    #[doc(alias = "queueFlags")]
    queue_flags: QueueFlags,
    #[doc(alias = "queueCount")]
    queue_count: u32,
    #[doc(alias = "timestampValidBits")]
    timestamp_valid_bits: u32,
    #[doc(alias = "minImageTransferGranularity")]
    min_image_transfer_granularity: Extent3D,
}
# [doc = include_str ! ("../../../doc/VkPhysicalDeviceMemoryProperties.md")]
#[doc(alias = "VkPhysicalDeviceMemoryProperties")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PhysicalDeviceMemoryProperties {
    #[doc(alias = "memoryTypeCount")]
    memory_type_count: u32,
    #[doc(alias = "memoryTypes")]
    memory_types: [MemoryType; MAX_MEMORY_TYPES as usize],
    #[doc(alias = "memoryHeapCount")]
    memory_heap_count: u32,
    #[doc(alias = "memoryHeaps")]
    memory_heaps: [MemoryHeap; MAX_MEMORY_HEAPS as usize],
}
# [doc = include_str ! ("../../../doc/VkMemoryAllocateInfo.md")]
#[doc(alias = "VkMemoryAllocateInfo")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct MemoryAllocateInfo {
    #[doc(alias = "sType")]
    s_type: StructureType,
    #[doc(alias = "pNext")]
    p_next: *const BaseInStructure,
    #[doc(alias = "allocationSize")]
    allocation_size: DeviceSize,
    #[doc(alias = "memoryTypeIndex")]
    memory_type_index: u32,
}
# [doc = include_str ! ("../../../doc/VkMemoryRequirements.md")]
#[doc(alias = "VkMemoryRequirements")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct MemoryRequirements {
    # [doc = include_str ! ("../../../doc/VkMemoryRequirements$size.md")]
    size: DeviceSize,
    # [doc = include_str ! ("../../../doc/VkMemoryRequirements$alignment.md")]
    alignment: DeviceSize,
    #[doc(alias = "memoryTypeBits")]
    memory_type_bits: u32,
}
# [doc = include_str ! ("../../../doc/VkSparseImageFormatProperties.md")]
#[doc(alias = "VkSparseImageFormatProperties")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct SparseImageFormatProperties {
    #[doc(alias = "aspectMask")]
    aspect_mask: ImageAspectFlags,
    #[doc(alias = "imageGranularity")]
    image_granularity: Extent3D,
    # [doc = include_str ! ("../../../doc/VkSparseImageFormatProperties$flags.md")]
    flags: SparseImageFormatFlags,
}
# [doc = include_str ! ("../../../doc/VkSparseImageMemoryRequirements.md")]
#[doc(alias = "VkSparseImageMemoryRequirements")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct SparseImageMemoryRequirements {
    #[doc(alias = "formatProperties")]
    format_properties: SparseImageFormatProperties,
    #[doc(alias = "imageMipTailFirstLod")]
    image_mip_tail_first_lod: u32,
    #[doc(alias = "imageMipTailSize")]
    image_mip_tail_size: DeviceSize,
    #[doc(alias = "imageMipTailOffset")]
    image_mip_tail_offset: DeviceSize,
    #[doc(alias = "imageMipTailStride")]
    image_mip_tail_stride: DeviceSize,
}
# [doc = include_str ! ("../../../doc/VkMemoryType.md")]
#[doc(alias = "VkMemoryType")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct MemoryType {
    #[doc(alias = "propertyFlags")]
    property_flags: MemoryPropertyFlags,
    #[doc(alias = "heapIndex")]
    heap_index: u32,
}
# [doc = include_str ! ("../../../doc/VkMemoryHeap.md")]
#[doc(alias = "VkMemoryHeap")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct MemoryHeap {
    # [doc = include_str ! ("../../../doc/VkMemoryHeap$size.md")]
    size: DeviceSize,
    # [doc = include_str ! ("../../../doc/VkMemoryHeap$flags.md")]
    flags: MemoryHeapFlags,
}
# [doc = include_str ! ("../../../doc/VkMappedMemoryRange.md")]
#[doc(alias = "VkMappedMemoryRange")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct MappedMemoryRange {
    #[doc(alias = "sType")]
    s_type: StructureType,
    #[doc(alias = "pNext")]
    p_next: *const BaseInStructure,
    # [doc = include_str ! ("../../../doc/VkMappedMemoryRange$memory.md")]
    memory: DeviceMemory,
    # [doc = include_str ! ("../../../doc/VkMappedMemoryRange$offset.md")]
    offset: DeviceSize,
    # [doc = include_str ! ("../../../doc/VkMappedMemoryRange$size.md")]
    size: DeviceSize,
}
# [doc = include_str ! ("../../../doc/VkFormatProperties.md")]
#[doc(alias = "VkFormatProperties")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct FormatProperties {
    #[doc(alias = "linearTilingFeatures")]
    linear_tiling_features: FormatFeatureFlags,
    #[doc(alias = "optimalTilingFeatures")]
    optimal_tiling_features: FormatFeatureFlags,
    #[doc(alias = "bufferFeatures")]
    buffer_features: FormatFeatureFlags,
}
# [doc = include_str ! ("../../../doc/VkImageFormatProperties.md")]
#[doc(alias = "VkImageFormatProperties")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct ImageFormatProperties {
    #[doc(alias = "maxExtent")]
    max_extent: Extent3D,
    #[doc(alias = "maxMipLevels")]
    max_mip_levels: u32,
    #[doc(alias = "maxArrayLayers")]
    max_array_layers: u32,
    #[doc(alias = "sampleCounts")]
    sample_counts: SampleCountFlags,
    #[doc(alias = "maxResourceSize")]
    max_resource_size: DeviceSize,
}
# [doc = include_str ! ("../../../doc/VkDescriptorBufferInfo.md")]
#[doc(alias = "VkDescriptorBufferInfo")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct DescriptorBufferInfo {
    # [doc = include_str ! ("../../../doc/VkDescriptorBufferInfo$buffer.md")]
    buffer: Buffer,
    # [doc = include_str ! ("../../../doc/VkDescriptorBufferInfo$offset.md")]
    offset: DeviceSize,
    # [doc = include_str ! ("../../../doc/VkDescriptorBufferInfo$range.md")]
    range: DeviceSize,
}
# [doc = include_str ! ("../../../doc/VkDescriptorImageInfo.md")]
#[doc(alias = "VkDescriptorImageInfo")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct DescriptorImageInfo {
    # [doc = include_str ! ("../../../doc/VkDescriptorImageInfo$sampler.md")]
    sampler: Sampler,
    #[doc(alias = "imageView")]
    image_view: ImageView,
    #[doc(alias = "imageLayout")]
    image_layout: ImageLayout,
}
# [doc = include_str ! ("../../../doc/VkWriteDescriptorSet.md")]
#[doc(alias = "VkWriteDescriptorSet")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct WriteDescriptorSet {
    #[doc(alias = "sType")]
    s_type: StructureType,
    #[doc(alias = "pNext")]
    p_next: *const BaseInStructure,
    #[doc(alias = "dstSet")]
    dst_set: DescriptorSet,
    #[doc(alias = "dstBinding")]
    dst_binding: u32,
    #[doc(alias = "dstArrayElement")]
    dst_array_element: u32,
    #[doc(alias = "descriptorCount")]
    descriptor_count: u32,
    #[doc(alias = "descriptorType")]
    descriptor_type: DescriptorType,
    #[doc(alias = "pImageInfo")]
    image_info: *const DescriptorImageInfo,
    #[doc(alias = "pBufferInfo")]
    buffer_info: *const DescriptorBufferInfo,
    #[doc(alias = "pTexelBufferView")]
    texel_buffer_view: *const BufferView,
}
# [doc = include_str ! ("../../../doc/VkCopyDescriptorSet.md")]
#[doc(alias = "VkCopyDescriptorSet")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct CopyDescriptorSet {
    #[doc(alias = "sType")]
    s_type: StructureType,
    #[doc(alias = "pNext")]
    p_next: *const BaseInStructure,
    #[doc(alias = "srcSet")]
    src_set: DescriptorSet,
    #[doc(alias = "srcBinding")]
    src_binding: u32,
    #[doc(alias = "srcArrayElement")]
    src_array_element: u32,
    #[doc(alias = "dstSet")]
    dst_set: DescriptorSet,
    #[doc(alias = "dstBinding")]
    dst_binding: u32,
    #[doc(alias = "dstArrayElement")]
    dst_array_element: u32,
    #[doc(alias = "descriptorCount")]
    descriptor_count: u32,
}
# [doc = include_str ! ("../../../doc/VkBufferCreateInfo.md")]
#[doc(alias = "VkBufferCreateInfo")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct BufferCreateInfo {
    #[doc(alias = "sType")]
    s_type: StructureType,
    #[doc(alias = "pNext")]
    p_next: *const BaseInStructure,
    # [doc = include_str ! ("../../../doc/VkBufferCreateInfo$flags.md")]
    flags: BufferCreateFlags,
    # [doc = include_str ! ("../../../doc/VkBufferCreateInfo$size.md")]
    size: DeviceSize,
    # [doc = include_str ! ("../../../doc/VkBufferCreateInfo$usage.md")]
    usage: BufferUsageFlags,
    #[doc(alias = "sharingMode")]
    sharing_mode: SharingMode,
    #[doc(alias = "queueFamilyIndexCount")]
    queue_family_index_count: u32,
    #[doc(alias = "pQueueFamilyIndices")]
    queue_family_indices: *const u32,
}
# [doc = include_str ! ("../../../doc/VkBufferViewCreateInfo.md")]
#[doc(alias = "VkBufferViewCreateInfo")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct BufferViewCreateInfo {
    #[doc(alias = "sType")]
    s_type: StructureType,
    #[doc(alias = "pNext")]
    p_next: *const BaseInStructure,
    # [doc = include_str ! ("../../../doc/VkBufferViewCreateInfo$flags.md")]
    flags: BufferViewCreateFlags,
    # [doc = include_str ! ("../../../doc/VkBufferViewCreateInfo$buffer.md")]
    buffer: Buffer,
    # [doc = include_str ! ("../../../doc/VkBufferViewCreateInfo$format.md")]
    format: Format,
    # [doc = include_str ! ("../../../doc/VkBufferViewCreateInfo$offset.md")]
    offset: DeviceSize,
    # [doc = include_str ! ("../../../doc/VkBufferViewCreateInfo$range.md")]
    range: DeviceSize,
}
# [doc = include_str ! ("../../../doc/VkImageSubresource.md")]
#[doc(alias = "VkImageSubresource")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct ImageSubresource {
    #[doc(alias = "aspectMask")]
    aspect_mask: ImageAspectFlags,
    #[doc(alias = "mipLevel")]
    mip_level: u32,
    #[doc(alias = "arrayLayer")]
    array_layer: u32,
}
# [doc = include_str ! ("../../../doc/VkImageSubresourceLayers.md")]
#[doc(alias = "VkImageSubresourceLayers")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct ImageSubresourceLayers {
    #[doc(alias = "aspectMask")]
    aspect_mask: ImageAspectFlags,
    #[doc(alias = "mipLevel")]
    mip_level: u32,
    #[doc(alias = "baseArrayLayer")]
    base_array_layer: u32,
    #[doc(alias = "layerCount")]
    layer_count: u32,
}
# [doc = include_str ! ("../../../doc/VkImageSubresourceRange.md")]
#[doc(alias = "VkImageSubresourceRange")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct ImageSubresourceRange {
    #[doc(alias = "aspectMask")]
    aspect_mask: ImageAspectFlags,
    #[doc(alias = "baseMipLevel")]
    base_mip_level: u32,
    #[doc(alias = "levelCount")]
    level_count: u32,
    #[doc(alias = "baseArrayLayer")]
    base_array_layer: u32,
    #[doc(alias = "layerCount")]
    layer_count: u32,
}
# [doc = include_str ! ("../../../doc/VkMemoryBarrier.md")]
#[doc(alias = "VkMemoryBarrier")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct MemoryBarrier {
    #[doc(alias = "sType")]
    s_type: StructureType,
    #[doc(alias = "pNext")]
    p_next: *const BaseInStructure,
    #[doc(alias = "srcAccessMask")]
    src_access_mask: AccessFlags,
    #[doc(alias = "dstAccessMask")]
    dst_access_mask: AccessFlags,
}
# [doc = include_str ! ("../../../doc/VkBufferMemoryBarrier.md")]
#[doc(alias = "VkBufferMemoryBarrier")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct BufferMemoryBarrier {
    #[doc(alias = "sType")]
    s_type: StructureType,
    #[doc(alias = "pNext")]
    p_next: *const BaseInStructure,
    #[doc(alias = "srcAccessMask")]
    src_access_mask: AccessFlags,
    #[doc(alias = "dstAccessMask")]
    dst_access_mask: AccessFlags,
    #[doc(alias = "srcQueueFamilyIndex")]
    src_queue_family_index: u32,
    #[doc(alias = "dstQueueFamilyIndex")]
    dst_queue_family_index: u32,
    # [doc = include_str ! ("../../../doc/VkBufferMemoryBarrier$buffer.md")]
    buffer: Buffer,
    # [doc = include_str ! ("../../../doc/VkBufferMemoryBarrier$offset.md")]
    offset: DeviceSize,
    # [doc = include_str ! ("../../../doc/VkBufferMemoryBarrier$size.md")]
    size: DeviceSize,
}
# [doc = include_str ! ("../../../doc/VkImageMemoryBarrier.md")]
#[doc(alias = "VkImageMemoryBarrier")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct ImageMemoryBarrier {
    #[doc(alias = "sType")]
    s_type: StructureType,
    #[doc(alias = "pNext")]
    p_next: *const BaseInStructure,
    #[doc(alias = "srcAccessMask")]
    src_access_mask: AccessFlags,
    #[doc(alias = "dstAccessMask")]
    dst_access_mask: AccessFlags,
    #[doc(alias = "oldLayout")]
    old_layout: ImageLayout,
    #[doc(alias = "newLayout")]
    new_layout: ImageLayout,
    #[doc(alias = "srcQueueFamilyIndex")]
    src_queue_family_index: u32,
    #[doc(alias = "dstQueueFamilyIndex")]
    dst_queue_family_index: u32,
    # [doc = include_str ! ("../../../doc/VkImageMemoryBarrier$image.md")]
    image: Image,
    #[doc(alias = "subresourceRange")]
    subresource_range: ImageSubresourceRange,
}
# [doc = include_str ! ("../../../doc/VkImageCreateInfo.md")]
#[doc(alias = "VkImageCreateInfo")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct ImageCreateInfo {
    #[doc(alias = "sType")]
    s_type: StructureType,
    #[doc(alias = "pNext")]
    p_next: *const BaseInStructure,
    # [doc = include_str ! ("../../../doc/VkImageCreateInfo$flags.md")]
    flags: ImageCreateFlags,
    #[doc(alias = "imageType")]
    image_type: ImageType,
    # [doc = include_str ! ("../../../doc/VkImageCreateInfo$format.md")]
    format: Format,
    # [doc = include_str ! ("../../../doc/VkImageCreateInfo$extent.md")]
    extent: Extent3D,
    #[doc(alias = "mipLevels")]
    mip_levels: u32,
    #[doc(alias = "arrayLayers")]
    array_layers: u32,
    # [doc = include_str ! ("../../../doc/VkImageCreateInfo$samples.md")]
    samples: SampleCountFlagBits,
    # [doc = include_str ! ("../../../doc/VkImageCreateInfo$tiling.md")]
    tiling: ImageTiling,
    # [doc = include_str ! ("../../../doc/VkImageCreateInfo$usage.md")]
    usage: ImageUsageFlags,
    #[doc(alias = "sharingMode")]
    sharing_mode: SharingMode,
    #[doc(alias = "queueFamilyIndexCount")]
    queue_family_index_count: u32,
    #[doc(alias = "pQueueFamilyIndices")]
    queue_family_indices: *const u32,
    #[doc(alias = "initialLayout")]
    initial_layout: ImageLayout,
}
# [doc = include_str ! ("../../../doc/VkSubresourceLayout.md")]
#[doc(alias = "VkSubresourceLayout")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct SubresourceLayout {
    # [doc = include_str ! ("../../../doc/VkSubresourceLayout$offset.md")]
    offset: DeviceSize,
    # [doc = include_str ! ("../../../doc/VkSubresourceLayout$size.md")]
    size: DeviceSize,
    #[doc(alias = "rowPitch")]
    row_pitch: DeviceSize,
    #[doc(alias = "arrayPitch")]
    array_pitch: DeviceSize,
    #[doc(alias = "depthPitch")]
    depth_pitch: DeviceSize,
}
# [doc = include_str ! ("../../../doc/VkImageViewCreateInfo.md")]
#[doc(alias = "VkImageViewCreateInfo")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct ImageViewCreateInfo {
    #[doc(alias = "sType")]
    s_type: StructureType,
    #[doc(alias = "pNext")]
    p_next: *const BaseInStructure,
    # [doc = include_str ! ("../../../doc/VkImageViewCreateInfo$flags.md")]
    flags: ImageViewCreateFlags,
    # [doc = include_str ! ("../../../doc/VkImageViewCreateInfo$image.md")]
    image: Image,
    #[doc(alias = "viewType")]
    view_type: ImageViewType,
    # [doc = include_str ! ("../../../doc/VkImageViewCreateInfo$format.md")]
    format: Format,
    # [doc = include_str ! ("../../../doc/VkImageViewCreateInfo$components.md")]
    components: ComponentMapping,
    #[doc(alias = "subresourceRange")]
    subresource_range: ImageSubresourceRange,
}
# [doc = include_str ! ("../../../doc/VkBufferCopy.md")]
#[doc(alias = "VkBufferCopy")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct BufferCopy {
    #[doc(alias = "srcOffset")]
    src_offset: DeviceSize,
    #[doc(alias = "dstOffset")]
    dst_offset: DeviceSize,
    # [doc = include_str ! ("../../../doc/VkBufferCopy$size.md")]
    size: DeviceSize,
}
# [doc = include_str ! ("../../../doc/VkSparseMemoryBind.md")]
#[doc(alias = "VkSparseMemoryBind")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct SparseMemoryBind {
    #[doc(alias = "resourceOffset")]
    resource_offset: DeviceSize,
    # [doc = include_str ! ("../../../doc/VkSparseMemoryBind$size.md")]
    size: DeviceSize,
    # [doc = include_str ! ("../../../doc/VkSparseMemoryBind$memory.md")]
    memory: DeviceMemory,
    #[doc(alias = "memoryOffset")]
    memory_offset: DeviceSize,
    # [doc = include_str ! ("../../../doc/VkSparseMemoryBind$flags.md")]
    flags: SparseMemoryBindFlags,
}
# [doc = include_str ! ("../../../doc/VkSparseImageMemoryBind.md")]
#[doc(alias = "VkSparseImageMemoryBind")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct SparseImageMemoryBind {
    # [doc = include_str ! ("../../../doc/VkSparseImageMemoryBind$subresource.md")]
    subresource: ImageSubresource,
    # [doc = include_str ! ("../../../doc/VkSparseImageMemoryBind$offset.md")]
    offset: Offset3D,
    # [doc = include_str ! ("../../../doc/VkSparseImageMemoryBind$extent.md")]
    extent: Extent3D,
    # [doc = include_str ! ("../../../doc/VkSparseImageMemoryBind$memory.md")]
    memory: DeviceMemory,
    #[doc(alias = "memoryOffset")]
    memory_offset: DeviceSize,
    # [doc = include_str ! ("../../../doc/VkSparseImageMemoryBind$flags.md")]
    flags: SparseMemoryBindFlags,
}
# [doc = include_str ! ("../../../doc/VkSparseBufferMemoryBindInfo.md")]
#[doc(alias = "VkSparseBufferMemoryBindInfo")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct SparseBufferMemoryBindInfo {
    # [doc = include_str ! ("../../../doc/VkSparseBufferMemoryBindInfo$buffer.md")]
    buffer: Buffer,
    #[doc(alias = "bindCount")]
    bind_count: u32,
    #[doc(alias = "pBinds")]
    binds: *const SparseMemoryBind,
}
# [doc = include_str ! ("../../../doc/VkSparseImageOpaqueMemoryBindInfo.md")]
#[doc(alias = "VkSparseImageOpaqueMemoryBindInfo")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct SparseImageOpaqueMemoryBindInfo {
    # [doc = include_str ! ("../../../doc/VkSparseImageOpaqueMemoryBindInfo$image.md")]
    image: Image,
    #[doc(alias = "bindCount")]
    bind_count: u32,
    #[doc(alias = "pBinds")]
    binds: *const SparseMemoryBind,
}
# [doc = include_str ! ("../../../doc/VkSparseImageMemoryBindInfo.md")]
#[doc(alias = "VkSparseImageMemoryBindInfo")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct SparseImageMemoryBindInfo {
    # [doc = include_str ! ("../../../doc/VkSparseImageMemoryBindInfo$image.md")]
    image: Image,
    #[doc(alias = "bindCount")]
    bind_count: u32,
    #[doc(alias = "pBinds")]
    binds: *const SparseImageMemoryBind,
}
# [doc = include_str ! ("../../../doc/VkBindSparseInfo.md")]
#[doc(alias = "VkBindSparseInfo")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct BindSparseInfo {
    #[doc(alias = "sType")]
    s_type: StructureType,
    #[doc(alias = "pNext")]
    p_next: *const BaseInStructure,
    #[doc(alias = "waitSemaphoreCount")]
    wait_semaphore_count: u32,
    #[doc(alias = "pWaitSemaphores")]
    wait_semaphores: *const Semaphore,
    #[doc(alias = "bufferBindCount")]
    buffer_bind_count: u32,
    #[doc(alias = "pBufferBinds")]
    buffer_binds: *const SparseBufferMemoryBindInfo,
    #[doc(alias = "imageOpaqueBindCount")]
    image_opaque_bind_count: u32,
    #[doc(alias = "pImageOpaqueBinds")]
    image_opaque_binds: *const SparseImageOpaqueMemoryBindInfo,
    #[doc(alias = "imageBindCount")]
    image_bind_count: u32,
    #[doc(alias = "pImageBinds")]
    image_binds: *const SparseImageMemoryBindInfo,
    #[doc(alias = "signalSemaphoreCount")]
    signal_semaphore_count: u32,
    #[doc(alias = "pSignalSemaphores")]
    signal_semaphores: *const Semaphore,
}
# [doc = include_str ! ("../../../doc/VkImageCopy.md")]
#[doc(alias = "VkImageCopy")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct ImageCopy {
    #[doc(alias = "srcSubresource")]
    src_subresource: ImageSubresourceLayers,
    #[doc(alias = "srcOffset")]
    src_offset: Offset3D,
    #[doc(alias = "dstSubresource")]
    dst_subresource: ImageSubresourceLayers,
    #[doc(alias = "dstOffset")]
    dst_offset: Offset3D,
    # [doc = include_str ! ("../../../doc/VkImageCopy$extent.md")]
    extent: Extent3D,
}
# [doc = include_str ! ("../../../doc/VkImageBlit.md")]
#[doc(alias = "VkImageBlit")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct ImageBlit {
    #[doc(alias = "srcSubresource")]
    src_subresource: ImageSubresourceLayers,
    #[doc(alias = "srcOffsets")]
    src_offsets: [Offset3D; 2 as usize],
    #[doc(alias = "dstSubresource")]
    dst_subresource: ImageSubresourceLayers,
    #[doc(alias = "dstOffsets")]
    dst_offsets: [Offset3D; 2 as usize],
}
# [doc = include_str ! ("../../../doc/VkBufferImageCopy.md")]
#[doc(alias = "VkBufferImageCopy")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct BufferImageCopy {
    #[doc(alias = "bufferOffset")]
    buffer_offset: DeviceSize,
    #[doc(alias = "bufferRowLength")]
    buffer_row_length: u32,
    #[doc(alias = "bufferImageHeight")]
    buffer_image_height: u32,
    #[doc(alias = "imageSubresource")]
    image_subresource: ImageSubresourceLayers,
    #[doc(alias = "imageOffset")]
    image_offset: Offset3D,
    #[doc(alias = "imageExtent")]
    image_extent: Extent3D,
}
# [doc = include_str ! ("../../../doc/VkImageResolve.md")]
#[doc(alias = "VkImageResolve")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct ImageResolve {
    #[doc(alias = "srcSubresource")]
    src_subresource: ImageSubresourceLayers,
    #[doc(alias = "srcOffset")]
    src_offset: Offset3D,
    #[doc(alias = "dstSubresource")]
    dst_subresource: ImageSubresourceLayers,
    #[doc(alias = "dstOffset")]
    dst_offset: Offset3D,
    # [doc = include_str ! ("../../../doc/VkImageResolve$extent.md")]
    extent: Extent3D,
}
# [doc = include_str ! ("../../../doc/VkShaderModuleCreateInfo.md")]
#[doc(alias = "VkShaderModuleCreateInfo")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct ShaderModuleCreateInfo {
    #[doc(alias = "sType")]
    s_type: StructureType,
    #[doc(alias = "pNext")]
    p_next: *const BaseInStructure,
    # [doc = include_str ! ("../../../doc/VkShaderModuleCreateInfo$flags.md")]
    flags: ShaderModuleCreateFlags,
    #[doc(alias = "codeSize")]
    code_size: usize,
    #[doc(alias = "pCode")]
    code: *const u32,
}
# [doc = include_str ! ("../../../doc/VkDescriptorSetLayoutBinding.md")]
#[doc(alias = "VkDescriptorSetLayoutBinding")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct DescriptorSetLayoutBinding {
    # [doc = include_str ! ("../../../doc/VkDescriptorSetLayoutBinding$binding.md")]
    binding: u32,
    #[doc(alias = "descriptorType")]
    descriptor_type: DescriptorType,
    #[doc(alias = "descriptorCount")]
    descriptor_count: u32,
    #[doc(alias = "stageFlags")]
    stage_flags: ShaderStageFlags,
    #[doc(alias = "pImmutableSamplers")]
    immutable_samplers: *const Sampler,
}
# [doc = include_str ! ("../../../doc/VkDescriptorSetLayoutCreateInfo.md")]
#[doc(alias = "VkDescriptorSetLayoutCreateInfo")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct DescriptorSetLayoutCreateInfo {
    #[doc(alias = "sType")]
    s_type: StructureType,
    #[doc(alias = "pNext")]
    p_next: *const BaseInStructure,
    # [doc = include_str ! ("../../../doc/VkDescriptorSetLayoutCreateInfo$flags.md")]
    flags: DescriptorSetLayoutCreateFlags,
    #[doc(alias = "bindingCount")]
    binding_count: u32,
    #[doc(alias = "pBindings")]
    bindings: *const DescriptorSetLayoutBinding,
}
# [doc = include_str ! ("../../../doc/VkDescriptorPoolSize.md")]
#[doc(alias = "VkDescriptorPoolSize")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct DescriptorPoolSize {
    #[doc(alias = "type")]
    type_: DescriptorType,
    #[doc(alias = "descriptorCount")]
    descriptor_count: u32,
}
# [doc = include_str ! ("../../../doc/VkDescriptorPoolCreateInfo.md")]
#[doc(alias = "VkDescriptorPoolCreateInfo")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct DescriptorPoolCreateInfo {
    #[doc(alias = "sType")]
    s_type: StructureType,
    #[doc(alias = "pNext")]
    p_next: *const BaseInStructure,
    # [doc = include_str ! ("../../../doc/VkDescriptorPoolCreateInfo$flags.md")]
    flags: DescriptorPoolCreateFlags,
    #[doc(alias = "maxSets")]
    max_sets: u32,
    #[doc(alias = "poolSizeCount")]
    pool_size_count: u32,
    #[doc(alias = "pPoolSizes")]
    pool_sizes: *const DescriptorPoolSize,
}
# [doc = include_str ! ("../../../doc/VkDescriptorSetAllocateInfo.md")]
#[doc(alias = "VkDescriptorSetAllocateInfo")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct DescriptorSetAllocateInfo {
    #[doc(alias = "sType")]
    s_type: StructureType,
    #[doc(alias = "pNext")]
    p_next: *const BaseInStructure,
    #[doc(alias = "descriptorPool")]
    descriptor_pool: DescriptorPool,
    #[doc(alias = "descriptorSetCount")]
    descriptor_set_count: u32,
    #[doc(alias = "pSetLayouts")]
    set_layouts: *const DescriptorSetLayout,
}
# [doc = include_str ! ("../../../doc/VkSpecializationMapEntry.md")]
#[doc(alias = "VkSpecializationMapEntry")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct SpecializationMapEntry {
    #[doc(alias = "constantID")]
    constant_id: u32,
    # [doc = include_str ! ("../../../doc/VkSpecializationMapEntry$offset.md")]
    offset: u32,
    # [doc = include_str ! ("../../../doc/VkSpecializationMapEntry$size.md")]
    size: usize,
}
# [doc = include_str ! ("../../../doc/VkSpecializationInfo.md")]
#[doc(alias = "VkSpecializationInfo")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct SpecializationInfo {
    #[doc(alias = "mapEntryCount")]
    map_entry_count: u32,
    #[doc(alias = "pMapEntries")]
    map_entries: *const SpecializationMapEntry,
    #[doc(alias = "dataSize")]
    data_size: usize,
    #[doc(alias = "pData")]
    data: *const std::ffi::c_void,
}
# [doc = include_str ! ("../../../doc/VkPipelineShaderStageCreateInfo.md")]
#[doc(alias = "VkPipelineShaderStageCreateInfo")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PipelineShaderStageCreateInfo {
    #[doc(alias = "sType")]
    s_type: StructureType,
    #[doc(alias = "pNext")]
    p_next: *const BaseInStructure,
    # [doc = include_str ! ("../../../doc/VkPipelineShaderStageCreateInfo$flags.md")]
    flags: PipelineShaderStageCreateFlags,
    # [doc = include_str ! ("../../../doc/VkPipelineShaderStageCreateInfo$stage.md")]
    stage: ShaderStageFlagBits,
    # [doc = include_str ! ("../../../doc/VkPipelineShaderStageCreateInfo$module.md")]
    module: ShaderModule,
    #[doc(alias = "pName")]
    name: *const CStr,
    #[doc(alias = "pSpecializationInfo")]
    specialization_info: *const SpecializationInfo,
}
# [doc = include_str ! ("../../../doc/VkComputePipelineCreateInfo.md")]
#[doc(alias = "VkComputePipelineCreateInfo")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct ComputePipelineCreateInfo {
    #[doc(alias = "sType")]
    s_type: StructureType,
    #[doc(alias = "pNext")]
    p_next: *const BaseInStructure,
    # [doc = include_str ! ("../../../doc/VkComputePipelineCreateInfo$flags.md")]
    flags: PipelineCreateFlags,
    # [doc = include_str ! ("../../../doc/VkComputePipelineCreateInfo$stage.md")]
    stage: PipelineShaderStageCreateInfo,
    # [doc = include_str ! ("../../../doc/VkComputePipelineCreateInfo$layout.md")]
    layout: PipelineLayout,
    #[doc(alias = "basePipelineHandle")]
    base_pipeline_handle: Pipeline,
    #[doc(alias = "basePipelineIndex")]
    base_pipeline_index: i32,
}
# [doc = include_str ! ("../../../doc/VkVertexInputBindingDescription.md")]
#[doc(alias = "VkVertexInputBindingDescription")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct VertexInputBindingDescription {
    # [doc = include_str ! ("../../../doc/VkVertexInputBindingDescription$binding.md")]
    binding: u32,
    # [doc = include_str ! ("../../../doc/VkVertexInputBindingDescription$stride.md")]
    stride: u32,
    #[doc(alias = "inputRate")]
    input_rate: VertexInputRate,
}
# [doc = include_str ! ("../../../doc/VkVertexInputAttributeDescription.md")]
#[doc(alias = "VkVertexInputAttributeDescription")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct VertexInputAttributeDescription {
    # [doc = include_str ! ("../../../doc/VkVertexInputAttributeDescription$location.md")]
    location: u32,
    # [doc = include_str ! ("../../../doc/VkVertexInputAttributeDescription$binding.md")]
    binding: u32,
    # [doc = include_str ! ("../../../doc/VkVertexInputAttributeDescription$format.md")]
    format: Format,
    # [doc = include_str ! ("../../../doc/VkVertexInputAttributeDescription$offset.md")]
    offset: u32,
}
# [doc = include_str ! ("../../../doc/VkPipelineVertexInputStateCreateInfo.md")]
#[doc(alias = "VkPipelineVertexInputStateCreateInfo")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PipelineVertexInputStateCreateInfo {
    #[doc(alias = "sType")]
    s_type: StructureType,
    #[doc(alias = "pNext")]
    p_next: *const BaseInStructure,
    # [doc = include_str ! ("../../../doc/VkPipelineVertexInputStateCreateInfo$flags.md")]
    flags: PipelineVertexInputStateCreateFlags,
    #[doc(alias = "vertexBindingDescriptionCount")]
    vertex_binding_description_count: u32,
    #[doc(alias = "pVertexBindingDescriptions")]
    vertex_binding_descriptions: *const VertexInputBindingDescription,
    #[doc(alias = "vertexAttributeDescriptionCount")]
    vertex_attribute_description_count: u32,
    #[doc(alias = "pVertexAttributeDescriptions")]
    vertex_attribute_descriptions: *const VertexInputAttributeDescription,
}
# [doc = include_str ! ("../../../doc/VkPipelineInputAssemblyStateCreateInfo.md")]
#[doc(alias = "VkPipelineInputAssemblyStateCreateInfo")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PipelineInputAssemblyStateCreateInfo {
    #[doc(alias = "sType")]
    s_type: StructureType,
    #[doc(alias = "pNext")]
    p_next: *const BaseInStructure,
    # [doc = include_str ! ("../../../doc/VkPipelineInputAssemblyStateCreateInfo$flags.md")]
    flags: PipelineInputAssemblyStateCreateFlags,
    # [doc = include_str ! ("../../../doc/VkPipelineInputAssemblyStateCreateInfo$topology.md")]
    topology: PrimitiveTopology,
    #[doc(alias = "primitiveRestartEnable")]
    primitive_restart_enable: Bool32,
}
# [doc = include_str ! ("../../../doc/VkPipelineTessellationStateCreateInfo.md")]
#[doc(alias = "VkPipelineTessellationStateCreateInfo")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PipelineTessellationStateCreateInfo {
    #[doc(alias = "sType")]
    s_type: StructureType,
    #[doc(alias = "pNext")]
    p_next: *const BaseInStructure,
    # [doc = include_str ! ("../../../doc/VkPipelineTessellationStateCreateInfo$flags.md")]
    flags: PipelineTessellationStateCreateFlags,
    #[doc(alias = "patchControlPoints")]
    patch_control_points: u32,
}
# [doc = include_str ! ("../../../doc/VkPipelineViewportStateCreateInfo.md")]
#[doc(alias = "VkPipelineViewportStateCreateInfo")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PipelineViewportStateCreateInfo {
    #[doc(alias = "sType")]
    s_type: StructureType,
    #[doc(alias = "pNext")]
    p_next: *const BaseInStructure,
    # [doc = include_str ! ("../../../doc/VkPipelineViewportStateCreateInfo$flags.md")]
    flags: PipelineViewportStateCreateFlags,
    #[doc(alias = "viewportCount")]
    viewport_count: u32,
    #[doc(alias = "pViewports")]
    viewports: *const Viewport,
    #[doc(alias = "scissorCount")]
    scissor_count: u32,
    #[doc(alias = "pScissors")]
    scissors: *const Rect2D,
}
# [doc = include_str ! ("../../../doc/VkPipelineRasterizationStateCreateInfo.md")]
#[doc(alias = "VkPipelineRasterizationStateCreateInfo")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PipelineRasterizationStateCreateInfo {
    #[doc(alias = "sType")]
    s_type: StructureType,
    #[doc(alias = "pNext")]
    p_next: *const BaseInStructure,
    # [doc = include_str ! ("../../../doc/VkPipelineRasterizationStateCreateInfo$flags.md")]
    flags: PipelineRasterizationStateCreateFlags,
    #[doc(alias = "depthClampEnable")]
    depth_clamp_enable: Bool32,
    #[doc(alias = "rasterizerDiscardEnable")]
    rasterizer_discard_enable: Bool32,
    #[doc(alias = "polygonMode")]
    polygon_mode: PolygonMode,
    #[doc(alias = "cullMode")]
    cull_mode: CullModeFlags,
    #[doc(alias = "frontFace")]
    front_face: FrontFace,
    #[doc(alias = "depthBiasEnable")]
    depth_bias_enable: Bool32,
    #[doc(alias = "depthBiasConstantFactor")]
    depth_bias_constant_factor: f32,
    #[doc(alias = "depthBiasClamp")]
    depth_bias_clamp: f32,
    #[doc(alias = "depthBiasSlopeFactor")]
    depth_bias_slope_factor: f32,
    #[doc(alias = "lineWidth")]
    line_width: f32,
}
# [doc = include_str ! ("../../../doc/VkPipelineMultisampleStateCreateInfo.md")]
#[doc(alias = "VkPipelineMultisampleStateCreateInfo")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PipelineMultisampleStateCreateInfo {
    #[doc(alias = "sType")]
    s_type: StructureType,
    #[doc(alias = "pNext")]
    p_next: *const BaseInStructure,
    # [doc = include_str ! ("../../../doc/VkPipelineMultisampleStateCreateInfo$flags.md")]
    flags: PipelineMultisampleStateCreateFlags,
    #[doc(alias = "rasterizationSamples")]
    rasterization_samples: SampleCountFlagBits,
    #[doc(alias = "sampleShadingEnable")]
    sample_shading_enable: Bool32,
    #[doc(alias = "minSampleShading")]
    min_sample_shading: f32,
    #[doc(alias = "pSampleMask")]
    sample_mask: *const SampleMask,
    #[doc(alias = "alphaToCoverageEnable")]
    alpha_to_coverage_enable: Bool32,
    #[doc(alias = "alphaToOneEnable")]
    alpha_to_one_enable: Bool32,
}
# [doc = include_str ! ("../../../doc/VkPipelineColorBlendAttachmentState.md")]
#[doc(alias = "VkPipelineColorBlendAttachmentState")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PipelineColorBlendAttachmentState {
    #[doc(alias = "blendEnable")]
    blend_enable: Bool32,
    #[doc(alias = "srcColorBlendFactor")]
    src_color_blend_factor: BlendFactor,
    #[doc(alias = "dstColorBlendFactor")]
    dst_color_blend_factor: BlendFactor,
    #[doc(alias = "colorBlendOp")]
    color_blend_op: BlendOp,
    #[doc(alias = "srcAlphaBlendFactor")]
    src_alpha_blend_factor: BlendFactor,
    #[doc(alias = "dstAlphaBlendFactor")]
    dst_alpha_blend_factor: BlendFactor,
    #[doc(alias = "alphaBlendOp")]
    alpha_blend_op: BlendOp,
    #[doc(alias = "colorWriteMask")]
    color_write_mask: ColorComponentFlags,
}
# [doc = include_str ! ("../../../doc/VkPipelineColorBlendStateCreateInfo.md")]
#[doc(alias = "VkPipelineColorBlendStateCreateInfo")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PipelineColorBlendStateCreateInfo {
    #[doc(alias = "sType")]
    s_type: StructureType,
    #[doc(alias = "pNext")]
    p_next: *const BaseInStructure,
    # [doc = include_str ! ("../../../doc/VkPipelineColorBlendStateCreateInfo$flags.md")]
    flags: PipelineColorBlendStateCreateFlags,
    #[doc(alias = "logicOpEnable")]
    logic_op_enable: Bool32,
    #[doc(alias = "logicOp")]
    logic_op: LogicOp,
    #[doc(alias = "attachmentCount")]
    attachment_count: u32,
    #[doc(alias = "pAttachments")]
    attachments: *const PipelineColorBlendAttachmentState,
    #[doc(alias = "blendConstants")]
    blend_constants: [f32; 4 as usize],
}
# [doc = include_str ! ("../../../doc/VkPipelineDynamicStateCreateInfo.md")]
#[doc(alias = "VkPipelineDynamicStateCreateInfo")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PipelineDynamicStateCreateInfo {
    #[doc(alias = "sType")]
    s_type: StructureType,
    #[doc(alias = "pNext")]
    p_next: *const BaseInStructure,
    # [doc = include_str ! ("../../../doc/VkPipelineDynamicStateCreateInfo$flags.md")]
    flags: PipelineDynamicStateCreateFlags,
    #[doc(alias = "dynamicStateCount")]
    dynamic_state_count: u32,
    #[doc(alias = "pDynamicStates")]
    dynamic_states: *const DynamicState,
}
# [doc = include_str ! ("../../../doc/VkStencilOpState.md")]
#[doc(alias = "VkStencilOpState")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct StencilOpState {
    #[doc(alias = "failOp")]
    fail_op: StencilOp,
    #[doc(alias = "passOp")]
    pass_op: StencilOp,
    #[doc(alias = "depthFailOp")]
    depth_fail_op: StencilOp,
    #[doc(alias = "compareOp")]
    compare_op: CompareOp,
    #[doc(alias = "compareMask")]
    compare_mask: u32,
    #[doc(alias = "writeMask")]
    write_mask: u32,
    # [doc = include_str ! ("../../../doc/VkStencilOpState$reference.md")]
    reference: u32,
}
# [doc = include_str ! ("../../../doc/VkPipelineDepthStencilStateCreateInfo.md")]
#[doc(alias = "VkPipelineDepthStencilStateCreateInfo")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PipelineDepthStencilStateCreateInfo {
    #[doc(alias = "sType")]
    s_type: StructureType,
    #[doc(alias = "pNext")]
    p_next: *const BaseInStructure,
    # [doc = include_str ! ("../../../doc/VkPipelineDepthStencilStateCreateInfo$flags.md")]
    flags: PipelineDepthStencilStateCreateFlags,
    #[doc(alias = "depthTestEnable")]
    depth_test_enable: Bool32,
    #[doc(alias = "depthWriteEnable")]
    depth_write_enable: Bool32,
    #[doc(alias = "depthCompareOp")]
    depth_compare_op: CompareOp,
    #[doc(alias = "depthBoundsTestEnable")]
    depth_bounds_test_enable: Bool32,
    #[doc(alias = "stencilTestEnable")]
    stencil_test_enable: Bool32,
    # [doc = include_str ! ("../../../doc/VkPipelineDepthStencilStateCreateInfo$front.md")]
    front: StencilOpState,
    back: StencilOpState,
    #[doc(alias = "minDepthBounds")]
    min_depth_bounds: f32,
    #[doc(alias = "maxDepthBounds")]
    max_depth_bounds: f32,
}
# [doc = include_str ! ("../../../doc/VkGraphicsPipelineCreateInfo.md")]
#[doc(alias = "VkGraphicsPipelineCreateInfo")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct GraphicsPipelineCreateInfo {
    #[doc(alias = "sType")]
    s_type: StructureType,
    #[doc(alias = "pNext")]
    p_next: *const BaseInStructure,
    # [doc = include_str ! ("../../../doc/VkGraphicsPipelineCreateInfo$flags.md")]
    flags: PipelineCreateFlags,
    #[doc(alias = "stageCount")]
    stage_count: u32,
    #[doc(alias = "pStages")]
    stages: *const PipelineShaderStageCreateInfo,
    #[doc(alias = "pVertexInputState")]
    vertex_input_state: *const PipelineVertexInputStateCreateInfo,
    #[doc(alias = "pInputAssemblyState")]
    input_assembly_state: *const PipelineInputAssemblyStateCreateInfo,
    #[doc(alias = "pTessellationState")]
    tessellation_state: *const PipelineTessellationStateCreateInfo,
    #[doc(alias = "pViewportState")]
    viewport_state: *const PipelineViewportStateCreateInfo,
    #[doc(alias = "pRasterizationState")]
    rasterization_state: *const PipelineRasterizationStateCreateInfo,
    #[doc(alias = "pMultisampleState")]
    multisample_state: *const PipelineMultisampleStateCreateInfo,
    #[doc(alias = "pDepthStencilState")]
    depth_stencil_state: *const PipelineDepthStencilStateCreateInfo,
    #[doc(alias = "pColorBlendState")]
    color_blend_state: *const PipelineColorBlendStateCreateInfo,
    #[doc(alias = "pDynamicState")]
    dynamic_state: *const PipelineDynamicStateCreateInfo,
    # [doc = include_str ! ("../../../doc/VkGraphicsPipelineCreateInfo$layout.md")]
    layout: PipelineLayout,
    #[doc(alias = "renderPass")]
    render_pass: RenderPass,
    # [doc = include_str ! ("../../../doc/VkGraphicsPipelineCreateInfo$subpass.md")]
    subpass: u32,
    #[doc(alias = "basePipelineHandle")]
    base_pipeline_handle: Pipeline,
    #[doc(alias = "basePipelineIndex")]
    base_pipeline_index: i32,
}
# [doc = include_str ! ("../../../doc/VkPipelineCacheCreateInfo.md")]
#[doc(alias = "VkPipelineCacheCreateInfo")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PipelineCacheCreateInfo {
    #[doc(alias = "sType")]
    s_type: StructureType,
    #[doc(alias = "pNext")]
    p_next: *const BaseInStructure,
    # [doc = include_str ! ("../../../doc/VkPipelineCacheCreateInfo$flags.md")]
    flags: PipelineCacheCreateFlags,
    #[doc(alias = "initialDataSize")]
    initial_data_size: usize,
    #[doc(alias = "pInitialData")]
    initial_data: *const std::ffi::c_void,
}
# [doc = include_str ! ("../../../doc/VkPipelineCacheHeaderVersionOne.md")]
#[doc(alias = "VkPipelineCacheHeaderVersionOne")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PipelineCacheHeaderVersionOne {
    #[doc(alias = "headerSize")]
    header_size: u32,
    #[doc(alias = "headerVersion")]
    header_version: PipelineCacheHeaderVersion,
    #[doc(alias = "vendorID")]
    vendor_id: u32,
    #[doc(alias = "deviceID")]
    device_id: u32,
    #[doc(alias = "pipelineCacheUUID")]
    pipeline_cache_uuid: [u8; UUID_SIZE as usize],
}
# [doc = include_str ! ("../../../doc/VkPushConstantRange.md")]
#[doc(alias = "VkPushConstantRange")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PushConstantRange {
    #[doc(alias = "stageFlags")]
    stage_flags: ShaderStageFlags,
    # [doc = include_str ! ("../../../doc/VkPushConstantRange$offset.md")]
    offset: u32,
    size: u32,
}
# [doc = include_str ! ("../../../doc/VkPipelineLayoutCreateInfo.md")]
#[doc(alias = "VkPipelineLayoutCreateInfo")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PipelineLayoutCreateInfo {
    #[doc(alias = "sType")]
    s_type: StructureType,
    #[doc(alias = "pNext")]
    p_next: *const BaseInStructure,
    # [doc = include_str ! ("../../../doc/VkPipelineLayoutCreateInfo$flags.md")]
    flags: PipelineLayoutCreateFlags,
    #[doc(alias = "setLayoutCount")]
    set_layout_count: u32,
    #[doc(alias = "pSetLayouts")]
    set_layouts: *const DescriptorSetLayout,
    #[doc(alias = "pushConstantRangeCount")]
    push_constant_range_count: u32,
    #[doc(alias = "pPushConstantRanges")]
    push_constant_ranges: *const PushConstantRange,
}
# [doc = include_str ! ("../../../doc/VkSamplerCreateInfo.md")]
#[doc(alias = "VkSamplerCreateInfo")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct SamplerCreateInfo {
    #[doc(alias = "sType")]
    s_type: StructureType,
    #[doc(alias = "pNext")]
    p_next: *const BaseInStructure,
    # [doc = include_str ! ("../../../doc/VkSamplerCreateInfo$flags.md")]
    flags: SamplerCreateFlags,
    #[doc(alias = "magFilter")]
    mag_filter: Filter,
    #[doc(alias = "minFilter")]
    min_filter: Filter,
    #[doc(alias = "mipmapMode")]
    mipmap_mode: SamplerMipmapMode,
    #[doc(alias = "addressModeU")]
    address_mode_u: SamplerAddressMode,
    #[doc(alias = "addressModeV")]
    address_mode_v: SamplerAddressMode,
    #[doc(alias = "addressModeW")]
    address_mode_w: SamplerAddressMode,
    #[doc(alias = "mipLodBias")]
    mip_lod_bias: f32,
    #[doc(alias = "anisotropyEnable")]
    anisotropy_enable: Bool32,
    #[doc(alias = "maxAnisotropy")]
    max_anisotropy: f32,
    #[doc(alias = "compareEnable")]
    compare_enable: Bool32,
    #[doc(alias = "compareOp")]
    compare_op: CompareOp,
    #[doc(alias = "minLod")]
    min_lod: f32,
    #[doc(alias = "maxLod")]
    max_lod: f32,
    #[doc(alias = "borderColor")]
    border_color: BorderColor,
    #[doc(alias = "unnormalizedCoordinates")]
    unnormalized_coordinates: Bool32,
}
# [doc = include_str ! ("../../../doc/VkCommandPoolCreateInfo.md")]
#[doc(alias = "VkCommandPoolCreateInfo")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct CommandPoolCreateInfo {
    #[doc(alias = "sType")]
    s_type: StructureType,
    #[doc(alias = "pNext")]
    p_next: *const BaseInStructure,
    # [doc = include_str ! ("../../../doc/VkCommandPoolCreateInfo$flags.md")]
    flags: CommandPoolCreateFlags,
    #[doc(alias = "queueFamilyIndex")]
    queue_family_index: u32,
}
# [doc = include_str ! ("../../../doc/VkCommandBufferAllocateInfo.md")]
#[doc(alias = "VkCommandBufferAllocateInfo")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct CommandBufferAllocateInfo {
    #[doc(alias = "sType")]
    s_type: StructureType,
    #[doc(alias = "pNext")]
    p_next: *const BaseInStructure,
    #[doc(alias = "commandPool")]
    command_pool: CommandPool,
    # [doc = include_str ! ("../../../doc/VkCommandBufferAllocateInfo$level.md")]
    level: CommandBufferLevel,
    #[doc(alias = "commandBufferCount")]
    command_buffer_count: u32,
}
# [doc = include_str ! ("../../../doc/VkCommandBufferInheritanceInfo.md")]
#[doc(alias = "VkCommandBufferInheritanceInfo")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct CommandBufferInheritanceInfo {
    #[doc(alias = "sType")]
    s_type: StructureType,
    #[doc(alias = "pNext")]
    p_next: *const BaseInStructure,
    #[doc(alias = "renderPass")]
    render_pass: RenderPass,
    # [doc = include_str ! ("../../../doc/VkCommandBufferInheritanceInfo$subpass.md")]
    subpass: u32,
    # [doc = include_str ! ("../../../doc/VkCommandBufferInheritanceInfo$framebuffer.md")]
    framebuffer: Framebuffer,
    #[doc(alias = "occlusionQueryEnable")]
    occlusion_query_enable: Bool32,
    #[doc(alias = "queryFlags")]
    query_flags: QueryControlFlags,
    #[doc(alias = "pipelineStatistics")]
    pipeline_statistics: QueryPipelineStatisticFlags,
}
# [doc = include_str ! ("../../../doc/VkCommandBufferBeginInfo.md")]
#[doc(alias = "VkCommandBufferBeginInfo")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct CommandBufferBeginInfo {
    #[doc(alias = "sType")]
    s_type: StructureType,
    #[doc(alias = "pNext")]
    p_next: *const BaseInStructure,
    # [doc = include_str ! ("../../../doc/VkCommandBufferBeginInfo$flags.md")]
    flags: CommandBufferUsageFlags,
    #[doc(alias = "pInheritanceInfo")]
    inheritance_info: *const CommandBufferInheritanceInfo,
}
# [doc = include_str ! ("../../../doc/VkRenderPassBeginInfo.md")]
#[doc(alias = "VkRenderPassBeginInfo")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct RenderPassBeginInfo {
    #[doc(alias = "sType")]
    s_type: StructureType,
    #[doc(alias = "pNext")]
    p_next: *const BaseInStructure,
    #[doc(alias = "renderPass")]
    render_pass: RenderPass,
    # [doc = include_str ! ("../../../doc/VkRenderPassBeginInfo$framebuffer.md")]
    framebuffer: Framebuffer,
    #[doc(alias = "renderArea")]
    render_area: Rect2D,
    #[doc(alias = "clearValueCount")]
    clear_value_count: u32,
    #[doc(alias = "pClearValues")]
    clear_values: *const ClearValue,
}
# [doc = include_str ! ("../../../doc/VkClearDepthStencilValue.md")]
#[doc(alias = "VkClearDepthStencilValue")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct ClearDepthStencilValue {
    # [doc = include_str ! ("../../../doc/VkClearDepthStencilValue$depth.md")]
    depth: f32,
    # [doc = include_str ! ("../../../doc/VkClearDepthStencilValue$stencil.md")]
    stencil: u32,
}
# [doc = include_str ! ("../../../doc/VkClearAttachment.md")]
#[doc(alias = "VkClearAttachment")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct ClearAttachment {
    #[doc(alias = "aspectMask")]
    aspect_mask: ImageAspectFlags,
    #[doc(alias = "colorAttachment")]
    color_attachment: u32,
    #[doc(alias = "clearValue")]
    clear_value: ClearValue,
}
# [doc = include_str ! ("../../../doc/VkAttachmentDescription.md")]
#[doc(alias = "VkAttachmentDescription")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct AttachmentDescription {
    # [doc = include_str ! ("../../../doc/VkAttachmentDescription$flags.md")]
    flags: AttachmentDescriptionFlags,
    # [doc = include_str ! ("../../../doc/VkAttachmentDescription$format.md")]
    format: Format,
    # [doc = include_str ! ("../../../doc/VkAttachmentDescription$samples.md")]
    samples: SampleCountFlagBits,
    #[doc(alias = "loadOp")]
    load_op: AttachmentLoadOp,
    #[doc(alias = "storeOp")]
    store_op: AttachmentStoreOp,
    #[doc(alias = "stencilLoadOp")]
    stencil_load_op: AttachmentLoadOp,
    #[doc(alias = "stencilStoreOp")]
    stencil_store_op: AttachmentStoreOp,
    #[doc(alias = "initialLayout")]
    initial_layout: ImageLayout,
    #[doc(alias = "finalLayout")]
    final_layout: ImageLayout,
}
# [doc = include_str ! ("../../../doc/VkAttachmentReference.md")]
#[doc(alias = "VkAttachmentReference")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct AttachmentReference {
    # [doc = include_str ! ("../../../doc/VkAttachmentReference$attachment.md")]
    attachment: u32,
    # [doc = include_str ! ("../../../doc/VkAttachmentReference$layout.md")]
    layout: ImageLayout,
}
# [doc = include_str ! ("../../../doc/VkSubpassDescription.md")]
#[doc(alias = "VkSubpassDescription")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct SubpassDescription {
    # [doc = include_str ! ("../../../doc/VkSubpassDescription$flags.md")]
    flags: SubpassDescriptionFlags,
    #[doc(alias = "pipelineBindPoint")]
    pipeline_bind_point: PipelineBindPoint,
    #[doc(alias = "inputAttachmentCount")]
    input_attachment_count: u32,
    #[doc(alias = "pInputAttachments")]
    input_attachments: *const AttachmentReference,
    #[doc(alias = "colorAttachmentCount")]
    color_attachment_count: u32,
    #[doc(alias = "pColorAttachments")]
    color_attachments: *const AttachmentReference,
    #[doc(alias = "pResolveAttachments")]
    resolve_attachments: *const AttachmentReference,
    #[doc(alias = "pDepthStencilAttachment")]
    depth_stencil_attachment: *const AttachmentReference,
    #[doc(alias = "preserveAttachmentCount")]
    preserve_attachment_count: u32,
    #[doc(alias = "pPreserveAttachments")]
    preserve_attachments: *const u32,
}
# [doc = include_str ! ("../../../doc/VkSubpassDependency.md")]
#[doc(alias = "VkSubpassDependency")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct SubpassDependency {
    #[doc(alias = "srcSubpass")]
    src_subpass: u32,
    #[doc(alias = "dstSubpass")]
    dst_subpass: u32,
    #[doc(alias = "srcStageMask")]
    src_stage_mask: PipelineStageFlags,
    #[doc(alias = "dstStageMask")]
    dst_stage_mask: PipelineStageFlags,
    #[doc(alias = "srcAccessMask")]
    src_access_mask: AccessFlags,
    #[doc(alias = "dstAccessMask")]
    dst_access_mask: AccessFlags,
    #[doc(alias = "dependencyFlags")]
    dependency_flags: DependencyFlags,
}
# [doc = include_str ! ("../../../doc/VkRenderPassCreateInfo.md")]
#[doc(alias = "VkRenderPassCreateInfo")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct RenderPassCreateInfo {
    #[doc(alias = "sType")]
    s_type: StructureType,
    #[doc(alias = "pNext")]
    p_next: *const BaseInStructure,
    # [doc = include_str ! ("../../../doc/VkRenderPassCreateInfo$flags.md")]
    flags: RenderPassCreateFlags,
    #[doc(alias = "attachmentCount")]
    attachment_count: u32,
    #[doc(alias = "pAttachments")]
    attachments: *const AttachmentDescription,
    #[doc(alias = "subpassCount")]
    subpass_count: u32,
    #[doc(alias = "pSubpasses")]
    subpasses: *const SubpassDescription,
    #[doc(alias = "dependencyCount")]
    dependency_count: u32,
    #[doc(alias = "pDependencies")]
    dependencies: *const SubpassDependency,
}
# [doc = include_str ! ("../../../doc/VkEventCreateInfo.md")]
#[doc(alias = "VkEventCreateInfo")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct EventCreateInfo {
    #[doc(alias = "sType")]
    s_type: StructureType,
    #[doc(alias = "pNext")]
    p_next: *const BaseInStructure,
    # [doc = include_str ! ("../../../doc/VkEventCreateInfo$flags.md")]
    flags: EventCreateFlags,
}
# [doc = include_str ! ("../../../doc/VkFenceCreateInfo.md")]
#[doc(alias = "VkFenceCreateInfo")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct FenceCreateInfo {
    #[doc(alias = "sType")]
    s_type: StructureType,
    #[doc(alias = "pNext")]
    p_next: *const BaseInStructure,
    # [doc = include_str ! ("../../../doc/VkFenceCreateInfo$flags.md")]
    flags: FenceCreateFlags,
}
# [doc = include_str ! ("../../../doc/VkPhysicalDeviceFeatures.md")]
#[doc(alias = "VkPhysicalDeviceFeatures")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PhysicalDeviceFeatures {
    #[doc(alias = "robustBufferAccess")]
    robust_buffer_access: Bool32,
    #[doc(alias = "fullDrawIndexUint32")]
    full_draw_index_uint32: Bool32,
    #[doc(alias = "imageCubeArray")]
    image_cube_array: Bool32,
    #[doc(alias = "independentBlend")]
    independent_blend: Bool32,
    #[doc(alias = "geometryShader")]
    geometry_shader: Bool32,
    #[doc(alias = "tessellationShader")]
    tessellation_shader: Bool32,
    #[doc(alias = "sampleRateShading")]
    sample_rate_shading: Bool32,
    #[doc(alias = "dualSrcBlend")]
    dual_src_blend: Bool32,
    #[doc(alias = "logicOp")]
    logic_op: Bool32,
    #[doc(alias = "multiDrawIndirect")]
    multi_draw_indirect: Bool32,
    #[doc(alias = "drawIndirectFirstInstance")]
    draw_indirect_first_instance: Bool32,
    #[doc(alias = "depthClamp")]
    depth_clamp: Bool32,
    #[doc(alias = "depthBiasClamp")]
    depth_bias_clamp: Bool32,
    #[doc(alias = "fillModeNonSolid")]
    fill_mode_non_solid: Bool32,
    #[doc(alias = "depthBounds")]
    depth_bounds: Bool32,
    #[doc(alias = "wideLines")]
    wide_lines: Bool32,
    #[doc(alias = "largePoints")]
    large_points: Bool32,
    #[doc(alias = "alphaToOne")]
    alpha_to_one: Bool32,
    #[doc(alias = "multiViewport")]
    multi_viewport: Bool32,
    #[doc(alias = "samplerAnisotropy")]
    sampler_anisotropy: Bool32,
    #[doc(alias = "textureCompressionETC2")]
    texture_compression_etc2: Bool32,
    #[doc(alias = "textureCompressionASTC_LDR")]
    texture_compression_astc_ldr: Bool32,
    #[doc(alias = "textureCompressionBC")]
    texture_compression_bc: Bool32,
    #[doc(alias = "occlusionQueryPrecise")]
    occlusion_query_precise: Bool32,
    #[doc(alias = "pipelineStatisticsQuery")]
    pipeline_statistics_query: Bool32,
    #[doc(alias = "vertexPipelineStoresAndAtomics")]
    vertex_pipeline_stores_and_atomics: Bool32,
    #[doc(alias = "fragmentStoresAndAtomics")]
    fragment_stores_and_atomics: Bool32,
    #[doc(alias = "shaderTessellationAndGeometryPointSize")]
    shader_tessellation_and_geometry_point_size: Bool32,
    #[doc(alias = "shaderImageGatherExtended")]
    shader_image_gather_extended: Bool32,
    #[doc(alias = "shaderStorageImageExtendedFormats")]
    shader_storage_image_extended_formats: Bool32,
    #[doc(alias = "shaderStorageImageMultisample")]
    shader_storage_image_multisample: Bool32,
    #[doc(alias = "shaderStorageImageReadWithoutFormat")]
    shader_storage_image_read_without_format: Bool32,
    #[doc(alias = "shaderStorageImageWriteWithoutFormat")]
    shader_storage_image_write_without_format: Bool32,
    #[doc(alias = "shaderUniformBufferArrayDynamicIndexing")]
    shader_uniform_buffer_array_dynamic_indexing: Bool32,
    #[doc(alias = "shaderSampledImageArrayDynamicIndexing")]
    shader_sampled_image_array_dynamic_indexing: Bool32,
    #[doc(alias = "shaderStorageBufferArrayDynamicIndexing")]
    shader_storage_buffer_array_dynamic_indexing: Bool32,
    #[doc(alias = "shaderStorageImageArrayDynamicIndexing")]
    shader_storage_image_array_dynamic_indexing: Bool32,
    #[doc(alias = "shaderClipDistance")]
    shader_clip_distance: Bool32,
    #[doc(alias = "shaderCullDistance")]
    shader_cull_distance: Bool32,
    #[doc(alias = "shaderFloat64")]
    shader_float64: Bool32,
    #[doc(alias = "shaderInt64")]
    shader_int64: Bool32,
    #[doc(alias = "shaderInt16")]
    shader_int16: Bool32,
    #[doc(alias = "shaderResourceResidency")]
    shader_resource_residency: Bool32,
    #[doc(alias = "shaderResourceMinLod")]
    shader_resource_min_lod: Bool32,
    #[doc(alias = "sparseBinding")]
    sparse_binding: Bool32,
    #[doc(alias = "sparseResidencyBuffer")]
    sparse_residency_buffer: Bool32,
    #[doc(alias = "sparseResidencyImage2D")]
    sparse_residency_image2_d: Bool32,
    #[doc(alias = "sparseResidencyImage3D")]
    sparse_residency_image3_d: Bool32,
    #[doc(alias = "sparseResidency2Samples")]
    sparse_residency2_samples: Bool32,
    #[doc(alias = "sparseResidency4Samples")]
    sparse_residency4_samples: Bool32,
    #[doc(alias = "sparseResidency8Samples")]
    sparse_residency8_samples: Bool32,
    #[doc(alias = "sparseResidency16Samples")]
    sparse_residency16_samples: Bool32,
    #[doc(alias = "sparseResidencyAliased")]
    sparse_residency_aliased: Bool32,
    #[doc(alias = "variableMultisampleRate")]
    variable_multisample_rate: Bool32,
    #[doc(alias = "inheritedQueries")]
    inherited_queries: Bool32,
}
# [doc = include_str ! ("../../../doc/VkPhysicalDeviceSparseProperties.md")]
#[doc(alias = "VkPhysicalDeviceSparseProperties")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PhysicalDeviceSparseProperties {
    #[doc(alias = "residencyStandard2DBlockShape")]
    residency_standard2_d_block_shape: Bool32,
    #[doc(alias = "residencyStandard2DMultisampleBlockShape")]
    residency_standard2_d_multisample_block_shape: Bool32,
    #[doc(alias = "residencyStandard3DBlockShape")]
    residency_standard3_d_block_shape: Bool32,
    #[doc(alias = "residencyAlignedMipSize")]
    residency_aligned_mip_size: Bool32,
    #[doc(alias = "residencyNonResidentStrict")]
    residency_non_resident_strict: Bool32,
}
# [doc = include_str ! ("../../../doc/VkPhysicalDeviceLimits.md")]
#[doc(alias = "VkPhysicalDeviceLimits")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PhysicalDeviceLimits {
    #[doc(alias = "maxImageDimension1D")]
    max_image_dimension1_d: u32,
    #[doc(alias = "maxImageDimension2D")]
    max_image_dimension2_d: u32,
    #[doc(alias = "maxImageDimension3D")]
    max_image_dimension3_d: u32,
    #[doc(alias = "maxImageDimensionCube")]
    max_image_dimension_cube: u32,
    #[doc(alias = "maxImageArrayLayers")]
    max_image_array_layers: u32,
    #[doc(alias = "maxTexelBufferElements")]
    max_texel_buffer_elements: u32,
    #[doc(alias = "maxUniformBufferRange")]
    max_uniform_buffer_range: u32,
    #[doc(alias = "maxStorageBufferRange")]
    max_storage_buffer_range: u32,
    #[doc(alias = "maxPushConstantsSize")]
    max_push_constants_size: u32,
    #[doc(alias = "maxMemoryAllocationCount")]
    max_memory_allocation_count: u32,
    #[doc(alias = "maxSamplerAllocationCount")]
    max_sampler_allocation_count: u32,
    #[doc(alias = "bufferImageGranularity")]
    buffer_image_granularity: DeviceSize,
    #[doc(alias = "sparseAddressSpaceSize")]
    sparse_address_space_size: DeviceSize,
    #[doc(alias = "maxBoundDescriptorSets")]
    max_bound_descriptor_sets: u32,
    #[doc(alias = "maxPerStageDescriptorSamplers")]
    max_per_stage_descriptor_samplers: u32,
    #[doc(alias = "maxPerStageDescriptorUniformBuffers")]
    max_per_stage_descriptor_uniform_buffers: u32,
    #[doc(alias = "maxPerStageDescriptorStorageBuffers")]
    max_per_stage_descriptor_storage_buffers: u32,
    #[doc(alias = "maxPerStageDescriptorSampledImages")]
    max_per_stage_descriptor_sampled_images: u32,
    #[doc(alias = "maxPerStageDescriptorStorageImages")]
    max_per_stage_descriptor_storage_images: u32,
    #[doc(alias = "maxPerStageDescriptorInputAttachments")]
    max_per_stage_descriptor_input_attachments: u32,
    #[doc(alias = "maxPerStageResources")]
    max_per_stage_resources: u32,
    #[doc(alias = "maxDescriptorSetSamplers")]
    max_descriptor_set_samplers: u32,
    #[doc(alias = "maxDescriptorSetUniformBuffers")]
    max_descriptor_set_uniform_buffers: u32,
    #[doc(alias = "maxDescriptorSetUniformBuffersDynamic")]
    max_descriptor_set_uniform_buffers_dynamic: u32,
    #[doc(alias = "maxDescriptorSetStorageBuffers")]
    max_descriptor_set_storage_buffers: u32,
    #[doc(alias = "maxDescriptorSetStorageBuffersDynamic")]
    max_descriptor_set_storage_buffers_dynamic: u32,
    #[doc(alias = "maxDescriptorSetSampledImages")]
    max_descriptor_set_sampled_images: u32,
    #[doc(alias = "maxDescriptorSetStorageImages")]
    max_descriptor_set_storage_images: u32,
    #[doc(alias = "maxDescriptorSetInputAttachments")]
    max_descriptor_set_input_attachments: u32,
    #[doc(alias = "maxVertexInputAttributes")]
    max_vertex_input_attributes: u32,
    #[doc(alias = "maxVertexInputBindings")]
    max_vertex_input_bindings: u32,
    #[doc(alias = "maxVertexInputAttributeOffset")]
    max_vertex_input_attribute_offset: u32,
    #[doc(alias = "maxVertexInputBindingStride")]
    max_vertex_input_binding_stride: u32,
    #[doc(alias = "maxVertexOutputComponents")]
    max_vertex_output_components: u32,
    #[doc(alias = "maxTessellationGenerationLevel")]
    max_tessellation_generation_level: u32,
    #[doc(alias = "maxTessellationPatchSize")]
    max_tessellation_patch_size: u32,
    #[doc(alias = "maxTessellationControlPerVertexInputComponents")]
    max_tessellation_control_per_vertex_input_components: u32,
    #[doc(alias = "maxTessellationControlPerVertexOutputComponents")]
    max_tessellation_control_per_vertex_output_components: u32,
    #[doc(alias = "maxTessellationControlPerPatchOutputComponents")]
    max_tessellation_control_per_patch_output_components: u32,
    #[doc(alias = "maxTessellationControlTotalOutputComponents")]
    max_tessellation_control_total_output_components: u32,
    #[doc(alias = "maxTessellationEvaluationInputComponents")]
    max_tessellation_evaluation_input_components: u32,
    #[doc(alias = "maxTessellationEvaluationOutputComponents")]
    max_tessellation_evaluation_output_components: u32,
    #[doc(alias = "maxGeometryShaderInvocations")]
    max_geometry_shader_invocations: u32,
    #[doc(alias = "maxGeometryInputComponents")]
    max_geometry_input_components: u32,
    #[doc(alias = "maxGeometryOutputComponents")]
    max_geometry_output_components: u32,
    #[doc(alias = "maxGeometryOutputVertices")]
    max_geometry_output_vertices: u32,
    #[doc(alias = "maxGeometryTotalOutputComponents")]
    max_geometry_total_output_components: u32,
    #[doc(alias = "maxFragmentInputComponents")]
    max_fragment_input_components: u32,
    #[doc(alias = "maxFragmentOutputAttachments")]
    max_fragment_output_attachments: u32,
    #[doc(alias = "maxFragmentDualSrcAttachments")]
    max_fragment_dual_src_attachments: u32,
    #[doc(alias = "maxFragmentCombinedOutputResources")]
    max_fragment_combined_output_resources: u32,
    #[doc(alias = "maxComputeSharedMemorySize")]
    max_compute_shared_memory_size: u32,
    #[doc(alias = "maxComputeWorkGroupCount")]
    max_compute_work_group_count: [u32; 3 as usize],
    #[doc(alias = "maxComputeWorkGroupInvocations")]
    max_compute_work_group_invocations: u32,
    #[doc(alias = "maxComputeWorkGroupSize")]
    max_compute_work_group_size: [u32; 3 as usize],
    #[doc(alias = "subPixelPrecisionBits")]
    sub_pixel_precision_bits: u32,
    #[doc(alias = "subTexelPrecisionBits")]
    sub_texel_precision_bits: u32,
    #[doc(alias = "mipmapPrecisionBits")]
    mipmap_precision_bits: u32,
    #[doc(alias = "maxDrawIndexedIndexValue")]
    max_draw_indexed_index_value: u32,
    #[doc(alias = "maxDrawIndirectCount")]
    max_draw_indirect_count: u32,
    #[doc(alias = "maxSamplerLodBias")]
    max_sampler_lod_bias: f32,
    #[doc(alias = "maxSamplerAnisotropy")]
    max_sampler_anisotropy: f32,
    #[doc(alias = "maxViewports")]
    max_viewports: u32,
    #[doc(alias = "maxViewportDimensions")]
    max_viewport_dimensions: [u32; 2 as usize],
    #[doc(alias = "viewportBoundsRange")]
    viewport_bounds_range: [f32; 2 as usize],
    #[doc(alias = "viewportSubPixelBits")]
    viewport_sub_pixel_bits: u32,
    #[doc(alias = "minMemoryMapAlignment")]
    min_memory_map_alignment: usize,
    #[doc(alias = "minTexelBufferOffsetAlignment")]
    min_texel_buffer_offset_alignment: DeviceSize,
    #[doc(alias = "minUniformBufferOffsetAlignment")]
    min_uniform_buffer_offset_alignment: DeviceSize,
    #[doc(alias = "minStorageBufferOffsetAlignment")]
    min_storage_buffer_offset_alignment: DeviceSize,
    #[doc(alias = "minTexelOffset")]
    min_texel_offset: i32,
    #[doc(alias = "maxTexelOffset")]
    max_texel_offset: u32,
    #[doc(alias = "minTexelGatherOffset")]
    min_texel_gather_offset: i32,
    #[doc(alias = "maxTexelGatherOffset")]
    max_texel_gather_offset: u32,
    #[doc(alias = "minInterpolationOffset")]
    min_interpolation_offset: f32,
    #[doc(alias = "maxInterpolationOffset")]
    max_interpolation_offset: f32,
    #[doc(alias = "subPixelInterpolationOffsetBits")]
    sub_pixel_interpolation_offset_bits: u32,
    #[doc(alias = "maxFramebufferWidth")]
    max_framebuffer_width: u32,
    #[doc(alias = "maxFramebufferHeight")]
    max_framebuffer_height: u32,
    #[doc(alias = "maxFramebufferLayers")]
    max_framebuffer_layers: u32,
    #[doc(alias = "framebufferColorSampleCounts")]
    framebuffer_color_sample_counts: SampleCountFlags,
    #[doc(alias = "framebufferDepthSampleCounts")]
    framebuffer_depth_sample_counts: SampleCountFlags,
    #[doc(alias = "framebufferStencilSampleCounts")]
    framebuffer_stencil_sample_counts: SampleCountFlags,
    #[doc(alias = "framebufferNoAttachmentsSampleCounts")]
    framebuffer_no_attachments_sample_counts: SampleCountFlags,
    #[doc(alias = "maxColorAttachments")]
    max_color_attachments: u32,
    #[doc(alias = "sampledImageColorSampleCounts")]
    sampled_image_color_sample_counts: SampleCountFlags,
    #[doc(alias = "sampledImageIntegerSampleCounts")]
    sampled_image_integer_sample_counts: SampleCountFlags,
    #[doc(alias = "sampledImageDepthSampleCounts")]
    sampled_image_depth_sample_counts: SampleCountFlags,
    #[doc(alias = "sampledImageStencilSampleCounts")]
    sampled_image_stencil_sample_counts: SampleCountFlags,
    #[doc(alias = "storageImageSampleCounts")]
    storage_image_sample_counts: SampleCountFlags,
    #[doc(alias = "maxSampleMaskWords")]
    max_sample_mask_words: u32,
    #[doc(alias = "timestampComputeAndGraphics")]
    timestamp_compute_and_graphics: Bool32,
    #[doc(alias = "timestampPeriod")]
    timestamp_period: f32,
    #[doc(alias = "maxClipDistances")]
    max_clip_distances: u32,
    #[doc(alias = "maxCullDistances")]
    max_cull_distances: u32,
    #[doc(alias = "maxCombinedClipAndCullDistances")]
    max_combined_clip_and_cull_distances: u32,
    #[doc(alias = "discreteQueuePriorities")]
    discrete_queue_priorities: u32,
    #[doc(alias = "pointSizeRange")]
    point_size_range: [f32; 2 as usize],
    #[doc(alias = "lineWidthRange")]
    line_width_range: [f32; 2 as usize],
    #[doc(alias = "pointSizeGranularity")]
    point_size_granularity: f32,
    #[doc(alias = "lineWidthGranularity")]
    line_width_granularity: f32,
    #[doc(alias = "strictLines")]
    strict_lines: Bool32,
    #[doc(alias = "standardSampleLocations")]
    standard_sample_locations: Bool32,
    #[doc(alias = "optimalBufferCopyOffsetAlignment")]
    optimal_buffer_copy_offset_alignment: DeviceSize,
    #[doc(alias = "optimalBufferCopyRowPitchAlignment")]
    optimal_buffer_copy_row_pitch_alignment: DeviceSize,
    #[doc(alias = "nonCoherentAtomSize")]
    non_coherent_atom_size: DeviceSize,
}
# [doc = include_str ! ("../../../doc/VkSemaphoreCreateInfo.md")]
#[doc(alias = "VkSemaphoreCreateInfo")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct SemaphoreCreateInfo {
    #[doc(alias = "sType")]
    s_type: StructureType,
    #[doc(alias = "pNext")]
    p_next: *const BaseInStructure,
    # [doc = include_str ! ("../../../doc/VkSemaphoreCreateInfo$flags.md")]
    flags: SemaphoreCreateFlags,
}
# [doc = include_str ! ("../../../doc/VkQueryPoolCreateInfo.md")]
#[doc(alias = "VkQueryPoolCreateInfo")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct QueryPoolCreateInfo {
    #[doc(alias = "sType")]
    s_type: StructureType,
    #[doc(alias = "pNext")]
    p_next: *const BaseInStructure,
    # [doc = include_str ! ("../../../doc/VkQueryPoolCreateInfo$flags.md")]
    flags: QueryPoolCreateFlags,
    #[doc(alias = "queryType")]
    query_type: QueryType,
    #[doc(alias = "queryCount")]
    query_count: u32,
    #[doc(alias = "pipelineStatistics")]
    pipeline_statistics: QueryPipelineStatisticFlags,
}
# [doc = include_str ! ("../../../doc/VkFramebufferCreateInfo.md")]
#[doc(alias = "VkFramebufferCreateInfo")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct FramebufferCreateInfo {
    #[doc(alias = "sType")]
    s_type: StructureType,
    #[doc(alias = "pNext")]
    p_next: *const BaseInStructure,
    # [doc = include_str ! ("../../../doc/VkFramebufferCreateInfo$flags.md")]
    flags: FramebufferCreateFlags,
    #[doc(alias = "renderPass")]
    render_pass: RenderPass,
    #[doc(alias = "attachmentCount")]
    attachment_count: u32,
    #[doc(alias = "pAttachments")]
    attachments: *const ImageView,
    # [doc = include_str ! ("../../../doc/VkFramebufferCreateInfo$width.md")]
    width: u32,
    height: u32,
    layers: u32,
}
# [doc = include_str ! ("../../../doc/VkDrawIndirectCommand.md")]
#[doc(alias = "VkDrawIndirectCommand")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct DrawIndirectCommand {
    #[doc(alias = "vertexCount")]
    vertex_count: u32,
    #[doc(alias = "instanceCount")]
    instance_count: u32,
    #[doc(alias = "firstVertex")]
    first_vertex: u32,
    #[doc(alias = "firstInstance")]
    first_instance: u32,
}
# [doc = include_str ! ("../../../doc/VkDrawIndexedIndirectCommand.md")]
#[doc(alias = "VkDrawIndexedIndirectCommand")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct DrawIndexedIndirectCommand {
    #[doc(alias = "indexCount")]
    index_count: u32,
    #[doc(alias = "instanceCount")]
    instance_count: u32,
    #[doc(alias = "firstIndex")]
    first_index: u32,
    #[doc(alias = "vertexOffset")]
    vertex_offset: i32,
    #[doc(alias = "firstInstance")]
    first_instance: u32,
}
# [doc = include_str ! ("../../../doc/VkDispatchIndirectCommand.md")]
#[doc(alias = "VkDispatchIndirectCommand")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct DispatchIndirectCommand {
    # [doc = include_str ! ("../../../doc/VkDispatchIndirectCommand$x.md")]
    x: u32,
    # [doc = include_str ! ("../../../doc/VkDispatchIndirectCommand$y.md")]
    y: u32,
    # [doc = include_str ! ("../../../doc/VkDispatchIndirectCommand$z.md")]
    z: u32,
}
# [doc = include_str ! ("../../../doc/VkSubmitInfo.md")]
#[doc(alias = "VkSubmitInfo")]
#[derive(Clone, Copy)]
#[repr(C)]
pub struct SubmitInfo {
    #[doc(alias = "sType")]
    s_type: StructureType,
    #[doc(alias = "pNext")]
    p_next: *const BaseInStructure,
    #[doc(alias = "waitSemaphoreCount")]
    wait_semaphore_count: u32,
    #[doc(alias = "pWaitSemaphores")]
    wait_semaphores: *const Semaphore,
    #[doc(alias = "pWaitDstStageMask")]
    wait_dst_stage_mask: *const PipelineStageFlags,
    #[doc(alias = "commandBufferCount")]
    command_buffer_count: u32,
    #[doc(alias = "pCommandBuffers")]
    command_buffers: *const CommandBuffer,
    #[doc(alias = "signalSemaphoreCount")]
    signal_semaphore_count: u32,
    #[doc(alias = "pSignalSemaphores")]
    signal_semaphores: *const Semaphore,
}
# [doc = include_str ! ("../../../doc/VkClearColorValue.md")]
#[doc(alias = "VkClearColorValue")]
#[repr(C)]
#[derive(Clone, Copy)]
pub union ClearColorValue {
    # [doc = include_str ! ("../../../doc/VkClearColorValue$float32.md")]
    float32: [f32; 4 as usize],
    # [doc = include_str ! ("../../../doc/VkClearColorValue$int32.md")]
    int32: [i32; 4 as usize],
    # [doc = include_str ! ("../../../doc/VkClearColorValue$uint32.md")]
    uint32: [u32; 4 as usize],
}
# [doc = include_str ! ("../../../doc/VkClearValue.md")]
#[doc(alias = "VkClearValue")]
#[repr(C)]
#[derive(Clone, Copy)]
pub union ClearValue {
    # [doc = include_str ! ("../../../doc/VkClearValue$color.md")]
    color: ClearColorValue,
    #[doc(alias = "depthStencil")]
    depth_stencil: ClearDepthStencilValue,
}
# [doc = include_str ! ("../../../doc/VkInstance.md")]
#[derive(Clone, Copy, PartialEq, Eq)]
#[doc(alias = "VkInstance")]
#[repr(transparent)]
pub struct Instance(*mut std::ffi::c_void);
impl Instance {
    pub const fn null() -> Self {
        Self(::std::ptr::null_mut() as _)
    }
}
impl const Default for Instance {
    fn default() -> Self {
        Self::null()
    }
}
# [doc = include_str ! ("../../../doc/VkPhysicalDevice.md")]
#[derive(Clone, Copy, PartialEq, Eq)]
#[doc(alias = "VkPhysicalDevice")]
#[repr(transparent)]
pub struct PhysicalDevice(*mut std::ffi::c_void);
impl PhysicalDevice {
    pub const fn null() -> Self {
        Self(::std::ptr::null_mut() as _)
    }
}
impl const Default for PhysicalDevice {
    fn default() -> Self {
        Self::null()
    }
}
# [doc = include_str ! ("../../../doc/VkDevice.md")]
#[derive(Clone, Copy, PartialEq, Eq)]
#[doc(alias = "VkDevice")]
#[repr(transparent)]
pub struct Device(*mut std::ffi::c_void);
impl Device {
    pub const fn null() -> Self {
        Self(::std::ptr::null_mut() as _)
    }
}
impl const Default for Device {
    fn default() -> Self {
        Self::null()
    }
}
# [doc = include_str ! ("../../../doc/VkQueue.md")]
#[derive(Clone, Copy, PartialEq, Eq)]
#[doc(alias = "VkQueue")]
#[repr(transparent)]
pub struct Queue(*mut std::ffi::c_void);
impl Queue {
    pub const fn null() -> Self {
        Self(::std::ptr::null_mut() as _)
    }
}
impl const Default for Queue {
    fn default() -> Self {
        Self::null()
    }
}
# [doc = include_str ! ("../../../doc/VkCommandBuffer.md")]
#[derive(Clone, Copy, PartialEq, Eq)]
#[doc(alias = "VkCommandBuffer")]
#[repr(transparent)]
pub struct CommandBuffer(*mut std::ffi::c_void);
impl CommandBuffer {
    pub const fn null() -> Self {
        Self(::std::ptr::null_mut() as _)
    }
}
impl const Default for CommandBuffer {
    fn default() -> Self {
        Self::null()
    }
}
# [doc = include_str ! ("../../../doc/VkDeviceMemory.md")]
#[derive(Clone, Copy, PartialEq, Eq)]
#[doc(alias = "VkDeviceMemory")]
#[repr(transparent)]
pub struct DeviceMemory(u64);
impl DeviceMemory {
    pub const fn null() -> Self {
        Self(0)
    }
}
impl const Default for DeviceMemory {
    fn default() -> Self {
        Self::null()
    }
}
# [doc = include_str ! ("../../../doc/VkCommandPool.md")]
#[derive(Clone, Copy, PartialEq, Eq)]
#[doc(alias = "VkCommandPool")]
#[repr(transparent)]
pub struct CommandPool(u64);
impl CommandPool {
    pub const fn null() -> Self {
        Self(0)
    }
}
impl const Default for CommandPool {
    fn default() -> Self {
        Self::null()
    }
}
# [doc = include_str ! ("../../../doc/VkBuffer.md")]
#[derive(Clone, Copy, PartialEq, Eq)]
#[doc(alias = "VkBuffer")]
#[repr(transparent)]
pub struct Buffer(u64);
impl Buffer {
    pub const fn null() -> Self {
        Self(0)
    }
}
impl const Default for Buffer {
    fn default() -> Self {
        Self::null()
    }
}
# [doc = include_str ! ("../../../doc/VkBufferView.md")]
#[derive(Clone, Copy, PartialEq, Eq)]
#[doc(alias = "VkBufferView")]
#[repr(transparent)]
pub struct BufferView(u64);
impl BufferView {
    pub const fn null() -> Self {
        Self(0)
    }
}
impl const Default for BufferView {
    fn default() -> Self {
        Self::null()
    }
}
# [doc = include_str ! ("../../../doc/VkImage.md")]
#[derive(Clone, Copy, PartialEq, Eq)]
#[doc(alias = "VkImage")]
#[repr(transparent)]
pub struct Image(u64);
impl Image {
    pub const fn null() -> Self {
        Self(0)
    }
}
impl const Default for Image {
    fn default() -> Self {
        Self::null()
    }
}
# [doc = include_str ! ("../../../doc/VkImageView.md")]
#[derive(Clone, Copy, PartialEq, Eq)]
#[doc(alias = "VkImageView")]
#[repr(transparent)]
pub struct ImageView(u64);
impl ImageView {
    pub const fn null() -> Self {
        Self(0)
    }
}
impl const Default for ImageView {
    fn default() -> Self {
        Self::null()
    }
}
# [doc = include_str ! ("../../../doc/VkShaderModule.md")]
#[derive(Clone, Copy, PartialEq, Eq)]
#[doc(alias = "VkShaderModule")]
#[repr(transparent)]
pub struct ShaderModule(u64);
impl ShaderModule {
    pub const fn null() -> Self {
        Self(0)
    }
}
impl const Default for ShaderModule {
    fn default() -> Self {
        Self::null()
    }
}
# [doc = include_str ! ("../../../doc/VkPipeline.md")]
#[derive(Clone, Copy, PartialEq, Eq)]
#[doc(alias = "VkPipeline")]
#[repr(transparent)]
pub struct Pipeline(u64);
impl Pipeline {
    pub const fn null() -> Self {
        Self(0)
    }
}
impl const Default for Pipeline {
    fn default() -> Self {
        Self::null()
    }
}
# [doc = include_str ! ("../../../doc/VkPipelineLayout.md")]
#[derive(Clone, Copy, PartialEq, Eq)]
#[doc(alias = "VkPipelineLayout")]
#[repr(transparent)]
pub struct PipelineLayout(u64);
impl PipelineLayout {
    pub const fn null() -> Self {
        Self(0)
    }
}
impl const Default for PipelineLayout {
    fn default() -> Self {
        Self::null()
    }
}
# [doc = include_str ! ("../../../doc/VkSampler.md")]
#[derive(Clone, Copy, PartialEq, Eq)]
#[doc(alias = "VkSampler")]
#[repr(transparent)]
pub struct Sampler(u64);
impl Sampler {
    pub const fn null() -> Self {
        Self(0)
    }
}
impl const Default for Sampler {
    fn default() -> Self {
        Self::null()
    }
}
# [doc = include_str ! ("../../../doc/VkDescriptorSet.md")]
#[derive(Clone, Copy, PartialEq, Eq)]
#[doc(alias = "VkDescriptorSet")]
#[repr(transparent)]
pub struct DescriptorSet(u64);
impl DescriptorSet {
    pub const fn null() -> Self {
        Self(0)
    }
}
impl const Default for DescriptorSet {
    fn default() -> Self {
        Self::null()
    }
}
# [doc = include_str ! ("../../../doc/VkDescriptorSetLayout.md")]
#[derive(Clone, Copy, PartialEq, Eq)]
#[doc(alias = "VkDescriptorSetLayout")]
#[repr(transparent)]
pub struct DescriptorSetLayout(u64);
impl DescriptorSetLayout {
    pub const fn null() -> Self {
        Self(0)
    }
}
impl const Default for DescriptorSetLayout {
    fn default() -> Self {
        Self::null()
    }
}
# [doc = include_str ! ("../../../doc/VkDescriptorPool.md")]
#[derive(Clone, Copy, PartialEq, Eq)]
#[doc(alias = "VkDescriptorPool")]
#[repr(transparent)]
pub struct DescriptorPool(u64);
impl DescriptorPool {
    pub const fn null() -> Self {
        Self(0)
    }
}
impl const Default for DescriptorPool {
    fn default() -> Self {
        Self::null()
    }
}
# [doc = include_str ! ("../../../doc/VkFence.md")]
#[derive(Clone, Copy, PartialEq, Eq)]
#[doc(alias = "VkFence")]
#[repr(transparent)]
pub struct Fence(u64);
impl Fence {
    pub const fn null() -> Self {
        Self(0)
    }
}
impl const Default for Fence {
    fn default() -> Self {
        Self::null()
    }
}
# [doc = include_str ! ("../../../doc/VkSemaphore.md")]
#[derive(Clone, Copy, PartialEq, Eq)]
#[doc(alias = "VkSemaphore")]
#[repr(transparent)]
pub struct Semaphore(u64);
impl Semaphore {
    pub const fn null() -> Self {
        Self(0)
    }
}
impl const Default for Semaphore {
    fn default() -> Self {
        Self::null()
    }
}
# [doc = include_str ! ("../../../doc/VkEvent.md")]
#[derive(Clone, Copy, PartialEq, Eq)]
#[doc(alias = "VkEvent")]
#[repr(transparent)]
pub struct Event(u64);
impl Event {
    pub const fn null() -> Self {
        Self(0)
    }
}
impl const Default for Event {
    fn default() -> Self {
        Self::null()
    }
}
# [doc = include_str ! ("../../../doc/VkQueryPool.md")]
#[derive(Clone, Copy, PartialEq, Eq)]
#[doc(alias = "VkQueryPool")]
#[repr(transparent)]
pub struct QueryPool(u64);
impl QueryPool {
    pub const fn null() -> Self {
        Self(0)
    }
}
impl const Default for QueryPool {
    fn default() -> Self {
        Self::null()
    }
}
# [doc = include_str ! ("../../../doc/VkFramebuffer.md")]
#[derive(Clone, Copy, PartialEq, Eq)]
#[doc(alias = "VkFramebuffer")]
#[repr(transparent)]
pub struct Framebuffer(u64);
impl Framebuffer {
    pub const fn null() -> Self {
        Self(0)
    }
}
impl const Default for Framebuffer {
    fn default() -> Self {
        Self::null()
    }
}
# [doc = include_str ! ("../../../doc/VkRenderPass.md")]
#[derive(Clone, Copy, PartialEq, Eq)]
#[doc(alias = "VkRenderPass")]
#[repr(transparent)]
pub struct RenderPass(u64);
impl RenderPass {
    pub const fn null() -> Self {
        Self(0)
    }
}
impl const Default for RenderPass {
    fn default() -> Self {
        Self::null()
    }
}
# [doc = include_str ! ("../../../doc/VkPipelineCache.md")]
#[derive(Clone, Copy, PartialEq, Eq)]
#[doc(alias = "VkPipelineCache")]
#[repr(transparent)]
pub struct PipelineCache(u64);
impl PipelineCache {
    pub const fn null() -> Self {
        Self(0)
    }
}
impl const Default for PipelineCache {
    fn default() -> Self {
        Self::null()
    }
}
# [doc = include_str ! ("../../../doc/PFN_vkInternalAllocationNotification.md")]
#[doc(alias = "PFN_vkInternalAllocationNotification")]
pub type PFNInternalAllocationNotification = unsafe extern "system" fn(
    p_user_data: *mut std::ffi::c_void,
    size: usize,
    allocation_type: InternalAllocationType,
    allocation_scope: SystemAllocationScope,
);
# [doc = include_str ! ("../../../doc/PFN_vkInternalFreeNotification.md")]
#[doc(alias = "PFN_vkInternalFreeNotification")]
pub type PFNInternalFreeNotification = unsafe extern "system" fn(
    p_user_data: *mut std::ffi::c_void,
    size: usize,
    allocation_type: InternalAllocationType,
    allocation_scope: SystemAllocationScope,
);
# [doc = include_str ! ("../../../doc/PFN_vkReallocationFunction.md")]
#[doc(alias = "PFN_vkReallocationFunction")]
pub type PFNReallocationFunction = unsafe extern "system" fn(
    p_user_data: *mut std::ffi::c_void,
    p_original: *mut std::ffi::c_void,
    size: usize,
    alignment: usize,
    allocation_scope: SystemAllocationScope,
) -> *mut std::ffi::c_void;
# [doc = include_str ! ("../../../doc/PFN_vkAllocationFunction.md")]
#[doc(alias = "PFN_vkAllocationFunction")]
pub type PFNAllocationFunction = unsafe extern "system" fn(
    p_user_data: *mut std::ffi::c_void,
    size: usize,
    alignment: usize,
    allocation_scope: SystemAllocationScope,
) -> *mut std::ffi::c_void;
# [doc = include_str ! ("../../../doc/PFN_vkFreeFunction.md")]
#[doc(alias = "PFN_vkFreeFunction")]
pub type PFNFreeFunction =
    unsafe extern "system" fn(p_user_data: *mut std::ffi::c_void, p_memory: *mut std::ffi::c_void);
# [doc = include_str ! ("../../../doc/PFN_vkVoidFunction.md")]
#[doc(alias = "PFN_vkVoidFunction")]
pub type PFNVoidFunction = unsafe extern "system" fn();
# [doc = include_str ! ("../../../doc/VkSampleMask.md")]
#[doc(alias = "VkSampleMask")]
pub type SampleMask = u32;
# [doc = include_str ! ("../../../doc/VkBool32.md")]
#[doc(alias = "VkBool32")]
pub type Bool32 = u32;
# [doc = include_str ! ("../../../doc/VkFlags.md")]
#[doc(alias = "VkFlags")]
pub type Flags = u32;
# [doc = include_str ! ("../../../doc/VkDeviceSize.md")]
#[doc(alias = "VkDeviceSize")]
pub type DeviceSize = u64;
# [doc = include_str ! ("../../../doc/VkDeviceAddress.md")]
#[doc(alias = "VkDeviceAddress")]
pub type DeviceAddress = u64;
# [doc = include_str ! ("../../../doc/VkFramebufferCreateFlagBits.md")]
#[doc(alias = "VkFramebufferCreateFlags")]
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct FramebufferCreateFlags(u32);
impl FramebufferCreateFlags {
    #[doc(alias = "VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT")]
    #[cfg(feature = "VULKAN_1_2")]
    pub const IMAGELESS: Self = Self(1);
    #[doc(alias = "VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT_KHR")]
    #[cfg(feature = "VK_KHR_imageless_framebuffer")]
    pub const IMAGELESS_KHR: Self = Self::IMAGELESS;
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    #[allow(unused_mut)]
    pub const fn all() -> Self {
        let mut all = Self::empty();
        #[cfg(feature = "VULKAN_1_2")]
        {
            all |= Self::IMAGELESS;
        }
        #[cfg(feature = "VK_KHR_imageless_framebuffer")]
        {
            all |= Self::IMAGELESS_KHR;
        }
        all
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl const std::ops::BitOr for FramebufferCreateFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl const std::ops::BitOrAssign for FramebufferCreateFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl const std::ops::BitXor for FramebufferCreateFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl const std::ops::BitXorAssign for FramebufferCreateFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl const std::ops::BitAnd for FramebufferCreateFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl const std::ops::BitAndAssign for FramebufferCreateFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl const std::ops::Sub for FramebufferCreateFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl const std::ops::SubAssign for FramebufferCreateFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl const std::ops::Not for FramebufferCreateFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl Extend<FramebufferCreateFlags> for FramebufferCreateFlags {
    fn extend<T: IntoIterator<Item = FramebufferCreateFlags>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, i);
        }
    }
}
impl FromIterator<FramebufferCreateFlags> for FramebufferCreateFlags {
    fn from_iter<T: IntoIterator<Item = FramebufferCreateFlags>>(iterator: T) -> FramebufferCreateFlags {
        let mut out = Self::empty();
        <Self as Extend<FramebufferCreateFlags>>::extend(&mut out, iterator);
        out
    }
}
impl const Default for FramebufferCreateFlags {
    fn default() -> Self {
        Self::empty()
    }
}
impl const From<FramebufferCreateFlagBits> for FramebufferCreateFlags {
    fn from(bit: FramebufferCreateFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(bit.bits()) }
    }
}
impl Extend<FramebufferCreateFlagBits> for FramebufferCreateFlags {
    fn extend<T: IntoIterator<Item = FramebufferCreateFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, Self::from(i));
        }
    }
}
impl FromIterator<FramebufferCreateFlagBits> for FramebufferCreateFlags {
    fn from_iter<T: IntoIterator<Item = FramebufferCreateFlagBits>>(iterator: T) -> FramebufferCreateFlags {
        let mut out = Self::empty();
        <Self as Extend<FramebufferCreateFlagBits>>::extend(&mut out, iterator);
        out
    }
}
impl std::fmt::Debug for FramebufferCreateFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(FramebufferCreateFlags);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == FramebufferCreateFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    #[cfg(feature = "VULKAN_1_2")]
                    if self.0.contains(FramebufferCreateFlags::IMAGELESS) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(IMAGELESS))?;
                    }
                    #[cfg(feature = "VK_KHR_imageless_framebuffer")]
                    if self.0.contains(FramebufferCreateFlags::IMAGELESS_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(IMAGELESS_KHR))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(FramebufferCreateFlags))
            .field(&Flags(*self))
            .finish()
    }
}
#[doc(alias = "VkQueryPoolCreateFlags")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct QueryPoolCreateFlags(u32);
impl QueryPoolCreateFlags {
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
}
# [doc = include_str ! ("../../../doc/VkRenderPassCreateFlagBits.md")]
#[doc(alias = "VkRenderPassCreateFlags")]
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct RenderPassCreateFlags(u32);
impl RenderPassCreateFlags {
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    #[allow(unused_mut)]
    pub const fn all() -> Self {
        let mut all = Self::empty();
        all
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl const std::ops::BitOr for RenderPassCreateFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl const std::ops::BitOrAssign for RenderPassCreateFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl const std::ops::BitXor for RenderPassCreateFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl const std::ops::BitXorAssign for RenderPassCreateFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl const std::ops::BitAnd for RenderPassCreateFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl const std::ops::BitAndAssign for RenderPassCreateFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl const std::ops::Sub for RenderPassCreateFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl const std::ops::SubAssign for RenderPassCreateFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl const std::ops::Not for RenderPassCreateFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl Extend<RenderPassCreateFlags> for RenderPassCreateFlags {
    fn extend<T: IntoIterator<Item = RenderPassCreateFlags>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, i);
        }
    }
}
impl FromIterator<RenderPassCreateFlags> for RenderPassCreateFlags {
    fn from_iter<T: IntoIterator<Item = RenderPassCreateFlags>>(iterator: T) -> RenderPassCreateFlags {
        let mut out = Self::empty();
        <Self as Extend<RenderPassCreateFlags>>::extend(&mut out, iterator);
        out
    }
}
impl const Default for RenderPassCreateFlags {
    fn default() -> Self {
        Self::empty()
    }
}
impl const From<RenderPassCreateFlagBits> for RenderPassCreateFlags {
    fn from(bit: RenderPassCreateFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(bit.bits()) }
    }
}
impl Extend<RenderPassCreateFlagBits> for RenderPassCreateFlags {
    fn extend<T: IntoIterator<Item = RenderPassCreateFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, Self::from(i));
        }
    }
}
impl FromIterator<RenderPassCreateFlagBits> for RenderPassCreateFlags {
    fn from_iter<T: IntoIterator<Item = RenderPassCreateFlagBits>>(iterator: T) -> RenderPassCreateFlags {
        let mut out = Self::empty();
        <Self as Extend<RenderPassCreateFlagBits>>::extend(&mut out, iterator);
        out
    }
}
impl std::fmt::Debug for RenderPassCreateFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(RenderPassCreateFlags);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == RenderPassCreateFlags::empty() {
                    f.write_str("empty")?;
                } else {
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(RenderPassCreateFlags))
            .field(&Flags(*self))
            .finish()
    }
}
# [doc = include_str ! ("../../../doc/VkSamplerCreateFlagBits.md")]
#[doc(alias = "VkSamplerCreateFlags")]
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct SamplerCreateFlags(u32);
impl SamplerCreateFlags {
    #[doc(alias = "VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT")]
    #[cfg(feature = "VK_EXT_fragment_density_map")]
    pub const SUBSAMPLED_EXT: Self = Self(1);
    #[doc(alias = "VK_SAMPLER_CREATE_SUBSAMPLED_COARSE_RECONSTRUCTION_BIT_EXT")]
    #[cfg(feature = "VK_EXT_fragment_density_map")]
    pub const SUBSAMPLED_COARSE_RECONSTRUCTION_EXT: Self = Self(2);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    #[allow(unused_mut)]
    pub const fn all() -> Self {
        let mut all = Self::empty();
        #[cfg(feature = "VK_EXT_fragment_density_map")]
        {
            all |= Self::SUBSAMPLED_EXT;
        }
        #[cfg(feature = "VK_EXT_fragment_density_map")]
        {
            all |= Self::SUBSAMPLED_COARSE_RECONSTRUCTION_EXT;
        }
        all
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl const std::ops::BitOr for SamplerCreateFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl const std::ops::BitOrAssign for SamplerCreateFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl const std::ops::BitXor for SamplerCreateFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl const std::ops::BitXorAssign for SamplerCreateFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl const std::ops::BitAnd for SamplerCreateFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl const std::ops::BitAndAssign for SamplerCreateFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl const std::ops::Sub for SamplerCreateFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl const std::ops::SubAssign for SamplerCreateFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl const std::ops::Not for SamplerCreateFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl Extend<SamplerCreateFlags> for SamplerCreateFlags {
    fn extend<T: IntoIterator<Item = SamplerCreateFlags>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, i);
        }
    }
}
impl FromIterator<SamplerCreateFlags> for SamplerCreateFlags {
    fn from_iter<T: IntoIterator<Item = SamplerCreateFlags>>(iterator: T) -> SamplerCreateFlags {
        let mut out = Self::empty();
        <Self as Extend<SamplerCreateFlags>>::extend(&mut out, iterator);
        out
    }
}
impl const Default for SamplerCreateFlags {
    fn default() -> Self {
        Self::empty()
    }
}
impl const From<SamplerCreateFlagBits> for SamplerCreateFlags {
    fn from(bit: SamplerCreateFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(bit.bits()) }
    }
}
impl Extend<SamplerCreateFlagBits> for SamplerCreateFlags {
    fn extend<T: IntoIterator<Item = SamplerCreateFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, Self::from(i));
        }
    }
}
impl FromIterator<SamplerCreateFlagBits> for SamplerCreateFlags {
    fn from_iter<T: IntoIterator<Item = SamplerCreateFlagBits>>(iterator: T) -> SamplerCreateFlags {
        let mut out = Self::empty();
        <Self as Extend<SamplerCreateFlagBits>>::extend(&mut out, iterator);
        out
    }
}
impl std::fmt::Debug for SamplerCreateFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(SamplerCreateFlags);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == SamplerCreateFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    #[cfg(feature = "VK_EXT_fragment_density_map")]
                    if self.0.contains(SamplerCreateFlags::SUBSAMPLED_EXT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(SUBSAMPLED_EXT))?;
                    }
                    #[cfg(feature = "VK_EXT_fragment_density_map")]
                    if self
                        .0
                        .contains(SamplerCreateFlags::SUBSAMPLED_COARSE_RECONSTRUCTION_EXT)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(SUBSAMPLED_COARSE_RECONSTRUCTION_EXT))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(SamplerCreateFlags))
            .field(&Flags(*self))
            .finish()
    }
}
#[doc(alias = "VkPipelineLayoutCreateFlags")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct PipelineLayoutCreateFlags(u32);
impl PipelineLayoutCreateFlags {
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
}
#[doc(alias = "VkPipelineCacheCreateFlags")]
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct PipelineCacheCreateFlags(u32);
impl PipelineCacheCreateFlags {
    #[doc(alias = "VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT")]
    pub const EXTERNALLY_SYNCHRONIZED: Self = Self(1);
    #[doc(alias = "VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT_EXT")]
    pub const EXTERNALLY_SYNCHRONIZED_EXT: Self = Self::EXTERNALLY_SYNCHRONIZED;
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    #[allow(unused_mut)]
    pub const fn all() -> Self {
        let mut all = Self::empty();
        #[cfg(feature = "VULKAN_1_3")]
        {
            all |= Self::EXTERNALLY_SYNCHRONIZED;
        }
        #[cfg(feature = "VK_EXT_pipeline_creation_cache_control")]
        {
            all |= Self::EXTERNALLY_SYNCHRONIZED_EXT;
        }
        all
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl const std::ops::BitOr for PipelineCacheCreateFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl const std::ops::BitOrAssign for PipelineCacheCreateFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl const std::ops::BitXor for PipelineCacheCreateFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl const std::ops::BitXorAssign for PipelineCacheCreateFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl const std::ops::BitAnd for PipelineCacheCreateFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl const std::ops::BitAndAssign for PipelineCacheCreateFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl const std::ops::Sub for PipelineCacheCreateFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl const std::ops::SubAssign for PipelineCacheCreateFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl const std::ops::Not for PipelineCacheCreateFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl Extend<PipelineCacheCreateFlags> for PipelineCacheCreateFlags {
    fn extend<T: IntoIterator<Item = PipelineCacheCreateFlags>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, i);
        }
    }
}
impl FromIterator<PipelineCacheCreateFlags> for PipelineCacheCreateFlags {
    fn from_iter<T: IntoIterator<Item = PipelineCacheCreateFlags>>(iterator: T) -> PipelineCacheCreateFlags {
        let mut out = Self::empty();
        <Self as Extend<PipelineCacheCreateFlags>>::extend(&mut out, iterator);
        out
    }
}
impl const Default for PipelineCacheCreateFlags {
    fn default() -> Self {
        Self::empty()
    }
}
#[cfg(feature = "VK_EXT_pipeline_creation_cache_control")]
impl const From<PipelineCacheCreateFlagBits> for PipelineCacheCreateFlags {
    fn from(bit: PipelineCacheCreateFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(bit.bits()) }
    }
}
#[cfg(feature = "VK_EXT_pipeline_creation_cache_control")]
impl Extend<PipelineCacheCreateFlagBits> for PipelineCacheCreateFlags {
    fn extend<T: IntoIterator<Item = PipelineCacheCreateFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, Self::from(i));
        }
    }
}
#[cfg(feature = "VK_EXT_pipeline_creation_cache_control")]
impl FromIterator<PipelineCacheCreateFlagBits> for PipelineCacheCreateFlags {
    fn from_iter<T: IntoIterator<Item = PipelineCacheCreateFlagBits>>(iterator: T) -> PipelineCacheCreateFlags {
        let mut out = Self::empty();
        <Self as Extend<PipelineCacheCreateFlagBits>>::extend(&mut out, iterator);
        out
    }
}
impl std::fmt::Debug for PipelineCacheCreateFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(PipelineCacheCreateFlags);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == PipelineCacheCreateFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    #[cfg(feature = "VULKAN_1_3")]
                    if self.0.contains(PipelineCacheCreateFlags::EXTERNALLY_SYNCHRONIZED) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(EXTERNALLY_SYNCHRONIZED))?;
                    }
                    #[cfg(feature = "VK_EXT_pipeline_creation_cache_control")]
                    if self.0.contains(PipelineCacheCreateFlags::EXTERNALLY_SYNCHRONIZED_EXT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(EXTERNALLY_SYNCHRONIZED_EXT))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(PipelineCacheCreateFlags))
            .field(&Flags(*self))
            .finish()
    }
}
#[doc(alias = "VkPipelineDepthStencilStateCreateFlags")]
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct PipelineDepthStencilStateCreateFlags(u32);
impl PipelineDepthStencilStateCreateFlags {
    #[doc(alias = "VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_ARM")]
    pub const RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_ARM: Self = Self(1);
    #[doc(alias = "VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_ARM")]
    pub const RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_ARM: Self = Self(2);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    #[allow(unused_mut)]
    pub const fn all() -> Self {
        let mut all = Self::empty();
        #[cfg(feature = "VK_ARM_rasterization_order_attachment_access")]
        {
            all |= Self::RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_ARM;
        }
        #[cfg(feature = "VK_ARM_rasterization_order_attachment_access")]
        {
            all |= Self::RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_ARM;
        }
        all
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl const std::ops::BitOr for PipelineDepthStencilStateCreateFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl const std::ops::BitOrAssign for PipelineDepthStencilStateCreateFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl const std::ops::BitXor for PipelineDepthStencilStateCreateFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl const std::ops::BitXorAssign for PipelineDepthStencilStateCreateFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl const std::ops::BitAnd for PipelineDepthStencilStateCreateFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl const std::ops::BitAndAssign for PipelineDepthStencilStateCreateFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl const std::ops::Sub for PipelineDepthStencilStateCreateFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl const std::ops::SubAssign for PipelineDepthStencilStateCreateFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl const std::ops::Not for PipelineDepthStencilStateCreateFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl Extend<PipelineDepthStencilStateCreateFlags> for PipelineDepthStencilStateCreateFlags {
    fn extend<T: IntoIterator<Item = PipelineDepthStencilStateCreateFlags>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, i);
        }
    }
}
impl FromIterator<PipelineDepthStencilStateCreateFlags> for PipelineDepthStencilStateCreateFlags {
    fn from_iter<T: IntoIterator<Item = PipelineDepthStencilStateCreateFlags>>(
        iterator: T,
    ) -> PipelineDepthStencilStateCreateFlags {
        let mut out = Self::empty();
        <Self as Extend<PipelineDepthStencilStateCreateFlags>>::extend(&mut out, iterator);
        out
    }
}
impl const Default for PipelineDepthStencilStateCreateFlags {
    fn default() -> Self {
        Self::empty()
    }
}
#[cfg(feature = "VK_ARM_rasterization_order_attachment_access")]
impl const From<PipelineDepthStencilStateCreateFlagBits> for PipelineDepthStencilStateCreateFlags {
    fn from(bit: PipelineDepthStencilStateCreateFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(bit.bits()) }
    }
}
#[cfg(feature = "VK_ARM_rasterization_order_attachment_access")]
impl Extend<PipelineDepthStencilStateCreateFlagBits> for PipelineDepthStencilStateCreateFlags {
    fn extend<T: IntoIterator<Item = PipelineDepthStencilStateCreateFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, Self::from(i));
        }
    }
}
#[cfg(feature = "VK_ARM_rasterization_order_attachment_access")]
impl FromIterator<PipelineDepthStencilStateCreateFlagBits> for PipelineDepthStencilStateCreateFlags {
    fn from_iter<T: IntoIterator<Item = PipelineDepthStencilStateCreateFlagBits>>(
        iterator: T,
    ) -> PipelineDepthStencilStateCreateFlags {
        let mut out = Self::empty();
        <Self as Extend<PipelineDepthStencilStateCreateFlagBits>>::extend(&mut out, iterator);
        out
    }
}
impl std::fmt::Debug for PipelineDepthStencilStateCreateFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(PipelineDepthStencilStateCreateFlags);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == PipelineDepthStencilStateCreateFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    #[cfg(feature = "VK_ARM_rasterization_order_attachment_access")]
                    if self
                        .0
                        .contains(PipelineDepthStencilStateCreateFlags::RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_ARM)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_ARM))?;
                    }
                    #[cfg(feature = "VK_ARM_rasterization_order_attachment_access")]
                    if self.0.contains(
                        PipelineDepthStencilStateCreateFlags::RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_ARM,
                    ) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_ARM))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(PipelineDepthStencilStateCreateFlags))
            .field(&Flags(*self))
            .finish()
    }
}
#[doc(alias = "VkPipelineDynamicStateCreateFlags")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct PipelineDynamicStateCreateFlags(u32);
impl PipelineDynamicStateCreateFlags {
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
}
#[doc(alias = "VkPipelineColorBlendStateCreateFlags")]
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct PipelineColorBlendStateCreateFlags(u32);
impl PipelineColorBlendStateCreateFlags {
    #[doc(alias = "VK_PIPELINE_COLOR_BLEND_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_ARM")]
    pub const RASTERIZATION_ORDER_ATTACHMENT_ACCESS_ARM: Self = Self(1);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    #[allow(unused_mut)]
    pub const fn all() -> Self {
        let mut all = Self::empty();
        #[cfg(feature = "VK_ARM_rasterization_order_attachment_access")]
        {
            all |= Self::RASTERIZATION_ORDER_ATTACHMENT_ACCESS_ARM;
        }
        all
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl const std::ops::BitOr for PipelineColorBlendStateCreateFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl const std::ops::BitOrAssign for PipelineColorBlendStateCreateFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl const std::ops::BitXor for PipelineColorBlendStateCreateFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl const std::ops::BitXorAssign for PipelineColorBlendStateCreateFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl const std::ops::BitAnd for PipelineColorBlendStateCreateFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl const std::ops::BitAndAssign for PipelineColorBlendStateCreateFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl const std::ops::Sub for PipelineColorBlendStateCreateFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl const std::ops::SubAssign for PipelineColorBlendStateCreateFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl const std::ops::Not for PipelineColorBlendStateCreateFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl Extend<PipelineColorBlendStateCreateFlags> for PipelineColorBlendStateCreateFlags {
    fn extend<T: IntoIterator<Item = PipelineColorBlendStateCreateFlags>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, i);
        }
    }
}
impl FromIterator<PipelineColorBlendStateCreateFlags> for PipelineColorBlendStateCreateFlags {
    fn from_iter<T: IntoIterator<Item = PipelineColorBlendStateCreateFlags>>(
        iterator: T,
    ) -> PipelineColorBlendStateCreateFlags {
        let mut out = Self::empty();
        <Self as Extend<PipelineColorBlendStateCreateFlags>>::extend(&mut out, iterator);
        out
    }
}
impl const Default for PipelineColorBlendStateCreateFlags {
    fn default() -> Self {
        Self::empty()
    }
}
#[cfg(feature = "VK_ARM_rasterization_order_attachment_access")]
impl const From<PipelineColorBlendStateCreateFlagBits> for PipelineColorBlendStateCreateFlags {
    fn from(bit: PipelineColorBlendStateCreateFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(bit.bits()) }
    }
}
#[cfg(feature = "VK_ARM_rasterization_order_attachment_access")]
impl Extend<PipelineColorBlendStateCreateFlagBits> for PipelineColorBlendStateCreateFlags {
    fn extend<T: IntoIterator<Item = PipelineColorBlendStateCreateFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, Self::from(i));
        }
    }
}
#[cfg(feature = "VK_ARM_rasterization_order_attachment_access")]
impl FromIterator<PipelineColorBlendStateCreateFlagBits> for PipelineColorBlendStateCreateFlags {
    fn from_iter<T: IntoIterator<Item = PipelineColorBlendStateCreateFlagBits>>(
        iterator: T,
    ) -> PipelineColorBlendStateCreateFlags {
        let mut out = Self::empty();
        <Self as Extend<PipelineColorBlendStateCreateFlagBits>>::extend(&mut out, iterator);
        out
    }
}
impl std::fmt::Debug for PipelineColorBlendStateCreateFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(PipelineColorBlendStateCreateFlags);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == PipelineColorBlendStateCreateFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    #[cfg(feature = "VK_ARM_rasterization_order_attachment_access")]
                    if self
                        .0
                        .contains(PipelineColorBlendStateCreateFlags::RASTERIZATION_ORDER_ATTACHMENT_ACCESS_ARM)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(RASTERIZATION_ORDER_ATTACHMENT_ACCESS_ARM))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(PipelineColorBlendStateCreateFlags))
            .field(&Flags(*self))
            .finish()
    }
}
#[doc(alias = "VkPipelineMultisampleStateCreateFlags")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct PipelineMultisampleStateCreateFlags(u32);
impl PipelineMultisampleStateCreateFlags {
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
}
#[doc(alias = "VkPipelineRasterizationStateCreateFlags")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct PipelineRasterizationStateCreateFlags(u32);
impl PipelineRasterizationStateCreateFlags {
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
}
#[doc(alias = "VkPipelineViewportStateCreateFlags")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct PipelineViewportStateCreateFlags(u32);
impl PipelineViewportStateCreateFlags {
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
}
#[doc(alias = "VkPipelineTessellationStateCreateFlags")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct PipelineTessellationStateCreateFlags(u32);
impl PipelineTessellationStateCreateFlags {
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
}
#[doc(alias = "VkPipelineInputAssemblyStateCreateFlags")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct PipelineInputAssemblyStateCreateFlags(u32);
impl PipelineInputAssemblyStateCreateFlags {
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
}
#[doc(alias = "VkPipelineVertexInputStateCreateFlags")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct PipelineVertexInputStateCreateFlags(u32);
impl PipelineVertexInputStateCreateFlags {
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
}
# [doc = include_str ! ("../../../doc/VkPipelineShaderStageCreateFlagBits.md")]
#[doc(alias = "VkPipelineShaderStageCreateFlags")]
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct PipelineShaderStageCreateFlags(u32);
impl PipelineShaderStageCreateFlags {
    #[doc(alias = "VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const ALLOW_VARYING_SUBGROUP_SIZE: Self = Self(1);
    #[doc(alias = "VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const REQUIRE_FULL_SUBGROUPS: Self = Self(2);
    #[doc(alias = "VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT")]
    #[cfg(feature = "VK_EXT_subgroup_size_control")]
    pub const ALLOW_VARYING_SUBGROUP_SIZE_EXT: Self = Self::ALLOW_VARYING_SUBGROUP_SIZE;
    #[doc(alias = "VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT")]
    #[cfg(feature = "VK_EXT_subgroup_size_control")]
    pub const REQUIRE_FULL_SUBGROUPS_EXT: Self = Self::REQUIRE_FULL_SUBGROUPS;
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    #[allow(unused_mut)]
    pub const fn all() -> Self {
        let mut all = Self::empty();
        #[cfg(feature = "VULKAN_1_3")]
        {
            all |= Self::ALLOW_VARYING_SUBGROUP_SIZE;
        }
        #[cfg(feature = "VULKAN_1_3")]
        {
            all |= Self::REQUIRE_FULL_SUBGROUPS;
        }
        #[cfg(feature = "VK_EXT_subgroup_size_control")]
        {
            all |= Self::ALLOW_VARYING_SUBGROUP_SIZE_EXT;
        }
        #[cfg(feature = "VK_EXT_subgroup_size_control")]
        {
            all |= Self::REQUIRE_FULL_SUBGROUPS_EXT;
        }
        all
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl const std::ops::BitOr for PipelineShaderStageCreateFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl const std::ops::BitOrAssign for PipelineShaderStageCreateFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl const std::ops::BitXor for PipelineShaderStageCreateFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl const std::ops::BitXorAssign for PipelineShaderStageCreateFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl const std::ops::BitAnd for PipelineShaderStageCreateFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl const std::ops::BitAndAssign for PipelineShaderStageCreateFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl const std::ops::Sub for PipelineShaderStageCreateFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl const std::ops::SubAssign for PipelineShaderStageCreateFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl const std::ops::Not for PipelineShaderStageCreateFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl Extend<PipelineShaderStageCreateFlags> for PipelineShaderStageCreateFlags {
    fn extend<T: IntoIterator<Item = PipelineShaderStageCreateFlags>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, i);
        }
    }
}
impl FromIterator<PipelineShaderStageCreateFlags> for PipelineShaderStageCreateFlags {
    fn from_iter<T: IntoIterator<Item = PipelineShaderStageCreateFlags>>(
        iterator: T,
    ) -> PipelineShaderStageCreateFlags {
        let mut out = Self::empty();
        <Self as Extend<PipelineShaderStageCreateFlags>>::extend(&mut out, iterator);
        out
    }
}
impl const Default for PipelineShaderStageCreateFlags {
    fn default() -> Self {
        Self::empty()
    }
}
impl const From<PipelineShaderStageCreateFlagBits> for PipelineShaderStageCreateFlags {
    fn from(bit: PipelineShaderStageCreateFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(bit.bits()) }
    }
}
impl Extend<PipelineShaderStageCreateFlagBits> for PipelineShaderStageCreateFlags {
    fn extend<T: IntoIterator<Item = PipelineShaderStageCreateFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, Self::from(i));
        }
    }
}
impl FromIterator<PipelineShaderStageCreateFlagBits> for PipelineShaderStageCreateFlags {
    fn from_iter<T: IntoIterator<Item = PipelineShaderStageCreateFlagBits>>(
        iterator: T,
    ) -> PipelineShaderStageCreateFlags {
        let mut out = Self::empty();
        <Self as Extend<PipelineShaderStageCreateFlagBits>>::extend(&mut out, iterator);
        out
    }
}
impl std::fmt::Debug for PipelineShaderStageCreateFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(PipelineShaderStageCreateFlags);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == PipelineShaderStageCreateFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    #[cfg(feature = "VULKAN_1_3")]
                    if self
                        .0
                        .contains(PipelineShaderStageCreateFlags::ALLOW_VARYING_SUBGROUP_SIZE)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(ALLOW_VARYING_SUBGROUP_SIZE))?;
                    }
                    #[cfg(feature = "VULKAN_1_3")]
                    if self.0.contains(PipelineShaderStageCreateFlags::REQUIRE_FULL_SUBGROUPS) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(REQUIRE_FULL_SUBGROUPS))?;
                    }
                    #[cfg(feature = "VK_EXT_subgroup_size_control")]
                    if self
                        .0
                        .contains(PipelineShaderStageCreateFlags::ALLOW_VARYING_SUBGROUP_SIZE_EXT)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(ALLOW_VARYING_SUBGROUP_SIZE_EXT))?;
                    }
                    #[cfg(feature = "VK_EXT_subgroup_size_control")]
                    if self
                        .0
                        .contains(PipelineShaderStageCreateFlags::REQUIRE_FULL_SUBGROUPS_EXT)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(REQUIRE_FULL_SUBGROUPS_EXT))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(PipelineShaderStageCreateFlags))
            .field(&Flags(*self))
            .finish()
    }
}
# [doc = include_str ! ("../../../doc/VkDescriptorSetLayoutCreateFlagBits.md")]
#[doc(alias = "VkDescriptorSetLayoutCreateFlags")]
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct DescriptorSetLayoutCreateFlags(u32);
impl DescriptorSetLayoutCreateFlags {
    #[doc(alias = "VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT")]
    #[cfg(feature = "VULKAN_1_2")]
    pub const UPDATE_AFTER_BIND_POOL: Self = Self(2);
    #[doc(alias = "VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR")]
    #[cfg(feature = "VK_KHR_push_descriptor")]
    pub const PUSH_DESCRIPTOR_KHR: Self = Self(1);
    #[doc(alias = "VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_VALVE")]
    #[cfg(feature = "VK_VALVE_mutable_descriptor_type")]
    pub const HOST_ONLY_POOL_VALVE: Self = Self(4);
    #[doc(alias = "VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT")]
    #[cfg(feature = "VK_EXT_descriptor_indexing")]
    pub const UPDATE_AFTER_BIND_POOL_EXT: Self = Self::UPDATE_AFTER_BIND_POOL;
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    #[allow(unused_mut)]
    pub const fn all() -> Self {
        let mut all = Self::empty();
        #[cfg(feature = "VULKAN_1_2")]
        {
            all |= Self::UPDATE_AFTER_BIND_POOL;
        }
        #[cfg(feature = "VK_KHR_push_descriptor")]
        {
            all |= Self::PUSH_DESCRIPTOR_KHR;
        }
        #[cfg(feature = "VK_VALVE_mutable_descriptor_type")]
        {
            all |= Self::HOST_ONLY_POOL_VALVE;
        }
        #[cfg(feature = "VK_EXT_descriptor_indexing")]
        {
            all |= Self::UPDATE_AFTER_BIND_POOL_EXT;
        }
        all
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl const std::ops::BitOr for DescriptorSetLayoutCreateFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl const std::ops::BitOrAssign for DescriptorSetLayoutCreateFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl const std::ops::BitXor for DescriptorSetLayoutCreateFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl const std::ops::BitXorAssign for DescriptorSetLayoutCreateFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl const std::ops::BitAnd for DescriptorSetLayoutCreateFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl const std::ops::BitAndAssign for DescriptorSetLayoutCreateFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl const std::ops::Sub for DescriptorSetLayoutCreateFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl const std::ops::SubAssign for DescriptorSetLayoutCreateFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl const std::ops::Not for DescriptorSetLayoutCreateFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl Extend<DescriptorSetLayoutCreateFlags> for DescriptorSetLayoutCreateFlags {
    fn extend<T: IntoIterator<Item = DescriptorSetLayoutCreateFlags>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, i);
        }
    }
}
impl FromIterator<DescriptorSetLayoutCreateFlags> for DescriptorSetLayoutCreateFlags {
    fn from_iter<T: IntoIterator<Item = DescriptorSetLayoutCreateFlags>>(
        iterator: T,
    ) -> DescriptorSetLayoutCreateFlags {
        let mut out = Self::empty();
        <Self as Extend<DescriptorSetLayoutCreateFlags>>::extend(&mut out, iterator);
        out
    }
}
impl const Default for DescriptorSetLayoutCreateFlags {
    fn default() -> Self {
        Self::empty()
    }
}
impl const From<DescriptorSetLayoutCreateFlagBits> for DescriptorSetLayoutCreateFlags {
    fn from(bit: DescriptorSetLayoutCreateFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(bit.bits()) }
    }
}
impl Extend<DescriptorSetLayoutCreateFlagBits> for DescriptorSetLayoutCreateFlags {
    fn extend<T: IntoIterator<Item = DescriptorSetLayoutCreateFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, Self::from(i));
        }
    }
}
impl FromIterator<DescriptorSetLayoutCreateFlagBits> for DescriptorSetLayoutCreateFlags {
    fn from_iter<T: IntoIterator<Item = DescriptorSetLayoutCreateFlagBits>>(
        iterator: T,
    ) -> DescriptorSetLayoutCreateFlags {
        let mut out = Self::empty();
        <Self as Extend<DescriptorSetLayoutCreateFlagBits>>::extend(&mut out, iterator);
        out
    }
}
impl std::fmt::Debug for DescriptorSetLayoutCreateFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(DescriptorSetLayoutCreateFlags);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == DescriptorSetLayoutCreateFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    #[cfg(feature = "VULKAN_1_2")]
                    if self.0.contains(DescriptorSetLayoutCreateFlags::UPDATE_AFTER_BIND_POOL) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(UPDATE_AFTER_BIND_POOL))?;
                    }
                    #[cfg(feature = "VK_KHR_push_descriptor")]
                    if self.0.contains(DescriptorSetLayoutCreateFlags::PUSH_DESCRIPTOR_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(PUSH_DESCRIPTOR_KHR))?;
                    }
                    #[cfg(feature = "VK_VALVE_mutable_descriptor_type")]
                    if self.0.contains(DescriptorSetLayoutCreateFlags::HOST_ONLY_POOL_VALVE) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(HOST_ONLY_POOL_VALVE))?;
                    }
                    #[cfg(feature = "VK_EXT_descriptor_indexing")]
                    if self
                        .0
                        .contains(DescriptorSetLayoutCreateFlags::UPDATE_AFTER_BIND_POOL_EXT)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(UPDATE_AFTER_BIND_POOL_EXT))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(DescriptorSetLayoutCreateFlags))
            .field(&Flags(*self))
            .finish()
    }
}
#[doc(alias = "VkBufferViewCreateFlags")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct BufferViewCreateFlags(u32);
impl BufferViewCreateFlags {
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
}
# [doc = include_str ! ("../../../doc/VkInstanceCreateFlagBits.md")]
#[doc(alias = "VkInstanceCreateFlags")]
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct InstanceCreateFlags(u32);
impl InstanceCreateFlags {
    #[doc(alias = "VK_INSTANCE_CREATE_ENUMERATE_PORTABILITY_BIT_KHR")]
    #[cfg(feature = "VK_KHR_portability_enumeration")]
    pub const ENUMERATE_PORTABILITY_KHR: Self = Self(1);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    #[allow(unused_mut)]
    pub const fn all() -> Self {
        let mut all = Self::empty();
        #[cfg(feature = "VK_KHR_portability_enumeration")]
        {
            all |= Self::ENUMERATE_PORTABILITY_KHR;
        }
        all
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl const std::ops::BitOr for InstanceCreateFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl const std::ops::BitOrAssign for InstanceCreateFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl const std::ops::BitXor for InstanceCreateFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl const std::ops::BitXorAssign for InstanceCreateFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl const std::ops::BitAnd for InstanceCreateFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl const std::ops::BitAndAssign for InstanceCreateFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl const std::ops::Sub for InstanceCreateFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl const std::ops::SubAssign for InstanceCreateFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl const std::ops::Not for InstanceCreateFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl Extend<InstanceCreateFlags> for InstanceCreateFlags {
    fn extend<T: IntoIterator<Item = InstanceCreateFlags>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, i);
        }
    }
}
impl FromIterator<InstanceCreateFlags> for InstanceCreateFlags {
    fn from_iter<T: IntoIterator<Item = InstanceCreateFlags>>(iterator: T) -> InstanceCreateFlags {
        let mut out = Self::empty();
        <Self as Extend<InstanceCreateFlags>>::extend(&mut out, iterator);
        out
    }
}
impl const Default for InstanceCreateFlags {
    fn default() -> Self {
        Self::empty()
    }
}
impl const From<InstanceCreateFlagBits> for InstanceCreateFlags {
    fn from(bit: InstanceCreateFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(bit.bits()) }
    }
}
impl Extend<InstanceCreateFlagBits> for InstanceCreateFlags {
    fn extend<T: IntoIterator<Item = InstanceCreateFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, Self::from(i));
        }
    }
}
impl FromIterator<InstanceCreateFlagBits> for InstanceCreateFlags {
    fn from_iter<T: IntoIterator<Item = InstanceCreateFlagBits>>(iterator: T) -> InstanceCreateFlags {
        let mut out = Self::empty();
        <Self as Extend<InstanceCreateFlagBits>>::extend(&mut out, iterator);
        out
    }
}
impl std::fmt::Debug for InstanceCreateFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(InstanceCreateFlags);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == InstanceCreateFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    #[cfg(feature = "VK_KHR_portability_enumeration")]
                    if self.0.contains(InstanceCreateFlags::ENUMERATE_PORTABILITY_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(ENUMERATE_PORTABILITY_KHR))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(InstanceCreateFlags))
            .field(&Flags(*self))
            .finish()
    }
}
#[doc(alias = "VkDeviceCreateFlags")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct DeviceCreateFlags(u32);
impl DeviceCreateFlags {
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
}
# [doc = include_str ! ("../../../doc/VkDeviceQueueCreateFlagBits.md")]
#[doc(alias = "VkDeviceQueueCreateFlags")]
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct DeviceQueueCreateFlags(u32);
impl DeviceQueueCreateFlags {
    #[doc(alias = "VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT")]
    pub const PROTECTED: Self = Self(1);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    #[allow(unused_mut)]
    pub const fn all() -> Self {
        let mut all = Self::empty();
        {
            all |= Self::PROTECTED;
        }
        all
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl const std::ops::BitOr for DeviceQueueCreateFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl const std::ops::BitOrAssign for DeviceQueueCreateFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl const std::ops::BitXor for DeviceQueueCreateFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl const std::ops::BitXorAssign for DeviceQueueCreateFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl const std::ops::BitAnd for DeviceQueueCreateFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl const std::ops::BitAndAssign for DeviceQueueCreateFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl const std::ops::Sub for DeviceQueueCreateFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl const std::ops::SubAssign for DeviceQueueCreateFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl const std::ops::Not for DeviceQueueCreateFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl Extend<DeviceQueueCreateFlags> for DeviceQueueCreateFlags {
    fn extend<T: IntoIterator<Item = DeviceQueueCreateFlags>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, i);
        }
    }
}
impl FromIterator<DeviceQueueCreateFlags> for DeviceQueueCreateFlags {
    fn from_iter<T: IntoIterator<Item = DeviceQueueCreateFlags>>(iterator: T) -> DeviceQueueCreateFlags {
        let mut out = Self::empty();
        <Self as Extend<DeviceQueueCreateFlags>>::extend(&mut out, iterator);
        out
    }
}
impl const Default for DeviceQueueCreateFlags {
    fn default() -> Self {
        Self::empty()
    }
}
impl const From<DeviceQueueCreateFlagBits> for DeviceQueueCreateFlags {
    fn from(bit: DeviceQueueCreateFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(bit.bits()) }
    }
}
impl Extend<DeviceQueueCreateFlagBits> for DeviceQueueCreateFlags {
    fn extend<T: IntoIterator<Item = DeviceQueueCreateFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, Self::from(i));
        }
    }
}
impl FromIterator<DeviceQueueCreateFlagBits> for DeviceQueueCreateFlags {
    fn from_iter<T: IntoIterator<Item = DeviceQueueCreateFlagBits>>(iterator: T) -> DeviceQueueCreateFlags {
        let mut out = Self::empty();
        <Self as Extend<DeviceQueueCreateFlagBits>>::extend(&mut out, iterator);
        out
    }
}
impl std::fmt::Debug for DeviceQueueCreateFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(DeviceQueueCreateFlags);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == DeviceQueueCreateFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(DeviceQueueCreateFlags::PROTECTED) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(PROTECTED))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(DeviceQueueCreateFlags))
            .field(&Flags(*self))
            .finish()
    }
}
# [doc = include_str ! ("../../../doc/VkQueueFlagBits.md")]
#[doc(alias = "VkQueueFlags")]
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct QueueFlags(u32);
impl QueueFlags {
    #[doc(alias = "VK_QUEUE_GRAPHICS_BIT")]
    pub const GRAPHICS: Self = Self(1);
    #[doc(alias = "VK_QUEUE_COMPUTE_BIT")]
    pub const COMPUTE: Self = Self(2);
    #[doc(alias = "VK_QUEUE_TRANSFER_BIT")]
    pub const TRANSFER: Self = Self(4);
    #[doc(alias = "VK_QUEUE_SPARSE_BINDING_BIT")]
    pub const SPARSE_BINDING: Self = Self(8);
    #[doc(alias = "VK_QUEUE_PROTECTED_BIT")]
    pub const PROTECTED: Self = Self(16);
    #[doc(alias = "VK_QUEUE_VIDEO_DECODE_BIT_KHR")]
    #[cfg(feature = "VK_KHR_video_decode_queue")]
    pub const VIDEO_DECODE_KHR: Self = Self(32);
    #[doc(alias = "VK_QUEUE_VIDEO_ENCODE_BIT_KHR")]
    #[cfg(feature = "VK_KHR_video_encode_queue")]
    pub const VIDEO_ENCODE_KHR: Self = Self(64);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    #[allow(unused_mut)]
    pub const fn all() -> Self {
        let mut all = Self::empty();
        {
            all |= Self::GRAPHICS;
        }
        {
            all |= Self::COMPUTE;
        }
        {
            all |= Self::TRANSFER;
        }
        {
            all |= Self::SPARSE_BINDING;
        }
        {
            all |= Self::PROTECTED;
        }
        #[cfg(feature = "VK_KHR_video_decode_queue")]
        {
            all |= Self::VIDEO_DECODE_KHR;
        }
        #[cfg(feature = "VK_KHR_video_encode_queue")]
        {
            all |= Self::VIDEO_ENCODE_KHR;
        }
        all
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl const std::ops::BitOr for QueueFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl const std::ops::BitOrAssign for QueueFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl const std::ops::BitXor for QueueFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl const std::ops::BitXorAssign for QueueFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl const std::ops::BitAnd for QueueFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl const std::ops::BitAndAssign for QueueFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl const std::ops::Sub for QueueFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl const std::ops::SubAssign for QueueFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl const std::ops::Not for QueueFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl Extend<QueueFlags> for QueueFlags {
    fn extend<T: IntoIterator<Item = QueueFlags>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, i);
        }
    }
}
impl FromIterator<QueueFlags> for QueueFlags {
    fn from_iter<T: IntoIterator<Item = QueueFlags>>(iterator: T) -> QueueFlags {
        let mut out = Self::empty();
        <Self as Extend<QueueFlags>>::extend(&mut out, iterator);
        out
    }
}
impl const Default for QueueFlags {
    fn default() -> Self {
        Self::empty()
    }
}
impl const From<QueueFlagBits> for QueueFlags {
    fn from(bit: QueueFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(bit.bits()) }
    }
}
impl Extend<QueueFlagBits> for QueueFlags {
    fn extend<T: IntoIterator<Item = QueueFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, Self::from(i));
        }
    }
}
impl FromIterator<QueueFlagBits> for QueueFlags {
    fn from_iter<T: IntoIterator<Item = QueueFlagBits>>(iterator: T) -> QueueFlags {
        let mut out = Self::empty();
        <Self as Extend<QueueFlagBits>>::extend(&mut out, iterator);
        out
    }
}
impl std::fmt::Debug for QueueFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(QueueFlags);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == QueueFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(QueueFlags::GRAPHICS) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(GRAPHICS))?;
                    }
                    if self.0.contains(QueueFlags::COMPUTE) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(COMPUTE))?;
                    }
                    if self.0.contains(QueueFlags::TRANSFER) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(TRANSFER))?;
                    }
                    if self.0.contains(QueueFlags::SPARSE_BINDING) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(SPARSE_BINDING))?;
                    }
                    if self.0.contains(QueueFlags::PROTECTED) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(PROTECTED))?;
                    }
                    #[cfg(feature = "VK_KHR_video_decode_queue")]
                    if self.0.contains(QueueFlags::VIDEO_DECODE_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(VIDEO_DECODE_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_video_encode_queue")]
                    if self.0.contains(QueueFlags::VIDEO_ENCODE_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(VIDEO_ENCODE_KHR))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(QueueFlags)).field(&Flags(*self)).finish()
    }
}
# [doc = include_str ! ("../../../doc/VkMemoryPropertyFlagBits.md")]
#[doc(alias = "VkMemoryPropertyFlags")]
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct MemoryPropertyFlags(u32);
impl MemoryPropertyFlags {
    #[doc(alias = "VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT")]
    pub const DEVICE_LOCAL: Self = Self(1);
    #[doc(alias = "VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT")]
    pub const HOST_VISIBLE: Self = Self(2);
    #[doc(alias = "VK_MEMORY_PROPERTY_HOST_COHERENT_BIT")]
    pub const HOST_COHERENT: Self = Self(4);
    #[doc(alias = "VK_MEMORY_PROPERTY_HOST_CACHED_BIT")]
    pub const HOST_CACHED: Self = Self(8);
    #[doc(alias = "VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT")]
    pub const LAZILY_ALLOCATED: Self = Self(16);
    #[doc(alias = "VK_MEMORY_PROPERTY_PROTECTED_BIT")]
    pub const PROTECTED: Self = Self(32);
    #[doc(alias = "VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD")]
    #[cfg(feature = "VK_AMD_device_coherent_memory")]
    pub const DEVICE_COHERENT_AMD: Self = Self(64);
    #[doc(alias = "VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD")]
    #[cfg(feature = "VK_AMD_device_coherent_memory")]
    pub const DEVICE_UNCACHED_AMD: Self = Self(128);
    #[doc(alias = "VK_MEMORY_PROPERTY_RDMA_CAPABLE_BIT_NV")]
    #[cfg(feature = "VK_NV_external_memory_rdma")]
    pub const RDMA_CAPABLE_NV: Self = Self(256);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    #[allow(unused_mut)]
    pub const fn all() -> Self {
        let mut all = Self::empty();
        {
            all |= Self::DEVICE_LOCAL;
        }
        {
            all |= Self::HOST_VISIBLE;
        }
        {
            all |= Self::HOST_COHERENT;
        }
        {
            all |= Self::HOST_CACHED;
        }
        {
            all |= Self::LAZILY_ALLOCATED;
        }
        {
            all |= Self::PROTECTED;
        }
        #[cfg(feature = "VK_AMD_device_coherent_memory")]
        {
            all |= Self::DEVICE_COHERENT_AMD;
        }
        #[cfg(feature = "VK_AMD_device_coherent_memory")]
        {
            all |= Self::DEVICE_UNCACHED_AMD;
        }
        #[cfg(feature = "VK_NV_external_memory_rdma")]
        {
            all |= Self::RDMA_CAPABLE_NV;
        }
        all
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl const std::ops::BitOr for MemoryPropertyFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl const std::ops::BitOrAssign for MemoryPropertyFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl const std::ops::BitXor for MemoryPropertyFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl const std::ops::BitXorAssign for MemoryPropertyFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl const std::ops::BitAnd for MemoryPropertyFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl const std::ops::BitAndAssign for MemoryPropertyFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl const std::ops::Sub for MemoryPropertyFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl const std::ops::SubAssign for MemoryPropertyFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl const std::ops::Not for MemoryPropertyFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl Extend<MemoryPropertyFlags> for MemoryPropertyFlags {
    fn extend<T: IntoIterator<Item = MemoryPropertyFlags>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, i);
        }
    }
}
impl FromIterator<MemoryPropertyFlags> for MemoryPropertyFlags {
    fn from_iter<T: IntoIterator<Item = MemoryPropertyFlags>>(iterator: T) -> MemoryPropertyFlags {
        let mut out = Self::empty();
        <Self as Extend<MemoryPropertyFlags>>::extend(&mut out, iterator);
        out
    }
}
impl const Default for MemoryPropertyFlags {
    fn default() -> Self {
        Self::empty()
    }
}
impl const From<MemoryPropertyFlagBits> for MemoryPropertyFlags {
    fn from(bit: MemoryPropertyFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(bit.bits()) }
    }
}
impl Extend<MemoryPropertyFlagBits> for MemoryPropertyFlags {
    fn extend<T: IntoIterator<Item = MemoryPropertyFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, Self::from(i));
        }
    }
}
impl FromIterator<MemoryPropertyFlagBits> for MemoryPropertyFlags {
    fn from_iter<T: IntoIterator<Item = MemoryPropertyFlagBits>>(iterator: T) -> MemoryPropertyFlags {
        let mut out = Self::empty();
        <Self as Extend<MemoryPropertyFlagBits>>::extend(&mut out, iterator);
        out
    }
}
impl std::fmt::Debug for MemoryPropertyFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(MemoryPropertyFlags);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == MemoryPropertyFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(MemoryPropertyFlags::DEVICE_LOCAL) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(DEVICE_LOCAL))?;
                    }
                    if self.0.contains(MemoryPropertyFlags::HOST_VISIBLE) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(HOST_VISIBLE))?;
                    }
                    if self.0.contains(MemoryPropertyFlags::HOST_COHERENT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(HOST_COHERENT))?;
                    }
                    if self.0.contains(MemoryPropertyFlags::HOST_CACHED) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(HOST_CACHED))?;
                    }
                    if self.0.contains(MemoryPropertyFlags::LAZILY_ALLOCATED) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(LAZILY_ALLOCATED))?;
                    }
                    if self.0.contains(MemoryPropertyFlags::PROTECTED) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(PROTECTED))?;
                    }
                    #[cfg(feature = "VK_AMD_device_coherent_memory")]
                    if self.0.contains(MemoryPropertyFlags::DEVICE_COHERENT_AMD) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(DEVICE_COHERENT_AMD))?;
                    }
                    #[cfg(feature = "VK_AMD_device_coherent_memory")]
                    if self.0.contains(MemoryPropertyFlags::DEVICE_UNCACHED_AMD) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(DEVICE_UNCACHED_AMD))?;
                    }
                    #[cfg(feature = "VK_NV_external_memory_rdma")]
                    if self.0.contains(MemoryPropertyFlags::RDMA_CAPABLE_NV) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(RDMA_CAPABLE_NV))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(MemoryPropertyFlags))
            .field(&Flags(*self))
            .finish()
    }
}
# [doc = include_str ! ("../../../doc/VkMemoryHeapFlagBits.md")]
#[doc(alias = "VkMemoryHeapFlags")]
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct MemoryHeapFlags(u32);
impl MemoryHeapFlags {
    #[doc(alias = "VK_MEMORY_HEAP_DEVICE_LOCAL_BIT")]
    pub const DEVICE_LOCAL: Self = Self(1);
    #[doc(alias = "VK_MEMORY_HEAP_MULTI_INSTANCE_BIT")]
    pub const MULTI_INSTANCE: Self = Self(2);
    #[doc(alias = "VK_MEMORY_HEAP_MULTI_INSTANCE_BIT_KHR")]
    #[cfg(feature = "VK_KHR_device_group_creation")]
    pub const MULTI_INSTANCE_KHR: Self = Self::MULTI_INSTANCE;
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    #[allow(unused_mut)]
    pub const fn all() -> Self {
        let mut all = Self::empty();
        {
            all |= Self::DEVICE_LOCAL;
        }
        {
            all |= Self::MULTI_INSTANCE;
        }
        #[cfg(feature = "VK_KHR_device_group_creation")]
        {
            all |= Self::MULTI_INSTANCE_KHR;
        }
        all
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl const std::ops::BitOr for MemoryHeapFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl const std::ops::BitOrAssign for MemoryHeapFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl const std::ops::BitXor for MemoryHeapFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl const std::ops::BitXorAssign for MemoryHeapFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl const std::ops::BitAnd for MemoryHeapFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl const std::ops::BitAndAssign for MemoryHeapFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl const std::ops::Sub for MemoryHeapFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl const std::ops::SubAssign for MemoryHeapFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl const std::ops::Not for MemoryHeapFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl Extend<MemoryHeapFlags> for MemoryHeapFlags {
    fn extend<T: IntoIterator<Item = MemoryHeapFlags>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, i);
        }
    }
}
impl FromIterator<MemoryHeapFlags> for MemoryHeapFlags {
    fn from_iter<T: IntoIterator<Item = MemoryHeapFlags>>(iterator: T) -> MemoryHeapFlags {
        let mut out = Self::empty();
        <Self as Extend<MemoryHeapFlags>>::extend(&mut out, iterator);
        out
    }
}
impl const Default for MemoryHeapFlags {
    fn default() -> Self {
        Self::empty()
    }
}
impl const From<MemoryHeapFlagBits> for MemoryHeapFlags {
    fn from(bit: MemoryHeapFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(bit.bits()) }
    }
}
impl Extend<MemoryHeapFlagBits> for MemoryHeapFlags {
    fn extend<T: IntoIterator<Item = MemoryHeapFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, Self::from(i));
        }
    }
}
impl FromIterator<MemoryHeapFlagBits> for MemoryHeapFlags {
    fn from_iter<T: IntoIterator<Item = MemoryHeapFlagBits>>(iterator: T) -> MemoryHeapFlags {
        let mut out = Self::empty();
        <Self as Extend<MemoryHeapFlagBits>>::extend(&mut out, iterator);
        out
    }
}
impl std::fmt::Debug for MemoryHeapFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(MemoryHeapFlags);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == MemoryHeapFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(MemoryHeapFlags::DEVICE_LOCAL) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(DEVICE_LOCAL))?;
                    }
                    if self.0.contains(MemoryHeapFlags::MULTI_INSTANCE) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(MULTI_INSTANCE))?;
                    }
                    #[cfg(feature = "VK_KHR_device_group_creation")]
                    if self.0.contains(MemoryHeapFlags::MULTI_INSTANCE_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(MULTI_INSTANCE_KHR))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(MemoryHeapFlags)).field(&Flags(*self)).finish()
    }
}
# [doc = include_str ! ("../../../doc/VkAccessFlagBits.md")]
#[doc(alias = "VkAccessFlags")]
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct AccessFlags(u32);
impl AccessFlags {
    #[doc(alias = "VK_ACCESS_INDIRECT_COMMAND_READ_BIT")]
    pub const INDIRECT_COMMAND_READ: Self = Self(1);
    #[doc(alias = "VK_ACCESS_INDEX_READ_BIT")]
    pub const INDEX_READ: Self = Self(2);
    #[doc(alias = "VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT")]
    pub const VERTEX_ATTRIBUTE_READ: Self = Self(4);
    #[doc(alias = "VK_ACCESS_UNIFORM_READ_BIT")]
    pub const UNIFORM_READ: Self = Self(8);
    #[doc(alias = "VK_ACCESS_INPUT_ATTACHMENT_READ_BIT")]
    pub const INPUT_ATTACHMENT_READ: Self = Self(16);
    #[doc(alias = "VK_ACCESS_SHADER_READ_BIT")]
    pub const SHADER_READ: Self = Self(32);
    #[doc(alias = "VK_ACCESS_SHADER_WRITE_BIT")]
    pub const SHADER_WRITE: Self = Self(64);
    #[doc(alias = "VK_ACCESS_COLOR_ATTACHMENT_READ_BIT")]
    pub const COLOR_ATTACHMENT_READ: Self = Self(128);
    #[doc(alias = "VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT")]
    pub const COLOR_ATTACHMENT_WRITE: Self = Self(256);
    #[doc(alias = "VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT")]
    pub const DEPTH_STENCIL_ATTACHMENT_READ: Self = Self(512);
    #[doc(alias = "VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT")]
    pub const DEPTH_STENCIL_ATTACHMENT_WRITE: Self = Self(1024);
    #[doc(alias = "VK_ACCESS_TRANSFER_READ_BIT")]
    pub const TRANSFER_READ: Self = Self(2048);
    #[doc(alias = "VK_ACCESS_TRANSFER_WRITE_BIT")]
    pub const TRANSFER_WRITE: Self = Self(4096);
    #[doc(alias = "VK_ACCESS_HOST_READ_BIT")]
    pub const HOST_READ: Self = Self(8192);
    #[doc(alias = "VK_ACCESS_HOST_WRITE_BIT")]
    pub const HOST_WRITE: Self = Self(16384);
    #[doc(alias = "VK_ACCESS_MEMORY_READ_BIT")]
    pub const MEMORY_READ: Self = Self(32768);
    #[doc(alias = "VK_ACCESS_MEMORY_WRITE_BIT")]
    pub const MEMORY_WRITE: Self = Self(65536);
    #[doc(alias = "VK_ACCESS_NONE")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const NONE: Self = Self(0);
    #[doc(alias = "VK_ACCESS_TRANSFORM_FEEDBACK_WRITE_BIT_EXT")]
    #[cfg(feature = "VK_EXT_transform_feedback")]
    pub const TRANSFORM_FEEDBACK_WRITE_EXT: Self = Self(33554432);
    #[doc(alias = "VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT")]
    #[cfg(feature = "VK_EXT_transform_feedback")]
    pub const TRANSFORM_FEEDBACK_COUNTER_READ_EXT: Self = Self(67108864);
    #[doc(alias = "VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT")]
    #[cfg(feature = "VK_EXT_transform_feedback")]
    pub const TRANSFORM_FEEDBACK_COUNTER_WRITE_EXT: Self = Self(134217728);
    #[doc(alias = "VK_ACCESS_CONDITIONAL_RENDERING_READ_BIT_EXT")]
    #[cfg(feature = "VK_EXT_conditional_rendering")]
    pub const CONDITIONAL_RENDERING_READ_EXT: Self = Self(1048576);
    #[doc(alias = "VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    pub const COLOR_ATTACHMENT_READ_NONCOHERENT_EXT: Self = Self(524288);
    #[doc(alias = "VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR")]
    #[cfg(feature = "VK_KHR_acceleration_structure")]
    pub const ACCELERATION_STRUCTURE_READ_KHR: Self = Self(2097152);
    #[doc(alias = "VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR")]
    #[cfg(feature = "VK_KHR_acceleration_structure")]
    pub const ACCELERATION_STRUCTURE_WRITE_KHR: Self = Self(4194304);
    #[doc(alias = "VK_ACCESS_FRAGMENT_DENSITY_MAP_READ_BIT_EXT")]
    #[cfg(feature = "VK_EXT_fragment_density_map")]
    pub const FRAGMENT_DENSITY_MAP_READ_EXT: Self = Self(16777216);
    #[doc(alias = "VK_ACCESS_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR")]
    #[cfg(feature = "VK_KHR_fragment_shading_rate")]
    pub const FRAGMENT_SHADING_RATE_ATTACHMENT_READ_KHR: Self = Self(8388608);
    #[doc(alias = "VK_ACCESS_COMMAND_PREPROCESS_READ_BIT_NV")]
    #[cfg(feature = "VK_NV_device_generated_commands")]
    pub const COMMAND_PREPROCESS_READ_NV: Self = Self(131072);
    #[doc(alias = "VK_ACCESS_COMMAND_PREPROCESS_WRITE_BIT_NV")]
    #[cfg(feature = "VK_NV_device_generated_commands")]
    pub const COMMAND_PREPROCESS_WRITE_NV: Self = Self(262144);
    #[doc(alias = "VK_ACCESS_SHADING_RATE_IMAGE_READ_BIT_NV")]
    #[cfg(feature = "VK_NV_shading_rate_image")]
    pub const SHADING_RATE_IMAGE_READ_NV: Self = Self::FRAGMENT_SHADING_RATE_ATTACHMENT_READ_KHR;
    #[doc(alias = "VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_NV")]
    #[cfg(feature = "VK_NV_ray_tracing")]
    pub const ACCELERATION_STRUCTURE_READ_NV: Self = Self::ACCELERATION_STRUCTURE_READ_KHR;
    #[doc(alias = "VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_NV")]
    #[cfg(feature = "VK_NV_ray_tracing")]
    pub const ACCELERATION_STRUCTURE_WRITE_NV: Self = Self::ACCELERATION_STRUCTURE_WRITE_KHR;
    #[doc(alias = "VK_ACCESS_NONE_KHR")]
    #[cfg(feature = "VK_KHR_synchronization2")]
    pub const NONE_KHR: Self = Self::NONE;
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    #[allow(unused_mut)]
    pub const fn all() -> Self {
        let mut all = Self::empty();
        {
            all |= Self::INDIRECT_COMMAND_READ;
        }
        {
            all |= Self::INDEX_READ;
        }
        {
            all |= Self::VERTEX_ATTRIBUTE_READ;
        }
        {
            all |= Self::UNIFORM_READ;
        }
        {
            all |= Self::INPUT_ATTACHMENT_READ;
        }
        {
            all |= Self::SHADER_READ;
        }
        {
            all |= Self::SHADER_WRITE;
        }
        {
            all |= Self::COLOR_ATTACHMENT_READ;
        }
        {
            all |= Self::COLOR_ATTACHMENT_WRITE;
        }
        {
            all |= Self::DEPTH_STENCIL_ATTACHMENT_READ;
        }
        {
            all |= Self::DEPTH_STENCIL_ATTACHMENT_WRITE;
        }
        {
            all |= Self::TRANSFER_READ;
        }
        {
            all |= Self::TRANSFER_WRITE;
        }
        {
            all |= Self::HOST_READ;
        }
        {
            all |= Self::HOST_WRITE;
        }
        {
            all |= Self::MEMORY_READ;
        }
        {
            all |= Self::MEMORY_WRITE;
        }
        #[cfg(feature = "VULKAN_1_3")]
        {
            all |= Self::NONE;
        }
        #[cfg(feature = "VK_EXT_transform_feedback")]
        {
            all |= Self::TRANSFORM_FEEDBACK_WRITE_EXT;
        }
        #[cfg(feature = "VK_EXT_transform_feedback")]
        {
            all |= Self::TRANSFORM_FEEDBACK_COUNTER_READ_EXT;
        }
        #[cfg(feature = "VK_EXT_transform_feedback")]
        {
            all |= Self::TRANSFORM_FEEDBACK_COUNTER_WRITE_EXT;
        }
        #[cfg(feature = "VK_EXT_conditional_rendering")]
        {
            all |= Self::CONDITIONAL_RENDERING_READ_EXT;
        }
        #[cfg(feature = "VK_EXT_blend_operation_advanced")]
        {
            all |= Self::COLOR_ATTACHMENT_READ_NONCOHERENT_EXT;
        }
        #[cfg(feature = "VK_KHR_acceleration_structure")]
        {
            all |= Self::ACCELERATION_STRUCTURE_READ_KHR;
        }
        #[cfg(feature = "VK_KHR_acceleration_structure")]
        {
            all |= Self::ACCELERATION_STRUCTURE_WRITE_KHR;
        }
        #[cfg(feature = "VK_EXT_fragment_density_map")]
        {
            all |= Self::FRAGMENT_DENSITY_MAP_READ_EXT;
        }
        #[cfg(feature = "VK_KHR_fragment_shading_rate")]
        {
            all |= Self::FRAGMENT_SHADING_RATE_ATTACHMENT_READ_KHR;
        }
        #[cfg(feature = "VK_NV_device_generated_commands")]
        {
            all |= Self::COMMAND_PREPROCESS_READ_NV;
        }
        #[cfg(feature = "VK_NV_device_generated_commands")]
        {
            all |= Self::COMMAND_PREPROCESS_WRITE_NV;
        }
        #[cfg(feature = "VK_NV_shading_rate_image")]
        {
            all |= Self::SHADING_RATE_IMAGE_READ_NV;
        }
        #[cfg(feature = "VK_NV_ray_tracing")]
        {
            all |= Self::ACCELERATION_STRUCTURE_READ_NV;
        }
        #[cfg(feature = "VK_NV_ray_tracing")]
        {
            all |= Self::ACCELERATION_STRUCTURE_WRITE_NV;
        }
        #[cfg(feature = "VK_KHR_synchronization2")]
        {
            all |= Self::NONE_KHR;
        }
        all
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl const std::ops::BitOr for AccessFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl const std::ops::BitOrAssign for AccessFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl const std::ops::BitXor for AccessFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl const std::ops::BitXorAssign for AccessFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl const std::ops::BitAnd for AccessFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl const std::ops::BitAndAssign for AccessFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl const std::ops::Sub for AccessFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl const std::ops::SubAssign for AccessFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl const std::ops::Not for AccessFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl Extend<AccessFlags> for AccessFlags {
    fn extend<T: IntoIterator<Item = AccessFlags>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, i);
        }
    }
}
impl FromIterator<AccessFlags> for AccessFlags {
    fn from_iter<T: IntoIterator<Item = AccessFlags>>(iterator: T) -> AccessFlags {
        let mut out = Self::empty();
        <Self as Extend<AccessFlags>>::extend(&mut out, iterator);
        out
    }
}
impl const Default for AccessFlags {
    fn default() -> Self {
        Self::empty()
    }
}
impl const From<AccessFlagBits> for AccessFlags {
    fn from(bit: AccessFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(bit.bits()) }
    }
}
impl Extend<AccessFlagBits> for AccessFlags {
    fn extend<T: IntoIterator<Item = AccessFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, Self::from(i));
        }
    }
}
impl FromIterator<AccessFlagBits> for AccessFlags {
    fn from_iter<T: IntoIterator<Item = AccessFlagBits>>(iterator: T) -> AccessFlags {
        let mut out = Self::empty();
        <Self as Extend<AccessFlagBits>>::extend(&mut out, iterator);
        out
    }
}
impl std::fmt::Debug for AccessFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(AccessFlags);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == AccessFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(AccessFlags::INDIRECT_COMMAND_READ) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(INDIRECT_COMMAND_READ))?;
                    }
                    if self.0.contains(AccessFlags::INDEX_READ) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(INDEX_READ))?;
                    }
                    if self.0.contains(AccessFlags::VERTEX_ATTRIBUTE_READ) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(VERTEX_ATTRIBUTE_READ))?;
                    }
                    if self.0.contains(AccessFlags::UNIFORM_READ) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(UNIFORM_READ))?;
                    }
                    if self.0.contains(AccessFlags::INPUT_ATTACHMENT_READ) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(INPUT_ATTACHMENT_READ))?;
                    }
                    if self.0.contains(AccessFlags::SHADER_READ) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(SHADER_READ))?;
                    }
                    if self.0.contains(AccessFlags::SHADER_WRITE) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(SHADER_WRITE))?;
                    }
                    if self.0.contains(AccessFlags::COLOR_ATTACHMENT_READ) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(COLOR_ATTACHMENT_READ))?;
                    }
                    if self.0.contains(AccessFlags::COLOR_ATTACHMENT_WRITE) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(COLOR_ATTACHMENT_WRITE))?;
                    }
                    if self.0.contains(AccessFlags::DEPTH_STENCIL_ATTACHMENT_READ) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(DEPTH_STENCIL_ATTACHMENT_READ))?;
                    }
                    if self.0.contains(AccessFlags::DEPTH_STENCIL_ATTACHMENT_WRITE) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(DEPTH_STENCIL_ATTACHMENT_WRITE))?;
                    }
                    if self.0.contains(AccessFlags::TRANSFER_READ) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(TRANSFER_READ))?;
                    }
                    if self.0.contains(AccessFlags::TRANSFER_WRITE) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(TRANSFER_WRITE))?;
                    }
                    if self.0.contains(AccessFlags::HOST_READ) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(HOST_READ))?;
                    }
                    if self.0.contains(AccessFlags::HOST_WRITE) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(HOST_WRITE))?;
                    }
                    if self.0.contains(AccessFlags::MEMORY_READ) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(MEMORY_READ))?;
                    }
                    if self.0.contains(AccessFlags::MEMORY_WRITE) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(MEMORY_WRITE))?;
                    }
                    #[cfg(feature = "VULKAN_1_3")]
                    if self.0.contains(AccessFlags::NONE) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(NONE))?;
                    }
                    #[cfg(feature = "VK_EXT_transform_feedback")]
                    if self.0.contains(AccessFlags::TRANSFORM_FEEDBACK_WRITE_EXT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(TRANSFORM_FEEDBACK_WRITE_EXT))?;
                    }
                    #[cfg(feature = "VK_EXT_transform_feedback")]
                    if self.0.contains(AccessFlags::TRANSFORM_FEEDBACK_COUNTER_READ_EXT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(TRANSFORM_FEEDBACK_COUNTER_READ_EXT))?;
                    }
                    #[cfg(feature = "VK_EXT_transform_feedback")]
                    if self.0.contains(AccessFlags::TRANSFORM_FEEDBACK_COUNTER_WRITE_EXT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(TRANSFORM_FEEDBACK_COUNTER_WRITE_EXT))?;
                    }
                    #[cfg(feature = "VK_EXT_conditional_rendering")]
                    if self.0.contains(AccessFlags::CONDITIONAL_RENDERING_READ_EXT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(CONDITIONAL_RENDERING_READ_EXT))?;
                    }
                    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
                    if self.0.contains(AccessFlags::COLOR_ATTACHMENT_READ_NONCOHERENT_EXT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(COLOR_ATTACHMENT_READ_NONCOHERENT_EXT))?;
                    }
                    #[cfg(feature = "VK_KHR_acceleration_structure")]
                    if self.0.contains(AccessFlags::ACCELERATION_STRUCTURE_READ_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(ACCELERATION_STRUCTURE_READ_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_acceleration_structure")]
                    if self.0.contains(AccessFlags::ACCELERATION_STRUCTURE_WRITE_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(ACCELERATION_STRUCTURE_WRITE_KHR))?;
                    }
                    #[cfg(feature = "VK_EXT_fragment_density_map")]
                    if self.0.contains(AccessFlags::FRAGMENT_DENSITY_MAP_READ_EXT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(FRAGMENT_DENSITY_MAP_READ_EXT))?;
                    }
                    #[cfg(feature = "VK_KHR_fragment_shading_rate")]
                    if self.0.contains(AccessFlags::FRAGMENT_SHADING_RATE_ATTACHMENT_READ_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(FRAGMENT_SHADING_RATE_ATTACHMENT_READ_KHR))?;
                    }
                    #[cfg(feature = "VK_NV_device_generated_commands")]
                    if self.0.contains(AccessFlags::COMMAND_PREPROCESS_READ_NV) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(COMMAND_PREPROCESS_READ_NV))?;
                    }
                    #[cfg(feature = "VK_NV_device_generated_commands")]
                    if self.0.contains(AccessFlags::COMMAND_PREPROCESS_WRITE_NV) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(COMMAND_PREPROCESS_WRITE_NV))?;
                    }
                    #[cfg(feature = "VK_NV_shading_rate_image")]
                    if self.0.contains(AccessFlags::SHADING_RATE_IMAGE_READ_NV) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(SHADING_RATE_IMAGE_READ_NV))?;
                    }
                    #[cfg(feature = "VK_NV_ray_tracing")]
                    if self.0.contains(AccessFlags::ACCELERATION_STRUCTURE_READ_NV) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(ACCELERATION_STRUCTURE_READ_NV))?;
                    }
                    #[cfg(feature = "VK_NV_ray_tracing")]
                    if self.0.contains(AccessFlags::ACCELERATION_STRUCTURE_WRITE_NV) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(ACCELERATION_STRUCTURE_WRITE_NV))?;
                    }
                    #[cfg(feature = "VK_KHR_synchronization2")]
                    if self.0.contains(AccessFlags::NONE_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(NONE_KHR))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(AccessFlags)).field(&Flags(*self)).finish()
    }
}
# [doc = include_str ! ("../../../doc/VkBufferUsageFlagBits.md")]
#[doc(alias = "VkBufferUsageFlags")]
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct BufferUsageFlags(u32);
impl BufferUsageFlags {
    #[doc(alias = "VK_BUFFER_USAGE_TRANSFER_SRC_BIT")]
    pub const TRANSFER_SRC: Self = Self(1);
    #[doc(alias = "VK_BUFFER_USAGE_TRANSFER_DST_BIT")]
    pub const TRANSFER_DST: Self = Self(2);
    #[doc(alias = "VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT")]
    pub const UNIFORM_TEXEL_BUFFER: Self = Self(4);
    #[doc(alias = "VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT")]
    pub const STORAGE_TEXEL_BUFFER: Self = Self(8);
    #[doc(alias = "VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT")]
    pub const UNIFORM_BUFFER: Self = Self(16);
    #[doc(alias = "VK_BUFFER_USAGE_STORAGE_BUFFER_BIT")]
    pub const STORAGE_BUFFER: Self = Self(32);
    #[doc(alias = "VK_BUFFER_USAGE_INDEX_BUFFER_BIT")]
    pub const INDEX_BUFFER: Self = Self(64);
    #[doc(alias = "VK_BUFFER_USAGE_VERTEX_BUFFER_BIT")]
    pub const VERTEX_BUFFER: Self = Self(128);
    #[doc(alias = "VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT")]
    pub const INDIRECT_BUFFER: Self = Self(256);
    #[doc(alias = "VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT")]
    #[cfg(feature = "VULKAN_1_2")]
    pub const SHADER_DEVICE_ADDRESS: Self = Self(131072);
    #[doc(alias = "VK_BUFFER_USAGE_VIDEO_DECODE_SRC_BIT_KHR")]
    #[cfg(feature = "VK_KHR_video_decode_queue")]
    pub const VIDEO_DECODE_SRC_KHR: Self = Self(8192);
    #[doc(alias = "VK_BUFFER_USAGE_VIDEO_DECODE_DST_BIT_KHR")]
    #[cfg(feature = "VK_KHR_video_decode_queue")]
    pub const VIDEO_DECODE_DST_KHR: Self = Self(16384);
    #[doc(alias = "VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT")]
    #[cfg(feature = "VK_EXT_transform_feedback")]
    pub const TRANSFORM_FEEDBACK_BUFFER_EXT: Self = Self(2048);
    #[doc(alias = "VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT")]
    #[cfg(feature = "VK_EXT_transform_feedback")]
    pub const TRANSFORM_FEEDBACK_COUNTER_BUFFER_EXT: Self = Self(4096);
    #[doc(alias = "VK_BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT")]
    #[cfg(feature = "VK_EXT_conditional_rendering")]
    pub const CONDITIONAL_RENDERING_EXT: Self = Self(512);
    #[doc(alias = "VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR")]
    #[cfg(feature = "VK_KHR_acceleration_structure")]
    pub const ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_KHR: Self = Self(524288);
    #[doc(alias = "VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR")]
    #[cfg(feature = "VK_KHR_acceleration_structure")]
    pub const ACCELERATION_STRUCTURE_STORAGE_KHR: Self = Self(1048576);
    #[doc(alias = "VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR")]
    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
    pub const SHADER_BINDING_TABLE_KHR: Self = Self(1024);
    #[doc(alias = "VK_BUFFER_USAGE_VIDEO_ENCODE_DST_BIT_KHR")]
    #[cfg(feature = "VK_KHR_video_encode_queue")]
    pub const VIDEO_ENCODE_DST_KHR: Self = Self(32768);
    #[doc(alias = "VK_BUFFER_USAGE_VIDEO_ENCODE_SRC_BIT_KHR")]
    #[cfg(feature = "VK_KHR_video_encode_queue")]
    pub const VIDEO_ENCODE_SRC_KHR: Self = Self(65536);
    #[doc(alias = "VK_BUFFER_USAGE_RAY_TRACING_BIT_NV")]
    #[cfg(feature = "VK_NV_ray_tracing")]
    pub const RAY_TRACING_NV: Self = Self::SHADER_BINDING_TABLE_KHR;
    #[doc(alias = "VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_EXT")]
    #[cfg(feature = "VK_EXT_buffer_device_address")]
    pub const SHADER_DEVICE_ADDRESS_EXT: Self = Self::SHADER_DEVICE_ADDRESS;
    #[doc(alias = "VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_KHR")]
    #[cfg(feature = "VK_KHR_buffer_device_address")]
    pub const SHADER_DEVICE_ADDRESS_KHR: Self = Self::SHADER_DEVICE_ADDRESS;
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    #[allow(unused_mut)]
    pub const fn all() -> Self {
        let mut all = Self::empty();
        {
            all |= Self::TRANSFER_SRC;
        }
        {
            all |= Self::TRANSFER_DST;
        }
        {
            all |= Self::UNIFORM_TEXEL_BUFFER;
        }
        {
            all |= Self::STORAGE_TEXEL_BUFFER;
        }
        {
            all |= Self::UNIFORM_BUFFER;
        }
        {
            all |= Self::STORAGE_BUFFER;
        }
        {
            all |= Self::INDEX_BUFFER;
        }
        {
            all |= Self::VERTEX_BUFFER;
        }
        {
            all |= Self::INDIRECT_BUFFER;
        }
        #[cfg(feature = "VULKAN_1_2")]
        {
            all |= Self::SHADER_DEVICE_ADDRESS;
        }
        #[cfg(feature = "VK_KHR_video_decode_queue")]
        {
            all |= Self::VIDEO_DECODE_SRC_KHR;
        }
        #[cfg(feature = "VK_KHR_video_decode_queue")]
        {
            all |= Self::VIDEO_DECODE_DST_KHR;
        }
        #[cfg(feature = "VK_EXT_transform_feedback")]
        {
            all |= Self::TRANSFORM_FEEDBACK_BUFFER_EXT;
        }
        #[cfg(feature = "VK_EXT_transform_feedback")]
        {
            all |= Self::TRANSFORM_FEEDBACK_COUNTER_BUFFER_EXT;
        }
        #[cfg(feature = "VK_EXT_conditional_rendering")]
        {
            all |= Self::CONDITIONAL_RENDERING_EXT;
        }
        #[cfg(feature = "VK_KHR_acceleration_structure")]
        {
            all |= Self::ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_KHR;
        }
        #[cfg(feature = "VK_KHR_acceleration_structure")]
        {
            all |= Self::ACCELERATION_STRUCTURE_STORAGE_KHR;
        }
        #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
        {
            all |= Self::SHADER_BINDING_TABLE_KHR;
        }
        #[cfg(feature = "VK_KHR_video_encode_queue")]
        {
            all |= Self::VIDEO_ENCODE_DST_KHR;
        }
        #[cfg(feature = "VK_KHR_video_encode_queue")]
        {
            all |= Self::VIDEO_ENCODE_SRC_KHR;
        }
        #[cfg(feature = "VK_NV_ray_tracing")]
        {
            all |= Self::RAY_TRACING_NV;
        }
        #[cfg(feature = "VK_EXT_buffer_device_address")]
        {
            all |= Self::SHADER_DEVICE_ADDRESS_EXT;
        }
        #[cfg(feature = "VK_KHR_buffer_device_address")]
        {
            all |= Self::SHADER_DEVICE_ADDRESS_KHR;
        }
        all
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl const std::ops::BitOr for BufferUsageFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl const std::ops::BitOrAssign for BufferUsageFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl const std::ops::BitXor for BufferUsageFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl const std::ops::BitXorAssign for BufferUsageFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl const std::ops::BitAnd for BufferUsageFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl const std::ops::BitAndAssign for BufferUsageFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl const std::ops::Sub for BufferUsageFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl const std::ops::SubAssign for BufferUsageFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl const std::ops::Not for BufferUsageFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl Extend<BufferUsageFlags> for BufferUsageFlags {
    fn extend<T: IntoIterator<Item = BufferUsageFlags>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, i);
        }
    }
}
impl FromIterator<BufferUsageFlags> for BufferUsageFlags {
    fn from_iter<T: IntoIterator<Item = BufferUsageFlags>>(iterator: T) -> BufferUsageFlags {
        let mut out = Self::empty();
        <Self as Extend<BufferUsageFlags>>::extend(&mut out, iterator);
        out
    }
}
impl const Default for BufferUsageFlags {
    fn default() -> Self {
        Self::empty()
    }
}
impl const From<BufferUsageFlagBits> for BufferUsageFlags {
    fn from(bit: BufferUsageFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(bit.bits()) }
    }
}
impl Extend<BufferUsageFlagBits> for BufferUsageFlags {
    fn extend<T: IntoIterator<Item = BufferUsageFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, Self::from(i));
        }
    }
}
impl FromIterator<BufferUsageFlagBits> for BufferUsageFlags {
    fn from_iter<T: IntoIterator<Item = BufferUsageFlagBits>>(iterator: T) -> BufferUsageFlags {
        let mut out = Self::empty();
        <Self as Extend<BufferUsageFlagBits>>::extend(&mut out, iterator);
        out
    }
}
impl std::fmt::Debug for BufferUsageFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(BufferUsageFlags);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == BufferUsageFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(BufferUsageFlags::TRANSFER_SRC) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(TRANSFER_SRC))?;
                    }
                    if self.0.contains(BufferUsageFlags::TRANSFER_DST) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(TRANSFER_DST))?;
                    }
                    if self.0.contains(BufferUsageFlags::UNIFORM_TEXEL_BUFFER) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(UNIFORM_TEXEL_BUFFER))?;
                    }
                    if self.0.contains(BufferUsageFlags::STORAGE_TEXEL_BUFFER) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(STORAGE_TEXEL_BUFFER))?;
                    }
                    if self.0.contains(BufferUsageFlags::UNIFORM_BUFFER) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(UNIFORM_BUFFER))?;
                    }
                    if self.0.contains(BufferUsageFlags::STORAGE_BUFFER) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(STORAGE_BUFFER))?;
                    }
                    if self.0.contains(BufferUsageFlags::INDEX_BUFFER) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(INDEX_BUFFER))?;
                    }
                    if self.0.contains(BufferUsageFlags::VERTEX_BUFFER) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(VERTEX_BUFFER))?;
                    }
                    if self.0.contains(BufferUsageFlags::INDIRECT_BUFFER) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(INDIRECT_BUFFER))?;
                    }
                    #[cfg(feature = "VULKAN_1_2")]
                    if self.0.contains(BufferUsageFlags::SHADER_DEVICE_ADDRESS) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(SHADER_DEVICE_ADDRESS))?;
                    }
                    #[cfg(feature = "VK_KHR_video_decode_queue")]
                    if self.0.contains(BufferUsageFlags::VIDEO_DECODE_SRC_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(VIDEO_DECODE_SRC_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_video_decode_queue")]
                    if self.0.contains(BufferUsageFlags::VIDEO_DECODE_DST_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(VIDEO_DECODE_DST_KHR))?;
                    }
                    #[cfg(feature = "VK_EXT_transform_feedback")]
                    if self.0.contains(BufferUsageFlags::TRANSFORM_FEEDBACK_BUFFER_EXT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(TRANSFORM_FEEDBACK_BUFFER_EXT))?;
                    }
                    #[cfg(feature = "VK_EXT_transform_feedback")]
                    if self.0.contains(BufferUsageFlags::TRANSFORM_FEEDBACK_COUNTER_BUFFER_EXT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(TRANSFORM_FEEDBACK_COUNTER_BUFFER_EXT))?;
                    }
                    #[cfg(feature = "VK_EXT_conditional_rendering")]
                    if self.0.contains(BufferUsageFlags::CONDITIONAL_RENDERING_EXT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(CONDITIONAL_RENDERING_EXT))?;
                    }
                    #[cfg(feature = "VK_KHR_acceleration_structure")]
                    if self
                        .0
                        .contains(BufferUsageFlags::ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_KHR)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_acceleration_structure")]
                    if self.0.contains(BufferUsageFlags::ACCELERATION_STRUCTURE_STORAGE_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(ACCELERATION_STRUCTURE_STORAGE_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
                    if self.0.contains(BufferUsageFlags::SHADER_BINDING_TABLE_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(SHADER_BINDING_TABLE_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_video_encode_queue")]
                    if self.0.contains(BufferUsageFlags::VIDEO_ENCODE_DST_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(VIDEO_ENCODE_DST_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_video_encode_queue")]
                    if self.0.contains(BufferUsageFlags::VIDEO_ENCODE_SRC_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(VIDEO_ENCODE_SRC_KHR))?;
                    }
                    #[cfg(feature = "VK_NV_ray_tracing")]
                    if self.0.contains(BufferUsageFlags::RAY_TRACING_NV) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(RAY_TRACING_NV))?;
                    }
                    #[cfg(feature = "VK_EXT_buffer_device_address")]
                    if self.0.contains(BufferUsageFlags::SHADER_DEVICE_ADDRESS_EXT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(SHADER_DEVICE_ADDRESS_EXT))?;
                    }
                    #[cfg(feature = "VK_KHR_buffer_device_address")]
                    if self.0.contains(BufferUsageFlags::SHADER_DEVICE_ADDRESS_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(SHADER_DEVICE_ADDRESS_KHR))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(BufferUsageFlags))
            .field(&Flags(*self))
            .finish()
    }
}
# [doc = include_str ! ("../../../doc/VkBufferCreateFlagBits.md")]
#[doc(alias = "VkBufferCreateFlags")]
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct BufferCreateFlags(u32);
impl BufferCreateFlags {
    #[doc(alias = "VK_BUFFER_CREATE_SPARSE_BINDING_BIT")]
    pub const SPARSE_BINDING: Self = Self(1);
    #[doc(alias = "VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT")]
    pub const SPARSE_RESIDENCY: Self = Self(2);
    #[doc(alias = "VK_BUFFER_CREATE_SPARSE_ALIASED_BIT")]
    pub const SPARSE_ALIASED: Self = Self(4);
    #[doc(alias = "VK_BUFFER_CREATE_PROTECTED_BIT")]
    pub const PROTECTED: Self = Self(8);
    #[doc(alias = "VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT")]
    #[cfg(feature = "VULKAN_1_2")]
    pub const DEVICE_ADDRESS_CAPTURE_REPLAY: Self = Self(16);
    #[doc(alias = "VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT")]
    #[cfg(feature = "VK_EXT_buffer_device_address")]
    pub const DEVICE_ADDRESS_CAPTURE_REPLAY_EXT: Self = Self::DEVICE_ADDRESS_CAPTURE_REPLAY;
    #[doc(alias = "VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR")]
    #[cfg(feature = "VK_KHR_buffer_device_address")]
    pub const DEVICE_ADDRESS_CAPTURE_REPLAY_KHR: Self = Self::DEVICE_ADDRESS_CAPTURE_REPLAY;
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    #[allow(unused_mut)]
    pub const fn all() -> Self {
        let mut all = Self::empty();
        {
            all |= Self::SPARSE_BINDING;
        }
        {
            all |= Self::SPARSE_RESIDENCY;
        }
        {
            all |= Self::SPARSE_ALIASED;
        }
        {
            all |= Self::PROTECTED;
        }
        #[cfg(feature = "VULKAN_1_2")]
        {
            all |= Self::DEVICE_ADDRESS_CAPTURE_REPLAY;
        }
        #[cfg(feature = "VK_EXT_buffer_device_address")]
        {
            all |= Self::DEVICE_ADDRESS_CAPTURE_REPLAY_EXT;
        }
        #[cfg(feature = "VK_KHR_buffer_device_address")]
        {
            all |= Self::DEVICE_ADDRESS_CAPTURE_REPLAY_KHR;
        }
        all
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl const std::ops::BitOr for BufferCreateFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl const std::ops::BitOrAssign for BufferCreateFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl const std::ops::BitXor for BufferCreateFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl const std::ops::BitXorAssign for BufferCreateFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl const std::ops::BitAnd for BufferCreateFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl const std::ops::BitAndAssign for BufferCreateFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl const std::ops::Sub for BufferCreateFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl const std::ops::SubAssign for BufferCreateFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl const std::ops::Not for BufferCreateFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl Extend<BufferCreateFlags> for BufferCreateFlags {
    fn extend<T: IntoIterator<Item = BufferCreateFlags>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, i);
        }
    }
}
impl FromIterator<BufferCreateFlags> for BufferCreateFlags {
    fn from_iter<T: IntoIterator<Item = BufferCreateFlags>>(iterator: T) -> BufferCreateFlags {
        let mut out = Self::empty();
        <Self as Extend<BufferCreateFlags>>::extend(&mut out, iterator);
        out
    }
}
impl const Default for BufferCreateFlags {
    fn default() -> Self {
        Self::empty()
    }
}
impl const From<BufferCreateFlagBits> for BufferCreateFlags {
    fn from(bit: BufferCreateFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(bit.bits()) }
    }
}
impl Extend<BufferCreateFlagBits> for BufferCreateFlags {
    fn extend<T: IntoIterator<Item = BufferCreateFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, Self::from(i));
        }
    }
}
impl FromIterator<BufferCreateFlagBits> for BufferCreateFlags {
    fn from_iter<T: IntoIterator<Item = BufferCreateFlagBits>>(iterator: T) -> BufferCreateFlags {
        let mut out = Self::empty();
        <Self as Extend<BufferCreateFlagBits>>::extend(&mut out, iterator);
        out
    }
}
impl std::fmt::Debug for BufferCreateFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(BufferCreateFlags);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == BufferCreateFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(BufferCreateFlags::SPARSE_BINDING) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(SPARSE_BINDING))?;
                    }
                    if self.0.contains(BufferCreateFlags::SPARSE_RESIDENCY) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(SPARSE_RESIDENCY))?;
                    }
                    if self.0.contains(BufferCreateFlags::SPARSE_ALIASED) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(SPARSE_ALIASED))?;
                    }
                    if self.0.contains(BufferCreateFlags::PROTECTED) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(PROTECTED))?;
                    }
                    #[cfg(feature = "VULKAN_1_2")]
                    if self.0.contains(BufferCreateFlags::DEVICE_ADDRESS_CAPTURE_REPLAY) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(DEVICE_ADDRESS_CAPTURE_REPLAY))?;
                    }
                    #[cfg(feature = "VK_EXT_buffer_device_address")]
                    if self.0.contains(BufferCreateFlags::DEVICE_ADDRESS_CAPTURE_REPLAY_EXT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(DEVICE_ADDRESS_CAPTURE_REPLAY_EXT))?;
                    }
                    #[cfg(feature = "VK_KHR_buffer_device_address")]
                    if self.0.contains(BufferCreateFlags::DEVICE_ADDRESS_CAPTURE_REPLAY_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(DEVICE_ADDRESS_CAPTURE_REPLAY_KHR))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(BufferCreateFlags))
            .field(&Flags(*self))
            .finish()
    }
}
# [doc = include_str ! ("../../../doc/VkShaderStageFlagBits.md")]
#[doc(alias = "VkShaderStageFlags")]
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct ShaderStageFlags(u32);
impl ShaderStageFlags {
    #[doc(alias = "VK_SHADER_STAGE_VERTEX_BIT")]
    pub const VERTEX: Self = Self(1);
    #[doc(alias = "VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT")]
    pub const TESSELLATION_CONTROL: Self = Self(2);
    #[doc(alias = "VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT")]
    pub const TESSELLATION_EVALUATION: Self = Self(4);
    #[doc(alias = "VK_SHADER_STAGE_GEOMETRY_BIT")]
    pub const GEOMETRY: Self = Self(8);
    #[doc(alias = "VK_SHADER_STAGE_FRAGMENT_BIT")]
    pub const FRAGMENT: Self = Self(16);
    #[doc(alias = "VK_SHADER_STAGE_COMPUTE_BIT")]
    pub const COMPUTE: Self = Self(32);
    #[doc(alias = "VK_SHADER_STAGE_ALL_GRAPHICS")]
    pub const ALL_GRAPHICS: Self = Self(31);
    #[doc(alias = "VK_SHADER_STAGE_ALL")]
    pub const ALL: Self = Self(2147483647);
    #[doc(alias = "VK_SHADER_STAGE_RAYGEN_BIT_KHR")]
    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
    pub const RAYGEN_KHR: Self = Self(256);
    #[doc(alias = "VK_SHADER_STAGE_ANY_HIT_BIT_KHR")]
    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
    pub const ANY_HIT_KHR: Self = Self(512);
    #[doc(alias = "VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR")]
    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
    pub const CLOSEST_HIT_KHR: Self = Self(1024);
    #[doc(alias = "VK_SHADER_STAGE_MISS_BIT_KHR")]
    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
    pub const MISS_KHR: Self = Self(2048);
    #[doc(alias = "VK_SHADER_STAGE_INTERSECTION_BIT_KHR")]
    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
    pub const INTERSECTION_KHR: Self = Self(4096);
    #[doc(alias = "VK_SHADER_STAGE_CALLABLE_BIT_KHR")]
    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
    pub const CALLABLE_KHR: Self = Self(8192);
    #[doc(alias = "VK_SHADER_STAGE_TASK_BIT_NV")]
    #[cfg(feature = "VK_NV_mesh_shader")]
    pub const TASK_NV: Self = Self(64);
    #[doc(alias = "VK_SHADER_STAGE_MESH_BIT_NV")]
    #[cfg(feature = "VK_NV_mesh_shader")]
    pub const MESH_NV: Self = Self(128);
    #[doc(alias = "VK_SHADER_STAGE_SUBPASS_SHADING_BIT_HUAWEI")]
    #[cfg(feature = "VK_HUAWEI_subpass_shading")]
    pub const SUBPASS_SHADING_HUAWEI: Self = Self(16384);
    #[doc(alias = "VK_SHADER_STAGE_RAYGEN_BIT_NV")]
    #[cfg(feature = "VK_NV_ray_tracing")]
    pub const RAYGEN_NV: Self = Self::RAYGEN_KHR;
    #[doc(alias = "VK_SHADER_STAGE_ANY_HIT_BIT_NV")]
    #[cfg(feature = "VK_NV_ray_tracing")]
    pub const ANY_HIT_NV: Self = Self::ANY_HIT_KHR;
    #[doc(alias = "VK_SHADER_STAGE_CLOSEST_HIT_BIT_NV")]
    #[cfg(feature = "VK_NV_ray_tracing")]
    pub const CLOSEST_HIT_NV: Self = Self::CLOSEST_HIT_KHR;
    #[doc(alias = "VK_SHADER_STAGE_MISS_BIT_NV")]
    #[cfg(feature = "VK_NV_ray_tracing")]
    pub const MISS_NV: Self = Self::MISS_KHR;
    #[doc(alias = "VK_SHADER_STAGE_INTERSECTION_BIT_NV")]
    #[cfg(feature = "VK_NV_ray_tracing")]
    pub const INTERSECTION_NV: Self = Self::INTERSECTION_KHR;
    #[doc(alias = "VK_SHADER_STAGE_CALLABLE_BIT_NV")]
    #[cfg(feature = "VK_NV_ray_tracing")]
    pub const CALLABLE_NV: Self = Self::CALLABLE_KHR;
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    #[allow(unused_mut)]
    pub const fn all() -> Self {
        let mut all = Self::empty();
        {
            all |= Self::VERTEX;
        }
        {
            all |= Self::TESSELLATION_CONTROL;
        }
        {
            all |= Self::TESSELLATION_EVALUATION;
        }
        {
            all |= Self::GEOMETRY;
        }
        {
            all |= Self::FRAGMENT;
        }
        {
            all |= Self::COMPUTE;
        }
        {
            all |= Self::ALL_GRAPHICS;
        }
        {
            all |= Self::ALL;
        }
        #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
        {
            all |= Self::RAYGEN_KHR;
        }
        #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
        {
            all |= Self::ANY_HIT_KHR;
        }
        #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
        {
            all |= Self::CLOSEST_HIT_KHR;
        }
        #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
        {
            all |= Self::MISS_KHR;
        }
        #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
        {
            all |= Self::INTERSECTION_KHR;
        }
        #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
        {
            all |= Self::CALLABLE_KHR;
        }
        #[cfg(feature = "VK_NV_mesh_shader")]
        {
            all |= Self::TASK_NV;
        }
        #[cfg(feature = "VK_NV_mesh_shader")]
        {
            all |= Self::MESH_NV;
        }
        #[cfg(feature = "VK_HUAWEI_subpass_shading")]
        {
            all |= Self::SUBPASS_SHADING_HUAWEI;
        }
        #[cfg(feature = "VK_NV_ray_tracing")]
        {
            all |= Self::RAYGEN_NV;
        }
        #[cfg(feature = "VK_NV_ray_tracing")]
        {
            all |= Self::ANY_HIT_NV;
        }
        #[cfg(feature = "VK_NV_ray_tracing")]
        {
            all |= Self::CLOSEST_HIT_NV;
        }
        #[cfg(feature = "VK_NV_ray_tracing")]
        {
            all |= Self::MISS_NV;
        }
        #[cfg(feature = "VK_NV_ray_tracing")]
        {
            all |= Self::INTERSECTION_NV;
        }
        #[cfg(feature = "VK_NV_ray_tracing")]
        {
            all |= Self::CALLABLE_NV;
        }
        all
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl const std::ops::BitOr for ShaderStageFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl const std::ops::BitOrAssign for ShaderStageFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl const std::ops::BitXor for ShaderStageFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl const std::ops::BitXorAssign for ShaderStageFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl const std::ops::BitAnd for ShaderStageFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl const std::ops::BitAndAssign for ShaderStageFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl const std::ops::Sub for ShaderStageFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl const std::ops::SubAssign for ShaderStageFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl const std::ops::Not for ShaderStageFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl Extend<ShaderStageFlags> for ShaderStageFlags {
    fn extend<T: IntoIterator<Item = ShaderStageFlags>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, i);
        }
    }
}
impl FromIterator<ShaderStageFlags> for ShaderStageFlags {
    fn from_iter<T: IntoIterator<Item = ShaderStageFlags>>(iterator: T) -> ShaderStageFlags {
        let mut out = Self::empty();
        <Self as Extend<ShaderStageFlags>>::extend(&mut out, iterator);
        out
    }
}
impl const Default for ShaderStageFlags {
    fn default() -> Self {
        Self::empty()
    }
}
impl const From<ShaderStageFlagBits> for ShaderStageFlags {
    fn from(bit: ShaderStageFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(bit.bits()) }
    }
}
impl Extend<ShaderStageFlagBits> for ShaderStageFlags {
    fn extend<T: IntoIterator<Item = ShaderStageFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, Self::from(i));
        }
    }
}
impl FromIterator<ShaderStageFlagBits> for ShaderStageFlags {
    fn from_iter<T: IntoIterator<Item = ShaderStageFlagBits>>(iterator: T) -> ShaderStageFlags {
        let mut out = Self::empty();
        <Self as Extend<ShaderStageFlagBits>>::extend(&mut out, iterator);
        out
    }
}
impl std::fmt::Debug for ShaderStageFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(ShaderStageFlags);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == ShaderStageFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(ShaderStageFlags::VERTEX) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(VERTEX))?;
                    }
                    if self.0.contains(ShaderStageFlags::TESSELLATION_CONTROL) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(TESSELLATION_CONTROL))?;
                    }
                    if self.0.contains(ShaderStageFlags::TESSELLATION_EVALUATION) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(TESSELLATION_EVALUATION))?;
                    }
                    if self.0.contains(ShaderStageFlags::GEOMETRY) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(GEOMETRY))?;
                    }
                    if self.0.contains(ShaderStageFlags::FRAGMENT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(FRAGMENT))?;
                    }
                    if self.0.contains(ShaderStageFlags::COMPUTE) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(COMPUTE))?;
                    }
                    if self.0.contains(ShaderStageFlags::ALL_GRAPHICS) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(ALL_GRAPHICS))?;
                    }
                    if self.0.contains(ShaderStageFlags::ALL) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(ALL))?;
                    }
                    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
                    if self.0.contains(ShaderStageFlags::RAYGEN_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(RAYGEN_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
                    if self.0.contains(ShaderStageFlags::ANY_HIT_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(ANY_HIT_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
                    if self.0.contains(ShaderStageFlags::CLOSEST_HIT_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(CLOSEST_HIT_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
                    if self.0.contains(ShaderStageFlags::MISS_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(MISS_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
                    if self.0.contains(ShaderStageFlags::INTERSECTION_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(INTERSECTION_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
                    if self.0.contains(ShaderStageFlags::CALLABLE_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(CALLABLE_KHR))?;
                    }
                    #[cfg(feature = "VK_NV_mesh_shader")]
                    if self.0.contains(ShaderStageFlags::TASK_NV) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(TASK_NV))?;
                    }
                    #[cfg(feature = "VK_NV_mesh_shader")]
                    if self.0.contains(ShaderStageFlags::MESH_NV) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(MESH_NV))?;
                    }
                    #[cfg(feature = "VK_HUAWEI_subpass_shading")]
                    if self.0.contains(ShaderStageFlags::SUBPASS_SHADING_HUAWEI) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(SUBPASS_SHADING_HUAWEI))?;
                    }
                    #[cfg(feature = "VK_NV_ray_tracing")]
                    if self.0.contains(ShaderStageFlags::RAYGEN_NV) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(RAYGEN_NV))?;
                    }
                    #[cfg(feature = "VK_NV_ray_tracing")]
                    if self.0.contains(ShaderStageFlags::ANY_HIT_NV) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(ANY_HIT_NV))?;
                    }
                    #[cfg(feature = "VK_NV_ray_tracing")]
                    if self.0.contains(ShaderStageFlags::CLOSEST_HIT_NV) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(CLOSEST_HIT_NV))?;
                    }
                    #[cfg(feature = "VK_NV_ray_tracing")]
                    if self.0.contains(ShaderStageFlags::MISS_NV) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(MISS_NV))?;
                    }
                    #[cfg(feature = "VK_NV_ray_tracing")]
                    if self.0.contains(ShaderStageFlags::INTERSECTION_NV) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(INTERSECTION_NV))?;
                    }
                    #[cfg(feature = "VK_NV_ray_tracing")]
                    if self.0.contains(ShaderStageFlags::CALLABLE_NV) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(CALLABLE_NV))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(ShaderStageFlags))
            .field(&Flags(*self))
            .finish()
    }
}
# [doc = include_str ! ("../../../doc/VkImageUsageFlagBits.md")]
#[doc(alias = "VkImageUsageFlags")]
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct ImageUsageFlags(u32);
impl ImageUsageFlags {
    #[doc(alias = "VK_IMAGE_USAGE_TRANSFER_SRC_BIT")]
    pub const TRANSFER_SRC: Self = Self(1);
    #[doc(alias = "VK_IMAGE_USAGE_TRANSFER_DST_BIT")]
    pub const TRANSFER_DST: Self = Self(2);
    #[doc(alias = "VK_IMAGE_USAGE_SAMPLED_BIT")]
    pub const SAMPLED: Self = Self(4);
    #[doc(alias = "VK_IMAGE_USAGE_STORAGE_BIT")]
    pub const STORAGE: Self = Self(8);
    #[doc(alias = "VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT")]
    pub const COLOR_ATTACHMENT: Self = Self(16);
    #[doc(alias = "VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT")]
    pub const DEPTH_STENCIL_ATTACHMENT: Self = Self(32);
    #[doc(alias = "VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT")]
    pub const TRANSIENT_ATTACHMENT: Self = Self(64);
    #[doc(alias = "VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT")]
    pub const INPUT_ATTACHMENT: Self = Self(128);
    #[doc(alias = "VK_IMAGE_USAGE_VIDEO_DECODE_DST_BIT_KHR")]
    #[cfg(feature = "VK_KHR_video_decode_queue")]
    pub const VIDEO_DECODE_DST_KHR: Self = Self(1024);
    #[doc(alias = "VK_IMAGE_USAGE_VIDEO_DECODE_SRC_BIT_KHR")]
    #[cfg(feature = "VK_KHR_video_decode_queue")]
    pub const VIDEO_DECODE_SRC_KHR: Self = Self(2048);
    #[doc(alias = "VK_IMAGE_USAGE_VIDEO_DECODE_DPB_BIT_KHR")]
    #[cfg(feature = "VK_KHR_video_decode_queue")]
    pub const VIDEO_DECODE_DPB_KHR: Self = Self(4096);
    #[doc(alias = "VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT")]
    #[cfg(feature = "VK_EXT_fragment_density_map")]
    pub const FRAGMENT_DENSITY_MAP_EXT: Self = Self(512);
    #[doc(alias = "VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR")]
    #[cfg(feature = "VK_KHR_fragment_shading_rate")]
    pub const FRAGMENT_SHADING_RATE_ATTACHMENT_KHR: Self = Self(256);
    #[doc(alias = "VK_IMAGE_USAGE_VIDEO_ENCODE_DST_BIT_KHR")]
    #[cfg(feature = "VK_KHR_video_encode_queue")]
    pub const VIDEO_ENCODE_DST_KHR: Self = Self(8192);
    #[doc(alias = "VK_IMAGE_USAGE_VIDEO_ENCODE_SRC_BIT_KHR")]
    #[cfg(feature = "VK_KHR_video_encode_queue")]
    pub const VIDEO_ENCODE_SRC_KHR: Self = Self(16384);
    #[doc(alias = "VK_IMAGE_USAGE_VIDEO_ENCODE_DPB_BIT_KHR")]
    #[cfg(feature = "VK_KHR_video_encode_queue")]
    pub const VIDEO_ENCODE_DPB_KHR: Self = Self(32768);
    #[doc(alias = "VK_IMAGE_USAGE_INVOCATION_MASK_BIT_HUAWEI")]
    #[cfg(feature = "VK_HUAWEI_invocation_mask")]
    pub const INVOCATION_MASK_HUAWEI: Self = Self(262144);
    #[doc(alias = "VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV")]
    #[cfg(feature = "VK_NV_shading_rate_image")]
    pub const SHADING_RATE_IMAGE_NV: Self = Self::FRAGMENT_SHADING_RATE_ATTACHMENT_KHR;
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    #[allow(unused_mut)]
    pub const fn all() -> Self {
        let mut all = Self::empty();
        {
            all |= Self::TRANSFER_SRC;
        }
        {
            all |= Self::TRANSFER_DST;
        }
        {
            all |= Self::SAMPLED;
        }
        {
            all |= Self::STORAGE;
        }
        {
            all |= Self::COLOR_ATTACHMENT;
        }
        {
            all |= Self::DEPTH_STENCIL_ATTACHMENT;
        }
        {
            all |= Self::TRANSIENT_ATTACHMENT;
        }
        {
            all |= Self::INPUT_ATTACHMENT;
        }
        #[cfg(feature = "VK_KHR_video_decode_queue")]
        {
            all |= Self::VIDEO_DECODE_DST_KHR;
        }
        #[cfg(feature = "VK_KHR_video_decode_queue")]
        {
            all |= Self::VIDEO_DECODE_SRC_KHR;
        }
        #[cfg(feature = "VK_KHR_video_decode_queue")]
        {
            all |= Self::VIDEO_DECODE_DPB_KHR;
        }
        #[cfg(feature = "VK_EXT_fragment_density_map")]
        {
            all |= Self::FRAGMENT_DENSITY_MAP_EXT;
        }
        #[cfg(feature = "VK_KHR_fragment_shading_rate")]
        {
            all |= Self::FRAGMENT_SHADING_RATE_ATTACHMENT_KHR;
        }
        #[cfg(feature = "VK_KHR_video_encode_queue")]
        {
            all |= Self::VIDEO_ENCODE_DST_KHR;
        }
        #[cfg(feature = "VK_KHR_video_encode_queue")]
        {
            all |= Self::VIDEO_ENCODE_SRC_KHR;
        }
        #[cfg(feature = "VK_KHR_video_encode_queue")]
        {
            all |= Self::VIDEO_ENCODE_DPB_KHR;
        }
        #[cfg(feature = "VK_HUAWEI_invocation_mask")]
        {
            all |= Self::INVOCATION_MASK_HUAWEI;
        }
        #[cfg(feature = "VK_NV_shading_rate_image")]
        {
            all |= Self::SHADING_RATE_IMAGE_NV;
        }
        all
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl const std::ops::BitOr for ImageUsageFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl const std::ops::BitOrAssign for ImageUsageFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl const std::ops::BitXor for ImageUsageFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl const std::ops::BitXorAssign for ImageUsageFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl const std::ops::BitAnd for ImageUsageFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl const std::ops::BitAndAssign for ImageUsageFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl const std::ops::Sub for ImageUsageFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl const std::ops::SubAssign for ImageUsageFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl const std::ops::Not for ImageUsageFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl Extend<ImageUsageFlags> for ImageUsageFlags {
    fn extend<T: IntoIterator<Item = ImageUsageFlags>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, i);
        }
    }
}
impl FromIterator<ImageUsageFlags> for ImageUsageFlags {
    fn from_iter<T: IntoIterator<Item = ImageUsageFlags>>(iterator: T) -> ImageUsageFlags {
        let mut out = Self::empty();
        <Self as Extend<ImageUsageFlags>>::extend(&mut out, iterator);
        out
    }
}
impl const Default for ImageUsageFlags {
    fn default() -> Self {
        Self::empty()
    }
}
impl const From<ImageUsageFlagBits> for ImageUsageFlags {
    fn from(bit: ImageUsageFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(bit.bits()) }
    }
}
impl Extend<ImageUsageFlagBits> for ImageUsageFlags {
    fn extend<T: IntoIterator<Item = ImageUsageFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, Self::from(i));
        }
    }
}
impl FromIterator<ImageUsageFlagBits> for ImageUsageFlags {
    fn from_iter<T: IntoIterator<Item = ImageUsageFlagBits>>(iterator: T) -> ImageUsageFlags {
        let mut out = Self::empty();
        <Self as Extend<ImageUsageFlagBits>>::extend(&mut out, iterator);
        out
    }
}
impl std::fmt::Debug for ImageUsageFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(ImageUsageFlags);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == ImageUsageFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(ImageUsageFlags::TRANSFER_SRC) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(TRANSFER_SRC))?;
                    }
                    if self.0.contains(ImageUsageFlags::TRANSFER_DST) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(TRANSFER_DST))?;
                    }
                    if self.0.contains(ImageUsageFlags::SAMPLED) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(SAMPLED))?;
                    }
                    if self.0.contains(ImageUsageFlags::STORAGE) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(STORAGE))?;
                    }
                    if self.0.contains(ImageUsageFlags::COLOR_ATTACHMENT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(COLOR_ATTACHMENT))?;
                    }
                    if self.0.contains(ImageUsageFlags::DEPTH_STENCIL_ATTACHMENT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(DEPTH_STENCIL_ATTACHMENT))?;
                    }
                    if self.0.contains(ImageUsageFlags::TRANSIENT_ATTACHMENT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(TRANSIENT_ATTACHMENT))?;
                    }
                    if self.0.contains(ImageUsageFlags::INPUT_ATTACHMENT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(INPUT_ATTACHMENT))?;
                    }
                    #[cfg(feature = "VK_KHR_video_decode_queue")]
                    if self.0.contains(ImageUsageFlags::VIDEO_DECODE_DST_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(VIDEO_DECODE_DST_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_video_decode_queue")]
                    if self.0.contains(ImageUsageFlags::VIDEO_DECODE_SRC_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(VIDEO_DECODE_SRC_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_video_decode_queue")]
                    if self.0.contains(ImageUsageFlags::VIDEO_DECODE_DPB_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(VIDEO_DECODE_DPB_KHR))?;
                    }
                    #[cfg(feature = "VK_EXT_fragment_density_map")]
                    if self.0.contains(ImageUsageFlags::FRAGMENT_DENSITY_MAP_EXT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(FRAGMENT_DENSITY_MAP_EXT))?;
                    }
                    #[cfg(feature = "VK_KHR_fragment_shading_rate")]
                    if self.0.contains(ImageUsageFlags::FRAGMENT_SHADING_RATE_ATTACHMENT_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(FRAGMENT_SHADING_RATE_ATTACHMENT_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_video_encode_queue")]
                    if self.0.contains(ImageUsageFlags::VIDEO_ENCODE_DST_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(VIDEO_ENCODE_DST_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_video_encode_queue")]
                    if self.0.contains(ImageUsageFlags::VIDEO_ENCODE_SRC_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(VIDEO_ENCODE_SRC_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_video_encode_queue")]
                    if self.0.contains(ImageUsageFlags::VIDEO_ENCODE_DPB_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(VIDEO_ENCODE_DPB_KHR))?;
                    }
                    #[cfg(feature = "VK_HUAWEI_invocation_mask")]
                    if self.0.contains(ImageUsageFlags::INVOCATION_MASK_HUAWEI) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(INVOCATION_MASK_HUAWEI))?;
                    }
                    #[cfg(feature = "VK_NV_shading_rate_image")]
                    if self.0.contains(ImageUsageFlags::SHADING_RATE_IMAGE_NV) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(SHADING_RATE_IMAGE_NV))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(ImageUsageFlags)).field(&Flags(*self)).finish()
    }
}
# [doc = include_str ! ("../../../doc/VkImageCreateFlagBits.md")]
#[doc(alias = "VkImageCreateFlags")]
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct ImageCreateFlags(u32);
impl ImageCreateFlags {
    #[doc(alias = "VK_IMAGE_CREATE_SPARSE_BINDING_BIT")]
    pub const SPARSE_BINDING: Self = Self(1);
    #[doc(alias = "VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT")]
    pub const SPARSE_RESIDENCY: Self = Self(2);
    #[doc(alias = "VK_IMAGE_CREATE_SPARSE_ALIASED_BIT")]
    pub const SPARSE_ALIASED: Self = Self(4);
    #[doc(alias = "VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT")]
    pub const MUTABLE_FORMAT: Self = Self(8);
    #[doc(alias = "VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT")]
    pub const CUBE_COMPATIBLE: Self = Self(16);
    #[doc(alias = "VK_IMAGE_CREATE_ALIAS_BIT")]
    pub const ALIAS: Self = Self(1024);
    #[doc(alias = "VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT")]
    pub const SPLIT_INSTANCE_BIND_REGIONS: Self = Self(64);
    #[doc(alias = "VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT")]
    pub const N2D_ARRAY_COMPATIBLE: Self = Self(32);
    #[doc(alias = "VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT")]
    pub const BLOCK_TEXEL_VIEW_COMPATIBLE: Self = Self(128);
    #[doc(alias = "VK_IMAGE_CREATE_EXTENDED_USAGE_BIT")]
    pub const EXTENDED_USAGE: Self = Self(256);
    #[doc(alias = "VK_IMAGE_CREATE_PROTECTED_BIT")]
    pub const PROTECTED: Self = Self(2048);
    #[doc(alias = "VK_IMAGE_CREATE_DISJOINT_BIT")]
    pub const DISJOINT: Self = Self(512);
    #[doc(alias = "VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV")]
    #[cfg(feature = "VK_NV_corner_sampled_image")]
    pub const CORNER_SAMPLED_NV: Self = Self(8192);
    #[doc(alias = "VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT")]
    #[cfg(feature = "VK_EXT_sample_locations")]
    pub const SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_EXT: Self = Self(4096);
    #[doc(alias = "VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT")]
    #[cfg(feature = "VK_EXT_fragment_density_map")]
    pub const SUBSAMPLED_EXT: Self = Self(16384);
    #[doc(alias = "VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR")]
    #[cfg(feature = "VK_KHR_device_group")]
    pub const SPLIT_INSTANCE_BIND_REGIONS_KHR: Self = Self::SPLIT_INSTANCE_BIND_REGIONS;
    #[doc(alias = "VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT_KHR")]
    #[cfg(feature = "VK_KHR_maintenance1")]
    pub const N2D_ARRAY_COMPATIBLE_KHR: Self = Self::N2D_ARRAY_COMPATIBLE;
    #[doc(alias = "VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT_KHR")]
    #[cfg(feature = "VK_KHR_maintenance2")]
    pub const BLOCK_TEXEL_VIEW_COMPATIBLE_KHR: Self = Self::BLOCK_TEXEL_VIEW_COMPATIBLE;
    #[doc(alias = "VK_IMAGE_CREATE_EXTENDED_USAGE_BIT_KHR")]
    #[cfg(feature = "VK_KHR_maintenance2")]
    pub const EXTENDED_USAGE_KHR: Self = Self::EXTENDED_USAGE;
    #[doc(alias = "VK_IMAGE_CREATE_DISJOINT_BIT_KHR")]
    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
    pub const DISJOINT_KHR: Self = Self::DISJOINT;
    #[doc(alias = "VK_IMAGE_CREATE_ALIAS_BIT_KHR")]
    #[cfg(feature = "VK_KHR_bind_memory2")]
    pub const ALIAS_KHR: Self = Self::ALIAS;
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    #[allow(unused_mut)]
    pub const fn all() -> Self {
        let mut all = Self::empty();
        {
            all |= Self::SPARSE_BINDING;
        }
        {
            all |= Self::SPARSE_RESIDENCY;
        }
        {
            all |= Self::SPARSE_ALIASED;
        }
        {
            all |= Self::MUTABLE_FORMAT;
        }
        {
            all |= Self::CUBE_COMPATIBLE;
        }
        {
            all |= Self::ALIAS;
        }
        {
            all |= Self::SPLIT_INSTANCE_BIND_REGIONS;
        }
        {
            all |= Self::N2D_ARRAY_COMPATIBLE;
        }
        {
            all |= Self::BLOCK_TEXEL_VIEW_COMPATIBLE;
        }
        {
            all |= Self::EXTENDED_USAGE;
        }
        {
            all |= Self::PROTECTED;
        }
        {
            all |= Self::DISJOINT;
        }
        #[cfg(feature = "VK_NV_corner_sampled_image")]
        {
            all |= Self::CORNER_SAMPLED_NV;
        }
        #[cfg(feature = "VK_EXT_sample_locations")]
        {
            all |= Self::SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_EXT;
        }
        #[cfg(feature = "VK_EXT_fragment_density_map")]
        {
            all |= Self::SUBSAMPLED_EXT;
        }
        #[cfg(feature = "VK_KHR_device_group")]
        {
            all |= Self::SPLIT_INSTANCE_BIND_REGIONS_KHR;
        }
        #[cfg(feature = "VK_KHR_maintenance1")]
        {
            all |= Self::N2D_ARRAY_COMPATIBLE_KHR;
        }
        #[cfg(feature = "VK_KHR_maintenance2")]
        {
            all |= Self::BLOCK_TEXEL_VIEW_COMPATIBLE_KHR;
        }
        #[cfg(feature = "VK_KHR_maintenance2")]
        {
            all |= Self::EXTENDED_USAGE_KHR;
        }
        #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
        {
            all |= Self::DISJOINT_KHR;
        }
        #[cfg(feature = "VK_KHR_bind_memory2")]
        {
            all |= Self::ALIAS_KHR;
        }
        all
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl const std::ops::BitOr for ImageCreateFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl const std::ops::BitOrAssign for ImageCreateFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl const std::ops::BitXor for ImageCreateFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl const std::ops::BitXorAssign for ImageCreateFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl const std::ops::BitAnd for ImageCreateFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl const std::ops::BitAndAssign for ImageCreateFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl const std::ops::Sub for ImageCreateFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl const std::ops::SubAssign for ImageCreateFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl const std::ops::Not for ImageCreateFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl Extend<ImageCreateFlags> for ImageCreateFlags {
    fn extend<T: IntoIterator<Item = ImageCreateFlags>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, i);
        }
    }
}
impl FromIterator<ImageCreateFlags> for ImageCreateFlags {
    fn from_iter<T: IntoIterator<Item = ImageCreateFlags>>(iterator: T) -> ImageCreateFlags {
        let mut out = Self::empty();
        <Self as Extend<ImageCreateFlags>>::extend(&mut out, iterator);
        out
    }
}
impl const Default for ImageCreateFlags {
    fn default() -> Self {
        Self::empty()
    }
}
impl const From<ImageCreateFlagBits> for ImageCreateFlags {
    fn from(bit: ImageCreateFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(bit.bits()) }
    }
}
impl Extend<ImageCreateFlagBits> for ImageCreateFlags {
    fn extend<T: IntoIterator<Item = ImageCreateFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, Self::from(i));
        }
    }
}
impl FromIterator<ImageCreateFlagBits> for ImageCreateFlags {
    fn from_iter<T: IntoIterator<Item = ImageCreateFlagBits>>(iterator: T) -> ImageCreateFlags {
        let mut out = Self::empty();
        <Self as Extend<ImageCreateFlagBits>>::extend(&mut out, iterator);
        out
    }
}
impl std::fmt::Debug for ImageCreateFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(ImageCreateFlags);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == ImageCreateFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(ImageCreateFlags::SPARSE_BINDING) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(SPARSE_BINDING))?;
                    }
                    if self.0.contains(ImageCreateFlags::SPARSE_RESIDENCY) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(SPARSE_RESIDENCY))?;
                    }
                    if self.0.contains(ImageCreateFlags::SPARSE_ALIASED) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(SPARSE_ALIASED))?;
                    }
                    if self.0.contains(ImageCreateFlags::MUTABLE_FORMAT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(MUTABLE_FORMAT))?;
                    }
                    if self.0.contains(ImageCreateFlags::CUBE_COMPATIBLE) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(CUBE_COMPATIBLE))?;
                    }
                    if self.0.contains(ImageCreateFlags::ALIAS) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(ALIAS))?;
                    }
                    if self.0.contains(ImageCreateFlags::SPLIT_INSTANCE_BIND_REGIONS) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(SPLIT_INSTANCE_BIND_REGIONS))?;
                    }
                    if self.0.contains(ImageCreateFlags::N2D_ARRAY_COMPATIBLE) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(N2D_ARRAY_COMPATIBLE))?;
                    }
                    if self.0.contains(ImageCreateFlags::BLOCK_TEXEL_VIEW_COMPATIBLE) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(BLOCK_TEXEL_VIEW_COMPATIBLE))?;
                    }
                    if self.0.contains(ImageCreateFlags::EXTENDED_USAGE) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(EXTENDED_USAGE))?;
                    }
                    if self.0.contains(ImageCreateFlags::PROTECTED) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(PROTECTED))?;
                    }
                    if self.0.contains(ImageCreateFlags::DISJOINT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(DISJOINT))?;
                    }
                    #[cfg(feature = "VK_NV_corner_sampled_image")]
                    if self.0.contains(ImageCreateFlags::CORNER_SAMPLED_NV) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(CORNER_SAMPLED_NV))?;
                    }
                    #[cfg(feature = "VK_EXT_sample_locations")]
                    if self.0.contains(ImageCreateFlags::SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_EXT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_EXT))?;
                    }
                    #[cfg(feature = "VK_EXT_fragment_density_map")]
                    if self.0.contains(ImageCreateFlags::SUBSAMPLED_EXT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(SUBSAMPLED_EXT))?;
                    }
                    #[cfg(feature = "VK_KHR_device_group")]
                    if self.0.contains(ImageCreateFlags::SPLIT_INSTANCE_BIND_REGIONS_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(SPLIT_INSTANCE_BIND_REGIONS_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_maintenance1")]
                    if self.0.contains(ImageCreateFlags::N2D_ARRAY_COMPATIBLE_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(N2D_ARRAY_COMPATIBLE_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_maintenance2")]
                    if self.0.contains(ImageCreateFlags::BLOCK_TEXEL_VIEW_COMPATIBLE_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(BLOCK_TEXEL_VIEW_COMPATIBLE_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_maintenance2")]
                    if self.0.contains(ImageCreateFlags::EXTENDED_USAGE_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(EXTENDED_USAGE_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
                    if self.0.contains(ImageCreateFlags::DISJOINT_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(DISJOINT_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_bind_memory2")]
                    if self.0.contains(ImageCreateFlags::ALIAS_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(ALIAS_KHR))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(ImageCreateFlags))
            .field(&Flags(*self))
            .finish()
    }
}
# [doc = include_str ! ("../../../doc/VkImageViewCreateFlagBits.md")]
#[doc(alias = "VkImageViewCreateFlags")]
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct ImageViewCreateFlags(u32);
impl ImageViewCreateFlags {
    #[doc(alias = "VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT")]
    #[cfg(feature = "VK_EXT_fragment_density_map")]
    pub const FRAGMENT_DENSITY_MAP_DYNAMIC_EXT: Self = Self(1);
    #[doc(alias = "VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DEFERRED_BIT_EXT")]
    #[cfg(feature = "VK_EXT_fragment_density_map2")]
    pub const FRAGMENT_DENSITY_MAP_DEFERRED_EXT: Self = Self(2);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    #[allow(unused_mut)]
    pub const fn all() -> Self {
        let mut all = Self::empty();
        #[cfg(feature = "VK_EXT_fragment_density_map")]
        {
            all |= Self::FRAGMENT_DENSITY_MAP_DYNAMIC_EXT;
        }
        #[cfg(feature = "VK_EXT_fragment_density_map2")]
        {
            all |= Self::FRAGMENT_DENSITY_MAP_DEFERRED_EXT;
        }
        all
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl const std::ops::BitOr for ImageViewCreateFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl const std::ops::BitOrAssign for ImageViewCreateFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl const std::ops::BitXor for ImageViewCreateFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl const std::ops::BitXorAssign for ImageViewCreateFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl const std::ops::BitAnd for ImageViewCreateFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl const std::ops::BitAndAssign for ImageViewCreateFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl const std::ops::Sub for ImageViewCreateFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl const std::ops::SubAssign for ImageViewCreateFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl const std::ops::Not for ImageViewCreateFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl Extend<ImageViewCreateFlags> for ImageViewCreateFlags {
    fn extend<T: IntoIterator<Item = ImageViewCreateFlags>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, i);
        }
    }
}
impl FromIterator<ImageViewCreateFlags> for ImageViewCreateFlags {
    fn from_iter<T: IntoIterator<Item = ImageViewCreateFlags>>(iterator: T) -> ImageViewCreateFlags {
        let mut out = Self::empty();
        <Self as Extend<ImageViewCreateFlags>>::extend(&mut out, iterator);
        out
    }
}
impl const Default for ImageViewCreateFlags {
    fn default() -> Self {
        Self::empty()
    }
}
impl const From<ImageViewCreateFlagBits> for ImageViewCreateFlags {
    fn from(bit: ImageViewCreateFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(bit.bits()) }
    }
}
impl Extend<ImageViewCreateFlagBits> for ImageViewCreateFlags {
    fn extend<T: IntoIterator<Item = ImageViewCreateFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, Self::from(i));
        }
    }
}
impl FromIterator<ImageViewCreateFlagBits> for ImageViewCreateFlags {
    fn from_iter<T: IntoIterator<Item = ImageViewCreateFlagBits>>(iterator: T) -> ImageViewCreateFlags {
        let mut out = Self::empty();
        <Self as Extend<ImageViewCreateFlagBits>>::extend(&mut out, iterator);
        out
    }
}
impl std::fmt::Debug for ImageViewCreateFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(ImageViewCreateFlags);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == ImageViewCreateFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    #[cfg(feature = "VK_EXT_fragment_density_map")]
                    if self.0.contains(ImageViewCreateFlags::FRAGMENT_DENSITY_MAP_DYNAMIC_EXT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(FRAGMENT_DENSITY_MAP_DYNAMIC_EXT))?;
                    }
                    #[cfg(feature = "VK_EXT_fragment_density_map2")]
                    if self.0.contains(ImageViewCreateFlags::FRAGMENT_DENSITY_MAP_DEFERRED_EXT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(FRAGMENT_DENSITY_MAP_DEFERRED_EXT))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(ImageViewCreateFlags))
            .field(&Flags(*self))
            .finish()
    }
}
# [doc = include_str ! ("../../../doc/VkPipelineCreateFlagBits.md")]
#[doc(alias = "VkPipelineCreateFlags")]
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct PipelineCreateFlags(u32);
impl PipelineCreateFlags {
    #[doc(alias = "VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT")]
    pub const DISABLE_OPTIMIZATION: Self = Self(1);
    #[doc(alias = "VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT")]
    pub const ALLOW_DERIVATIVES: Self = Self(2);
    #[doc(alias = "VK_PIPELINE_CREATE_DERIVATIVE_BIT")]
    pub const DERIVATIVE: Self = Self(4);
    #[doc(alias = "VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT")]
    pub const VIEW_INDEX_FROM_DEVICE_INDEX: Self = Self(8);
    #[doc(alias = "VK_PIPELINE_CREATE_DISPATCH_BASE_BIT")]
    pub const DISPATCH_BASE: Self = Self(16);
    #[doc(alias = "VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const FAIL_ON_PIPELINE_COMPILE_REQUIRED: Self = Self(256);
    #[doc(alias = "VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const EARLY_RETURN_ON_FAILURE: Self = Self(512);
    #[doc(alias = "VK_PIPELINE_CREATE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR")]
    #[cfg(feature = "VK_KHR_dynamic_rendering")]
    pub const RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_KHR: Self = Self(2097152);
    #[doc(alias = "VK_PIPELINE_CREATE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT")]
    #[cfg(feature = "VK_KHR_dynamic_rendering")]
    pub const RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_EXT: Self = Self(4194304);
    #[doc(alias = "VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR")]
    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
    pub const RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_KHR: Self = Self(16384);
    #[doc(alias = "VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR")]
    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
    pub const RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_KHR: Self = Self(32768);
    #[doc(alias = "VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR")]
    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
    pub const RAY_TRACING_NO_NULL_MISS_SHADERS_KHR: Self = Self(65536);
    #[doc(alias = "VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR")]
    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
    pub const RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_KHR: Self = Self(131072);
    #[doc(alias = "VK_PIPELINE_CREATE_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR")]
    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
    pub const RAY_TRACING_SKIP_TRIANGLES_KHR: Self = Self(4096);
    #[doc(alias = "VK_PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR")]
    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
    pub const RAY_TRACING_SKIP_AABBS_KHR: Self = Self(8192);
    #[doc(alias = "VK_PIPELINE_CREATE_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR")]
    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
    pub const RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_KHR: Self = Self(524288);
    #[doc(alias = "VK_PIPELINE_CREATE_DEFER_COMPILE_BIT_NV")]
    #[cfg(feature = "VK_NV_ray_tracing")]
    pub const DEFER_COMPILE_NV: Self = Self(32);
    #[doc(alias = "VK_PIPELINE_CREATE_CAPTURE_STATISTICS_BIT_KHR")]
    #[cfg(feature = "VK_KHR_pipeline_executable_properties")]
    pub const CAPTURE_STATISTICS_KHR: Self = Self(64);
    #[doc(alias = "VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR")]
    #[cfg(feature = "VK_KHR_pipeline_executable_properties")]
    pub const CAPTURE_INTERNAL_REPRESENTATIONS_KHR: Self = Self(128);
    #[doc(alias = "VK_PIPELINE_CREATE_INDIRECT_BINDABLE_BIT_NV")]
    #[cfg(feature = "VK_NV_device_generated_commands")]
    pub const INDIRECT_BINDABLE_NV: Self = Self(262144);
    #[doc(alias = "VK_PIPELINE_CREATE_LIBRARY_BIT_KHR")]
    #[cfg(feature = "VK_KHR_pipeline_library")]
    pub const LIBRARY_KHR: Self = Self(2048);
    #[doc(alias = "VK_PIPELINE_CREATE_RAY_TRACING_ALLOW_MOTION_BIT_NV")]
    #[cfg(feature = "VK_NV_ray_tracing_motion_blur")]
    pub const RAY_TRACING_ALLOW_MOTION_NV: Self = Self(1048576);
    #[doc(alias = "VK_PIPELINE_CREATE_DISPATCH_BASE")]
    pub const DISPATCH_BASE_DUP: Self = Self::DISPATCH_BASE;
    #[doc(alias = "VK_PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR")]
    #[cfg(feature = "VK_KHR_dynamic_rendering")]
    pub const PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_SHADING_RATE_ATTACHMENT_KHR: Self =
        Self::RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_KHR;
    #[doc(alias = "VK_PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT")]
    #[cfg(feature = "VK_KHR_dynamic_rendering")]
    pub const PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_DENSITY_MAP_ATTACHMENT_EXT: Self =
        Self::RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_EXT;
    #[doc(alias = "VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR")]
    #[cfg(feature = "VK_KHR_device_group")]
    pub const VIEW_INDEX_FROM_DEVICE_INDEX_KHR: Self = Self::VIEW_INDEX_FROM_DEVICE_INDEX;
    #[doc(alias = "VK_PIPELINE_CREATE_DISPATCH_BASE_KHR")]
    #[cfg(feature = "VK_KHR_device_group")]
    pub const DISPATCH_BASE_KHR: Self = Self::DISPATCH_BASE_DUP;
    #[doc(alias = "VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT_EXT")]
    #[cfg(feature = "VK_EXT_pipeline_creation_cache_control")]
    pub const FAIL_ON_PIPELINE_COMPILE_REQUIRED_EXT: Self = Self::FAIL_ON_PIPELINE_COMPILE_REQUIRED;
    #[doc(alias = "VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT_EXT")]
    #[cfg(feature = "VK_EXT_pipeline_creation_cache_control")]
    pub const EARLY_RETURN_ON_FAILURE_EXT: Self = Self::EARLY_RETURN_ON_FAILURE;
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    #[allow(unused_mut)]
    pub const fn all() -> Self {
        let mut all = Self::empty();
        {
            all |= Self::DISABLE_OPTIMIZATION;
        }
        {
            all |= Self::ALLOW_DERIVATIVES;
        }
        {
            all |= Self::DERIVATIVE;
        }
        {
            all |= Self::VIEW_INDEX_FROM_DEVICE_INDEX;
        }
        {
            all |= Self::DISPATCH_BASE;
        }
        #[cfg(feature = "VULKAN_1_3")]
        {
            all |= Self::FAIL_ON_PIPELINE_COMPILE_REQUIRED;
        }
        #[cfg(feature = "VULKAN_1_3")]
        {
            all |= Self::EARLY_RETURN_ON_FAILURE;
        }
        #[cfg(feature = "VK_KHR_dynamic_rendering")]
        {
            all |= Self::RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_KHR;
        }
        #[cfg(feature = "VK_KHR_dynamic_rendering")]
        {
            all |= Self::RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_EXT;
        }
        #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
        {
            all |= Self::RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_KHR;
        }
        #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
        {
            all |= Self::RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_KHR;
        }
        #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
        {
            all |= Self::RAY_TRACING_NO_NULL_MISS_SHADERS_KHR;
        }
        #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
        {
            all |= Self::RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_KHR;
        }
        #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
        {
            all |= Self::RAY_TRACING_SKIP_TRIANGLES_KHR;
        }
        #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
        {
            all |= Self::RAY_TRACING_SKIP_AABBS_KHR;
        }
        #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
        {
            all |= Self::RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_KHR;
        }
        #[cfg(feature = "VK_NV_ray_tracing")]
        {
            all |= Self::DEFER_COMPILE_NV;
        }
        #[cfg(feature = "VK_KHR_pipeline_executable_properties")]
        {
            all |= Self::CAPTURE_STATISTICS_KHR;
        }
        #[cfg(feature = "VK_KHR_pipeline_executable_properties")]
        {
            all |= Self::CAPTURE_INTERNAL_REPRESENTATIONS_KHR;
        }
        #[cfg(feature = "VK_NV_device_generated_commands")]
        {
            all |= Self::INDIRECT_BINDABLE_NV;
        }
        #[cfg(feature = "VK_KHR_pipeline_library")]
        {
            all |= Self::LIBRARY_KHR;
        }
        #[cfg(feature = "VK_NV_ray_tracing_motion_blur")]
        {
            all |= Self::RAY_TRACING_ALLOW_MOTION_NV;
        }
        {
            all |= Self::DISPATCH_BASE_DUP;
        }
        #[cfg(feature = "VK_KHR_dynamic_rendering")]
        {
            all |= Self::PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_SHADING_RATE_ATTACHMENT_KHR;
        }
        #[cfg(feature = "VK_KHR_dynamic_rendering")]
        {
            all |= Self::PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_DENSITY_MAP_ATTACHMENT_EXT;
        }
        #[cfg(feature = "VK_KHR_device_group")]
        {
            all |= Self::VIEW_INDEX_FROM_DEVICE_INDEX_KHR;
        }
        #[cfg(feature = "VK_KHR_device_group")]
        {
            all |= Self::DISPATCH_BASE_KHR;
        }
        #[cfg(feature = "VK_EXT_pipeline_creation_cache_control")]
        {
            all |= Self::FAIL_ON_PIPELINE_COMPILE_REQUIRED_EXT;
        }
        #[cfg(feature = "VK_EXT_pipeline_creation_cache_control")]
        {
            all |= Self::EARLY_RETURN_ON_FAILURE_EXT;
        }
        all
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl const std::ops::BitOr for PipelineCreateFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl const std::ops::BitOrAssign for PipelineCreateFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl const std::ops::BitXor for PipelineCreateFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl const std::ops::BitXorAssign for PipelineCreateFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl const std::ops::BitAnd for PipelineCreateFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl const std::ops::BitAndAssign for PipelineCreateFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl const std::ops::Sub for PipelineCreateFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl const std::ops::SubAssign for PipelineCreateFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl const std::ops::Not for PipelineCreateFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl Extend<PipelineCreateFlags> for PipelineCreateFlags {
    fn extend<T: IntoIterator<Item = PipelineCreateFlags>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, i);
        }
    }
}
impl FromIterator<PipelineCreateFlags> for PipelineCreateFlags {
    fn from_iter<T: IntoIterator<Item = PipelineCreateFlags>>(iterator: T) -> PipelineCreateFlags {
        let mut out = Self::empty();
        <Self as Extend<PipelineCreateFlags>>::extend(&mut out, iterator);
        out
    }
}
impl const Default for PipelineCreateFlags {
    fn default() -> Self {
        Self::empty()
    }
}
impl const From<PipelineCreateFlagBits> for PipelineCreateFlags {
    fn from(bit: PipelineCreateFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(bit.bits()) }
    }
}
impl Extend<PipelineCreateFlagBits> for PipelineCreateFlags {
    fn extend<T: IntoIterator<Item = PipelineCreateFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, Self::from(i));
        }
    }
}
impl FromIterator<PipelineCreateFlagBits> for PipelineCreateFlags {
    fn from_iter<T: IntoIterator<Item = PipelineCreateFlagBits>>(iterator: T) -> PipelineCreateFlags {
        let mut out = Self::empty();
        <Self as Extend<PipelineCreateFlagBits>>::extend(&mut out, iterator);
        out
    }
}
impl std::fmt::Debug for PipelineCreateFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(PipelineCreateFlags);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == PipelineCreateFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(PipelineCreateFlags::DISABLE_OPTIMIZATION) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(DISABLE_OPTIMIZATION))?;
                    }
                    if self.0.contains(PipelineCreateFlags::ALLOW_DERIVATIVES) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(ALLOW_DERIVATIVES))?;
                    }
                    if self.0.contains(PipelineCreateFlags::DERIVATIVE) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(DERIVATIVE))?;
                    }
                    if self.0.contains(PipelineCreateFlags::VIEW_INDEX_FROM_DEVICE_INDEX) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(VIEW_INDEX_FROM_DEVICE_INDEX))?;
                    }
                    if self.0.contains(PipelineCreateFlags::DISPATCH_BASE) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(DISPATCH_BASE))?;
                    }
                    #[cfg(feature = "VULKAN_1_3")]
                    if self.0.contains(PipelineCreateFlags::FAIL_ON_PIPELINE_COMPILE_REQUIRED) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(FAIL_ON_PIPELINE_COMPILE_REQUIRED))?;
                    }
                    #[cfg(feature = "VULKAN_1_3")]
                    if self.0.contains(PipelineCreateFlags::EARLY_RETURN_ON_FAILURE) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(EARLY_RETURN_ON_FAILURE))?;
                    }
                    #[cfg(feature = "VK_KHR_dynamic_rendering")]
                    if self
                        .0
                        .contains(PipelineCreateFlags::RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_KHR)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_dynamic_rendering")]
                    if self
                        .0
                        .contains(PipelineCreateFlags::RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_EXT)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_EXT))?;
                    }
                    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
                    if self
                        .0
                        .contains(PipelineCreateFlags::RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_KHR)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
                    if self
                        .0
                        .contains(PipelineCreateFlags::RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_KHR)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
                    if self
                        .0
                        .contains(PipelineCreateFlags::RAY_TRACING_NO_NULL_MISS_SHADERS_KHR)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(RAY_TRACING_NO_NULL_MISS_SHADERS_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
                    if self
                        .0
                        .contains(PipelineCreateFlags::RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_KHR)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
                    if self.0.contains(PipelineCreateFlags::RAY_TRACING_SKIP_TRIANGLES_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(RAY_TRACING_SKIP_TRIANGLES_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
                    if self.0.contains(PipelineCreateFlags::RAY_TRACING_SKIP_AABBS_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(RAY_TRACING_SKIP_AABBS_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
                    if self
                        .0
                        .contains(PipelineCreateFlags::RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_KHR)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_KHR))?;
                    }
                    #[cfg(feature = "VK_NV_ray_tracing")]
                    if self.0.contains(PipelineCreateFlags::DEFER_COMPILE_NV) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(DEFER_COMPILE_NV))?;
                    }
                    #[cfg(feature = "VK_KHR_pipeline_executable_properties")]
                    if self.0.contains(PipelineCreateFlags::CAPTURE_STATISTICS_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(CAPTURE_STATISTICS_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_pipeline_executable_properties")]
                    if self
                        .0
                        .contains(PipelineCreateFlags::CAPTURE_INTERNAL_REPRESENTATIONS_KHR)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(CAPTURE_INTERNAL_REPRESENTATIONS_KHR))?;
                    }
                    #[cfg(feature = "VK_NV_device_generated_commands")]
                    if self.0.contains(PipelineCreateFlags::INDIRECT_BINDABLE_NV) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(INDIRECT_BINDABLE_NV))?;
                    }
                    #[cfg(feature = "VK_KHR_pipeline_library")]
                    if self.0.contains(PipelineCreateFlags::LIBRARY_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(LIBRARY_KHR))?;
                    }
                    #[cfg(feature = "VK_NV_ray_tracing_motion_blur")]
                    if self.0.contains(PipelineCreateFlags::RAY_TRACING_ALLOW_MOTION_NV) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(RAY_TRACING_ALLOW_MOTION_NV))?;
                    }
                    if self.0.contains(PipelineCreateFlags::DISPATCH_BASE_DUP) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(DISPATCH_BASE_DUP))?;
                    }
                    #[cfg(feature = "VK_KHR_dynamic_rendering")]
                    if self.0.contains(
                        PipelineCreateFlags::PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_SHADING_RATE_ATTACHMENT_KHR,
                    ) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(
                            PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_SHADING_RATE_ATTACHMENT_KHR
                        ))?;
                    }
                    #[cfg(feature = "VK_KHR_dynamic_rendering")]
                    if self.0.contains(
                        PipelineCreateFlags::PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_DENSITY_MAP_ATTACHMENT_EXT,
                    ) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(
                            PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_DENSITY_MAP_ATTACHMENT_EXT
                        ))?;
                    }
                    #[cfg(feature = "VK_KHR_device_group")]
                    if self.0.contains(PipelineCreateFlags::VIEW_INDEX_FROM_DEVICE_INDEX_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(VIEW_INDEX_FROM_DEVICE_INDEX_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_device_group")]
                    if self.0.contains(PipelineCreateFlags::DISPATCH_BASE_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(DISPATCH_BASE_KHR))?;
                    }
                    #[cfg(feature = "VK_EXT_pipeline_creation_cache_control")]
                    if self
                        .0
                        .contains(PipelineCreateFlags::FAIL_ON_PIPELINE_COMPILE_REQUIRED_EXT)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(FAIL_ON_PIPELINE_COMPILE_REQUIRED_EXT))?;
                    }
                    #[cfg(feature = "VK_EXT_pipeline_creation_cache_control")]
                    if self.0.contains(PipelineCreateFlags::EARLY_RETURN_ON_FAILURE_EXT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(EARLY_RETURN_ON_FAILURE_EXT))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(PipelineCreateFlags))
            .field(&Flags(*self))
            .finish()
    }
}
# [doc = include_str ! ("../../../doc/VkColorComponentFlagBits.md")]
#[doc(alias = "VkColorComponentFlags")]
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct ColorComponentFlags(u32);
impl ColorComponentFlags {
    #[doc(alias = "VK_COLOR_COMPONENT_R_BIT")]
    pub const R: Self = Self(1);
    #[doc(alias = "VK_COLOR_COMPONENT_G_BIT")]
    pub const G: Self = Self(2);
    #[doc(alias = "VK_COLOR_COMPONENT_B_BIT")]
    pub const B: Self = Self(4);
    #[doc(alias = "VK_COLOR_COMPONENT_A_BIT")]
    pub const A: Self = Self(8);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    #[allow(unused_mut)]
    pub const fn all() -> Self {
        let mut all = Self::empty();
        {
            all |= Self::R;
        }
        {
            all |= Self::G;
        }
        {
            all |= Self::B;
        }
        {
            all |= Self::A;
        }
        all
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl const std::ops::BitOr for ColorComponentFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl const std::ops::BitOrAssign for ColorComponentFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl const std::ops::BitXor for ColorComponentFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl const std::ops::BitXorAssign for ColorComponentFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl const std::ops::BitAnd for ColorComponentFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl const std::ops::BitAndAssign for ColorComponentFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl const std::ops::Sub for ColorComponentFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl const std::ops::SubAssign for ColorComponentFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl const std::ops::Not for ColorComponentFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl Extend<ColorComponentFlags> for ColorComponentFlags {
    fn extend<T: IntoIterator<Item = ColorComponentFlags>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, i);
        }
    }
}
impl FromIterator<ColorComponentFlags> for ColorComponentFlags {
    fn from_iter<T: IntoIterator<Item = ColorComponentFlags>>(iterator: T) -> ColorComponentFlags {
        let mut out = Self::empty();
        <Self as Extend<ColorComponentFlags>>::extend(&mut out, iterator);
        out
    }
}
impl const Default for ColorComponentFlags {
    fn default() -> Self {
        Self::empty()
    }
}
impl const From<ColorComponentFlagBits> for ColorComponentFlags {
    fn from(bit: ColorComponentFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(bit.bits()) }
    }
}
impl Extend<ColorComponentFlagBits> for ColorComponentFlags {
    fn extend<T: IntoIterator<Item = ColorComponentFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, Self::from(i));
        }
    }
}
impl FromIterator<ColorComponentFlagBits> for ColorComponentFlags {
    fn from_iter<T: IntoIterator<Item = ColorComponentFlagBits>>(iterator: T) -> ColorComponentFlags {
        let mut out = Self::empty();
        <Self as Extend<ColorComponentFlagBits>>::extend(&mut out, iterator);
        out
    }
}
impl std::fmt::Debug for ColorComponentFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(ColorComponentFlags);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == ColorComponentFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(ColorComponentFlags::R) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(R))?;
                    }
                    if self.0.contains(ColorComponentFlags::G) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(G))?;
                    }
                    if self.0.contains(ColorComponentFlags::B) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(B))?;
                    }
                    if self.0.contains(ColorComponentFlags::A) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(A))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(ColorComponentFlags))
            .field(&Flags(*self))
            .finish()
    }
}
# [doc = include_str ! ("../../../doc/VkFenceCreateFlagBits.md")]
#[doc(alias = "VkFenceCreateFlags")]
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct FenceCreateFlags(u32);
impl FenceCreateFlags {
    #[doc(alias = "VK_FENCE_CREATE_SIGNALED_BIT")]
    pub const SIGNALED: Self = Self(1);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    #[allow(unused_mut)]
    pub const fn all() -> Self {
        let mut all = Self::empty();
        {
            all |= Self::SIGNALED;
        }
        all
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl const std::ops::BitOr for FenceCreateFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl const std::ops::BitOrAssign for FenceCreateFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl const std::ops::BitXor for FenceCreateFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl const std::ops::BitXorAssign for FenceCreateFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl const std::ops::BitAnd for FenceCreateFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl const std::ops::BitAndAssign for FenceCreateFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl const std::ops::Sub for FenceCreateFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl const std::ops::SubAssign for FenceCreateFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl const std::ops::Not for FenceCreateFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl Extend<FenceCreateFlags> for FenceCreateFlags {
    fn extend<T: IntoIterator<Item = FenceCreateFlags>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, i);
        }
    }
}
impl FromIterator<FenceCreateFlags> for FenceCreateFlags {
    fn from_iter<T: IntoIterator<Item = FenceCreateFlags>>(iterator: T) -> FenceCreateFlags {
        let mut out = Self::empty();
        <Self as Extend<FenceCreateFlags>>::extend(&mut out, iterator);
        out
    }
}
impl const Default for FenceCreateFlags {
    fn default() -> Self {
        Self::empty()
    }
}
impl const From<FenceCreateFlagBits> for FenceCreateFlags {
    fn from(bit: FenceCreateFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(bit.bits()) }
    }
}
impl Extend<FenceCreateFlagBits> for FenceCreateFlags {
    fn extend<T: IntoIterator<Item = FenceCreateFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, Self::from(i));
        }
    }
}
impl FromIterator<FenceCreateFlagBits> for FenceCreateFlags {
    fn from_iter<T: IntoIterator<Item = FenceCreateFlagBits>>(iterator: T) -> FenceCreateFlags {
        let mut out = Self::empty();
        <Self as Extend<FenceCreateFlagBits>>::extend(&mut out, iterator);
        out
    }
}
impl std::fmt::Debug for FenceCreateFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(FenceCreateFlags);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == FenceCreateFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(FenceCreateFlags::SIGNALED) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(SIGNALED))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(FenceCreateFlags))
            .field(&Flags(*self))
            .finish()
    }
}
#[doc(alias = "VkSemaphoreCreateFlags")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct SemaphoreCreateFlags(u32);
impl SemaphoreCreateFlags {
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
}
# [doc = include_str ! ("../../../doc/VkFormatFeatureFlagBits.md")]
#[doc(alias = "VkFormatFeatureFlags")]
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct FormatFeatureFlags(u32);
impl FormatFeatureFlags {
    #[doc(alias = "VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT")]
    pub const SAMPLED_IMAGE: Self = Self(1);
    #[doc(alias = "VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT")]
    pub const STORAGE_IMAGE: Self = Self(2);
    #[doc(alias = "VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT")]
    pub const STORAGE_IMAGE_ATOMIC: Self = Self(4);
    #[doc(alias = "VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT")]
    pub const UNIFORM_TEXEL_BUFFER: Self = Self(8);
    #[doc(alias = "VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT")]
    pub const STORAGE_TEXEL_BUFFER: Self = Self(16);
    #[doc(alias = "VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT")]
    pub const STORAGE_TEXEL_BUFFER_ATOMIC: Self = Self(32);
    #[doc(alias = "VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT")]
    pub const VERTEX_BUFFER: Self = Self(64);
    #[doc(alias = "VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT")]
    pub const COLOR_ATTACHMENT: Self = Self(128);
    #[doc(alias = "VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT")]
    pub const COLOR_ATTACHMENT_BLEND: Self = Self(256);
    #[doc(alias = "VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT")]
    pub const DEPTH_STENCIL_ATTACHMENT: Self = Self(512);
    #[doc(alias = "VK_FORMAT_FEATURE_BLIT_SRC_BIT")]
    pub const BLIT_SRC: Self = Self(1024);
    #[doc(alias = "VK_FORMAT_FEATURE_BLIT_DST_BIT")]
    pub const BLIT_DST: Self = Self(2048);
    #[doc(alias = "VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT")]
    pub const SAMPLED_IMAGE_FILTER_LINEAR: Self = Self(4096);
    #[doc(alias = "VK_FORMAT_FEATURE_TRANSFER_SRC_BIT")]
    pub const TRANSFER_SRC: Self = Self(16384);
    #[doc(alias = "VK_FORMAT_FEATURE_TRANSFER_DST_BIT")]
    pub const TRANSFER_DST: Self = Self(32768);
    #[doc(alias = "VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT")]
    pub const MIDPOINT_CHROMA_SAMPLES: Self = Self(131072);
    #[doc(alias = "VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT")]
    pub const SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER: Self = Self(262144);
    #[doc(alias = "VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT")]
    pub const SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER: Self = Self(524288);
    #[doc(alias = "VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT")]
    pub const SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT: Self = Self(1048576);
    #[doc(alias = "VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT")]
    pub const SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE: Self = Self(2097152);
    #[doc(alias = "VK_FORMAT_FEATURE_DISJOINT_BIT")]
    pub const DISJOINT: Self = Self(4194304);
    #[doc(alias = "VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT")]
    pub const COSITED_CHROMA_SAMPLES: Self = Self(8388608);
    #[doc(alias = "VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT")]
    #[cfg(feature = "VULKAN_1_2")]
    pub const SAMPLED_IMAGE_FILTER_MINMAX: Self = Self(65536);
    #[doc(alias = "VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG")]
    #[cfg(feature = "VK_IMG_filter_cubic")]
    pub const SAMPLED_IMAGE_FILTER_CUBIC_IMG: Self = Self(8192);
    #[doc(alias = "VK_FORMAT_FEATURE_VIDEO_DECODE_OUTPUT_BIT_KHR")]
    #[cfg(feature = "VK_KHR_video_decode_queue")]
    pub const VIDEO_DECODE_OUTPUT_KHR: Self = Self(33554432);
    #[doc(alias = "VK_FORMAT_FEATURE_VIDEO_DECODE_DPB_BIT_KHR")]
    #[cfg(feature = "VK_KHR_video_decode_queue")]
    pub const VIDEO_DECODE_DPB_KHR: Self = Self(67108864);
    #[doc(alias = "VK_FORMAT_FEATURE_ACCELERATION_STRUCTURE_VERTEX_BUFFER_BIT_KHR")]
    #[cfg(feature = "VK_KHR_acceleration_structure")]
    pub const ACCELERATION_STRUCTURE_VERTEX_BUFFER_KHR: Self = Self(536870912);
    #[doc(alias = "VK_FORMAT_FEATURE_FRAGMENT_DENSITY_MAP_BIT_EXT")]
    #[cfg(feature = "VK_EXT_fragment_density_map")]
    pub const FRAGMENT_DENSITY_MAP_EXT: Self = Self(16777216);
    #[doc(alias = "VK_FORMAT_FEATURE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR")]
    #[cfg(feature = "VK_KHR_fragment_shading_rate")]
    pub const FRAGMENT_SHADING_RATE_ATTACHMENT_KHR: Self = Self(1073741824);
    #[doc(alias = "VK_FORMAT_FEATURE_VIDEO_ENCODE_INPUT_BIT_KHR")]
    #[cfg(feature = "VK_KHR_video_encode_queue")]
    pub const VIDEO_ENCODE_INPUT_KHR: Self = Self(134217728);
    #[doc(alias = "VK_FORMAT_FEATURE_VIDEO_ENCODE_DPB_BIT_KHR")]
    #[cfg(feature = "VK_KHR_video_encode_queue")]
    pub const VIDEO_ENCODE_DPB_KHR: Self = Self(268435456);
    #[doc(alias = "VK_FORMAT_FEATURE_TRANSFER_SRC_BIT_KHR")]
    #[cfg(feature = "VK_KHR_maintenance1")]
    pub const TRANSFER_SRC_KHR: Self = Self::TRANSFER_SRC;
    #[doc(alias = "VK_FORMAT_FEATURE_TRANSFER_DST_BIT_KHR")]
    #[cfg(feature = "VK_KHR_maintenance1")]
    pub const TRANSFER_DST_KHR: Self = Self::TRANSFER_DST;
    #[doc(alias = "VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT")]
    #[cfg(feature = "VK_EXT_sampler_filter_minmax")]
    pub const SAMPLED_IMAGE_FILTER_MINMAX_EXT: Self = Self::SAMPLED_IMAGE_FILTER_MINMAX;
    #[doc(alias = "VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT_KHR")]
    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
    pub const MIDPOINT_CHROMA_SAMPLES_KHR: Self = Self::MIDPOINT_CHROMA_SAMPLES;
    #[doc(alias = "VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR")]
    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
    pub const SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_KHR: Self =
        Self::SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER;
    #[doc(alias = "VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR")]
    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
    pub const SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_KHR: Self =
        Self::SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER;
    #[doc(alias = "VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR")]
    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
    pub const SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_KHR: Self =
        Self::SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT;
    #[doc(alias = "VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR")]
    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
    pub const SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_KHR: Self =
        Self::SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE;
    #[doc(alias = "VK_FORMAT_FEATURE_DISJOINT_BIT_KHR")]
    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
    pub const DISJOINT_KHR: Self = Self::DISJOINT;
    #[doc(alias = "VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT_KHR")]
    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
    pub const COSITED_CHROMA_SAMPLES_KHR: Self = Self::COSITED_CHROMA_SAMPLES;
    #[doc(alias = "VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT")]
    #[cfg(feature = "VK_EXT_filter_cubic")]
    pub const SAMPLED_IMAGE_FILTER_CUBIC_EXT: Self = Self::SAMPLED_IMAGE_FILTER_CUBIC_IMG;
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    #[allow(unused_mut)]
    pub const fn all() -> Self {
        let mut all = Self::empty();
        {
            all |= Self::SAMPLED_IMAGE;
        }
        {
            all |= Self::STORAGE_IMAGE;
        }
        {
            all |= Self::STORAGE_IMAGE_ATOMIC;
        }
        {
            all |= Self::UNIFORM_TEXEL_BUFFER;
        }
        {
            all |= Self::STORAGE_TEXEL_BUFFER;
        }
        {
            all |= Self::STORAGE_TEXEL_BUFFER_ATOMIC;
        }
        {
            all |= Self::VERTEX_BUFFER;
        }
        {
            all |= Self::COLOR_ATTACHMENT;
        }
        {
            all |= Self::COLOR_ATTACHMENT_BLEND;
        }
        {
            all |= Self::DEPTH_STENCIL_ATTACHMENT;
        }
        {
            all |= Self::BLIT_SRC;
        }
        {
            all |= Self::BLIT_DST;
        }
        {
            all |= Self::SAMPLED_IMAGE_FILTER_LINEAR;
        }
        {
            all |= Self::TRANSFER_SRC;
        }
        {
            all |= Self::TRANSFER_DST;
        }
        {
            all |= Self::MIDPOINT_CHROMA_SAMPLES;
        }
        {
            all |= Self::SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER;
        }
        {
            all |= Self::SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER;
        }
        {
            all |= Self::SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT;
        }
        {
            all |= Self::SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE;
        }
        {
            all |= Self::DISJOINT;
        }
        {
            all |= Self::COSITED_CHROMA_SAMPLES;
        }
        #[cfg(feature = "VULKAN_1_2")]
        {
            all |= Self::SAMPLED_IMAGE_FILTER_MINMAX;
        }
        #[cfg(feature = "VK_IMG_filter_cubic")]
        {
            all |= Self::SAMPLED_IMAGE_FILTER_CUBIC_IMG;
        }
        #[cfg(feature = "VK_KHR_video_decode_queue")]
        {
            all |= Self::VIDEO_DECODE_OUTPUT_KHR;
        }
        #[cfg(feature = "VK_KHR_video_decode_queue")]
        {
            all |= Self::VIDEO_DECODE_DPB_KHR;
        }
        #[cfg(feature = "VK_KHR_acceleration_structure")]
        {
            all |= Self::ACCELERATION_STRUCTURE_VERTEX_BUFFER_KHR;
        }
        #[cfg(feature = "VK_EXT_fragment_density_map")]
        {
            all |= Self::FRAGMENT_DENSITY_MAP_EXT;
        }
        #[cfg(feature = "VK_KHR_fragment_shading_rate")]
        {
            all |= Self::FRAGMENT_SHADING_RATE_ATTACHMENT_KHR;
        }
        #[cfg(feature = "VK_KHR_video_encode_queue")]
        {
            all |= Self::VIDEO_ENCODE_INPUT_KHR;
        }
        #[cfg(feature = "VK_KHR_video_encode_queue")]
        {
            all |= Self::VIDEO_ENCODE_DPB_KHR;
        }
        #[cfg(feature = "VK_KHR_maintenance1")]
        {
            all |= Self::TRANSFER_SRC_KHR;
        }
        #[cfg(feature = "VK_KHR_maintenance1")]
        {
            all |= Self::TRANSFER_DST_KHR;
        }
        #[cfg(feature = "VK_EXT_sampler_filter_minmax")]
        {
            all |= Self::SAMPLED_IMAGE_FILTER_MINMAX_EXT;
        }
        #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
        {
            all |= Self::MIDPOINT_CHROMA_SAMPLES_KHR;
        }
        #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
        {
            all |= Self::SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_KHR;
        }
        #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
        {
            all |= Self::SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_KHR;
        }
        #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
        {
            all |= Self::SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_KHR;
        }
        #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
        {
            all |= Self::SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_KHR;
        }
        #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
        {
            all |= Self::DISJOINT_KHR;
        }
        #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
        {
            all |= Self::COSITED_CHROMA_SAMPLES_KHR;
        }
        #[cfg(feature = "VK_EXT_filter_cubic")]
        {
            all |= Self::SAMPLED_IMAGE_FILTER_CUBIC_EXT;
        }
        all
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl const std::ops::BitOr for FormatFeatureFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl const std::ops::BitOrAssign for FormatFeatureFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl const std::ops::BitXor for FormatFeatureFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl const std::ops::BitXorAssign for FormatFeatureFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl const std::ops::BitAnd for FormatFeatureFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl const std::ops::BitAndAssign for FormatFeatureFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl const std::ops::Sub for FormatFeatureFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl const std::ops::SubAssign for FormatFeatureFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl const std::ops::Not for FormatFeatureFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl Extend<FormatFeatureFlags> for FormatFeatureFlags {
    fn extend<T: IntoIterator<Item = FormatFeatureFlags>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, i);
        }
    }
}
impl FromIterator<FormatFeatureFlags> for FormatFeatureFlags {
    fn from_iter<T: IntoIterator<Item = FormatFeatureFlags>>(iterator: T) -> FormatFeatureFlags {
        let mut out = Self::empty();
        <Self as Extend<FormatFeatureFlags>>::extend(&mut out, iterator);
        out
    }
}
impl const Default for FormatFeatureFlags {
    fn default() -> Self {
        Self::empty()
    }
}
impl const From<FormatFeatureFlagBits> for FormatFeatureFlags {
    fn from(bit: FormatFeatureFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(bit.bits()) }
    }
}
impl Extend<FormatFeatureFlagBits> for FormatFeatureFlags {
    fn extend<T: IntoIterator<Item = FormatFeatureFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, Self::from(i));
        }
    }
}
impl FromIterator<FormatFeatureFlagBits> for FormatFeatureFlags {
    fn from_iter<T: IntoIterator<Item = FormatFeatureFlagBits>>(iterator: T) -> FormatFeatureFlags {
        let mut out = Self::empty();
        <Self as Extend<FormatFeatureFlagBits>>::extend(&mut out, iterator);
        out
    }
}
impl std::fmt::Debug for FormatFeatureFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(FormatFeatureFlags);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == FormatFeatureFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(FormatFeatureFlags::SAMPLED_IMAGE) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(SAMPLED_IMAGE))?;
                    }
                    if self.0.contains(FormatFeatureFlags::STORAGE_IMAGE) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(STORAGE_IMAGE))?;
                    }
                    if self.0.contains(FormatFeatureFlags::STORAGE_IMAGE_ATOMIC) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(STORAGE_IMAGE_ATOMIC))?;
                    }
                    if self.0.contains(FormatFeatureFlags::UNIFORM_TEXEL_BUFFER) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(UNIFORM_TEXEL_BUFFER))?;
                    }
                    if self.0.contains(FormatFeatureFlags::STORAGE_TEXEL_BUFFER) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(STORAGE_TEXEL_BUFFER))?;
                    }
                    if self.0.contains(FormatFeatureFlags::STORAGE_TEXEL_BUFFER_ATOMIC) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(STORAGE_TEXEL_BUFFER_ATOMIC))?;
                    }
                    if self.0.contains(FormatFeatureFlags::VERTEX_BUFFER) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(VERTEX_BUFFER))?;
                    }
                    if self.0.contains(FormatFeatureFlags::COLOR_ATTACHMENT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(COLOR_ATTACHMENT))?;
                    }
                    if self.0.contains(FormatFeatureFlags::COLOR_ATTACHMENT_BLEND) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(COLOR_ATTACHMENT_BLEND))?;
                    }
                    if self.0.contains(FormatFeatureFlags::DEPTH_STENCIL_ATTACHMENT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(DEPTH_STENCIL_ATTACHMENT))?;
                    }
                    if self.0.contains(FormatFeatureFlags::BLIT_SRC) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(BLIT_SRC))?;
                    }
                    if self.0.contains(FormatFeatureFlags::BLIT_DST) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(BLIT_DST))?;
                    }
                    if self.0.contains(FormatFeatureFlags::SAMPLED_IMAGE_FILTER_LINEAR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(SAMPLED_IMAGE_FILTER_LINEAR))?;
                    }
                    if self.0.contains(FormatFeatureFlags::TRANSFER_SRC) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(TRANSFER_SRC))?;
                    }
                    if self.0.contains(FormatFeatureFlags::TRANSFER_DST) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(TRANSFER_DST))?;
                    }
                    if self.0.contains(FormatFeatureFlags::MIDPOINT_CHROMA_SAMPLES) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(MIDPOINT_CHROMA_SAMPLES))?;
                    }
                    if self
                        .0
                        .contains(FormatFeatureFlags::SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER))?;
                    }
                    if self
                        .0
                        .contains(FormatFeatureFlags::SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(
                            SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER
                        ))?;
                    }
                    if self
                        .0
                        .contains(FormatFeatureFlags::SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(
                            SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT
                        ))?;
                    }
                    if self.0.contains(
                        FormatFeatureFlags::SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE,
                    ) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(
                            SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE
                        ))?;
                    }
                    if self.0.contains(FormatFeatureFlags::DISJOINT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(DISJOINT))?;
                    }
                    if self.0.contains(FormatFeatureFlags::COSITED_CHROMA_SAMPLES) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(COSITED_CHROMA_SAMPLES))?;
                    }
                    #[cfg(feature = "VULKAN_1_2")]
                    if self.0.contains(FormatFeatureFlags::SAMPLED_IMAGE_FILTER_MINMAX) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(SAMPLED_IMAGE_FILTER_MINMAX))?;
                    }
                    #[cfg(feature = "VK_IMG_filter_cubic")]
                    if self.0.contains(FormatFeatureFlags::SAMPLED_IMAGE_FILTER_CUBIC_IMG) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(SAMPLED_IMAGE_FILTER_CUBIC_IMG))?;
                    }
                    #[cfg(feature = "VK_KHR_video_decode_queue")]
                    if self.0.contains(FormatFeatureFlags::VIDEO_DECODE_OUTPUT_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(VIDEO_DECODE_OUTPUT_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_video_decode_queue")]
                    if self.0.contains(FormatFeatureFlags::VIDEO_DECODE_DPB_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(VIDEO_DECODE_DPB_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_acceleration_structure")]
                    if self
                        .0
                        .contains(FormatFeatureFlags::ACCELERATION_STRUCTURE_VERTEX_BUFFER_KHR)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(ACCELERATION_STRUCTURE_VERTEX_BUFFER_KHR))?;
                    }
                    #[cfg(feature = "VK_EXT_fragment_density_map")]
                    if self.0.contains(FormatFeatureFlags::FRAGMENT_DENSITY_MAP_EXT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(FRAGMENT_DENSITY_MAP_EXT))?;
                    }
                    #[cfg(feature = "VK_KHR_fragment_shading_rate")]
                    if self
                        .0
                        .contains(FormatFeatureFlags::FRAGMENT_SHADING_RATE_ATTACHMENT_KHR)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(FRAGMENT_SHADING_RATE_ATTACHMENT_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_video_encode_queue")]
                    if self.0.contains(FormatFeatureFlags::VIDEO_ENCODE_INPUT_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(VIDEO_ENCODE_INPUT_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_video_encode_queue")]
                    if self.0.contains(FormatFeatureFlags::VIDEO_ENCODE_DPB_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(VIDEO_ENCODE_DPB_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_maintenance1")]
                    if self.0.contains(FormatFeatureFlags::TRANSFER_SRC_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(TRANSFER_SRC_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_maintenance1")]
                    if self.0.contains(FormatFeatureFlags::TRANSFER_DST_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(TRANSFER_DST_KHR))?;
                    }
                    #[cfg(feature = "VK_EXT_sampler_filter_minmax")]
                    if self.0.contains(FormatFeatureFlags::SAMPLED_IMAGE_FILTER_MINMAX_EXT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(SAMPLED_IMAGE_FILTER_MINMAX_EXT))?;
                    }
                    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
                    if self.0.contains(FormatFeatureFlags::MIDPOINT_CHROMA_SAMPLES_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(MIDPOINT_CHROMA_SAMPLES_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
                    if self
                        .0
                        .contains(FormatFeatureFlags::SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_KHR)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
                    if self
                        .0
                        .contains(FormatFeatureFlags::SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_KHR)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(
                            SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_KHR
                        ))?;
                    }
                    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
                    if self
                        .0
                        .contains(FormatFeatureFlags::SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_KHR)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(
                            SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_KHR
                        ))?;
                    }
                    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
                    if self.0.contains(
                        FormatFeatureFlags::SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_KHR,
                    ) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(
                            SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_KHR
                        ))?;
                    }
                    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
                    if self.0.contains(FormatFeatureFlags::DISJOINT_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(DISJOINT_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
                    if self.0.contains(FormatFeatureFlags::COSITED_CHROMA_SAMPLES_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(COSITED_CHROMA_SAMPLES_KHR))?;
                    }
                    #[cfg(feature = "VK_EXT_filter_cubic")]
                    if self.0.contains(FormatFeatureFlags::SAMPLED_IMAGE_FILTER_CUBIC_EXT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(SAMPLED_IMAGE_FILTER_CUBIC_EXT))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(FormatFeatureFlags))
            .field(&Flags(*self))
            .finish()
    }
}
# [doc = include_str ! ("../../../doc/VkQueryControlFlagBits.md")]
#[doc(alias = "VkQueryControlFlags")]
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct QueryControlFlags(u32);
impl QueryControlFlags {
    #[doc(alias = "VK_QUERY_CONTROL_PRECISE_BIT")]
    pub const PRECISE: Self = Self(1);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    #[allow(unused_mut)]
    pub const fn all() -> Self {
        let mut all = Self::empty();
        {
            all |= Self::PRECISE;
        }
        all
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl const std::ops::BitOr for QueryControlFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl const std::ops::BitOrAssign for QueryControlFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl const std::ops::BitXor for QueryControlFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl const std::ops::BitXorAssign for QueryControlFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl const std::ops::BitAnd for QueryControlFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl const std::ops::BitAndAssign for QueryControlFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl const std::ops::Sub for QueryControlFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl const std::ops::SubAssign for QueryControlFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl const std::ops::Not for QueryControlFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl Extend<QueryControlFlags> for QueryControlFlags {
    fn extend<T: IntoIterator<Item = QueryControlFlags>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, i);
        }
    }
}
impl FromIterator<QueryControlFlags> for QueryControlFlags {
    fn from_iter<T: IntoIterator<Item = QueryControlFlags>>(iterator: T) -> QueryControlFlags {
        let mut out = Self::empty();
        <Self as Extend<QueryControlFlags>>::extend(&mut out, iterator);
        out
    }
}
impl const Default for QueryControlFlags {
    fn default() -> Self {
        Self::empty()
    }
}
impl const From<QueryControlFlagBits> for QueryControlFlags {
    fn from(bit: QueryControlFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(bit.bits()) }
    }
}
impl Extend<QueryControlFlagBits> for QueryControlFlags {
    fn extend<T: IntoIterator<Item = QueryControlFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, Self::from(i));
        }
    }
}
impl FromIterator<QueryControlFlagBits> for QueryControlFlags {
    fn from_iter<T: IntoIterator<Item = QueryControlFlagBits>>(iterator: T) -> QueryControlFlags {
        let mut out = Self::empty();
        <Self as Extend<QueryControlFlagBits>>::extend(&mut out, iterator);
        out
    }
}
impl std::fmt::Debug for QueryControlFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(QueryControlFlags);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == QueryControlFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(QueryControlFlags::PRECISE) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(PRECISE))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(QueryControlFlags))
            .field(&Flags(*self))
            .finish()
    }
}
# [doc = include_str ! ("../../../doc/VkQueryResultFlagBits.md")]
#[doc(alias = "VkQueryResultFlags")]
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct QueryResultFlags(u32);
impl QueryResultFlags {
    #[doc(alias = "VK_QUERY_RESULT_64_BIT")]
    pub const N64: Self = Self(1);
    #[doc(alias = "VK_QUERY_RESULT_WAIT_BIT")]
    pub const WAIT: Self = Self(2);
    #[doc(alias = "VK_QUERY_RESULT_WITH_AVAILABILITY_BIT")]
    pub const WITH_AVAILABILITY: Self = Self(4);
    #[doc(alias = "VK_QUERY_RESULT_PARTIAL_BIT")]
    pub const PARTIAL: Self = Self(8);
    #[doc(alias = "VK_QUERY_RESULT_WITH_STATUS_BIT_KHR")]
    #[cfg(feature = "VK_KHR_video_queue")]
    pub const WITH_STATUS_KHR: Self = Self(16);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    #[allow(unused_mut)]
    pub const fn all() -> Self {
        let mut all = Self::empty();
        {
            all |= Self::N64;
        }
        {
            all |= Self::WAIT;
        }
        {
            all |= Self::WITH_AVAILABILITY;
        }
        {
            all |= Self::PARTIAL;
        }
        #[cfg(feature = "VK_KHR_video_queue")]
        {
            all |= Self::WITH_STATUS_KHR;
        }
        all
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl const std::ops::BitOr for QueryResultFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl const std::ops::BitOrAssign for QueryResultFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl const std::ops::BitXor for QueryResultFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl const std::ops::BitXorAssign for QueryResultFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl const std::ops::BitAnd for QueryResultFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl const std::ops::BitAndAssign for QueryResultFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl const std::ops::Sub for QueryResultFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl const std::ops::SubAssign for QueryResultFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl const std::ops::Not for QueryResultFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl Extend<QueryResultFlags> for QueryResultFlags {
    fn extend<T: IntoIterator<Item = QueryResultFlags>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, i);
        }
    }
}
impl FromIterator<QueryResultFlags> for QueryResultFlags {
    fn from_iter<T: IntoIterator<Item = QueryResultFlags>>(iterator: T) -> QueryResultFlags {
        let mut out = Self::empty();
        <Self as Extend<QueryResultFlags>>::extend(&mut out, iterator);
        out
    }
}
impl const Default for QueryResultFlags {
    fn default() -> Self {
        Self::empty()
    }
}
impl const From<QueryResultFlagBits> for QueryResultFlags {
    fn from(bit: QueryResultFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(bit.bits()) }
    }
}
impl Extend<QueryResultFlagBits> for QueryResultFlags {
    fn extend<T: IntoIterator<Item = QueryResultFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, Self::from(i));
        }
    }
}
impl FromIterator<QueryResultFlagBits> for QueryResultFlags {
    fn from_iter<T: IntoIterator<Item = QueryResultFlagBits>>(iterator: T) -> QueryResultFlags {
        let mut out = Self::empty();
        <Self as Extend<QueryResultFlagBits>>::extend(&mut out, iterator);
        out
    }
}
impl std::fmt::Debug for QueryResultFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(QueryResultFlags);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == QueryResultFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(QueryResultFlags::N64) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(N64))?;
                    }
                    if self.0.contains(QueryResultFlags::WAIT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(WAIT))?;
                    }
                    if self.0.contains(QueryResultFlags::WITH_AVAILABILITY) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(WITH_AVAILABILITY))?;
                    }
                    if self.0.contains(QueryResultFlags::PARTIAL) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(PARTIAL))?;
                    }
                    #[cfg(feature = "VK_KHR_video_queue")]
                    if self.0.contains(QueryResultFlags::WITH_STATUS_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(WITH_STATUS_KHR))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(QueryResultFlags))
            .field(&Flags(*self))
            .finish()
    }
}
#[doc(alias = "VkShaderModuleCreateFlags")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct ShaderModuleCreateFlags(u32);
impl ShaderModuleCreateFlags {
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
}
# [doc = include_str ! ("../../../doc/VkEventCreateFlagBits.md")]
#[doc(alias = "VkEventCreateFlags")]
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct EventCreateFlags(u32);
impl EventCreateFlags {
    #[doc(alias = "VK_EVENT_CREATE_DEVICE_ONLY_BIT")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const DEVICE_ONLY: Self = Self(1);
    #[doc(alias = "VK_EVENT_CREATE_DEVICE_ONLY_BIT_KHR")]
    #[cfg(feature = "VK_KHR_synchronization2")]
    pub const DEVICE_ONLY_KHR: Self = Self::DEVICE_ONLY;
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    #[allow(unused_mut)]
    pub const fn all() -> Self {
        let mut all = Self::empty();
        #[cfg(feature = "VULKAN_1_3")]
        {
            all |= Self::DEVICE_ONLY;
        }
        #[cfg(feature = "VK_KHR_synchronization2")]
        {
            all |= Self::DEVICE_ONLY_KHR;
        }
        all
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl const std::ops::BitOr for EventCreateFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl const std::ops::BitOrAssign for EventCreateFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl const std::ops::BitXor for EventCreateFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl const std::ops::BitXorAssign for EventCreateFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl const std::ops::BitAnd for EventCreateFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl const std::ops::BitAndAssign for EventCreateFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl const std::ops::Sub for EventCreateFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl const std::ops::SubAssign for EventCreateFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl const std::ops::Not for EventCreateFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl Extend<EventCreateFlags> for EventCreateFlags {
    fn extend<T: IntoIterator<Item = EventCreateFlags>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, i);
        }
    }
}
impl FromIterator<EventCreateFlags> for EventCreateFlags {
    fn from_iter<T: IntoIterator<Item = EventCreateFlags>>(iterator: T) -> EventCreateFlags {
        let mut out = Self::empty();
        <Self as Extend<EventCreateFlags>>::extend(&mut out, iterator);
        out
    }
}
impl const Default for EventCreateFlags {
    fn default() -> Self {
        Self::empty()
    }
}
impl const From<EventCreateFlagBits> for EventCreateFlags {
    fn from(bit: EventCreateFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(bit.bits()) }
    }
}
impl Extend<EventCreateFlagBits> for EventCreateFlags {
    fn extend<T: IntoIterator<Item = EventCreateFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, Self::from(i));
        }
    }
}
impl FromIterator<EventCreateFlagBits> for EventCreateFlags {
    fn from_iter<T: IntoIterator<Item = EventCreateFlagBits>>(iterator: T) -> EventCreateFlags {
        let mut out = Self::empty();
        <Self as Extend<EventCreateFlagBits>>::extend(&mut out, iterator);
        out
    }
}
impl std::fmt::Debug for EventCreateFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(EventCreateFlags);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == EventCreateFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    #[cfg(feature = "VULKAN_1_3")]
                    if self.0.contains(EventCreateFlags::DEVICE_ONLY) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(DEVICE_ONLY))?;
                    }
                    #[cfg(feature = "VK_KHR_synchronization2")]
                    if self.0.contains(EventCreateFlags::DEVICE_ONLY_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(DEVICE_ONLY_KHR))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(EventCreateFlags))
            .field(&Flags(*self))
            .finish()
    }
}
# [doc = include_str ! ("../../../doc/VkCommandPoolCreateFlagBits.md")]
#[doc(alias = "VkCommandPoolCreateFlags")]
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct CommandPoolCreateFlags(u32);
impl CommandPoolCreateFlags {
    #[doc(alias = "VK_COMMAND_POOL_CREATE_TRANSIENT_BIT")]
    pub const TRANSIENT: Self = Self(1);
    #[doc(alias = "VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT")]
    pub const RESET_COMMAND_BUFFER: Self = Self(2);
    #[doc(alias = "VK_COMMAND_POOL_CREATE_PROTECTED_BIT")]
    pub const PROTECTED: Self = Self(4);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    #[allow(unused_mut)]
    pub const fn all() -> Self {
        let mut all = Self::empty();
        {
            all |= Self::TRANSIENT;
        }
        {
            all |= Self::RESET_COMMAND_BUFFER;
        }
        {
            all |= Self::PROTECTED;
        }
        all
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl const std::ops::BitOr for CommandPoolCreateFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl const std::ops::BitOrAssign for CommandPoolCreateFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl const std::ops::BitXor for CommandPoolCreateFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl const std::ops::BitXorAssign for CommandPoolCreateFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl const std::ops::BitAnd for CommandPoolCreateFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl const std::ops::BitAndAssign for CommandPoolCreateFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl const std::ops::Sub for CommandPoolCreateFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl const std::ops::SubAssign for CommandPoolCreateFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl const std::ops::Not for CommandPoolCreateFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl Extend<CommandPoolCreateFlags> for CommandPoolCreateFlags {
    fn extend<T: IntoIterator<Item = CommandPoolCreateFlags>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, i);
        }
    }
}
impl FromIterator<CommandPoolCreateFlags> for CommandPoolCreateFlags {
    fn from_iter<T: IntoIterator<Item = CommandPoolCreateFlags>>(iterator: T) -> CommandPoolCreateFlags {
        let mut out = Self::empty();
        <Self as Extend<CommandPoolCreateFlags>>::extend(&mut out, iterator);
        out
    }
}
impl const Default for CommandPoolCreateFlags {
    fn default() -> Self {
        Self::empty()
    }
}
impl const From<CommandPoolCreateFlagBits> for CommandPoolCreateFlags {
    fn from(bit: CommandPoolCreateFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(bit.bits()) }
    }
}
impl Extend<CommandPoolCreateFlagBits> for CommandPoolCreateFlags {
    fn extend<T: IntoIterator<Item = CommandPoolCreateFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, Self::from(i));
        }
    }
}
impl FromIterator<CommandPoolCreateFlagBits> for CommandPoolCreateFlags {
    fn from_iter<T: IntoIterator<Item = CommandPoolCreateFlagBits>>(iterator: T) -> CommandPoolCreateFlags {
        let mut out = Self::empty();
        <Self as Extend<CommandPoolCreateFlagBits>>::extend(&mut out, iterator);
        out
    }
}
impl std::fmt::Debug for CommandPoolCreateFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(CommandPoolCreateFlags);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == CommandPoolCreateFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(CommandPoolCreateFlags::TRANSIENT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(TRANSIENT))?;
                    }
                    if self.0.contains(CommandPoolCreateFlags::RESET_COMMAND_BUFFER) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(RESET_COMMAND_BUFFER))?;
                    }
                    if self.0.contains(CommandPoolCreateFlags::PROTECTED) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(PROTECTED))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(CommandPoolCreateFlags))
            .field(&Flags(*self))
            .finish()
    }
}
# [doc = include_str ! ("../../../doc/VkCommandPoolResetFlagBits.md")]
#[doc(alias = "VkCommandPoolResetFlags")]
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct CommandPoolResetFlags(u32);
impl CommandPoolResetFlags {
    #[doc(alias = "VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT")]
    pub const RELEASE_RESOURCES: Self = Self(1);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    #[allow(unused_mut)]
    pub const fn all() -> Self {
        let mut all = Self::empty();
        {
            all |= Self::RELEASE_RESOURCES;
        }
        all
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl const std::ops::BitOr for CommandPoolResetFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl const std::ops::BitOrAssign for CommandPoolResetFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl const std::ops::BitXor for CommandPoolResetFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl const std::ops::BitXorAssign for CommandPoolResetFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl const std::ops::BitAnd for CommandPoolResetFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl const std::ops::BitAndAssign for CommandPoolResetFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl const std::ops::Sub for CommandPoolResetFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl const std::ops::SubAssign for CommandPoolResetFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl const std::ops::Not for CommandPoolResetFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl Extend<CommandPoolResetFlags> for CommandPoolResetFlags {
    fn extend<T: IntoIterator<Item = CommandPoolResetFlags>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, i);
        }
    }
}
impl FromIterator<CommandPoolResetFlags> for CommandPoolResetFlags {
    fn from_iter<T: IntoIterator<Item = CommandPoolResetFlags>>(iterator: T) -> CommandPoolResetFlags {
        let mut out = Self::empty();
        <Self as Extend<CommandPoolResetFlags>>::extend(&mut out, iterator);
        out
    }
}
impl const Default for CommandPoolResetFlags {
    fn default() -> Self {
        Self::empty()
    }
}
impl const From<CommandPoolResetFlagBits> for CommandPoolResetFlags {
    fn from(bit: CommandPoolResetFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(bit.bits()) }
    }
}
impl Extend<CommandPoolResetFlagBits> for CommandPoolResetFlags {
    fn extend<T: IntoIterator<Item = CommandPoolResetFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, Self::from(i));
        }
    }
}
impl FromIterator<CommandPoolResetFlagBits> for CommandPoolResetFlags {
    fn from_iter<T: IntoIterator<Item = CommandPoolResetFlagBits>>(iterator: T) -> CommandPoolResetFlags {
        let mut out = Self::empty();
        <Self as Extend<CommandPoolResetFlagBits>>::extend(&mut out, iterator);
        out
    }
}
impl std::fmt::Debug for CommandPoolResetFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(CommandPoolResetFlags);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == CommandPoolResetFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(CommandPoolResetFlags::RELEASE_RESOURCES) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(RELEASE_RESOURCES))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(CommandPoolResetFlags))
            .field(&Flags(*self))
            .finish()
    }
}
# [doc = include_str ! ("../../../doc/VkCommandBufferResetFlagBits.md")]
#[doc(alias = "VkCommandBufferResetFlags")]
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct CommandBufferResetFlags(u32);
impl CommandBufferResetFlags {
    #[doc(alias = "VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT")]
    pub const RELEASE_RESOURCES: Self = Self(1);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    #[allow(unused_mut)]
    pub const fn all() -> Self {
        let mut all = Self::empty();
        {
            all |= Self::RELEASE_RESOURCES;
        }
        all
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl const std::ops::BitOr for CommandBufferResetFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl const std::ops::BitOrAssign for CommandBufferResetFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl const std::ops::BitXor for CommandBufferResetFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl const std::ops::BitXorAssign for CommandBufferResetFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl const std::ops::BitAnd for CommandBufferResetFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl const std::ops::BitAndAssign for CommandBufferResetFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl const std::ops::Sub for CommandBufferResetFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl const std::ops::SubAssign for CommandBufferResetFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl const std::ops::Not for CommandBufferResetFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl Extend<CommandBufferResetFlags> for CommandBufferResetFlags {
    fn extend<T: IntoIterator<Item = CommandBufferResetFlags>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, i);
        }
    }
}
impl FromIterator<CommandBufferResetFlags> for CommandBufferResetFlags {
    fn from_iter<T: IntoIterator<Item = CommandBufferResetFlags>>(iterator: T) -> CommandBufferResetFlags {
        let mut out = Self::empty();
        <Self as Extend<CommandBufferResetFlags>>::extend(&mut out, iterator);
        out
    }
}
impl const Default for CommandBufferResetFlags {
    fn default() -> Self {
        Self::empty()
    }
}
impl const From<CommandBufferResetFlagBits> for CommandBufferResetFlags {
    fn from(bit: CommandBufferResetFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(bit.bits()) }
    }
}
impl Extend<CommandBufferResetFlagBits> for CommandBufferResetFlags {
    fn extend<T: IntoIterator<Item = CommandBufferResetFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, Self::from(i));
        }
    }
}
impl FromIterator<CommandBufferResetFlagBits> for CommandBufferResetFlags {
    fn from_iter<T: IntoIterator<Item = CommandBufferResetFlagBits>>(iterator: T) -> CommandBufferResetFlags {
        let mut out = Self::empty();
        <Self as Extend<CommandBufferResetFlagBits>>::extend(&mut out, iterator);
        out
    }
}
impl std::fmt::Debug for CommandBufferResetFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(CommandBufferResetFlags);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == CommandBufferResetFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(CommandBufferResetFlags::RELEASE_RESOURCES) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(RELEASE_RESOURCES))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(CommandBufferResetFlags))
            .field(&Flags(*self))
            .finish()
    }
}
# [doc = include_str ! ("../../../doc/VkCommandBufferUsageFlagBits.md")]
#[doc(alias = "VkCommandBufferUsageFlags")]
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct CommandBufferUsageFlags(u32);
impl CommandBufferUsageFlags {
    #[doc(alias = "VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT")]
    pub const ONE_TIME_SUBMIT: Self = Self(1);
    #[doc(alias = "VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT")]
    pub const RENDER_PASS_CONTINUE: Self = Self(2);
    #[doc(alias = "VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT")]
    pub const SIMULTANEOUS_USE: Self = Self(4);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    #[allow(unused_mut)]
    pub const fn all() -> Self {
        let mut all = Self::empty();
        {
            all |= Self::ONE_TIME_SUBMIT;
        }
        {
            all |= Self::RENDER_PASS_CONTINUE;
        }
        {
            all |= Self::SIMULTANEOUS_USE;
        }
        all
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl const std::ops::BitOr for CommandBufferUsageFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl const std::ops::BitOrAssign for CommandBufferUsageFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl const std::ops::BitXor for CommandBufferUsageFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl const std::ops::BitXorAssign for CommandBufferUsageFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl const std::ops::BitAnd for CommandBufferUsageFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl const std::ops::BitAndAssign for CommandBufferUsageFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl const std::ops::Sub for CommandBufferUsageFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl const std::ops::SubAssign for CommandBufferUsageFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl const std::ops::Not for CommandBufferUsageFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl Extend<CommandBufferUsageFlags> for CommandBufferUsageFlags {
    fn extend<T: IntoIterator<Item = CommandBufferUsageFlags>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, i);
        }
    }
}
impl FromIterator<CommandBufferUsageFlags> for CommandBufferUsageFlags {
    fn from_iter<T: IntoIterator<Item = CommandBufferUsageFlags>>(iterator: T) -> CommandBufferUsageFlags {
        let mut out = Self::empty();
        <Self as Extend<CommandBufferUsageFlags>>::extend(&mut out, iterator);
        out
    }
}
impl const Default for CommandBufferUsageFlags {
    fn default() -> Self {
        Self::empty()
    }
}
impl const From<CommandBufferUsageFlagBits> for CommandBufferUsageFlags {
    fn from(bit: CommandBufferUsageFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(bit.bits()) }
    }
}
impl Extend<CommandBufferUsageFlagBits> for CommandBufferUsageFlags {
    fn extend<T: IntoIterator<Item = CommandBufferUsageFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, Self::from(i));
        }
    }
}
impl FromIterator<CommandBufferUsageFlagBits> for CommandBufferUsageFlags {
    fn from_iter<T: IntoIterator<Item = CommandBufferUsageFlagBits>>(iterator: T) -> CommandBufferUsageFlags {
        let mut out = Self::empty();
        <Self as Extend<CommandBufferUsageFlagBits>>::extend(&mut out, iterator);
        out
    }
}
impl std::fmt::Debug for CommandBufferUsageFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(CommandBufferUsageFlags);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == CommandBufferUsageFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(CommandBufferUsageFlags::ONE_TIME_SUBMIT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(ONE_TIME_SUBMIT))?;
                    }
                    if self.0.contains(CommandBufferUsageFlags::RENDER_PASS_CONTINUE) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(RENDER_PASS_CONTINUE))?;
                    }
                    if self.0.contains(CommandBufferUsageFlags::SIMULTANEOUS_USE) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(SIMULTANEOUS_USE))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(CommandBufferUsageFlags))
            .field(&Flags(*self))
            .finish()
    }
}
# [doc = include_str ! ("../../../doc/VkQueryPipelineStatisticFlagBits.md")]
#[doc(alias = "VkQueryPipelineStatisticFlags")]
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct QueryPipelineStatisticFlags(u32);
impl QueryPipelineStatisticFlags {
    #[doc(alias = "VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT")]
    pub const INPUT_ASSEMBLY_VERTICES: Self = Self(1);
    #[doc(alias = "VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT")]
    pub const INPUT_ASSEMBLY_PRIMITIVES: Self = Self(2);
    #[doc(alias = "VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT")]
    pub const VERTEX_SHADER_INVOCATIONS: Self = Self(4);
    #[doc(alias = "VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT")]
    pub const GEOMETRY_SHADER_INVOCATIONS: Self = Self(8);
    #[doc(alias = "VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT")]
    pub const GEOMETRY_SHADER_PRIMITIVES: Self = Self(16);
    #[doc(alias = "VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT")]
    pub const CLIPPING_INVOCATIONS: Self = Self(32);
    #[doc(alias = "VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT")]
    pub const CLIPPING_PRIMITIVES: Self = Self(64);
    #[doc(alias = "VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT")]
    pub const FRAGMENT_SHADER_INVOCATIONS: Self = Self(128);
    #[doc(alias = "VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT")]
    pub const TESSELLATION_CONTROL_SHADER_PATCHES: Self = Self(256);
    #[doc(alias = "VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT")]
    pub const TESSELLATION_EVALUATION_SHADER_INVOCATIONS: Self = Self(512);
    #[doc(alias = "VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT")]
    pub const COMPUTE_SHADER_INVOCATIONS: Self = Self(1024);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    #[allow(unused_mut)]
    pub const fn all() -> Self {
        let mut all = Self::empty();
        {
            all |= Self::INPUT_ASSEMBLY_VERTICES;
        }
        {
            all |= Self::INPUT_ASSEMBLY_PRIMITIVES;
        }
        {
            all |= Self::VERTEX_SHADER_INVOCATIONS;
        }
        {
            all |= Self::GEOMETRY_SHADER_INVOCATIONS;
        }
        {
            all |= Self::GEOMETRY_SHADER_PRIMITIVES;
        }
        {
            all |= Self::CLIPPING_INVOCATIONS;
        }
        {
            all |= Self::CLIPPING_PRIMITIVES;
        }
        {
            all |= Self::FRAGMENT_SHADER_INVOCATIONS;
        }
        {
            all |= Self::TESSELLATION_CONTROL_SHADER_PATCHES;
        }
        {
            all |= Self::TESSELLATION_EVALUATION_SHADER_INVOCATIONS;
        }
        {
            all |= Self::COMPUTE_SHADER_INVOCATIONS;
        }
        all
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl const std::ops::BitOr for QueryPipelineStatisticFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl const std::ops::BitOrAssign for QueryPipelineStatisticFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl const std::ops::BitXor for QueryPipelineStatisticFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl const std::ops::BitXorAssign for QueryPipelineStatisticFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl const std::ops::BitAnd for QueryPipelineStatisticFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl const std::ops::BitAndAssign for QueryPipelineStatisticFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl const std::ops::Sub for QueryPipelineStatisticFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl const std::ops::SubAssign for QueryPipelineStatisticFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl const std::ops::Not for QueryPipelineStatisticFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl Extend<QueryPipelineStatisticFlags> for QueryPipelineStatisticFlags {
    fn extend<T: IntoIterator<Item = QueryPipelineStatisticFlags>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, i);
        }
    }
}
impl FromIterator<QueryPipelineStatisticFlags> for QueryPipelineStatisticFlags {
    fn from_iter<T: IntoIterator<Item = QueryPipelineStatisticFlags>>(iterator: T) -> QueryPipelineStatisticFlags {
        let mut out = Self::empty();
        <Self as Extend<QueryPipelineStatisticFlags>>::extend(&mut out, iterator);
        out
    }
}
impl const Default for QueryPipelineStatisticFlags {
    fn default() -> Self {
        Self::empty()
    }
}
impl const From<QueryPipelineStatisticFlagBits> for QueryPipelineStatisticFlags {
    fn from(bit: QueryPipelineStatisticFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(bit.bits()) }
    }
}
impl Extend<QueryPipelineStatisticFlagBits> for QueryPipelineStatisticFlags {
    fn extend<T: IntoIterator<Item = QueryPipelineStatisticFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, Self::from(i));
        }
    }
}
impl FromIterator<QueryPipelineStatisticFlagBits> for QueryPipelineStatisticFlags {
    fn from_iter<T: IntoIterator<Item = QueryPipelineStatisticFlagBits>>(iterator: T) -> QueryPipelineStatisticFlags {
        let mut out = Self::empty();
        <Self as Extend<QueryPipelineStatisticFlagBits>>::extend(&mut out, iterator);
        out
    }
}
impl std::fmt::Debug for QueryPipelineStatisticFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(QueryPipelineStatisticFlags);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == QueryPipelineStatisticFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(QueryPipelineStatisticFlags::INPUT_ASSEMBLY_VERTICES) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(INPUT_ASSEMBLY_VERTICES))?;
                    }
                    if self.0.contains(QueryPipelineStatisticFlags::INPUT_ASSEMBLY_PRIMITIVES) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(INPUT_ASSEMBLY_PRIMITIVES))?;
                    }
                    if self.0.contains(QueryPipelineStatisticFlags::VERTEX_SHADER_INVOCATIONS) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(VERTEX_SHADER_INVOCATIONS))?;
                    }
                    if self
                        .0
                        .contains(QueryPipelineStatisticFlags::GEOMETRY_SHADER_INVOCATIONS)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(GEOMETRY_SHADER_INVOCATIONS))?;
                    }
                    if self.0.contains(QueryPipelineStatisticFlags::GEOMETRY_SHADER_PRIMITIVES) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(GEOMETRY_SHADER_PRIMITIVES))?;
                    }
                    if self.0.contains(QueryPipelineStatisticFlags::CLIPPING_INVOCATIONS) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(CLIPPING_INVOCATIONS))?;
                    }
                    if self.0.contains(QueryPipelineStatisticFlags::CLIPPING_PRIMITIVES) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(CLIPPING_PRIMITIVES))?;
                    }
                    if self
                        .0
                        .contains(QueryPipelineStatisticFlags::FRAGMENT_SHADER_INVOCATIONS)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(FRAGMENT_SHADER_INVOCATIONS))?;
                    }
                    if self
                        .0
                        .contains(QueryPipelineStatisticFlags::TESSELLATION_CONTROL_SHADER_PATCHES)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(TESSELLATION_CONTROL_SHADER_PATCHES))?;
                    }
                    if self
                        .0
                        .contains(QueryPipelineStatisticFlags::TESSELLATION_EVALUATION_SHADER_INVOCATIONS)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(TESSELLATION_EVALUATION_SHADER_INVOCATIONS))?;
                    }
                    if self.0.contains(QueryPipelineStatisticFlags::COMPUTE_SHADER_INVOCATIONS) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(COMPUTE_SHADER_INVOCATIONS))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(QueryPipelineStatisticFlags))
            .field(&Flags(*self))
            .finish()
    }
}
#[doc(alias = "VkMemoryMapFlags")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct MemoryMapFlags(u32);
impl MemoryMapFlags {
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
}
# [doc = include_str ! ("../../../doc/VkImageAspectFlagBits.md")]
#[doc(alias = "VkImageAspectFlags")]
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct ImageAspectFlags(u32);
impl ImageAspectFlags {
    #[doc(alias = "VK_IMAGE_ASPECT_COLOR_BIT")]
    pub const COLOR: Self = Self(1);
    #[doc(alias = "VK_IMAGE_ASPECT_DEPTH_BIT")]
    pub const DEPTH: Self = Self(2);
    #[doc(alias = "VK_IMAGE_ASPECT_STENCIL_BIT")]
    pub const STENCIL: Self = Self(4);
    #[doc(alias = "VK_IMAGE_ASPECT_METADATA_BIT")]
    pub const METADATA: Self = Self(8);
    #[doc(alias = "VK_IMAGE_ASPECT_PLANE_0_BIT")]
    pub const PLANE0: Self = Self(16);
    #[doc(alias = "VK_IMAGE_ASPECT_PLANE_1_BIT")]
    pub const PLANE1: Self = Self(32);
    #[doc(alias = "VK_IMAGE_ASPECT_PLANE_2_BIT")]
    pub const PLANE2: Self = Self(64);
    #[doc(alias = "VK_IMAGE_ASPECT_NONE")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const NONE: Self = Self(0);
    #[doc(alias = "VK_IMAGE_ASPECT_MEMORY_PLANE_0_BIT_EXT")]
    #[cfg(feature = "VK_EXT_image_drm_format_modifier")]
    pub const MEMORY_PLANE0_EXT: Self = Self(128);
    #[doc(alias = "VK_IMAGE_ASPECT_MEMORY_PLANE_1_BIT_EXT")]
    #[cfg(feature = "VK_EXT_image_drm_format_modifier")]
    pub const MEMORY_PLANE1_EXT: Self = Self(256);
    #[doc(alias = "VK_IMAGE_ASPECT_MEMORY_PLANE_2_BIT_EXT")]
    #[cfg(feature = "VK_EXT_image_drm_format_modifier")]
    pub const MEMORY_PLANE2_EXT: Self = Self(512);
    #[doc(alias = "VK_IMAGE_ASPECT_MEMORY_PLANE_3_BIT_EXT")]
    #[cfg(feature = "VK_EXT_image_drm_format_modifier")]
    pub const MEMORY_PLANE3_EXT: Self = Self(1024);
    #[doc(alias = "VK_IMAGE_ASPECT_PLANE_0_BIT_KHR")]
    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
    pub const PLANE0_KHR: Self = Self::PLANE0;
    #[doc(alias = "VK_IMAGE_ASPECT_PLANE_1_BIT_KHR")]
    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
    pub const PLANE1_KHR: Self = Self::PLANE1;
    #[doc(alias = "VK_IMAGE_ASPECT_PLANE_2_BIT_KHR")]
    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
    pub const PLANE2_KHR: Self = Self::PLANE2;
    #[doc(alias = "VK_IMAGE_ASPECT_NONE_KHR")]
    #[cfg(feature = "VK_KHR_maintenance4")]
    pub const NONE_KHR: Self = Self::NONE;
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    #[allow(unused_mut)]
    pub const fn all() -> Self {
        let mut all = Self::empty();
        {
            all |= Self::COLOR;
        }
        {
            all |= Self::DEPTH;
        }
        {
            all |= Self::STENCIL;
        }
        {
            all |= Self::METADATA;
        }
        {
            all |= Self::PLANE0;
        }
        {
            all |= Self::PLANE1;
        }
        {
            all |= Self::PLANE2;
        }
        #[cfg(feature = "VULKAN_1_3")]
        {
            all |= Self::NONE;
        }
        #[cfg(feature = "VK_EXT_image_drm_format_modifier")]
        {
            all |= Self::MEMORY_PLANE0_EXT;
        }
        #[cfg(feature = "VK_EXT_image_drm_format_modifier")]
        {
            all |= Self::MEMORY_PLANE1_EXT;
        }
        #[cfg(feature = "VK_EXT_image_drm_format_modifier")]
        {
            all |= Self::MEMORY_PLANE2_EXT;
        }
        #[cfg(feature = "VK_EXT_image_drm_format_modifier")]
        {
            all |= Self::MEMORY_PLANE3_EXT;
        }
        #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
        {
            all |= Self::PLANE0_KHR;
        }
        #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
        {
            all |= Self::PLANE1_KHR;
        }
        #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
        {
            all |= Self::PLANE2_KHR;
        }
        #[cfg(feature = "VK_KHR_maintenance4")]
        {
            all |= Self::NONE_KHR;
        }
        all
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl const std::ops::BitOr for ImageAspectFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl const std::ops::BitOrAssign for ImageAspectFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl const std::ops::BitXor for ImageAspectFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl const std::ops::BitXorAssign for ImageAspectFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl const std::ops::BitAnd for ImageAspectFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl const std::ops::BitAndAssign for ImageAspectFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl const std::ops::Sub for ImageAspectFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl const std::ops::SubAssign for ImageAspectFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl const std::ops::Not for ImageAspectFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl Extend<ImageAspectFlags> for ImageAspectFlags {
    fn extend<T: IntoIterator<Item = ImageAspectFlags>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, i);
        }
    }
}
impl FromIterator<ImageAspectFlags> for ImageAspectFlags {
    fn from_iter<T: IntoIterator<Item = ImageAspectFlags>>(iterator: T) -> ImageAspectFlags {
        let mut out = Self::empty();
        <Self as Extend<ImageAspectFlags>>::extend(&mut out, iterator);
        out
    }
}
impl const Default for ImageAspectFlags {
    fn default() -> Self {
        Self::empty()
    }
}
impl const From<ImageAspectFlagBits> for ImageAspectFlags {
    fn from(bit: ImageAspectFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(bit.bits()) }
    }
}
impl Extend<ImageAspectFlagBits> for ImageAspectFlags {
    fn extend<T: IntoIterator<Item = ImageAspectFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, Self::from(i));
        }
    }
}
impl FromIterator<ImageAspectFlagBits> for ImageAspectFlags {
    fn from_iter<T: IntoIterator<Item = ImageAspectFlagBits>>(iterator: T) -> ImageAspectFlags {
        let mut out = Self::empty();
        <Self as Extend<ImageAspectFlagBits>>::extend(&mut out, iterator);
        out
    }
}
impl std::fmt::Debug for ImageAspectFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(ImageAspectFlags);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == ImageAspectFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(ImageAspectFlags::COLOR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(COLOR))?;
                    }
                    if self.0.contains(ImageAspectFlags::DEPTH) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(DEPTH))?;
                    }
                    if self.0.contains(ImageAspectFlags::STENCIL) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(STENCIL))?;
                    }
                    if self.0.contains(ImageAspectFlags::METADATA) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(METADATA))?;
                    }
                    if self.0.contains(ImageAspectFlags::PLANE0) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(PLANE0))?;
                    }
                    if self.0.contains(ImageAspectFlags::PLANE1) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(PLANE1))?;
                    }
                    if self.0.contains(ImageAspectFlags::PLANE2) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(PLANE2))?;
                    }
                    #[cfg(feature = "VULKAN_1_3")]
                    if self.0.contains(ImageAspectFlags::NONE) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(NONE))?;
                    }
                    #[cfg(feature = "VK_EXT_image_drm_format_modifier")]
                    if self.0.contains(ImageAspectFlags::MEMORY_PLANE0_EXT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(MEMORY_PLANE0_EXT))?;
                    }
                    #[cfg(feature = "VK_EXT_image_drm_format_modifier")]
                    if self.0.contains(ImageAspectFlags::MEMORY_PLANE1_EXT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(MEMORY_PLANE1_EXT))?;
                    }
                    #[cfg(feature = "VK_EXT_image_drm_format_modifier")]
                    if self.0.contains(ImageAspectFlags::MEMORY_PLANE2_EXT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(MEMORY_PLANE2_EXT))?;
                    }
                    #[cfg(feature = "VK_EXT_image_drm_format_modifier")]
                    if self.0.contains(ImageAspectFlags::MEMORY_PLANE3_EXT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(MEMORY_PLANE3_EXT))?;
                    }
                    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
                    if self.0.contains(ImageAspectFlags::PLANE0_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(PLANE0_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
                    if self.0.contains(ImageAspectFlags::PLANE1_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(PLANE1_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
                    if self.0.contains(ImageAspectFlags::PLANE2_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(PLANE2_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_maintenance4")]
                    if self.0.contains(ImageAspectFlags::NONE_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(NONE_KHR))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(ImageAspectFlags))
            .field(&Flags(*self))
            .finish()
    }
}
# [doc = include_str ! ("../../../doc/VkSparseMemoryBindFlagBits.md")]
#[doc(alias = "VkSparseMemoryBindFlags")]
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct SparseMemoryBindFlags(u32);
impl SparseMemoryBindFlags {
    #[doc(alias = "VK_SPARSE_MEMORY_BIND_METADATA_BIT")]
    pub const METADATA: Self = Self(1);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    #[allow(unused_mut)]
    pub const fn all() -> Self {
        let mut all = Self::empty();
        {
            all |= Self::METADATA;
        }
        all
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl const std::ops::BitOr for SparseMemoryBindFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl const std::ops::BitOrAssign for SparseMemoryBindFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl const std::ops::BitXor for SparseMemoryBindFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl const std::ops::BitXorAssign for SparseMemoryBindFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl const std::ops::BitAnd for SparseMemoryBindFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl const std::ops::BitAndAssign for SparseMemoryBindFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl const std::ops::Sub for SparseMemoryBindFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl const std::ops::SubAssign for SparseMemoryBindFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl const std::ops::Not for SparseMemoryBindFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl Extend<SparseMemoryBindFlags> for SparseMemoryBindFlags {
    fn extend<T: IntoIterator<Item = SparseMemoryBindFlags>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, i);
        }
    }
}
impl FromIterator<SparseMemoryBindFlags> for SparseMemoryBindFlags {
    fn from_iter<T: IntoIterator<Item = SparseMemoryBindFlags>>(iterator: T) -> SparseMemoryBindFlags {
        let mut out = Self::empty();
        <Self as Extend<SparseMemoryBindFlags>>::extend(&mut out, iterator);
        out
    }
}
impl const Default for SparseMemoryBindFlags {
    fn default() -> Self {
        Self::empty()
    }
}
impl const From<SparseMemoryBindFlagBits> for SparseMemoryBindFlags {
    fn from(bit: SparseMemoryBindFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(bit.bits()) }
    }
}
impl Extend<SparseMemoryBindFlagBits> for SparseMemoryBindFlags {
    fn extend<T: IntoIterator<Item = SparseMemoryBindFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, Self::from(i));
        }
    }
}
impl FromIterator<SparseMemoryBindFlagBits> for SparseMemoryBindFlags {
    fn from_iter<T: IntoIterator<Item = SparseMemoryBindFlagBits>>(iterator: T) -> SparseMemoryBindFlags {
        let mut out = Self::empty();
        <Self as Extend<SparseMemoryBindFlagBits>>::extend(&mut out, iterator);
        out
    }
}
impl std::fmt::Debug for SparseMemoryBindFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(SparseMemoryBindFlags);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == SparseMemoryBindFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(SparseMemoryBindFlags::METADATA) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(METADATA))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(SparseMemoryBindFlags))
            .field(&Flags(*self))
            .finish()
    }
}
# [doc = include_str ! ("../../../doc/VkSparseImageFormatFlagBits.md")]
#[doc(alias = "VkSparseImageFormatFlags")]
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct SparseImageFormatFlags(u32);
impl SparseImageFormatFlags {
    #[doc(alias = "VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT")]
    pub const SINGLE_MIPTAIL: Self = Self(1);
    #[doc(alias = "VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT")]
    pub const ALIGNED_MIP_SIZE: Self = Self(2);
    #[doc(alias = "VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT")]
    pub const NONSTANDARD_BLOCK_SIZE: Self = Self(4);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    #[allow(unused_mut)]
    pub const fn all() -> Self {
        let mut all = Self::empty();
        {
            all |= Self::SINGLE_MIPTAIL;
        }
        {
            all |= Self::ALIGNED_MIP_SIZE;
        }
        {
            all |= Self::NONSTANDARD_BLOCK_SIZE;
        }
        all
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl const std::ops::BitOr for SparseImageFormatFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl const std::ops::BitOrAssign for SparseImageFormatFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl const std::ops::BitXor for SparseImageFormatFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl const std::ops::BitXorAssign for SparseImageFormatFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl const std::ops::BitAnd for SparseImageFormatFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl const std::ops::BitAndAssign for SparseImageFormatFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl const std::ops::Sub for SparseImageFormatFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl const std::ops::SubAssign for SparseImageFormatFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl const std::ops::Not for SparseImageFormatFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl Extend<SparseImageFormatFlags> for SparseImageFormatFlags {
    fn extend<T: IntoIterator<Item = SparseImageFormatFlags>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, i);
        }
    }
}
impl FromIterator<SparseImageFormatFlags> for SparseImageFormatFlags {
    fn from_iter<T: IntoIterator<Item = SparseImageFormatFlags>>(iterator: T) -> SparseImageFormatFlags {
        let mut out = Self::empty();
        <Self as Extend<SparseImageFormatFlags>>::extend(&mut out, iterator);
        out
    }
}
impl const Default for SparseImageFormatFlags {
    fn default() -> Self {
        Self::empty()
    }
}
impl const From<SparseImageFormatFlagBits> for SparseImageFormatFlags {
    fn from(bit: SparseImageFormatFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(bit.bits()) }
    }
}
impl Extend<SparseImageFormatFlagBits> for SparseImageFormatFlags {
    fn extend<T: IntoIterator<Item = SparseImageFormatFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, Self::from(i));
        }
    }
}
impl FromIterator<SparseImageFormatFlagBits> for SparseImageFormatFlags {
    fn from_iter<T: IntoIterator<Item = SparseImageFormatFlagBits>>(iterator: T) -> SparseImageFormatFlags {
        let mut out = Self::empty();
        <Self as Extend<SparseImageFormatFlagBits>>::extend(&mut out, iterator);
        out
    }
}
impl std::fmt::Debug for SparseImageFormatFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(SparseImageFormatFlags);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == SparseImageFormatFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(SparseImageFormatFlags::SINGLE_MIPTAIL) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(SINGLE_MIPTAIL))?;
                    }
                    if self.0.contains(SparseImageFormatFlags::ALIGNED_MIP_SIZE) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(ALIGNED_MIP_SIZE))?;
                    }
                    if self.0.contains(SparseImageFormatFlags::NONSTANDARD_BLOCK_SIZE) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(NONSTANDARD_BLOCK_SIZE))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(SparseImageFormatFlags))
            .field(&Flags(*self))
            .finish()
    }
}
# [doc = include_str ! ("../../../doc/VkSubpassDescriptionFlagBits.md")]
#[doc(alias = "VkSubpassDescriptionFlags")]
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct SubpassDescriptionFlags(u32);
impl SubpassDescriptionFlags {
    #[doc(alias = "VK_SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX")]
    #[cfg(feature = "VK_NVX_multiview_per_view_attributes")]
    pub const PER_VIEW_ATTRIBUTES_NVX: Self = Self(1);
    #[doc(alias = "VK_SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX")]
    #[cfg(feature = "VK_NVX_multiview_per_view_attributes")]
    pub const PER_VIEW_POSITION_X_ONLY_NVX: Self = Self(2);
    #[doc(alias = "VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_COLOR_ACCESS_BIT_ARM")]
    #[cfg(feature = "VK_ARM_rasterization_order_attachment_access")]
    pub const RASTERIZATION_ORDER_ATTACHMENT_COLOR_ACCESS_ARM: Self = Self(16);
    #[doc(alias = "VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_ARM")]
    #[cfg(feature = "VK_ARM_rasterization_order_attachment_access")]
    pub const RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_ARM: Self = Self(32);
    #[doc(alias = "VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_ARM")]
    #[cfg(feature = "VK_ARM_rasterization_order_attachment_access")]
    pub const RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_ARM: Self = Self(64);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    #[allow(unused_mut)]
    pub const fn all() -> Self {
        let mut all = Self::empty();
        #[cfg(feature = "VK_NVX_multiview_per_view_attributes")]
        {
            all |= Self::PER_VIEW_ATTRIBUTES_NVX;
        }
        #[cfg(feature = "VK_NVX_multiview_per_view_attributes")]
        {
            all |= Self::PER_VIEW_POSITION_X_ONLY_NVX;
        }
        #[cfg(feature = "VK_ARM_rasterization_order_attachment_access")]
        {
            all |= Self::RASTERIZATION_ORDER_ATTACHMENT_COLOR_ACCESS_ARM;
        }
        #[cfg(feature = "VK_ARM_rasterization_order_attachment_access")]
        {
            all |= Self::RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_ARM;
        }
        #[cfg(feature = "VK_ARM_rasterization_order_attachment_access")]
        {
            all |= Self::RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_ARM;
        }
        all
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl const std::ops::BitOr for SubpassDescriptionFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl const std::ops::BitOrAssign for SubpassDescriptionFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl const std::ops::BitXor for SubpassDescriptionFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl const std::ops::BitXorAssign for SubpassDescriptionFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl const std::ops::BitAnd for SubpassDescriptionFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl const std::ops::BitAndAssign for SubpassDescriptionFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl const std::ops::Sub for SubpassDescriptionFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl const std::ops::SubAssign for SubpassDescriptionFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl const std::ops::Not for SubpassDescriptionFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl Extend<SubpassDescriptionFlags> for SubpassDescriptionFlags {
    fn extend<T: IntoIterator<Item = SubpassDescriptionFlags>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, i);
        }
    }
}
impl FromIterator<SubpassDescriptionFlags> for SubpassDescriptionFlags {
    fn from_iter<T: IntoIterator<Item = SubpassDescriptionFlags>>(iterator: T) -> SubpassDescriptionFlags {
        let mut out = Self::empty();
        <Self as Extend<SubpassDescriptionFlags>>::extend(&mut out, iterator);
        out
    }
}
impl const Default for SubpassDescriptionFlags {
    fn default() -> Self {
        Self::empty()
    }
}
impl const From<SubpassDescriptionFlagBits> for SubpassDescriptionFlags {
    fn from(bit: SubpassDescriptionFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(bit.bits()) }
    }
}
impl Extend<SubpassDescriptionFlagBits> for SubpassDescriptionFlags {
    fn extend<T: IntoIterator<Item = SubpassDescriptionFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, Self::from(i));
        }
    }
}
impl FromIterator<SubpassDescriptionFlagBits> for SubpassDescriptionFlags {
    fn from_iter<T: IntoIterator<Item = SubpassDescriptionFlagBits>>(iterator: T) -> SubpassDescriptionFlags {
        let mut out = Self::empty();
        <Self as Extend<SubpassDescriptionFlagBits>>::extend(&mut out, iterator);
        out
    }
}
impl std::fmt::Debug for SubpassDescriptionFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(SubpassDescriptionFlags);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == SubpassDescriptionFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    #[cfg(feature = "VK_NVX_multiview_per_view_attributes")]
                    if self.0.contains(SubpassDescriptionFlags::PER_VIEW_ATTRIBUTES_NVX) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(PER_VIEW_ATTRIBUTES_NVX))?;
                    }
                    #[cfg(feature = "VK_NVX_multiview_per_view_attributes")]
                    if self.0.contains(SubpassDescriptionFlags::PER_VIEW_POSITION_X_ONLY_NVX) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(PER_VIEW_POSITION_X_ONLY_NVX))?;
                    }
                    #[cfg(feature = "VK_ARM_rasterization_order_attachment_access")]
                    if self
                        .0
                        .contains(SubpassDescriptionFlags::RASTERIZATION_ORDER_ATTACHMENT_COLOR_ACCESS_ARM)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(RASTERIZATION_ORDER_ATTACHMENT_COLOR_ACCESS_ARM))?;
                    }
                    #[cfg(feature = "VK_ARM_rasterization_order_attachment_access")]
                    if self
                        .0
                        .contains(SubpassDescriptionFlags::RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_ARM)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_ARM))?;
                    }
                    #[cfg(feature = "VK_ARM_rasterization_order_attachment_access")]
                    if self
                        .0
                        .contains(SubpassDescriptionFlags::RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_ARM)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_ARM))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(SubpassDescriptionFlags))
            .field(&Flags(*self))
            .finish()
    }
}
# [doc = include_str ! ("../../../doc/VkPipelineStageFlagBits.md")]
#[doc(alias = "VkPipelineStageFlags")]
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct PipelineStageFlags(u32);
impl PipelineStageFlags {
    #[doc(alias = "VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT")]
    pub const TOP_OF_PIPE: Self = Self(1);
    #[doc(alias = "VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT")]
    pub const DRAW_INDIRECT: Self = Self(2);
    #[doc(alias = "VK_PIPELINE_STAGE_VERTEX_INPUT_BIT")]
    pub const VERTEX_INPUT: Self = Self(4);
    #[doc(alias = "VK_PIPELINE_STAGE_VERTEX_SHADER_BIT")]
    pub const VERTEX_SHADER: Self = Self(8);
    #[doc(alias = "VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT")]
    pub const TESSELLATION_CONTROL_SHADER: Self = Self(16);
    #[doc(alias = "VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT")]
    pub const TESSELLATION_EVALUATION_SHADER: Self = Self(32);
    #[doc(alias = "VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT")]
    pub const GEOMETRY_SHADER: Self = Self(64);
    #[doc(alias = "VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT")]
    pub const FRAGMENT_SHADER: Self = Self(128);
    #[doc(alias = "VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT")]
    pub const EARLY_FRAGMENT_TESTS: Self = Self(256);
    #[doc(alias = "VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT")]
    pub const LATE_FRAGMENT_TESTS: Self = Self(512);
    #[doc(alias = "VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT")]
    pub const COLOR_ATTACHMENT_OUTPUT: Self = Self(1024);
    #[doc(alias = "VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT")]
    pub const COMPUTE_SHADER: Self = Self(2048);
    #[doc(alias = "VK_PIPELINE_STAGE_TRANSFER_BIT")]
    pub const TRANSFER: Self = Self(4096);
    #[doc(alias = "VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT")]
    pub const BOTTOM_OF_PIPE: Self = Self(8192);
    #[doc(alias = "VK_PIPELINE_STAGE_HOST_BIT")]
    pub const HOST: Self = Self(16384);
    #[doc(alias = "VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT")]
    pub const ALL_GRAPHICS: Self = Self(32768);
    #[doc(alias = "VK_PIPELINE_STAGE_ALL_COMMANDS_BIT")]
    pub const ALL_COMMANDS: Self = Self(65536);
    #[doc(alias = "VK_PIPELINE_STAGE_NONE")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const NONE: Self = Self(0);
    #[doc(alias = "VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT")]
    #[cfg(feature = "VK_EXT_transform_feedback")]
    pub const TRANSFORM_FEEDBACK_EXT: Self = Self(16777216);
    #[doc(alias = "VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT")]
    #[cfg(feature = "VK_EXT_conditional_rendering")]
    pub const CONDITIONAL_RENDERING_EXT: Self = Self(262144);
    #[doc(alias = "VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR")]
    #[cfg(feature = "VK_KHR_acceleration_structure")]
    pub const ACCELERATION_STRUCTURE_BUILD_KHR: Self = Self(33554432);
    #[doc(alias = "VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_KHR")]
    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
    pub const RAY_TRACING_SHADER_KHR: Self = Self(2097152);
    #[doc(alias = "VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV")]
    #[cfg(feature = "VK_NV_mesh_shader")]
    pub const TASK_SHADER_NV: Self = Self(524288);
    #[doc(alias = "VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV")]
    #[cfg(feature = "VK_NV_mesh_shader")]
    pub const MESH_SHADER_NV: Self = Self(1048576);
    #[doc(alias = "VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT")]
    #[cfg(feature = "VK_EXT_fragment_density_map")]
    pub const FRAGMENT_DENSITY_PROCESS_EXT: Self = Self(8388608);
    #[doc(alias = "VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR")]
    #[cfg(feature = "VK_KHR_fragment_shading_rate")]
    pub const FRAGMENT_SHADING_RATE_ATTACHMENT_KHR: Self = Self(4194304);
    #[doc(alias = "VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_NV")]
    #[cfg(feature = "VK_NV_device_generated_commands")]
    pub const COMMAND_PREPROCESS_NV: Self = Self(131072);
    #[doc(alias = "VK_PIPELINE_STAGE_SHADING_RATE_IMAGE_BIT_NV")]
    #[cfg(feature = "VK_NV_shading_rate_image")]
    pub const SHADING_RATE_IMAGE_NV: Self = Self::FRAGMENT_SHADING_RATE_ATTACHMENT_KHR;
    #[doc(alias = "VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_NV")]
    #[cfg(feature = "VK_NV_ray_tracing")]
    pub const RAY_TRACING_SHADER_NV: Self = Self::RAY_TRACING_SHADER_KHR;
    #[doc(alias = "VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_NV")]
    #[cfg(feature = "VK_NV_ray_tracing")]
    pub const ACCELERATION_STRUCTURE_BUILD_NV: Self = Self::ACCELERATION_STRUCTURE_BUILD_KHR;
    #[doc(alias = "VK_PIPELINE_STAGE_NONE_KHR")]
    #[cfg(feature = "VK_KHR_synchronization2")]
    pub const NONE_KHR: Self = Self::NONE;
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    #[allow(unused_mut)]
    pub const fn all() -> Self {
        let mut all = Self::empty();
        {
            all |= Self::TOP_OF_PIPE;
        }
        {
            all |= Self::DRAW_INDIRECT;
        }
        {
            all |= Self::VERTEX_INPUT;
        }
        {
            all |= Self::VERTEX_SHADER;
        }
        {
            all |= Self::TESSELLATION_CONTROL_SHADER;
        }
        {
            all |= Self::TESSELLATION_EVALUATION_SHADER;
        }
        {
            all |= Self::GEOMETRY_SHADER;
        }
        {
            all |= Self::FRAGMENT_SHADER;
        }
        {
            all |= Self::EARLY_FRAGMENT_TESTS;
        }
        {
            all |= Self::LATE_FRAGMENT_TESTS;
        }
        {
            all |= Self::COLOR_ATTACHMENT_OUTPUT;
        }
        {
            all |= Self::COMPUTE_SHADER;
        }
        {
            all |= Self::TRANSFER;
        }
        {
            all |= Self::BOTTOM_OF_PIPE;
        }
        {
            all |= Self::HOST;
        }
        {
            all |= Self::ALL_GRAPHICS;
        }
        {
            all |= Self::ALL_COMMANDS;
        }
        #[cfg(feature = "VULKAN_1_3")]
        {
            all |= Self::NONE;
        }
        #[cfg(feature = "VK_EXT_transform_feedback")]
        {
            all |= Self::TRANSFORM_FEEDBACK_EXT;
        }
        #[cfg(feature = "VK_EXT_conditional_rendering")]
        {
            all |= Self::CONDITIONAL_RENDERING_EXT;
        }
        #[cfg(feature = "VK_KHR_acceleration_structure")]
        {
            all |= Self::ACCELERATION_STRUCTURE_BUILD_KHR;
        }
        #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
        {
            all |= Self::RAY_TRACING_SHADER_KHR;
        }
        #[cfg(feature = "VK_NV_mesh_shader")]
        {
            all |= Self::TASK_SHADER_NV;
        }
        #[cfg(feature = "VK_NV_mesh_shader")]
        {
            all |= Self::MESH_SHADER_NV;
        }
        #[cfg(feature = "VK_EXT_fragment_density_map")]
        {
            all |= Self::FRAGMENT_DENSITY_PROCESS_EXT;
        }
        #[cfg(feature = "VK_KHR_fragment_shading_rate")]
        {
            all |= Self::FRAGMENT_SHADING_RATE_ATTACHMENT_KHR;
        }
        #[cfg(feature = "VK_NV_device_generated_commands")]
        {
            all |= Self::COMMAND_PREPROCESS_NV;
        }
        #[cfg(feature = "VK_NV_shading_rate_image")]
        {
            all |= Self::SHADING_RATE_IMAGE_NV;
        }
        #[cfg(feature = "VK_NV_ray_tracing")]
        {
            all |= Self::RAY_TRACING_SHADER_NV;
        }
        #[cfg(feature = "VK_NV_ray_tracing")]
        {
            all |= Self::ACCELERATION_STRUCTURE_BUILD_NV;
        }
        #[cfg(feature = "VK_KHR_synchronization2")]
        {
            all |= Self::NONE_KHR;
        }
        all
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl const std::ops::BitOr for PipelineStageFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl const std::ops::BitOrAssign for PipelineStageFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl const std::ops::BitXor for PipelineStageFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl const std::ops::BitXorAssign for PipelineStageFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl const std::ops::BitAnd for PipelineStageFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl const std::ops::BitAndAssign for PipelineStageFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl const std::ops::Sub for PipelineStageFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl const std::ops::SubAssign for PipelineStageFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl const std::ops::Not for PipelineStageFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl Extend<PipelineStageFlags> for PipelineStageFlags {
    fn extend<T: IntoIterator<Item = PipelineStageFlags>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, i);
        }
    }
}
impl FromIterator<PipelineStageFlags> for PipelineStageFlags {
    fn from_iter<T: IntoIterator<Item = PipelineStageFlags>>(iterator: T) -> PipelineStageFlags {
        let mut out = Self::empty();
        <Self as Extend<PipelineStageFlags>>::extend(&mut out, iterator);
        out
    }
}
impl const Default for PipelineStageFlags {
    fn default() -> Self {
        Self::empty()
    }
}
impl const From<PipelineStageFlagBits> for PipelineStageFlags {
    fn from(bit: PipelineStageFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(bit.bits()) }
    }
}
impl Extend<PipelineStageFlagBits> for PipelineStageFlags {
    fn extend<T: IntoIterator<Item = PipelineStageFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, Self::from(i));
        }
    }
}
impl FromIterator<PipelineStageFlagBits> for PipelineStageFlags {
    fn from_iter<T: IntoIterator<Item = PipelineStageFlagBits>>(iterator: T) -> PipelineStageFlags {
        let mut out = Self::empty();
        <Self as Extend<PipelineStageFlagBits>>::extend(&mut out, iterator);
        out
    }
}
impl std::fmt::Debug for PipelineStageFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(PipelineStageFlags);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == PipelineStageFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(PipelineStageFlags::TOP_OF_PIPE) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(TOP_OF_PIPE))?;
                    }
                    if self.0.contains(PipelineStageFlags::DRAW_INDIRECT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(DRAW_INDIRECT))?;
                    }
                    if self.0.contains(PipelineStageFlags::VERTEX_INPUT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(VERTEX_INPUT))?;
                    }
                    if self.0.contains(PipelineStageFlags::VERTEX_SHADER) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(VERTEX_SHADER))?;
                    }
                    if self.0.contains(PipelineStageFlags::TESSELLATION_CONTROL_SHADER) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(TESSELLATION_CONTROL_SHADER))?;
                    }
                    if self.0.contains(PipelineStageFlags::TESSELLATION_EVALUATION_SHADER) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(TESSELLATION_EVALUATION_SHADER))?;
                    }
                    if self.0.contains(PipelineStageFlags::GEOMETRY_SHADER) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(GEOMETRY_SHADER))?;
                    }
                    if self.0.contains(PipelineStageFlags::FRAGMENT_SHADER) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(FRAGMENT_SHADER))?;
                    }
                    if self.0.contains(PipelineStageFlags::EARLY_FRAGMENT_TESTS) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(EARLY_FRAGMENT_TESTS))?;
                    }
                    if self.0.contains(PipelineStageFlags::LATE_FRAGMENT_TESTS) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(LATE_FRAGMENT_TESTS))?;
                    }
                    if self.0.contains(PipelineStageFlags::COLOR_ATTACHMENT_OUTPUT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(COLOR_ATTACHMENT_OUTPUT))?;
                    }
                    if self.0.contains(PipelineStageFlags::COMPUTE_SHADER) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(COMPUTE_SHADER))?;
                    }
                    if self.0.contains(PipelineStageFlags::TRANSFER) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(TRANSFER))?;
                    }
                    if self.0.contains(PipelineStageFlags::BOTTOM_OF_PIPE) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(BOTTOM_OF_PIPE))?;
                    }
                    if self.0.contains(PipelineStageFlags::HOST) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(HOST))?;
                    }
                    if self.0.contains(PipelineStageFlags::ALL_GRAPHICS) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(ALL_GRAPHICS))?;
                    }
                    if self.0.contains(PipelineStageFlags::ALL_COMMANDS) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(ALL_COMMANDS))?;
                    }
                    #[cfg(feature = "VULKAN_1_3")]
                    if self.0.contains(PipelineStageFlags::NONE) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(NONE))?;
                    }
                    #[cfg(feature = "VK_EXT_transform_feedback")]
                    if self.0.contains(PipelineStageFlags::TRANSFORM_FEEDBACK_EXT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(TRANSFORM_FEEDBACK_EXT))?;
                    }
                    #[cfg(feature = "VK_EXT_conditional_rendering")]
                    if self.0.contains(PipelineStageFlags::CONDITIONAL_RENDERING_EXT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(CONDITIONAL_RENDERING_EXT))?;
                    }
                    #[cfg(feature = "VK_KHR_acceleration_structure")]
                    if self.0.contains(PipelineStageFlags::ACCELERATION_STRUCTURE_BUILD_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(ACCELERATION_STRUCTURE_BUILD_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
                    if self.0.contains(PipelineStageFlags::RAY_TRACING_SHADER_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(RAY_TRACING_SHADER_KHR))?;
                    }
                    #[cfg(feature = "VK_NV_mesh_shader")]
                    if self.0.contains(PipelineStageFlags::TASK_SHADER_NV) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(TASK_SHADER_NV))?;
                    }
                    #[cfg(feature = "VK_NV_mesh_shader")]
                    if self.0.contains(PipelineStageFlags::MESH_SHADER_NV) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(MESH_SHADER_NV))?;
                    }
                    #[cfg(feature = "VK_EXT_fragment_density_map")]
                    if self.0.contains(PipelineStageFlags::FRAGMENT_DENSITY_PROCESS_EXT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(FRAGMENT_DENSITY_PROCESS_EXT))?;
                    }
                    #[cfg(feature = "VK_KHR_fragment_shading_rate")]
                    if self
                        .0
                        .contains(PipelineStageFlags::FRAGMENT_SHADING_RATE_ATTACHMENT_KHR)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(FRAGMENT_SHADING_RATE_ATTACHMENT_KHR))?;
                    }
                    #[cfg(feature = "VK_NV_device_generated_commands")]
                    if self.0.contains(PipelineStageFlags::COMMAND_PREPROCESS_NV) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(COMMAND_PREPROCESS_NV))?;
                    }
                    #[cfg(feature = "VK_NV_shading_rate_image")]
                    if self.0.contains(PipelineStageFlags::SHADING_RATE_IMAGE_NV) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(SHADING_RATE_IMAGE_NV))?;
                    }
                    #[cfg(feature = "VK_NV_ray_tracing")]
                    if self.0.contains(PipelineStageFlags::RAY_TRACING_SHADER_NV) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(RAY_TRACING_SHADER_NV))?;
                    }
                    #[cfg(feature = "VK_NV_ray_tracing")]
                    if self.0.contains(PipelineStageFlags::ACCELERATION_STRUCTURE_BUILD_NV) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(ACCELERATION_STRUCTURE_BUILD_NV))?;
                    }
                    #[cfg(feature = "VK_KHR_synchronization2")]
                    if self.0.contains(PipelineStageFlags::NONE_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(NONE_KHR))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(PipelineStageFlags))
            .field(&Flags(*self))
            .finish()
    }
}
# [doc = include_str ! ("../../../doc/VkSampleCountFlagBits.md")]
#[doc(alias = "VkSampleCountFlags")]
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct SampleCountFlags(u32);
impl SampleCountFlags {
    #[doc(alias = "VK_SAMPLE_COUNT_1_BIT")]
    pub const N1: Self = Self(1);
    #[doc(alias = "VK_SAMPLE_COUNT_2_BIT")]
    pub const N2: Self = Self(2);
    #[doc(alias = "VK_SAMPLE_COUNT_4_BIT")]
    pub const N4: Self = Self(4);
    #[doc(alias = "VK_SAMPLE_COUNT_8_BIT")]
    pub const N8: Self = Self(8);
    #[doc(alias = "VK_SAMPLE_COUNT_16_BIT")]
    pub const N16: Self = Self(16);
    #[doc(alias = "VK_SAMPLE_COUNT_32_BIT")]
    pub const N32: Self = Self(32);
    #[doc(alias = "VK_SAMPLE_COUNT_64_BIT")]
    pub const N64: Self = Self(64);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    #[allow(unused_mut)]
    pub const fn all() -> Self {
        let mut all = Self::empty();
        {
            all |= Self::N1;
        }
        {
            all |= Self::N2;
        }
        {
            all |= Self::N4;
        }
        {
            all |= Self::N8;
        }
        {
            all |= Self::N16;
        }
        {
            all |= Self::N32;
        }
        {
            all |= Self::N64;
        }
        all
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl const std::ops::BitOr for SampleCountFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl const std::ops::BitOrAssign for SampleCountFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl const std::ops::BitXor for SampleCountFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl const std::ops::BitXorAssign for SampleCountFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl const std::ops::BitAnd for SampleCountFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl const std::ops::BitAndAssign for SampleCountFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl const std::ops::Sub for SampleCountFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl const std::ops::SubAssign for SampleCountFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl const std::ops::Not for SampleCountFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl Extend<SampleCountFlags> for SampleCountFlags {
    fn extend<T: IntoIterator<Item = SampleCountFlags>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, i);
        }
    }
}
impl FromIterator<SampleCountFlags> for SampleCountFlags {
    fn from_iter<T: IntoIterator<Item = SampleCountFlags>>(iterator: T) -> SampleCountFlags {
        let mut out = Self::empty();
        <Self as Extend<SampleCountFlags>>::extend(&mut out, iterator);
        out
    }
}
impl const Default for SampleCountFlags {
    fn default() -> Self {
        Self::empty()
    }
}
impl const From<SampleCountFlagBits> for SampleCountFlags {
    fn from(bit: SampleCountFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(bit.bits()) }
    }
}
impl Extend<SampleCountFlagBits> for SampleCountFlags {
    fn extend<T: IntoIterator<Item = SampleCountFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, Self::from(i));
        }
    }
}
impl FromIterator<SampleCountFlagBits> for SampleCountFlags {
    fn from_iter<T: IntoIterator<Item = SampleCountFlagBits>>(iterator: T) -> SampleCountFlags {
        let mut out = Self::empty();
        <Self as Extend<SampleCountFlagBits>>::extend(&mut out, iterator);
        out
    }
}
impl std::fmt::Debug for SampleCountFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(SampleCountFlags);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == SampleCountFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(SampleCountFlags::N1) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(N1))?;
                    }
                    if self.0.contains(SampleCountFlags::N2) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(N2))?;
                    }
                    if self.0.contains(SampleCountFlags::N4) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(N4))?;
                    }
                    if self.0.contains(SampleCountFlags::N8) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(N8))?;
                    }
                    if self.0.contains(SampleCountFlags::N16) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(N16))?;
                    }
                    if self.0.contains(SampleCountFlags::N32) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(N32))?;
                    }
                    if self.0.contains(SampleCountFlags::N64) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(N64))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(SampleCountFlags))
            .field(&Flags(*self))
            .finish()
    }
}
# [doc = include_str ! ("../../../doc/VkAttachmentDescriptionFlagBits.md")]
#[doc(alias = "VkAttachmentDescriptionFlags")]
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct AttachmentDescriptionFlags(u32);
impl AttachmentDescriptionFlags {
    #[doc(alias = "VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT")]
    pub const MAY_ALIAS: Self = Self(1);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    #[allow(unused_mut)]
    pub const fn all() -> Self {
        let mut all = Self::empty();
        {
            all |= Self::MAY_ALIAS;
        }
        all
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl const std::ops::BitOr for AttachmentDescriptionFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl const std::ops::BitOrAssign for AttachmentDescriptionFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl const std::ops::BitXor for AttachmentDescriptionFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl const std::ops::BitXorAssign for AttachmentDescriptionFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl const std::ops::BitAnd for AttachmentDescriptionFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl const std::ops::BitAndAssign for AttachmentDescriptionFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl const std::ops::Sub for AttachmentDescriptionFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl const std::ops::SubAssign for AttachmentDescriptionFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl const std::ops::Not for AttachmentDescriptionFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl Extend<AttachmentDescriptionFlags> for AttachmentDescriptionFlags {
    fn extend<T: IntoIterator<Item = AttachmentDescriptionFlags>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, i);
        }
    }
}
impl FromIterator<AttachmentDescriptionFlags> for AttachmentDescriptionFlags {
    fn from_iter<T: IntoIterator<Item = AttachmentDescriptionFlags>>(iterator: T) -> AttachmentDescriptionFlags {
        let mut out = Self::empty();
        <Self as Extend<AttachmentDescriptionFlags>>::extend(&mut out, iterator);
        out
    }
}
impl const Default for AttachmentDescriptionFlags {
    fn default() -> Self {
        Self::empty()
    }
}
impl const From<AttachmentDescriptionFlagBits> for AttachmentDescriptionFlags {
    fn from(bit: AttachmentDescriptionFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(bit.bits()) }
    }
}
impl Extend<AttachmentDescriptionFlagBits> for AttachmentDescriptionFlags {
    fn extend<T: IntoIterator<Item = AttachmentDescriptionFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, Self::from(i));
        }
    }
}
impl FromIterator<AttachmentDescriptionFlagBits> for AttachmentDescriptionFlags {
    fn from_iter<T: IntoIterator<Item = AttachmentDescriptionFlagBits>>(iterator: T) -> AttachmentDescriptionFlags {
        let mut out = Self::empty();
        <Self as Extend<AttachmentDescriptionFlagBits>>::extend(&mut out, iterator);
        out
    }
}
impl std::fmt::Debug for AttachmentDescriptionFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(AttachmentDescriptionFlags);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == AttachmentDescriptionFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(AttachmentDescriptionFlags::MAY_ALIAS) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(MAY_ALIAS))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(AttachmentDescriptionFlags))
            .field(&Flags(*self))
            .finish()
    }
}
# [doc = include_str ! ("../../../doc/VkStencilFaceFlagBits.md")]
#[doc(alias = "VkStencilFaceFlags")]
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct StencilFaceFlags(u32);
impl StencilFaceFlags {
    #[doc(alias = "VK_STENCIL_FACE_FRONT_BIT")]
    pub const FRONT: Self = Self(1);
    #[doc(alias = "VK_STENCIL_FACE_BACK_BIT")]
    pub const BACK: Self = Self(2);
    #[doc(alias = "VK_STENCIL_FACE_FRONT_AND_BACK")]
    pub const FRONT_AND_BACK: Self = Self(3);
    #[doc(alias = "VK_STENCIL_FRONT_AND_BACK")]
    pub const STENCIL_FRONT_AND_BACK: Self = Self::FRONT_AND_BACK;
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    #[allow(unused_mut)]
    pub const fn all() -> Self {
        let mut all = Self::empty();
        {
            all |= Self::FRONT;
        }
        {
            all |= Self::BACK;
        }
        {
            all |= Self::FRONT_AND_BACK;
        }
        {
            all |= Self::STENCIL_FRONT_AND_BACK;
        }
        all
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl const std::ops::BitOr for StencilFaceFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl const std::ops::BitOrAssign for StencilFaceFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl const std::ops::BitXor for StencilFaceFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl const std::ops::BitXorAssign for StencilFaceFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl const std::ops::BitAnd for StencilFaceFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl const std::ops::BitAndAssign for StencilFaceFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl const std::ops::Sub for StencilFaceFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl const std::ops::SubAssign for StencilFaceFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl const std::ops::Not for StencilFaceFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl Extend<StencilFaceFlags> for StencilFaceFlags {
    fn extend<T: IntoIterator<Item = StencilFaceFlags>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, i);
        }
    }
}
impl FromIterator<StencilFaceFlags> for StencilFaceFlags {
    fn from_iter<T: IntoIterator<Item = StencilFaceFlags>>(iterator: T) -> StencilFaceFlags {
        let mut out = Self::empty();
        <Self as Extend<StencilFaceFlags>>::extend(&mut out, iterator);
        out
    }
}
impl const Default for StencilFaceFlags {
    fn default() -> Self {
        Self::empty()
    }
}
impl const From<StencilFaceFlagBits> for StencilFaceFlags {
    fn from(bit: StencilFaceFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(bit.bits()) }
    }
}
impl Extend<StencilFaceFlagBits> for StencilFaceFlags {
    fn extend<T: IntoIterator<Item = StencilFaceFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, Self::from(i));
        }
    }
}
impl FromIterator<StencilFaceFlagBits> for StencilFaceFlags {
    fn from_iter<T: IntoIterator<Item = StencilFaceFlagBits>>(iterator: T) -> StencilFaceFlags {
        let mut out = Self::empty();
        <Self as Extend<StencilFaceFlagBits>>::extend(&mut out, iterator);
        out
    }
}
impl std::fmt::Debug for StencilFaceFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(StencilFaceFlags);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == StencilFaceFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(StencilFaceFlags::FRONT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(FRONT))?;
                    }
                    if self.0.contains(StencilFaceFlags::BACK) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(BACK))?;
                    }
                    if self.0.contains(StencilFaceFlags::FRONT_AND_BACK) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(FRONT_AND_BACK))?;
                    }
                    if self.0.contains(StencilFaceFlags::STENCIL_FRONT_AND_BACK) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(STENCIL_FRONT_AND_BACK))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(StencilFaceFlags))
            .field(&Flags(*self))
            .finish()
    }
}
# [doc = include_str ! ("../../../doc/VkCullModeFlagBits.md")]
#[doc(alias = "VkCullModeFlags")]
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct CullModeFlags(u32);
impl CullModeFlags {
    #[doc(alias = "VK_CULL_MODE_NONE")]
    pub const NONE: Self = Self(0);
    #[doc(alias = "VK_CULL_MODE_FRONT_BIT")]
    pub const FRONT: Self = Self(1);
    #[doc(alias = "VK_CULL_MODE_BACK_BIT")]
    pub const BACK: Self = Self(2);
    #[doc(alias = "VK_CULL_MODE_FRONT_AND_BACK")]
    pub const FRONT_AND_BACK: Self = Self(3);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    #[allow(unused_mut)]
    pub const fn all() -> Self {
        let mut all = Self::empty();
        {
            all |= Self::NONE;
        }
        {
            all |= Self::FRONT;
        }
        {
            all |= Self::BACK;
        }
        {
            all |= Self::FRONT_AND_BACK;
        }
        all
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl const std::ops::BitOr for CullModeFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl const std::ops::BitOrAssign for CullModeFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl const std::ops::BitXor for CullModeFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl const std::ops::BitXorAssign for CullModeFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl const std::ops::BitAnd for CullModeFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl const std::ops::BitAndAssign for CullModeFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl const std::ops::Sub for CullModeFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl const std::ops::SubAssign for CullModeFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl const std::ops::Not for CullModeFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl Extend<CullModeFlags> for CullModeFlags {
    fn extend<T: IntoIterator<Item = CullModeFlags>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, i);
        }
    }
}
impl FromIterator<CullModeFlags> for CullModeFlags {
    fn from_iter<T: IntoIterator<Item = CullModeFlags>>(iterator: T) -> CullModeFlags {
        let mut out = Self::empty();
        <Self as Extend<CullModeFlags>>::extend(&mut out, iterator);
        out
    }
}
impl const Default for CullModeFlags {
    fn default() -> Self {
        Self::empty()
    }
}
impl const From<CullModeFlagBits> for CullModeFlags {
    fn from(bit: CullModeFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(bit.bits()) }
    }
}
impl Extend<CullModeFlagBits> for CullModeFlags {
    fn extend<T: IntoIterator<Item = CullModeFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, Self::from(i));
        }
    }
}
impl FromIterator<CullModeFlagBits> for CullModeFlags {
    fn from_iter<T: IntoIterator<Item = CullModeFlagBits>>(iterator: T) -> CullModeFlags {
        let mut out = Self::empty();
        <Self as Extend<CullModeFlagBits>>::extend(&mut out, iterator);
        out
    }
}
impl std::fmt::Debug for CullModeFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(CullModeFlags);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == CullModeFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(CullModeFlags::NONE) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(NONE))?;
                    }
                    if self.0.contains(CullModeFlags::FRONT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(FRONT))?;
                    }
                    if self.0.contains(CullModeFlags::BACK) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(BACK))?;
                    }
                    if self.0.contains(CullModeFlags::FRONT_AND_BACK) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(FRONT_AND_BACK))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(CullModeFlags)).field(&Flags(*self)).finish()
    }
}
# [doc = include_str ! ("../../../doc/VkDescriptorPoolCreateFlagBits.md")]
#[doc(alias = "VkDescriptorPoolCreateFlags")]
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct DescriptorPoolCreateFlags(u32);
impl DescriptorPoolCreateFlags {
    #[doc(alias = "VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT")]
    pub const FREE_DESCRIPTOR_SET: Self = Self(1);
    #[doc(alias = "VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT")]
    #[cfg(feature = "VULKAN_1_2")]
    pub const UPDATE_AFTER_BIND: Self = Self(2);
    #[doc(alias = "VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_VALVE")]
    #[cfg(feature = "VK_VALVE_mutable_descriptor_type")]
    pub const HOST_ONLY_VALVE: Self = Self(4);
    #[doc(alias = "VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT")]
    #[cfg(feature = "VK_EXT_descriptor_indexing")]
    pub const UPDATE_AFTER_BIND_EXT: Self = Self::UPDATE_AFTER_BIND;
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    #[allow(unused_mut)]
    pub const fn all() -> Self {
        let mut all = Self::empty();
        {
            all |= Self::FREE_DESCRIPTOR_SET;
        }
        #[cfg(feature = "VULKAN_1_2")]
        {
            all |= Self::UPDATE_AFTER_BIND;
        }
        #[cfg(feature = "VK_VALVE_mutable_descriptor_type")]
        {
            all |= Self::HOST_ONLY_VALVE;
        }
        #[cfg(feature = "VK_EXT_descriptor_indexing")]
        {
            all |= Self::UPDATE_AFTER_BIND_EXT;
        }
        all
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl const std::ops::BitOr for DescriptorPoolCreateFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl const std::ops::BitOrAssign for DescriptorPoolCreateFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl const std::ops::BitXor for DescriptorPoolCreateFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl const std::ops::BitXorAssign for DescriptorPoolCreateFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl const std::ops::BitAnd for DescriptorPoolCreateFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl const std::ops::BitAndAssign for DescriptorPoolCreateFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl const std::ops::Sub for DescriptorPoolCreateFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl const std::ops::SubAssign for DescriptorPoolCreateFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl const std::ops::Not for DescriptorPoolCreateFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl Extend<DescriptorPoolCreateFlags> for DescriptorPoolCreateFlags {
    fn extend<T: IntoIterator<Item = DescriptorPoolCreateFlags>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, i);
        }
    }
}
impl FromIterator<DescriptorPoolCreateFlags> for DescriptorPoolCreateFlags {
    fn from_iter<T: IntoIterator<Item = DescriptorPoolCreateFlags>>(iterator: T) -> DescriptorPoolCreateFlags {
        let mut out = Self::empty();
        <Self as Extend<DescriptorPoolCreateFlags>>::extend(&mut out, iterator);
        out
    }
}
impl const Default for DescriptorPoolCreateFlags {
    fn default() -> Self {
        Self::empty()
    }
}
impl const From<DescriptorPoolCreateFlagBits> for DescriptorPoolCreateFlags {
    fn from(bit: DescriptorPoolCreateFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(bit.bits()) }
    }
}
impl Extend<DescriptorPoolCreateFlagBits> for DescriptorPoolCreateFlags {
    fn extend<T: IntoIterator<Item = DescriptorPoolCreateFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, Self::from(i));
        }
    }
}
impl FromIterator<DescriptorPoolCreateFlagBits> for DescriptorPoolCreateFlags {
    fn from_iter<T: IntoIterator<Item = DescriptorPoolCreateFlagBits>>(iterator: T) -> DescriptorPoolCreateFlags {
        let mut out = Self::empty();
        <Self as Extend<DescriptorPoolCreateFlagBits>>::extend(&mut out, iterator);
        out
    }
}
impl std::fmt::Debug for DescriptorPoolCreateFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(DescriptorPoolCreateFlags);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == DescriptorPoolCreateFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(DescriptorPoolCreateFlags::FREE_DESCRIPTOR_SET) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(FREE_DESCRIPTOR_SET))?;
                    }
                    #[cfg(feature = "VULKAN_1_2")]
                    if self.0.contains(DescriptorPoolCreateFlags::UPDATE_AFTER_BIND) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(UPDATE_AFTER_BIND))?;
                    }
                    #[cfg(feature = "VK_VALVE_mutable_descriptor_type")]
                    if self.0.contains(DescriptorPoolCreateFlags::HOST_ONLY_VALVE) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(HOST_ONLY_VALVE))?;
                    }
                    #[cfg(feature = "VK_EXT_descriptor_indexing")]
                    if self.0.contains(DescriptorPoolCreateFlags::UPDATE_AFTER_BIND_EXT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(UPDATE_AFTER_BIND_EXT))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(DescriptorPoolCreateFlags))
            .field(&Flags(*self))
            .finish()
    }
}
#[doc(alias = "VkDescriptorPoolResetFlags")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct DescriptorPoolResetFlags(u32);
impl DescriptorPoolResetFlags {
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
}
# [doc = include_str ! ("../../../doc/VkDependencyFlagBits.md")]
#[doc(alias = "VkDependencyFlags")]
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct DependencyFlags(u32);
impl DependencyFlags {
    #[doc(alias = "VK_DEPENDENCY_BY_REGION_BIT")]
    pub const BY_REGION: Self = Self(1);
    #[doc(alias = "VK_DEPENDENCY_DEVICE_GROUP_BIT")]
    pub const DEVICE_GROUP: Self = Self(4);
    #[doc(alias = "VK_DEPENDENCY_VIEW_LOCAL_BIT")]
    pub const VIEW_LOCAL: Self = Self(2);
    #[doc(alias = "VK_DEPENDENCY_VIEW_LOCAL_BIT_KHR")]
    #[cfg(feature = "VK_KHR_multiview")]
    pub const VIEW_LOCAL_KHR: Self = Self::VIEW_LOCAL;
    #[doc(alias = "VK_DEPENDENCY_DEVICE_GROUP_BIT_KHR")]
    #[cfg(feature = "VK_KHR_device_group")]
    pub const DEVICE_GROUP_KHR: Self = Self::DEVICE_GROUP;
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    #[allow(unused_mut)]
    pub const fn all() -> Self {
        let mut all = Self::empty();
        {
            all |= Self::BY_REGION;
        }
        {
            all |= Self::DEVICE_GROUP;
        }
        {
            all |= Self::VIEW_LOCAL;
        }
        #[cfg(feature = "VK_KHR_multiview")]
        {
            all |= Self::VIEW_LOCAL_KHR;
        }
        #[cfg(feature = "VK_KHR_device_group")]
        {
            all |= Self::DEVICE_GROUP_KHR;
        }
        all
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl const std::ops::BitOr for DependencyFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl const std::ops::BitOrAssign for DependencyFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl const std::ops::BitXor for DependencyFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl const std::ops::BitXorAssign for DependencyFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl const std::ops::BitAnd for DependencyFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl const std::ops::BitAndAssign for DependencyFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl const std::ops::Sub for DependencyFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl const std::ops::SubAssign for DependencyFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl const std::ops::Not for DependencyFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl Extend<DependencyFlags> for DependencyFlags {
    fn extend<T: IntoIterator<Item = DependencyFlags>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, i);
        }
    }
}
impl FromIterator<DependencyFlags> for DependencyFlags {
    fn from_iter<T: IntoIterator<Item = DependencyFlags>>(iterator: T) -> DependencyFlags {
        let mut out = Self::empty();
        <Self as Extend<DependencyFlags>>::extend(&mut out, iterator);
        out
    }
}
impl const Default for DependencyFlags {
    fn default() -> Self {
        Self::empty()
    }
}
impl const From<DependencyFlagBits> for DependencyFlags {
    fn from(bit: DependencyFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(bit.bits()) }
    }
}
impl Extend<DependencyFlagBits> for DependencyFlags {
    fn extend<T: IntoIterator<Item = DependencyFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, Self::from(i));
        }
    }
}
impl FromIterator<DependencyFlagBits> for DependencyFlags {
    fn from_iter<T: IntoIterator<Item = DependencyFlagBits>>(iterator: T) -> DependencyFlags {
        let mut out = Self::empty();
        <Self as Extend<DependencyFlagBits>>::extend(&mut out, iterator);
        out
    }
}
impl std::fmt::Debug for DependencyFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(DependencyFlags);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == DependencyFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(DependencyFlags::BY_REGION) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(BY_REGION))?;
                    }
                    if self.0.contains(DependencyFlags::DEVICE_GROUP) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(DEVICE_GROUP))?;
                    }
                    if self.0.contains(DependencyFlags::VIEW_LOCAL) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(VIEW_LOCAL))?;
                    }
                    #[cfg(feature = "VK_KHR_multiview")]
                    if self.0.contains(DependencyFlags::VIEW_LOCAL_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(VIEW_LOCAL_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_device_group")]
                    if self.0.contains(DependencyFlags::DEVICE_GROUP_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(DEVICE_GROUP_KHR))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(DependencyFlags)).field(&Flags(*self)).finish()
    }
}
# [doc = include_str ! ("../../../doc/VK_MAX_PHYSICAL_DEVICE_NAME_SIZE.md")]
#[doc(alias = "VK_MAX_PHYSICAL_DEVICE_NAME_SIZE")]
pub const MAX_PHYSICAL_DEVICE_NAME_SIZE: u32 = 256;
# [doc = include_str ! ("../../../doc/VK_UUID_SIZE.md")]
#[doc(alias = "VK_UUID_SIZE")]
pub const UUID_SIZE: u32 = 16;
# [doc = include_str ! ("../../../doc/VK_LUID_SIZE.md")]
#[doc(alias = "VK_LUID_SIZE")]
pub const LUID_SIZE: u32 = 8;
# [doc = include_str ! ("../../../doc/VK_MAX_EXTENSION_NAME_SIZE.md")]
#[doc(alias = "VK_MAX_EXTENSION_NAME_SIZE")]
pub const MAX_EXTENSION_NAME_SIZE: u32 = 256;
# [doc = include_str ! ("../../../doc/VK_MAX_DESCRIPTION_SIZE.md")]
#[doc(alias = "VK_MAX_DESCRIPTION_SIZE")]
pub const MAX_DESCRIPTION_SIZE: u32 = 256;
# [doc = include_str ! ("../../../doc/VK_MAX_MEMORY_TYPES.md")]
#[doc(alias = "VK_MAX_MEMORY_TYPES")]
pub const MAX_MEMORY_TYPES: u32 = 32;
# [doc = include_str ! ("../../../doc/VK_MAX_MEMORY_HEAPS.md")]
#[doc(alias = "VK_MAX_MEMORY_HEAPS")]
pub const MAX_MEMORY_HEAPS: u32 = 16;
# [doc = include_str ! ("../../../doc/VK_LOD_CLAMP_NONE.md")]
#[doc(alias = "VK_LOD_CLAMP_NONE")]
pub const LOD_CLAMP_NONE: f32 = 1000.0;
# [doc = include_str ! ("../../../doc/VK_REMAINING_MIP_LEVELS.md")]
#[doc(alias = "VK_REMAINING_MIP_LEVELS")]
pub const REMAINING_MIP_LEVELS: u32 = !0;
# [doc = include_str ! ("../../../doc/VK_REMAINING_ARRAY_LAYERS.md")]
#[doc(alias = "VK_REMAINING_ARRAY_LAYERS")]
pub const REMAINING_ARRAY_LAYERS: u32 = !0;
# [doc = include_str ! ("../../../doc/VK_WHOLE_SIZE.md")]
#[doc(alias = "VK_WHOLE_SIZE")]
pub const WHOLE_SIZE: u64 = !0;
# [doc = include_str ! ("../../../doc/VK_ATTACHMENT_UNUSED.md")]
#[doc(alias = "VK_ATTACHMENT_UNUSED")]
pub const ATTACHMENT_UNUSED: u32 = !0;
# [doc = include_str ! ("../../../doc/VK_TRUE.md")]
#[doc(alias = "VK_TRUE")]
pub const TRUE: u32 = 1;
# [doc = include_str ! ("../../../doc/VK_FALSE.md")]
#[doc(alias = "VK_FALSE")]
pub const FALSE: u32 = 0;
# [doc = include_str ! ("../../../doc/VK_QUEUE_FAMILY_IGNORED.md")]
#[doc(alias = "VK_QUEUE_FAMILY_IGNORED")]
pub const QUEUE_FAMILY_IGNORED: u32 = !0;
# [doc = include_str ! ("../../../doc/VK_QUEUE_FAMILY_EXTERNAL.md")]
#[doc(alias = "VK_QUEUE_FAMILY_EXTERNAL")]
pub const QUEUE_FAMILY_EXTERNAL: u32 = !1;
# [doc = include_str ! ("../../../doc/VK_QUEUE_FAMILY_FOREIGN_EXT.md")]
#[doc(alias = "VK_QUEUE_FAMILY_FOREIGN_EXT")]
pub const QUEUE_FAMILY_FOREIGN_EXT: u32 = !2;
# [doc = include_str ! ("../../../doc/VK_SUBPASS_EXTERNAL.md")]
#[doc(alias = "VK_SUBPASS_EXTERNAL")]
pub const SUBPASS_EXTERNAL: u32 = !0;
# [doc = include_str ! ("../../../doc/VK_MAX_DEVICE_GROUP_SIZE.md")]
#[doc(alias = "VK_MAX_DEVICE_GROUP_SIZE")]
pub const MAX_DEVICE_GROUP_SIZE: u32 = 32;
# [doc = include_str ! ("../../../doc/VK_MAX_DRIVER_NAME_SIZE.md")]
#[doc(alias = "VK_MAX_DRIVER_NAME_SIZE")]
pub const MAX_DRIVER_NAME_SIZE: u32 = 256;
# [doc = include_str ! ("../../../doc/VK_MAX_DRIVER_INFO_SIZE.md")]
#[doc(alias = "VK_MAX_DRIVER_INFO_SIZE")]
pub const MAX_DRIVER_INFO_SIZE: u32 = 256;
# [doc = include_str ! ("../../../doc/VK_SHADER_UNUSED_KHR.md")]
#[doc(alias = "VK_SHADER_UNUSED_KHR")]
pub const SHADER_UNUSED_KHR: u32 = !0;
# [doc = include_str ! ("../../../doc/VK_MAX_GLOBAL_PRIORITY_SIZE_KHR.md")]
#[doc(alias = "VK_MAX_GLOBAL_PRIORITY_SIZE_KHR")]
pub const MAX_GLOBAL_PRIORITY_SIZE_KHR: u32 = 16;
# [doc = include_str ! ("../../../doc/VkQueueFlagBits.md")]
#[doc(alias = "VkQueueFlagBits")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct QueueFlagBits(u32);
impl QueueFlagBits {
    #[doc(alias = "VK_QUEUE_GRAPHICS_BIT")]
    pub const GRAPHICS: Self = Self(1);
    #[doc(alias = "VK_QUEUE_COMPUTE_BIT")]
    pub const COMPUTE: Self = Self(2);
    #[doc(alias = "VK_QUEUE_TRANSFER_BIT")]
    pub const TRANSFER: Self = Self(4);
    #[doc(alias = "VK_QUEUE_SPARSE_BINDING_BIT")]
    pub const SPARSE_BINDING: Self = Self(8);
    #[doc(alias = "VK_QUEUE_PROTECTED_BIT")]
    pub const PROTECTED: Self = Self(16);
    #[doc(alias = "VK_QUEUE_VIDEO_DECODE_BIT_KHR")]
    #[cfg(feature = "VK_KHR_video_decode_queue")]
    pub const VIDEO_DECODE_KHR: Self = Self(32);
    #[doc(alias = "VK_QUEUE_VIDEO_ENCODE_BIT_KHR")]
    #[cfg(feature = "VK_KHR_video_encode_queue")]
    pub const VIDEO_ENCODE_KHR: Self = Self(64);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        match bits {
            x if x == Self::GRAPHICS.bits() => Some(Self(x)),
            x if x == Self::COMPUTE.bits() => Some(Self(x)),
            x if x == Self::TRANSFER.bits() => Some(Self(x)),
            x if x == Self::SPARSE_BINDING.bits() => Some(Self(x)),
            x if x == Self::PROTECTED.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_video_decode_queue")]
            x if x == Self::VIDEO_DECODE_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_video_encode_queue")]
            x if x == Self::VIDEO_ENCODE_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_QCOM_extension_440")]
            x if x == Self::RESERVED7_QCOM.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
}
# [doc = include_str ! ("../../../doc/VkCullModeFlagBits.md")]
#[doc(alias = "VkCullModeFlagBits")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct CullModeFlagBits(u32);
impl CullModeFlagBits {
    #[doc(alias = "VK_CULL_MODE_NONE")]
    pub const NONE: Self = Self(0);
    #[doc(alias = "VK_CULL_MODE_FRONT_BIT")]
    pub const FRONT: Self = Self(1);
    #[doc(alias = "VK_CULL_MODE_BACK_BIT")]
    pub const BACK: Self = Self(2);
    #[doc(alias = "VK_CULL_MODE_FRONT_AND_BACK")]
    pub const FRONT_AND_BACK: Self = Self(3);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        match bits {
            x if x == Self::NONE.bits() => Some(Self(x)),
            x if x == Self::FRONT.bits() => Some(Self(x)),
            x if x == Self::BACK.bits() => Some(Self(x)),
            x if x == Self::FRONT_AND_BACK.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
}
# [doc = include_str ! ("../../../doc/VkRenderPassCreateFlagBits.md")]
#[doc(alias = "VkRenderPassCreateFlagBits")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct RenderPassCreateFlagBits(u32);
impl RenderPassCreateFlagBits {
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        match bits {
            #[cfg(feature = "VK_KHR_extension_221")]
            x if x == Self::RESERVED0_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_QCOM_render_pass_transform")]
            x if x == Self::TRANSFORM_QCOM.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
}
# [doc = include_str ! ("../../../doc/VkMemoryPropertyFlagBits.md")]
#[doc(alias = "VkMemoryPropertyFlagBits")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct MemoryPropertyFlagBits(u32);
impl MemoryPropertyFlagBits {
    #[doc(alias = "VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT")]
    pub const DEVICE_LOCAL: Self = Self(1);
    #[doc(alias = "VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT")]
    pub const HOST_VISIBLE: Self = Self(2);
    #[doc(alias = "VK_MEMORY_PROPERTY_HOST_COHERENT_BIT")]
    pub const HOST_COHERENT: Self = Self(4);
    #[doc(alias = "VK_MEMORY_PROPERTY_HOST_CACHED_BIT")]
    pub const HOST_CACHED: Self = Self(8);
    #[doc(alias = "VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT")]
    pub const LAZILY_ALLOCATED: Self = Self(16);
    #[doc(alias = "VK_MEMORY_PROPERTY_PROTECTED_BIT")]
    pub const PROTECTED: Self = Self(32);
    #[doc(alias = "VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD")]
    #[cfg(feature = "VK_AMD_device_coherent_memory")]
    pub const DEVICE_COHERENT_AMD: Self = Self(64);
    #[doc(alias = "VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD")]
    #[cfg(feature = "VK_AMD_device_coherent_memory")]
    pub const DEVICE_UNCACHED_AMD: Self = Self(128);
    #[doc(alias = "VK_MEMORY_PROPERTY_RDMA_CAPABLE_BIT_NV")]
    #[cfg(feature = "VK_NV_external_memory_rdma")]
    pub const RDMA_CAPABLE_NV: Self = Self(256);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        match bits {
            x if x == Self::DEVICE_LOCAL.bits() => Some(Self(x)),
            x if x == Self::HOST_VISIBLE.bits() => Some(Self(x)),
            x if x == Self::HOST_COHERENT.bits() => Some(Self(x)),
            x if x == Self::HOST_CACHED.bits() => Some(Self(x)),
            x if x == Self::LAZILY_ALLOCATED.bits() => Some(Self(x)),
            x if x == Self::PROTECTED.bits() => Some(Self(x)),
            #[cfg(feature = "VK_AMD_device_coherent_memory")]
            x if x == Self::DEVICE_COHERENT_AMD.bits() => Some(Self(x)),
            #[cfg(feature = "VK_AMD_device_coherent_memory")]
            x if x == Self::DEVICE_UNCACHED_AMD.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_external_memory_rdma")]
            x if x == Self::RDMA_CAPABLE_NV.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
}
# [doc = include_str ! ("../../../doc/VkMemoryHeapFlagBits.md")]
#[doc(alias = "VkMemoryHeapFlagBits")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct MemoryHeapFlagBits(u32);
impl MemoryHeapFlagBits {
    #[doc(alias = "VK_MEMORY_HEAP_DEVICE_LOCAL_BIT")]
    pub const DEVICE_LOCAL: Self = Self(1);
    #[doc(alias = "VK_MEMORY_HEAP_MULTI_INSTANCE_BIT")]
    pub const MULTI_INSTANCE: Self = Self(2);
    #[doc(alias = "VK_MEMORY_HEAP_MULTI_INSTANCE_BIT_KHR")]
    #[cfg(feature = "VK_KHR_device_group_creation")]
    pub const MULTI_INSTANCE_KHR: Self = Self::MULTI_INSTANCE;
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        match bits {
            x if x == Self::DEVICE_LOCAL.bits() => Some(Self(x)),
            x if x == Self::MULTI_INSTANCE.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_extension_299")]
            x if x == Self::RESERVED2_KHR.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
}
# [doc = include_str ! ("../../../doc/VkAccessFlagBits.md")]
#[doc(alias = "VkAccessFlagBits")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct AccessFlagBits(u32);
impl AccessFlagBits {
    #[doc(alias = "VK_ACCESS_INDIRECT_COMMAND_READ_BIT")]
    pub const INDIRECT_COMMAND_READ: Self = Self(1);
    #[doc(alias = "VK_ACCESS_INDEX_READ_BIT")]
    pub const INDEX_READ: Self = Self(2);
    #[doc(alias = "VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT")]
    pub const VERTEX_ATTRIBUTE_READ: Self = Self(4);
    #[doc(alias = "VK_ACCESS_UNIFORM_READ_BIT")]
    pub const UNIFORM_READ: Self = Self(8);
    #[doc(alias = "VK_ACCESS_INPUT_ATTACHMENT_READ_BIT")]
    pub const INPUT_ATTACHMENT_READ: Self = Self(16);
    #[doc(alias = "VK_ACCESS_SHADER_READ_BIT")]
    pub const SHADER_READ: Self = Self(32);
    #[doc(alias = "VK_ACCESS_SHADER_WRITE_BIT")]
    pub const SHADER_WRITE: Self = Self(64);
    #[doc(alias = "VK_ACCESS_COLOR_ATTACHMENT_READ_BIT")]
    pub const COLOR_ATTACHMENT_READ: Self = Self(128);
    #[doc(alias = "VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT")]
    pub const COLOR_ATTACHMENT_WRITE: Self = Self(256);
    #[doc(alias = "VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT")]
    pub const DEPTH_STENCIL_ATTACHMENT_READ: Self = Self(512);
    #[doc(alias = "VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT")]
    pub const DEPTH_STENCIL_ATTACHMENT_WRITE: Self = Self(1024);
    #[doc(alias = "VK_ACCESS_TRANSFER_READ_BIT")]
    pub const TRANSFER_READ: Self = Self(2048);
    #[doc(alias = "VK_ACCESS_TRANSFER_WRITE_BIT")]
    pub const TRANSFER_WRITE: Self = Self(4096);
    #[doc(alias = "VK_ACCESS_HOST_READ_BIT")]
    pub const HOST_READ: Self = Self(8192);
    #[doc(alias = "VK_ACCESS_HOST_WRITE_BIT")]
    pub const HOST_WRITE: Self = Self(16384);
    #[doc(alias = "VK_ACCESS_MEMORY_READ_BIT")]
    pub const MEMORY_READ: Self = Self(32768);
    #[doc(alias = "VK_ACCESS_MEMORY_WRITE_BIT")]
    pub const MEMORY_WRITE: Self = Self(65536);
    #[doc(alias = "VK_ACCESS_NONE")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const NONE: Self = Self(0);
    #[doc(alias = "VK_ACCESS_TRANSFORM_FEEDBACK_WRITE_BIT_EXT")]
    #[cfg(feature = "VK_EXT_transform_feedback")]
    pub const TRANSFORM_FEEDBACK_WRITE_EXT: Self = Self(33554432);
    #[doc(alias = "VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT")]
    #[cfg(feature = "VK_EXT_transform_feedback")]
    pub const TRANSFORM_FEEDBACK_COUNTER_READ_EXT: Self = Self(67108864);
    #[doc(alias = "VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT")]
    #[cfg(feature = "VK_EXT_transform_feedback")]
    pub const TRANSFORM_FEEDBACK_COUNTER_WRITE_EXT: Self = Self(134217728);
    #[doc(alias = "VK_ACCESS_CONDITIONAL_RENDERING_READ_BIT_EXT")]
    #[cfg(feature = "VK_EXT_conditional_rendering")]
    pub const CONDITIONAL_RENDERING_READ_EXT: Self = Self(1048576);
    #[doc(alias = "VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    pub const COLOR_ATTACHMENT_READ_NONCOHERENT_EXT: Self = Self(524288);
    #[doc(alias = "VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR")]
    #[cfg(feature = "VK_KHR_acceleration_structure")]
    pub const ACCELERATION_STRUCTURE_READ_KHR: Self = Self(2097152);
    #[doc(alias = "VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR")]
    #[cfg(feature = "VK_KHR_acceleration_structure")]
    pub const ACCELERATION_STRUCTURE_WRITE_KHR: Self = Self(4194304);
    #[doc(alias = "VK_ACCESS_FRAGMENT_DENSITY_MAP_READ_BIT_EXT")]
    #[cfg(feature = "VK_EXT_fragment_density_map")]
    pub const FRAGMENT_DENSITY_MAP_READ_EXT: Self = Self(16777216);
    #[doc(alias = "VK_ACCESS_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR")]
    #[cfg(feature = "VK_KHR_fragment_shading_rate")]
    pub const FRAGMENT_SHADING_RATE_ATTACHMENT_READ_KHR: Self = Self(8388608);
    #[doc(alias = "VK_ACCESS_COMMAND_PREPROCESS_READ_BIT_NV")]
    #[cfg(feature = "VK_NV_device_generated_commands")]
    pub const COMMAND_PREPROCESS_READ_NV: Self = Self(131072);
    #[doc(alias = "VK_ACCESS_COMMAND_PREPROCESS_WRITE_BIT_NV")]
    #[cfg(feature = "VK_NV_device_generated_commands")]
    pub const COMMAND_PREPROCESS_WRITE_NV: Self = Self(262144);
    #[doc(alias = "VK_ACCESS_SHADING_RATE_IMAGE_READ_BIT_NV")]
    #[cfg(feature = "VK_NV_shading_rate_image")]
    pub const SHADING_RATE_IMAGE_READ_NV: Self = Self::FRAGMENT_SHADING_RATE_ATTACHMENT_READ_KHR;
    #[doc(alias = "VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_NV")]
    #[cfg(feature = "VK_NV_ray_tracing")]
    pub const ACCELERATION_STRUCTURE_READ_NV: Self = Self::ACCELERATION_STRUCTURE_READ_KHR;
    #[doc(alias = "VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_NV")]
    #[cfg(feature = "VK_NV_ray_tracing")]
    pub const ACCELERATION_STRUCTURE_WRITE_NV: Self = Self::ACCELERATION_STRUCTURE_WRITE_KHR;
    #[doc(alias = "VK_ACCESS_NONE_KHR")]
    #[cfg(feature = "VK_KHR_synchronization2")]
    pub const NONE_KHR: Self = Self::NONE;
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        match bits {
            x if x == Self::INDIRECT_COMMAND_READ.bits() => Some(Self(x)),
            x if x == Self::INDEX_READ.bits() => Some(Self(x)),
            x if x == Self::VERTEX_ATTRIBUTE_READ.bits() => Some(Self(x)),
            x if x == Self::UNIFORM_READ.bits() => Some(Self(x)),
            x if x == Self::INPUT_ATTACHMENT_READ.bits() => Some(Self(x)),
            x if x == Self::SHADER_READ.bits() => Some(Self(x)),
            x if x == Self::SHADER_WRITE.bits() => Some(Self(x)),
            x if x == Self::COLOR_ATTACHMENT_READ.bits() => Some(Self(x)),
            x if x == Self::COLOR_ATTACHMENT_WRITE.bits() => Some(Self(x)),
            x if x == Self::DEPTH_STENCIL_ATTACHMENT_READ.bits() => Some(Self(x)),
            x if x == Self::DEPTH_STENCIL_ATTACHMENT_WRITE.bits() => Some(Self(x)),
            x if x == Self::TRANSFER_READ.bits() => Some(Self(x)),
            x if x == Self::TRANSFER_WRITE.bits() => Some(Self(x)),
            x if x == Self::HOST_READ.bits() => Some(Self(x)),
            x if x == Self::HOST_WRITE.bits() => Some(Self(x)),
            x if x == Self::MEMORY_READ.bits() => Some(Self(x)),
            x if x == Self::MEMORY_WRITE.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::NONE.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_transform_feedback")]
            x if x == Self::TRANSFORM_FEEDBACK_WRITE_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_transform_feedback")]
            x if x == Self::TRANSFORM_FEEDBACK_COUNTER_READ_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_transform_feedback")]
            x if x == Self::TRANSFORM_FEEDBACK_COUNTER_WRITE_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_conditional_rendering")]
            x if x == Self::CONDITIONAL_RENDERING_READ_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::COLOR_ATTACHMENT_READ_NONCOHERENT_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_acceleration_structure")]
            x if x == Self::ACCELERATION_STRUCTURE_READ_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_acceleration_structure")]
            x if x == Self::ACCELERATION_STRUCTURE_WRITE_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_fragment_density_map")]
            x if x == Self::FRAGMENT_DENSITY_MAP_READ_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_fragment_shading_rate")]
            x if x == Self::FRAGMENT_SHADING_RATE_ATTACHMENT_READ_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_device_generated_commands")]
            x if x == Self::COMMAND_PREPROCESS_READ_NV.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_device_generated_commands")]
            x if x == Self::COMMAND_PREPROCESS_WRITE_NV.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
}
# [doc = include_str ! ("../../../doc/VkBufferUsageFlagBits.md")]
#[doc(alias = "VkBufferUsageFlagBits")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct BufferUsageFlagBits(u32);
impl BufferUsageFlagBits {
    #[doc(alias = "VK_BUFFER_USAGE_TRANSFER_SRC_BIT")]
    pub const TRANSFER_SRC: Self = Self(1);
    #[doc(alias = "VK_BUFFER_USAGE_TRANSFER_DST_BIT")]
    pub const TRANSFER_DST: Self = Self(2);
    #[doc(alias = "VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT")]
    pub const UNIFORM_TEXEL_BUFFER: Self = Self(4);
    #[doc(alias = "VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT")]
    pub const STORAGE_TEXEL_BUFFER: Self = Self(8);
    #[doc(alias = "VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT")]
    pub const UNIFORM_BUFFER: Self = Self(16);
    #[doc(alias = "VK_BUFFER_USAGE_STORAGE_BUFFER_BIT")]
    pub const STORAGE_BUFFER: Self = Self(32);
    #[doc(alias = "VK_BUFFER_USAGE_INDEX_BUFFER_BIT")]
    pub const INDEX_BUFFER: Self = Self(64);
    #[doc(alias = "VK_BUFFER_USAGE_VERTEX_BUFFER_BIT")]
    pub const VERTEX_BUFFER: Self = Self(128);
    #[doc(alias = "VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT")]
    pub const INDIRECT_BUFFER: Self = Self(256);
    #[doc(alias = "VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT")]
    #[cfg(feature = "VULKAN_1_2")]
    pub const SHADER_DEVICE_ADDRESS: Self = Self(131072);
    #[doc(alias = "VK_BUFFER_USAGE_VIDEO_DECODE_SRC_BIT_KHR")]
    #[cfg(feature = "VK_KHR_video_decode_queue")]
    pub const VIDEO_DECODE_SRC_KHR: Self = Self(8192);
    #[doc(alias = "VK_BUFFER_USAGE_VIDEO_DECODE_DST_BIT_KHR")]
    #[cfg(feature = "VK_KHR_video_decode_queue")]
    pub const VIDEO_DECODE_DST_KHR: Self = Self(16384);
    #[doc(alias = "VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT")]
    #[cfg(feature = "VK_EXT_transform_feedback")]
    pub const TRANSFORM_FEEDBACK_BUFFER_EXT: Self = Self(2048);
    #[doc(alias = "VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT")]
    #[cfg(feature = "VK_EXT_transform_feedback")]
    pub const TRANSFORM_FEEDBACK_COUNTER_BUFFER_EXT: Self = Self(4096);
    #[doc(alias = "VK_BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT")]
    #[cfg(feature = "VK_EXT_conditional_rendering")]
    pub const CONDITIONAL_RENDERING_EXT: Self = Self(512);
    #[doc(alias = "VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR")]
    #[cfg(feature = "VK_KHR_acceleration_structure")]
    pub const ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_KHR: Self = Self(524288);
    #[doc(alias = "VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR")]
    #[cfg(feature = "VK_KHR_acceleration_structure")]
    pub const ACCELERATION_STRUCTURE_STORAGE_KHR: Self = Self(1048576);
    #[doc(alias = "VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR")]
    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
    pub const SHADER_BINDING_TABLE_KHR: Self = Self(1024);
    #[doc(alias = "VK_BUFFER_USAGE_VIDEO_ENCODE_DST_BIT_KHR")]
    #[cfg(feature = "VK_KHR_video_encode_queue")]
    pub const VIDEO_ENCODE_DST_KHR: Self = Self(32768);
    #[doc(alias = "VK_BUFFER_USAGE_VIDEO_ENCODE_SRC_BIT_KHR")]
    #[cfg(feature = "VK_KHR_video_encode_queue")]
    pub const VIDEO_ENCODE_SRC_KHR: Self = Self(65536);
    #[doc(alias = "VK_BUFFER_USAGE_RAY_TRACING_BIT_NV")]
    #[cfg(feature = "VK_NV_ray_tracing")]
    pub const RAY_TRACING_NV: Self = Self::SHADER_BINDING_TABLE_KHR;
    #[doc(alias = "VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_EXT")]
    #[cfg(feature = "VK_EXT_buffer_device_address")]
    pub const SHADER_DEVICE_ADDRESS_EXT: Self = Self::SHADER_DEVICE_ADDRESS;
    #[doc(alias = "VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_KHR")]
    #[cfg(feature = "VK_KHR_buffer_device_address")]
    pub const SHADER_DEVICE_ADDRESS_KHR: Self = Self::SHADER_DEVICE_ADDRESS;
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        match bits {
            x if x == Self::TRANSFER_SRC.bits() => Some(Self(x)),
            x if x == Self::TRANSFER_DST.bits() => Some(Self(x)),
            x if x == Self::UNIFORM_TEXEL_BUFFER.bits() => Some(Self(x)),
            x if x == Self::STORAGE_TEXEL_BUFFER.bits() => Some(Self(x)),
            x if x == Self::UNIFORM_BUFFER.bits() => Some(Self(x)),
            x if x == Self::STORAGE_BUFFER.bits() => Some(Self(x)),
            x if x == Self::INDEX_BUFFER.bits() => Some(Self(x)),
            x if x == Self::VERTEX_BUFFER.bits() => Some(Self(x)),
            x if x == Self::INDIRECT_BUFFER.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::SHADER_DEVICE_ADDRESS.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_video_decode_queue")]
            x if x == Self::VIDEO_DECODE_SRC_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_video_decode_queue")]
            x if x == Self::VIDEO_DECODE_DST_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_transform_feedback")]
            x if x == Self::TRANSFORM_FEEDBACK_BUFFER_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_transform_feedback")]
            x if x == Self::TRANSFORM_FEEDBACK_COUNTER_BUFFER_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_conditional_rendering")]
            x if x == Self::CONDITIONAL_RENDERING_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_acceleration_structure")]
            x if x == Self::ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_acceleration_structure")]
            x if x == Self::ACCELERATION_STRUCTURE_STORAGE_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
            x if x == Self::SHADER_BINDING_TABLE_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_QCOM_extension_173")]
            x if x == Self::RESERVED18_QCOM.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_video_encode_queue")]
            x if x == Self::VIDEO_ENCODE_DST_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_video_encode_queue")]
            x if x == Self::VIDEO_ENCODE_SRC_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_AMD_extension_317")]
            x if x == Self::RESERVED21_AMD.bits() => Some(Self(x)),
            #[cfg(feature = "VK_AMD_extension_317")]
            x if x == Self::RESERVED22_AMD.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
}
# [doc = include_str ! ("../../../doc/VkBufferCreateFlagBits.md")]
#[doc(alias = "VkBufferCreateFlagBits")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct BufferCreateFlagBits(u32);
impl BufferCreateFlagBits {
    #[doc(alias = "VK_BUFFER_CREATE_SPARSE_BINDING_BIT")]
    pub const SPARSE_BINDING: Self = Self(1);
    #[doc(alias = "VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT")]
    pub const SPARSE_RESIDENCY: Self = Self(2);
    #[doc(alias = "VK_BUFFER_CREATE_SPARSE_ALIASED_BIT")]
    pub const SPARSE_ALIASED: Self = Self(4);
    #[doc(alias = "VK_BUFFER_CREATE_PROTECTED_BIT")]
    pub const PROTECTED: Self = Self(8);
    #[doc(alias = "VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT")]
    #[cfg(feature = "VULKAN_1_2")]
    pub const DEVICE_ADDRESS_CAPTURE_REPLAY: Self = Self(16);
    #[doc(alias = "VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT")]
    #[cfg(feature = "VK_EXT_buffer_device_address")]
    pub const DEVICE_ADDRESS_CAPTURE_REPLAY_EXT: Self = Self::DEVICE_ADDRESS_CAPTURE_REPLAY;
    #[doc(alias = "VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR")]
    #[cfg(feature = "VK_KHR_buffer_device_address")]
    pub const DEVICE_ADDRESS_CAPTURE_REPLAY_KHR: Self = Self::DEVICE_ADDRESS_CAPTURE_REPLAY;
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        match bits {
            x if x == Self::SPARSE_BINDING.bits() => Some(Self(x)),
            x if x == Self::SPARSE_RESIDENCY.bits() => Some(Self(x)),
            x if x == Self::SPARSE_ALIASED.bits() => Some(Self(x)),
            x if x == Self::PROTECTED.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::DEVICE_ADDRESS_CAPTURE_REPLAY.bits() => Some(Self(x)),
            #[cfg(feature = "VK_AMD_extension_317")]
            x if x == Self::RESERVED5_AMD.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
}
# [doc = include_str ! ("../../../doc/VkShaderStageFlagBits.md")]
#[doc(alias = "VkShaderStageFlagBits")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct ShaderStageFlagBits(u32);
impl ShaderStageFlagBits {
    #[doc(alias = "VK_SHADER_STAGE_VERTEX_BIT")]
    pub const VERTEX: Self = Self(1);
    #[doc(alias = "VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT")]
    pub const TESSELLATION_CONTROL: Self = Self(2);
    #[doc(alias = "VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT")]
    pub const TESSELLATION_EVALUATION: Self = Self(4);
    #[doc(alias = "VK_SHADER_STAGE_GEOMETRY_BIT")]
    pub const GEOMETRY: Self = Self(8);
    #[doc(alias = "VK_SHADER_STAGE_FRAGMENT_BIT")]
    pub const FRAGMENT: Self = Self(16);
    #[doc(alias = "VK_SHADER_STAGE_COMPUTE_BIT")]
    pub const COMPUTE: Self = Self(32);
    #[doc(alias = "VK_SHADER_STAGE_ALL_GRAPHICS")]
    pub const ALL_GRAPHICS: Self = Self(31);
    #[doc(alias = "VK_SHADER_STAGE_ALL")]
    pub const ALL: Self = Self(2147483647);
    #[doc(alias = "VK_SHADER_STAGE_RAYGEN_BIT_KHR")]
    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
    pub const RAYGEN_KHR: Self = Self(256);
    #[doc(alias = "VK_SHADER_STAGE_ANY_HIT_BIT_KHR")]
    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
    pub const ANY_HIT_KHR: Self = Self(512);
    #[doc(alias = "VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR")]
    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
    pub const CLOSEST_HIT_KHR: Self = Self(1024);
    #[doc(alias = "VK_SHADER_STAGE_MISS_BIT_KHR")]
    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
    pub const MISS_KHR: Self = Self(2048);
    #[doc(alias = "VK_SHADER_STAGE_INTERSECTION_BIT_KHR")]
    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
    pub const INTERSECTION_KHR: Self = Self(4096);
    #[doc(alias = "VK_SHADER_STAGE_CALLABLE_BIT_KHR")]
    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
    pub const CALLABLE_KHR: Self = Self(8192);
    #[doc(alias = "VK_SHADER_STAGE_TASK_BIT_NV")]
    #[cfg(feature = "VK_NV_mesh_shader")]
    pub const TASK_NV: Self = Self(64);
    #[doc(alias = "VK_SHADER_STAGE_MESH_BIT_NV")]
    #[cfg(feature = "VK_NV_mesh_shader")]
    pub const MESH_NV: Self = Self(128);
    #[doc(alias = "VK_SHADER_STAGE_SUBPASS_SHADING_BIT_HUAWEI")]
    #[cfg(feature = "VK_HUAWEI_subpass_shading")]
    pub const SUBPASS_SHADING_HUAWEI: Self = Self(16384);
    #[doc(alias = "VK_SHADER_STAGE_RAYGEN_BIT_NV")]
    #[cfg(feature = "VK_NV_ray_tracing")]
    pub const RAYGEN_NV: Self = Self::RAYGEN_KHR;
    #[doc(alias = "VK_SHADER_STAGE_ANY_HIT_BIT_NV")]
    #[cfg(feature = "VK_NV_ray_tracing")]
    pub const ANY_HIT_NV: Self = Self::ANY_HIT_KHR;
    #[doc(alias = "VK_SHADER_STAGE_CLOSEST_HIT_BIT_NV")]
    #[cfg(feature = "VK_NV_ray_tracing")]
    pub const CLOSEST_HIT_NV: Self = Self::CLOSEST_HIT_KHR;
    #[doc(alias = "VK_SHADER_STAGE_MISS_BIT_NV")]
    #[cfg(feature = "VK_NV_ray_tracing")]
    pub const MISS_NV: Self = Self::MISS_KHR;
    #[doc(alias = "VK_SHADER_STAGE_INTERSECTION_BIT_NV")]
    #[cfg(feature = "VK_NV_ray_tracing")]
    pub const INTERSECTION_NV: Self = Self::INTERSECTION_KHR;
    #[doc(alias = "VK_SHADER_STAGE_CALLABLE_BIT_NV")]
    #[cfg(feature = "VK_NV_ray_tracing")]
    pub const CALLABLE_NV: Self = Self::CALLABLE_KHR;
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        match bits {
            x if x == Self::VERTEX.bits() => Some(Self(x)),
            x if x == Self::TESSELLATION_CONTROL.bits() => Some(Self(x)),
            x if x == Self::TESSELLATION_EVALUATION.bits() => Some(Self(x)),
            x if x == Self::GEOMETRY.bits() => Some(Self(x)),
            x if x == Self::FRAGMENT.bits() => Some(Self(x)),
            x if x == Self::COMPUTE.bits() => Some(Self(x)),
            x if x == Self::ALL_GRAPHICS.bits() => Some(Self(x)),
            x if x == Self::ALL.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
            x if x == Self::RAYGEN_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
            x if x == Self::ANY_HIT_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
            x if x == Self::CLOSEST_HIT_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
            x if x == Self::MISS_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
            x if x == Self::INTERSECTION_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
            x if x == Self::CALLABLE_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_mesh_shader")]
            x if x == Self::TASK_NV.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_mesh_shader")]
            x if x == Self::MESH_NV.bits() => Some(Self(x)),
            #[cfg(feature = "VK_HUAWEI_subpass_shading")]
            x if x == Self::SUBPASS_SHADING_HUAWEI.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
}
# [doc = include_str ! ("../../../doc/VkImageUsageFlagBits.md")]
#[doc(alias = "VkImageUsageFlagBits")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct ImageUsageFlagBits(u32);
impl ImageUsageFlagBits {
    #[doc(alias = "VK_IMAGE_USAGE_TRANSFER_SRC_BIT")]
    pub const TRANSFER_SRC: Self = Self(1);
    #[doc(alias = "VK_IMAGE_USAGE_TRANSFER_DST_BIT")]
    pub const TRANSFER_DST: Self = Self(2);
    #[doc(alias = "VK_IMAGE_USAGE_SAMPLED_BIT")]
    pub const SAMPLED: Self = Self(4);
    #[doc(alias = "VK_IMAGE_USAGE_STORAGE_BIT")]
    pub const STORAGE: Self = Self(8);
    #[doc(alias = "VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT")]
    pub const COLOR_ATTACHMENT: Self = Self(16);
    #[doc(alias = "VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT")]
    pub const DEPTH_STENCIL_ATTACHMENT: Self = Self(32);
    #[doc(alias = "VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT")]
    pub const TRANSIENT_ATTACHMENT: Self = Self(64);
    #[doc(alias = "VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT")]
    pub const INPUT_ATTACHMENT: Self = Self(128);
    #[doc(alias = "VK_IMAGE_USAGE_VIDEO_DECODE_DST_BIT_KHR")]
    #[cfg(feature = "VK_KHR_video_decode_queue")]
    pub const VIDEO_DECODE_DST_KHR: Self = Self(1024);
    #[doc(alias = "VK_IMAGE_USAGE_VIDEO_DECODE_SRC_BIT_KHR")]
    #[cfg(feature = "VK_KHR_video_decode_queue")]
    pub const VIDEO_DECODE_SRC_KHR: Self = Self(2048);
    #[doc(alias = "VK_IMAGE_USAGE_VIDEO_DECODE_DPB_BIT_KHR")]
    #[cfg(feature = "VK_KHR_video_decode_queue")]
    pub const VIDEO_DECODE_DPB_KHR: Self = Self(4096);
    #[doc(alias = "VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT")]
    #[cfg(feature = "VK_EXT_fragment_density_map")]
    pub const FRAGMENT_DENSITY_MAP_EXT: Self = Self(512);
    #[doc(alias = "VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR")]
    #[cfg(feature = "VK_KHR_fragment_shading_rate")]
    pub const FRAGMENT_SHADING_RATE_ATTACHMENT_KHR: Self = Self(256);
    #[doc(alias = "VK_IMAGE_USAGE_VIDEO_ENCODE_DST_BIT_KHR")]
    #[cfg(feature = "VK_KHR_video_encode_queue")]
    pub const VIDEO_ENCODE_DST_KHR: Self = Self(8192);
    #[doc(alias = "VK_IMAGE_USAGE_VIDEO_ENCODE_SRC_BIT_KHR")]
    #[cfg(feature = "VK_KHR_video_encode_queue")]
    pub const VIDEO_ENCODE_SRC_KHR: Self = Self(16384);
    #[doc(alias = "VK_IMAGE_USAGE_VIDEO_ENCODE_DPB_BIT_KHR")]
    #[cfg(feature = "VK_KHR_video_encode_queue")]
    pub const VIDEO_ENCODE_DPB_KHR: Self = Self(32768);
    #[doc(alias = "VK_IMAGE_USAGE_INVOCATION_MASK_BIT_HUAWEI")]
    #[cfg(feature = "VK_HUAWEI_invocation_mask")]
    pub const INVOCATION_MASK_HUAWEI: Self = Self(262144);
    #[doc(alias = "VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV")]
    #[cfg(feature = "VK_NV_shading_rate_image")]
    pub const SHADING_RATE_IMAGE_NV: Self = Self::FRAGMENT_SHADING_RATE_ATTACHMENT_KHR;
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        match bits {
            x if x == Self::TRANSFER_SRC.bits() => Some(Self(x)),
            x if x == Self::TRANSFER_DST.bits() => Some(Self(x)),
            x if x == Self::SAMPLED.bits() => Some(Self(x)),
            x if x == Self::STORAGE.bits() => Some(Self(x)),
            x if x == Self::COLOR_ATTACHMENT.bits() => Some(Self(x)),
            x if x == Self::DEPTH_STENCIL_ATTACHMENT.bits() => Some(Self(x)),
            x if x == Self::TRANSIENT_ATTACHMENT.bits() => Some(Self(x)),
            x if x == Self::INPUT_ATTACHMENT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_video_decode_queue")]
            x if x == Self::VIDEO_DECODE_DST_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_video_decode_queue")]
            x if x == Self::VIDEO_DECODE_SRC_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_video_decode_queue")]
            x if x == Self::VIDEO_DECODE_DPB_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_QCOM_extension_173")]
            x if x == Self::RESERVED16_QCOM.bits() => Some(Self(x)),
            #[cfg(feature = "VK_QCOM_extension_173")]
            x if x == Self::RESERVED17_QCOM.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_fragment_density_map")]
            x if x == Self::FRAGMENT_DENSITY_MAP_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_fragment_shading_rate")]
            x if x == Self::FRAGMENT_SHADING_RATE_ATTACHMENT_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_INTEL_extension_271")]
            x if x == Self::RESERVED22_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_video_encode_queue")]
            x if x == Self::VIDEO_ENCODE_DST_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_video_encode_queue")]
            x if x == Self::VIDEO_ENCODE_SRC_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_video_encode_queue")]
            x if x == Self::VIDEO_ENCODE_DPB_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_extension_340")]
            x if x == Self::RESERVED19_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_HUAWEI_invocation_mask")]
            x if x == Self::INVOCATION_MASK_HUAWEI.bits() => Some(Self(x)),
            #[cfg(feature = "VK_QCOM_extension_441")]
            x if x == Self::RESERVED20_QCOM.bits() => Some(Self(x)),
            #[cfg(feature = "VK_QCOM_extension_441")]
            x if x == Self::RESERVED21_QCOM.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
}
# [doc = include_str ! ("../../../doc/VkImageCreateFlagBits.md")]
#[doc(alias = "VkImageCreateFlagBits")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct ImageCreateFlagBits(u32);
impl ImageCreateFlagBits {
    #[doc(alias = "VK_IMAGE_CREATE_SPARSE_BINDING_BIT")]
    pub const SPARSE_BINDING: Self = Self(1);
    #[doc(alias = "VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT")]
    pub const SPARSE_RESIDENCY: Self = Self(2);
    #[doc(alias = "VK_IMAGE_CREATE_SPARSE_ALIASED_BIT")]
    pub const SPARSE_ALIASED: Self = Self(4);
    #[doc(alias = "VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT")]
    pub const MUTABLE_FORMAT: Self = Self(8);
    #[doc(alias = "VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT")]
    pub const CUBE_COMPATIBLE: Self = Self(16);
    #[doc(alias = "VK_IMAGE_CREATE_ALIAS_BIT")]
    pub const ALIAS: Self = Self(1024);
    #[doc(alias = "VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT")]
    pub const SPLIT_INSTANCE_BIND_REGIONS: Self = Self(64);
    #[doc(alias = "VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT")]
    pub const N2D_ARRAY_COMPATIBLE: Self = Self(32);
    #[doc(alias = "VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT")]
    pub const BLOCK_TEXEL_VIEW_COMPATIBLE: Self = Self(128);
    #[doc(alias = "VK_IMAGE_CREATE_EXTENDED_USAGE_BIT")]
    pub const EXTENDED_USAGE: Self = Self(256);
    #[doc(alias = "VK_IMAGE_CREATE_PROTECTED_BIT")]
    pub const PROTECTED: Self = Self(2048);
    #[doc(alias = "VK_IMAGE_CREATE_DISJOINT_BIT")]
    pub const DISJOINT: Self = Self(512);
    #[doc(alias = "VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV")]
    #[cfg(feature = "VK_NV_corner_sampled_image")]
    pub const CORNER_SAMPLED_NV: Self = Self(8192);
    #[doc(alias = "VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT")]
    #[cfg(feature = "VK_EXT_sample_locations")]
    pub const SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_EXT: Self = Self(4096);
    #[doc(alias = "VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT")]
    #[cfg(feature = "VK_EXT_fragment_density_map")]
    pub const SUBSAMPLED_EXT: Self = Self(16384);
    #[doc(alias = "VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR")]
    #[cfg(feature = "VK_KHR_device_group")]
    pub const SPLIT_INSTANCE_BIND_REGIONS_KHR: Self = Self::SPLIT_INSTANCE_BIND_REGIONS;
    #[doc(alias = "VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT_KHR")]
    #[cfg(feature = "VK_KHR_maintenance1")]
    pub const N2D_ARRAY_COMPATIBLE_KHR: Self = Self::N2D_ARRAY_COMPATIBLE;
    #[doc(alias = "VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT_KHR")]
    #[cfg(feature = "VK_KHR_maintenance2")]
    pub const BLOCK_TEXEL_VIEW_COMPATIBLE_KHR: Self = Self::BLOCK_TEXEL_VIEW_COMPATIBLE;
    #[doc(alias = "VK_IMAGE_CREATE_EXTENDED_USAGE_BIT_KHR")]
    #[cfg(feature = "VK_KHR_maintenance2")]
    pub const EXTENDED_USAGE_KHR: Self = Self::EXTENDED_USAGE;
    #[doc(alias = "VK_IMAGE_CREATE_DISJOINT_BIT_KHR")]
    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
    pub const DISJOINT_KHR: Self = Self::DISJOINT;
    #[doc(alias = "VK_IMAGE_CREATE_ALIAS_BIT_KHR")]
    #[cfg(feature = "VK_KHR_bind_memory2")]
    pub const ALIAS_KHR: Self = Self::ALIAS;
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        match bits {
            x if x == Self::SPARSE_BINDING.bits() => Some(Self(x)),
            x if x == Self::SPARSE_RESIDENCY.bits() => Some(Self(x)),
            x if x == Self::SPARSE_ALIASED.bits() => Some(Self(x)),
            x if x == Self::MUTABLE_FORMAT.bits() => Some(Self(x)),
            x if x == Self::CUBE_COMPATIBLE.bits() => Some(Self(x)),
            x if x == Self::ALIAS.bits() => Some(Self(x)),
            x if x == Self::SPLIT_INSTANCE_BIND_REGIONS.bits() => Some(Self(x)),
            x if x == Self::N2D_ARRAY_COMPATIBLE.bits() => Some(Self(x)),
            x if x == Self::BLOCK_TEXEL_VIEW_COMPATIBLE.bits() => Some(Self(x)),
            x if x == Self::EXTENDED_USAGE.bits() => Some(Self(x)),
            x if x == Self::PROTECTED.bits() => Some(Self(x)),
            x if x == Self::DISJOINT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_corner_sampled_image")]
            x if x == Self::CORNER_SAMPLED_NV.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_sample_locations")]
            x if x == Self::SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_fragment_density_map")]
            x if x == Self::SUBSAMPLED_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_AMD_extension_317")]
            x if x == Self::RESERVED16_AMD.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_extension_377")]
            x if x == Self::RESERVED18_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_extension_394")]
            x if x == Self::RESERVED394_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_QCOM_fragment_density_map_offset")]
            x if x == Self::FRAGMENT_DENSITY_MAP_OFFSET_QCOM.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
}
# [doc = include_str ! ("../../../doc/VkImageViewCreateFlagBits.md")]
#[doc(alias = "VkImageViewCreateFlagBits")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct ImageViewCreateFlagBits(u32);
impl ImageViewCreateFlagBits {
    #[doc(alias = "VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT")]
    #[cfg(feature = "VK_EXT_fragment_density_map")]
    pub const FRAGMENT_DENSITY_MAP_DYNAMIC_EXT: Self = Self(1);
    #[doc(alias = "VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DEFERRED_BIT_EXT")]
    #[cfg(feature = "VK_EXT_fragment_density_map2")]
    pub const FRAGMENT_DENSITY_MAP_DEFERRED_EXT: Self = Self(2);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        match bits {
            #[cfg(feature = "VK_EXT_fragment_density_map")]
            x if x == Self::FRAGMENT_DENSITY_MAP_DYNAMIC_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_AMD_extension_317")]
            x if x == Self::RESERVED2_AMD.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_fragment_density_map2")]
            x if x == Self::FRAGMENT_DENSITY_MAP_DEFERRED_EXT.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
}
# [doc = include_str ! ("../../../doc/VkSamplerCreateFlagBits.md")]
#[doc(alias = "VkSamplerCreateFlagBits")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct SamplerCreateFlagBits(u32);
impl SamplerCreateFlagBits {
    #[doc(alias = "VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT")]
    #[cfg(feature = "VK_EXT_fragment_density_map")]
    pub const SUBSAMPLED_EXT: Self = Self(1);
    #[doc(alias = "VK_SAMPLER_CREATE_SUBSAMPLED_COARSE_RECONSTRUCTION_BIT_EXT")]
    #[cfg(feature = "VK_EXT_fragment_density_map")]
    pub const SUBSAMPLED_COARSE_RECONSTRUCTION_EXT: Self = Self(2);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        match bits {
            #[cfg(feature = "VK_EXT_fragment_density_map")]
            x if x == Self::SUBSAMPLED_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_fragment_density_map")]
            x if x == Self::SUBSAMPLED_COARSE_RECONSTRUCTION_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_AMD_extension_317")]
            x if x == Self::RESERVED3_AMD.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_disable_cube_map_wrap")]
            x if x == Self::RESERVED2_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_QCOM_extension_441")]
            x if x == Self::IMAGE_PROCESSING_QCOM.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
}
# [doc = include_str ! ("../../../doc/VkPipelineCreateFlagBits.md")]
#[doc(alias = "VkPipelineCreateFlagBits")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct PipelineCreateFlagBits(u32);
impl PipelineCreateFlagBits {
    #[doc(alias = "VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT")]
    pub const DISABLE_OPTIMIZATION: Self = Self(1);
    #[doc(alias = "VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT")]
    pub const ALLOW_DERIVATIVES: Self = Self(2);
    #[doc(alias = "VK_PIPELINE_CREATE_DERIVATIVE_BIT")]
    pub const DERIVATIVE: Self = Self(4);
    #[doc(alias = "VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT")]
    pub const VIEW_INDEX_FROM_DEVICE_INDEX: Self = Self(8);
    #[doc(alias = "VK_PIPELINE_CREATE_DISPATCH_BASE_BIT")]
    pub const DISPATCH_BASE: Self = Self(16);
    #[doc(alias = "VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const FAIL_ON_PIPELINE_COMPILE_REQUIRED: Self = Self(256);
    #[doc(alias = "VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const EARLY_RETURN_ON_FAILURE: Self = Self(512);
    #[doc(alias = "VK_PIPELINE_CREATE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR")]
    #[cfg(feature = "VK_KHR_dynamic_rendering")]
    pub const RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_KHR: Self = Self(2097152);
    #[doc(alias = "VK_PIPELINE_CREATE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT")]
    #[cfg(feature = "VK_KHR_dynamic_rendering")]
    pub const RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_EXT: Self = Self(4194304);
    #[doc(alias = "VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR")]
    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
    pub const RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_KHR: Self = Self(16384);
    #[doc(alias = "VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR")]
    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
    pub const RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_KHR: Self = Self(32768);
    #[doc(alias = "VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR")]
    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
    pub const RAY_TRACING_NO_NULL_MISS_SHADERS_KHR: Self = Self(65536);
    #[doc(alias = "VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR")]
    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
    pub const RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_KHR: Self = Self(131072);
    #[doc(alias = "VK_PIPELINE_CREATE_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR")]
    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
    pub const RAY_TRACING_SKIP_TRIANGLES_KHR: Self = Self(4096);
    #[doc(alias = "VK_PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR")]
    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
    pub const RAY_TRACING_SKIP_AABBS_KHR: Self = Self(8192);
    #[doc(alias = "VK_PIPELINE_CREATE_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR")]
    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
    pub const RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_KHR: Self = Self(524288);
    #[doc(alias = "VK_PIPELINE_CREATE_DEFER_COMPILE_BIT_NV")]
    #[cfg(feature = "VK_NV_ray_tracing")]
    pub const DEFER_COMPILE_NV: Self = Self(32);
    #[doc(alias = "VK_PIPELINE_CREATE_CAPTURE_STATISTICS_BIT_KHR")]
    #[cfg(feature = "VK_KHR_pipeline_executable_properties")]
    pub const CAPTURE_STATISTICS_KHR: Self = Self(64);
    #[doc(alias = "VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR")]
    #[cfg(feature = "VK_KHR_pipeline_executable_properties")]
    pub const CAPTURE_INTERNAL_REPRESENTATIONS_KHR: Self = Self(128);
    #[doc(alias = "VK_PIPELINE_CREATE_INDIRECT_BINDABLE_BIT_NV")]
    #[cfg(feature = "VK_NV_device_generated_commands")]
    pub const INDIRECT_BINDABLE_NV: Self = Self(262144);
    #[doc(alias = "VK_PIPELINE_CREATE_LIBRARY_BIT_KHR")]
    #[cfg(feature = "VK_KHR_pipeline_library")]
    pub const LIBRARY_KHR: Self = Self(2048);
    #[doc(alias = "VK_PIPELINE_CREATE_RAY_TRACING_ALLOW_MOTION_BIT_NV")]
    #[cfg(feature = "VK_NV_ray_tracing_motion_blur")]
    pub const RAY_TRACING_ALLOW_MOTION_NV: Self = Self(1048576);
    #[doc(alias = "VK_PIPELINE_CREATE_DISPATCH_BASE")]
    pub const DISPATCH_BASE_DUP: Self = Self::DISPATCH_BASE;
    #[doc(alias = "VK_PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR")]
    #[cfg(feature = "VK_KHR_dynamic_rendering")]
    pub const PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_SHADING_RATE_ATTACHMENT_KHR: Self =
        Self::RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_KHR;
    #[doc(alias = "VK_PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT")]
    #[cfg(feature = "VK_KHR_dynamic_rendering")]
    pub const PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_DENSITY_MAP_ATTACHMENT_EXT: Self =
        Self::RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_EXT;
    #[doc(alias = "VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR")]
    #[cfg(feature = "VK_KHR_device_group")]
    pub const VIEW_INDEX_FROM_DEVICE_INDEX_KHR: Self = Self::VIEW_INDEX_FROM_DEVICE_INDEX;
    #[doc(alias = "VK_PIPELINE_CREATE_DISPATCH_BASE_KHR")]
    #[cfg(feature = "VK_KHR_device_group")]
    pub const DISPATCH_BASE_KHR: Self = Self::DISPATCH_BASE_DUP;
    #[doc(alias = "VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT_EXT")]
    #[cfg(feature = "VK_EXT_pipeline_creation_cache_control")]
    pub const FAIL_ON_PIPELINE_COMPILE_REQUIRED_EXT: Self = Self::FAIL_ON_PIPELINE_COMPILE_REQUIRED;
    #[doc(alias = "VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT_EXT")]
    #[cfg(feature = "VK_EXT_pipeline_creation_cache_control")]
    pub const EARLY_RETURN_ON_FAILURE_EXT: Self = Self::EARLY_RETURN_ON_FAILURE;
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        match bits {
            x if x == Self::DISABLE_OPTIMIZATION.bits() => Some(Self(x)),
            x if x == Self::ALLOW_DERIVATIVES.bits() => Some(Self(x)),
            x if x == Self::DERIVATIVE.bits() => Some(Self(x)),
            x if x == Self::VIEW_INDEX_FROM_DEVICE_INDEX.bits() => Some(Self(x)),
            x if x == Self::DISPATCH_BASE.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::FAIL_ON_PIPELINE_COMPILE_REQUIRED.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::EARLY_RETURN_ON_FAILURE.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_dynamic_rendering")]
            x if x == Self::RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_dynamic_rendering")]
            x if x == Self::RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
            x if x == Self::RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
            x if x == Self::RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
            x if x == Self::RAY_TRACING_NO_NULL_MISS_SHADERS_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
            x if x == Self::RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
            x if x == Self::RAY_TRACING_SKIP_TRIANGLES_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
            x if x == Self::RAY_TRACING_SKIP_AABBS_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
            x if x == Self::RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_ray_tracing")]
            x if x == Self::DEFER_COMPILE_NV.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_pipeline_executable_properties")]
            x if x == Self::CAPTURE_STATISTICS_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_pipeline_executable_properties")]
            x if x == Self::CAPTURE_INTERNAL_REPRESENTATIONS_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_device_generated_commands")]
            x if x == Self::INDIRECT_BINDABLE_NV.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_pipeline_library")]
            x if x == Self::LIBRARY_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_AMD_extension_321")]
            x if x == Self::RESERVED23_AMD.bits() => Some(Self(x)),
            #[cfg(feature = "VK_AMD_extension_321")]
            x if x == Self::RESERVED10_AMD.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_ray_tracing_motion_blur")]
            x if x == Self::RAY_TRACING_ALLOW_MOTION_NV.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
}
# [doc = include_str ! ("../../../doc/VkPipelineShaderStageCreateFlagBits.md")]
#[doc(alias = "VkPipelineShaderStageCreateFlagBits")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct PipelineShaderStageCreateFlagBits(u32);
impl PipelineShaderStageCreateFlagBits {
    #[doc(alias = "VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const ALLOW_VARYING_SUBGROUP_SIZE: Self = Self(1);
    #[doc(alias = "VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const REQUIRE_FULL_SUBGROUPS: Self = Self(2);
    #[doc(alias = "VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT")]
    #[cfg(feature = "VK_EXT_subgroup_size_control")]
    pub const ALLOW_VARYING_SUBGROUP_SIZE_EXT: Self = Self::ALLOW_VARYING_SUBGROUP_SIZE;
    #[doc(alias = "VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT")]
    #[cfg(feature = "VK_EXT_subgroup_size_control")]
    pub const REQUIRE_FULL_SUBGROUPS_EXT: Self = Self::REQUIRE_FULL_SUBGROUPS;
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        match bits {
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::ALLOW_VARYING_SUBGROUP_SIZE.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::REQUIRE_FULL_SUBGROUPS.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_extension_52")]
            x if x == Self::RESERVED2_NV.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_extension_297")]
            x if x == Self::RESERVED3_KHR.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
}
# [doc = include_str ! ("../../../doc/VkColorComponentFlagBits.md")]
#[doc(alias = "VkColorComponentFlagBits")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct ColorComponentFlagBits(u32);
impl ColorComponentFlagBits {
    #[doc(alias = "VK_COLOR_COMPONENT_R_BIT")]
    pub const R: Self = Self(1);
    #[doc(alias = "VK_COLOR_COMPONENT_G_BIT")]
    pub const G: Self = Self(2);
    #[doc(alias = "VK_COLOR_COMPONENT_B_BIT")]
    pub const B: Self = Self(4);
    #[doc(alias = "VK_COLOR_COMPONENT_A_BIT")]
    pub const A: Self = Self(8);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        match bits {
            x if x == Self::R.bits() => Some(Self(x)),
            x if x == Self::G.bits() => Some(Self(x)),
            x if x == Self::B.bits() => Some(Self(x)),
            x if x == Self::A.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
}
# [doc = include_str ! ("../../../doc/VkFenceCreateFlagBits.md")]
#[doc(alias = "VkFenceCreateFlagBits")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct FenceCreateFlagBits(u32);
impl FenceCreateFlagBits {
    #[doc(alias = "VK_FENCE_CREATE_SIGNALED_BIT")]
    pub const SIGNALED: Self = Self(1);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        match bits {
            x if x == Self::SIGNALED.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
}
# [doc = include_str ! ("../../../doc/VkFormatFeatureFlagBits.md")]
#[doc(alias = "VkFormatFeatureFlagBits")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct FormatFeatureFlagBits(u32);
impl FormatFeatureFlagBits {
    #[doc(alias = "VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT")]
    pub const SAMPLED_IMAGE: Self = Self(1);
    #[doc(alias = "VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT")]
    pub const STORAGE_IMAGE: Self = Self(2);
    #[doc(alias = "VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT")]
    pub const STORAGE_IMAGE_ATOMIC: Self = Self(4);
    #[doc(alias = "VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT")]
    pub const UNIFORM_TEXEL_BUFFER: Self = Self(8);
    #[doc(alias = "VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT")]
    pub const STORAGE_TEXEL_BUFFER: Self = Self(16);
    #[doc(alias = "VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT")]
    pub const STORAGE_TEXEL_BUFFER_ATOMIC: Self = Self(32);
    #[doc(alias = "VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT")]
    pub const VERTEX_BUFFER: Self = Self(64);
    #[doc(alias = "VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT")]
    pub const COLOR_ATTACHMENT: Self = Self(128);
    #[doc(alias = "VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT")]
    pub const COLOR_ATTACHMENT_BLEND: Self = Self(256);
    #[doc(alias = "VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT")]
    pub const DEPTH_STENCIL_ATTACHMENT: Self = Self(512);
    #[doc(alias = "VK_FORMAT_FEATURE_BLIT_SRC_BIT")]
    pub const BLIT_SRC: Self = Self(1024);
    #[doc(alias = "VK_FORMAT_FEATURE_BLIT_DST_BIT")]
    pub const BLIT_DST: Self = Self(2048);
    #[doc(alias = "VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT")]
    pub const SAMPLED_IMAGE_FILTER_LINEAR: Self = Self(4096);
    #[doc(alias = "VK_FORMAT_FEATURE_TRANSFER_SRC_BIT")]
    pub const TRANSFER_SRC: Self = Self(16384);
    #[doc(alias = "VK_FORMAT_FEATURE_TRANSFER_DST_BIT")]
    pub const TRANSFER_DST: Self = Self(32768);
    #[doc(alias = "VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT")]
    pub const MIDPOINT_CHROMA_SAMPLES: Self = Self(131072);
    #[doc(alias = "VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT")]
    pub const SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER: Self = Self(262144);
    #[doc(alias = "VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT")]
    pub const SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER: Self = Self(524288);
    #[doc(alias = "VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT")]
    pub const SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT: Self = Self(1048576);
    #[doc(alias = "VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT")]
    pub const SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE: Self = Self(2097152);
    #[doc(alias = "VK_FORMAT_FEATURE_DISJOINT_BIT")]
    pub const DISJOINT: Self = Self(4194304);
    #[doc(alias = "VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT")]
    pub const COSITED_CHROMA_SAMPLES: Self = Self(8388608);
    #[doc(alias = "VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT")]
    #[cfg(feature = "VULKAN_1_2")]
    pub const SAMPLED_IMAGE_FILTER_MINMAX: Self = Self(65536);
    #[doc(alias = "VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG")]
    #[cfg(feature = "VK_IMG_filter_cubic")]
    pub const SAMPLED_IMAGE_FILTER_CUBIC_IMG: Self = Self(8192);
    #[doc(alias = "VK_FORMAT_FEATURE_VIDEO_DECODE_OUTPUT_BIT_KHR")]
    #[cfg(feature = "VK_KHR_video_decode_queue")]
    pub const VIDEO_DECODE_OUTPUT_KHR: Self = Self(33554432);
    #[doc(alias = "VK_FORMAT_FEATURE_VIDEO_DECODE_DPB_BIT_KHR")]
    #[cfg(feature = "VK_KHR_video_decode_queue")]
    pub const VIDEO_DECODE_DPB_KHR: Self = Self(67108864);
    #[doc(alias = "VK_FORMAT_FEATURE_ACCELERATION_STRUCTURE_VERTEX_BUFFER_BIT_KHR")]
    #[cfg(feature = "VK_KHR_acceleration_structure")]
    pub const ACCELERATION_STRUCTURE_VERTEX_BUFFER_KHR: Self = Self(536870912);
    #[doc(alias = "VK_FORMAT_FEATURE_FRAGMENT_DENSITY_MAP_BIT_EXT")]
    #[cfg(feature = "VK_EXT_fragment_density_map")]
    pub const FRAGMENT_DENSITY_MAP_EXT: Self = Self(16777216);
    #[doc(alias = "VK_FORMAT_FEATURE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR")]
    #[cfg(feature = "VK_KHR_fragment_shading_rate")]
    pub const FRAGMENT_SHADING_RATE_ATTACHMENT_KHR: Self = Self(1073741824);
    #[doc(alias = "VK_FORMAT_FEATURE_VIDEO_ENCODE_INPUT_BIT_KHR")]
    #[cfg(feature = "VK_KHR_video_encode_queue")]
    pub const VIDEO_ENCODE_INPUT_KHR: Self = Self(134217728);
    #[doc(alias = "VK_FORMAT_FEATURE_VIDEO_ENCODE_DPB_BIT_KHR")]
    #[cfg(feature = "VK_KHR_video_encode_queue")]
    pub const VIDEO_ENCODE_DPB_KHR: Self = Self(268435456);
    #[doc(alias = "VK_FORMAT_FEATURE_TRANSFER_SRC_BIT_KHR")]
    #[cfg(feature = "VK_KHR_maintenance1")]
    pub const TRANSFER_SRC_KHR: Self = Self::TRANSFER_SRC;
    #[doc(alias = "VK_FORMAT_FEATURE_TRANSFER_DST_BIT_KHR")]
    #[cfg(feature = "VK_KHR_maintenance1")]
    pub const TRANSFER_DST_KHR: Self = Self::TRANSFER_DST;
    #[doc(alias = "VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT")]
    #[cfg(feature = "VK_EXT_sampler_filter_minmax")]
    pub const SAMPLED_IMAGE_FILTER_MINMAX_EXT: Self = Self::SAMPLED_IMAGE_FILTER_MINMAX;
    #[doc(alias = "VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT_KHR")]
    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
    pub const MIDPOINT_CHROMA_SAMPLES_KHR: Self = Self::MIDPOINT_CHROMA_SAMPLES;
    #[doc(alias = "VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR")]
    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
    pub const SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_KHR: Self =
        Self::SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER;
    #[doc(alias = "VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR")]
    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
    pub const SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_KHR: Self =
        Self::SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER;
    #[doc(alias = "VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR")]
    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
    pub const SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_KHR: Self =
        Self::SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT;
    #[doc(alias = "VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR")]
    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
    pub const SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_KHR: Self =
        Self::SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE;
    #[doc(alias = "VK_FORMAT_FEATURE_DISJOINT_BIT_KHR")]
    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
    pub const DISJOINT_KHR: Self = Self::DISJOINT;
    #[doc(alias = "VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT_KHR")]
    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
    pub const COSITED_CHROMA_SAMPLES_KHR: Self = Self::COSITED_CHROMA_SAMPLES;
    #[doc(alias = "VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT")]
    #[cfg(feature = "VK_EXT_filter_cubic")]
    pub const SAMPLED_IMAGE_FILTER_CUBIC_EXT: Self = Self::SAMPLED_IMAGE_FILTER_CUBIC_IMG;
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        match bits {
            x if x == Self::SAMPLED_IMAGE.bits() => Some(Self(x)),
            x if x == Self::STORAGE_IMAGE.bits() => Some(Self(x)),
            x if x == Self::STORAGE_IMAGE_ATOMIC.bits() => Some(Self(x)),
            x if x == Self::UNIFORM_TEXEL_BUFFER.bits() => Some(Self(x)),
            x if x == Self::STORAGE_TEXEL_BUFFER.bits() => Some(Self(x)),
            x if x == Self::STORAGE_TEXEL_BUFFER_ATOMIC.bits() => Some(Self(x)),
            x if x == Self::VERTEX_BUFFER.bits() => Some(Self(x)),
            x if x == Self::COLOR_ATTACHMENT.bits() => Some(Self(x)),
            x if x == Self::COLOR_ATTACHMENT_BLEND.bits() => Some(Self(x)),
            x if x == Self::DEPTH_STENCIL_ATTACHMENT.bits() => Some(Self(x)),
            x if x == Self::BLIT_SRC.bits() => Some(Self(x)),
            x if x == Self::BLIT_DST.bits() => Some(Self(x)),
            x if x == Self::SAMPLED_IMAGE_FILTER_LINEAR.bits() => Some(Self(x)),
            x if x == Self::TRANSFER_SRC.bits() => Some(Self(x)),
            x if x == Self::TRANSFER_DST.bits() => Some(Self(x)),
            x if x == Self::MIDPOINT_CHROMA_SAMPLES.bits() => Some(Self(x)),
            x if x == Self::SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER.bits() => Some(Self(x)),
            x if x == Self::SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER.bits() => Some(Self(x)),
            x if x == Self::SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT.bits() => Some(Self(x)),
            x if x == Self::SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE.bits() => {
                Some(Self(x))
            },
            x if x == Self::DISJOINT.bits() => Some(Self(x)),
            x if x == Self::COSITED_CHROMA_SAMPLES.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::SAMPLED_IMAGE_FILTER_MINMAX.bits() => Some(Self(x)),
            #[cfg(feature = "VK_IMG_filter_cubic")]
            x if x == Self::SAMPLED_IMAGE_FILTER_CUBIC_IMG.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_video_decode_queue")]
            x if x == Self::VIDEO_DECODE_OUTPUT_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_video_decode_queue")]
            x if x == Self::VIDEO_DECODE_DPB_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_acceleration_structure")]
            x if x == Self::ACCELERATION_STRUCTURE_VERTEX_BUFFER_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_fragment_density_map")]
            x if x == Self::FRAGMENT_DENSITY_MAP_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_fragment_shading_rate")]
            x if x == Self::FRAGMENT_SHADING_RATE_ATTACHMENT_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_video_encode_queue")]
            x if x == Self::VIDEO_ENCODE_INPUT_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_video_encode_queue")]
            x if x == Self::VIDEO_ENCODE_DPB_KHR.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
}
# [doc = include_str ! ("../../../doc/VkQueryControlFlagBits.md")]
#[doc(alias = "VkQueryControlFlagBits")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct QueryControlFlagBits(u32);
impl QueryControlFlagBits {
    #[doc(alias = "VK_QUERY_CONTROL_PRECISE_BIT")]
    pub const PRECISE: Self = Self(1);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        match bits {
            x if x == Self::PRECISE.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
}
# [doc = include_str ! ("../../../doc/VkQueryResultFlagBits.md")]
#[doc(alias = "VkQueryResultFlagBits")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct QueryResultFlagBits(u32);
impl QueryResultFlagBits {
    #[doc(alias = "VK_QUERY_RESULT_64_BIT")]
    pub const N64: Self = Self(1);
    #[doc(alias = "VK_QUERY_RESULT_WAIT_BIT")]
    pub const WAIT: Self = Self(2);
    #[doc(alias = "VK_QUERY_RESULT_WITH_AVAILABILITY_BIT")]
    pub const WITH_AVAILABILITY: Self = Self(4);
    #[doc(alias = "VK_QUERY_RESULT_PARTIAL_BIT")]
    pub const PARTIAL: Self = Self(8);
    #[doc(alias = "VK_QUERY_RESULT_WITH_STATUS_BIT_KHR")]
    #[cfg(feature = "VK_KHR_video_queue")]
    pub const WITH_STATUS_KHR: Self = Self(16);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        match bits {
            x if x == Self::N64.bits() => Some(Self(x)),
            x if x == Self::WAIT.bits() => Some(Self(x)),
            x if x == Self::WITH_AVAILABILITY.bits() => Some(Self(x)),
            x if x == Self::PARTIAL.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_video_queue")]
            x if x == Self::WITH_STATUS_KHR.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
}
# [doc = include_str ! ("../../../doc/VkCommandBufferUsageFlagBits.md")]
#[doc(alias = "VkCommandBufferUsageFlagBits")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct CommandBufferUsageFlagBits(u32);
impl CommandBufferUsageFlagBits {
    #[doc(alias = "VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT")]
    pub const ONE_TIME_SUBMIT: Self = Self(1);
    #[doc(alias = "VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT")]
    pub const RENDER_PASS_CONTINUE: Self = Self(2);
    #[doc(alias = "VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT")]
    pub const SIMULTANEOUS_USE: Self = Self(4);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        match bits {
            x if x == Self::ONE_TIME_SUBMIT.bits() => Some(Self(x)),
            x if x == Self::RENDER_PASS_CONTINUE.bits() => Some(Self(x)),
            x if x == Self::SIMULTANEOUS_USE.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
}
# [doc = include_str ! ("../../../doc/VkQueryPipelineStatisticFlagBits.md")]
#[doc(alias = "VkQueryPipelineStatisticFlagBits")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct QueryPipelineStatisticFlagBits(u32);
impl QueryPipelineStatisticFlagBits {
    #[doc(alias = "VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT")]
    pub const INPUT_ASSEMBLY_VERTICES: Self = Self(1);
    #[doc(alias = "VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT")]
    pub const INPUT_ASSEMBLY_PRIMITIVES: Self = Self(2);
    #[doc(alias = "VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT")]
    pub const VERTEX_SHADER_INVOCATIONS: Self = Self(4);
    #[doc(alias = "VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT")]
    pub const GEOMETRY_SHADER_INVOCATIONS: Self = Self(8);
    #[doc(alias = "VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT")]
    pub const GEOMETRY_SHADER_PRIMITIVES: Self = Self(16);
    #[doc(alias = "VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT")]
    pub const CLIPPING_INVOCATIONS: Self = Self(32);
    #[doc(alias = "VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT")]
    pub const CLIPPING_PRIMITIVES: Self = Self(64);
    #[doc(alias = "VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT")]
    pub const FRAGMENT_SHADER_INVOCATIONS: Self = Self(128);
    #[doc(alias = "VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT")]
    pub const TESSELLATION_CONTROL_SHADER_PATCHES: Self = Self(256);
    #[doc(alias = "VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT")]
    pub const TESSELLATION_EVALUATION_SHADER_INVOCATIONS: Self = Self(512);
    #[doc(alias = "VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT")]
    pub const COMPUTE_SHADER_INVOCATIONS: Self = Self(1024);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        match bits {
            x if x == Self::INPUT_ASSEMBLY_VERTICES.bits() => Some(Self(x)),
            x if x == Self::INPUT_ASSEMBLY_PRIMITIVES.bits() => Some(Self(x)),
            x if x == Self::VERTEX_SHADER_INVOCATIONS.bits() => Some(Self(x)),
            x if x == Self::GEOMETRY_SHADER_INVOCATIONS.bits() => Some(Self(x)),
            x if x == Self::GEOMETRY_SHADER_PRIMITIVES.bits() => Some(Self(x)),
            x if x == Self::CLIPPING_INVOCATIONS.bits() => Some(Self(x)),
            x if x == Self::CLIPPING_PRIMITIVES.bits() => Some(Self(x)),
            x if x == Self::FRAGMENT_SHADER_INVOCATIONS.bits() => Some(Self(x)),
            x if x == Self::TESSELLATION_CONTROL_SHADER_PATCHES.bits() => Some(Self(x)),
            x if x == Self::TESSELLATION_EVALUATION_SHADER_INVOCATIONS.bits() => Some(Self(x)),
            x if x == Self::COMPUTE_SHADER_INVOCATIONS.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
}
# [doc = include_str ! ("../../../doc/VkImageAspectFlagBits.md")]
#[doc(alias = "VkImageAspectFlagBits")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct ImageAspectFlagBits(u32);
impl ImageAspectFlagBits {
    #[doc(alias = "VK_IMAGE_ASPECT_COLOR_BIT")]
    pub const COLOR: Self = Self(1);
    #[doc(alias = "VK_IMAGE_ASPECT_DEPTH_BIT")]
    pub const DEPTH: Self = Self(2);
    #[doc(alias = "VK_IMAGE_ASPECT_STENCIL_BIT")]
    pub const STENCIL: Self = Self(4);
    #[doc(alias = "VK_IMAGE_ASPECT_METADATA_BIT")]
    pub const METADATA: Self = Self(8);
    #[doc(alias = "VK_IMAGE_ASPECT_PLANE_0_BIT")]
    pub const PLANE0: Self = Self(16);
    #[doc(alias = "VK_IMAGE_ASPECT_PLANE_1_BIT")]
    pub const PLANE1: Self = Self(32);
    #[doc(alias = "VK_IMAGE_ASPECT_PLANE_2_BIT")]
    pub const PLANE2: Self = Self(64);
    #[doc(alias = "VK_IMAGE_ASPECT_NONE")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const NONE: Self = Self(0);
    #[doc(alias = "VK_IMAGE_ASPECT_MEMORY_PLANE_0_BIT_EXT")]
    #[cfg(feature = "VK_EXT_image_drm_format_modifier")]
    pub const MEMORY_PLANE0_EXT: Self = Self(128);
    #[doc(alias = "VK_IMAGE_ASPECT_MEMORY_PLANE_1_BIT_EXT")]
    #[cfg(feature = "VK_EXT_image_drm_format_modifier")]
    pub const MEMORY_PLANE1_EXT: Self = Self(256);
    #[doc(alias = "VK_IMAGE_ASPECT_MEMORY_PLANE_2_BIT_EXT")]
    #[cfg(feature = "VK_EXT_image_drm_format_modifier")]
    pub const MEMORY_PLANE2_EXT: Self = Self(512);
    #[doc(alias = "VK_IMAGE_ASPECT_MEMORY_PLANE_3_BIT_EXT")]
    #[cfg(feature = "VK_EXT_image_drm_format_modifier")]
    pub const MEMORY_PLANE3_EXT: Self = Self(1024);
    #[doc(alias = "VK_IMAGE_ASPECT_PLANE_0_BIT_KHR")]
    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
    pub const PLANE0_KHR: Self = Self::PLANE0;
    #[doc(alias = "VK_IMAGE_ASPECT_PLANE_1_BIT_KHR")]
    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
    pub const PLANE1_KHR: Self = Self::PLANE1;
    #[doc(alias = "VK_IMAGE_ASPECT_PLANE_2_BIT_KHR")]
    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
    pub const PLANE2_KHR: Self = Self::PLANE2;
    #[doc(alias = "VK_IMAGE_ASPECT_NONE_KHR")]
    #[cfg(feature = "VK_KHR_maintenance4")]
    pub const NONE_KHR: Self = Self::NONE;
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        match bits {
            x if x == Self::COLOR.bits() => Some(Self(x)),
            x if x == Self::DEPTH.bits() => Some(Self(x)),
            x if x == Self::STENCIL.bits() => Some(Self(x)),
            x if x == Self::METADATA.bits() => Some(Self(x)),
            x if x == Self::PLANE0.bits() => Some(Self(x)),
            x if x == Self::PLANE1.bits() => Some(Self(x)),
            x if x == Self::PLANE2.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::NONE.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_image_drm_format_modifier")]
            x if x == Self::MEMORY_PLANE0_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_image_drm_format_modifier")]
            x if x == Self::MEMORY_PLANE1_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_image_drm_format_modifier")]
            x if x == Self::MEMORY_PLANE2_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_image_drm_format_modifier")]
            x if x == Self::MEMORY_PLANE3_EXT.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
}
# [doc = include_str ! ("../../../doc/VkSparseImageFormatFlagBits.md")]
#[doc(alias = "VkSparseImageFormatFlagBits")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct SparseImageFormatFlagBits(u32);
impl SparseImageFormatFlagBits {
    #[doc(alias = "VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT")]
    pub const SINGLE_MIPTAIL: Self = Self(1);
    #[doc(alias = "VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT")]
    pub const ALIGNED_MIP_SIZE: Self = Self(2);
    #[doc(alias = "VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT")]
    pub const NONSTANDARD_BLOCK_SIZE: Self = Self(4);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        match bits {
            x if x == Self::SINGLE_MIPTAIL.bits() => Some(Self(x)),
            x if x == Self::ALIGNED_MIP_SIZE.bits() => Some(Self(x)),
            x if x == Self::NONSTANDARD_BLOCK_SIZE.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
}
# [doc = include_str ! ("../../../doc/VkSparseMemoryBindFlagBits.md")]
#[doc(alias = "VkSparseMemoryBindFlagBits")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct SparseMemoryBindFlagBits(u32);
impl SparseMemoryBindFlagBits {
    #[doc(alias = "VK_SPARSE_MEMORY_BIND_METADATA_BIT")]
    pub const METADATA: Self = Self(1);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        match bits {
            x if x == Self::METADATA.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
}
# [doc = include_str ! ("../../../doc/VkPipelineStageFlagBits.md")]
#[doc(alias = "VkPipelineStageFlagBits")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct PipelineStageFlagBits(u32);
impl PipelineStageFlagBits {
    #[doc(alias = "VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT")]
    pub const TOP_OF_PIPE: Self = Self(1);
    #[doc(alias = "VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT")]
    pub const DRAW_INDIRECT: Self = Self(2);
    #[doc(alias = "VK_PIPELINE_STAGE_VERTEX_INPUT_BIT")]
    pub const VERTEX_INPUT: Self = Self(4);
    #[doc(alias = "VK_PIPELINE_STAGE_VERTEX_SHADER_BIT")]
    pub const VERTEX_SHADER: Self = Self(8);
    #[doc(alias = "VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT")]
    pub const TESSELLATION_CONTROL_SHADER: Self = Self(16);
    #[doc(alias = "VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT")]
    pub const TESSELLATION_EVALUATION_SHADER: Self = Self(32);
    #[doc(alias = "VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT")]
    pub const GEOMETRY_SHADER: Self = Self(64);
    #[doc(alias = "VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT")]
    pub const FRAGMENT_SHADER: Self = Self(128);
    #[doc(alias = "VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT")]
    pub const EARLY_FRAGMENT_TESTS: Self = Self(256);
    #[doc(alias = "VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT")]
    pub const LATE_FRAGMENT_TESTS: Self = Self(512);
    #[doc(alias = "VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT")]
    pub const COLOR_ATTACHMENT_OUTPUT: Self = Self(1024);
    #[doc(alias = "VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT")]
    pub const COMPUTE_SHADER: Self = Self(2048);
    #[doc(alias = "VK_PIPELINE_STAGE_TRANSFER_BIT")]
    pub const TRANSFER: Self = Self(4096);
    #[doc(alias = "VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT")]
    pub const BOTTOM_OF_PIPE: Self = Self(8192);
    #[doc(alias = "VK_PIPELINE_STAGE_HOST_BIT")]
    pub const HOST: Self = Self(16384);
    #[doc(alias = "VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT")]
    pub const ALL_GRAPHICS: Self = Self(32768);
    #[doc(alias = "VK_PIPELINE_STAGE_ALL_COMMANDS_BIT")]
    pub const ALL_COMMANDS: Self = Self(65536);
    #[doc(alias = "VK_PIPELINE_STAGE_NONE")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const NONE: Self = Self(0);
    #[doc(alias = "VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT")]
    #[cfg(feature = "VK_EXT_transform_feedback")]
    pub const TRANSFORM_FEEDBACK_EXT: Self = Self(16777216);
    #[doc(alias = "VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT")]
    #[cfg(feature = "VK_EXT_conditional_rendering")]
    pub const CONDITIONAL_RENDERING_EXT: Self = Self(262144);
    #[doc(alias = "VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR")]
    #[cfg(feature = "VK_KHR_acceleration_structure")]
    pub const ACCELERATION_STRUCTURE_BUILD_KHR: Self = Self(33554432);
    #[doc(alias = "VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_KHR")]
    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
    pub const RAY_TRACING_SHADER_KHR: Self = Self(2097152);
    #[doc(alias = "VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV")]
    #[cfg(feature = "VK_NV_mesh_shader")]
    pub const TASK_SHADER_NV: Self = Self(524288);
    #[doc(alias = "VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV")]
    #[cfg(feature = "VK_NV_mesh_shader")]
    pub const MESH_SHADER_NV: Self = Self(1048576);
    #[doc(alias = "VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT")]
    #[cfg(feature = "VK_EXT_fragment_density_map")]
    pub const FRAGMENT_DENSITY_PROCESS_EXT: Self = Self(8388608);
    #[doc(alias = "VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR")]
    #[cfg(feature = "VK_KHR_fragment_shading_rate")]
    pub const FRAGMENT_SHADING_RATE_ATTACHMENT_KHR: Self = Self(4194304);
    #[doc(alias = "VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_NV")]
    #[cfg(feature = "VK_NV_device_generated_commands")]
    pub const COMMAND_PREPROCESS_NV: Self = Self(131072);
    #[doc(alias = "VK_PIPELINE_STAGE_SHADING_RATE_IMAGE_BIT_NV")]
    #[cfg(feature = "VK_NV_shading_rate_image")]
    pub const SHADING_RATE_IMAGE_NV: Self = Self::FRAGMENT_SHADING_RATE_ATTACHMENT_KHR;
    #[doc(alias = "VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_NV")]
    #[cfg(feature = "VK_NV_ray_tracing")]
    pub const RAY_TRACING_SHADER_NV: Self = Self::RAY_TRACING_SHADER_KHR;
    #[doc(alias = "VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_NV")]
    #[cfg(feature = "VK_NV_ray_tracing")]
    pub const ACCELERATION_STRUCTURE_BUILD_NV: Self = Self::ACCELERATION_STRUCTURE_BUILD_KHR;
    #[doc(alias = "VK_PIPELINE_STAGE_NONE_KHR")]
    #[cfg(feature = "VK_KHR_synchronization2")]
    pub const NONE_KHR: Self = Self::NONE;
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        match bits {
            x if x == Self::TOP_OF_PIPE.bits() => Some(Self(x)),
            x if x == Self::DRAW_INDIRECT.bits() => Some(Self(x)),
            x if x == Self::VERTEX_INPUT.bits() => Some(Self(x)),
            x if x == Self::VERTEX_SHADER.bits() => Some(Self(x)),
            x if x == Self::TESSELLATION_CONTROL_SHADER.bits() => Some(Self(x)),
            x if x == Self::TESSELLATION_EVALUATION_SHADER.bits() => Some(Self(x)),
            x if x == Self::GEOMETRY_SHADER.bits() => Some(Self(x)),
            x if x == Self::FRAGMENT_SHADER.bits() => Some(Self(x)),
            x if x == Self::EARLY_FRAGMENT_TESTS.bits() => Some(Self(x)),
            x if x == Self::LATE_FRAGMENT_TESTS.bits() => Some(Self(x)),
            x if x == Self::COLOR_ATTACHMENT_OUTPUT.bits() => Some(Self(x)),
            x if x == Self::COMPUTE_SHADER.bits() => Some(Self(x)),
            x if x == Self::TRANSFER.bits() => Some(Self(x)),
            x if x == Self::BOTTOM_OF_PIPE.bits() => Some(Self(x)),
            x if x == Self::HOST.bits() => Some(Self(x)),
            x if x == Self::ALL_GRAPHICS.bits() => Some(Self(x)),
            x if x == Self::ALL_COMMANDS.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::NONE.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_transform_feedback")]
            x if x == Self::TRANSFORM_FEEDBACK_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_conditional_rendering")]
            x if x == Self::CONDITIONAL_RENDERING_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_acceleration_structure")]
            x if x == Self::ACCELERATION_STRUCTURE_BUILD_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
            x if x == Self::RAY_TRACING_SHADER_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_mesh_shader")]
            x if x == Self::TASK_SHADER_NV.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_mesh_shader")]
            x if x == Self::MESH_SHADER_NV.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_fragment_density_map")]
            x if x == Self::FRAGMENT_DENSITY_PROCESS_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_fragment_shading_rate")]
            x if x == Self::FRAGMENT_SHADING_RATE_ATTACHMENT_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_device_generated_commands")]
            x if x == Self::COMMAND_PREPROCESS_NV.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
}
# [doc = include_str ! ("../../../doc/VkCommandPoolCreateFlagBits.md")]
#[doc(alias = "VkCommandPoolCreateFlagBits")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct CommandPoolCreateFlagBits(u32);
impl CommandPoolCreateFlagBits {
    #[doc(alias = "VK_COMMAND_POOL_CREATE_TRANSIENT_BIT")]
    pub const TRANSIENT: Self = Self(1);
    #[doc(alias = "VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT")]
    pub const RESET_COMMAND_BUFFER: Self = Self(2);
    #[doc(alias = "VK_COMMAND_POOL_CREATE_PROTECTED_BIT")]
    pub const PROTECTED: Self = Self(4);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        match bits {
            x if x == Self::TRANSIENT.bits() => Some(Self(x)),
            x if x == Self::RESET_COMMAND_BUFFER.bits() => Some(Self(x)),
            x if x == Self::PROTECTED.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
}
# [doc = include_str ! ("../../../doc/VkCommandPoolResetFlagBits.md")]
#[doc(alias = "VkCommandPoolResetFlagBits")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct CommandPoolResetFlagBits(u32);
impl CommandPoolResetFlagBits {
    #[doc(alias = "VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT")]
    pub const RELEASE_RESOURCES: Self = Self(1);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        match bits {
            x if x == Self::RELEASE_RESOURCES.bits() => Some(Self(x)),
            #[cfg(feature = "VK_COREAVI_extension_444")]
            x if x == Self::RESERVED1_COREAVI.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
}
# [doc = include_str ! ("../../../doc/VkCommandBufferResetFlagBits.md")]
#[doc(alias = "VkCommandBufferResetFlagBits")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct CommandBufferResetFlagBits(u32);
impl CommandBufferResetFlagBits {
    #[doc(alias = "VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT")]
    pub const RELEASE_RESOURCES: Self = Self(1);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        match bits {
            x if x == Self::RELEASE_RESOURCES.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
}
# [doc = include_str ! ("../../../doc/VkSampleCountFlagBits.md")]
#[doc(alias = "VkSampleCountFlagBits")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct SampleCountFlagBits(u32);
impl SampleCountFlagBits {
    #[doc(alias = "VK_SAMPLE_COUNT_1_BIT")]
    pub const N1: Self = Self(1);
    #[doc(alias = "VK_SAMPLE_COUNT_2_BIT")]
    pub const N2: Self = Self(2);
    #[doc(alias = "VK_SAMPLE_COUNT_4_BIT")]
    pub const N4: Self = Self(4);
    #[doc(alias = "VK_SAMPLE_COUNT_8_BIT")]
    pub const N8: Self = Self(8);
    #[doc(alias = "VK_SAMPLE_COUNT_16_BIT")]
    pub const N16: Self = Self(16);
    #[doc(alias = "VK_SAMPLE_COUNT_32_BIT")]
    pub const N32: Self = Self(32);
    #[doc(alias = "VK_SAMPLE_COUNT_64_BIT")]
    pub const N64: Self = Self(64);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        match bits {
            x if x == Self::N1.bits() => Some(Self(x)),
            x if x == Self::N2.bits() => Some(Self(x)),
            x if x == Self::N4.bits() => Some(Self(x)),
            x if x == Self::N8.bits() => Some(Self(x)),
            x if x == Self::N16.bits() => Some(Self(x)),
            x if x == Self::N32.bits() => Some(Self(x)),
            x if x == Self::N64.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
}
# [doc = include_str ! ("../../../doc/VkAttachmentDescriptionFlagBits.md")]
#[doc(alias = "VkAttachmentDescriptionFlagBits")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct AttachmentDescriptionFlagBits(u32);
impl AttachmentDescriptionFlagBits {
    #[doc(alias = "VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT")]
    pub const MAY_ALIAS: Self = Self(1);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        match bits {
            x if x == Self::MAY_ALIAS.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
}
# [doc = include_str ! ("../../../doc/VkStencilFaceFlagBits.md")]
#[doc(alias = "VkStencilFaceFlagBits")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct StencilFaceFlagBits(u32);
impl StencilFaceFlagBits {
    #[doc(alias = "VK_STENCIL_FACE_FRONT_BIT")]
    pub const FRONT: Self = Self(1);
    #[doc(alias = "VK_STENCIL_FACE_BACK_BIT")]
    pub const BACK: Self = Self(2);
    #[doc(alias = "VK_STENCIL_FACE_FRONT_AND_BACK")]
    pub const FRONT_AND_BACK: Self = Self(3);
    #[doc(alias = "VK_STENCIL_FRONT_AND_BACK")]
    pub const STENCIL_FRONT_AND_BACK: Self = Self::FRONT_AND_BACK;
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        match bits {
            x if x == Self::FRONT.bits() => Some(Self(x)),
            x if x == Self::BACK.bits() => Some(Self(x)),
            x if x == Self::FRONT_AND_BACK.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
}
# [doc = include_str ! ("../../../doc/VkDescriptorPoolCreateFlagBits.md")]
#[doc(alias = "VkDescriptorPoolCreateFlagBits")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct DescriptorPoolCreateFlagBits(u32);
impl DescriptorPoolCreateFlagBits {
    #[doc(alias = "VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT")]
    pub const FREE_DESCRIPTOR_SET: Self = Self(1);
    #[doc(alias = "VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT")]
    #[cfg(feature = "VULKAN_1_2")]
    pub const UPDATE_AFTER_BIND: Self = Self(2);
    #[doc(alias = "VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_VALVE")]
    #[cfg(feature = "VK_VALVE_mutable_descriptor_type")]
    pub const HOST_ONLY_VALVE: Self = Self(4);
    #[doc(alias = "VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT")]
    #[cfg(feature = "VK_EXT_descriptor_indexing")]
    pub const UPDATE_AFTER_BIND_EXT: Self = Self::UPDATE_AFTER_BIND;
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        match bits {
            x if x == Self::FREE_DESCRIPTOR_SET.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::UPDATE_AFTER_BIND.bits() => Some(Self(x)),
            #[cfg(feature = "VK_VALVE_mutable_descriptor_type")]
            x if x == Self::HOST_ONLY_VALVE.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
}
# [doc = include_str ! ("../../../doc/VkDependencyFlagBits.md")]
#[doc(alias = "VkDependencyFlagBits")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct DependencyFlagBits(u32);
impl DependencyFlagBits {
    #[doc(alias = "VK_DEPENDENCY_BY_REGION_BIT")]
    pub const BY_REGION: Self = Self(1);
    #[doc(alias = "VK_DEPENDENCY_DEVICE_GROUP_BIT")]
    pub const DEVICE_GROUP: Self = Self(4);
    #[doc(alias = "VK_DEPENDENCY_VIEW_LOCAL_BIT")]
    pub const VIEW_LOCAL: Self = Self(2);
    #[doc(alias = "VK_DEPENDENCY_VIEW_LOCAL_BIT_KHR")]
    #[cfg(feature = "VK_KHR_multiview")]
    pub const VIEW_LOCAL_KHR: Self = Self::VIEW_LOCAL;
    #[doc(alias = "VK_DEPENDENCY_DEVICE_GROUP_BIT_KHR")]
    #[cfg(feature = "VK_KHR_device_group")]
    pub const DEVICE_GROUP_KHR: Self = Self::DEVICE_GROUP;
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        match bits {
            x if x == Self::BY_REGION.bits() => Some(Self(x)),
            x if x == Self::DEVICE_GROUP.bits() => Some(Self(x)),
            x if x == Self::VIEW_LOCAL.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
}
# [doc = include_str ! ("../../../doc/VkDescriptorSetLayoutCreateFlagBits.md")]
#[doc(alias = "VkDescriptorSetLayoutCreateFlagBits")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct DescriptorSetLayoutCreateFlagBits(u32);
impl DescriptorSetLayoutCreateFlagBits {
    #[doc(alias = "VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT")]
    #[cfg(feature = "VULKAN_1_2")]
    pub const UPDATE_AFTER_BIND_POOL: Self = Self(2);
    #[doc(alias = "VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR")]
    #[cfg(feature = "VK_KHR_push_descriptor")]
    pub const PUSH_DESCRIPTOR_KHR: Self = Self(1);
    #[doc(alias = "VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_VALVE")]
    #[cfg(feature = "VK_VALVE_mutable_descriptor_type")]
    pub const HOST_ONLY_POOL_VALVE: Self = Self(4);
    #[doc(alias = "VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT")]
    #[cfg(feature = "VK_EXT_descriptor_indexing")]
    pub const UPDATE_AFTER_BIND_POOL_EXT: Self = Self::UPDATE_AFTER_BIND_POOL;
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        match bits {
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::UPDATE_AFTER_BIND_POOL.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_push_descriptor")]
            x if x == Self::PUSH_DESCRIPTOR_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_AMD_extension_317")]
            x if x == Self::RESERVED4_AMD.bits() => Some(Self(x)),
            #[cfg(feature = "VK_AMD_extension_319")]
            x if x == Self::RESERVED3_AMD.bits() => Some(Self(x)),
            #[cfg(feature = "VK_VALVE_mutable_descriptor_type")]
            x if x == Self::HOST_ONLY_POOL_VALVE.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
}
# [doc = include_str ! ("../../../doc/VkSubpassDescriptionFlagBits.md")]
#[doc(alias = "VkSubpassDescriptionFlagBits")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct SubpassDescriptionFlagBits(u32);
impl SubpassDescriptionFlagBits {
    #[doc(alias = "VK_SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX")]
    #[cfg(feature = "VK_NVX_multiview_per_view_attributes")]
    pub const PER_VIEW_ATTRIBUTES_NVX: Self = Self(1);
    #[doc(alias = "VK_SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX")]
    #[cfg(feature = "VK_NVX_multiview_per_view_attributes")]
    pub const PER_VIEW_POSITION_X_ONLY_NVX: Self = Self(2);
    #[doc(alias = "VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_COLOR_ACCESS_BIT_ARM")]
    #[cfg(feature = "VK_ARM_rasterization_order_attachment_access")]
    pub const RASTERIZATION_ORDER_ATTACHMENT_COLOR_ACCESS_ARM: Self = Self(16);
    #[doc(alias = "VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_ARM")]
    #[cfg(feature = "VK_ARM_rasterization_order_attachment_access")]
    pub const RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_ARM: Self = Self(32);
    #[doc(alias = "VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_ARM")]
    #[cfg(feature = "VK_ARM_rasterization_order_attachment_access")]
    pub const RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_ARM: Self = Self(64);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        match bits {
            #[cfg(feature = "VK_NVX_multiview_per_view_attributes")]
            x if x == Self::PER_VIEW_ATTRIBUTES_NVX.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NVX_multiview_per_view_attributes")]
            x if x == Self::PER_VIEW_POSITION_X_ONLY_NVX.bits() => Some(Self(x)),
            #[cfg(feature = "VK_QCOM_render_pass_shader_resolve")]
            x if x == Self::FRAGMENT_REGION_QCOM.bits() => Some(Self(x)),
            #[cfg(feature = "VK_QCOM_render_pass_shader_resolve")]
            x if x == Self::SHADER_RESOLVE_QCOM.bits() => Some(Self(x)),
            #[cfg(feature = "VK_ARM_rasterization_order_attachment_access")]
            x if x == Self::RASTERIZATION_ORDER_ATTACHMENT_COLOR_ACCESS_ARM.bits() => Some(Self(x)),
            #[cfg(feature = "VK_ARM_rasterization_order_attachment_access")]
            x if x == Self::RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_ARM.bits() => Some(Self(x)),
            #[cfg(feature = "VK_ARM_rasterization_order_attachment_access")]
            x if x == Self::RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_ARM.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
}
# [doc = include_str ! ("../../../doc/VkFramebufferCreateFlagBits.md")]
#[doc(alias = "VkFramebufferCreateFlagBits")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct FramebufferCreateFlagBits(u32);
impl FramebufferCreateFlagBits {
    #[doc(alias = "VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT")]
    #[cfg(feature = "VULKAN_1_2")]
    pub const IMAGELESS: Self = Self(1);
    #[doc(alias = "VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT_KHR")]
    #[cfg(feature = "VK_KHR_imageless_framebuffer")]
    pub const IMAGELESS_KHR: Self = Self::IMAGELESS;
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        match bits {
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::IMAGELESS.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
}
# [doc = include_str ! ("../../../doc/VkEventCreateFlagBits.md")]
#[doc(alias = "VkEventCreateFlagBits")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct EventCreateFlagBits(u32);
impl EventCreateFlagBits {
    #[doc(alias = "VK_EVENT_CREATE_DEVICE_ONLY_BIT")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const DEVICE_ONLY: Self = Self(1);
    #[doc(alias = "VK_EVENT_CREATE_DEVICE_ONLY_BIT_KHR")]
    #[cfg(feature = "VK_KHR_synchronization2")]
    pub const DEVICE_ONLY_KHR: Self = Self::DEVICE_ONLY;
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        match bits {
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::DEVICE_ONLY.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
}
# [doc = include_str ! ("../../../doc/VkInstanceCreateFlagBits.md")]
#[doc(alias = "VkInstanceCreateFlagBits")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct InstanceCreateFlagBits(u32);
impl InstanceCreateFlagBits {
    #[doc(alias = "VK_INSTANCE_CREATE_ENUMERATE_PORTABILITY_BIT_KHR")]
    #[cfg(feature = "VK_KHR_portability_enumeration")]
    pub const ENUMERATE_PORTABILITY_KHR: Self = Self(1);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        match bits {
            #[cfg(feature = "VK_KHR_portability_enumeration")]
            x if x == Self::ENUMERATE_PORTABILITY_KHR.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
}
# [doc = include_str ! ("../../../doc/VkImageLayout.md")]
#[doc(alias = "VkImageLayout")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct ImageLayout(i32);
impl ImageLayout {
    #[doc(alias = "VK_IMAGE_LAYOUT_UNDEFINED")]
    pub const UNDEFINED: Self = Self(0);
    #[doc(alias = "VK_IMAGE_LAYOUT_GENERAL")]
    pub const GENERAL: Self = Self(1);
    #[doc(alias = "VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL")]
    pub const COLOR_ATTACHMENT_OPTIMAL: Self = Self(2);
    #[doc(alias = "VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL")]
    pub const DEPTH_STENCIL_ATTACHMENT_OPTIMAL: Self = Self(3);
    #[doc(alias = "VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL")]
    pub const DEPTH_STENCIL_READ_ONLY_OPTIMAL: Self = Self(4);
    #[doc(alias = "VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL")]
    pub const SHADER_READ_ONLY_OPTIMAL: Self = Self(5);
    #[doc(alias = "VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL")]
    pub const TRANSFER_SRC_OPTIMAL: Self = Self(6);
    #[doc(alias = "VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL")]
    pub const TRANSFER_DST_OPTIMAL: Self = Self(7);
    #[doc(alias = "VK_IMAGE_LAYOUT_PREINITIALIZED")]
    pub const PREINITIALIZED: Self = Self(8);
    #[doc(alias = "VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL")]
    pub const DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL: Self = Self(1000117000);
    #[doc(alias = "VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL")]
    pub const DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL: Self = Self(1000117001);
    #[doc(alias = "VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL")]
    #[cfg(feature = "VULKAN_1_2")]
    pub const DEPTH_ATTACHMENT_OPTIMAL: Self = Self(1000241000);
    #[doc(alias = "VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL")]
    #[cfg(feature = "VULKAN_1_2")]
    pub const DEPTH_READ_ONLY_OPTIMAL: Self = Self(1000241001);
    #[doc(alias = "VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL")]
    #[cfg(feature = "VULKAN_1_2")]
    pub const STENCIL_ATTACHMENT_OPTIMAL: Self = Self(1000241002);
    #[doc(alias = "VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL")]
    #[cfg(feature = "VULKAN_1_2")]
    pub const STENCIL_READ_ONLY_OPTIMAL: Self = Self(1000241003);
    #[doc(alias = "VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const READ_ONLY_OPTIMAL: Self = Self(1000314000);
    #[doc(alias = "VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const ATTACHMENT_OPTIMAL: Self = Self(1000314001);
    #[doc(alias = "VK_IMAGE_LAYOUT_PRESENT_SRC_KHR")]
    #[cfg(feature = "VK_KHR_swapchain")]
    pub const PRESENT_SRC_KHR: Self = Self(1000001002);
    #[doc(alias = "VK_IMAGE_LAYOUT_VIDEO_DECODE_DST_KHR")]
    #[cfg(feature = "VK_KHR_video_decode_queue")]
    pub const VIDEO_DECODE_DST_KHR: Self = Self(1000024000);
    #[doc(alias = "VK_IMAGE_LAYOUT_VIDEO_DECODE_SRC_KHR")]
    #[cfg(feature = "VK_KHR_video_decode_queue")]
    pub const VIDEO_DECODE_SRC_KHR: Self = Self(1000024001);
    #[doc(alias = "VK_IMAGE_LAYOUT_VIDEO_DECODE_DPB_KHR")]
    #[cfg(feature = "VK_KHR_video_decode_queue")]
    pub const VIDEO_DECODE_DPB_KHR: Self = Self(1000024002);
    #[doc(alias = "VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR")]
    #[cfg(feature = "VK_KHR_shared_presentable_image")]
    pub const SHARED_PRESENT_KHR: Self = Self(1000111000);
    #[doc(alias = "VK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT")]
    #[cfg(feature = "VK_EXT_fragment_density_map")]
    pub const FRAGMENT_DENSITY_MAP_OPTIMAL_EXT: Self = Self(1000218000);
    #[doc(alias = "VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR")]
    #[cfg(feature = "VK_KHR_fragment_shading_rate")]
    pub const FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR: Self = Self(1000164003);
    #[doc(alias = "VK_IMAGE_LAYOUT_VIDEO_ENCODE_DST_KHR")]
    #[cfg(feature = "VK_KHR_video_encode_queue")]
    pub const VIDEO_ENCODE_DST_KHR: Self = Self(1000299000);
    #[doc(alias = "VK_IMAGE_LAYOUT_VIDEO_ENCODE_SRC_KHR")]
    #[cfg(feature = "VK_KHR_video_encode_queue")]
    pub const VIDEO_ENCODE_SRC_KHR: Self = Self(1000299001);
    #[doc(alias = "VK_IMAGE_LAYOUT_VIDEO_ENCODE_DPB_KHR")]
    #[cfg(feature = "VK_KHR_video_encode_queue")]
    pub const VIDEO_ENCODE_DPB_KHR: Self = Self(1000299002);
    #[doc(alias = "VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL_KHR")]
    #[cfg(feature = "VK_KHR_maintenance2")]
    pub const DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL_KHR: Self = Self::DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL;
    #[doc(alias = "VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL_KHR")]
    #[cfg(feature = "VK_KHR_maintenance2")]
    pub const DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL_KHR: Self = Self::DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL;
    #[doc(alias = "VK_IMAGE_LAYOUT_SHADING_RATE_OPTIMAL_NV")]
    #[cfg(feature = "VK_NV_shading_rate_image")]
    pub const SHADING_RATE_OPTIMAL_NV: Self = Self::FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR;
    #[doc(alias = "VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL_KHR")]
    #[cfg(feature = "VK_KHR_separate_depth_stencil_layouts")]
    pub const DEPTH_ATTACHMENT_OPTIMAL_KHR: Self = Self::DEPTH_ATTACHMENT_OPTIMAL;
    #[doc(alias = "VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL_KHR")]
    #[cfg(feature = "VK_KHR_separate_depth_stencil_layouts")]
    pub const DEPTH_READ_ONLY_OPTIMAL_KHR: Self = Self::DEPTH_READ_ONLY_OPTIMAL;
    #[doc(alias = "VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL_KHR")]
    #[cfg(feature = "VK_KHR_separate_depth_stencil_layouts")]
    pub const STENCIL_ATTACHMENT_OPTIMAL_KHR: Self = Self::STENCIL_ATTACHMENT_OPTIMAL;
    #[doc(alias = "VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL_KHR")]
    #[cfg(feature = "VK_KHR_separate_depth_stencil_layouts")]
    pub const STENCIL_READ_ONLY_OPTIMAL_KHR: Self = Self::STENCIL_READ_ONLY_OPTIMAL;
    #[doc(alias = "VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL_KHR")]
    #[cfg(feature = "VK_KHR_synchronization2")]
    pub const READ_ONLY_OPTIMAL_KHR: Self = Self::READ_ONLY_OPTIMAL;
    #[doc(alias = "VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL_KHR")]
    #[cfg(feature = "VK_KHR_synchronization2")]
    pub const ATTACHMENT_OPTIMAL_KHR: Self = Self::ATTACHMENT_OPTIMAL;
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> i32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: i32) -> Option<Self> {
        match bits {
            x if x == Self::UNDEFINED.bits() => Some(Self(x)),
            x if x == Self::GENERAL.bits() => Some(Self(x)),
            x if x == Self::COLOR_ATTACHMENT_OPTIMAL.bits() => Some(Self(x)),
            x if x == Self::DEPTH_STENCIL_ATTACHMENT_OPTIMAL.bits() => Some(Self(x)),
            x if x == Self::DEPTH_STENCIL_READ_ONLY_OPTIMAL.bits() => Some(Self(x)),
            x if x == Self::SHADER_READ_ONLY_OPTIMAL.bits() => Some(Self(x)),
            x if x == Self::TRANSFER_SRC_OPTIMAL.bits() => Some(Self(x)),
            x if x == Self::TRANSFER_DST_OPTIMAL.bits() => Some(Self(x)),
            x if x == Self::PREINITIALIZED.bits() => Some(Self(x)),
            x if x == Self::DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL.bits() => Some(Self(x)),
            x if x == Self::DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::DEPTH_ATTACHMENT_OPTIMAL.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::DEPTH_READ_ONLY_OPTIMAL.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::STENCIL_ATTACHMENT_OPTIMAL.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::STENCIL_READ_ONLY_OPTIMAL.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::READ_ONLY_OPTIMAL.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::ATTACHMENT_OPTIMAL.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_swapchain")]
            x if x == Self::PRESENT_SRC_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_video_decode_queue")]
            x if x == Self::VIDEO_DECODE_DST_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_video_decode_queue")]
            x if x == Self::VIDEO_DECODE_SRC_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_video_decode_queue")]
            x if x == Self::VIDEO_DECODE_DPB_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_shared_presentable_image")]
            x if x == Self::SHARED_PRESENT_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_fragment_density_map")]
            x if x == Self::FRAGMENT_DENSITY_MAP_OPTIMAL_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_fragment_shading_rate")]
            x if x == Self::FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_video_encode_queue")]
            x if x == Self::VIDEO_ENCODE_DST_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_video_encode_queue")]
            x if x == Self::VIDEO_ENCODE_SRC_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_video_encode_queue")]
            x if x == Self::VIDEO_ENCODE_DPB_KHR.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: i32) -> Self {
        Self(bits)
    }
}
# [doc = include_str ! ("../../../doc/VkAttachmentLoadOp.md")]
#[doc(alias = "VkAttachmentLoadOp")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct AttachmentLoadOp(i32);
impl AttachmentLoadOp {
    #[doc(alias = "VK_ATTACHMENT_LOAD_OP_LOAD")]
    pub const LOAD: Self = Self(0);
    #[doc(alias = "VK_ATTACHMENT_LOAD_OP_CLEAR")]
    pub const CLEAR: Self = Self(1);
    #[doc(alias = "VK_ATTACHMENT_LOAD_OP_DONT_CARE")]
    pub const DONT_CARE: Self = Self(2);
    #[doc(alias = "VK_ATTACHMENT_LOAD_OP_NONE_EXT")]
    #[cfg(feature = "VK_EXT_load_store_op_none")]
    pub const NONE_EXT: Self = Self(1000400000);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> i32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: i32) -> Option<Self> {
        match bits {
            x if x == Self::LOAD.bits() => Some(Self(x)),
            x if x == Self::CLEAR.bits() => Some(Self(x)),
            x if x == Self::DONT_CARE.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_load_store_op_none")]
            x if x == Self::NONE_EXT.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: i32) -> Self {
        Self(bits)
    }
}
# [doc = include_str ! ("../../../doc/VkAttachmentStoreOp.md")]
#[doc(alias = "VkAttachmentStoreOp")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct AttachmentStoreOp(i32);
impl AttachmentStoreOp {
    #[doc(alias = "VK_ATTACHMENT_STORE_OP_STORE")]
    pub const STORE: Self = Self(0);
    #[doc(alias = "VK_ATTACHMENT_STORE_OP_DONT_CARE")]
    pub const DONT_CARE: Self = Self(1);
    #[doc(alias = "VK_ATTACHMENT_STORE_OP_NONE")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const NONE: Self = Self(1000301000);
    #[doc(alias = "VK_ATTACHMENT_STORE_OP_NONE_KHR")]
    #[cfg(feature = "VK_KHR_dynamic_rendering")]
    pub const NONE_KHR: Self = Self::NONE;
    #[doc(alias = "VK_ATTACHMENT_STORE_OP_NONE_EXT")]
    #[cfg(feature = "VK_EXT_load_store_op_none")]
    pub const NONE_EXT: Self = Self::NONE;
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> i32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: i32) -> Option<Self> {
        match bits {
            x if x == Self::STORE.bits() => Some(Self(x)),
            x if x == Self::DONT_CARE.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::NONE.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: i32) -> Self {
        Self(bits)
    }
}
# [doc = include_str ! ("../../../doc/VkImageType.md")]
#[doc(alias = "VkImageType")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct ImageType(i32);
impl ImageType {
    #[doc(alias = "VK_IMAGE_TYPE_1D")]
    pub const N1D: Self = Self(0);
    #[doc(alias = "VK_IMAGE_TYPE_2D")]
    pub const N2D: Self = Self(1);
    #[doc(alias = "VK_IMAGE_TYPE_3D")]
    pub const N3D: Self = Self(2);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> i32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: i32) -> Option<Self> {
        match bits {
            x if x == Self::N1D.bits() => Some(Self(x)),
            x if x == Self::N2D.bits() => Some(Self(x)),
            x if x == Self::N3D.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: i32) -> Self {
        Self(bits)
    }
}
# [doc = include_str ! ("../../../doc/VkImageTiling.md")]
#[doc(alias = "VkImageTiling")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct ImageTiling(i32);
impl ImageTiling {
    #[doc(alias = "VK_IMAGE_TILING_OPTIMAL")]
    pub const OPTIMAL: Self = Self(0);
    #[doc(alias = "VK_IMAGE_TILING_LINEAR")]
    pub const LINEAR: Self = Self(1);
    #[doc(alias = "VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT")]
    #[cfg(feature = "VK_EXT_image_drm_format_modifier")]
    pub const DRM_FORMAT_MODIFIER_EXT: Self = Self(1000158000);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> i32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: i32) -> Option<Self> {
        match bits {
            x if x == Self::OPTIMAL.bits() => Some(Self(x)),
            x if x == Self::LINEAR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_image_drm_format_modifier")]
            x if x == Self::DRM_FORMAT_MODIFIER_EXT.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: i32) -> Self {
        Self(bits)
    }
}
# [doc = include_str ! ("../../../doc/VkImageViewType.md")]
#[doc(alias = "VkImageViewType")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct ImageViewType(i32);
impl ImageViewType {
    #[doc(alias = "VK_IMAGE_VIEW_TYPE_1D")]
    pub const N1D: Self = Self(0);
    #[doc(alias = "VK_IMAGE_VIEW_TYPE_2D")]
    pub const N2D: Self = Self(1);
    #[doc(alias = "VK_IMAGE_VIEW_TYPE_3D")]
    pub const N3D: Self = Self(2);
    #[doc(alias = "VK_IMAGE_VIEW_TYPE_CUBE")]
    pub const CUBE: Self = Self(3);
    #[doc(alias = "VK_IMAGE_VIEW_TYPE_1D_ARRAY")]
    pub const N1D_ARRAY: Self = Self(4);
    #[doc(alias = "VK_IMAGE_VIEW_TYPE_2D_ARRAY")]
    pub const N2D_ARRAY: Self = Self(5);
    #[doc(alias = "VK_IMAGE_VIEW_TYPE_CUBE_ARRAY")]
    pub const CUBE_ARRAY: Self = Self(6);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> i32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: i32) -> Option<Self> {
        match bits {
            x if x == Self::N1D.bits() => Some(Self(x)),
            x if x == Self::N2D.bits() => Some(Self(x)),
            x if x == Self::N3D.bits() => Some(Self(x)),
            x if x == Self::CUBE.bits() => Some(Self(x)),
            x if x == Self::N1D_ARRAY.bits() => Some(Self(x)),
            x if x == Self::N2D_ARRAY.bits() => Some(Self(x)),
            x if x == Self::CUBE_ARRAY.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: i32) -> Self {
        Self(bits)
    }
}
# [doc = include_str ! ("../../../doc/VkCommandBufferLevel.md")]
#[doc(alias = "VkCommandBufferLevel")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct CommandBufferLevel(i32);
impl CommandBufferLevel {
    #[doc(alias = "VK_COMMAND_BUFFER_LEVEL_PRIMARY")]
    pub const PRIMARY: Self = Self(0);
    #[doc(alias = "VK_COMMAND_BUFFER_LEVEL_SECONDARY")]
    pub const SECONDARY: Self = Self(1);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> i32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: i32) -> Option<Self> {
        match bits {
            x if x == Self::PRIMARY.bits() => Some(Self(x)),
            x if x == Self::SECONDARY.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: i32) -> Self {
        Self(bits)
    }
}
# [doc = include_str ! ("../../../doc/VkComponentSwizzle.md")]
#[doc(alias = "VkComponentSwizzle")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct ComponentSwizzle(i32);
impl ComponentSwizzle {
    #[doc(alias = "VK_COMPONENT_SWIZZLE_IDENTITY")]
    pub const IDENTITY: Self = Self(0);
    #[doc(alias = "VK_COMPONENT_SWIZZLE_ZERO")]
    pub const ZERO: Self = Self(1);
    #[doc(alias = "VK_COMPONENT_SWIZZLE_ONE")]
    pub const ONE: Self = Self(2);
    #[doc(alias = "VK_COMPONENT_SWIZZLE_R")]
    pub const R: Self = Self(3);
    #[doc(alias = "VK_COMPONENT_SWIZZLE_G")]
    pub const G: Self = Self(4);
    #[doc(alias = "VK_COMPONENT_SWIZZLE_B")]
    pub const B: Self = Self(5);
    #[doc(alias = "VK_COMPONENT_SWIZZLE_A")]
    pub const A: Self = Self(6);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> i32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: i32) -> Option<Self> {
        match bits {
            x if x == Self::IDENTITY.bits() => Some(Self(x)),
            x if x == Self::ZERO.bits() => Some(Self(x)),
            x if x == Self::ONE.bits() => Some(Self(x)),
            x if x == Self::R.bits() => Some(Self(x)),
            x if x == Self::G.bits() => Some(Self(x)),
            x if x == Self::B.bits() => Some(Self(x)),
            x if x == Self::A.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: i32) -> Self {
        Self(bits)
    }
}
# [doc = include_str ! ("../../../doc/VkDescriptorType.md")]
#[doc(alias = "VkDescriptorType")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct DescriptorType(i32);
impl DescriptorType {
    #[doc(alias = "VK_DESCRIPTOR_TYPE_SAMPLER")]
    pub const SAMPLER: Self = Self(0);
    #[doc(alias = "VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER")]
    pub const COMBINED_IMAGE_SAMPLER: Self = Self(1);
    #[doc(alias = "VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE")]
    pub const SAMPLED_IMAGE: Self = Self(2);
    #[doc(alias = "VK_DESCRIPTOR_TYPE_STORAGE_IMAGE")]
    pub const STORAGE_IMAGE: Self = Self(3);
    #[doc(alias = "VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER")]
    pub const UNIFORM_TEXEL_BUFFER: Self = Self(4);
    #[doc(alias = "VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER")]
    pub const STORAGE_TEXEL_BUFFER: Self = Self(5);
    #[doc(alias = "VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER")]
    pub const UNIFORM_BUFFER: Self = Self(6);
    #[doc(alias = "VK_DESCRIPTOR_TYPE_STORAGE_BUFFER")]
    pub const STORAGE_BUFFER: Self = Self(7);
    #[doc(alias = "VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC")]
    pub const UNIFORM_BUFFER_DYNAMIC: Self = Self(8);
    #[doc(alias = "VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC")]
    pub const STORAGE_BUFFER_DYNAMIC: Self = Self(9);
    #[doc(alias = "VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT")]
    pub const INPUT_ATTACHMENT: Self = Self(10);
    #[doc(alias = "VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const INLINE_UNIFORM_BLOCK: Self = Self(1000138000);
    #[doc(alias = "VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR")]
    #[cfg(feature = "VK_KHR_acceleration_structure")]
    pub const ACCELERATION_STRUCTURE_KHR: Self = Self(1000150000);
    #[doc(alias = "VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV")]
    #[cfg(feature = "VK_NV_ray_tracing")]
    pub const ACCELERATION_STRUCTURE_NV: Self = Self(1000165000);
    #[doc(alias = "VK_DESCRIPTOR_TYPE_MUTABLE_VALVE")]
    #[cfg(feature = "VK_VALVE_mutable_descriptor_type")]
    pub const MUTABLE_VALVE: Self = Self(1000351000);
    #[doc(alias = "VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT")]
    #[cfg(feature = "VK_EXT_inline_uniform_block")]
    pub const INLINE_UNIFORM_BLOCK_EXT: Self = Self::INLINE_UNIFORM_BLOCK;
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> i32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: i32) -> Option<Self> {
        match bits {
            x if x == Self::SAMPLER.bits() => Some(Self(x)),
            x if x == Self::COMBINED_IMAGE_SAMPLER.bits() => Some(Self(x)),
            x if x == Self::SAMPLED_IMAGE.bits() => Some(Self(x)),
            x if x == Self::STORAGE_IMAGE.bits() => Some(Self(x)),
            x if x == Self::UNIFORM_TEXEL_BUFFER.bits() => Some(Self(x)),
            x if x == Self::STORAGE_TEXEL_BUFFER.bits() => Some(Self(x)),
            x if x == Self::UNIFORM_BUFFER.bits() => Some(Self(x)),
            x if x == Self::STORAGE_BUFFER.bits() => Some(Self(x)),
            x if x == Self::UNIFORM_BUFFER_DYNAMIC.bits() => Some(Self(x)),
            x if x == Self::STORAGE_BUFFER_DYNAMIC.bits() => Some(Self(x)),
            x if x == Self::INPUT_ATTACHMENT.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::INLINE_UNIFORM_BLOCK.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_acceleration_structure")]
            x if x == Self::ACCELERATION_STRUCTURE_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_ray_tracing")]
            x if x == Self::ACCELERATION_STRUCTURE_NV.bits() => Some(Self(x)),
            #[cfg(feature = "VK_VALVE_mutable_descriptor_type")]
            x if x == Self::MUTABLE_VALVE.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: i32) -> Self {
        Self(bits)
    }
}
# [doc = include_str ! ("../../../doc/VkQueryType.md")]
#[doc(alias = "VkQueryType")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct QueryType(i32);
impl QueryType {
    #[doc(alias = "VK_QUERY_TYPE_OCCLUSION")]
    pub const OCCLUSION: Self = Self(0);
    #[doc(alias = "VK_QUERY_TYPE_PIPELINE_STATISTICS")]
    pub const PIPELINE_STATISTICS: Self = Self(1);
    #[doc(alias = "VK_QUERY_TYPE_TIMESTAMP")]
    pub const TIMESTAMP: Self = Self(2);
    #[doc(alias = "VK_QUERY_TYPE_RESULT_STATUS_ONLY_KHR")]
    #[cfg(feature = "VK_KHR_video_queue")]
    pub const RESULT_STATUS_ONLY_KHR: Self = Self(1000023000);
    #[doc(alias = "VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT")]
    #[cfg(feature = "VK_EXT_transform_feedback")]
    pub const TRANSFORM_FEEDBACK_STREAM_EXT: Self = Self(1000028004);
    #[doc(alias = "VK_QUERY_TYPE_PERFORMANCE_QUERY_KHR")]
    #[cfg(feature = "VK_KHR_performance_query")]
    pub const PERFORMANCE_QUERY_KHR: Self = Self(1000116000);
    #[doc(alias = "VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_KHR")]
    #[cfg(feature = "VK_KHR_acceleration_structure")]
    pub const ACCELERATION_STRUCTURE_COMPACTED_SIZE_KHR: Self = Self(1000150000);
    #[doc(alias = "VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_SIZE_KHR")]
    #[cfg(feature = "VK_KHR_acceleration_structure")]
    pub const ACCELERATION_STRUCTURE_SERIALIZATION_SIZE_KHR: Self = Self(1000150001);
    #[doc(alias = "VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_NV")]
    #[cfg(feature = "VK_NV_ray_tracing")]
    pub const ACCELERATION_STRUCTURE_COMPACTED_SIZE_NV: Self = Self(1000165000);
    #[doc(alias = "VK_QUERY_TYPE_PERFORMANCE_QUERY_INTEL")]
    #[cfg(feature = "VK_INTEL_performance_query")]
    pub const PERFORMANCE_QUERY_INTEL: Self = Self(1000210000);
    #[doc(alias = "VK_QUERY_TYPE_VIDEO_ENCODE_BITSTREAM_BUFFER_RANGE_KHR")]
    #[cfg(feature = "VK_KHR_video_encode_queue")]
    pub const VIDEO_ENCODE_BITSTREAM_BUFFER_RANGE_KHR: Self = Self(1000299000);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> i32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: i32) -> Option<Self> {
        match bits {
            x if x == Self::OCCLUSION.bits() => Some(Self(x)),
            x if x == Self::PIPELINE_STATISTICS.bits() => Some(Self(x)),
            x if x == Self::TIMESTAMP.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_video_queue")]
            x if x == Self::RESULT_STATUS_ONLY_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_transform_feedback")]
            x if x == Self::TRANSFORM_FEEDBACK_STREAM_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_performance_query")]
            x if x == Self::PERFORMANCE_QUERY_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_acceleration_structure")]
            x if x == Self::ACCELERATION_STRUCTURE_COMPACTED_SIZE_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_acceleration_structure")]
            x if x == Self::ACCELERATION_STRUCTURE_SERIALIZATION_SIZE_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_ray_tracing")]
            x if x == Self::ACCELERATION_STRUCTURE_COMPACTED_SIZE_NV.bits() => Some(Self(x)),
            #[cfg(feature = "VK_INTEL_performance_query")]
            x if x == Self::PERFORMANCE_QUERY_INTEL.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_video_encode_queue")]
            x if x == Self::VIDEO_ENCODE_BITSTREAM_BUFFER_RANGE_KHR.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: i32) -> Self {
        Self(bits)
    }
}
# [doc = include_str ! ("../../../doc/VkBorderColor.md")]
#[doc(alias = "VkBorderColor")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct BorderColor(i32);
impl BorderColor {
    #[doc(alias = "VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK")]
    pub const FLOAT_TRANSPARENT_BLACK: Self = Self(0);
    #[doc(alias = "VK_BORDER_COLOR_INT_TRANSPARENT_BLACK")]
    pub const INT_TRANSPARENT_BLACK: Self = Self(1);
    #[doc(alias = "VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK")]
    pub const FLOAT_OPAQUE_BLACK: Self = Self(2);
    #[doc(alias = "VK_BORDER_COLOR_INT_OPAQUE_BLACK")]
    pub const INT_OPAQUE_BLACK: Self = Self(3);
    #[doc(alias = "VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE")]
    pub const FLOAT_OPAQUE_WHITE: Self = Self(4);
    #[doc(alias = "VK_BORDER_COLOR_INT_OPAQUE_WHITE")]
    pub const INT_OPAQUE_WHITE: Self = Self(5);
    #[doc(alias = "VK_BORDER_COLOR_FLOAT_CUSTOM_EXT")]
    #[cfg(feature = "VK_EXT_custom_border_color")]
    pub const FLOAT_CUSTOM_EXT: Self = Self(1000287003);
    #[doc(alias = "VK_BORDER_COLOR_INT_CUSTOM_EXT")]
    #[cfg(feature = "VK_EXT_custom_border_color")]
    pub const INT_CUSTOM_EXT: Self = Self(1000287004);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> i32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: i32) -> Option<Self> {
        match bits {
            x if x == Self::FLOAT_TRANSPARENT_BLACK.bits() => Some(Self(x)),
            x if x == Self::INT_TRANSPARENT_BLACK.bits() => Some(Self(x)),
            x if x == Self::FLOAT_OPAQUE_BLACK.bits() => Some(Self(x)),
            x if x == Self::INT_OPAQUE_BLACK.bits() => Some(Self(x)),
            x if x == Self::FLOAT_OPAQUE_WHITE.bits() => Some(Self(x)),
            x if x == Self::INT_OPAQUE_WHITE.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_custom_border_color")]
            x if x == Self::FLOAT_CUSTOM_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_custom_border_color")]
            x if x == Self::INT_CUSTOM_EXT.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: i32) -> Self {
        Self(bits)
    }
}
# [doc = include_str ! ("../../../doc/VkPipelineBindPoint.md")]
#[doc(alias = "VkPipelineBindPoint")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct PipelineBindPoint(i32);
impl PipelineBindPoint {
    #[doc(alias = "VK_PIPELINE_BIND_POINT_GRAPHICS")]
    pub const GRAPHICS: Self = Self(0);
    #[doc(alias = "VK_PIPELINE_BIND_POINT_COMPUTE")]
    pub const COMPUTE: Self = Self(1);
    #[doc(alias = "VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR")]
    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
    pub const RAY_TRACING_KHR: Self = Self(1000165000);
    #[doc(alias = "VK_PIPELINE_BIND_POINT_SUBPASS_SHADING_HUAWEI")]
    #[cfg(feature = "VK_HUAWEI_subpass_shading")]
    pub const SUBPASS_SHADING_HUAWEI: Self = Self(1000369003);
    #[doc(alias = "VK_PIPELINE_BIND_POINT_RAY_TRACING_NV")]
    #[cfg(feature = "VK_NV_ray_tracing")]
    pub const RAY_TRACING_NV: Self = Self::RAY_TRACING_KHR;
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> i32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: i32) -> Option<Self> {
        match bits {
            x if x == Self::GRAPHICS.bits() => Some(Self(x)),
            x if x == Self::COMPUTE.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
            x if x == Self::RAY_TRACING_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_HUAWEI_subpass_shading")]
            x if x == Self::SUBPASS_SHADING_HUAWEI.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: i32) -> Self {
        Self(bits)
    }
}
# [doc = include_str ! ("../../../doc/VkPipelineCacheHeaderVersion.md")]
#[doc(alias = "VkPipelineCacheHeaderVersion")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct PipelineCacheHeaderVersion(i32);
impl PipelineCacheHeaderVersion {
    #[doc(alias = "VK_PIPELINE_CACHE_HEADER_VERSION_ONE")]
    pub const ONE: Self = Self(1);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> i32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: i32) -> Option<Self> {
        match bits {
            x if x == Self::ONE.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: i32) -> Self {
        Self(bits)
    }
}
# [doc = include_str ! ("../../../doc/VkPrimitiveTopology.md")]
#[doc(alias = "VkPrimitiveTopology")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct PrimitiveTopology(i32);
impl PrimitiveTopology {
    #[doc(alias = "VK_PRIMITIVE_TOPOLOGY_POINT_LIST")]
    pub const POINT_LIST: Self = Self(0);
    #[doc(alias = "VK_PRIMITIVE_TOPOLOGY_LINE_LIST")]
    pub const LINE_LIST: Self = Self(1);
    #[doc(alias = "VK_PRIMITIVE_TOPOLOGY_LINE_STRIP")]
    pub const LINE_STRIP: Self = Self(2);
    #[doc(alias = "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST")]
    pub const TRIANGLE_LIST: Self = Self(3);
    #[doc(alias = "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP")]
    pub const TRIANGLE_STRIP: Self = Self(4);
    #[doc(alias = "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN")]
    pub const TRIANGLE_FAN: Self = Self(5);
    #[doc(alias = "VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY")]
    pub const LINE_LIST_WITH_ADJACENCY: Self = Self(6);
    #[doc(alias = "VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY")]
    pub const LINE_STRIP_WITH_ADJACENCY: Self = Self(7);
    #[doc(alias = "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY")]
    pub const TRIANGLE_LIST_WITH_ADJACENCY: Self = Self(8);
    #[doc(alias = "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY")]
    pub const TRIANGLE_STRIP_WITH_ADJACENCY: Self = Self(9);
    #[doc(alias = "VK_PRIMITIVE_TOPOLOGY_PATCH_LIST")]
    pub const PATCH_LIST: Self = Self(10);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> i32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: i32) -> Option<Self> {
        match bits {
            x if x == Self::POINT_LIST.bits() => Some(Self(x)),
            x if x == Self::LINE_LIST.bits() => Some(Self(x)),
            x if x == Self::LINE_STRIP.bits() => Some(Self(x)),
            x if x == Self::TRIANGLE_LIST.bits() => Some(Self(x)),
            x if x == Self::TRIANGLE_STRIP.bits() => Some(Self(x)),
            x if x == Self::TRIANGLE_FAN.bits() => Some(Self(x)),
            x if x == Self::LINE_LIST_WITH_ADJACENCY.bits() => Some(Self(x)),
            x if x == Self::LINE_STRIP_WITH_ADJACENCY.bits() => Some(Self(x)),
            x if x == Self::TRIANGLE_LIST_WITH_ADJACENCY.bits() => Some(Self(x)),
            x if x == Self::TRIANGLE_STRIP_WITH_ADJACENCY.bits() => Some(Self(x)),
            x if x == Self::PATCH_LIST.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: i32) -> Self {
        Self(bits)
    }
}
# [doc = include_str ! ("../../../doc/VkSharingMode.md")]
#[doc(alias = "VkSharingMode")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct SharingMode(i32);
impl SharingMode {
    #[doc(alias = "VK_SHARING_MODE_EXCLUSIVE")]
    pub const EXCLUSIVE: Self = Self(0);
    #[doc(alias = "VK_SHARING_MODE_CONCURRENT")]
    pub const CONCURRENT: Self = Self(1);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> i32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: i32) -> Option<Self> {
        match bits {
            x if x == Self::EXCLUSIVE.bits() => Some(Self(x)),
            x if x == Self::CONCURRENT.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: i32) -> Self {
        Self(bits)
    }
}
# [doc = include_str ! ("../../../doc/VkIndexType.md")]
#[doc(alias = "VkIndexType")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct IndexType(i32);
impl IndexType {
    #[doc(alias = "VK_INDEX_TYPE_UINT16")]
    pub const UINT16: Self = Self(0);
    #[doc(alias = "VK_INDEX_TYPE_UINT32")]
    pub const UINT32: Self = Self(1);
    #[doc(alias = "VK_INDEX_TYPE_NONE_KHR")]
    #[cfg(feature = "VK_KHR_acceleration_structure")]
    pub const NONE_KHR: Self = Self(1000165000);
    #[doc(alias = "VK_INDEX_TYPE_UINT8_EXT")]
    #[cfg(feature = "VK_EXT_index_type_uint8")]
    pub const UINT8_EXT: Self = Self(1000265000);
    #[doc(alias = "VK_INDEX_TYPE_NONE_NV")]
    #[cfg(feature = "VK_NV_ray_tracing")]
    pub const NONE_NV: Self = Self::NONE_KHR;
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> i32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: i32) -> Option<Self> {
        match bits {
            x if x == Self::UINT16.bits() => Some(Self(x)),
            x if x == Self::UINT32.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_acceleration_structure")]
            x if x == Self::NONE_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_index_type_uint8")]
            x if x == Self::UINT8_EXT.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: i32) -> Self {
        Self(bits)
    }
}
# [doc = include_str ! ("../../../doc/VkFilter.md")]
#[doc(alias = "VkFilter")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct Filter(i32);
impl Filter {
    #[doc(alias = "VK_FILTER_NEAREST")]
    pub const NEAREST: Self = Self(0);
    #[doc(alias = "VK_FILTER_LINEAR")]
    pub const LINEAR: Self = Self(1);
    #[doc(alias = "VK_FILTER_CUBIC_IMG")]
    #[cfg(feature = "VK_IMG_filter_cubic")]
    pub const CUBIC_IMG: Self = Self(1000015000);
    #[doc(alias = "VK_FILTER_CUBIC_EXT")]
    #[cfg(feature = "VK_EXT_filter_cubic")]
    pub const CUBIC_EXT: Self = Self::CUBIC_IMG;
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> i32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: i32) -> Option<Self> {
        match bits {
            x if x == Self::NEAREST.bits() => Some(Self(x)),
            x if x == Self::LINEAR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_IMG_filter_cubic")]
            x if x == Self::CUBIC_IMG.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: i32) -> Self {
        Self(bits)
    }
}
# [doc = include_str ! ("../../../doc/VkSamplerMipmapMode.md")]
#[doc(alias = "VkSamplerMipmapMode")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct SamplerMipmapMode(i32);
impl SamplerMipmapMode {
    #[doc(alias = "VK_SAMPLER_MIPMAP_MODE_NEAREST")]
    pub const NEAREST: Self = Self(0);
    #[doc(alias = "VK_SAMPLER_MIPMAP_MODE_LINEAR")]
    pub const LINEAR: Self = Self(1);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> i32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: i32) -> Option<Self> {
        match bits {
            x if x == Self::NEAREST.bits() => Some(Self(x)),
            x if x == Self::LINEAR.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: i32) -> Self {
        Self(bits)
    }
}
# [doc = include_str ! ("../../../doc/VkSamplerAddressMode.md")]
#[doc(alias = "VkSamplerAddressMode")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct SamplerAddressMode(i32);
impl SamplerAddressMode {
    #[doc(alias = "VK_SAMPLER_ADDRESS_MODE_REPEAT")]
    pub const REPEAT: Self = Self(0);
    #[doc(alias = "VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT")]
    pub const MIRRORED_REPEAT: Self = Self(1);
    #[doc(alias = "VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE")]
    pub const CLAMP_TO_EDGE: Self = Self(2);
    #[doc(alias = "VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER")]
    pub const CLAMP_TO_BORDER: Self = Self(3);
    #[doc(alias = "VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE")]
    #[cfg(feature = "VK_KHR_sampler_mirror_clamp_to_edge")]
    pub const MIRROR_CLAMP_TO_EDGE: Self = Self(4);
    #[doc(alias = "VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE_KHR")]
    #[cfg(feature = "VK_KHR_sampler_mirror_clamp_to_edge")]
    pub const MIRROR_CLAMP_TO_EDGE_KHR: Self = Self::MIRROR_CLAMP_TO_EDGE;
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> i32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: i32) -> Option<Self> {
        match bits {
            x if x == Self::REPEAT.bits() => Some(Self(x)),
            x if x == Self::MIRRORED_REPEAT.bits() => Some(Self(x)),
            x if x == Self::CLAMP_TO_EDGE.bits() => Some(Self(x)),
            x if x == Self::CLAMP_TO_BORDER.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_sampler_mirror_clamp_to_edge")]
            x if x == Self::MIRROR_CLAMP_TO_EDGE.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: i32) -> Self {
        Self(bits)
    }
}
# [doc = include_str ! ("../../../doc/VkCompareOp.md")]
#[doc(alias = "VkCompareOp")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct CompareOp(i32);
impl CompareOp {
    #[doc(alias = "VK_COMPARE_OP_NEVER")]
    pub const NEVER: Self = Self(0);
    #[doc(alias = "VK_COMPARE_OP_LESS")]
    pub const LESS: Self = Self(1);
    #[doc(alias = "VK_COMPARE_OP_EQUAL")]
    pub const EQUAL: Self = Self(2);
    #[doc(alias = "VK_COMPARE_OP_LESS_OR_EQUAL")]
    pub const LESS_OR_EQUAL: Self = Self(3);
    #[doc(alias = "VK_COMPARE_OP_GREATER")]
    pub const GREATER: Self = Self(4);
    #[doc(alias = "VK_COMPARE_OP_NOT_EQUAL")]
    pub const NOT_EQUAL: Self = Self(5);
    #[doc(alias = "VK_COMPARE_OP_GREATER_OR_EQUAL")]
    pub const GREATER_OR_EQUAL: Self = Self(6);
    #[doc(alias = "VK_COMPARE_OP_ALWAYS")]
    pub const ALWAYS: Self = Self(7);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> i32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: i32) -> Option<Self> {
        match bits {
            x if x == Self::NEVER.bits() => Some(Self(x)),
            x if x == Self::LESS.bits() => Some(Self(x)),
            x if x == Self::EQUAL.bits() => Some(Self(x)),
            x if x == Self::LESS_OR_EQUAL.bits() => Some(Self(x)),
            x if x == Self::GREATER.bits() => Some(Self(x)),
            x if x == Self::NOT_EQUAL.bits() => Some(Self(x)),
            x if x == Self::GREATER_OR_EQUAL.bits() => Some(Self(x)),
            x if x == Self::ALWAYS.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: i32) -> Self {
        Self(bits)
    }
}
# [doc = include_str ! ("../../../doc/VkPolygonMode.md")]
#[doc(alias = "VkPolygonMode")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct PolygonMode(i32);
impl PolygonMode {
    #[doc(alias = "VK_POLYGON_MODE_FILL")]
    pub const FILL: Self = Self(0);
    #[doc(alias = "VK_POLYGON_MODE_LINE")]
    pub const LINE: Self = Self(1);
    #[doc(alias = "VK_POLYGON_MODE_POINT")]
    pub const POINT: Self = Self(2);
    #[doc(alias = "VK_POLYGON_MODE_FILL_RECTANGLE_NV")]
    #[cfg(feature = "VK_NV_fill_rectangle")]
    pub const FILL_RECTANGLE_NV: Self = Self(1000153000);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> i32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: i32) -> Option<Self> {
        match bits {
            x if x == Self::FILL.bits() => Some(Self(x)),
            x if x == Self::LINE.bits() => Some(Self(x)),
            x if x == Self::POINT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_fill_rectangle")]
            x if x == Self::FILL_RECTANGLE_NV.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: i32) -> Self {
        Self(bits)
    }
}
# [doc = include_str ! ("../../../doc/VkFrontFace.md")]
#[doc(alias = "VkFrontFace")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct FrontFace(i32);
impl FrontFace {
    #[doc(alias = "VK_FRONT_FACE_COUNTER_CLOCKWISE")]
    pub const COUNTER_CLOCKWISE: Self = Self(0);
    #[doc(alias = "VK_FRONT_FACE_CLOCKWISE")]
    pub const CLOCKWISE: Self = Self(1);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> i32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: i32) -> Option<Self> {
        match bits {
            x if x == Self::COUNTER_CLOCKWISE.bits() => Some(Self(x)),
            x if x == Self::CLOCKWISE.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: i32) -> Self {
        Self(bits)
    }
}
# [doc = include_str ! ("../../../doc/VkBlendFactor.md")]
#[doc(alias = "VkBlendFactor")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct BlendFactor(i32);
impl BlendFactor {
    #[doc(alias = "VK_BLEND_FACTOR_ZERO")]
    pub const ZERO: Self = Self(0);
    #[doc(alias = "VK_BLEND_FACTOR_ONE")]
    pub const ONE: Self = Self(1);
    #[doc(alias = "VK_BLEND_FACTOR_SRC_COLOR")]
    pub const SRC_COLOR: Self = Self(2);
    #[doc(alias = "VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR")]
    pub const ONE_MINUS_SRC_COLOR: Self = Self(3);
    #[doc(alias = "VK_BLEND_FACTOR_DST_COLOR")]
    pub const DST_COLOR: Self = Self(4);
    #[doc(alias = "VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR")]
    pub const ONE_MINUS_DST_COLOR: Self = Self(5);
    #[doc(alias = "VK_BLEND_FACTOR_SRC_ALPHA")]
    pub const SRC_ALPHA: Self = Self(6);
    #[doc(alias = "VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA")]
    pub const ONE_MINUS_SRC_ALPHA: Self = Self(7);
    #[doc(alias = "VK_BLEND_FACTOR_DST_ALPHA")]
    pub const DST_ALPHA: Self = Self(8);
    #[doc(alias = "VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA")]
    pub const ONE_MINUS_DST_ALPHA: Self = Self(9);
    #[doc(alias = "VK_BLEND_FACTOR_CONSTANT_COLOR")]
    pub const CONSTANT_COLOR: Self = Self(10);
    #[doc(alias = "VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR")]
    pub const ONE_MINUS_CONSTANT_COLOR: Self = Self(11);
    #[doc(alias = "VK_BLEND_FACTOR_CONSTANT_ALPHA")]
    pub const CONSTANT_ALPHA: Self = Self(12);
    #[doc(alias = "VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA")]
    pub const ONE_MINUS_CONSTANT_ALPHA: Self = Self(13);
    #[doc(alias = "VK_BLEND_FACTOR_SRC_ALPHA_SATURATE")]
    pub const SRC_ALPHA_SATURATE: Self = Self(14);
    #[doc(alias = "VK_BLEND_FACTOR_SRC1_COLOR")]
    pub const SRC1_COLOR: Self = Self(15);
    #[doc(alias = "VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR")]
    pub const ONE_MINUS_SRC1_COLOR: Self = Self(16);
    #[doc(alias = "VK_BLEND_FACTOR_SRC1_ALPHA")]
    pub const SRC1_ALPHA: Self = Self(17);
    #[doc(alias = "VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA")]
    pub const ONE_MINUS_SRC1_ALPHA: Self = Self(18);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> i32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: i32) -> Option<Self> {
        match bits {
            x if x == Self::ZERO.bits() => Some(Self(x)),
            x if x == Self::ONE.bits() => Some(Self(x)),
            x if x == Self::SRC_COLOR.bits() => Some(Self(x)),
            x if x == Self::ONE_MINUS_SRC_COLOR.bits() => Some(Self(x)),
            x if x == Self::DST_COLOR.bits() => Some(Self(x)),
            x if x == Self::ONE_MINUS_DST_COLOR.bits() => Some(Self(x)),
            x if x == Self::SRC_ALPHA.bits() => Some(Self(x)),
            x if x == Self::ONE_MINUS_SRC_ALPHA.bits() => Some(Self(x)),
            x if x == Self::DST_ALPHA.bits() => Some(Self(x)),
            x if x == Self::ONE_MINUS_DST_ALPHA.bits() => Some(Self(x)),
            x if x == Self::CONSTANT_COLOR.bits() => Some(Self(x)),
            x if x == Self::ONE_MINUS_CONSTANT_COLOR.bits() => Some(Self(x)),
            x if x == Self::CONSTANT_ALPHA.bits() => Some(Self(x)),
            x if x == Self::ONE_MINUS_CONSTANT_ALPHA.bits() => Some(Self(x)),
            x if x == Self::SRC_ALPHA_SATURATE.bits() => Some(Self(x)),
            x if x == Self::SRC1_COLOR.bits() => Some(Self(x)),
            x if x == Self::ONE_MINUS_SRC1_COLOR.bits() => Some(Self(x)),
            x if x == Self::SRC1_ALPHA.bits() => Some(Self(x)),
            x if x == Self::ONE_MINUS_SRC1_ALPHA.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: i32) -> Self {
        Self(bits)
    }
}
# [doc = include_str ! ("../../../doc/VkBlendOp.md")]
#[doc(alias = "VkBlendOp")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct BlendOp(i32);
impl BlendOp {
    #[doc(alias = "VK_BLEND_OP_ADD")]
    pub const ADD: Self = Self(0);
    #[doc(alias = "VK_BLEND_OP_SUBTRACT")]
    pub const SUBTRACT: Self = Self(1);
    #[doc(alias = "VK_BLEND_OP_REVERSE_SUBTRACT")]
    pub const REVERSE_SUBTRACT: Self = Self(2);
    #[doc(alias = "VK_BLEND_OP_MIN")]
    pub const MIN: Self = Self(3);
    #[doc(alias = "VK_BLEND_OP_MAX")]
    pub const MAX: Self = Self(4);
    #[doc(alias = "VK_BLEND_OP_ZERO_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    pub const ZERO_EXT: Self = Self(1000148000);
    #[doc(alias = "VK_BLEND_OP_SRC_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    pub const SRC_EXT: Self = Self(1000148001);
    #[doc(alias = "VK_BLEND_OP_DST_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    pub const DST_EXT: Self = Self(1000148002);
    #[doc(alias = "VK_BLEND_OP_SRC_OVER_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    pub const SRC_OVER_EXT: Self = Self(1000148003);
    #[doc(alias = "VK_BLEND_OP_DST_OVER_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    pub const DST_OVER_EXT: Self = Self(1000148004);
    #[doc(alias = "VK_BLEND_OP_SRC_IN_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    pub const SRC_IN_EXT: Self = Self(1000148005);
    #[doc(alias = "VK_BLEND_OP_DST_IN_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    pub const DST_IN_EXT: Self = Self(1000148006);
    #[doc(alias = "VK_BLEND_OP_SRC_OUT_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    pub const SRC_OUT_EXT: Self = Self(1000148007);
    #[doc(alias = "VK_BLEND_OP_DST_OUT_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    pub const DST_OUT_EXT: Self = Self(1000148008);
    #[doc(alias = "VK_BLEND_OP_SRC_ATOP_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    pub const SRC_ATOP_EXT: Self = Self(1000148009);
    #[doc(alias = "VK_BLEND_OP_DST_ATOP_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    pub const DST_ATOP_EXT: Self = Self(1000148010);
    #[doc(alias = "VK_BLEND_OP_XOR_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    pub const XOR_EXT: Self = Self(1000148011);
    #[doc(alias = "VK_BLEND_OP_MULTIPLY_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    pub const MULTIPLY_EXT: Self = Self(1000148012);
    #[doc(alias = "VK_BLEND_OP_SCREEN_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    pub const SCREEN_EXT: Self = Self(1000148013);
    #[doc(alias = "VK_BLEND_OP_OVERLAY_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    pub const OVERLAY_EXT: Self = Self(1000148014);
    #[doc(alias = "VK_BLEND_OP_DARKEN_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    pub const DARKEN_EXT: Self = Self(1000148015);
    #[doc(alias = "VK_BLEND_OP_LIGHTEN_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    pub const LIGHTEN_EXT: Self = Self(1000148016);
    #[doc(alias = "VK_BLEND_OP_COLORDODGE_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    pub const COLORDODGE_EXT: Self = Self(1000148017);
    #[doc(alias = "VK_BLEND_OP_COLORBURN_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    pub const COLORBURN_EXT: Self = Self(1000148018);
    #[doc(alias = "VK_BLEND_OP_HARDLIGHT_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    pub const HARDLIGHT_EXT: Self = Self(1000148019);
    #[doc(alias = "VK_BLEND_OP_SOFTLIGHT_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    pub const SOFTLIGHT_EXT: Self = Self(1000148020);
    #[doc(alias = "VK_BLEND_OP_DIFFERENCE_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    pub const DIFFERENCE_EXT: Self = Self(1000148021);
    #[doc(alias = "VK_BLEND_OP_EXCLUSION_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    pub const EXCLUSION_EXT: Self = Self(1000148022);
    #[doc(alias = "VK_BLEND_OP_INVERT_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    pub const INVERT_EXT: Self = Self(1000148023);
    #[doc(alias = "VK_BLEND_OP_INVERT_RGB_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    pub const INVERT_RGB_EXT: Self = Self(1000148024);
    #[doc(alias = "VK_BLEND_OP_LINEARDODGE_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    pub const LINEARDODGE_EXT: Self = Self(1000148025);
    #[doc(alias = "VK_BLEND_OP_LINEARBURN_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    pub const LINEARBURN_EXT: Self = Self(1000148026);
    #[doc(alias = "VK_BLEND_OP_VIVIDLIGHT_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    pub const VIVIDLIGHT_EXT: Self = Self(1000148027);
    #[doc(alias = "VK_BLEND_OP_LINEARLIGHT_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    pub const LINEARLIGHT_EXT: Self = Self(1000148028);
    #[doc(alias = "VK_BLEND_OP_PINLIGHT_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    pub const PINLIGHT_EXT: Self = Self(1000148029);
    #[doc(alias = "VK_BLEND_OP_HARDMIX_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    pub const HARDMIX_EXT: Self = Self(1000148030);
    #[doc(alias = "VK_BLEND_OP_HSL_HUE_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    pub const HSL_HUE_EXT: Self = Self(1000148031);
    #[doc(alias = "VK_BLEND_OP_HSL_SATURATION_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    pub const HSL_SATURATION_EXT: Self = Self(1000148032);
    #[doc(alias = "VK_BLEND_OP_HSL_COLOR_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    pub const HSL_COLOR_EXT: Self = Self(1000148033);
    #[doc(alias = "VK_BLEND_OP_HSL_LUMINOSITY_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    pub const HSL_LUMINOSITY_EXT: Self = Self(1000148034);
    #[doc(alias = "VK_BLEND_OP_PLUS_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    pub const PLUS_EXT: Self = Self(1000148035);
    #[doc(alias = "VK_BLEND_OP_PLUS_CLAMPED_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    pub const PLUS_CLAMPED_EXT: Self = Self(1000148036);
    #[doc(alias = "VK_BLEND_OP_PLUS_CLAMPED_ALPHA_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    pub const PLUS_CLAMPED_ALPHA_EXT: Self = Self(1000148037);
    #[doc(alias = "VK_BLEND_OP_PLUS_DARKER_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    pub const PLUS_DARKER_EXT: Self = Self(1000148038);
    #[doc(alias = "VK_BLEND_OP_MINUS_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    pub const MINUS_EXT: Self = Self(1000148039);
    #[doc(alias = "VK_BLEND_OP_MINUS_CLAMPED_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    pub const MINUS_CLAMPED_EXT: Self = Self(1000148040);
    #[doc(alias = "VK_BLEND_OP_CONTRAST_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    pub const CONTRAST_EXT: Self = Self(1000148041);
    #[doc(alias = "VK_BLEND_OP_INVERT_OVG_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    pub const INVERT_OVG_EXT: Self = Self(1000148042);
    #[doc(alias = "VK_BLEND_OP_RED_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    pub const RED_EXT: Self = Self(1000148043);
    #[doc(alias = "VK_BLEND_OP_GREEN_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    pub const GREEN_EXT: Self = Self(1000148044);
    #[doc(alias = "VK_BLEND_OP_BLUE_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    pub const BLUE_EXT: Self = Self(1000148045);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> i32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: i32) -> Option<Self> {
        match bits {
            x if x == Self::ADD.bits() => Some(Self(x)),
            x if x == Self::SUBTRACT.bits() => Some(Self(x)),
            x if x == Self::REVERSE_SUBTRACT.bits() => Some(Self(x)),
            x if x == Self::MIN.bits() => Some(Self(x)),
            x if x == Self::MAX.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::ZERO_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::SRC_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::DST_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::SRC_OVER_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::DST_OVER_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::SRC_IN_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::DST_IN_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::SRC_OUT_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::DST_OUT_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::SRC_ATOP_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::DST_ATOP_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::XOR_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::MULTIPLY_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::SCREEN_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::OVERLAY_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::DARKEN_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::LIGHTEN_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::COLORDODGE_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::COLORBURN_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::HARDLIGHT_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::SOFTLIGHT_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::DIFFERENCE_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::EXCLUSION_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::INVERT_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::INVERT_RGB_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::LINEARDODGE_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::LINEARBURN_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::VIVIDLIGHT_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::LINEARLIGHT_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::PINLIGHT_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::HARDMIX_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::HSL_HUE_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::HSL_SATURATION_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::HSL_COLOR_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::HSL_LUMINOSITY_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::PLUS_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::PLUS_CLAMPED_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::PLUS_CLAMPED_ALPHA_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::PLUS_DARKER_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::MINUS_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::MINUS_CLAMPED_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::CONTRAST_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::INVERT_OVG_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::RED_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::GREEN_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::BLUE_EXT.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: i32) -> Self {
        Self(bits)
    }
}
# [doc = include_str ! ("../../../doc/VkStencilOp.md")]
#[doc(alias = "VkStencilOp")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct StencilOp(i32);
impl StencilOp {
    #[doc(alias = "VK_STENCIL_OP_KEEP")]
    pub const KEEP: Self = Self(0);
    #[doc(alias = "VK_STENCIL_OP_ZERO")]
    pub const ZERO: Self = Self(1);
    #[doc(alias = "VK_STENCIL_OP_REPLACE")]
    pub const REPLACE: Self = Self(2);
    #[doc(alias = "VK_STENCIL_OP_INCREMENT_AND_CLAMP")]
    pub const INCREMENT_AND_CLAMP: Self = Self(3);
    #[doc(alias = "VK_STENCIL_OP_DECREMENT_AND_CLAMP")]
    pub const DECREMENT_AND_CLAMP: Self = Self(4);
    #[doc(alias = "VK_STENCIL_OP_INVERT")]
    pub const INVERT: Self = Self(5);
    #[doc(alias = "VK_STENCIL_OP_INCREMENT_AND_WRAP")]
    pub const INCREMENT_AND_WRAP: Self = Self(6);
    #[doc(alias = "VK_STENCIL_OP_DECREMENT_AND_WRAP")]
    pub const DECREMENT_AND_WRAP: Self = Self(7);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> i32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: i32) -> Option<Self> {
        match bits {
            x if x == Self::KEEP.bits() => Some(Self(x)),
            x if x == Self::ZERO.bits() => Some(Self(x)),
            x if x == Self::REPLACE.bits() => Some(Self(x)),
            x if x == Self::INCREMENT_AND_CLAMP.bits() => Some(Self(x)),
            x if x == Self::DECREMENT_AND_CLAMP.bits() => Some(Self(x)),
            x if x == Self::INVERT.bits() => Some(Self(x)),
            x if x == Self::INCREMENT_AND_WRAP.bits() => Some(Self(x)),
            x if x == Self::DECREMENT_AND_WRAP.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: i32) -> Self {
        Self(bits)
    }
}
# [doc = include_str ! ("../../../doc/VkLogicOp.md")]
#[doc(alias = "VkLogicOp")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct LogicOp(i32);
impl LogicOp {
    #[doc(alias = "VK_LOGIC_OP_CLEAR")]
    pub const CLEAR: Self = Self(0);
    #[doc(alias = "VK_LOGIC_OP_AND")]
    pub const AND: Self = Self(1);
    #[doc(alias = "VK_LOGIC_OP_AND_REVERSE")]
    pub const AND_REVERSE: Self = Self(2);
    #[doc(alias = "VK_LOGIC_OP_COPY")]
    pub const COPY: Self = Self(3);
    #[doc(alias = "VK_LOGIC_OP_AND_INVERTED")]
    pub const AND_INVERTED: Self = Self(4);
    #[doc(alias = "VK_LOGIC_OP_NO_OP")]
    pub const NO_OP: Self = Self(5);
    #[doc(alias = "VK_LOGIC_OP_XOR")]
    pub const XOR: Self = Self(6);
    #[doc(alias = "VK_LOGIC_OP_OR")]
    pub const OR: Self = Self(7);
    #[doc(alias = "VK_LOGIC_OP_NOR")]
    pub const NOR: Self = Self(8);
    #[doc(alias = "VK_LOGIC_OP_EQUIVALENT")]
    pub const EQUIVALENT: Self = Self(9);
    #[doc(alias = "VK_LOGIC_OP_INVERT")]
    pub const INVERT: Self = Self(10);
    #[doc(alias = "VK_LOGIC_OP_OR_REVERSE")]
    pub const OR_REVERSE: Self = Self(11);
    #[doc(alias = "VK_LOGIC_OP_COPY_INVERTED")]
    pub const COPY_INVERTED: Self = Self(12);
    #[doc(alias = "VK_LOGIC_OP_OR_INVERTED")]
    pub const OR_INVERTED: Self = Self(13);
    #[doc(alias = "VK_LOGIC_OP_NAND")]
    pub const NAND: Self = Self(14);
    #[doc(alias = "VK_LOGIC_OP_SET")]
    pub const SET: Self = Self(15);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> i32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: i32) -> Option<Self> {
        match bits {
            x if x == Self::CLEAR.bits() => Some(Self(x)),
            x if x == Self::AND.bits() => Some(Self(x)),
            x if x == Self::AND_REVERSE.bits() => Some(Self(x)),
            x if x == Self::COPY.bits() => Some(Self(x)),
            x if x == Self::AND_INVERTED.bits() => Some(Self(x)),
            x if x == Self::NO_OP.bits() => Some(Self(x)),
            x if x == Self::XOR.bits() => Some(Self(x)),
            x if x == Self::OR.bits() => Some(Self(x)),
            x if x == Self::NOR.bits() => Some(Self(x)),
            x if x == Self::EQUIVALENT.bits() => Some(Self(x)),
            x if x == Self::INVERT.bits() => Some(Self(x)),
            x if x == Self::OR_REVERSE.bits() => Some(Self(x)),
            x if x == Self::COPY_INVERTED.bits() => Some(Self(x)),
            x if x == Self::OR_INVERTED.bits() => Some(Self(x)),
            x if x == Self::NAND.bits() => Some(Self(x)),
            x if x == Self::SET.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: i32) -> Self {
        Self(bits)
    }
}
# [doc = include_str ! ("../../../doc/VkInternalAllocationType.md")]
#[doc(alias = "VkInternalAllocationType")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct InternalAllocationType(i32);
impl InternalAllocationType {
    #[doc(alias = "VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE")]
    pub const EXECUTABLE: Self = Self(0);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> i32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: i32) -> Option<Self> {
        match bits {
            x if x == Self::EXECUTABLE.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: i32) -> Self {
        Self(bits)
    }
}
# [doc = include_str ! ("../../../doc/VkSystemAllocationScope.md")]
#[doc(alias = "VkSystemAllocationScope")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct SystemAllocationScope(i32);
impl SystemAllocationScope {
    #[doc(alias = "VK_SYSTEM_ALLOCATION_SCOPE_COMMAND")]
    pub const COMMAND: Self = Self(0);
    #[doc(alias = "VK_SYSTEM_ALLOCATION_SCOPE_OBJECT")]
    pub const OBJECT: Self = Self(1);
    #[doc(alias = "VK_SYSTEM_ALLOCATION_SCOPE_CACHE")]
    pub const CACHE: Self = Self(2);
    #[doc(alias = "VK_SYSTEM_ALLOCATION_SCOPE_DEVICE")]
    pub const DEVICE: Self = Self(3);
    #[doc(alias = "VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE")]
    pub const INSTANCE: Self = Self(4);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> i32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: i32) -> Option<Self> {
        match bits {
            x if x == Self::COMMAND.bits() => Some(Self(x)),
            x if x == Self::OBJECT.bits() => Some(Self(x)),
            x if x == Self::CACHE.bits() => Some(Self(x)),
            x if x == Self::DEVICE.bits() => Some(Self(x)),
            x if x == Self::INSTANCE.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: i32) -> Self {
        Self(bits)
    }
}
# [doc = include_str ! ("../../../doc/VkPhysicalDeviceType.md")]
#[doc(alias = "VkPhysicalDeviceType")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct PhysicalDeviceType(i32);
impl PhysicalDeviceType {
    #[doc(alias = "VK_PHYSICAL_DEVICE_TYPE_OTHER")]
    pub const OTHER: Self = Self(0);
    #[doc(alias = "VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU")]
    pub const INTEGRATED_GPU: Self = Self(1);
    #[doc(alias = "VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU")]
    pub const DISCRETE_GPU: Self = Self(2);
    #[doc(alias = "VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU")]
    pub const VIRTUAL_GPU: Self = Self(3);
    #[doc(alias = "VK_PHYSICAL_DEVICE_TYPE_CPU")]
    pub const CPU: Self = Self(4);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> i32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: i32) -> Option<Self> {
        match bits {
            x if x == Self::OTHER.bits() => Some(Self(x)),
            x if x == Self::INTEGRATED_GPU.bits() => Some(Self(x)),
            x if x == Self::DISCRETE_GPU.bits() => Some(Self(x)),
            x if x == Self::VIRTUAL_GPU.bits() => Some(Self(x)),
            x if x == Self::CPU.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: i32) -> Self {
        Self(bits)
    }
}
# [doc = include_str ! ("../../../doc/VkVertexInputRate.md")]
#[doc(alias = "VkVertexInputRate")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct VertexInputRate(i32);
impl VertexInputRate {
    #[doc(alias = "VK_VERTEX_INPUT_RATE_VERTEX")]
    pub const VERTEX: Self = Self(0);
    #[doc(alias = "VK_VERTEX_INPUT_RATE_INSTANCE")]
    pub const INSTANCE: Self = Self(1);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> i32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: i32) -> Option<Self> {
        match bits {
            x if x == Self::VERTEX.bits() => Some(Self(x)),
            x if x == Self::INSTANCE.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: i32) -> Self {
        Self(bits)
    }
}
# [doc = include_str ! ("../../../doc/VkFormat.md")]
#[doc(alias = "VkFormat")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct Format(i32);
impl Format {
    #[doc(alias = "VK_FORMAT_UNDEFINED")]
    pub const UNDEFINED: Self = Self(0);
    #[doc(alias = "VK_FORMAT_R4G4_UNORM_PACK8")]
    pub const R4G4_UNORM_PACK8: Self = Self(1);
    #[doc(alias = "VK_FORMAT_R4G4B4A4_UNORM_PACK16")]
    pub const R4G4B4A4_UNORM_PACK16: Self = Self(2);
    #[doc(alias = "VK_FORMAT_B4G4R4A4_UNORM_PACK16")]
    pub const B4G4R4A4_UNORM_PACK16: Self = Self(3);
    #[doc(alias = "VK_FORMAT_R5G6B5_UNORM_PACK16")]
    pub const R5G6B5_UNORM_PACK16: Self = Self(4);
    #[doc(alias = "VK_FORMAT_B5G6R5_UNORM_PACK16")]
    pub const B5G6R5_UNORM_PACK16: Self = Self(5);
    #[doc(alias = "VK_FORMAT_R5G5B5A1_UNORM_PACK16")]
    pub const R5G5B5A1_UNORM_PACK16: Self = Self(6);
    #[doc(alias = "VK_FORMAT_B5G5R5A1_UNORM_PACK16")]
    pub const B5G5R5A1_UNORM_PACK16: Self = Self(7);
    #[doc(alias = "VK_FORMAT_A1R5G5B5_UNORM_PACK16")]
    pub const A1R5G5B5_UNORM_PACK16: Self = Self(8);
    #[doc(alias = "VK_FORMAT_R8_UNORM")]
    pub const R8_UNORM: Self = Self(9);
    #[doc(alias = "VK_FORMAT_R8_SNORM")]
    pub const R8_SNORM: Self = Self(10);
    #[doc(alias = "VK_FORMAT_R8_USCALED")]
    pub const R8_USCALED: Self = Self(11);
    #[doc(alias = "VK_FORMAT_R8_SSCALED")]
    pub const R8_SSCALED: Self = Self(12);
    #[doc(alias = "VK_FORMAT_R8_UINT")]
    pub const R8_UINT: Self = Self(13);
    #[doc(alias = "VK_FORMAT_R8_SINT")]
    pub const R8_SINT: Self = Self(14);
    #[doc(alias = "VK_FORMAT_R8_SRGB")]
    pub const R8_SRGB: Self = Self(15);
    #[doc(alias = "VK_FORMAT_R8G8_UNORM")]
    pub const R8G8_UNORM: Self = Self(16);
    #[doc(alias = "VK_FORMAT_R8G8_SNORM")]
    pub const R8G8_SNORM: Self = Self(17);
    #[doc(alias = "VK_FORMAT_R8G8_USCALED")]
    pub const R8G8_USCALED: Self = Self(18);
    #[doc(alias = "VK_FORMAT_R8G8_SSCALED")]
    pub const R8G8_SSCALED: Self = Self(19);
    #[doc(alias = "VK_FORMAT_R8G8_UINT")]
    pub const R8G8_UINT: Self = Self(20);
    #[doc(alias = "VK_FORMAT_R8G8_SINT")]
    pub const R8G8_SINT: Self = Self(21);
    #[doc(alias = "VK_FORMAT_R8G8_SRGB")]
    pub const R8G8_SRGB: Self = Self(22);
    #[doc(alias = "VK_FORMAT_R8G8B8_UNORM")]
    pub const R8G8B8_UNORM: Self = Self(23);
    #[doc(alias = "VK_FORMAT_R8G8B8_SNORM")]
    pub const R8G8B8_SNORM: Self = Self(24);
    #[doc(alias = "VK_FORMAT_R8G8B8_USCALED")]
    pub const R8G8B8_USCALED: Self = Self(25);
    #[doc(alias = "VK_FORMAT_R8G8B8_SSCALED")]
    pub const R8G8B8_SSCALED: Self = Self(26);
    #[doc(alias = "VK_FORMAT_R8G8B8_UINT")]
    pub const R8G8B8_UINT: Self = Self(27);
    #[doc(alias = "VK_FORMAT_R8G8B8_SINT")]
    pub const R8G8B8_SINT: Self = Self(28);
    #[doc(alias = "VK_FORMAT_R8G8B8_SRGB")]
    pub const R8G8B8_SRGB: Self = Self(29);
    #[doc(alias = "VK_FORMAT_B8G8R8_UNORM")]
    pub const B8G8R8_UNORM: Self = Self(30);
    #[doc(alias = "VK_FORMAT_B8G8R8_SNORM")]
    pub const B8G8R8_SNORM: Self = Self(31);
    #[doc(alias = "VK_FORMAT_B8G8R8_USCALED")]
    pub const B8G8R8_USCALED: Self = Self(32);
    #[doc(alias = "VK_FORMAT_B8G8R8_SSCALED")]
    pub const B8G8R8_SSCALED: Self = Self(33);
    #[doc(alias = "VK_FORMAT_B8G8R8_UINT")]
    pub const B8G8R8_UINT: Self = Self(34);
    #[doc(alias = "VK_FORMAT_B8G8R8_SINT")]
    pub const B8G8R8_SINT: Self = Self(35);
    #[doc(alias = "VK_FORMAT_B8G8R8_SRGB")]
    pub const B8G8R8_SRGB: Self = Self(36);
    #[doc(alias = "VK_FORMAT_R8G8B8A8_UNORM")]
    pub const R8G8B8A8_UNORM: Self = Self(37);
    #[doc(alias = "VK_FORMAT_R8G8B8A8_SNORM")]
    pub const R8G8B8A8_SNORM: Self = Self(38);
    #[doc(alias = "VK_FORMAT_R8G8B8A8_USCALED")]
    pub const R8G8B8A8_USCALED: Self = Self(39);
    #[doc(alias = "VK_FORMAT_R8G8B8A8_SSCALED")]
    pub const R8G8B8A8_SSCALED: Self = Self(40);
    #[doc(alias = "VK_FORMAT_R8G8B8A8_UINT")]
    pub const R8G8B8A8_UINT: Self = Self(41);
    #[doc(alias = "VK_FORMAT_R8G8B8A8_SINT")]
    pub const R8G8B8A8_SINT: Self = Self(42);
    #[doc(alias = "VK_FORMAT_R8G8B8A8_SRGB")]
    pub const R8G8B8A8_SRGB: Self = Self(43);
    #[doc(alias = "VK_FORMAT_B8G8R8A8_UNORM")]
    pub const B8G8R8A8_UNORM: Self = Self(44);
    #[doc(alias = "VK_FORMAT_B8G8R8A8_SNORM")]
    pub const B8G8R8A8_SNORM: Self = Self(45);
    #[doc(alias = "VK_FORMAT_B8G8R8A8_USCALED")]
    pub const B8G8R8A8_USCALED: Self = Self(46);
    #[doc(alias = "VK_FORMAT_B8G8R8A8_SSCALED")]
    pub const B8G8R8A8_SSCALED: Self = Self(47);
    #[doc(alias = "VK_FORMAT_B8G8R8A8_UINT")]
    pub const B8G8R8A8_UINT: Self = Self(48);
    #[doc(alias = "VK_FORMAT_B8G8R8A8_SINT")]
    pub const B8G8R8A8_SINT: Self = Self(49);
    #[doc(alias = "VK_FORMAT_B8G8R8A8_SRGB")]
    pub const B8G8R8A8_SRGB: Self = Self(50);
    #[doc(alias = "VK_FORMAT_A8B8G8R8_UNORM_PACK32")]
    pub const A8B8G8R8_UNORM_PACK32: Self = Self(51);
    #[doc(alias = "VK_FORMAT_A8B8G8R8_SNORM_PACK32")]
    pub const A8B8G8R8_SNORM_PACK32: Self = Self(52);
    #[doc(alias = "VK_FORMAT_A8B8G8R8_USCALED_PACK32")]
    pub const A8B8G8R8_USCALED_PACK32: Self = Self(53);
    #[doc(alias = "VK_FORMAT_A8B8G8R8_SSCALED_PACK32")]
    pub const A8B8G8R8_SSCALED_PACK32: Self = Self(54);
    #[doc(alias = "VK_FORMAT_A8B8G8R8_UINT_PACK32")]
    pub const A8B8G8R8_UINT_PACK32: Self = Self(55);
    #[doc(alias = "VK_FORMAT_A8B8G8R8_SINT_PACK32")]
    pub const A8B8G8R8_SINT_PACK32: Self = Self(56);
    #[doc(alias = "VK_FORMAT_A8B8G8R8_SRGB_PACK32")]
    pub const A8B8G8R8_SRGB_PACK32: Self = Self(57);
    #[doc(alias = "VK_FORMAT_A2R10G10B10_UNORM_PACK32")]
    pub const A2R10G10B10_UNORM_PACK32: Self = Self(58);
    #[doc(alias = "VK_FORMAT_A2R10G10B10_SNORM_PACK32")]
    pub const A2R10G10B10_SNORM_PACK32: Self = Self(59);
    #[doc(alias = "VK_FORMAT_A2R10G10B10_USCALED_PACK32")]
    pub const A2R10G10B10_USCALED_PACK32: Self = Self(60);
    #[doc(alias = "VK_FORMAT_A2R10G10B10_SSCALED_PACK32")]
    pub const A2R10G10B10_SSCALED_PACK32: Self = Self(61);
    #[doc(alias = "VK_FORMAT_A2R10G10B10_UINT_PACK32")]
    pub const A2R10G10B10_UINT_PACK32: Self = Self(62);
    #[doc(alias = "VK_FORMAT_A2R10G10B10_SINT_PACK32")]
    pub const A2R10G10B10_SINT_PACK32: Self = Self(63);
    #[doc(alias = "VK_FORMAT_A2B10G10R10_UNORM_PACK32")]
    pub const A2B10G10R10_UNORM_PACK32: Self = Self(64);
    #[doc(alias = "VK_FORMAT_A2B10G10R10_SNORM_PACK32")]
    pub const A2B10G10R10_SNORM_PACK32: Self = Self(65);
    #[doc(alias = "VK_FORMAT_A2B10G10R10_USCALED_PACK32")]
    pub const A2B10G10R10_USCALED_PACK32: Self = Self(66);
    #[doc(alias = "VK_FORMAT_A2B10G10R10_SSCALED_PACK32")]
    pub const A2B10G10R10_SSCALED_PACK32: Self = Self(67);
    #[doc(alias = "VK_FORMAT_A2B10G10R10_UINT_PACK32")]
    pub const A2B10G10R10_UINT_PACK32: Self = Self(68);
    #[doc(alias = "VK_FORMAT_A2B10G10R10_SINT_PACK32")]
    pub const A2B10G10R10_SINT_PACK32: Self = Self(69);
    #[doc(alias = "VK_FORMAT_R16_UNORM")]
    pub const R16_UNORM: Self = Self(70);
    #[doc(alias = "VK_FORMAT_R16_SNORM")]
    pub const R16_SNORM: Self = Self(71);
    #[doc(alias = "VK_FORMAT_R16_USCALED")]
    pub const R16_USCALED: Self = Self(72);
    #[doc(alias = "VK_FORMAT_R16_SSCALED")]
    pub const R16_SSCALED: Self = Self(73);
    #[doc(alias = "VK_FORMAT_R16_UINT")]
    pub const R16_UINT: Self = Self(74);
    #[doc(alias = "VK_FORMAT_R16_SINT")]
    pub const R16_SINT: Self = Self(75);
    #[doc(alias = "VK_FORMAT_R16_SFLOAT")]
    pub const R16_SFLOAT: Self = Self(76);
    #[doc(alias = "VK_FORMAT_R16G16_UNORM")]
    pub const R16G16_UNORM: Self = Self(77);
    #[doc(alias = "VK_FORMAT_R16G16_SNORM")]
    pub const R16G16_SNORM: Self = Self(78);
    #[doc(alias = "VK_FORMAT_R16G16_USCALED")]
    pub const R16G16_USCALED: Self = Self(79);
    #[doc(alias = "VK_FORMAT_R16G16_SSCALED")]
    pub const R16G16_SSCALED: Self = Self(80);
    #[doc(alias = "VK_FORMAT_R16G16_UINT")]
    pub const R16G16_UINT: Self = Self(81);
    #[doc(alias = "VK_FORMAT_R16G16_SINT")]
    pub const R16G16_SINT: Self = Self(82);
    #[doc(alias = "VK_FORMAT_R16G16_SFLOAT")]
    pub const R16G16_SFLOAT: Self = Self(83);
    #[doc(alias = "VK_FORMAT_R16G16B16_UNORM")]
    pub const R16G16B16_UNORM: Self = Self(84);
    #[doc(alias = "VK_FORMAT_R16G16B16_SNORM")]
    pub const R16G16B16_SNORM: Self = Self(85);
    #[doc(alias = "VK_FORMAT_R16G16B16_USCALED")]
    pub const R16G16B16_USCALED: Self = Self(86);
    #[doc(alias = "VK_FORMAT_R16G16B16_SSCALED")]
    pub const R16G16B16_SSCALED: Self = Self(87);
    #[doc(alias = "VK_FORMAT_R16G16B16_UINT")]
    pub const R16G16B16_UINT: Self = Self(88);
    #[doc(alias = "VK_FORMAT_R16G16B16_SINT")]
    pub const R16G16B16_SINT: Self = Self(89);
    #[doc(alias = "VK_FORMAT_R16G16B16_SFLOAT")]
    pub const R16G16B16_SFLOAT: Self = Self(90);
    #[doc(alias = "VK_FORMAT_R16G16B16A16_UNORM")]
    pub const R16G16B16A16_UNORM: Self = Self(91);
    #[doc(alias = "VK_FORMAT_R16G16B16A16_SNORM")]
    pub const R16G16B16A16_SNORM: Self = Self(92);
    #[doc(alias = "VK_FORMAT_R16G16B16A16_USCALED")]
    pub const R16G16B16A16_USCALED: Self = Self(93);
    #[doc(alias = "VK_FORMAT_R16G16B16A16_SSCALED")]
    pub const R16G16B16A16_SSCALED: Self = Self(94);
    #[doc(alias = "VK_FORMAT_R16G16B16A16_UINT")]
    pub const R16G16B16A16_UINT: Self = Self(95);
    #[doc(alias = "VK_FORMAT_R16G16B16A16_SINT")]
    pub const R16G16B16A16_SINT: Self = Self(96);
    #[doc(alias = "VK_FORMAT_R16G16B16A16_SFLOAT")]
    pub const R16G16B16A16_SFLOAT: Self = Self(97);
    #[doc(alias = "VK_FORMAT_R32_UINT")]
    pub const R32_UINT: Self = Self(98);
    #[doc(alias = "VK_FORMAT_R32_SINT")]
    pub const R32_SINT: Self = Self(99);
    #[doc(alias = "VK_FORMAT_R32_SFLOAT")]
    pub const R32_SFLOAT: Self = Self(100);
    #[doc(alias = "VK_FORMAT_R32G32_UINT")]
    pub const R32G32_UINT: Self = Self(101);
    #[doc(alias = "VK_FORMAT_R32G32_SINT")]
    pub const R32G32_SINT: Self = Self(102);
    #[doc(alias = "VK_FORMAT_R32G32_SFLOAT")]
    pub const R32G32_SFLOAT: Self = Self(103);
    #[doc(alias = "VK_FORMAT_R32G32B32_UINT")]
    pub const R32G32B32_UINT: Self = Self(104);
    #[doc(alias = "VK_FORMAT_R32G32B32_SINT")]
    pub const R32G32B32_SINT: Self = Self(105);
    #[doc(alias = "VK_FORMAT_R32G32B32_SFLOAT")]
    pub const R32G32B32_SFLOAT: Self = Self(106);
    #[doc(alias = "VK_FORMAT_R32G32B32A32_UINT")]
    pub const R32G32B32A32_UINT: Self = Self(107);
    #[doc(alias = "VK_FORMAT_R32G32B32A32_SINT")]
    pub const R32G32B32A32_SINT: Self = Self(108);
    #[doc(alias = "VK_FORMAT_R32G32B32A32_SFLOAT")]
    pub const R32G32B32A32_SFLOAT: Self = Self(109);
    #[doc(alias = "VK_FORMAT_R64_UINT")]
    pub const R64_UINT: Self = Self(110);
    #[doc(alias = "VK_FORMAT_R64_SINT")]
    pub const R64_SINT: Self = Self(111);
    #[doc(alias = "VK_FORMAT_R64_SFLOAT")]
    pub const R64_SFLOAT: Self = Self(112);
    #[doc(alias = "VK_FORMAT_R64G64_UINT")]
    pub const R64G64_UINT: Self = Self(113);
    #[doc(alias = "VK_FORMAT_R64G64_SINT")]
    pub const R64G64_SINT: Self = Self(114);
    #[doc(alias = "VK_FORMAT_R64G64_SFLOAT")]
    pub const R64G64_SFLOAT: Self = Self(115);
    #[doc(alias = "VK_FORMAT_R64G64B64_UINT")]
    pub const R64G64B64_UINT: Self = Self(116);
    #[doc(alias = "VK_FORMAT_R64G64B64_SINT")]
    pub const R64G64B64_SINT: Self = Self(117);
    #[doc(alias = "VK_FORMAT_R64G64B64_SFLOAT")]
    pub const R64G64B64_SFLOAT: Self = Self(118);
    #[doc(alias = "VK_FORMAT_R64G64B64A64_UINT")]
    pub const R64G64B64A64_UINT: Self = Self(119);
    #[doc(alias = "VK_FORMAT_R64G64B64A64_SINT")]
    pub const R64G64B64A64_SINT: Self = Self(120);
    #[doc(alias = "VK_FORMAT_R64G64B64A64_SFLOAT")]
    pub const R64G64B64A64_SFLOAT: Self = Self(121);
    #[doc(alias = "VK_FORMAT_B10G11R11_UFLOAT_PACK32")]
    pub const B10G11R11_UFLOAT_PACK32: Self = Self(122);
    #[doc(alias = "VK_FORMAT_E5B9G9R9_UFLOAT_PACK32")]
    pub const E5B9G9R9_UFLOAT_PACK32: Self = Self(123);
    #[doc(alias = "VK_FORMAT_D16_UNORM")]
    pub const D16_UNORM: Self = Self(124);
    #[doc(alias = "VK_FORMAT_X8_D24_UNORM_PACK32")]
    pub const X8_D24_UNORM_PACK32: Self = Self(125);
    #[doc(alias = "VK_FORMAT_D32_SFLOAT")]
    pub const D32_SFLOAT: Self = Self(126);
    #[doc(alias = "VK_FORMAT_S8_UINT")]
    pub const S8_UINT: Self = Self(127);
    #[doc(alias = "VK_FORMAT_D16_UNORM_S8_UINT")]
    pub const D16_UNORM_S8_UINT: Self = Self(128);
    #[doc(alias = "VK_FORMAT_D24_UNORM_S8_UINT")]
    pub const D24_UNORM_S8_UINT: Self = Self(129);
    #[doc(alias = "VK_FORMAT_D32_SFLOAT_S8_UINT")]
    pub const D32_SFLOAT_S8_UINT: Self = Self(130);
    #[doc(alias = "VK_FORMAT_BC1_RGB_UNORM_BLOCK")]
    pub const BC1_RGB_UNORM_BLOCK: Self = Self(131);
    #[doc(alias = "VK_FORMAT_BC1_RGB_SRGB_BLOCK")]
    pub const BC1_RGB_SRGB_BLOCK: Self = Self(132);
    #[doc(alias = "VK_FORMAT_BC1_RGBA_UNORM_BLOCK")]
    pub const BC1_RGBA_UNORM_BLOCK: Self = Self(133);
    #[doc(alias = "VK_FORMAT_BC1_RGBA_SRGB_BLOCK")]
    pub const BC1_RGBA_SRGB_BLOCK: Self = Self(134);
    #[doc(alias = "VK_FORMAT_BC2_UNORM_BLOCK")]
    pub const BC2_UNORM_BLOCK: Self = Self(135);
    #[doc(alias = "VK_FORMAT_BC2_SRGB_BLOCK")]
    pub const BC2_SRGB_BLOCK: Self = Self(136);
    #[doc(alias = "VK_FORMAT_BC3_UNORM_BLOCK")]
    pub const BC3_UNORM_BLOCK: Self = Self(137);
    #[doc(alias = "VK_FORMAT_BC3_SRGB_BLOCK")]
    pub const BC3_SRGB_BLOCK: Self = Self(138);
    #[doc(alias = "VK_FORMAT_BC4_UNORM_BLOCK")]
    pub const BC4_UNORM_BLOCK: Self = Self(139);
    #[doc(alias = "VK_FORMAT_BC4_SNORM_BLOCK")]
    pub const BC4_SNORM_BLOCK: Self = Self(140);
    #[doc(alias = "VK_FORMAT_BC5_UNORM_BLOCK")]
    pub const BC5_UNORM_BLOCK: Self = Self(141);
    #[doc(alias = "VK_FORMAT_BC5_SNORM_BLOCK")]
    pub const BC5_SNORM_BLOCK: Self = Self(142);
    #[doc(alias = "VK_FORMAT_BC6H_UFLOAT_BLOCK")]
    pub const BC6H_UFLOAT_BLOCK: Self = Self(143);
    #[doc(alias = "VK_FORMAT_BC6H_SFLOAT_BLOCK")]
    pub const BC6H_SFLOAT_BLOCK: Self = Self(144);
    #[doc(alias = "VK_FORMAT_BC7_UNORM_BLOCK")]
    pub const BC7_UNORM_BLOCK: Self = Self(145);
    #[doc(alias = "VK_FORMAT_BC7_SRGB_BLOCK")]
    pub const BC7_SRGB_BLOCK: Self = Self(146);
    #[doc(alias = "VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK")]
    pub const ETC2_R8G8B8_UNORM_BLOCK: Self = Self(147);
    #[doc(alias = "VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK")]
    pub const ETC2_R8G8B8_SRGB_BLOCK: Self = Self(148);
    #[doc(alias = "VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK")]
    pub const ETC2_R8G8B8A1_UNORM_BLOCK: Self = Self(149);
    #[doc(alias = "VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK")]
    pub const ETC2_R8G8B8A1_SRGB_BLOCK: Self = Self(150);
    #[doc(alias = "VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK")]
    pub const ETC2_R8G8B8A8_UNORM_BLOCK: Self = Self(151);
    #[doc(alias = "VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK")]
    pub const ETC2_R8G8B8A8_SRGB_BLOCK: Self = Self(152);
    #[doc(alias = "VK_FORMAT_EAC_R11_UNORM_BLOCK")]
    pub const EAC_R11_UNORM_BLOCK: Self = Self(153);
    #[doc(alias = "VK_FORMAT_EAC_R11_SNORM_BLOCK")]
    pub const EAC_R11_SNORM_BLOCK: Self = Self(154);
    #[doc(alias = "VK_FORMAT_EAC_R11G11_UNORM_BLOCK")]
    pub const EAC_R11G11_UNORM_BLOCK: Self = Self(155);
    #[doc(alias = "VK_FORMAT_EAC_R11G11_SNORM_BLOCK")]
    pub const EAC_R11G11_SNORM_BLOCK: Self = Self(156);
    #[doc(alias = "VK_FORMAT_ASTC_4x4_UNORM_BLOCK")]
    pub const ASTC4X4_UNORM_BLOCK: Self = Self(157);
    #[doc(alias = "VK_FORMAT_ASTC_4x4_SRGB_BLOCK")]
    pub const ASTC4X4_SRGB_BLOCK: Self = Self(158);
    #[doc(alias = "VK_FORMAT_ASTC_5x4_UNORM_BLOCK")]
    pub const ASTC5X4_UNORM_BLOCK: Self = Self(159);
    #[doc(alias = "VK_FORMAT_ASTC_5x4_SRGB_BLOCK")]
    pub const ASTC5X4_SRGB_BLOCK: Self = Self(160);
    #[doc(alias = "VK_FORMAT_ASTC_5x5_UNORM_BLOCK")]
    pub const ASTC5X5_UNORM_BLOCK: Self = Self(161);
    #[doc(alias = "VK_FORMAT_ASTC_5x5_SRGB_BLOCK")]
    pub const ASTC5X5_SRGB_BLOCK: Self = Self(162);
    #[doc(alias = "VK_FORMAT_ASTC_6x5_UNORM_BLOCK")]
    pub const ASTC6X5_UNORM_BLOCK: Self = Self(163);
    #[doc(alias = "VK_FORMAT_ASTC_6x5_SRGB_BLOCK")]
    pub const ASTC6X5_SRGB_BLOCK: Self = Self(164);
    #[doc(alias = "VK_FORMAT_ASTC_6x6_UNORM_BLOCK")]
    pub const ASTC6X6_UNORM_BLOCK: Self = Self(165);
    #[doc(alias = "VK_FORMAT_ASTC_6x6_SRGB_BLOCK")]
    pub const ASTC6X6_SRGB_BLOCK: Self = Self(166);
    #[doc(alias = "VK_FORMAT_ASTC_8x5_UNORM_BLOCK")]
    pub const ASTC8X5_UNORM_BLOCK: Self = Self(167);
    #[doc(alias = "VK_FORMAT_ASTC_8x5_SRGB_BLOCK")]
    pub const ASTC8X5_SRGB_BLOCK: Self = Self(168);
    #[doc(alias = "VK_FORMAT_ASTC_8x6_UNORM_BLOCK")]
    pub const ASTC8X6_UNORM_BLOCK: Self = Self(169);
    #[doc(alias = "VK_FORMAT_ASTC_8x6_SRGB_BLOCK")]
    pub const ASTC8X6_SRGB_BLOCK: Self = Self(170);
    #[doc(alias = "VK_FORMAT_ASTC_8x8_UNORM_BLOCK")]
    pub const ASTC8X8_UNORM_BLOCK: Self = Self(171);
    #[doc(alias = "VK_FORMAT_ASTC_8x8_SRGB_BLOCK")]
    pub const ASTC8X8_SRGB_BLOCK: Self = Self(172);
    #[doc(alias = "VK_FORMAT_ASTC_10x5_UNORM_BLOCK")]
    pub const ASTC10X5_UNORM_BLOCK: Self = Self(173);
    #[doc(alias = "VK_FORMAT_ASTC_10x5_SRGB_BLOCK")]
    pub const ASTC10X5_SRGB_BLOCK: Self = Self(174);
    #[doc(alias = "VK_FORMAT_ASTC_10x6_UNORM_BLOCK")]
    pub const ASTC10X6_UNORM_BLOCK: Self = Self(175);
    #[doc(alias = "VK_FORMAT_ASTC_10x6_SRGB_BLOCK")]
    pub const ASTC10X6_SRGB_BLOCK: Self = Self(176);
    #[doc(alias = "VK_FORMAT_ASTC_10x8_UNORM_BLOCK")]
    pub const ASTC10X8_UNORM_BLOCK: Self = Self(177);
    #[doc(alias = "VK_FORMAT_ASTC_10x8_SRGB_BLOCK")]
    pub const ASTC10X8_SRGB_BLOCK: Self = Self(178);
    #[doc(alias = "VK_FORMAT_ASTC_10x10_UNORM_BLOCK")]
    pub const ASTC10X10_UNORM_BLOCK: Self = Self(179);
    #[doc(alias = "VK_FORMAT_ASTC_10x10_SRGB_BLOCK")]
    pub const ASTC10X10_SRGB_BLOCK: Self = Self(180);
    #[doc(alias = "VK_FORMAT_ASTC_12x10_UNORM_BLOCK")]
    pub const ASTC12X10_UNORM_BLOCK: Self = Self(181);
    #[doc(alias = "VK_FORMAT_ASTC_12x10_SRGB_BLOCK")]
    pub const ASTC12X10_SRGB_BLOCK: Self = Self(182);
    #[doc(alias = "VK_FORMAT_ASTC_12x12_UNORM_BLOCK")]
    pub const ASTC12X12_UNORM_BLOCK: Self = Self(183);
    #[doc(alias = "VK_FORMAT_ASTC_12x12_SRGB_BLOCK")]
    pub const ASTC12X12_SRGB_BLOCK: Self = Self(184);
    #[doc(alias = "VK_FORMAT_G8B8G8R8_422_UNORM")]
    pub const G8B8G8R8422_UNORM: Self = Self(1000156000);
    #[doc(alias = "VK_FORMAT_B8G8R8G8_422_UNORM")]
    pub const B8G8R8G8422_UNORM: Self = Self(1000156001);
    #[doc(alias = "VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM")]
    pub const G8_B8_R83PLANE_420_UNORM: Self = Self(1000156002);
    #[doc(alias = "VK_FORMAT_G8_B8R8_2PLANE_420_UNORM")]
    pub const G8_B8R82PLANE_420_UNORM: Self = Self(1000156003);
    #[doc(alias = "VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM")]
    pub const G8_B8_R83PLANE_422_UNORM: Self = Self(1000156004);
    #[doc(alias = "VK_FORMAT_G8_B8R8_2PLANE_422_UNORM")]
    pub const G8_B8R82PLANE_422_UNORM: Self = Self(1000156005);
    #[doc(alias = "VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM")]
    pub const G8_B8_R83PLANE_444_UNORM: Self = Self(1000156006);
    #[doc(alias = "VK_FORMAT_R10X6_UNORM_PACK16")]
    pub const R10X6_UNORM_PACK16: Self = Self(1000156007);
    #[doc(alias = "VK_FORMAT_R10X6G10X6_UNORM_2PACK16")]
    pub const R10X6G10X6_UNORM2PACK16: Self = Self(1000156008);
    #[doc(alias = "VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16")]
    pub const R10X6G10X6B10X6A10X6_UNORM4PACK16: Self = Self(1000156009);
    #[doc(alias = "VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16")]
    pub const G10X6B10X6G10X6R10X6422_UNORM_4PACK16: Self = Self(1000156010);
    #[doc(alias = "VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16")]
    pub const B10X6G10X6R10X6G10X6422_UNORM_4PACK16: Self = Self(1000156011);
    #[doc(alias = "VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16")]
    pub const G10X6_B10X6_R10X63PLANE_420_UNORM_3PACK16: Self = Self(1000156012);
    #[doc(alias = "VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16")]
    pub const G10X6_B10X6R10X62PLANE_420_UNORM_3PACK16: Self = Self(1000156013);
    #[doc(alias = "VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16")]
    pub const G10X6_B10X6_R10X63PLANE_422_UNORM_3PACK16: Self = Self(1000156014);
    #[doc(alias = "VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16")]
    pub const G10X6_B10X6R10X62PLANE_422_UNORM_3PACK16: Self = Self(1000156015);
    #[doc(alias = "VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16")]
    pub const G10X6_B10X6_R10X63PLANE_444_UNORM_3PACK16: Self = Self(1000156016);
    #[doc(alias = "VK_FORMAT_R12X4_UNORM_PACK16")]
    pub const R12X4_UNORM_PACK16: Self = Self(1000156017);
    #[doc(alias = "VK_FORMAT_R12X4G12X4_UNORM_2PACK16")]
    pub const R12X4G12X4_UNORM2PACK16: Self = Self(1000156018);
    #[doc(alias = "VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16")]
    pub const R12X4G12X4B12X4A12X4_UNORM4PACK16: Self = Self(1000156019);
    #[doc(alias = "VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16")]
    pub const G12X4B12X4G12X4R12X4422_UNORM_4PACK16: Self = Self(1000156020);
    #[doc(alias = "VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16")]
    pub const B12X4G12X4R12X4G12X4422_UNORM_4PACK16: Self = Self(1000156021);
    #[doc(alias = "VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16")]
    pub const G12X4_B12X4_R12X43PLANE_420_UNORM_3PACK16: Self = Self(1000156022);
    #[doc(alias = "VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16")]
    pub const G12X4_B12X4R12X42PLANE_420_UNORM_3PACK16: Self = Self(1000156023);
    #[doc(alias = "VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16")]
    pub const G12X4_B12X4_R12X43PLANE_422_UNORM_3PACK16: Self = Self(1000156024);
    #[doc(alias = "VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16")]
    pub const G12X4_B12X4R12X42PLANE_422_UNORM_3PACK16: Self = Self(1000156025);
    #[doc(alias = "VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16")]
    pub const G12X4_B12X4_R12X43PLANE_444_UNORM_3PACK16: Self = Self(1000156026);
    #[doc(alias = "VK_FORMAT_G16B16G16R16_422_UNORM")]
    pub const G16B16G16R16422_UNORM: Self = Self(1000156027);
    #[doc(alias = "VK_FORMAT_B16G16R16G16_422_UNORM")]
    pub const B16G16R16G16422_UNORM: Self = Self(1000156028);
    #[doc(alias = "VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM")]
    pub const G16_B16_R163PLANE_420_UNORM: Self = Self(1000156029);
    #[doc(alias = "VK_FORMAT_G16_B16R16_2PLANE_420_UNORM")]
    pub const G16_B16R162PLANE_420_UNORM: Self = Self(1000156030);
    #[doc(alias = "VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM")]
    pub const G16_B16_R163PLANE_422_UNORM: Self = Self(1000156031);
    #[doc(alias = "VK_FORMAT_G16_B16R16_2PLANE_422_UNORM")]
    pub const G16_B16R162PLANE_422_UNORM: Self = Self(1000156032);
    #[doc(alias = "VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM")]
    pub const G16_B16_R163PLANE_444_UNORM: Self = Self(1000156033);
    #[doc(alias = "VK_FORMAT_G8_B8R8_2PLANE_444_UNORM")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const G8_B8R82PLANE_444_UNORM: Self = Self(1000330000);
    #[doc(alias = "VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const G10X6_B10X6R10X62PLANE_444_UNORM_3PACK16: Self = Self(1000330001);
    #[doc(alias = "VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const G12X4_B12X4R12X42PLANE_444_UNORM_3PACK16: Self = Self(1000330002);
    #[doc(alias = "VK_FORMAT_G16_B16R16_2PLANE_444_UNORM")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const G16_B16R162PLANE_444_UNORM: Self = Self(1000330003);
    #[doc(alias = "VK_FORMAT_A4R4G4B4_UNORM_PACK16")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const A4R4G4B4_UNORM_PACK16: Self = Self(1000340000);
    #[doc(alias = "VK_FORMAT_A4B4G4R4_UNORM_PACK16")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const A4B4G4R4_UNORM_PACK16: Self = Self(1000340001);
    #[doc(alias = "VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const ASTC4X4_SFLOAT_BLOCK: Self = Self(1000066000);
    #[doc(alias = "VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const ASTC5X4_SFLOAT_BLOCK: Self = Self(1000066001);
    #[doc(alias = "VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const ASTC5X5_SFLOAT_BLOCK: Self = Self(1000066002);
    #[doc(alias = "VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const ASTC6X5_SFLOAT_BLOCK: Self = Self(1000066003);
    #[doc(alias = "VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const ASTC6X6_SFLOAT_BLOCK: Self = Self(1000066004);
    #[doc(alias = "VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const ASTC8X5_SFLOAT_BLOCK: Self = Self(1000066005);
    #[doc(alias = "VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const ASTC8X6_SFLOAT_BLOCK: Self = Self(1000066006);
    #[doc(alias = "VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const ASTC8X8_SFLOAT_BLOCK: Self = Self(1000066007);
    #[doc(alias = "VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const ASTC10X5_SFLOAT_BLOCK: Self = Self(1000066008);
    #[doc(alias = "VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const ASTC10X6_SFLOAT_BLOCK: Self = Self(1000066009);
    #[doc(alias = "VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const ASTC10X8_SFLOAT_BLOCK: Self = Self(1000066010);
    #[doc(alias = "VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const ASTC10X10_SFLOAT_BLOCK: Self = Self(1000066011);
    #[doc(alias = "VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const ASTC12X10_SFLOAT_BLOCK: Self = Self(1000066012);
    #[doc(alias = "VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const ASTC12X12_SFLOAT_BLOCK: Self = Self(1000066013);
    #[doc(alias = "VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG")]
    #[cfg(feature = "VK_IMG_format_pvrtc")]
    pub const PVRTC12BPP_UNORM_BLOCK_IMG: Self = Self(1000054000);
    #[doc(alias = "VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG")]
    #[cfg(feature = "VK_IMG_format_pvrtc")]
    pub const PVRTC14BPP_UNORM_BLOCK_IMG: Self = Self(1000054001);
    #[doc(alias = "VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG")]
    #[cfg(feature = "VK_IMG_format_pvrtc")]
    pub const PVRTC22BPP_UNORM_BLOCK_IMG: Self = Self(1000054002);
    #[doc(alias = "VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG")]
    #[cfg(feature = "VK_IMG_format_pvrtc")]
    pub const PVRTC24BPP_UNORM_BLOCK_IMG: Self = Self(1000054003);
    #[doc(alias = "VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG")]
    #[cfg(feature = "VK_IMG_format_pvrtc")]
    pub const PVRTC12BPP_SRGB_BLOCK_IMG: Self = Self(1000054004);
    #[doc(alias = "VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG")]
    #[cfg(feature = "VK_IMG_format_pvrtc")]
    pub const PVRTC14BPP_SRGB_BLOCK_IMG: Self = Self(1000054005);
    #[doc(alias = "VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG")]
    #[cfg(feature = "VK_IMG_format_pvrtc")]
    pub const PVRTC22BPP_SRGB_BLOCK_IMG: Self = Self(1000054006);
    #[doc(alias = "VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG")]
    #[cfg(feature = "VK_IMG_format_pvrtc")]
    pub const PVRTC24BPP_SRGB_BLOCK_IMG: Self = Self(1000054007);
    #[doc(alias = "VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK_EXT")]
    #[cfg(feature = "VK_EXT_texture_compression_astc_hdr")]
    pub const ASTC4X4_SFLOAT_BLOCK_EXT: Self = Self::ASTC4X4_SFLOAT_BLOCK;
    #[doc(alias = "VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK_EXT")]
    #[cfg(feature = "VK_EXT_texture_compression_astc_hdr")]
    pub const ASTC5X4_SFLOAT_BLOCK_EXT: Self = Self::ASTC5X4_SFLOAT_BLOCK;
    #[doc(alias = "VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK_EXT")]
    #[cfg(feature = "VK_EXT_texture_compression_astc_hdr")]
    pub const ASTC5X5_SFLOAT_BLOCK_EXT: Self = Self::ASTC5X5_SFLOAT_BLOCK;
    #[doc(alias = "VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK_EXT")]
    #[cfg(feature = "VK_EXT_texture_compression_astc_hdr")]
    pub const ASTC6X5_SFLOAT_BLOCK_EXT: Self = Self::ASTC6X5_SFLOAT_BLOCK;
    #[doc(alias = "VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK_EXT")]
    #[cfg(feature = "VK_EXT_texture_compression_astc_hdr")]
    pub const ASTC6X6_SFLOAT_BLOCK_EXT: Self = Self::ASTC6X6_SFLOAT_BLOCK;
    #[doc(alias = "VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK_EXT")]
    #[cfg(feature = "VK_EXT_texture_compression_astc_hdr")]
    pub const ASTC8X5_SFLOAT_BLOCK_EXT: Self = Self::ASTC8X5_SFLOAT_BLOCK;
    #[doc(alias = "VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK_EXT")]
    #[cfg(feature = "VK_EXT_texture_compression_astc_hdr")]
    pub const ASTC8X6_SFLOAT_BLOCK_EXT: Self = Self::ASTC8X6_SFLOAT_BLOCK;
    #[doc(alias = "VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK_EXT")]
    #[cfg(feature = "VK_EXT_texture_compression_astc_hdr")]
    pub const ASTC8X8_SFLOAT_BLOCK_EXT: Self = Self::ASTC8X8_SFLOAT_BLOCK;
    #[doc(alias = "VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK_EXT")]
    #[cfg(feature = "VK_EXT_texture_compression_astc_hdr")]
    pub const ASTC10X5_SFLOAT_BLOCK_EXT: Self = Self::ASTC10X5_SFLOAT_BLOCK;
    #[doc(alias = "VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK_EXT")]
    #[cfg(feature = "VK_EXT_texture_compression_astc_hdr")]
    pub const ASTC10X6_SFLOAT_BLOCK_EXT: Self = Self::ASTC10X6_SFLOAT_BLOCK;
    #[doc(alias = "VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK_EXT")]
    #[cfg(feature = "VK_EXT_texture_compression_astc_hdr")]
    pub const ASTC10X8_SFLOAT_BLOCK_EXT: Self = Self::ASTC10X8_SFLOAT_BLOCK;
    #[doc(alias = "VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK_EXT")]
    #[cfg(feature = "VK_EXT_texture_compression_astc_hdr")]
    pub const ASTC10X10_SFLOAT_BLOCK_EXT: Self = Self::ASTC10X10_SFLOAT_BLOCK;
    #[doc(alias = "VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK_EXT")]
    #[cfg(feature = "VK_EXT_texture_compression_astc_hdr")]
    pub const ASTC12X10_SFLOAT_BLOCK_EXT: Self = Self::ASTC12X10_SFLOAT_BLOCK;
    #[doc(alias = "VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK_EXT")]
    #[cfg(feature = "VK_EXT_texture_compression_astc_hdr")]
    pub const ASTC12X12_SFLOAT_BLOCK_EXT: Self = Self::ASTC12X12_SFLOAT_BLOCK;
    #[doc(alias = "VK_FORMAT_G8B8G8R8_422_UNORM_KHR")]
    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
    pub const G8B8G8R8422_UNORM_KHR: Self = Self::G8B8G8R8422_UNORM;
    #[doc(alias = "VK_FORMAT_B8G8R8G8_422_UNORM_KHR")]
    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
    pub const B8G8R8G8422_UNORM_KHR: Self = Self::B8G8R8G8422_UNORM;
    #[doc(alias = "VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM_KHR")]
    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
    pub const G8_B8_R83PLANE_420_UNORM_KHR: Self = Self::G8_B8_R83PLANE_420_UNORM;
    #[doc(alias = "VK_FORMAT_G8_B8R8_2PLANE_420_UNORM_KHR")]
    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
    pub const G8_B8R82PLANE_420_UNORM_KHR: Self = Self::G8_B8R82PLANE_420_UNORM;
    #[doc(alias = "VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM_KHR")]
    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
    pub const G8_B8_R83PLANE_422_UNORM_KHR: Self = Self::G8_B8_R83PLANE_422_UNORM;
    #[doc(alias = "VK_FORMAT_G8_B8R8_2PLANE_422_UNORM_KHR")]
    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
    pub const G8_B8R82PLANE_422_UNORM_KHR: Self = Self::G8_B8R82PLANE_422_UNORM;
    #[doc(alias = "VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM_KHR")]
    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
    pub const G8_B8_R83PLANE_444_UNORM_KHR: Self = Self::G8_B8_R83PLANE_444_UNORM;
    #[doc(alias = "VK_FORMAT_R10X6_UNORM_PACK16_KHR")]
    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
    pub const R10X6_UNORM_PACK16_KHR: Self = Self::R10X6_UNORM_PACK16;
    #[doc(alias = "VK_FORMAT_R10X6G10X6_UNORM_2PACK16_KHR")]
    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
    pub const R10X6G10X6_UNORM2PACK16_KHR: Self = Self::R10X6G10X6_UNORM2PACK16;
    #[doc(alias = "VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16_KHR")]
    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
    pub const R10X6G10X6B10X6A10X6_UNORM4PACK16_KHR: Self = Self::R10X6G10X6B10X6A10X6_UNORM4PACK16;
    #[doc(alias = "VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16_KHR")]
    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
    pub const G10X6B10X6G10X6R10X6422_UNORM_4PACK16_KHR: Self = Self::G10X6B10X6G10X6R10X6422_UNORM_4PACK16;
    #[doc(alias = "VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16_KHR")]
    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
    pub const B10X6G10X6R10X6G10X6422_UNORM_4PACK16_KHR: Self = Self::B10X6G10X6R10X6G10X6422_UNORM_4PACK16;
    #[doc(alias = "VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16_KHR")]
    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
    pub const G10X6_B10X6_R10X63PLANE_420_UNORM_3PACK16_KHR: Self = Self::G10X6_B10X6_R10X63PLANE_420_UNORM_3PACK16;
    #[doc(alias = "VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16_KHR")]
    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
    pub const G10X6_B10X6R10X62PLANE_420_UNORM_3PACK16_KHR: Self = Self::G10X6_B10X6R10X62PLANE_420_UNORM_3PACK16;
    #[doc(alias = "VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16_KHR")]
    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
    pub const G10X6_B10X6_R10X63PLANE_422_UNORM_3PACK16_KHR: Self = Self::G10X6_B10X6_R10X63PLANE_422_UNORM_3PACK16;
    #[doc(alias = "VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16_KHR")]
    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
    pub const G10X6_B10X6R10X62PLANE_422_UNORM_3PACK16_KHR: Self = Self::G10X6_B10X6R10X62PLANE_422_UNORM_3PACK16;
    #[doc(alias = "VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16_KHR")]
    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
    pub const G10X6_B10X6_R10X63PLANE_444_UNORM_3PACK16_KHR: Self = Self::G10X6_B10X6_R10X63PLANE_444_UNORM_3PACK16;
    #[doc(alias = "VK_FORMAT_R12X4_UNORM_PACK16_KHR")]
    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
    pub const R12X4_UNORM_PACK16_KHR: Self = Self::R12X4_UNORM_PACK16;
    #[doc(alias = "VK_FORMAT_R12X4G12X4_UNORM_2PACK16_KHR")]
    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
    pub const R12X4G12X4_UNORM2PACK16_KHR: Self = Self::R12X4G12X4_UNORM2PACK16;
    #[doc(alias = "VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16_KHR")]
    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
    pub const R12X4G12X4B12X4A12X4_UNORM4PACK16_KHR: Self = Self::R12X4G12X4B12X4A12X4_UNORM4PACK16;
    #[doc(alias = "VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16_KHR")]
    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
    pub const G12X4B12X4G12X4R12X4422_UNORM_4PACK16_KHR: Self = Self::G12X4B12X4G12X4R12X4422_UNORM_4PACK16;
    #[doc(alias = "VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16_KHR")]
    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
    pub const B12X4G12X4R12X4G12X4422_UNORM_4PACK16_KHR: Self = Self::B12X4G12X4R12X4G12X4422_UNORM_4PACK16;
    #[doc(alias = "VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16_KHR")]
    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
    pub const G12X4_B12X4_R12X43PLANE_420_UNORM_3PACK16_KHR: Self = Self::G12X4_B12X4_R12X43PLANE_420_UNORM_3PACK16;
    #[doc(alias = "VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16_KHR")]
    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
    pub const G12X4_B12X4R12X42PLANE_420_UNORM_3PACK16_KHR: Self = Self::G12X4_B12X4R12X42PLANE_420_UNORM_3PACK16;
    #[doc(alias = "VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16_KHR")]
    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
    pub const G12X4_B12X4_R12X43PLANE_422_UNORM_3PACK16_KHR: Self = Self::G12X4_B12X4_R12X43PLANE_422_UNORM_3PACK16;
    #[doc(alias = "VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16_KHR")]
    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
    pub const G12X4_B12X4R12X42PLANE_422_UNORM_3PACK16_KHR: Self = Self::G12X4_B12X4R12X42PLANE_422_UNORM_3PACK16;
    #[doc(alias = "VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16_KHR")]
    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
    pub const G12X4_B12X4_R12X43PLANE_444_UNORM_3PACK16_KHR: Self = Self::G12X4_B12X4_R12X43PLANE_444_UNORM_3PACK16;
    #[doc(alias = "VK_FORMAT_G16B16G16R16_422_UNORM_KHR")]
    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
    pub const G16B16G16R16422_UNORM_KHR: Self = Self::G16B16G16R16422_UNORM;
    #[doc(alias = "VK_FORMAT_B16G16R16G16_422_UNORM_KHR")]
    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
    pub const B16G16R16G16422_UNORM_KHR: Self = Self::B16G16R16G16422_UNORM;
    #[doc(alias = "VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM_KHR")]
    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
    pub const G16_B16_R163PLANE_420_UNORM_KHR: Self = Self::G16_B16_R163PLANE_420_UNORM;
    #[doc(alias = "VK_FORMAT_G16_B16R16_2PLANE_420_UNORM_KHR")]
    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
    pub const G16_B16R162PLANE_420_UNORM_KHR: Self = Self::G16_B16R162PLANE_420_UNORM;
    #[doc(alias = "VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM_KHR")]
    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
    pub const G16_B16_R163PLANE_422_UNORM_KHR: Self = Self::G16_B16_R163PLANE_422_UNORM;
    #[doc(alias = "VK_FORMAT_G16_B16R16_2PLANE_422_UNORM_KHR")]
    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
    pub const G16_B16R162PLANE_422_UNORM_KHR: Self = Self::G16_B16R162PLANE_422_UNORM;
    #[doc(alias = "VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM_KHR")]
    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
    pub const G16_B16_R163PLANE_444_UNORM_KHR: Self = Self::G16_B16_R163PLANE_444_UNORM;
    #[doc(alias = "VK_FORMAT_G8_B8R8_2PLANE_444_UNORM_EXT")]
    #[cfg(feature = "VK_EXT_ycbcr_2plane_444_formats")]
    pub const G8_B8R82PLANE_444_UNORM_EXT: Self = Self::G8_B8R82PLANE_444_UNORM;
    #[doc(alias = "VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16_EXT")]
    #[cfg(feature = "VK_EXT_ycbcr_2plane_444_formats")]
    pub const G10X6_B10X6R10X62PLANE_444_UNORM_3PACK16_EXT: Self = Self::G10X6_B10X6R10X62PLANE_444_UNORM_3PACK16;
    #[doc(alias = "VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16_EXT")]
    #[cfg(feature = "VK_EXT_ycbcr_2plane_444_formats")]
    pub const G12X4_B12X4R12X42PLANE_444_UNORM_3PACK16_EXT: Self = Self::G12X4_B12X4R12X42PLANE_444_UNORM_3PACK16;
    #[doc(alias = "VK_FORMAT_G16_B16R16_2PLANE_444_UNORM_EXT")]
    #[cfg(feature = "VK_EXT_ycbcr_2plane_444_formats")]
    pub const G16_B16R162PLANE_444_UNORM_EXT: Self = Self::G16_B16R162PLANE_444_UNORM;
    #[doc(alias = "VK_FORMAT_A4R4G4B4_UNORM_PACK16_EXT")]
    #[cfg(feature = "VK_EXT_4444_formats")]
    pub const A4R4G4B4_UNORM_PACK16_EXT: Self = Self::A4R4G4B4_UNORM_PACK16;
    #[doc(alias = "VK_FORMAT_A4B4G4R4_UNORM_PACK16_EXT")]
    #[cfg(feature = "VK_EXT_4444_formats")]
    pub const A4B4G4R4_UNORM_PACK16_EXT: Self = Self::A4B4G4R4_UNORM_PACK16;
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> i32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: i32) -> Option<Self> {
        match bits {
            x if x == Self::UNDEFINED.bits() => Some(Self(x)),
            x if x == Self::R4G4_UNORM_PACK8.bits() => Some(Self(x)),
            x if x == Self::R4G4B4A4_UNORM_PACK16.bits() => Some(Self(x)),
            x if x == Self::B4G4R4A4_UNORM_PACK16.bits() => Some(Self(x)),
            x if x == Self::R5G6B5_UNORM_PACK16.bits() => Some(Self(x)),
            x if x == Self::B5G6R5_UNORM_PACK16.bits() => Some(Self(x)),
            x if x == Self::R5G5B5A1_UNORM_PACK16.bits() => Some(Self(x)),
            x if x == Self::B5G5R5A1_UNORM_PACK16.bits() => Some(Self(x)),
            x if x == Self::A1R5G5B5_UNORM_PACK16.bits() => Some(Self(x)),
            x if x == Self::R8_UNORM.bits() => Some(Self(x)),
            x if x == Self::R8_SNORM.bits() => Some(Self(x)),
            x if x == Self::R8_USCALED.bits() => Some(Self(x)),
            x if x == Self::R8_SSCALED.bits() => Some(Self(x)),
            x if x == Self::R8_UINT.bits() => Some(Self(x)),
            x if x == Self::R8_SINT.bits() => Some(Self(x)),
            x if x == Self::R8_SRGB.bits() => Some(Self(x)),
            x if x == Self::R8G8_UNORM.bits() => Some(Self(x)),
            x if x == Self::R8G8_SNORM.bits() => Some(Self(x)),
            x if x == Self::R8G8_USCALED.bits() => Some(Self(x)),
            x if x == Self::R8G8_SSCALED.bits() => Some(Self(x)),
            x if x == Self::R8G8_UINT.bits() => Some(Self(x)),
            x if x == Self::R8G8_SINT.bits() => Some(Self(x)),
            x if x == Self::R8G8_SRGB.bits() => Some(Self(x)),
            x if x == Self::R8G8B8_UNORM.bits() => Some(Self(x)),
            x if x == Self::R8G8B8_SNORM.bits() => Some(Self(x)),
            x if x == Self::R8G8B8_USCALED.bits() => Some(Self(x)),
            x if x == Self::R8G8B8_SSCALED.bits() => Some(Self(x)),
            x if x == Self::R8G8B8_UINT.bits() => Some(Self(x)),
            x if x == Self::R8G8B8_SINT.bits() => Some(Self(x)),
            x if x == Self::R8G8B8_SRGB.bits() => Some(Self(x)),
            x if x == Self::B8G8R8_UNORM.bits() => Some(Self(x)),
            x if x == Self::B8G8R8_SNORM.bits() => Some(Self(x)),
            x if x == Self::B8G8R8_USCALED.bits() => Some(Self(x)),
            x if x == Self::B8G8R8_SSCALED.bits() => Some(Self(x)),
            x if x == Self::B8G8R8_UINT.bits() => Some(Self(x)),
            x if x == Self::B8G8R8_SINT.bits() => Some(Self(x)),
            x if x == Self::B8G8R8_SRGB.bits() => Some(Self(x)),
            x if x == Self::R8G8B8A8_UNORM.bits() => Some(Self(x)),
            x if x == Self::R8G8B8A8_SNORM.bits() => Some(Self(x)),
            x if x == Self::R8G8B8A8_USCALED.bits() => Some(Self(x)),
            x if x == Self::R8G8B8A8_SSCALED.bits() => Some(Self(x)),
            x if x == Self::R8G8B8A8_UINT.bits() => Some(Self(x)),
            x if x == Self::R8G8B8A8_SINT.bits() => Some(Self(x)),
            x if x == Self::R8G8B8A8_SRGB.bits() => Some(Self(x)),
            x if x == Self::B8G8R8A8_UNORM.bits() => Some(Self(x)),
            x if x == Self::B8G8R8A8_SNORM.bits() => Some(Self(x)),
            x if x == Self::B8G8R8A8_USCALED.bits() => Some(Self(x)),
            x if x == Self::B8G8R8A8_SSCALED.bits() => Some(Self(x)),
            x if x == Self::B8G8R8A8_UINT.bits() => Some(Self(x)),
            x if x == Self::B8G8R8A8_SINT.bits() => Some(Self(x)),
            x if x == Self::B8G8R8A8_SRGB.bits() => Some(Self(x)),
            x if x == Self::A8B8G8R8_UNORM_PACK32.bits() => Some(Self(x)),
            x if x == Self::A8B8G8R8_SNORM_PACK32.bits() => Some(Self(x)),
            x if x == Self::A8B8G8R8_USCALED_PACK32.bits() => Some(Self(x)),
            x if x == Self::A8B8G8R8_SSCALED_PACK32.bits() => Some(Self(x)),
            x if x == Self::A8B8G8R8_UINT_PACK32.bits() => Some(Self(x)),
            x if x == Self::A8B8G8R8_SINT_PACK32.bits() => Some(Self(x)),
            x if x == Self::A8B8G8R8_SRGB_PACK32.bits() => Some(Self(x)),
            x if x == Self::A2R10G10B10_UNORM_PACK32.bits() => Some(Self(x)),
            x if x == Self::A2R10G10B10_SNORM_PACK32.bits() => Some(Self(x)),
            x if x == Self::A2R10G10B10_USCALED_PACK32.bits() => Some(Self(x)),
            x if x == Self::A2R10G10B10_SSCALED_PACK32.bits() => Some(Self(x)),
            x if x == Self::A2R10G10B10_UINT_PACK32.bits() => Some(Self(x)),
            x if x == Self::A2R10G10B10_SINT_PACK32.bits() => Some(Self(x)),
            x if x == Self::A2B10G10R10_UNORM_PACK32.bits() => Some(Self(x)),
            x if x == Self::A2B10G10R10_SNORM_PACK32.bits() => Some(Self(x)),
            x if x == Self::A2B10G10R10_USCALED_PACK32.bits() => Some(Self(x)),
            x if x == Self::A2B10G10R10_SSCALED_PACK32.bits() => Some(Self(x)),
            x if x == Self::A2B10G10R10_UINT_PACK32.bits() => Some(Self(x)),
            x if x == Self::A2B10G10R10_SINT_PACK32.bits() => Some(Self(x)),
            x if x == Self::R16_UNORM.bits() => Some(Self(x)),
            x if x == Self::R16_SNORM.bits() => Some(Self(x)),
            x if x == Self::R16_USCALED.bits() => Some(Self(x)),
            x if x == Self::R16_SSCALED.bits() => Some(Self(x)),
            x if x == Self::R16_UINT.bits() => Some(Self(x)),
            x if x == Self::R16_SINT.bits() => Some(Self(x)),
            x if x == Self::R16_SFLOAT.bits() => Some(Self(x)),
            x if x == Self::R16G16_UNORM.bits() => Some(Self(x)),
            x if x == Self::R16G16_SNORM.bits() => Some(Self(x)),
            x if x == Self::R16G16_USCALED.bits() => Some(Self(x)),
            x if x == Self::R16G16_SSCALED.bits() => Some(Self(x)),
            x if x == Self::R16G16_UINT.bits() => Some(Self(x)),
            x if x == Self::R16G16_SINT.bits() => Some(Self(x)),
            x if x == Self::R16G16_SFLOAT.bits() => Some(Self(x)),
            x if x == Self::R16G16B16_UNORM.bits() => Some(Self(x)),
            x if x == Self::R16G16B16_SNORM.bits() => Some(Self(x)),
            x if x == Self::R16G16B16_USCALED.bits() => Some(Self(x)),
            x if x == Self::R16G16B16_SSCALED.bits() => Some(Self(x)),
            x if x == Self::R16G16B16_UINT.bits() => Some(Self(x)),
            x if x == Self::R16G16B16_SINT.bits() => Some(Self(x)),
            x if x == Self::R16G16B16_SFLOAT.bits() => Some(Self(x)),
            x if x == Self::R16G16B16A16_UNORM.bits() => Some(Self(x)),
            x if x == Self::R16G16B16A16_SNORM.bits() => Some(Self(x)),
            x if x == Self::R16G16B16A16_USCALED.bits() => Some(Self(x)),
            x if x == Self::R16G16B16A16_SSCALED.bits() => Some(Self(x)),
            x if x == Self::R16G16B16A16_UINT.bits() => Some(Self(x)),
            x if x == Self::R16G16B16A16_SINT.bits() => Some(Self(x)),
            x if x == Self::R16G16B16A16_SFLOAT.bits() => Some(Self(x)),
            x if x == Self::R32_UINT.bits() => Some(Self(x)),
            x if x == Self::R32_SINT.bits() => Some(Self(x)),
            x if x == Self::R32_SFLOAT.bits() => Some(Self(x)),
            x if x == Self::R32G32_UINT.bits() => Some(Self(x)),
            x if x == Self::R32G32_SINT.bits() => Some(Self(x)),
            x if x == Self::R32G32_SFLOAT.bits() => Some(Self(x)),
            x if x == Self::R32G32B32_UINT.bits() => Some(Self(x)),
            x if x == Self::R32G32B32_SINT.bits() => Some(Self(x)),
            x if x == Self::R32G32B32_SFLOAT.bits() => Some(Self(x)),
            x if x == Self::R32G32B32A32_UINT.bits() => Some(Self(x)),
            x if x == Self::R32G32B32A32_SINT.bits() => Some(Self(x)),
            x if x == Self::R32G32B32A32_SFLOAT.bits() => Some(Self(x)),
            x if x == Self::R64_UINT.bits() => Some(Self(x)),
            x if x == Self::R64_SINT.bits() => Some(Self(x)),
            x if x == Self::R64_SFLOAT.bits() => Some(Self(x)),
            x if x == Self::R64G64_UINT.bits() => Some(Self(x)),
            x if x == Self::R64G64_SINT.bits() => Some(Self(x)),
            x if x == Self::R64G64_SFLOAT.bits() => Some(Self(x)),
            x if x == Self::R64G64B64_UINT.bits() => Some(Self(x)),
            x if x == Self::R64G64B64_SINT.bits() => Some(Self(x)),
            x if x == Self::R64G64B64_SFLOAT.bits() => Some(Self(x)),
            x if x == Self::R64G64B64A64_UINT.bits() => Some(Self(x)),
            x if x == Self::R64G64B64A64_SINT.bits() => Some(Self(x)),
            x if x == Self::R64G64B64A64_SFLOAT.bits() => Some(Self(x)),
            x if x == Self::B10G11R11_UFLOAT_PACK32.bits() => Some(Self(x)),
            x if x == Self::E5B9G9R9_UFLOAT_PACK32.bits() => Some(Self(x)),
            x if x == Self::D16_UNORM.bits() => Some(Self(x)),
            x if x == Self::X8_D24_UNORM_PACK32.bits() => Some(Self(x)),
            x if x == Self::D32_SFLOAT.bits() => Some(Self(x)),
            x if x == Self::S8_UINT.bits() => Some(Self(x)),
            x if x == Self::D16_UNORM_S8_UINT.bits() => Some(Self(x)),
            x if x == Self::D24_UNORM_S8_UINT.bits() => Some(Self(x)),
            x if x == Self::D32_SFLOAT_S8_UINT.bits() => Some(Self(x)),
            x if x == Self::BC1_RGB_UNORM_BLOCK.bits() => Some(Self(x)),
            x if x == Self::BC1_RGB_SRGB_BLOCK.bits() => Some(Self(x)),
            x if x == Self::BC1_RGBA_UNORM_BLOCK.bits() => Some(Self(x)),
            x if x == Self::BC1_RGBA_SRGB_BLOCK.bits() => Some(Self(x)),
            x if x == Self::BC2_UNORM_BLOCK.bits() => Some(Self(x)),
            x if x == Self::BC2_SRGB_BLOCK.bits() => Some(Self(x)),
            x if x == Self::BC3_UNORM_BLOCK.bits() => Some(Self(x)),
            x if x == Self::BC3_SRGB_BLOCK.bits() => Some(Self(x)),
            x if x == Self::BC4_UNORM_BLOCK.bits() => Some(Self(x)),
            x if x == Self::BC4_SNORM_BLOCK.bits() => Some(Self(x)),
            x if x == Self::BC5_UNORM_BLOCK.bits() => Some(Self(x)),
            x if x == Self::BC5_SNORM_BLOCK.bits() => Some(Self(x)),
            x if x == Self::BC6H_UFLOAT_BLOCK.bits() => Some(Self(x)),
            x if x == Self::BC6H_SFLOAT_BLOCK.bits() => Some(Self(x)),
            x if x == Self::BC7_UNORM_BLOCK.bits() => Some(Self(x)),
            x if x == Self::BC7_SRGB_BLOCK.bits() => Some(Self(x)),
            x if x == Self::ETC2_R8G8B8_UNORM_BLOCK.bits() => Some(Self(x)),
            x if x == Self::ETC2_R8G8B8_SRGB_BLOCK.bits() => Some(Self(x)),
            x if x == Self::ETC2_R8G8B8A1_UNORM_BLOCK.bits() => Some(Self(x)),
            x if x == Self::ETC2_R8G8B8A1_SRGB_BLOCK.bits() => Some(Self(x)),
            x if x == Self::ETC2_R8G8B8A8_UNORM_BLOCK.bits() => Some(Self(x)),
            x if x == Self::ETC2_R8G8B8A8_SRGB_BLOCK.bits() => Some(Self(x)),
            x if x == Self::EAC_R11_UNORM_BLOCK.bits() => Some(Self(x)),
            x if x == Self::EAC_R11_SNORM_BLOCK.bits() => Some(Self(x)),
            x if x == Self::EAC_R11G11_UNORM_BLOCK.bits() => Some(Self(x)),
            x if x == Self::EAC_R11G11_SNORM_BLOCK.bits() => Some(Self(x)),
            x if x == Self::ASTC4X4_UNORM_BLOCK.bits() => Some(Self(x)),
            x if x == Self::ASTC4X4_SRGB_BLOCK.bits() => Some(Self(x)),
            x if x == Self::ASTC5X4_UNORM_BLOCK.bits() => Some(Self(x)),
            x if x == Self::ASTC5X4_SRGB_BLOCK.bits() => Some(Self(x)),
            x if x == Self::ASTC5X5_UNORM_BLOCK.bits() => Some(Self(x)),
            x if x == Self::ASTC5X5_SRGB_BLOCK.bits() => Some(Self(x)),
            x if x == Self::ASTC6X5_UNORM_BLOCK.bits() => Some(Self(x)),
            x if x == Self::ASTC6X5_SRGB_BLOCK.bits() => Some(Self(x)),
            x if x == Self::ASTC6X6_UNORM_BLOCK.bits() => Some(Self(x)),
            x if x == Self::ASTC6X6_SRGB_BLOCK.bits() => Some(Self(x)),
            x if x == Self::ASTC8X5_UNORM_BLOCK.bits() => Some(Self(x)),
            x if x == Self::ASTC8X5_SRGB_BLOCK.bits() => Some(Self(x)),
            x if x == Self::ASTC8X6_UNORM_BLOCK.bits() => Some(Self(x)),
            x if x == Self::ASTC8X6_SRGB_BLOCK.bits() => Some(Self(x)),
            x if x == Self::ASTC8X8_UNORM_BLOCK.bits() => Some(Self(x)),
            x if x == Self::ASTC8X8_SRGB_BLOCK.bits() => Some(Self(x)),
            x if x == Self::ASTC10X5_UNORM_BLOCK.bits() => Some(Self(x)),
            x if x == Self::ASTC10X5_SRGB_BLOCK.bits() => Some(Self(x)),
            x if x == Self::ASTC10X6_UNORM_BLOCK.bits() => Some(Self(x)),
            x if x == Self::ASTC10X6_SRGB_BLOCK.bits() => Some(Self(x)),
            x if x == Self::ASTC10X8_UNORM_BLOCK.bits() => Some(Self(x)),
            x if x == Self::ASTC10X8_SRGB_BLOCK.bits() => Some(Self(x)),
            x if x == Self::ASTC10X10_UNORM_BLOCK.bits() => Some(Self(x)),
            x if x == Self::ASTC10X10_SRGB_BLOCK.bits() => Some(Self(x)),
            x if x == Self::ASTC12X10_UNORM_BLOCK.bits() => Some(Self(x)),
            x if x == Self::ASTC12X10_SRGB_BLOCK.bits() => Some(Self(x)),
            x if x == Self::ASTC12X12_UNORM_BLOCK.bits() => Some(Self(x)),
            x if x == Self::ASTC12X12_SRGB_BLOCK.bits() => Some(Self(x)),
            x if x == Self::G8B8G8R8422_UNORM.bits() => Some(Self(x)),
            x if x == Self::B8G8R8G8422_UNORM.bits() => Some(Self(x)),
            x if x == Self::G8_B8_R83PLANE_420_UNORM.bits() => Some(Self(x)),
            x if x == Self::G8_B8R82PLANE_420_UNORM.bits() => Some(Self(x)),
            x if x == Self::G8_B8_R83PLANE_422_UNORM.bits() => Some(Self(x)),
            x if x == Self::G8_B8R82PLANE_422_UNORM.bits() => Some(Self(x)),
            x if x == Self::G8_B8_R83PLANE_444_UNORM.bits() => Some(Self(x)),
            x if x == Self::R10X6_UNORM_PACK16.bits() => Some(Self(x)),
            x if x == Self::R10X6G10X6_UNORM2PACK16.bits() => Some(Self(x)),
            x if x == Self::R10X6G10X6B10X6A10X6_UNORM4PACK16.bits() => Some(Self(x)),
            x if x == Self::G10X6B10X6G10X6R10X6422_UNORM_4PACK16.bits() => Some(Self(x)),
            x if x == Self::B10X6G10X6R10X6G10X6422_UNORM_4PACK16.bits() => Some(Self(x)),
            x if x == Self::G10X6_B10X6_R10X63PLANE_420_UNORM_3PACK16.bits() => Some(Self(x)),
            x if x == Self::G10X6_B10X6R10X62PLANE_420_UNORM_3PACK16.bits() => Some(Self(x)),
            x if x == Self::G10X6_B10X6_R10X63PLANE_422_UNORM_3PACK16.bits() => Some(Self(x)),
            x if x == Self::G10X6_B10X6R10X62PLANE_422_UNORM_3PACK16.bits() => Some(Self(x)),
            x if x == Self::G10X6_B10X6_R10X63PLANE_444_UNORM_3PACK16.bits() => Some(Self(x)),
            x if x == Self::R12X4_UNORM_PACK16.bits() => Some(Self(x)),
            x if x == Self::R12X4G12X4_UNORM2PACK16.bits() => Some(Self(x)),
            x if x == Self::R12X4G12X4B12X4A12X4_UNORM4PACK16.bits() => Some(Self(x)),
            x if x == Self::G12X4B12X4G12X4R12X4422_UNORM_4PACK16.bits() => Some(Self(x)),
            x if x == Self::B12X4G12X4R12X4G12X4422_UNORM_4PACK16.bits() => Some(Self(x)),
            x if x == Self::G12X4_B12X4_R12X43PLANE_420_UNORM_3PACK16.bits() => Some(Self(x)),
            x if x == Self::G12X4_B12X4R12X42PLANE_420_UNORM_3PACK16.bits() => Some(Self(x)),
            x if x == Self::G12X4_B12X4_R12X43PLANE_422_UNORM_3PACK16.bits() => Some(Self(x)),
            x if x == Self::G12X4_B12X4R12X42PLANE_422_UNORM_3PACK16.bits() => Some(Self(x)),
            x if x == Self::G12X4_B12X4_R12X43PLANE_444_UNORM_3PACK16.bits() => Some(Self(x)),
            x if x == Self::G16B16G16R16422_UNORM.bits() => Some(Self(x)),
            x if x == Self::B16G16R16G16422_UNORM.bits() => Some(Self(x)),
            x if x == Self::G16_B16_R163PLANE_420_UNORM.bits() => Some(Self(x)),
            x if x == Self::G16_B16R162PLANE_420_UNORM.bits() => Some(Self(x)),
            x if x == Self::G16_B16_R163PLANE_422_UNORM.bits() => Some(Self(x)),
            x if x == Self::G16_B16R162PLANE_422_UNORM.bits() => Some(Self(x)),
            x if x == Self::G16_B16_R163PLANE_444_UNORM.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::G8_B8R82PLANE_444_UNORM.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::G10X6_B10X6R10X62PLANE_444_UNORM_3PACK16.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::G12X4_B12X4R12X42PLANE_444_UNORM_3PACK16.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::G16_B16R162PLANE_444_UNORM.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::A4R4G4B4_UNORM_PACK16.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::A4B4G4R4_UNORM_PACK16.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::ASTC4X4_SFLOAT_BLOCK.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::ASTC5X4_SFLOAT_BLOCK.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::ASTC5X5_SFLOAT_BLOCK.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::ASTC6X5_SFLOAT_BLOCK.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::ASTC6X6_SFLOAT_BLOCK.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::ASTC8X5_SFLOAT_BLOCK.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::ASTC8X6_SFLOAT_BLOCK.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::ASTC8X8_SFLOAT_BLOCK.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::ASTC10X5_SFLOAT_BLOCK.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::ASTC10X6_SFLOAT_BLOCK.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::ASTC10X8_SFLOAT_BLOCK.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::ASTC10X10_SFLOAT_BLOCK.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::ASTC12X10_SFLOAT_BLOCK.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::ASTC12X12_SFLOAT_BLOCK.bits() => Some(Self(x)),
            #[cfg(feature = "VK_IMG_format_pvrtc")]
            x if x == Self::PVRTC12BPP_UNORM_BLOCK_IMG.bits() => Some(Self(x)),
            #[cfg(feature = "VK_IMG_format_pvrtc")]
            x if x == Self::PVRTC14BPP_UNORM_BLOCK_IMG.bits() => Some(Self(x)),
            #[cfg(feature = "VK_IMG_format_pvrtc")]
            x if x == Self::PVRTC22BPP_UNORM_BLOCK_IMG.bits() => Some(Self(x)),
            #[cfg(feature = "VK_IMG_format_pvrtc")]
            x if x == Self::PVRTC24BPP_UNORM_BLOCK_IMG.bits() => Some(Self(x)),
            #[cfg(feature = "VK_IMG_format_pvrtc")]
            x if x == Self::PVRTC12BPP_SRGB_BLOCK_IMG.bits() => Some(Self(x)),
            #[cfg(feature = "VK_IMG_format_pvrtc")]
            x if x == Self::PVRTC14BPP_SRGB_BLOCK_IMG.bits() => Some(Self(x)),
            #[cfg(feature = "VK_IMG_format_pvrtc")]
            x if x == Self::PVRTC22BPP_SRGB_BLOCK_IMG.bits() => Some(Self(x)),
            #[cfg(feature = "VK_IMG_format_pvrtc")]
            x if x == Self::PVRTC24BPP_SRGB_BLOCK_IMG.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_extension_289")]
            x if x == Self::ASTC3X3X3_UNORM_BLOCK_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_extension_289")]
            x if x == Self::ASTC3X3X3_SRGB_BLOCK_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_extension_289")]
            x if x == Self::ASTC3X3X3_SFLOAT_BLOCK_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_extension_289")]
            x if x == Self::ASTC4X3X3_UNORM_BLOCK_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_extension_289")]
            x if x == Self::ASTC4X3X3_SRGB_BLOCK_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_extension_289")]
            x if x == Self::ASTC4X3X3_SFLOAT_BLOCK_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_extension_289")]
            x if x == Self::ASTC4X4X3_UNORM_BLOCK_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_extension_289")]
            x if x == Self::ASTC4X4X3_SRGB_BLOCK_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_extension_289")]
            x if x == Self::ASTC4X4X3_SFLOAT_BLOCK_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_extension_289")]
            x if x == Self::ASTC4X4X4_UNORM_BLOCK_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_extension_289")]
            x if x == Self::ASTC4X4X4_SRGB_BLOCK_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_extension_289")]
            x if x == Self::ASTC4X4X4_SFLOAT_BLOCK_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_extension_289")]
            x if x == Self::ASTC5X4X4_UNORM_BLOCK_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_extension_289")]
            x if x == Self::ASTC5X4X4_SRGB_BLOCK_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_extension_289")]
            x if x == Self::ASTC5X4X4_SFLOAT_BLOCK_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_extension_289")]
            x if x == Self::ASTC5X5X4_UNORM_BLOCK_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_extension_289")]
            x if x == Self::ASTC5X5X4_SRGB_BLOCK_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_extension_289")]
            x if x == Self::ASTC5X5X4_SFLOAT_BLOCK_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_extension_289")]
            x if x == Self::ASTC5X5X5_UNORM_BLOCK_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_extension_289")]
            x if x == Self::ASTC5X5X5_SRGB_BLOCK_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_extension_289")]
            x if x == Self::ASTC5X5X5_SFLOAT_BLOCK_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_extension_289")]
            x if x == Self::ASTC6X5X5_UNORM_BLOCK_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_extension_289")]
            x if x == Self::ASTC6X5X5_SRGB_BLOCK_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_extension_289")]
            x if x == Self::ASTC6X5X5_SFLOAT_BLOCK_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_extension_289")]
            x if x == Self::ASTC6X6X5_UNORM_BLOCK_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_extension_289")]
            x if x == Self::ASTC6X6X5_SRGB_BLOCK_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_extension_289")]
            x if x == Self::ASTC6X6X5_SFLOAT_BLOCK_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_extension_289")]
            x if x == Self::ASTC6X6X6_UNORM_BLOCK_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_extension_289")]
            x if x == Self::ASTC6X6X6_SRGB_BLOCK_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_extension_289")]
            x if x == Self::ASTC6X6X6_SFLOAT_BLOCK_EXT.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: i32) -> Self {
        Self(bits)
    }
}
# [doc = include_str ! ("../../../doc/VkStructureType.md")]
#[doc(alias = "VkStructureType")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct StructureType(i32);
impl StructureType {
    #[doc(alias = "VK_STRUCTURE_TYPE_APPLICATION_INFO")]
    pub const APPLICATION_INFO: Self = Self(0);
    #[doc(alias = "VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO")]
    pub const INSTANCE_CREATE_INFO: Self = Self(1);
    #[doc(alias = "VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO")]
    pub const DEVICE_QUEUE_CREATE_INFO: Self = Self(2);
    #[doc(alias = "VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO")]
    pub const DEVICE_CREATE_INFO: Self = Self(3);
    #[doc(alias = "VK_STRUCTURE_TYPE_SUBMIT_INFO")]
    pub const SUBMIT_INFO: Self = Self(4);
    #[doc(alias = "VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO")]
    pub const MEMORY_ALLOCATE_INFO: Self = Self(5);
    #[doc(alias = "VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE")]
    pub const MAPPED_MEMORY_RANGE: Self = Self(6);
    #[doc(alias = "VK_STRUCTURE_TYPE_BIND_SPARSE_INFO")]
    pub const BIND_SPARSE_INFO: Self = Self(7);
    #[doc(alias = "VK_STRUCTURE_TYPE_FENCE_CREATE_INFO")]
    pub const FENCE_CREATE_INFO: Self = Self(8);
    #[doc(alias = "VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO")]
    pub const SEMAPHORE_CREATE_INFO: Self = Self(9);
    #[doc(alias = "VK_STRUCTURE_TYPE_EVENT_CREATE_INFO")]
    pub const EVENT_CREATE_INFO: Self = Self(10);
    #[doc(alias = "VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO")]
    pub const QUERY_POOL_CREATE_INFO: Self = Self(11);
    #[doc(alias = "VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO")]
    pub const BUFFER_CREATE_INFO: Self = Self(12);
    #[doc(alias = "VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO")]
    pub const BUFFER_VIEW_CREATE_INFO: Self = Self(13);
    #[doc(alias = "VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO")]
    pub const IMAGE_CREATE_INFO: Self = Self(14);
    #[doc(alias = "VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO")]
    pub const IMAGE_VIEW_CREATE_INFO: Self = Self(15);
    #[doc(alias = "VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO")]
    pub const SHADER_MODULE_CREATE_INFO: Self = Self(16);
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO")]
    pub const PIPELINE_CACHE_CREATE_INFO: Self = Self(17);
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO")]
    pub const PIPELINE_SHADER_STAGE_CREATE_INFO: Self = Self(18);
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO")]
    pub const PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO: Self = Self(19);
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO")]
    pub const PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO: Self = Self(20);
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO")]
    pub const PIPELINE_TESSELLATION_STATE_CREATE_INFO: Self = Self(21);
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO")]
    pub const PIPELINE_VIEWPORT_STATE_CREATE_INFO: Self = Self(22);
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO")]
    pub const PIPELINE_RASTERIZATION_STATE_CREATE_INFO: Self = Self(23);
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO")]
    pub const PIPELINE_MULTISAMPLE_STATE_CREATE_INFO: Self = Self(24);
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO")]
    pub const PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO: Self = Self(25);
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO")]
    pub const PIPELINE_COLOR_BLEND_STATE_CREATE_INFO: Self = Self(26);
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO")]
    pub const PIPELINE_DYNAMIC_STATE_CREATE_INFO: Self = Self(27);
    #[doc(alias = "VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO")]
    pub const GRAPHICS_PIPELINE_CREATE_INFO: Self = Self(28);
    #[doc(alias = "VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO")]
    pub const COMPUTE_PIPELINE_CREATE_INFO: Self = Self(29);
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO")]
    pub const PIPELINE_LAYOUT_CREATE_INFO: Self = Self(30);
    #[doc(alias = "VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO")]
    pub const SAMPLER_CREATE_INFO: Self = Self(31);
    #[doc(alias = "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO")]
    pub const DESCRIPTOR_SET_LAYOUT_CREATE_INFO: Self = Self(32);
    #[doc(alias = "VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO")]
    pub const DESCRIPTOR_POOL_CREATE_INFO: Self = Self(33);
    #[doc(alias = "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO")]
    pub const DESCRIPTOR_SET_ALLOCATE_INFO: Self = Self(34);
    #[doc(alias = "VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET")]
    pub const WRITE_DESCRIPTOR_SET: Self = Self(35);
    #[doc(alias = "VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET")]
    pub const COPY_DESCRIPTOR_SET: Self = Self(36);
    #[doc(alias = "VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO")]
    pub const FRAMEBUFFER_CREATE_INFO: Self = Self(37);
    #[doc(alias = "VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO")]
    pub const RENDER_PASS_CREATE_INFO: Self = Self(38);
    #[doc(alias = "VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO")]
    pub const COMMAND_POOL_CREATE_INFO: Self = Self(39);
    #[doc(alias = "VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO")]
    pub const COMMAND_BUFFER_ALLOCATE_INFO: Self = Self(40);
    #[doc(alias = "VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO")]
    pub const COMMAND_BUFFER_INHERITANCE_INFO: Self = Self(41);
    #[doc(alias = "VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO")]
    pub const COMMAND_BUFFER_BEGIN_INFO: Self = Self(42);
    #[doc(alias = "VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO")]
    pub const RENDER_PASS_BEGIN_INFO: Self = Self(43);
    #[doc(alias = "VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER")]
    pub const BUFFER_MEMORY_BARRIER: Self = Self(44);
    #[doc(alias = "VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER")]
    pub const IMAGE_MEMORY_BARRIER: Self = Self(45);
    #[doc(alias = "VK_STRUCTURE_TYPE_MEMORY_BARRIER")]
    pub const MEMORY_BARRIER: Self = Self(46);
    #[doc(alias = "VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO")]
    pub const LOADER_INSTANCE_CREATE_INFO: Self = Self(47);
    #[doc(alias = "VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO")]
    pub const LOADER_DEVICE_CREATE_INFO: Self = Self(48);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES")]
    pub const PHYSICAL_DEVICE_SUBGROUP_PROPERTIES: Self = Self(1000094000);
    #[doc(alias = "VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO")]
    pub const BIND_BUFFER_MEMORY_INFO: Self = Self(1000157000);
    #[doc(alias = "VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO")]
    pub const BIND_IMAGE_MEMORY_INFO: Self = Self(1000157001);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES")]
    pub const PHYSICAL_DEVICE16BIT_STORAGE_FEATURES: Self = Self(1000083000);
    #[doc(alias = "VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS")]
    pub const MEMORY_DEDICATED_REQUIREMENTS: Self = Self(1000127000);
    #[doc(alias = "VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO")]
    pub const MEMORY_DEDICATED_ALLOCATE_INFO: Self = Self(1000127001);
    #[doc(alias = "VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO")]
    pub const MEMORY_ALLOCATE_FLAGS_INFO: Self = Self(1000060000);
    #[doc(alias = "VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO")]
    pub const DEVICE_GROUP_RENDER_PASS_BEGIN_INFO: Self = Self(1000060003);
    #[doc(alias = "VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO")]
    pub const DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO: Self = Self(1000060004);
    #[doc(alias = "VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO")]
    pub const DEVICE_GROUP_SUBMIT_INFO: Self = Self(1000060005);
    #[doc(alias = "VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO")]
    pub const DEVICE_GROUP_BIND_SPARSE_INFO: Self = Self(1000060006);
    #[doc(alias = "VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO")]
    pub const BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO: Self = Self(1000060013);
    #[doc(alias = "VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO")]
    pub const BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO: Self = Self(1000060014);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES")]
    pub const PHYSICAL_DEVICE_GROUP_PROPERTIES: Self = Self(1000070000);
    #[doc(alias = "VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO")]
    pub const DEVICE_GROUP_DEVICE_CREATE_INFO: Self = Self(1000070001);
    #[doc(alias = "VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2")]
    pub const BUFFER_MEMORY_REQUIREMENTS_INFO2: Self = Self(1000146000);
    #[doc(alias = "VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2")]
    pub const IMAGE_MEMORY_REQUIREMENTS_INFO2: Self = Self(1000146001);
    #[doc(alias = "VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2")]
    pub const IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO2: Self = Self(1000146002);
    #[doc(alias = "VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2")]
    pub const MEMORY_REQUIREMENTS2: Self = Self(1000146003);
    #[doc(alias = "VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2")]
    pub const SPARSE_IMAGE_MEMORY_REQUIREMENTS2: Self = Self(1000146004);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2")]
    pub const PHYSICAL_DEVICE_FEATURES2: Self = Self(1000059000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2")]
    pub const PHYSICAL_DEVICE_PROPERTIES2: Self = Self(1000059001);
    #[doc(alias = "VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2")]
    pub const FORMAT_PROPERTIES2: Self = Self(1000059002);
    #[doc(alias = "VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2")]
    pub const IMAGE_FORMAT_PROPERTIES2: Self = Self(1000059003);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2")]
    pub const PHYSICAL_DEVICE_IMAGE_FORMAT_INFO2: Self = Self(1000059004);
    #[doc(alias = "VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2")]
    pub const QUEUE_FAMILY_PROPERTIES2: Self = Self(1000059005);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2")]
    pub const PHYSICAL_DEVICE_MEMORY_PROPERTIES2: Self = Self(1000059006);
    #[doc(alias = "VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2")]
    pub const SPARSE_IMAGE_FORMAT_PROPERTIES2: Self = Self(1000059007);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2")]
    pub const PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO2: Self = Self(1000059008);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES")]
    pub const PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES: Self = Self(1000117000);
    #[doc(alias = "VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO")]
    pub const RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO: Self = Self(1000117001);
    #[doc(alias = "VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO")]
    pub const IMAGE_VIEW_USAGE_CREATE_INFO: Self = Self(1000117002);
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO")]
    pub const PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO: Self = Self(1000117003);
    #[doc(alias = "VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO")]
    pub const RENDER_PASS_MULTIVIEW_CREATE_INFO: Self = Self(1000053000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES")]
    pub const PHYSICAL_DEVICE_MULTIVIEW_FEATURES: Self = Self(1000053001);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES")]
    pub const PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES: Self = Self(1000053002);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES")]
    pub const PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES: Self = Self(1000120000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO")]
    pub const PROTECTED_SUBMIT_INFO: Self = Self(1000145000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES")]
    pub const PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES: Self = Self(1000145001);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES")]
    pub const PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES: Self = Self(1000145002);
    #[doc(alias = "VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2")]
    pub const DEVICE_QUEUE_INFO2: Self = Self(1000145003);
    #[doc(alias = "VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO")]
    pub const SAMPLER_YCBCR_CONVERSION_CREATE_INFO: Self = Self(1000156000);
    #[doc(alias = "VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO")]
    pub const SAMPLER_YCBCR_CONVERSION_INFO: Self = Self(1000156001);
    #[doc(alias = "VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO")]
    pub const BIND_IMAGE_PLANE_MEMORY_INFO: Self = Self(1000156002);
    #[doc(alias = "VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO")]
    pub const IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO: Self = Self(1000156003);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES")]
    pub const PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES: Self = Self(1000156004);
    #[doc(alias = "VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES")]
    pub const SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES: Self = Self(1000156005);
    #[doc(alias = "VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO")]
    pub const DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO: Self = Self(1000085000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO")]
    pub const PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO: Self = Self(1000071000);
    #[doc(alias = "VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES")]
    pub const EXTERNAL_IMAGE_FORMAT_PROPERTIES: Self = Self(1000071001);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO")]
    pub const PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO: Self = Self(1000071002);
    #[doc(alias = "VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES")]
    pub const EXTERNAL_BUFFER_PROPERTIES: Self = Self(1000071003);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES")]
    pub const PHYSICAL_DEVICE_ID_PROPERTIES: Self = Self(1000071004);
    #[doc(alias = "VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO")]
    pub const EXTERNAL_MEMORY_BUFFER_CREATE_INFO: Self = Self(1000072000);
    #[doc(alias = "VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO")]
    pub const EXTERNAL_MEMORY_IMAGE_CREATE_INFO: Self = Self(1000072001);
    #[doc(alias = "VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO")]
    pub const EXPORT_MEMORY_ALLOCATE_INFO: Self = Self(1000072002);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO")]
    pub const PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO: Self = Self(1000112000);
    #[doc(alias = "VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES")]
    pub const EXTERNAL_FENCE_PROPERTIES: Self = Self(1000112001);
    #[doc(alias = "VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO")]
    pub const EXPORT_FENCE_CREATE_INFO: Self = Self(1000113000);
    #[doc(alias = "VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO")]
    pub const EXPORT_SEMAPHORE_CREATE_INFO: Self = Self(1000077000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO")]
    pub const PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO: Self = Self(1000076000);
    #[doc(alias = "VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES")]
    pub const EXTERNAL_SEMAPHORE_PROPERTIES: Self = Self(1000076001);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES")]
    pub const PHYSICAL_DEVICE_MAINTENANCE3_PROPERTIES: Self = Self(1000168000);
    #[doc(alias = "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT")]
    pub const DESCRIPTOR_SET_LAYOUT_SUPPORT: Self = Self(1000168001);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES")]
    pub const PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES: Self = Self(1000063000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES")]
    #[cfg(feature = "VULKAN_1_2")]
    pub const PHYSICAL_DEVICE_VULKAN1_1_FEATURES: Self = Self(49);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES")]
    #[cfg(feature = "VULKAN_1_2")]
    pub const PHYSICAL_DEVICE_VULKAN1_1_PROPERTIES: Self = Self(50);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES")]
    #[cfg(feature = "VULKAN_1_2")]
    pub const PHYSICAL_DEVICE_VULKAN1_2_FEATURES: Self = Self(51);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES")]
    #[cfg(feature = "VULKAN_1_2")]
    pub const PHYSICAL_DEVICE_VULKAN1_2_PROPERTIES: Self = Self(52);
    #[doc(alias = "VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO")]
    #[cfg(feature = "VULKAN_1_2")]
    pub const IMAGE_FORMAT_LIST_CREATE_INFO: Self = Self(1000147000);
    #[doc(alias = "VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2")]
    #[cfg(feature = "VULKAN_1_2")]
    pub const ATTACHMENT_DESCRIPTION2: Self = Self(1000109000);
    #[doc(alias = "VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2")]
    #[cfg(feature = "VULKAN_1_2")]
    pub const ATTACHMENT_REFERENCE2: Self = Self(1000109001);
    #[doc(alias = "VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2")]
    #[cfg(feature = "VULKAN_1_2")]
    pub const SUBPASS_DESCRIPTION2: Self = Self(1000109002);
    #[doc(alias = "VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2")]
    #[cfg(feature = "VULKAN_1_2")]
    pub const SUBPASS_DEPENDENCY2: Self = Self(1000109003);
    #[doc(alias = "VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2")]
    #[cfg(feature = "VULKAN_1_2")]
    pub const RENDER_PASS_CREATE_INFO2: Self = Self(1000109004);
    #[doc(alias = "VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO")]
    #[cfg(feature = "VULKAN_1_2")]
    pub const SUBPASS_BEGIN_INFO: Self = Self(1000109005);
    #[doc(alias = "VK_STRUCTURE_TYPE_SUBPASS_END_INFO")]
    #[cfg(feature = "VULKAN_1_2")]
    pub const SUBPASS_END_INFO: Self = Self(1000109006);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES")]
    #[cfg(feature = "VULKAN_1_2")]
    pub const PHYSICAL_DEVICE8BIT_STORAGE_FEATURES: Self = Self(1000177000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES")]
    #[cfg(feature = "VULKAN_1_2")]
    pub const PHYSICAL_DEVICE_DRIVER_PROPERTIES: Self = Self(1000196000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES")]
    #[cfg(feature = "VULKAN_1_2")]
    pub const PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES: Self = Self(1000180000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES")]
    #[cfg(feature = "VULKAN_1_2")]
    pub const PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES: Self = Self(1000082000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES")]
    #[cfg(feature = "VULKAN_1_2")]
    pub const PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES: Self = Self(1000197000);
    #[doc(alias = "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO")]
    #[cfg(feature = "VULKAN_1_2")]
    pub const DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO: Self = Self(1000161000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES")]
    #[cfg(feature = "VULKAN_1_2")]
    pub const PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES: Self = Self(1000161001);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES")]
    #[cfg(feature = "VULKAN_1_2")]
    pub const PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES: Self = Self(1000161002);
    #[doc(alias = "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO")]
    #[cfg(feature = "VULKAN_1_2")]
    pub const DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO: Self = Self(1000161003);
    #[doc(alias = "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT")]
    #[cfg(feature = "VULKAN_1_2")]
    pub const DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT: Self = Self(1000161004);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES")]
    #[cfg(feature = "VULKAN_1_2")]
    pub const PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES: Self = Self(1000199000);
    #[doc(alias = "VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE")]
    #[cfg(feature = "VULKAN_1_2")]
    pub const SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE: Self = Self(1000199001);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES")]
    #[cfg(feature = "VULKAN_1_2")]
    pub const PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES: Self = Self(1000221000);
    #[doc(alias = "VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO")]
    #[cfg(feature = "VULKAN_1_2")]
    pub const IMAGE_STENCIL_USAGE_CREATE_INFO: Self = Self(1000246000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES")]
    #[cfg(feature = "VULKAN_1_2")]
    pub const PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES: Self = Self(1000130000);
    #[doc(alias = "VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO")]
    #[cfg(feature = "VULKAN_1_2")]
    pub const SAMPLER_REDUCTION_MODE_CREATE_INFO: Self = Self(1000130001);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES")]
    #[cfg(feature = "VULKAN_1_2")]
    pub const PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES: Self = Self(1000211000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES")]
    #[cfg(feature = "VULKAN_1_2")]
    pub const PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES: Self = Self(1000108000);
    #[doc(alias = "VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO")]
    #[cfg(feature = "VULKAN_1_2")]
    pub const FRAMEBUFFER_ATTACHMENTS_CREATE_INFO: Self = Self(1000108001);
    #[doc(alias = "VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO")]
    #[cfg(feature = "VULKAN_1_2")]
    pub const FRAMEBUFFER_ATTACHMENT_IMAGE_INFO: Self = Self(1000108002);
    #[doc(alias = "VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO")]
    #[cfg(feature = "VULKAN_1_2")]
    pub const RENDER_PASS_ATTACHMENT_BEGIN_INFO: Self = Self(1000108003);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES")]
    #[cfg(feature = "VULKAN_1_2")]
    pub const PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES: Self = Self(1000253000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES")]
    #[cfg(feature = "VULKAN_1_2")]
    pub const PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES: Self = Self(1000175000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES")]
    #[cfg(feature = "VULKAN_1_2")]
    pub const PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES: Self = Self(1000241000);
    #[doc(alias = "VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT")]
    #[cfg(feature = "VULKAN_1_2")]
    pub const ATTACHMENT_REFERENCE_STENCIL_LAYOUT: Self = Self(1000241001);
    #[doc(alias = "VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT")]
    #[cfg(feature = "VULKAN_1_2")]
    pub const ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT: Self = Self(1000241002);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES")]
    #[cfg(feature = "VULKAN_1_2")]
    pub const PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES: Self = Self(1000261000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES")]
    #[cfg(feature = "VULKAN_1_2")]
    pub const PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES: Self = Self(1000207000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES")]
    #[cfg(feature = "VULKAN_1_2")]
    pub const PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES: Self = Self(1000207001);
    #[doc(alias = "VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO")]
    #[cfg(feature = "VULKAN_1_2")]
    pub const SEMAPHORE_TYPE_CREATE_INFO: Self = Self(1000207002);
    #[doc(alias = "VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO")]
    #[cfg(feature = "VULKAN_1_2")]
    pub const TIMELINE_SEMAPHORE_SUBMIT_INFO: Self = Self(1000207003);
    #[doc(alias = "VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO")]
    #[cfg(feature = "VULKAN_1_2")]
    pub const SEMAPHORE_WAIT_INFO: Self = Self(1000207004);
    #[doc(alias = "VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO")]
    #[cfg(feature = "VULKAN_1_2")]
    pub const SEMAPHORE_SIGNAL_INFO: Self = Self(1000207005);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES")]
    #[cfg(feature = "VULKAN_1_2")]
    pub const PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES: Self = Self(1000257000);
    #[doc(alias = "VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO")]
    #[cfg(feature = "VULKAN_1_2")]
    pub const BUFFER_DEVICE_ADDRESS_INFO: Self = Self(1000244001);
    #[doc(alias = "VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO")]
    #[cfg(feature = "VULKAN_1_2")]
    pub const BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO: Self = Self(1000257002);
    #[doc(alias = "VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO")]
    #[cfg(feature = "VULKAN_1_2")]
    pub const MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO: Self = Self(1000257003);
    #[doc(alias = "VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO")]
    #[cfg(feature = "VULKAN_1_2")]
    pub const DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO: Self = Self(1000257004);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const PHYSICAL_DEVICE_VULKAN1_3_FEATURES: Self = Self(53);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const PHYSICAL_DEVICE_VULKAN1_3_PROPERTIES: Self = Self(54);
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const PIPELINE_CREATION_FEEDBACK_CREATE_INFO: Self = Self(1000192000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES: Self = Self(1000215000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const PHYSICAL_DEVICE_TOOL_PROPERTIES: Self = Self(1000245000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES: Self = Self(1000276000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES: Self = Self(1000295000);
    #[doc(alias = "VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const DEVICE_PRIVATE_DATA_CREATE_INFO: Self = Self(1000295001);
    #[doc(alias = "VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const PRIVATE_DATA_SLOT_CREATE_INFO: Self = Self(1000295002);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES: Self = Self(1000297000);
    #[doc(alias = "VK_STRUCTURE_TYPE_MEMORY_BARRIER_2")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const MEMORY_BARRIER2: Self = Self(1000314000);
    #[doc(alias = "VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const BUFFER_MEMORY_BARRIER2: Self = Self(1000314001);
    #[doc(alias = "VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const IMAGE_MEMORY_BARRIER2: Self = Self(1000314002);
    #[doc(alias = "VK_STRUCTURE_TYPE_DEPENDENCY_INFO")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const DEPENDENCY_INFO: Self = Self(1000314003);
    #[doc(alias = "VK_STRUCTURE_TYPE_SUBMIT_INFO_2")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const SUBMIT_INFO2: Self = Self(1000314004);
    #[doc(alias = "VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const SEMAPHORE_SUBMIT_INFO: Self = Self(1000314005);
    #[doc(alias = "VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const COMMAND_BUFFER_SUBMIT_INFO: Self = Self(1000314006);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const PHYSICAL_DEVICE_SYNCHRONIZATION2_FEATURES: Self = Self(1000314007);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES: Self = Self(1000325000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES: Self = Self(1000335000);
    #[doc(alias = "VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const COPY_BUFFER_INFO2: Self = Self(1000337000);
    #[doc(alias = "VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const COPY_IMAGE_INFO2: Self = Self(1000337001);
    #[doc(alias = "VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const COPY_BUFFER_TO_IMAGE_INFO2: Self = Self(1000337002);
    #[doc(alias = "VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const COPY_IMAGE_TO_BUFFER_INFO2: Self = Self(1000337003);
    #[doc(alias = "VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const BLIT_IMAGE_INFO2: Self = Self(1000337004);
    #[doc(alias = "VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const RESOLVE_IMAGE_INFO2: Self = Self(1000337005);
    #[doc(alias = "VK_STRUCTURE_TYPE_BUFFER_COPY_2")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const BUFFER_COPY2: Self = Self(1000337006);
    #[doc(alias = "VK_STRUCTURE_TYPE_IMAGE_COPY_2")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const IMAGE_COPY2: Self = Self(1000337007);
    #[doc(alias = "VK_STRUCTURE_TYPE_IMAGE_BLIT_2")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const IMAGE_BLIT2: Self = Self(1000337008);
    #[doc(alias = "VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const BUFFER_IMAGE_COPY2: Self = Self(1000337009);
    #[doc(alias = "VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const IMAGE_RESOLVE2: Self = Self(1000337010);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES: Self = Self(1000225000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO: Self = Self(1000225001);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES: Self = Self(1000225002);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES: Self = Self(1000138000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES: Self = Self(1000138001);
    #[doc(alias = "VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK: Self = Self(1000138002);
    #[doc(alias = "VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO: Self = Self(1000138003);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES: Self = Self(1000066000);
    #[doc(alias = "VK_STRUCTURE_TYPE_RENDERING_INFO")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const RENDERING_INFO: Self = Self(1000044000);
    #[doc(alias = "VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const RENDERING_ATTACHMENT_INFO: Self = Self(1000044001);
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const PIPELINE_RENDERING_CREATE_INFO: Self = Self(1000044002);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES: Self = Self(1000044003);
    #[doc(alias = "VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const COMMAND_BUFFER_INHERITANCE_RENDERING_INFO: Self = Self(1000044004);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES: Self = Self(1000280000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES: Self = Self(1000280001);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES: Self = Self(1000281001);
    #[doc(alias = "VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const FORMAT_PROPERTIES3: Self = Self(1000360000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const PHYSICAL_DEVICE_MAINTENANCE4_FEATURES: Self = Self(1000413000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const PHYSICAL_DEVICE_MAINTENANCE4_PROPERTIES: Self = Self(1000413001);
    #[doc(alias = "VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const DEVICE_BUFFER_MEMORY_REQUIREMENTS: Self = Self(1000413002);
    #[doc(alias = "VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const DEVICE_IMAGE_MEMORY_REQUIREMENTS: Self = Self(1000413003);
    #[doc(alias = "VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR")]
    #[cfg(feature = "VK_KHR_swapchain")]
    pub const SWAPCHAIN_CREATE_INFO_KHR: Self = Self(1000001000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PRESENT_INFO_KHR")]
    #[cfg(feature = "VK_KHR_swapchain")]
    pub const PRESENT_INFO_KHR: Self = Self(1000001001);
    #[doc(alias = "VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR")]
    #[cfg(feature = "VK_KHR_device_group")]
    pub const DEVICE_GROUP_PRESENT_CAPABILITIES_KHR: Self = Self(1000060007);
    #[doc(alias = "VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR")]
    #[cfg(feature = "VK_KHR_device_group")]
    pub const IMAGE_SWAPCHAIN_CREATE_INFO_KHR: Self = Self(1000060008);
    #[doc(alias = "VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR")]
    #[cfg(feature = "VK_KHR_device_group")]
    pub const BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR: Self = Self(1000060009);
    #[doc(alias = "VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR")]
    #[cfg(feature = "VK_KHR_device_group")]
    pub const ACQUIRE_NEXT_IMAGE_INFO_KHR: Self = Self(1000060010);
    #[doc(alias = "VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR")]
    #[cfg(feature = "VK_KHR_device_group")]
    pub const DEVICE_GROUP_PRESENT_INFO_KHR: Self = Self(1000060011);
    #[doc(alias = "VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR")]
    #[cfg(feature = "VK_KHR_device_group")]
    pub const DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR: Self = Self(1000060012);
    #[doc(alias = "VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR")]
    #[cfg(feature = "VK_KHR_display")]
    pub const DISPLAY_MODE_CREATE_INFO_KHR: Self = Self(1000002000);
    #[doc(alias = "VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR")]
    #[cfg(feature = "VK_KHR_display")]
    pub const DISPLAY_SURFACE_CREATE_INFO_KHR: Self = Self(1000002001);
    #[doc(alias = "VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR")]
    #[cfg(feature = "VK_KHR_display_swapchain")]
    pub const DISPLAY_PRESENT_INFO_KHR: Self = Self(1000003000);
    #[doc(alias = "VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR")]
    #[cfg(feature = "VK_KHR_xlib_surface")]
    pub const XLIB_SURFACE_CREATE_INFO_KHR: Self = Self(1000004000);
    #[doc(alias = "VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR")]
    #[cfg(feature = "VK_KHR_xcb_surface")]
    pub const XCB_SURFACE_CREATE_INFO_KHR: Self = Self(1000005000);
    #[doc(alias = "VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR")]
    #[cfg(feature = "VK_KHR_wayland_surface")]
    pub const WAYLAND_SURFACE_CREATE_INFO_KHR: Self = Self(1000006000);
    #[doc(alias = "VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR")]
    #[cfg(feature = "VK_KHR_android_surface")]
    pub const ANDROID_SURFACE_CREATE_INFO_KHR: Self = Self(1000008000);
    #[doc(alias = "VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR")]
    #[cfg(feature = "VK_KHR_win32_surface")]
    pub const WIN32_SURFACE_CREATE_INFO_KHR: Self = Self(1000009000);
    #[doc(alias = "VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT")]
    #[cfg(feature = "VK_EXT_debug_report")]
    pub const DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT: Self = Self(1000011000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD")]
    #[cfg(feature = "VK_AMD_rasterization_order")]
    pub const PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD: Self = Self(1000018000);
    #[doc(alias = "VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT")]
    #[cfg(feature = "VK_EXT_debug_marker")]
    pub const DEBUG_MARKER_OBJECT_NAME_INFO_EXT: Self = Self(1000022000);
    #[doc(alias = "VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT")]
    #[cfg(feature = "VK_EXT_debug_marker")]
    pub const DEBUG_MARKER_OBJECT_TAG_INFO_EXT: Self = Self(1000022001);
    #[doc(alias = "VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT")]
    #[cfg(feature = "VK_EXT_debug_marker")]
    pub const DEBUG_MARKER_MARKER_INFO_EXT: Self = Self(1000022002);
    #[doc(alias = "VK_STRUCTURE_TYPE_VIDEO_PROFILE_KHR")]
    #[cfg(feature = "VK_KHR_video_queue")]
    pub const VIDEO_PROFILE_KHR: Self = Self(1000023000);
    #[doc(alias = "VK_STRUCTURE_TYPE_VIDEO_CAPABILITIES_KHR")]
    #[cfg(feature = "VK_KHR_video_queue")]
    pub const VIDEO_CAPABILITIES_KHR: Self = Self(1000023001);
    #[doc(alias = "VK_STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_KHR")]
    #[cfg(feature = "VK_KHR_video_queue")]
    pub const VIDEO_PICTURE_RESOURCE_KHR: Self = Self(1000023002);
    #[doc(alias = "VK_STRUCTURE_TYPE_VIDEO_GET_MEMORY_PROPERTIES_KHR")]
    #[cfg(feature = "VK_KHR_video_queue")]
    pub const VIDEO_GET_MEMORY_PROPERTIES_KHR: Self = Self(1000023003);
    #[doc(alias = "VK_STRUCTURE_TYPE_VIDEO_BIND_MEMORY_KHR")]
    #[cfg(feature = "VK_KHR_video_queue")]
    pub const VIDEO_BIND_MEMORY_KHR: Self = Self(1000023004);
    #[doc(alias = "VK_STRUCTURE_TYPE_VIDEO_SESSION_CREATE_INFO_KHR")]
    #[cfg(feature = "VK_KHR_video_queue")]
    pub const VIDEO_SESSION_CREATE_INFO_KHR: Self = Self(1000023005);
    #[doc(alias = "VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_CREATE_INFO_KHR")]
    #[cfg(feature = "VK_KHR_video_queue")]
    pub const VIDEO_SESSION_PARAMETERS_CREATE_INFO_KHR: Self = Self(1000023006);
    #[doc(alias = "VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_UPDATE_INFO_KHR")]
    #[cfg(feature = "VK_KHR_video_queue")]
    pub const VIDEO_SESSION_PARAMETERS_UPDATE_INFO_KHR: Self = Self(1000023007);
    #[doc(alias = "VK_STRUCTURE_TYPE_VIDEO_BEGIN_CODING_INFO_KHR")]
    #[cfg(feature = "VK_KHR_video_queue")]
    pub const VIDEO_BEGIN_CODING_INFO_KHR: Self = Self(1000023008);
    #[doc(alias = "VK_STRUCTURE_TYPE_VIDEO_END_CODING_INFO_KHR")]
    #[cfg(feature = "VK_KHR_video_queue")]
    pub const VIDEO_END_CODING_INFO_KHR: Self = Self(1000023009);
    #[doc(alias = "VK_STRUCTURE_TYPE_VIDEO_CODING_CONTROL_INFO_KHR")]
    #[cfg(feature = "VK_KHR_video_queue")]
    pub const VIDEO_CODING_CONTROL_INFO_KHR: Self = Self(1000023010);
    #[doc(alias = "VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_KHR")]
    #[cfg(feature = "VK_KHR_video_queue")]
    pub const VIDEO_REFERENCE_SLOT_KHR: Self = Self(1000023011);
    #[doc(alias = "VK_STRUCTURE_TYPE_VIDEO_QUEUE_FAMILY_PROPERTIES_2_KHR")]
    #[cfg(feature = "VK_KHR_video_queue")]
    pub const VIDEO_QUEUE_FAMILY_PROPERTIES2_KHR: Self = Self(1000023012);
    #[doc(alias = "VK_STRUCTURE_TYPE_VIDEO_PROFILES_KHR")]
    #[cfg(feature = "VK_KHR_video_queue")]
    pub const VIDEO_PROFILES_KHR: Self = Self(1000023013);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_FORMAT_INFO_KHR")]
    #[cfg(feature = "VK_KHR_video_queue")]
    pub const PHYSICAL_DEVICE_VIDEO_FORMAT_INFO_KHR: Self = Self(1000023014);
    #[doc(alias = "VK_STRUCTURE_TYPE_VIDEO_FORMAT_PROPERTIES_KHR")]
    #[cfg(feature = "VK_KHR_video_queue")]
    pub const VIDEO_FORMAT_PROPERTIES_KHR: Self = Self(1000023015);
    #[doc(alias = "VK_STRUCTURE_TYPE_QUEUE_FAMILY_QUERY_RESULT_STATUS_PROPERTIES_2_KHR")]
    #[cfg(feature = "VK_KHR_video_queue")]
    pub const QUEUE_FAMILY_QUERY_RESULT_STATUS_PROPERTIES2_KHR: Self = Self(1000023016);
    #[doc(alias = "VK_STRUCTURE_TYPE_VIDEO_DECODE_INFO_KHR")]
    #[cfg(feature = "VK_KHR_video_decode_queue")]
    pub const VIDEO_DECODE_INFO_KHR: Self = Self(1000024000);
    #[doc(alias = "VK_STRUCTURE_TYPE_VIDEO_DECODE_CAPABILITIES_KHR")]
    #[cfg(feature = "VK_KHR_video_decode_queue")]
    pub const VIDEO_DECODE_CAPABILITIES_KHR: Self = Self(1000024001);
    #[doc(alias = "VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV")]
    #[cfg(feature = "VK_NV_dedicated_allocation")]
    pub const DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV: Self = Self(1000026000);
    #[doc(alias = "VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV")]
    #[cfg(feature = "VK_NV_dedicated_allocation")]
    pub const DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV: Self = Self(1000026001);
    #[doc(alias = "VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV")]
    #[cfg(feature = "VK_NV_dedicated_allocation")]
    pub const DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV: Self = Self(1000026002);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT")]
    #[cfg(feature = "VK_EXT_transform_feedback")]
    pub const PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT: Self = Self(1000028000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT")]
    #[cfg(feature = "VK_EXT_transform_feedback")]
    pub const PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT: Self = Self(1000028001);
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT")]
    #[cfg(feature = "VK_EXT_transform_feedback")]
    pub const PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT: Self = Self(1000028002);
    #[doc(alias = "VK_STRUCTURE_TYPE_CU_MODULE_CREATE_INFO_NVX")]
    #[cfg(feature = "VK_NVX_binary_import")]
    pub const CU_MODULE_CREATE_INFO_NVX: Self = Self(1000029000);
    #[doc(alias = "VK_STRUCTURE_TYPE_CU_FUNCTION_CREATE_INFO_NVX")]
    #[cfg(feature = "VK_NVX_binary_import")]
    pub const CU_FUNCTION_CREATE_INFO_NVX: Self = Self(1000029001);
    #[doc(alias = "VK_STRUCTURE_TYPE_CU_LAUNCH_INFO_NVX")]
    #[cfg(feature = "VK_NVX_binary_import")]
    pub const CU_LAUNCH_INFO_NVX: Self = Self(1000029002);
    #[doc(alias = "VK_STRUCTURE_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX")]
    #[cfg(feature = "VK_NVX_image_view_handle")]
    pub const IMAGE_VIEW_HANDLE_INFO_NVX: Self = Self(1000030000);
    #[doc(alias = "VK_STRUCTURE_TYPE_IMAGE_VIEW_ADDRESS_PROPERTIES_NVX")]
    #[cfg(feature = "VK_NVX_image_view_handle")]
    pub const IMAGE_VIEW_ADDRESS_PROPERTIES_NVX: Self = Self(1000030001);
    #[doc(alias = "VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD")]
    #[cfg(feature = "VK_AMD_texture_gather_bias_lod")]
    pub const TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD: Self = Self(1000041000);
    #[doc(alias = "VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR")]
    #[cfg(feature = "VK_KHR_dynamic_rendering")]
    pub const RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR: Self = Self(1000044006);
    #[doc(alias = "VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT")]
    #[cfg(feature = "VK_KHR_dynamic_rendering")]
    pub const RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT: Self = Self(1000044007);
    #[doc(alias = "VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD")]
    #[cfg(feature = "VK_KHR_dynamic_rendering")]
    pub const ATTACHMENT_SAMPLE_COUNT_INFO_AMD: Self = Self(1000044008);
    #[doc(alias = "VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX")]
    #[cfg(feature = "VK_KHR_dynamic_rendering")]
    pub const MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX: Self = Self(1000044009);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV")]
    #[cfg(feature = "VK_NV_corner_sampled_image")]
    pub const PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV: Self = Self(1000050000);
    #[doc(alias = "VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV")]
    #[cfg(feature = "VK_NV_external_memory")]
    pub const EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV: Self = Self(1000056000);
    #[doc(alias = "VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV")]
    #[cfg(feature = "VK_NV_external_memory")]
    pub const EXPORT_MEMORY_ALLOCATE_INFO_NV: Self = Self(1000056001);
    #[doc(alias = "VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV")]
    #[cfg(feature = "VK_NV_external_memory_win32")]
    pub const IMPORT_MEMORY_WIN32_HANDLE_INFO_NV: Self = Self(1000057000);
    #[doc(alias = "VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV")]
    #[cfg(feature = "VK_NV_external_memory_win32")]
    pub const EXPORT_MEMORY_WIN32_HANDLE_INFO_NV: Self = Self(1000057001);
    #[doc(alias = "VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV")]
    #[cfg(feature = "VK_NV_win32_keyed_mutex")]
    pub const WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV: Self = Self(1000058000);
    #[doc(alias = "VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT")]
    #[cfg(feature = "VK_EXT_validation_flags")]
    pub const VALIDATION_FLAGS_EXT: Self = Self(1000061000);
    #[doc(alias = "VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN")]
    #[cfg(feature = "VK_NN_vi_surface")]
    pub const VI_SURFACE_CREATE_INFO_NN: Self = Self(1000062000);
    #[doc(alias = "VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT")]
    #[cfg(feature = "VK_EXT_astc_decode_mode")]
    pub const IMAGE_VIEW_ASTC_DECODE_MODE_EXT: Self = Self(1000067000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT")]
    #[cfg(feature = "VK_EXT_astc_decode_mode")]
    pub const PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT: Self = Self(1000067001);
    #[doc(alias = "VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR")]
    #[cfg(feature = "VK_KHR_external_memory_win32")]
    pub const IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR: Self = Self(1000073000);
    #[doc(alias = "VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR")]
    #[cfg(feature = "VK_KHR_external_memory_win32")]
    pub const EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR: Self = Self(1000073001);
    #[doc(alias = "VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR")]
    #[cfg(feature = "VK_KHR_external_memory_win32")]
    pub const MEMORY_WIN32_HANDLE_PROPERTIES_KHR: Self = Self(1000073002);
    #[doc(alias = "VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR")]
    #[cfg(feature = "VK_KHR_external_memory_win32")]
    pub const MEMORY_GET_WIN32_HANDLE_INFO_KHR: Self = Self(1000073003);
    #[doc(alias = "VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR")]
    #[cfg(feature = "VK_KHR_external_memory_fd")]
    pub const IMPORT_MEMORY_FD_INFO_KHR: Self = Self(1000074000);
    #[doc(alias = "VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR")]
    #[cfg(feature = "VK_KHR_external_memory_fd")]
    pub const MEMORY_FD_PROPERTIES_KHR: Self = Self(1000074001);
    #[doc(alias = "VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR")]
    #[cfg(feature = "VK_KHR_external_memory_fd")]
    pub const MEMORY_GET_FD_INFO_KHR: Self = Self(1000074002);
    #[doc(alias = "VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR")]
    #[cfg(feature = "VK_KHR_win32_keyed_mutex")]
    pub const WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR: Self = Self(1000075000);
    #[doc(alias = "VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR")]
    #[cfg(feature = "VK_KHR_external_semaphore_win32")]
    pub const IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR: Self = Self(1000078000);
    #[doc(alias = "VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR")]
    #[cfg(feature = "VK_KHR_external_semaphore_win32")]
    pub const EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR: Self = Self(1000078001);
    #[doc(alias = "VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR")]
    #[cfg(feature = "VK_KHR_external_semaphore_win32")]
    pub const D3D12_FENCE_SUBMIT_INFO_KHR: Self = Self(1000078002);
    #[doc(alias = "VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR")]
    #[cfg(feature = "VK_KHR_external_semaphore_win32")]
    pub const SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR: Self = Self(1000078003);
    #[doc(alias = "VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR")]
    #[cfg(feature = "VK_KHR_external_semaphore_fd")]
    pub const IMPORT_SEMAPHORE_FD_INFO_KHR: Self = Self(1000079000);
    #[doc(alias = "VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR")]
    #[cfg(feature = "VK_KHR_external_semaphore_fd")]
    pub const SEMAPHORE_GET_FD_INFO_KHR: Self = Self(1000079001);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR")]
    #[cfg(feature = "VK_KHR_push_descriptor")]
    pub const PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR: Self = Self(1000080000);
    #[doc(alias = "VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT")]
    #[cfg(feature = "VK_EXT_conditional_rendering")]
    pub const COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT: Self = Self(1000081000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT")]
    #[cfg(feature = "VK_EXT_conditional_rendering")]
    pub const PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT: Self = Self(1000081001);
    #[doc(alias = "VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT")]
    #[cfg(feature = "VK_EXT_conditional_rendering")]
    pub const CONDITIONAL_RENDERING_BEGIN_INFO_EXT: Self = Self(1000081002);
    #[doc(alias = "VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR")]
    #[cfg(feature = "VK_KHR_incremental_present")]
    pub const PRESENT_REGIONS_KHR: Self = Self(1000084000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV")]
    #[cfg(feature = "VK_NV_clip_space_w_scaling")]
    pub const PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV: Self = Self(1000087000);
    #[doc(alias = "VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT")]
    #[cfg(feature = "VK_EXT_display_surface_counter")]
    pub const SURFACE_CAPABILITIES2_EXT: Self = Self(1000090000);
    #[doc(alias = "VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT")]
    #[cfg(feature = "VK_EXT_display_control")]
    pub const DISPLAY_POWER_INFO_EXT: Self = Self(1000091000);
    #[doc(alias = "VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT")]
    #[cfg(feature = "VK_EXT_display_control")]
    pub const DEVICE_EVENT_INFO_EXT: Self = Self(1000091001);
    #[doc(alias = "VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT")]
    #[cfg(feature = "VK_EXT_display_control")]
    pub const DISPLAY_EVENT_INFO_EXT: Self = Self(1000091002);
    #[doc(alias = "VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT")]
    #[cfg(feature = "VK_EXT_display_control")]
    pub const SWAPCHAIN_COUNTER_CREATE_INFO_EXT: Self = Self(1000091003);
    #[doc(alias = "VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE")]
    #[cfg(feature = "VK_GOOGLE_display_timing")]
    pub const PRESENT_TIMES_INFO_GOOGLE: Self = Self(1000092000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX")]
    #[cfg(feature = "VK_NVX_multiview_per_view_attributes")]
    pub const PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX: Self = Self(1000097000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV")]
    #[cfg(feature = "VK_NV_viewport_swizzle")]
    pub const PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV: Self = Self(1000098000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT")]
    #[cfg(feature = "VK_EXT_discard_rectangles")]
    pub const PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT: Self = Self(1000099000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT")]
    #[cfg(feature = "VK_EXT_discard_rectangles")]
    pub const PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT: Self = Self(1000099001);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT")]
    #[cfg(feature = "VK_EXT_conservative_rasterization")]
    pub const PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT: Self = Self(1000101000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT")]
    #[cfg(feature = "VK_EXT_conservative_rasterization")]
    pub const PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT: Self = Self(1000101001);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT")]
    #[cfg(feature = "VK_EXT_depth_clip_enable")]
    pub const PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT: Self = Self(1000102000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT")]
    #[cfg(feature = "VK_EXT_depth_clip_enable")]
    pub const PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT: Self = Self(1000102001);
    #[doc(alias = "VK_STRUCTURE_TYPE_HDR_METADATA_EXT")]
    #[cfg(feature = "VK_EXT_hdr_metadata")]
    pub const HDR_METADATA_EXT: Self = Self(1000105000);
    #[doc(alias = "VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR")]
    #[cfg(feature = "VK_KHR_shared_presentable_image")]
    pub const SHARED_PRESENT_SURFACE_CAPABILITIES_KHR: Self = Self(1000111000);
    #[doc(alias = "VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR")]
    #[cfg(feature = "VK_KHR_external_fence_win32")]
    pub const IMPORT_FENCE_WIN32_HANDLE_INFO_KHR: Self = Self(1000114000);
    #[doc(alias = "VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR")]
    #[cfg(feature = "VK_KHR_external_fence_win32")]
    pub const EXPORT_FENCE_WIN32_HANDLE_INFO_KHR: Self = Self(1000114001);
    #[doc(alias = "VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR")]
    #[cfg(feature = "VK_KHR_external_fence_win32")]
    pub const FENCE_GET_WIN32_HANDLE_INFO_KHR: Self = Self(1000114002);
    #[doc(alias = "VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR")]
    #[cfg(feature = "VK_KHR_external_fence_fd")]
    pub const IMPORT_FENCE_FD_INFO_KHR: Self = Self(1000115000);
    #[doc(alias = "VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR")]
    #[cfg(feature = "VK_KHR_external_fence_fd")]
    pub const FENCE_GET_FD_INFO_KHR: Self = Self(1000115001);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR")]
    #[cfg(feature = "VK_KHR_performance_query")]
    pub const PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR: Self = Self(1000116000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR")]
    #[cfg(feature = "VK_KHR_performance_query")]
    pub const PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR: Self = Self(1000116001);
    #[doc(alias = "VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR")]
    #[cfg(feature = "VK_KHR_performance_query")]
    pub const QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR: Self = Self(1000116002);
    #[doc(alias = "VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR")]
    #[cfg(feature = "VK_KHR_performance_query")]
    pub const PERFORMANCE_QUERY_SUBMIT_INFO_KHR: Self = Self(1000116003);
    #[doc(alias = "VK_STRUCTURE_TYPE_ACQUIRE_PROFILING_LOCK_INFO_KHR")]
    #[cfg(feature = "VK_KHR_performance_query")]
    pub const ACQUIRE_PROFILING_LOCK_INFO_KHR: Self = Self(1000116004);
    #[doc(alias = "VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_KHR")]
    #[cfg(feature = "VK_KHR_performance_query")]
    pub const PERFORMANCE_COUNTER_KHR: Self = Self(1000116005);
    #[doc(alias = "VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_KHR")]
    #[cfg(feature = "VK_KHR_performance_query")]
    pub const PERFORMANCE_COUNTER_DESCRIPTION_KHR: Self = Self(1000116006);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR")]
    #[cfg(feature = "VK_KHR_get_surface_capabilities2")]
    pub const PHYSICAL_DEVICE_SURFACE_INFO2_KHR: Self = Self(1000119000);
    #[doc(alias = "VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR")]
    #[cfg(feature = "VK_KHR_get_surface_capabilities2")]
    pub const SURFACE_CAPABILITIES2_KHR: Self = Self(1000119001);
    #[doc(alias = "VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR")]
    #[cfg(feature = "VK_KHR_get_surface_capabilities2")]
    pub const SURFACE_FORMAT2_KHR: Self = Self(1000119002);
    #[doc(alias = "VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR")]
    #[cfg(feature = "VK_KHR_get_display_properties2")]
    pub const DISPLAY_PROPERTIES2_KHR: Self = Self(1000121000);
    #[doc(alias = "VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR")]
    #[cfg(feature = "VK_KHR_get_display_properties2")]
    pub const DISPLAY_PLANE_PROPERTIES2_KHR: Self = Self(1000121001);
    #[doc(alias = "VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR")]
    #[cfg(feature = "VK_KHR_get_display_properties2")]
    pub const DISPLAY_MODE_PROPERTIES2_KHR: Self = Self(1000121002);
    #[doc(alias = "VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR")]
    #[cfg(feature = "VK_KHR_get_display_properties2")]
    pub const DISPLAY_PLANE_INFO2_KHR: Self = Self(1000121003);
    #[doc(alias = "VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR")]
    #[cfg(feature = "VK_KHR_get_display_properties2")]
    pub const DISPLAY_PLANE_CAPABILITIES2_KHR: Self = Self(1000121004);
    #[doc(alias = "VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK")]
    #[cfg(feature = "VK_MVK_ios_surface")]
    pub const IOS_SURFACE_CREATE_INFO_MVK: Self = Self(1000122000);
    #[doc(alias = "VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK")]
    #[cfg(feature = "VK_MVK_macos_surface")]
    pub const MACOS_SURFACE_CREATE_INFO_MVK: Self = Self(1000123000);
    #[doc(alias = "VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT")]
    #[cfg(feature = "VK_EXT_debug_utils")]
    pub const DEBUG_UTILS_OBJECT_NAME_INFO_EXT: Self = Self(1000128000);
    #[doc(alias = "VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT")]
    #[cfg(feature = "VK_EXT_debug_utils")]
    pub const DEBUG_UTILS_OBJECT_TAG_INFO_EXT: Self = Self(1000128001);
    #[doc(alias = "VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT")]
    #[cfg(feature = "VK_EXT_debug_utils")]
    pub const DEBUG_UTILS_LABEL_EXT: Self = Self(1000128002);
    #[doc(alias = "VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT")]
    #[cfg(feature = "VK_EXT_debug_utils")]
    pub const DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT: Self = Self(1000128003);
    #[doc(alias = "VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT")]
    #[cfg(feature = "VK_EXT_debug_utils")]
    pub const DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT: Self = Self(1000128004);
    #[doc(alias = "VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID")]
    #[cfg(feature = "VK_ANDROID_external_memory_android_hardware_buffer")]
    pub const ANDROID_HARDWARE_BUFFER_USAGE_ANDROID: Self = Self(1000129000);
    #[doc(alias = "VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID")]
    #[cfg(feature = "VK_ANDROID_external_memory_android_hardware_buffer")]
    pub const ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID: Self = Self(1000129001);
    #[doc(alias = "VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID")]
    #[cfg(feature = "VK_ANDROID_external_memory_android_hardware_buffer")]
    pub const ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID: Self = Self(1000129002);
    #[doc(alias = "VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID")]
    #[cfg(feature = "VK_ANDROID_external_memory_android_hardware_buffer")]
    pub const IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID: Self = Self(1000129003);
    #[doc(alias = "VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID")]
    #[cfg(feature = "VK_ANDROID_external_memory_android_hardware_buffer")]
    pub const MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID: Self = Self(1000129004);
    #[doc(alias = "VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID")]
    #[cfg(feature = "VK_ANDROID_external_memory_android_hardware_buffer")]
    pub const EXTERNAL_FORMAT_ANDROID: Self = Self(1000129005);
    #[doc(alias = "VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_2_ANDROID")]
    #[cfg(feature = "VK_ANDROID_external_memory_android_hardware_buffer")]
    pub const ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES2_ANDROID: Self = Self(1000129006);
    #[doc(alias = "VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT")]
    #[cfg(feature = "VK_EXT_sample_locations")]
    pub const SAMPLE_LOCATIONS_INFO_EXT: Self = Self(1000143000);
    #[doc(alias = "VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT")]
    #[cfg(feature = "VK_EXT_sample_locations")]
    pub const RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT: Self = Self(1000143001);
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT")]
    #[cfg(feature = "VK_EXT_sample_locations")]
    pub const PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT: Self = Self(1000143002);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT")]
    #[cfg(feature = "VK_EXT_sample_locations")]
    pub const PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT: Self = Self(1000143003);
    #[doc(alias = "VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT")]
    #[cfg(feature = "VK_EXT_sample_locations")]
    pub const MULTISAMPLE_PROPERTIES_EXT: Self = Self(1000143004);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    pub const PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT: Self = Self(1000148000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    pub const PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT: Self = Self(1000148001);
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    pub const PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT: Self = Self(1000148002);
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV")]
    #[cfg(feature = "VK_NV_fragment_coverage_to_color")]
    pub const PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV: Self = Self(1000149000);
    #[doc(alias = "VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR")]
    #[cfg(feature = "VK_KHR_acceleration_structure")]
    pub const WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR: Self = Self(1000150007);
    #[doc(alias = "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR")]
    #[cfg(feature = "VK_KHR_acceleration_structure")]
    pub const ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR: Self = Self(1000150000);
    #[doc(alias = "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR")]
    #[cfg(feature = "VK_KHR_acceleration_structure")]
    pub const ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR: Self = Self(1000150002);
    #[doc(alias = "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR")]
    #[cfg(feature = "VK_KHR_acceleration_structure")]
    pub const ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR: Self = Self(1000150003);
    #[doc(alias = "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR")]
    #[cfg(feature = "VK_KHR_acceleration_structure")]
    pub const ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR: Self = Self(1000150004);
    #[doc(alias = "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR")]
    #[cfg(feature = "VK_KHR_acceleration_structure")]
    pub const ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR: Self = Self(1000150005);
    #[doc(alias = "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR")]
    #[cfg(feature = "VK_KHR_acceleration_structure")]
    pub const ACCELERATION_STRUCTURE_GEOMETRY_KHR: Self = Self(1000150006);
    #[doc(alias = "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_VERSION_INFO_KHR")]
    #[cfg(feature = "VK_KHR_acceleration_structure")]
    pub const ACCELERATION_STRUCTURE_VERSION_INFO_KHR: Self = Self(1000150009);
    #[doc(alias = "VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_INFO_KHR")]
    #[cfg(feature = "VK_KHR_acceleration_structure")]
    pub const COPY_ACCELERATION_STRUCTURE_INFO_KHR: Self = Self(1000150010);
    #[doc(alias = "VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR")]
    #[cfg(feature = "VK_KHR_acceleration_structure")]
    pub const COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR: Self = Self(1000150011);
    #[doc(alias = "VK_STRUCTURE_TYPE_COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR")]
    #[cfg(feature = "VK_KHR_acceleration_structure")]
    pub const COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR: Self = Self(1000150012);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR")]
    #[cfg(feature = "VK_KHR_acceleration_structure")]
    pub const PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR: Self = Self(1000150013);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR")]
    #[cfg(feature = "VK_KHR_acceleration_structure")]
    pub const PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR: Self = Self(1000150014);
    #[doc(alias = "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR")]
    #[cfg(feature = "VK_KHR_acceleration_structure")]
    pub const ACCELERATION_STRUCTURE_CREATE_INFO_KHR: Self = Self(1000150017);
    #[doc(alias = "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR")]
    #[cfg(feature = "VK_KHR_acceleration_structure")]
    pub const ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR: Self = Self(1000150020);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR")]
    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
    pub const PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR: Self = Self(1000347000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR")]
    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
    pub const PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR: Self = Self(1000347001);
    #[doc(alias = "VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR")]
    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
    pub const RAY_TRACING_PIPELINE_CREATE_INFO_KHR: Self = Self(1000150015);
    #[doc(alias = "VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR")]
    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
    pub const RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR: Self = Self(1000150016);
    #[doc(alias = "VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_INTERFACE_CREATE_INFO_KHR")]
    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
    pub const RAY_TRACING_PIPELINE_INTERFACE_CREATE_INFO_KHR: Self = Self(1000150018);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR")]
    #[cfg(feature = "VK_KHR_ray_query")]
    pub const PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR: Self = Self(1000348013);
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV")]
    #[cfg(feature = "VK_NV_framebuffer_mixed_samples")]
    pub const PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV: Self = Self(1000152000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV")]
    #[cfg(feature = "VK_NV_shader_sm_builtins")]
    pub const PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV: Self = Self(1000154000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV")]
    #[cfg(feature = "VK_NV_shader_sm_builtins")]
    pub const PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV: Self = Self(1000154001);
    #[doc(alias = "VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT")]
    #[cfg(feature = "VK_EXT_image_drm_format_modifier")]
    pub const DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT: Self = Self(1000158000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT")]
    #[cfg(feature = "VK_EXT_image_drm_format_modifier")]
    pub const PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT: Self = Self(1000158002);
    #[doc(alias = "VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT")]
    #[cfg(feature = "VK_EXT_image_drm_format_modifier")]
    pub const IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT: Self = Self(1000158003);
    #[doc(alias = "VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT")]
    #[cfg(feature = "VK_EXT_image_drm_format_modifier")]
    pub const IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT: Self = Self(1000158004);
    #[doc(alias = "VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT")]
    #[cfg(feature = "VK_EXT_image_drm_format_modifier")]
    pub const IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT: Self = Self(1000158005);
    #[doc(alias = "VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT")]
    #[cfg(feature = "VK_EXT_image_drm_format_modifier")]
    pub const DRM_FORMAT_MODIFIER_PROPERTIES_LIST2_EXT: Self = Self(1000158006);
    #[doc(alias = "VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT")]
    #[cfg(feature = "VK_EXT_validation_cache")]
    pub const VALIDATION_CACHE_CREATE_INFO_EXT: Self = Self(1000160000);
    #[doc(alias = "VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT")]
    #[cfg(feature = "VK_EXT_validation_cache")]
    pub const SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT: Self = Self(1000160001);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR")]
    #[cfg(feature = "VK_KHR_portability_subset")]
    pub const PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR: Self = Self(1000163000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_PROPERTIES_KHR")]
    #[cfg(feature = "VK_KHR_portability_subset")]
    pub const PHYSICAL_DEVICE_PORTABILITY_SUBSET_PROPERTIES_KHR: Self = Self(1000163001);
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV")]
    #[cfg(feature = "VK_NV_shading_rate_image")]
    pub const PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV: Self = Self(1000164000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV")]
    #[cfg(feature = "VK_NV_shading_rate_image")]
    pub const PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV: Self = Self(1000164001);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV")]
    #[cfg(feature = "VK_NV_shading_rate_image")]
    pub const PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV: Self = Self(1000164002);
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV")]
    #[cfg(feature = "VK_NV_shading_rate_image")]
    pub const PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV: Self = Self(1000164005);
    #[doc(alias = "VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV")]
    #[cfg(feature = "VK_NV_ray_tracing")]
    pub const RAY_TRACING_PIPELINE_CREATE_INFO_NV: Self = Self(1000165000);
    #[doc(alias = "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV")]
    #[cfg(feature = "VK_NV_ray_tracing")]
    pub const ACCELERATION_STRUCTURE_CREATE_INFO_NV: Self = Self(1000165001);
    #[doc(alias = "VK_STRUCTURE_TYPE_GEOMETRY_NV")]
    #[cfg(feature = "VK_NV_ray_tracing")]
    pub const GEOMETRY_NV: Self = Self(1000165003);
    #[doc(alias = "VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV")]
    #[cfg(feature = "VK_NV_ray_tracing")]
    pub const GEOMETRY_TRIANGLES_NV: Self = Self(1000165004);
    #[doc(alias = "VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV")]
    #[cfg(feature = "VK_NV_ray_tracing")]
    pub const GEOMETRY_AABB_NV: Self = Self(1000165005);
    #[doc(alias = "VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV")]
    #[cfg(feature = "VK_NV_ray_tracing")]
    pub const BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV: Self = Self(1000165006);
    #[doc(alias = "VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV")]
    #[cfg(feature = "VK_NV_ray_tracing")]
    pub const WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV: Self = Self(1000165007);
    #[doc(alias = "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV")]
    #[cfg(feature = "VK_NV_ray_tracing")]
    pub const ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV: Self = Self(1000165008);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV")]
    #[cfg(feature = "VK_NV_ray_tracing")]
    pub const PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV: Self = Self(1000165009);
    #[doc(alias = "VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV")]
    #[cfg(feature = "VK_NV_ray_tracing")]
    pub const RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV: Self = Self(1000165011);
    #[doc(alias = "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV")]
    #[cfg(feature = "VK_NV_ray_tracing")]
    pub const ACCELERATION_STRUCTURE_INFO_NV: Self = Self(1000165012);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV")]
    #[cfg(feature = "VK_NV_representative_fragment_test")]
    pub const PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV: Self = Self(1000166000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV")]
    #[cfg(feature = "VK_NV_representative_fragment_test")]
    pub const PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV: Self = Self(1000166001);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT")]
    #[cfg(feature = "VK_EXT_filter_cubic")]
    pub const PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT: Self = Self(1000170000);
    #[doc(alias = "VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT")]
    #[cfg(feature = "VK_EXT_filter_cubic")]
    pub const FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT: Self = Self(1000170001);
    #[doc(alias = "VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT")]
    #[cfg(feature = "VK_EXT_external_memory_host")]
    pub const IMPORT_MEMORY_HOST_POINTER_INFO_EXT: Self = Self(1000178000);
    #[doc(alias = "VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT")]
    #[cfg(feature = "VK_EXT_external_memory_host")]
    pub const MEMORY_HOST_POINTER_PROPERTIES_EXT: Self = Self(1000178001);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT")]
    #[cfg(feature = "VK_EXT_external_memory_host")]
    pub const PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT: Self = Self(1000178002);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR")]
    #[cfg(feature = "VK_KHR_shader_clock")]
    pub const PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR: Self = Self(1000181000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD")]
    #[cfg(feature = "VK_AMD_pipeline_compiler_control")]
    pub const PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD: Self = Self(1000183000);
    #[doc(alias = "VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_EXT")]
    #[cfg(feature = "VK_EXT_calibrated_timestamps")]
    pub const CALIBRATED_TIMESTAMP_INFO_EXT: Self = Self(1000184000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD")]
    #[cfg(feature = "VK_AMD_shader_core_properties")]
    pub const PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD: Self = Self(1000185000);
    #[doc(alias = "VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_KHR")]
    #[cfg(feature = "VK_KHR_global_priority")]
    pub const DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_KHR: Self = Self(1000174000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_KHR")]
    #[cfg(feature = "VK_KHR_global_priority")]
    pub const PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_KHR: Self = Self(1000388000);
    #[doc(alias = "VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_KHR")]
    #[cfg(feature = "VK_KHR_global_priority")]
    pub const QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_KHR: Self = Self(1000388001);
    #[doc(alias = "VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD")]
    #[cfg(feature = "VK_AMD_memory_overallocation_behavior")]
    pub const DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD: Self = Self(1000189000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT")]
    #[cfg(feature = "VK_EXT_vertex_attribute_divisor")]
    pub const PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT: Self = Self(1000190000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT")]
    #[cfg(feature = "VK_EXT_vertex_attribute_divisor")]
    pub const PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT: Self = Self(1000190001);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT")]
    #[cfg(feature = "VK_EXT_vertex_attribute_divisor")]
    pub const PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT: Self = Self(1000190002);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV")]
    #[cfg(feature = "VK_NV_compute_shader_derivatives")]
    pub const PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV: Self = Self(1000201000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV")]
    #[cfg(feature = "VK_NV_mesh_shader")]
    pub const PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV: Self = Self(1000202000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV")]
    #[cfg(feature = "VK_NV_mesh_shader")]
    pub const PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV: Self = Self(1000202001);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_NV")]
    #[cfg(feature = "VK_NV_fragment_shader_barycentric")]
    pub const PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_NV: Self = Self(1000203000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV")]
    #[cfg(feature = "VK_NV_shader_image_footprint")]
    pub const PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV: Self = Self(1000204000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV")]
    #[cfg(feature = "VK_NV_scissor_exclusive")]
    pub const PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV: Self = Self(1000205000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV")]
    #[cfg(feature = "VK_NV_scissor_exclusive")]
    pub const PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV: Self = Self(1000205002);
    #[doc(alias = "VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV")]
    #[cfg(feature = "VK_NV_device_diagnostic_checkpoints")]
    pub const CHECKPOINT_DATA_NV: Self = Self(1000206000);
    #[doc(alias = "VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV")]
    #[cfg(feature = "VK_NV_device_diagnostic_checkpoints")]
    pub const QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV: Self = Self(1000206001);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL")]
    #[cfg(feature = "VK_INTEL_shader_integer_functions2")]
    pub const PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS2_FEATURES_INTEL: Self = Self(1000209000);
    #[doc(alias = "VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL")]
    #[cfg(feature = "VK_INTEL_performance_query")]
    pub const QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL: Self = Self(1000210000);
    #[doc(alias = "VK_STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL")]
    #[cfg(feature = "VK_INTEL_performance_query")]
    pub const INITIALIZE_PERFORMANCE_API_INFO_INTEL: Self = Self(1000210001);
    #[doc(alias = "VK_STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL")]
    #[cfg(feature = "VK_INTEL_performance_query")]
    pub const PERFORMANCE_MARKER_INFO_INTEL: Self = Self(1000210002);
    #[doc(alias = "VK_STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL")]
    #[cfg(feature = "VK_INTEL_performance_query")]
    pub const PERFORMANCE_STREAM_MARKER_INFO_INTEL: Self = Self(1000210003);
    #[doc(alias = "VK_STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL")]
    #[cfg(feature = "VK_INTEL_performance_query")]
    pub const PERFORMANCE_OVERRIDE_INFO_INTEL: Self = Self(1000210004);
    #[doc(alias = "VK_STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL")]
    #[cfg(feature = "VK_INTEL_performance_query")]
    pub const PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL: Self = Self(1000210005);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT")]
    #[cfg(feature = "VK_EXT_pci_bus_info")]
    pub const PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT: Self = Self(1000212000);
    #[doc(alias = "VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD")]
    #[cfg(feature = "VK_AMD_display_native_hdr")]
    pub const DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD: Self = Self(1000213000);
    #[doc(alias = "VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD")]
    #[cfg(feature = "VK_AMD_display_native_hdr")]
    pub const SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD: Self = Self(1000213001);
    #[doc(alias = "VK_STRUCTURE_TYPE_IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA")]
    #[cfg(feature = "VK_FUCHSIA_imagepipe_surface")]
    pub const IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA: Self = Self(1000214000);
    #[doc(alias = "VK_STRUCTURE_TYPE_METAL_SURFACE_CREATE_INFO_EXT")]
    #[cfg(feature = "VK_EXT_metal_surface")]
    pub const METAL_SURFACE_CREATE_INFO_EXT: Self = Self(1000217000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT")]
    #[cfg(feature = "VK_EXT_fragment_density_map")]
    pub const PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT: Self = Self(1000218000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT")]
    #[cfg(feature = "VK_EXT_fragment_density_map")]
    pub const PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT: Self = Self(1000218001);
    #[doc(alias = "VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT")]
    #[cfg(feature = "VK_EXT_fragment_density_map")]
    pub const RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT: Self = Self(1000218002);
    #[doc(alias = "VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR")]
    #[cfg(feature = "VK_KHR_fragment_shading_rate")]
    pub const FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR: Self = Self(1000226000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR")]
    #[cfg(feature = "VK_KHR_fragment_shading_rate")]
    pub const PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR: Self = Self(1000226001);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR")]
    #[cfg(feature = "VK_KHR_fragment_shading_rate")]
    pub const PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR: Self = Self(1000226002);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR")]
    #[cfg(feature = "VK_KHR_fragment_shading_rate")]
    pub const PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR: Self = Self(1000226003);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR")]
    #[cfg(feature = "VK_KHR_fragment_shading_rate")]
    pub const PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR: Self = Self(1000226004);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD")]
    #[cfg(feature = "VK_AMD_shader_core_properties2")]
    pub const PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES2_AMD: Self = Self(1000227000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD")]
    #[cfg(feature = "VK_AMD_device_coherent_memory")]
    pub const PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD: Self = Self(1000229000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT")]
    #[cfg(feature = "VK_EXT_shader_image_atomic_int64")]
    pub const PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT: Self = Self(1000234000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT")]
    #[cfg(feature = "VK_EXT_memory_budget")]
    pub const PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT: Self = Self(1000237000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT")]
    #[cfg(feature = "VK_EXT_memory_priority")]
    pub const PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT: Self = Self(1000238000);
    #[doc(alias = "VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT")]
    #[cfg(feature = "VK_EXT_memory_priority")]
    pub const MEMORY_PRIORITY_ALLOCATE_INFO_EXT: Self = Self(1000238001);
    #[doc(alias = "VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR")]
    #[cfg(feature = "VK_KHR_surface_protected_capabilities")]
    pub const SURFACE_PROTECTED_CAPABILITIES_KHR: Self = Self(1000239000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV")]
    #[cfg(feature = "VK_NV_dedicated_allocation_image_aliasing")]
    pub const PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV: Self = Self(1000240000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT")]
    #[cfg(feature = "VK_EXT_buffer_device_address")]
    pub const PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT: Self = Self(1000244000);
    #[doc(alias = "VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT")]
    #[cfg(feature = "VK_EXT_buffer_device_address")]
    pub const BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT: Self = Self(1000244002);
    #[doc(alias = "VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT")]
    #[cfg(feature = "VK_EXT_validation_features")]
    pub const VALIDATION_FEATURES_EXT: Self = Self(1000247000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR")]
    #[cfg(feature = "VK_KHR_present_wait")]
    pub const PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR: Self = Self(1000248000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV")]
    #[cfg(feature = "VK_NV_cooperative_matrix")]
    pub const PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV: Self = Self(1000249000);
    #[doc(alias = "VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV")]
    #[cfg(feature = "VK_NV_cooperative_matrix")]
    pub const COOPERATIVE_MATRIX_PROPERTIES_NV: Self = Self(1000249001);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV")]
    #[cfg(feature = "VK_NV_cooperative_matrix")]
    pub const PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV: Self = Self(1000249002);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV")]
    #[cfg(feature = "VK_NV_coverage_reduction_mode")]
    pub const PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV: Self = Self(1000250000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV")]
    #[cfg(feature = "VK_NV_coverage_reduction_mode")]
    pub const PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV: Self = Self(1000250001);
    #[doc(alias = "VK_STRUCTURE_TYPE_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV")]
    #[cfg(feature = "VK_NV_coverage_reduction_mode")]
    pub const FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV: Self = Self(1000250002);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT")]
    #[cfg(feature = "VK_EXT_fragment_shader_interlock")]
    pub const PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT: Self = Self(1000251000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT")]
    #[cfg(feature = "VK_EXT_ycbcr_image_arrays")]
    pub const PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT: Self = Self(1000252000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT")]
    #[cfg(feature = "VK_EXT_provoking_vertex")]
    pub const PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT: Self = Self(1000254000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT")]
    #[cfg(feature = "VK_EXT_provoking_vertex")]
    pub const PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT: Self = Self(1000254001);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT")]
    #[cfg(feature = "VK_EXT_provoking_vertex")]
    pub const PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT: Self = Self(1000254002);
    #[doc(alias = "VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT")]
    #[cfg(feature = "VK_EXT_full_screen_exclusive")]
    pub const SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT: Self = Self(1000255000);
    #[doc(alias = "VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT")]
    #[cfg(feature = "VK_EXT_full_screen_exclusive")]
    pub const SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT: Self = Self(1000255002);
    #[doc(alias = "VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT")]
    #[cfg(feature = "VK_EXT_full_screen_exclusive")]
    pub const SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT: Self = Self(1000255001);
    #[doc(alias = "VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT")]
    #[cfg(feature = "VK_EXT_headless_surface")]
    pub const HEADLESS_SURFACE_CREATE_INFO_EXT: Self = Self(1000256000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT")]
    #[cfg(feature = "VK_EXT_line_rasterization")]
    pub const PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT: Self = Self(1000259000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT")]
    #[cfg(feature = "VK_EXT_line_rasterization")]
    pub const PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT: Self = Self(1000259001);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT")]
    #[cfg(feature = "VK_EXT_line_rasterization")]
    pub const PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT: Self = Self(1000259002);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT")]
    #[cfg(feature = "VK_EXT_shader_atomic_float")]
    pub const PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT: Self = Self(1000260000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT")]
    #[cfg(feature = "VK_EXT_index_type_uint8")]
    pub const PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT: Self = Self(1000265000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT")]
    #[cfg(feature = "VK_EXT_extended_dynamic_state")]
    pub const PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT: Self = Self(1000267000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR")]
    #[cfg(feature = "VK_KHR_pipeline_executable_properties")]
    pub const PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR: Self = Self(1000269000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR")]
    #[cfg(feature = "VK_KHR_pipeline_executable_properties")]
    pub const PIPELINE_INFO_KHR: Self = Self(1000269001);
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR")]
    #[cfg(feature = "VK_KHR_pipeline_executable_properties")]
    pub const PIPELINE_EXECUTABLE_PROPERTIES_KHR: Self = Self(1000269002);
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR")]
    #[cfg(feature = "VK_KHR_pipeline_executable_properties")]
    pub const PIPELINE_EXECUTABLE_INFO_KHR: Self = Self(1000269003);
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR")]
    #[cfg(feature = "VK_KHR_pipeline_executable_properties")]
    pub const PIPELINE_EXECUTABLE_STATISTIC_KHR: Self = Self(1000269004);
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR")]
    #[cfg(feature = "VK_KHR_pipeline_executable_properties")]
    pub const PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR: Self = Self(1000269005);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT")]
    #[cfg(feature = "VK_EXT_shader_atomic_float2")]
    pub const PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT2_FEATURES_EXT: Self = Self(1000273000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV")]
    #[cfg(feature = "VK_NV_device_generated_commands")]
    pub const PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV: Self = Self(1000277000);
    #[doc(alias = "VK_STRUCTURE_TYPE_GRAPHICS_SHADER_GROUP_CREATE_INFO_NV")]
    #[cfg(feature = "VK_NV_device_generated_commands")]
    pub const GRAPHICS_SHADER_GROUP_CREATE_INFO_NV: Self = Self(1000277001);
    #[doc(alias = "VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV")]
    #[cfg(feature = "VK_NV_device_generated_commands")]
    pub const GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV: Self = Self(1000277002);
    #[doc(alias = "VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_NV")]
    #[cfg(feature = "VK_NV_device_generated_commands")]
    pub const INDIRECT_COMMANDS_LAYOUT_TOKEN_NV: Self = Self(1000277003);
    #[doc(alias = "VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NV")]
    #[cfg(feature = "VK_NV_device_generated_commands")]
    pub const INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NV: Self = Self(1000277004);
    #[doc(alias = "VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_NV")]
    #[cfg(feature = "VK_NV_device_generated_commands")]
    pub const GENERATED_COMMANDS_INFO_NV: Self = Self(1000277005);
    #[doc(alias = "VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_NV")]
    #[cfg(feature = "VK_NV_device_generated_commands")]
    pub const GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_NV: Self = Self(1000277006);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV")]
    #[cfg(feature = "VK_NV_device_generated_commands")]
    pub const PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV: Self = Self(1000277007);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV")]
    #[cfg(feature = "VK_NV_inherited_viewport_scissor")]
    pub const PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV: Self = Self(1000278000);
    #[doc(alias = "VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV")]
    #[cfg(feature = "VK_NV_inherited_viewport_scissor")]
    pub const COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV: Self = Self(1000278001);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT")]
    #[cfg(feature = "VK_EXT_texel_buffer_alignment")]
    pub const PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT: Self = Self(1000281000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT")]
    #[cfg(feature = "VK_EXT_device_memory_report")]
    pub const PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT: Self = Self(1000284000);
    #[doc(alias = "VK_STRUCTURE_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT")]
    #[cfg(feature = "VK_EXT_device_memory_report")]
    pub const DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT: Self = Self(1000284001);
    #[doc(alias = "VK_STRUCTURE_TYPE_DEVICE_MEMORY_REPORT_CALLBACK_DATA_EXT")]
    #[cfg(feature = "VK_EXT_device_memory_report")]
    pub const DEVICE_MEMORY_REPORT_CALLBACK_DATA_EXT: Self = Self(1000284002);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT")]
    #[cfg(feature = "VK_EXT_robustness2")]
    pub const PHYSICAL_DEVICE_ROBUSTNESS2_FEATURES_EXT: Self = Self(1000286000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_EXT")]
    #[cfg(feature = "VK_EXT_robustness2")]
    pub const PHYSICAL_DEVICE_ROBUSTNESS2_PROPERTIES_EXT: Self = Self(1000286001);
    #[doc(alias = "VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT")]
    #[cfg(feature = "VK_EXT_custom_border_color")]
    pub const SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT: Self = Self(1000287000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT")]
    #[cfg(feature = "VK_EXT_custom_border_color")]
    pub const PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT: Self = Self(1000287001);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT")]
    #[cfg(feature = "VK_EXT_custom_border_color")]
    pub const PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT: Self = Self(1000287002);
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR")]
    #[cfg(feature = "VK_KHR_pipeline_library")]
    pub const PIPELINE_LIBRARY_CREATE_INFO_KHR: Self = Self(1000290000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PRESENT_ID_KHR")]
    #[cfg(feature = "VK_KHR_present_id")]
    pub const PRESENT_ID_KHR: Self = Self(1000294000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR")]
    #[cfg(feature = "VK_KHR_present_id")]
    pub const PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR: Self = Self(1000294001);
    #[doc(alias = "VK_STRUCTURE_TYPE_VIDEO_ENCODE_INFO_KHR")]
    #[cfg(feature = "VK_KHR_video_encode_queue")]
    pub const VIDEO_ENCODE_INFO_KHR: Self = Self(1000299000);
    #[doc(alias = "VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_INFO_KHR")]
    #[cfg(feature = "VK_KHR_video_encode_queue")]
    pub const VIDEO_ENCODE_RATE_CONTROL_INFO_KHR: Self = Self(1000299001);
    #[doc(alias = "VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_LAYER_INFO_KHR")]
    #[cfg(feature = "VK_KHR_video_encode_queue")]
    pub const VIDEO_ENCODE_RATE_CONTROL_LAYER_INFO_KHR: Self = Self(1000299002);
    #[doc(alias = "VK_STRUCTURE_TYPE_VIDEO_ENCODE_CAPABILITIES_KHR")]
    #[cfg(feature = "VK_KHR_video_encode_queue")]
    pub const VIDEO_ENCODE_CAPABILITIES_KHR: Self = Self(1000299003);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV")]
    #[cfg(feature = "VK_NV_device_diagnostics_config")]
    pub const PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV: Self = Self(1000300000);
    #[doc(alias = "VK_STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV")]
    #[cfg(feature = "VK_NV_device_diagnostics_config")]
    pub const DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV: Self = Self(1000300001);
    #[doc(alias = "VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV")]
    #[cfg(feature = "VK_KHR_synchronization2")]
    pub const QUEUE_FAMILY_CHECKPOINT_PROPERTIES2_NV: Self = Self(1000314008);
    #[doc(alias = "VK_STRUCTURE_TYPE_CHECKPOINT_DATA_2_NV")]
    #[cfg(feature = "VK_KHR_synchronization2")]
    pub const CHECKPOINT_DATA2_NV: Self = Self(1000314009);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR")]
    #[cfg(feature = "VK_KHR_shader_subgroup_uniform_control_flow")]
    pub const PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR: Self = Self(1000323000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV")]
    #[cfg(feature = "VK_NV_fragment_shading_rate_enums")]
    pub const PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV: Self = Self(1000326000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV")]
    #[cfg(feature = "VK_NV_fragment_shading_rate_enums")]
    pub const PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV: Self = Self(1000326001);
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV")]
    #[cfg(feature = "VK_NV_fragment_shading_rate_enums")]
    pub const PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV: Self = Self(1000326002);
    #[doc(alias = "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_MOTION_TRIANGLES_DATA_NV")]
    #[cfg(feature = "VK_NV_ray_tracing_motion_blur")]
    pub const ACCELERATION_STRUCTURE_GEOMETRY_MOTION_TRIANGLES_DATA_NV: Self = Self(1000327000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV")]
    #[cfg(feature = "VK_NV_ray_tracing_motion_blur")]
    pub const PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV: Self = Self(1000327001);
    #[doc(alias = "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MOTION_INFO_NV")]
    #[cfg(feature = "VK_NV_ray_tracing_motion_blur")]
    pub const ACCELERATION_STRUCTURE_MOTION_INFO_NV: Self = Self(1000327002);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT")]
    #[cfg(feature = "VK_EXT_ycbcr_2plane_444_formats")]
    pub const PHYSICAL_DEVICE_YCBCR2_PLANE_444_FORMATS_FEATURES_EXT: Self = Self(1000330000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT")]
    #[cfg(feature = "VK_EXT_fragment_density_map2")]
    pub const PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP2_FEATURES_EXT: Self = Self(1000332000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT")]
    #[cfg(feature = "VK_EXT_fragment_density_map2")]
    pub const PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP2_PROPERTIES_EXT: Self = Self(1000332001);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR")]
    #[cfg(feature = "VK_KHR_workgroup_memory_explicit_layout")]
    pub const PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR: Self = Self(1000336000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT")]
    #[cfg(feature = "VK_EXT_4444_formats")]
    pub const PHYSICAL_DEVICE4444_FORMATS_FEATURES_EXT: Self = Self(1000340000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_ARM")]
    #[cfg(feature = "VK_ARM_rasterization_order_attachment_access")]
    pub const PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_ARM: Self = Self(1000342000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT")]
    #[cfg(feature = "VK_EXT_rgba10x6_formats")]
    pub const PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT: Self = Self(1000344000);
    #[doc(alias = "VK_STRUCTURE_TYPE_DIRECTFB_SURFACE_CREATE_INFO_EXT")]
    #[cfg(feature = "VK_EXT_directfb_surface")]
    pub const DIRECTFB_SURFACE_CREATE_INFO_EXT: Self = Self(1000346000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_VALVE")]
    #[cfg(feature = "VK_VALVE_mutable_descriptor_type")]
    pub const PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_VALVE: Self = Self(1000351000);
    #[doc(alias = "VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_VALVE")]
    #[cfg(feature = "VK_VALVE_mutable_descriptor_type")]
    pub const MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_VALVE: Self = Self(1000351002);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT")]
    #[cfg(feature = "VK_EXT_vertex_input_dynamic_state")]
    pub const PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT: Self = Self(1000352000);
    #[doc(alias = "VK_STRUCTURE_TYPE_VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT")]
    #[cfg(feature = "VK_EXT_vertex_input_dynamic_state")]
    pub const VERTEX_INPUT_BINDING_DESCRIPTION2_EXT: Self = Self(1000352001);
    #[doc(alias = "VK_STRUCTURE_TYPE_VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT")]
    #[cfg(feature = "VK_EXT_vertex_input_dynamic_state")]
    pub const VERTEX_INPUT_ATTRIBUTE_DESCRIPTION2_EXT: Self = Self(1000352002);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRM_PROPERTIES_EXT")]
    #[cfg(feature = "VK_EXT_physical_device_drm")]
    pub const PHYSICAL_DEVICE_DRM_PROPERTIES_EXT: Self = Self(1000353000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT")]
    #[cfg(feature = "VK_EXT_depth_clip_control")]
    pub const PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT: Self = Self(1000355000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_EXT")]
    #[cfg(feature = "VK_EXT_depth_clip_control")]
    pub const PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_EXT: Self = Self(1000355001);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT")]
    #[cfg(feature = "VK_EXT_primitive_topology_list_restart")]
    pub const PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT: Self = Self(1000356000);
    #[doc(alias = "VK_STRUCTURE_TYPE_IMPORT_MEMORY_ZIRCON_HANDLE_INFO_FUCHSIA")]
    #[cfg(feature = "VK_FUCHSIA_external_memory")]
    pub const IMPORT_MEMORY_ZIRCON_HANDLE_INFO_FUCHSIA: Self = Self(1000364000);
    #[doc(alias = "VK_STRUCTURE_TYPE_MEMORY_ZIRCON_HANDLE_PROPERTIES_FUCHSIA")]
    #[cfg(feature = "VK_FUCHSIA_external_memory")]
    pub const MEMORY_ZIRCON_HANDLE_PROPERTIES_FUCHSIA: Self = Self(1000364001);
    #[doc(alias = "VK_STRUCTURE_TYPE_MEMORY_GET_ZIRCON_HANDLE_INFO_FUCHSIA")]
    #[cfg(feature = "VK_FUCHSIA_external_memory")]
    pub const MEMORY_GET_ZIRCON_HANDLE_INFO_FUCHSIA: Self = Self(1000364002);
    #[doc(alias = "VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_ZIRCON_HANDLE_INFO_FUCHSIA")]
    #[cfg(feature = "VK_FUCHSIA_external_semaphore")]
    pub const IMPORT_SEMAPHORE_ZIRCON_HANDLE_INFO_FUCHSIA: Self = Self(1000365000);
    #[doc(alias = "VK_STRUCTURE_TYPE_SEMAPHORE_GET_ZIRCON_HANDLE_INFO_FUCHSIA")]
    #[cfg(feature = "VK_FUCHSIA_external_semaphore")]
    pub const SEMAPHORE_GET_ZIRCON_HANDLE_INFO_FUCHSIA: Self = Self(1000365001);
    #[doc(alias = "VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CREATE_INFO_FUCHSIA")]
    #[cfg(feature = "VK_FUCHSIA_buffer_collection")]
    pub const BUFFER_COLLECTION_CREATE_INFO_FUCHSIA: Self = Self(1000366000);
    #[doc(alias = "VK_STRUCTURE_TYPE_IMPORT_MEMORY_BUFFER_COLLECTION_FUCHSIA")]
    #[cfg(feature = "VK_FUCHSIA_buffer_collection")]
    pub const IMPORT_MEMORY_BUFFER_COLLECTION_FUCHSIA: Self = Self(1000366001);
    #[doc(alias = "VK_STRUCTURE_TYPE_BUFFER_COLLECTION_IMAGE_CREATE_INFO_FUCHSIA")]
    #[cfg(feature = "VK_FUCHSIA_buffer_collection")]
    pub const BUFFER_COLLECTION_IMAGE_CREATE_INFO_FUCHSIA: Self = Self(1000366002);
    #[doc(alias = "VK_STRUCTURE_TYPE_BUFFER_COLLECTION_PROPERTIES_FUCHSIA")]
    #[cfg(feature = "VK_FUCHSIA_buffer_collection")]
    pub const BUFFER_COLLECTION_PROPERTIES_FUCHSIA: Self = Self(1000366003);
    #[doc(alias = "VK_STRUCTURE_TYPE_BUFFER_CONSTRAINTS_INFO_FUCHSIA")]
    #[cfg(feature = "VK_FUCHSIA_buffer_collection")]
    pub const BUFFER_CONSTRAINTS_INFO_FUCHSIA: Self = Self(1000366004);
    #[doc(alias = "VK_STRUCTURE_TYPE_BUFFER_COLLECTION_BUFFER_CREATE_INFO_FUCHSIA")]
    #[cfg(feature = "VK_FUCHSIA_buffer_collection")]
    pub const BUFFER_COLLECTION_BUFFER_CREATE_INFO_FUCHSIA: Self = Self(1000366005);
    #[doc(alias = "VK_STRUCTURE_TYPE_IMAGE_CONSTRAINTS_INFO_FUCHSIA")]
    #[cfg(feature = "VK_FUCHSIA_buffer_collection")]
    pub const IMAGE_CONSTRAINTS_INFO_FUCHSIA: Self = Self(1000366006);
    #[doc(alias = "VK_STRUCTURE_TYPE_IMAGE_FORMAT_CONSTRAINTS_INFO_FUCHSIA")]
    #[cfg(feature = "VK_FUCHSIA_buffer_collection")]
    pub const IMAGE_FORMAT_CONSTRAINTS_INFO_FUCHSIA: Self = Self(1000366007);
    #[doc(alias = "VK_STRUCTURE_TYPE_SYSMEM_COLOR_SPACE_FUCHSIA")]
    #[cfg(feature = "VK_FUCHSIA_buffer_collection")]
    pub const SYSMEM_COLOR_SPACE_FUCHSIA: Self = Self(1000366008);
    #[doc(alias = "VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CONSTRAINTS_INFO_FUCHSIA")]
    #[cfg(feature = "VK_FUCHSIA_buffer_collection")]
    pub const BUFFER_COLLECTION_CONSTRAINTS_INFO_FUCHSIA: Self = Self(1000366009);
    #[doc(alias = "VK_STRUCTURE_TYPE_SUBPASS_SHADING_PIPELINE_CREATE_INFO_HUAWEI")]
    #[cfg(feature = "VK_HUAWEI_subpass_shading")]
    pub const SUBPASS_SHADING_PIPELINE_CREATE_INFO_HUAWEI: Self = Self(1000369000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI")]
    #[cfg(feature = "VK_HUAWEI_subpass_shading")]
    pub const PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI: Self = Self(1000369001);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI")]
    #[cfg(feature = "VK_HUAWEI_subpass_shading")]
    pub const PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI: Self = Self(1000369002);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI")]
    #[cfg(feature = "VK_HUAWEI_invocation_mask")]
    pub const PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI: Self = Self(1000370000);
    #[doc(alias = "VK_STRUCTURE_TYPE_MEMORY_GET_REMOTE_ADDRESS_INFO_NV")]
    #[cfg(feature = "VK_NV_external_memory_rdma")]
    pub const MEMORY_GET_REMOTE_ADDRESS_INFO_NV: Self = Self(1000371000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_RDMA_FEATURES_NV")]
    #[cfg(feature = "VK_NV_external_memory_rdma")]
    pub const PHYSICAL_DEVICE_EXTERNAL_MEMORY_RDMA_FEATURES_NV: Self = Self(1000371001);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT")]
    #[cfg(feature = "VK_EXT_extended_dynamic_state2")]
    pub const PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE2_FEATURES_EXT: Self = Self(1000377000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT")]
    #[cfg(feature = "VK_EXT_color_write_enable")]
    pub const PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT: Self = Self(1000381000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_COLOR_WRITE_CREATE_INFO_EXT")]
    #[cfg(feature = "VK_EXT_color_write_enable")]
    pub const PIPELINE_COLOR_WRITE_CREATE_INFO_EXT: Self = Self(1000381001);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT")]
    #[cfg(feature = "VK_EXT_image_view_min_lod")]
    pub const PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT: Self = Self(1000391000);
    #[doc(alias = "VK_STRUCTURE_TYPE_IMAGE_VIEW_MIN_LOD_CREATE_INFO_EXT")]
    #[cfg(feature = "VK_EXT_image_view_min_lod")]
    pub const IMAGE_VIEW_MIN_LOD_CREATE_INFO_EXT: Self = Self(1000391001);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT")]
    #[cfg(feature = "VK_EXT_multi_draw")]
    pub const PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT: Self = Self(1000392000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT")]
    #[cfg(feature = "VK_EXT_multi_draw")]
    pub const PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT: Self = Self(1000392001);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT")]
    #[cfg(feature = "VK_EXT_border_color_swizzle")]
    pub const PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT: Self = Self(1000411000);
    #[doc(alias = "VK_STRUCTURE_TYPE_SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT")]
    #[cfg(feature = "VK_EXT_border_color_swizzle")]
    pub const SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT: Self = Self(1000411001);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT")]
    #[cfg(feature = "VK_EXT_pageable_device_local_memory")]
    pub const PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT: Self = Self(1000412000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE")]
    #[cfg(feature = "VK_VALVE_descriptor_set_host_mapping")]
    pub const PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE: Self = Self(1000420000);
    #[doc(alias = "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_BINDING_REFERENCE_VALVE")]
    #[cfg(feature = "VK_VALVE_descriptor_set_host_mapping")]
    pub const DESCRIPTOR_SET_BINDING_REFERENCE_VALVE: Self = Self(1000420001);
    #[doc(alias = "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_HOST_MAPPING_INFO_VALVE")]
    #[cfg(feature = "VK_VALVE_descriptor_set_host_mapping")]
    pub const DESCRIPTOR_SET_LAYOUT_HOST_MAPPING_INFO_VALVE: Self = Self(1000420002);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV")]
    #[cfg(feature = "VK_NV_linear_color_attachment")]
    pub const PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV: Self = Self(1000430000);
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES")]
    pub const PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES: Self = Self::PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES;
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES")]
    pub const PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES: Self =
        Self::PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES;
    #[doc(alias = "VK_STRUCTURE_TYPE_DEBUG_REPORT_CREATE_INFO_EXT")]
    #[cfg(feature = "VK_EXT_debug_report")]
    pub const DEBUG_REPORT_CREATE_INFO_EXT: Self = Self::DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT;
    #[doc(alias = "VK_STRUCTURE_TYPE_RENDERING_INFO_KHR")]
    #[cfg(feature = "VK_KHR_dynamic_rendering")]
    pub const RENDERING_INFO_KHR: Self = Self::RENDERING_INFO;
    #[doc(alias = "VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO_KHR")]
    #[cfg(feature = "VK_KHR_dynamic_rendering")]
    pub const RENDERING_ATTACHMENT_INFO_KHR: Self = Self::RENDERING_ATTACHMENT_INFO;
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO_KHR")]
    #[cfg(feature = "VK_KHR_dynamic_rendering")]
    pub const PIPELINE_RENDERING_CREATE_INFO_KHR: Self = Self::PIPELINE_RENDERING_CREATE_INFO;
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES_KHR")]
    #[cfg(feature = "VK_KHR_dynamic_rendering")]
    pub const PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES_KHR: Self = Self::PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES;
    #[doc(alias = "VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO_KHR")]
    #[cfg(feature = "VK_KHR_dynamic_rendering")]
    pub const COMMAND_BUFFER_INHERITANCE_RENDERING_INFO_KHR: Self = Self::COMMAND_BUFFER_INHERITANCE_RENDERING_INFO;
    #[doc(alias = "VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_NV")]
    #[cfg(feature = "VK_KHR_dynamic_rendering")]
    pub const ATTACHMENT_SAMPLE_COUNT_INFO_NV: Self = Self::ATTACHMENT_SAMPLE_COUNT_INFO_AMD;
    #[doc(alias = "VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO_KHR")]
    #[cfg(feature = "VK_KHR_multiview")]
    pub const RENDER_PASS_MULTIVIEW_CREATE_INFO_KHR: Self = Self::RENDER_PASS_MULTIVIEW_CREATE_INFO;
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES_KHR")]
    #[cfg(feature = "VK_KHR_multiview")]
    pub const PHYSICAL_DEVICE_MULTIVIEW_FEATURES_KHR: Self = Self::PHYSICAL_DEVICE_MULTIVIEW_FEATURES;
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES_KHR")]
    #[cfg(feature = "VK_KHR_multiview")]
    pub const PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES_KHR: Self = Self::PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES;
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2_KHR")]
    #[cfg(feature = "VK_KHR_get_physical_device_properties2")]
    pub const PHYSICAL_DEVICE_FEATURES2_KHR: Self = Self::PHYSICAL_DEVICE_FEATURES2;
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2_KHR")]
    #[cfg(feature = "VK_KHR_get_physical_device_properties2")]
    pub const PHYSICAL_DEVICE_PROPERTIES2_KHR: Self = Self::PHYSICAL_DEVICE_PROPERTIES2;
    #[doc(alias = "VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2_KHR")]
    #[cfg(feature = "VK_KHR_get_physical_device_properties2")]
    pub const FORMAT_PROPERTIES2_KHR: Self = Self::FORMAT_PROPERTIES2;
    #[doc(alias = "VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2_KHR")]
    #[cfg(feature = "VK_KHR_get_physical_device_properties2")]
    pub const IMAGE_FORMAT_PROPERTIES2_KHR: Self = Self::IMAGE_FORMAT_PROPERTIES2;
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2_KHR")]
    #[cfg(feature = "VK_KHR_get_physical_device_properties2")]
    pub const PHYSICAL_DEVICE_IMAGE_FORMAT_INFO2_KHR: Self = Self::PHYSICAL_DEVICE_IMAGE_FORMAT_INFO2;
    #[doc(alias = "VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2_KHR")]
    #[cfg(feature = "VK_KHR_get_physical_device_properties2")]
    pub const QUEUE_FAMILY_PROPERTIES2_KHR: Self = Self::QUEUE_FAMILY_PROPERTIES2;
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2_KHR")]
    #[cfg(feature = "VK_KHR_get_physical_device_properties2")]
    pub const PHYSICAL_DEVICE_MEMORY_PROPERTIES2_KHR: Self = Self::PHYSICAL_DEVICE_MEMORY_PROPERTIES2;
    #[doc(alias = "VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2_KHR")]
    #[cfg(feature = "VK_KHR_get_physical_device_properties2")]
    pub const SPARSE_IMAGE_FORMAT_PROPERTIES2_KHR: Self = Self::SPARSE_IMAGE_FORMAT_PROPERTIES2;
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2_KHR")]
    #[cfg(feature = "VK_KHR_get_physical_device_properties2")]
    pub const PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO2_KHR: Self = Self::PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO2;
    #[doc(alias = "VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO_KHR")]
    #[cfg(feature = "VK_KHR_device_group")]
    pub const MEMORY_ALLOCATE_FLAGS_INFO_KHR: Self = Self::MEMORY_ALLOCATE_FLAGS_INFO;
    #[doc(alias = "VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO_KHR")]
    #[cfg(feature = "VK_KHR_device_group")]
    pub const DEVICE_GROUP_RENDER_PASS_BEGIN_INFO_KHR: Self = Self::DEVICE_GROUP_RENDER_PASS_BEGIN_INFO;
    #[doc(alias = "VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO_KHR")]
    #[cfg(feature = "VK_KHR_device_group")]
    pub const DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO_KHR: Self = Self::DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO;
    #[doc(alias = "VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO_KHR")]
    #[cfg(feature = "VK_KHR_device_group")]
    pub const DEVICE_GROUP_SUBMIT_INFO_KHR: Self = Self::DEVICE_GROUP_SUBMIT_INFO;
    #[doc(alias = "VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO_KHR")]
    #[cfg(feature = "VK_KHR_device_group")]
    pub const DEVICE_GROUP_BIND_SPARSE_INFO_KHR: Self = Self::DEVICE_GROUP_BIND_SPARSE_INFO;
    #[doc(alias = "VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO_KHR")]
    #[cfg(feature = "VK_KHR_device_group")]
    pub const BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO_KHR: Self = Self::BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO;
    #[doc(alias = "VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO_KHR")]
    #[cfg(feature = "VK_KHR_device_group")]
    pub const BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO_KHR: Self = Self::BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO;
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES_EXT")]
    #[cfg(feature = "VK_EXT_texture_compression_astc_hdr")]
    pub const PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES_EXT: Self =
        Self::PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES;
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES_KHR")]
    #[cfg(feature = "VK_KHR_device_group_creation")]
    pub const PHYSICAL_DEVICE_GROUP_PROPERTIES_KHR: Self = Self::PHYSICAL_DEVICE_GROUP_PROPERTIES;
    #[doc(alias = "VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO_KHR")]
    #[cfg(feature = "VK_KHR_device_group_creation")]
    pub const DEVICE_GROUP_DEVICE_CREATE_INFO_KHR: Self = Self::DEVICE_GROUP_DEVICE_CREATE_INFO;
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO_KHR")]
    #[cfg(feature = "VK_KHR_external_memory_capabilities")]
    pub const PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO_KHR: Self = Self::PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO;
    #[doc(alias = "VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES_KHR")]
    #[cfg(feature = "VK_KHR_external_memory_capabilities")]
    pub const EXTERNAL_IMAGE_FORMAT_PROPERTIES_KHR: Self = Self::EXTERNAL_IMAGE_FORMAT_PROPERTIES;
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO_KHR")]
    #[cfg(feature = "VK_KHR_external_memory_capabilities")]
    pub const PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO_KHR: Self = Self::PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO;
    #[doc(alias = "VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES_KHR")]
    #[cfg(feature = "VK_KHR_external_memory_capabilities")]
    pub const EXTERNAL_BUFFER_PROPERTIES_KHR: Self = Self::EXTERNAL_BUFFER_PROPERTIES;
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES_KHR")]
    #[cfg(feature = "VK_KHR_external_fence_capabilities")]
    pub const PHYSICAL_DEVICE_ID_PROPERTIES_KHR: Self = Self::PHYSICAL_DEVICE_ID_PROPERTIES;
    #[doc(alias = "VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO_KHR")]
    #[cfg(feature = "VK_KHR_external_memory")]
    pub const EXTERNAL_MEMORY_BUFFER_CREATE_INFO_KHR: Self = Self::EXTERNAL_MEMORY_BUFFER_CREATE_INFO;
    #[doc(alias = "VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_KHR")]
    #[cfg(feature = "VK_KHR_external_memory")]
    pub const EXTERNAL_MEMORY_IMAGE_CREATE_INFO_KHR: Self = Self::EXTERNAL_MEMORY_IMAGE_CREATE_INFO;
    #[doc(alias = "VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_KHR")]
    #[cfg(feature = "VK_KHR_external_memory")]
    pub const EXPORT_MEMORY_ALLOCATE_INFO_KHR: Self = Self::EXPORT_MEMORY_ALLOCATE_INFO;
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO_KHR")]
    #[cfg(feature = "VK_KHR_external_semaphore_capabilities")]
    pub const PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO_KHR: Self = Self::PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO;
    #[doc(alias = "VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES_KHR")]
    #[cfg(feature = "VK_KHR_external_semaphore_capabilities")]
    pub const EXTERNAL_SEMAPHORE_PROPERTIES_KHR: Self = Self::EXTERNAL_SEMAPHORE_PROPERTIES;
    #[doc(alias = "VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO_KHR")]
    #[cfg(feature = "VK_KHR_external_semaphore")]
    pub const EXPORT_SEMAPHORE_CREATE_INFO_KHR: Self = Self::EXPORT_SEMAPHORE_CREATE_INFO;
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES_KHR")]
    #[cfg(feature = "VK_KHR_shader_float16_int8")]
    pub const PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES_KHR: Self =
        Self::PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES;
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT16_INT8_FEATURES_KHR")]
    #[cfg(feature = "VK_KHR_shader_float16_int8")]
    pub const PHYSICAL_DEVICE_FLOAT16_INT8_FEATURES_KHR: Self = Self::PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES;
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES_KHR")]
    #[cfg(feature = "VK_KHR_16bit_storage")]
    pub const PHYSICAL_DEVICE16BIT_STORAGE_FEATURES_KHR: Self = Self::PHYSICAL_DEVICE16BIT_STORAGE_FEATURES;
    #[doc(alias = "VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO_KHR")]
    #[cfg(feature = "VK_KHR_descriptor_update_template")]
    pub const DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO_KHR: Self = Self::DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO;
    #[doc(alias = "VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES2_EXT")]
    #[cfg(feature = "VK_EXT_display_surface_counter")]
    pub const SURFACE_CAPABILITIES2_EXT_DUP: Self = Self::SURFACE_CAPABILITIES2_EXT;
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES_KHR")]
    #[cfg(feature = "VK_KHR_imageless_framebuffer")]
    pub const PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES_KHR: Self =
        Self::PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES;
    #[doc(alias = "VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO_KHR")]
    #[cfg(feature = "VK_KHR_imageless_framebuffer")]
    pub const FRAMEBUFFER_ATTACHMENTS_CREATE_INFO_KHR: Self = Self::FRAMEBUFFER_ATTACHMENTS_CREATE_INFO;
    #[doc(alias = "VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO_KHR")]
    #[cfg(feature = "VK_KHR_imageless_framebuffer")]
    pub const FRAMEBUFFER_ATTACHMENT_IMAGE_INFO_KHR: Self = Self::FRAMEBUFFER_ATTACHMENT_IMAGE_INFO;
    #[doc(alias = "VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO_KHR")]
    #[cfg(feature = "VK_KHR_imageless_framebuffer")]
    pub const RENDER_PASS_ATTACHMENT_BEGIN_INFO_KHR: Self = Self::RENDER_PASS_ATTACHMENT_BEGIN_INFO;
    #[doc(alias = "VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2_KHR")]
    #[cfg(feature = "VK_KHR_create_renderpass2")]
    pub const ATTACHMENT_DESCRIPTION2_KHR: Self = Self::ATTACHMENT_DESCRIPTION2;
    #[doc(alias = "VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2_KHR")]
    #[cfg(feature = "VK_KHR_create_renderpass2")]
    pub const ATTACHMENT_REFERENCE2_KHR: Self = Self::ATTACHMENT_REFERENCE2;
    #[doc(alias = "VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2_KHR")]
    #[cfg(feature = "VK_KHR_create_renderpass2")]
    pub const SUBPASS_DESCRIPTION2_KHR: Self = Self::SUBPASS_DESCRIPTION2;
    #[doc(alias = "VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2_KHR")]
    #[cfg(feature = "VK_KHR_create_renderpass2")]
    pub const SUBPASS_DEPENDENCY2_KHR: Self = Self::SUBPASS_DEPENDENCY2;
    #[doc(alias = "VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2_KHR")]
    #[cfg(feature = "VK_KHR_create_renderpass2")]
    pub const RENDER_PASS_CREATE_INFO2_KHR: Self = Self::RENDER_PASS_CREATE_INFO2;
    #[doc(alias = "VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO_KHR")]
    #[cfg(feature = "VK_KHR_create_renderpass2")]
    pub const SUBPASS_BEGIN_INFO_KHR: Self = Self::SUBPASS_BEGIN_INFO;
    #[doc(alias = "VK_STRUCTURE_TYPE_SUBPASS_END_INFO_KHR")]
    #[cfg(feature = "VK_KHR_create_renderpass2")]
    pub const SUBPASS_END_INFO_KHR: Self = Self::SUBPASS_END_INFO;
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO_KHR")]
    #[cfg(feature = "VK_KHR_external_fence_capabilities")]
    pub const PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO_KHR: Self = Self::PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO;
    #[doc(alias = "VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES_KHR")]
    #[cfg(feature = "VK_KHR_external_fence_capabilities")]
    pub const EXTERNAL_FENCE_PROPERTIES_KHR: Self = Self::EXTERNAL_FENCE_PROPERTIES;
    #[doc(alias = "VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO_KHR")]
    #[cfg(feature = "VK_KHR_external_fence")]
    pub const EXPORT_FENCE_CREATE_INFO_KHR: Self = Self::EXPORT_FENCE_CREATE_INFO;
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES_KHR")]
    #[cfg(feature = "VK_KHR_maintenance2")]
    pub const PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES_KHR: Self = Self::PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES;
    #[doc(alias = "VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO_KHR")]
    #[cfg(feature = "VK_KHR_maintenance2")]
    pub const RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO_KHR: Self =
        Self::RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO;
    #[doc(alias = "VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO_KHR")]
    #[cfg(feature = "VK_KHR_maintenance2")]
    pub const IMAGE_VIEW_USAGE_CREATE_INFO_KHR: Self = Self::IMAGE_VIEW_USAGE_CREATE_INFO;
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO_KHR")]
    #[cfg(feature = "VK_KHR_maintenance2")]
    pub const PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO_KHR: Self =
        Self::PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO;
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES_KHR")]
    #[cfg(feature = "VK_KHR_variable_pointers")]
    pub const PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES_KHR: Self = Self::PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES;
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES_KHR")]
    #[cfg(feature = "VK_KHR_variable_pointers")]
    pub const PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES_KHR: Self =
        Self::PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES_KHR;
    #[doc(alias = "VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS_KHR")]
    #[cfg(feature = "VK_KHR_dedicated_allocation")]
    pub const MEMORY_DEDICATED_REQUIREMENTS_KHR: Self = Self::MEMORY_DEDICATED_REQUIREMENTS;
    #[doc(alias = "VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_KHR")]
    #[cfg(feature = "VK_KHR_dedicated_allocation")]
    pub const MEMORY_DEDICATED_ALLOCATE_INFO_KHR: Self = Self::MEMORY_DEDICATED_ALLOCATE_INFO;
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT")]
    #[cfg(feature = "VK_EXT_sampler_filter_minmax")]
    pub const PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT: Self =
        Self::PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES;
    #[doc(alias = "VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT")]
    #[cfg(feature = "VK_EXT_sampler_filter_minmax")]
    pub const SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT: Self = Self::SAMPLER_REDUCTION_MODE_CREATE_INFO;
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT")]
    #[cfg(feature = "VK_EXT_inline_uniform_block")]
    pub const PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT: Self =
        Self::PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES;
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES_EXT")]
    #[cfg(feature = "VK_EXT_inline_uniform_block")]
    pub const PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES_EXT: Self =
        Self::PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES;
    #[doc(alias = "VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT")]
    #[cfg(feature = "VK_EXT_inline_uniform_block")]
    pub const WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT: Self = Self::WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK;
    #[doc(alias = "VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO_EXT")]
    #[cfg(feature = "VK_EXT_inline_uniform_block")]
    pub const DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO_EXT: Self =
        Self::DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO;
    #[doc(alias = "VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2_KHR")]
    #[cfg(feature = "VK_KHR_get_memory_requirements2")]
    pub const BUFFER_MEMORY_REQUIREMENTS_INFO2_KHR: Self = Self::BUFFER_MEMORY_REQUIREMENTS_INFO2;
    #[doc(alias = "VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2_KHR")]
    #[cfg(feature = "VK_KHR_get_memory_requirements2")]
    pub const IMAGE_MEMORY_REQUIREMENTS_INFO2_KHR: Self = Self::IMAGE_MEMORY_REQUIREMENTS_INFO2;
    #[doc(alias = "VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2_KHR")]
    #[cfg(feature = "VK_KHR_get_memory_requirements2")]
    pub const IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO2_KHR: Self = Self::IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO2;
    #[doc(alias = "VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2_KHR")]
    #[cfg(feature = "VK_KHR_get_memory_requirements2")]
    pub const MEMORY_REQUIREMENTS2_KHR: Self = Self::MEMORY_REQUIREMENTS2;
    #[doc(alias = "VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2_KHR")]
    #[cfg(feature = "VK_KHR_get_memory_requirements2")]
    pub const SPARSE_IMAGE_MEMORY_REQUIREMENTS2_KHR: Self = Self::SPARSE_IMAGE_MEMORY_REQUIREMENTS2;
    #[doc(alias = "VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR")]
    #[cfg(feature = "VK_KHR_image_format_list")]
    pub const IMAGE_FORMAT_LIST_CREATE_INFO_KHR: Self = Self::IMAGE_FORMAT_LIST_CREATE_INFO;
    #[doc(alias = "VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO_KHR")]
    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
    pub const SAMPLER_YCBCR_CONVERSION_CREATE_INFO_KHR: Self = Self::SAMPLER_YCBCR_CONVERSION_CREATE_INFO;
    #[doc(alias = "VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO_KHR")]
    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
    pub const SAMPLER_YCBCR_CONVERSION_INFO_KHR: Self = Self::SAMPLER_YCBCR_CONVERSION_INFO;
    #[doc(alias = "VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO_KHR")]
    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
    pub const BIND_IMAGE_PLANE_MEMORY_INFO_KHR: Self = Self::BIND_IMAGE_PLANE_MEMORY_INFO;
    #[doc(alias = "VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO_KHR")]
    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
    pub const IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO_KHR: Self = Self::IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO;
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES_KHR")]
    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
    pub const PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES_KHR: Self =
        Self::PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES;
    #[doc(alias = "VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES_KHR")]
    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
    pub const SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES_KHR: Self =
        Self::SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES;
    #[doc(alias = "VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO_KHR")]
    #[cfg(feature = "VK_KHR_bind_memory2")]
    pub const BIND_BUFFER_MEMORY_INFO_KHR: Self = Self::BIND_BUFFER_MEMORY_INFO;
    #[doc(alias = "VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO_KHR")]
    #[cfg(feature = "VK_KHR_bind_memory2")]
    pub const BIND_IMAGE_MEMORY_INFO_KHR: Self = Self::BIND_IMAGE_MEMORY_INFO;
    #[doc(alias = "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT")]
    #[cfg(feature = "VK_EXT_descriptor_indexing")]
    pub const DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT: Self =
        Self::DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO;
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT")]
    #[cfg(feature = "VK_EXT_descriptor_indexing")]
    pub const PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT: Self =
        Self::PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES;
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT")]
    #[cfg(feature = "VK_EXT_descriptor_indexing")]
    pub const PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT: Self =
        Self::PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES;
    #[doc(alias = "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT")]
    #[cfg(feature = "VK_EXT_descriptor_indexing")]
    pub const DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT: Self =
        Self::DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO;
    #[doc(alias = "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT")]
    #[cfg(feature = "VK_EXT_descriptor_indexing")]
    pub const DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT: Self =
        Self::DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT;
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES_KHR")]
    #[cfg(feature = "VK_KHR_maintenance3")]
    pub const PHYSICAL_DEVICE_MAINTENANCE3_PROPERTIES_KHR: Self = Self::PHYSICAL_DEVICE_MAINTENANCE3_PROPERTIES;
    #[doc(alias = "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT_KHR")]
    #[cfg(feature = "VK_KHR_maintenance3")]
    pub const DESCRIPTOR_SET_LAYOUT_SUPPORT_KHR: Self = Self::DESCRIPTOR_SET_LAYOUT_SUPPORT;
    #[doc(alias = "VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT")]
    #[cfg(feature = "VK_EXT_global_priority")]
    pub const DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT: Self = Self::DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_KHR;
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES_KHR")]
    #[cfg(feature = "VK_KHR_shader_subgroup_extended_types")]
    pub const PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES_KHR: Self =
        Self::PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES;
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR")]
    #[cfg(feature = "VK_KHR_8bit_storage")]
    pub const PHYSICAL_DEVICE8BIT_STORAGE_FEATURES_KHR: Self = Self::PHYSICAL_DEVICE8BIT_STORAGE_FEATURES;
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES_KHR")]
    #[cfg(feature = "VK_KHR_shader_atomic_int64")]
    pub const PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES_KHR: Self =
        Self::PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES;
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO_EXT")]
    #[cfg(feature = "VK_EXT_pipeline_creation_feedback")]
    pub const PIPELINE_CREATION_FEEDBACK_CREATE_INFO_EXT: Self = Self::PIPELINE_CREATION_FEEDBACK_CREATE_INFO;
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES_KHR")]
    #[cfg(feature = "VK_KHR_driver_properties")]
    pub const PHYSICAL_DEVICE_DRIVER_PROPERTIES_KHR: Self = Self::PHYSICAL_DEVICE_DRIVER_PROPERTIES;
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES_KHR")]
    #[cfg(feature = "VK_KHR_shader_float_controls")]
    pub const PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES_KHR: Self = Self::PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES;
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES_KHR")]
    #[cfg(feature = "VK_KHR_depth_stencil_resolve")]
    pub const PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES_KHR: Self =
        Self::PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES;
    #[doc(alias = "VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE_KHR")]
    #[cfg(feature = "VK_KHR_depth_stencil_resolve")]
    pub const SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE_KHR: Self = Self::SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE;
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES_KHR")]
    #[cfg(feature = "VK_KHR_timeline_semaphore")]
    pub const PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES_KHR: Self = Self::PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES;
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES_KHR")]
    #[cfg(feature = "VK_KHR_timeline_semaphore")]
    pub const PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES_KHR: Self =
        Self::PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES;
    #[doc(alias = "VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO_KHR")]
    #[cfg(feature = "VK_KHR_timeline_semaphore")]
    pub const SEMAPHORE_TYPE_CREATE_INFO_KHR: Self = Self::SEMAPHORE_TYPE_CREATE_INFO;
    #[doc(alias = "VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO_KHR")]
    #[cfg(feature = "VK_KHR_timeline_semaphore")]
    pub const TIMELINE_SEMAPHORE_SUBMIT_INFO_KHR: Self = Self::TIMELINE_SEMAPHORE_SUBMIT_INFO;
    #[doc(alias = "VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO_KHR")]
    #[cfg(feature = "VK_KHR_timeline_semaphore")]
    pub const SEMAPHORE_WAIT_INFO_KHR: Self = Self::SEMAPHORE_WAIT_INFO;
    #[doc(alias = "VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO_KHR")]
    #[cfg(feature = "VK_KHR_timeline_semaphore")]
    pub const SEMAPHORE_SIGNAL_INFO_KHR: Self = Self::SEMAPHORE_SIGNAL_INFO;
    #[doc(alias = "VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO_INTEL")]
    #[cfg(feature = "VK_INTEL_performance_query")]
    pub const QUERY_POOL_CREATE_INFO_INTEL: Self = Self::QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL;
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES_KHR")]
    #[cfg(feature = "VK_KHR_vulkan_memory_model")]
    pub const PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES_KHR: Self =
        Self::PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES;
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES_KHR")]
    #[cfg(feature = "VK_KHR_shader_terminate_invocation")]
    pub const PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES_KHR: Self =
        Self::PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES;
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES_EXT")]
    #[cfg(feature = "VK_EXT_scalar_block_layout")]
    pub const PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES_EXT: Self =
        Self::PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES;
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES_EXT")]
    #[cfg(feature = "VK_EXT_subgroup_size_control")]
    pub const PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES_EXT: Self =
        Self::PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES;
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO_EXT")]
    #[cfg(feature = "VK_EXT_subgroup_size_control")]
    pub const PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO_EXT: Self =
        Self::PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO;
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES_EXT")]
    #[cfg(feature = "VK_EXT_subgroup_size_control")]
    pub const PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES_EXT: Self =
        Self::PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES;
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES_KHR")]
    #[cfg(feature = "VK_KHR_separate_depth_stencil_layouts")]
    pub const PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES_KHR: Self =
        Self::PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES;
    #[doc(alias = "VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT_KHR")]
    #[cfg(feature = "VK_KHR_separate_depth_stencil_layouts")]
    pub const ATTACHMENT_REFERENCE_STENCIL_LAYOUT_KHR: Self = Self::ATTACHMENT_REFERENCE_STENCIL_LAYOUT;
    #[doc(alias = "VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT_KHR")]
    #[cfg(feature = "VK_KHR_separate_depth_stencil_layouts")]
    pub const ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT_KHR: Self = Self::ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT;
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_ADDRESS_FEATURES_EXT")]
    #[cfg(feature = "VK_EXT_buffer_device_address")]
    pub const PHYSICAL_DEVICE_BUFFER_ADDRESS_FEATURES_EXT: Self =
        Self::PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT;
    #[doc(alias = "VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_EXT")]
    #[cfg(feature = "VK_EXT_buffer_device_address")]
    pub const BUFFER_DEVICE_ADDRESS_INFO_EXT: Self = Self::BUFFER_DEVICE_ADDRESS_INFO;
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES_EXT")]
    #[cfg(feature = "VK_EXT_tooling_info")]
    pub const PHYSICAL_DEVICE_TOOL_PROPERTIES_EXT: Self = Self::PHYSICAL_DEVICE_TOOL_PROPERTIES;
    #[doc(alias = "VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO_EXT")]
    #[cfg(feature = "VK_EXT_separate_stencil_usage")]
    pub const IMAGE_STENCIL_USAGE_CREATE_INFO_EXT: Self = Self::IMAGE_STENCIL_USAGE_CREATE_INFO;
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES_KHR")]
    #[cfg(feature = "VK_KHR_uniform_buffer_standard_layout")]
    pub const PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES_KHR: Self =
        Self::PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES;
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_KHR")]
    #[cfg(feature = "VK_KHR_buffer_device_address")]
    pub const PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_KHR: Self =
        Self::PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES;
    #[doc(alias = "VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_KHR")]
    #[cfg(feature = "VK_KHR_buffer_device_address")]
    pub const BUFFER_DEVICE_ADDRESS_INFO_KHR: Self = Self::BUFFER_DEVICE_ADDRESS_INFO;
    #[doc(alias = "VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO_KHR")]
    #[cfg(feature = "VK_KHR_buffer_device_address")]
    pub const BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO_KHR: Self = Self::BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO;
    #[doc(alias = "VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO_KHR")]
    #[cfg(feature = "VK_KHR_buffer_device_address")]
    pub const MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO_KHR: Self = Self::MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO;
    #[doc(alias = "VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO_KHR")]
    #[cfg(feature = "VK_KHR_buffer_device_address")]
    pub const DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO_KHR: Self = Self::DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO;
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES_EXT")]
    #[cfg(feature = "VK_EXT_host_query_reset")]
    pub const PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES_EXT: Self = Self::PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES;
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES_EXT")]
    #[cfg(feature = "VK_EXT_shader_demote_to_helper_invocation")]
    pub const PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES_EXT: Self =
        Self::PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES;
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES_KHR")]
    #[cfg(feature = "VK_KHR_shader_integer_dot_product")]
    pub const PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES_KHR: Self =
        Self::PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES;
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES_KHR")]
    #[cfg(feature = "VK_KHR_shader_integer_dot_product")]
    pub const PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES_KHR: Self =
        Self::PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES;
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES_EXT")]
    #[cfg(feature = "VK_EXT_texel_buffer_alignment")]
    pub const PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES_EXT: Self =
        Self::PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES;
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES_EXT")]
    #[cfg(feature = "VK_EXT_private_data")]
    pub const PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES_EXT: Self = Self::PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES;
    #[doc(alias = "VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO_EXT")]
    #[cfg(feature = "VK_EXT_private_data")]
    pub const DEVICE_PRIVATE_DATA_CREATE_INFO_EXT: Self = Self::DEVICE_PRIVATE_DATA_CREATE_INFO;
    #[doc(alias = "VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO_EXT")]
    #[cfg(feature = "VK_EXT_private_data")]
    pub const PRIVATE_DATA_SLOT_CREATE_INFO_EXT: Self = Self::PRIVATE_DATA_SLOT_CREATE_INFO;
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES_EXT")]
    #[cfg(feature = "VK_EXT_pipeline_creation_cache_control")]
    pub const PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES_EXT: Self =
        Self::PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES;
    #[doc(alias = "VK_STRUCTURE_TYPE_MEMORY_BARRIER_2_KHR")]
    #[cfg(feature = "VK_KHR_synchronization2")]
    pub const MEMORY_BARRIER2_KHR: Self = Self::MEMORY_BARRIER2;
    #[doc(alias = "VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2_KHR")]
    #[cfg(feature = "VK_KHR_synchronization2")]
    pub const BUFFER_MEMORY_BARRIER2_KHR: Self = Self::BUFFER_MEMORY_BARRIER2;
    #[doc(alias = "VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2_KHR")]
    #[cfg(feature = "VK_KHR_synchronization2")]
    pub const IMAGE_MEMORY_BARRIER2_KHR: Self = Self::IMAGE_MEMORY_BARRIER2;
    #[doc(alias = "VK_STRUCTURE_TYPE_DEPENDENCY_INFO_KHR")]
    #[cfg(feature = "VK_KHR_synchronization2")]
    pub const DEPENDENCY_INFO_KHR: Self = Self::DEPENDENCY_INFO;
    #[doc(alias = "VK_STRUCTURE_TYPE_SUBMIT_INFO_2_KHR")]
    #[cfg(feature = "VK_KHR_synchronization2")]
    pub const SUBMIT_INFO2_KHR: Self = Self::SUBMIT_INFO2;
    #[doc(alias = "VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO_KHR")]
    #[cfg(feature = "VK_KHR_synchronization2")]
    pub const SEMAPHORE_SUBMIT_INFO_KHR: Self = Self::SEMAPHORE_SUBMIT_INFO;
    #[doc(alias = "VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO_KHR")]
    #[cfg(feature = "VK_KHR_synchronization2")]
    pub const COMMAND_BUFFER_SUBMIT_INFO_KHR: Self = Self::COMMAND_BUFFER_SUBMIT_INFO;
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES_KHR")]
    #[cfg(feature = "VK_KHR_synchronization2")]
    pub const PHYSICAL_DEVICE_SYNCHRONIZATION2_FEATURES_KHR: Self = Self::PHYSICAL_DEVICE_SYNCHRONIZATION2_FEATURES;
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES_KHR")]
    #[cfg(feature = "VK_KHR_zero_initialize_workgroup_memory")]
    pub const PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES_KHR: Self =
        Self::PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES;
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES_EXT")]
    #[cfg(feature = "VK_EXT_image_robustness")]
    pub const PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES_EXT: Self = Self::PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES;
    #[doc(alias = "VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2_KHR")]
    #[cfg(feature = "VK_KHR_copy_commands2")]
    pub const COPY_BUFFER_INFO2_KHR: Self = Self::COPY_BUFFER_INFO2;
    #[doc(alias = "VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2_KHR")]
    #[cfg(feature = "VK_KHR_copy_commands2")]
    pub const COPY_IMAGE_INFO2_KHR: Self = Self::COPY_IMAGE_INFO2;
    #[doc(alias = "VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2_KHR")]
    #[cfg(feature = "VK_KHR_copy_commands2")]
    pub const COPY_BUFFER_TO_IMAGE_INFO2_KHR: Self = Self::COPY_BUFFER_TO_IMAGE_INFO2;
    #[doc(alias = "VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2_KHR")]
    #[cfg(feature = "VK_KHR_copy_commands2")]
    pub const COPY_IMAGE_TO_BUFFER_INFO2_KHR: Self = Self::COPY_IMAGE_TO_BUFFER_INFO2;
    #[doc(alias = "VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2_KHR")]
    #[cfg(feature = "VK_KHR_copy_commands2")]
    pub const BLIT_IMAGE_INFO2_KHR: Self = Self::BLIT_IMAGE_INFO2;
    #[doc(alias = "VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2_KHR")]
    #[cfg(feature = "VK_KHR_copy_commands2")]
    pub const RESOLVE_IMAGE_INFO2_KHR: Self = Self::RESOLVE_IMAGE_INFO2;
    #[doc(alias = "VK_STRUCTURE_TYPE_BUFFER_COPY_2_KHR")]
    #[cfg(feature = "VK_KHR_copy_commands2")]
    pub const BUFFER_COPY2_KHR: Self = Self::BUFFER_COPY2;
    #[doc(alias = "VK_STRUCTURE_TYPE_IMAGE_COPY_2_KHR")]
    #[cfg(feature = "VK_KHR_copy_commands2")]
    pub const IMAGE_COPY2_KHR: Self = Self::IMAGE_COPY2;
    #[doc(alias = "VK_STRUCTURE_TYPE_IMAGE_BLIT_2_KHR")]
    #[cfg(feature = "VK_KHR_copy_commands2")]
    pub const IMAGE_BLIT2_KHR: Self = Self::IMAGE_BLIT2;
    #[doc(alias = "VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2_KHR")]
    #[cfg(feature = "VK_KHR_copy_commands2")]
    pub const BUFFER_IMAGE_COPY2_KHR: Self = Self::BUFFER_IMAGE_COPY2;
    #[doc(alias = "VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2_KHR")]
    #[cfg(feature = "VK_KHR_copy_commands2")]
    pub const IMAGE_RESOLVE2_KHR: Self = Self::IMAGE_RESOLVE2;
    #[doc(alias = "VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3_KHR")]
    #[cfg(feature = "VK_KHR_format_feature_flags2")]
    pub const FORMAT_PROPERTIES3_KHR: Self = Self::FORMAT_PROPERTIES3;
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_EXT")]
    #[cfg(feature = "VK_EXT_global_priority_query")]
    pub const PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_EXT: Self =
        Self::PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_KHR;
    #[doc(alias = "VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_EXT")]
    #[cfg(feature = "VK_EXT_global_priority_query")]
    pub const QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_EXT: Self = Self::QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_KHR;
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES_KHR")]
    #[cfg(feature = "VK_KHR_maintenance4")]
    pub const PHYSICAL_DEVICE_MAINTENANCE4_FEATURES_KHR: Self = Self::PHYSICAL_DEVICE_MAINTENANCE4_FEATURES;
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES_KHR")]
    #[cfg(feature = "VK_KHR_maintenance4")]
    pub const PHYSICAL_DEVICE_MAINTENANCE4_PROPERTIES_KHR: Self = Self::PHYSICAL_DEVICE_MAINTENANCE4_PROPERTIES;
    #[doc(alias = "VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS_KHR")]
    #[cfg(feature = "VK_KHR_maintenance4")]
    pub const DEVICE_BUFFER_MEMORY_REQUIREMENTS_KHR: Self = Self::DEVICE_BUFFER_MEMORY_REQUIREMENTS;
    #[doc(alias = "VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS_KHR")]
    #[cfg(feature = "VK_KHR_maintenance4")]
    pub const DEVICE_IMAGE_MEMORY_REQUIREMENTS_KHR: Self = Self::DEVICE_IMAGE_MEMORY_REQUIREMENTS;
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> i32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: i32) -> Option<Self> {
        match bits {
            x if x == Self::APPLICATION_INFO.bits() => Some(Self(x)),
            x if x == Self::INSTANCE_CREATE_INFO.bits() => Some(Self(x)),
            x if x == Self::DEVICE_QUEUE_CREATE_INFO.bits() => Some(Self(x)),
            x if x == Self::DEVICE_CREATE_INFO.bits() => Some(Self(x)),
            x if x == Self::SUBMIT_INFO.bits() => Some(Self(x)),
            x if x == Self::MEMORY_ALLOCATE_INFO.bits() => Some(Self(x)),
            x if x == Self::MAPPED_MEMORY_RANGE.bits() => Some(Self(x)),
            x if x == Self::BIND_SPARSE_INFO.bits() => Some(Self(x)),
            x if x == Self::FENCE_CREATE_INFO.bits() => Some(Self(x)),
            x if x == Self::SEMAPHORE_CREATE_INFO.bits() => Some(Self(x)),
            x if x == Self::EVENT_CREATE_INFO.bits() => Some(Self(x)),
            x if x == Self::QUERY_POOL_CREATE_INFO.bits() => Some(Self(x)),
            x if x == Self::BUFFER_CREATE_INFO.bits() => Some(Self(x)),
            x if x == Self::BUFFER_VIEW_CREATE_INFO.bits() => Some(Self(x)),
            x if x == Self::IMAGE_CREATE_INFO.bits() => Some(Self(x)),
            x if x == Self::IMAGE_VIEW_CREATE_INFO.bits() => Some(Self(x)),
            x if x == Self::SHADER_MODULE_CREATE_INFO.bits() => Some(Self(x)),
            x if x == Self::PIPELINE_CACHE_CREATE_INFO.bits() => Some(Self(x)),
            x if x == Self::PIPELINE_SHADER_STAGE_CREATE_INFO.bits() => Some(Self(x)),
            x if x == Self::PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO.bits() => Some(Self(x)),
            x if x == Self::PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO.bits() => Some(Self(x)),
            x if x == Self::PIPELINE_TESSELLATION_STATE_CREATE_INFO.bits() => Some(Self(x)),
            x if x == Self::PIPELINE_VIEWPORT_STATE_CREATE_INFO.bits() => Some(Self(x)),
            x if x == Self::PIPELINE_RASTERIZATION_STATE_CREATE_INFO.bits() => Some(Self(x)),
            x if x == Self::PIPELINE_MULTISAMPLE_STATE_CREATE_INFO.bits() => Some(Self(x)),
            x if x == Self::PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO.bits() => Some(Self(x)),
            x if x == Self::PIPELINE_COLOR_BLEND_STATE_CREATE_INFO.bits() => Some(Self(x)),
            x if x == Self::PIPELINE_DYNAMIC_STATE_CREATE_INFO.bits() => Some(Self(x)),
            x if x == Self::GRAPHICS_PIPELINE_CREATE_INFO.bits() => Some(Self(x)),
            x if x == Self::COMPUTE_PIPELINE_CREATE_INFO.bits() => Some(Self(x)),
            x if x == Self::PIPELINE_LAYOUT_CREATE_INFO.bits() => Some(Self(x)),
            x if x == Self::SAMPLER_CREATE_INFO.bits() => Some(Self(x)),
            x if x == Self::DESCRIPTOR_SET_LAYOUT_CREATE_INFO.bits() => Some(Self(x)),
            x if x == Self::DESCRIPTOR_POOL_CREATE_INFO.bits() => Some(Self(x)),
            x if x == Self::DESCRIPTOR_SET_ALLOCATE_INFO.bits() => Some(Self(x)),
            x if x == Self::WRITE_DESCRIPTOR_SET.bits() => Some(Self(x)),
            x if x == Self::COPY_DESCRIPTOR_SET.bits() => Some(Self(x)),
            x if x == Self::FRAMEBUFFER_CREATE_INFO.bits() => Some(Self(x)),
            x if x == Self::RENDER_PASS_CREATE_INFO.bits() => Some(Self(x)),
            x if x == Self::COMMAND_POOL_CREATE_INFO.bits() => Some(Self(x)),
            x if x == Self::COMMAND_BUFFER_ALLOCATE_INFO.bits() => Some(Self(x)),
            x if x == Self::COMMAND_BUFFER_INHERITANCE_INFO.bits() => Some(Self(x)),
            x if x == Self::COMMAND_BUFFER_BEGIN_INFO.bits() => Some(Self(x)),
            x if x == Self::RENDER_PASS_BEGIN_INFO.bits() => Some(Self(x)),
            x if x == Self::BUFFER_MEMORY_BARRIER.bits() => Some(Self(x)),
            x if x == Self::IMAGE_MEMORY_BARRIER.bits() => Some(Self(x)),
            x if x == Self::MEMORY_BARRIER.bits() => Some(Self(x)),
            x if x == Self::LOADER_INSTANCE_CREATE_INFO.bits() => Some(Self(x)),
            x if x == Self::LOADER_DEVICE_CREATE_INFO.bits() => Some(Self(x)),
            x if x == Self::PHYSICAL_DEVICE_SUBGROUP_PROPERTIES.bits() => Some(Self(x)),
            x if x == Self::BIND_BUFFER_MEMORY_INFO.bits() => Some(Self(x)),
            x if x == Self::BIND_IMAGE_MEMORY_INFO.bits() => Some(Self(x)),
            x if x == Self::PHYSICAL_DEVICE16BIT_STORAGE_FEATURES.bits() => Some(Self(x)),
            x if x == Self::MEMORY_DEDICATED_REQUIREMENTS.bits() => Some(Self(x)),
            x if x == Self::MEMORY_DEDICATED_ALLOCATE_INFO.bits() => Some(Self(x)),
            x if x == Self::MEMORY_ALLOCATE_FLAGS_INFO.bits() => Some(Self(x)),
            x if x == Self::DEVICE_GROUP_RENDER_PASS_BEGIN_INFO.bits() => Some(Self(x)),
            x if x == Self::DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO.bits() => Some(Self(x)),
            x if x == Self::DEVICE_GROUP_SUBMIT_INFO.bits() => Some(Self(x)),
            x if x == Self::DEVICE_GROUP_BIND_SPARSE_INFO.bits() => Some(Self(x)),
            x if x == Self::BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO.bits() => Some(Self(x)),
            x if x == Self::BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO.bits() => Some(Self(x)),
            x if x == Self::PHYSICAL_DEVICE_GROUP_PROPERTIES.bits() => Some(Self(x)),
            x if x == Self::DEVICE_GROUP_DEVICE_CREATE_INFO.bits() => Some(Self(x)),
            x if x == Self::BUFFER_MEMORY_REQUIREMENTS_INFO2.bits() => Some(Self(x)),
            x if x == Self::IMAGE_MEMORY_REQUIREMENTS_INFO2.bits() => Some(Self(x)),
            x if x == Self::IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO2.bits() => Some(Self(x)),
            x if x == Self::MEMORY_REQUIREMENTS2.bits() => Some(Self(x)),
            x if x == Self::SPARSE_IMAGE_MEMORY_REQUIREMENTS2.bits() => Some(Self(x)),
            x if x == Self::PHYSICAL_DEVICE_FEATURES2.bits() => Some(Self(x)),
            x if x == Self::PHYSICAL_DEVICE_PROPERTIES2.bits() => Some(Self(x)),
            x if x == Self::FORMAT_PROPERTIES2.bits() => Some(Self(x)),
            x if x == Self::IMAGE_FORMAT_PROPERTIES2.bits() => Some(Self(x)),
            x if x == Self::PHYSICAL_DEVICE_IMAGE_FORMAT_INFO2.bits() => Some(Self(x)),
            x if x == Self::QUEUE_FAMILY_PROPERTIES2.bits() => Some(Self(x)),
            x if x == Self::PHYSICAL_DEVICE_MEMORY_PROPERTIES2.bits() => Some(Self(x)),
            x if x == Self::SPARSE_IMAGE_FORMAT_PROPERTIES2.bits() => Some(Self(x)),
            x if x == Self::PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO2.bits() => Some(Self(x)),
            x if x == Self::PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES.bits() => Some(Self(x)),
            x if x == Self::RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO.bits() => Some(Self(x)),
            x if x == Self::IMAGE_VIEW_USAGE_CREATE_INFO.bits() => Some(Self(x)),
            x if x == Self::PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO.bits() => Some(Self(x)),
            x if x == Self::RENDER_PASS_MULTIVIEW_CREATE_INFO.bits() => Some(Self(x)),
            x if x == Self::PHYSICAL_DEVICE_MULTIVIEW_FEATURES.bits() => Some(Self(x)),
            x if x == Self::PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES.bits() => Some(Self(x)),
            x if x == Self::PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES.bits() => Some(Self(x)),
            x if x == Self::PROTECTED_SUBMIT_INFO.bits() => Some(Self(x)),
            x if x == Self::PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES.bits() => Some(Self(x)),
            x if x == Self::PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES.bits() => Some(Self(x)),
            x if x == Self::DEVICE_QUEUE_INFO2.bits() => Some(Self(x)),
            x if x == Self::SAMPLER_YCBCR_CONVERSION_CREATE_INFO.bits() => Some(Self(x)),
            x if x == Self::SAMPLER_YCBCR_CONVERSION_INFO.bits() => Some(Self(x)),
            x if x == Self::BIND_IMAGE_PLANE_MEMORY_INFO.bits() => Some(Self(x)),
            x if x == Self::IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO.bits() => Some(Self(x)),
            x if x == Self::PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES.bits() => Some(Self(x)),
            x if x == Self::SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES.bits() => Some(Self(x)),
            x if x == Self::DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO.bits() => Some(Self(x)),
            x if x == Self::PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO.bits() => Some(Self(x)),
            x if x == Self::EXTERNAL_IMAGE_FORMAT_PROPERTIES.bits() => Some(Self(x)),
            x if x == Self::PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO.bits() => Some(Self(x)),
            x if x == Self::EXTERNAL_BUFFER_PROPERTIES.bits() => Some(Self(x)),
            x if x == Self::PHYSICAL_DEVICE_ID_PROPERTIES.bits() => Some(Self(x)),
            x if x == Self::EXTERNAL_MEMORY_BUFFER_CREATE_INFO.bits() => Some(Self(x)),
            x if x == Self::EXTERNAL_MEMORY_IMAGE_CREATE_INFO.bits() => Some(Self(x)),
            x if x == Self::EXPORT_MEMORY_ALLOCATE_INFO.bits() => Some(Self(x)),
            x if x == Self::PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO.bits() => Some(Self(x)),
            x if x == Self::EXTERNAL_FENCE_PROPERTIES.bits() => Some(Self(x)),
            x if x == Self::EXPORT_FENCE_CREATE_INFO.bits() => Some(Self(x)),
            x if x == Self::EXPORT_SEMAPHORE_CREATE_INFO.bits() => Some(Self(x)),
            x if x == Self::PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO.bits() => Some(Self(x)),
            x if x == Self::EXTERNAL_SEMAPHORE_PROPERTIES.bits() => Some(Self(x)),
            x if x == Self::PHYSICAL_DEVICE_MAINTENANCE3_PROPERTIES.bits() => Some(Self(x)),
            x if x == Self::DESCRIPTOR_SET_LAYOUT_SUPPORT.bits() => Some(Self(x)),
            x if x == Self::PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::PHYSICAL_DEVICE_VULKAN1_1_FEATURES.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::PHYSICAL_DEVICE_VULKAN1_1_PROPERTIES.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::PHYSICAL_DEVICE_VULKAN1_2_FEATURES.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::PHYSICAL_DEVICE_VULKAN1_2_PROPERTIES.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::IMAGE_FORMAT_LIST_CREATE_INFO.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::ATTACHMENT_DESCRIPTION2.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::ATTACHMENT_REFERENCE2.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::SUBPASS_DESCRIPTION2.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::SUBPASS_DEPENDENCY2.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::RENDER_PASS_CREATE_INFO2.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::SUBPASS_BEGIN_INFO.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::SUBPASS_END_INFO.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::PHYSICAL_DEVICE8BIT_STORAGE_FEATURES.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::PHYSICAL_DEVICE_DRIVER_PROPERTIES.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::IMAGE_STENCIL_USAGE_CREATE_INFO.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::SAMPLER_REDUCTION_MODE_CREATE_INFO.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::FRAMEBUFFER_ATTACHMENTS_CREATE_INFO.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::FRAMEBUFFER_ATTACHMENT_IMAGE_INFO.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::RENDER_PASS_ATTACHMENT_BEGIN_INFO.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::ATTACHMENT_REFERENCE_STENCIL_LAYOUT.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::SEMAPHORE_TYPE_CREATE_INFO.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::TIMELINE_SEMAPHORE_SUBMIT_INFO.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::SEMAPHORE_WAIT_INFO.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::SEMAPHORE_SIGNAL_INFO.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::BUFFER_DEVICE_ADDRESS_INFO.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::PHYSICAL_DEVICE_VULKAN1_3_FEATURES.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::PHYSICAL_DEVICE_VULKAN1_3_PROPERTIES.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::PIPELINE_CREATION_FEEDBACK_CREATE_INFO.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::PHYSICAL_DEVICE_TOOL_PROPERTIES.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::DEVICE_PRIVATE_DATA_CREATE_INFO.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::PRIVATE_DATA_SLOT_CREATE_INFO.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::MEMORY_BARRIER2.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::BUFFER_MEMORY_BARRIER2.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::IMAGE_MEMORY_BARRIER2.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::DEPENDENCY_INFO.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::SUBMIT_INFO2.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::SEMAPHORE_SUBMIT_INFO.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::COMMAND_BUFFER_SUBMIT_INFO.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::PHYSICAL_DEVICE_SYNCHRONIZATION2_FEATURES.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::COPY_BUFFER_INFO2.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::COPY_IMAGE_INFO2.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::COPY_BUFFER_TO_IMAGE_INFO2.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::COPY_IMAGE_TO_BUFFER_INFO2.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::BLIT_IMAGE_INFO2.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::RESOLVE_IMAGE_INFO2.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::BUFFER_COPY2.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::IMAGE_COPY2.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::IMAGE_BLIT2.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::BUFFER_IMAGE_COPY2.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::IMAGE_RESOLVE2.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::RENDERING_INFO.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::RENDERING_ATTACHMENT_INFO.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::PIPELINE_RENDERING_CREATE_INFO.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::COMMAND_BUFFER_INHERITANCE_RENDERING_INFO.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::FORMAT_PROPERTIES3.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::PHYSICAL_DEVICE_MAINTENANCE4_FEATURES.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::PHYSICAL_DEVICE_MAINTENANCE4_PROPERTIES.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::DEVICE_BUFFER_MEMORY_REQUIREMENTS.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::DEVICE_IMAGE_MEMORY_REQUIREMENTS.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_swapchain")]
            x if x == Self::SWAPCHAIN_CREATE_INFO_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_swapchain")]
            x if x == Self::PRESENT_INFO_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_device_group")]
            x if x == Self::DEVICE_GROUP_PRESENT_CAPABILITIES_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_device_group")]
            x if x == Self::IMAGE_SWAPCHAIN_CREATE_INFO_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_device_group")]
            x if x == Self::BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_device_group")]
            x if x == Self::ACQUIRE_NEXT_IMAGE_INFO_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_device_group")]
            x if x == Self::DEVICE_GROUP_PRESENT_INFO_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_device_group")]
            x if x == Self::DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_display")]
            x if x == Self::DISPLAY_MODE_CREATE_INFO_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_display")]
            x if x == Self::DISPLAY_SURFACE_CREATE_INFO_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_display_swapchain")]
            x if x == Self::DISPLAY_PRESENT_INFO_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_xlib_surface")]
            x if x == Self::XLIB_SURFACE_CREATE_INFO_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_xcb_surface")]
            x if x == Self::XCB_SURFACE_CREATE_INFO_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_wayland_surface")]
            x if x == Self::WAYLAND_SURFACE_CREATE_INFO_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_android_surface")]
            x if x == Self::ANDROID_SURFACE_CREATE_INFO_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_win32_surface")]
            x if x == Self::WIN32_SURFACE_CREATE_INFO_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_ANDROID_native_buffer")]
            x if x == Self::NATIVE_BUFFER_ANDROID.bits() => Some(Self(x)),
            #[cfg(feature = "VK_ANDROID_native_buffer")]
            x if x == Self::SWAPCHAIN_IMAGE_CREATE_INFO_ANDROID.bits() => Some(Self(x)),
            #[cfg(feature = "VK_ANDROID_native_buffer")]
            x if x == Self::PHYSICAL_DEVICE_PRESENTATION_PROPERTIES_ANDROID.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_debug_report")]
            x if x == Self::DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_AMD_rasterization_order")]
            x if x == Self::PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_debug_marker")]
            x if x == Self::DEBUG_MARKER_OBJECT_NAME_INFO_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_debug_marker")]
            x if x == Self::DEBUG_MARKER_OBJECT_TAG_INFO_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_debug_marker")]
            x if x == Self::DEBUG_MARKER_MARKER_INFO_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_video_queue")]
            x if x == Self::VIDEO_PROFILE_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_video_queue")]
            x if x == Self::VIDEO_CAPABILITIES_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_video_queue")]
            x if x == Self::VIDEO_PICTURE_RESOURCE_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_video_queue")]
            x if x == Self::VIDEO_GET_MEMORY_PROPERTIES_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_video_queue")]
            x if x == Self::VIDEO_BIND_MEMORY_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_video_queue")]
            x if x == Self::VIDEO_SESSION_CREATE_INFO_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_video_queue")]
            x if x == Self::VIDEO_SESSION_PARAMETERS_CREATE_INFO_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_video_queue")]
            x if x == Self::VIDEO_SESSION_PARAMETERS_UPDATE_INFO_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_video_queue")]
            x if x == Self::VIDEO_BEGIN_CODING_INFO_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_video_queue")]
            x if x == Self::VIDEO_END_CODING_INFO_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_video_queue")]
            x if x == Self::VIDEO_CODING_CONTROL_INFO_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_video_queue")]
            x if x == Self::VIDEO_REFERENCE_SLOT_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_video_queue")]
            x if x == Self::VIDEO_QUEUE_FAMILY_PROPERTIES2_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_video_queue")]
            x if x == Self::VIDEO_PROFILES_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_video_queue")]
            x if x == Self::PHYSICAL_DEVICE_VIDEO_FORMAT_INFO_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_video_queue")]
            x if x == Self::VIDEO_FORMAT_PROPERTIES_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_video_queue")]
            x if x == Self::QUEUE_FAMILY_QUERY_RESULT_STATUS_PROPERTIES2_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_video_decode_queue")]
            x if x == Self::VIDEO_DECODE_INFO_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_video_decode_queue")]
            x if x == Self::VIDEO_DECODE_CAPABILITIES_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_dedicated_allocation")]
            x if x == Self::DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_dedicated_allocation")]
            x if x == Self::DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_dedicated_allocation")]
            x if x == Self::DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_transform_feedback")]
            x if x == Self::PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_transform_feedback")]
            x if x == Self::PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_transform_feedback")]
            x if x == Self::PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NVX_binary_import")]
            x if x == Self::CU_MODULE_CREATE_INFO_NVX.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NVX_binary_import")]
            x if x == Self::CU_FUNCTION_CREATE_INFO_NVX.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NVX_binary_import")]
            x if x == Self::CU_LAUNCH_INFO_NVX.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NVX_image_view_handle")]
            x if x == Self::IMAGE_VIEW_HANDLE_INFO_NVX.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NVX_image_view_handle")]
            x if x == Self::IMAGE_VIEW_ADDRESS_PROPERTIES_NVX.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_video_encode_h264")]
            x if x == Self::VIDEO_ENCODE_H264_CAPABILITIES_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_video_encode_h264")]
            x if x == Self::VIDEO_ENCODE_H264_SESSION_PARAMETERS_CREATE_INFO_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_video_encode_h264")]
            x if x == Self::VIDEO_ENCODE_H264_SESSION_PARAMETERS_ADD_INFO_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_video_encode_h264")]
            x if x == Self::VIDEO_ENCODE_H264_VCL_FRAME_INFO_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_video_encode_h264")]
            x if x == Self::VIDEO_ENCODE_H264_DPB_SLOT_INFO_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_video_encode_h264")]
            x if x == Self::VIDEO_ENCODE_H264_NALU_SLICE_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_video_encode_h264")]
            x if x == Self::VIDEO_ENCODE_H264_EMIT_PICTURE_PARAMETERS_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_video_encode_h264")]
            x if x == Self::VIDEO_ENCODE_H264_PROFILE_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_video_encode_h264")]
            x if x == Self::VIDEO_ENCODE_H264_RATE_CONTROL_INFO_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_video_encode_h264")]
            x if x == Self::VIDEO_ENCODE_H264_RATE_CONTROL_LAYER_INFO_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_video_encode_h264")]
            x if x == Self::VIDEO_ENCODE_H264_REFERENCE_LISTS_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_video_encode_h265")]
            x if x == Self::VIDEO_ENCODE_H265_CAPABILITIES_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_video_encode_h265")]
            x if x == Self::VIDEO_ENCODE_H265_SESSION_PARAMETERS_CREATE_INFO_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_video_encode_h265")]
            x if x == Self::VIDEO_ENCODE_H265_SESSION_PARAMETERS_ADD_INFO_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_video_encode_h265")]
            x if x == Self::VIDEO_ENCODE_H265_VCL_FRAME_INFO_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_video_encode_h265")]
            x if x == Self::VIDEO_ENCODE_H265_DPB_SLOT_INFO_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_video_encode_h265")]
            x if x == Self::VIDEO_ENCODE_H265_NALU_SLICE_SEGMENT_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_video_encode_h265")]
            x if x == Self::VIDEO_ENCODE_H265_EMIT_PICTURE_PARAMETERS_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_video_encode_h265")]
            x if x == Self::VIDEO_ENCODE_H265_PROFILE_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_video_encode_h265")]
            x if x == Self::VIDEO_ENCODE_H265_REFERENCE_LISTS_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_video_encode_h265")]
            x if x == Self::VIDEO_ENCODE_H265_RATE_CONTROL_INFO_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_video_encode_h265")]
            x if x == Self::VIDEO_ENCODE_H265_RATE_CONTROL_LAYER_INFO_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_video_decode_h264")]
            x if x == Self::VIDEO_DECODE_H264_CAPABILITIES_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_video_decode_h264")]
            x if x == Self::VIDEO_DECODE_H264_PICTURE_INFO_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_video_decode_h264")]
            x if x == Self::VIDEO_DECODE_H264_MVC_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_video_decode_h264")]
            x if x == Self::VIDEO_DECODE_H264_PROFILE_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_video_decode_h264")]
            x if x == Self::VIDEO_DECODE_H264_SESSION_PARAMETERS_CREATE_INFO_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_video_decode_h264")]
            x if x == Self::VIDEO_DECODE_H264_SESSION_PARAMETERS_ADD_INFO_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_video_decode_h264")]
            x if x == Self::VIDEO_DECODE_H264_DPB_SLOT_INFO_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_AMD_texture_gather_bias_lod")]
            x if x == Self::TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_dynamic_rendering")]
            x if x == Self::RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_dynamic_rendering")]
            x if x == Self::RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_dynamic_rendering")]
            x if x == Self::ATTACHMENT_SAMPLE_COUNT_INFO_AMD.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_dynamic_rendering")]
            x if x == Self::MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX.bits() => Some(Self(x)),
            #[cfg(feature = "VK_GGP_stream_descriptor_surface")]
            x if x == Self::STREAM_DESCRIPTOR_SURFACE_CREATE_INFO_GGP.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_corner_sampled_image")]
            x if x == Self::PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_external_memory")]
            x if x == Self::EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_external_memory")]
            x if x == Self::EXPORT_MEMORY_ALLOCATE_INFO_NV.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_external_memory_win32")]
            x if x == Self::IMPORT_MEMORY_WIN32_HANDLE_INFO_NV.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_external_memory_win32")]
            x if x == Self::EXPORT_MEMORY_WIN32_HANDLE_INFO_NV.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_win32_keyed_mutex")]
            x if x == Self::WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_validation_flags")]
            x if x == Self::VALIDATION_FLAGS_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NN_vi_surface")]
            x if x == Self::VI_SURFACE_CREATE_INFO_NN.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_astc_decode_mode")]
            x if x == Self::IMAGE_VIEW_ASTC_DECODE_MODE_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_astc_decode_mode")]
            x if x == Self::PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_external_memory_win32")]
            x if x == Self::IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_external_memory_win32")]
            x if x == Self::EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_external_memory_win32")]
            x if x == Self::MEMORY_WIN32_HANDLE_PROPERTIES_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_external_memory_win32")]
            x if x == Self::MEMORY_GET_WIN32_HANDLE_INFO_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_external_memory_fd")]
            x if x == Self::IMPORT_MEMORY_FD_INFO_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_external_memory_fd")]
            x if x == Self::MEMORY_FD_PROPERTIES_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_external_memory_fd")]
            x if x == Self::MEMORY_GET_FD_INFO_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_win32_keyed_mutex")]
            x if x == Self::WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_external_semaphore_win32")]
            x if x == Self::IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_external_semaphore_win32")]
            x if x == Self::EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_external_semaphore_win32")]
            x if x == Self::D3D12_FENCE_SUBMIT_INFO_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_external_semaphore_win32")]
            x if x == Self::SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_external_semaphore_fd")]
            x if x == Self::IMPORT_SEMAPHORE_FD_INFO_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_external_semaphore_fd")]
            x if x == Self::SEMAPHORE_GET_FD_INFO_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_push_descriptor")]
            x if x == Self::PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_conditional_rendering")]
            x if x == Self::COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_conditional_rendering")]
            x if x == Self::PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_conditional_rendering")]
            x if x == Self::CONDITIONAL_RENDERING_BEGIN_INFO_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_incremental_present")]
            x if x == Self::PRESENT_REGIONS_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_clip_space_w_scaling")]
            x if x == Self::PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_display_surface_counter")]
            x if x == Self::SURFACE_CAPABILITIES2_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_display_control")]
            x if x == Self::DISPLAY_POWER_INFO_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_display_control")]
            x if x == Self::DEVICE_EVENT_INFO_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_display_control")]
            x if x == Self::DISPLAY_EVENT_INFO_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_display_control")]
            x if x == Self::SWAPCHAIN_COUNTER_CREATE_INFO_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_GOOGLE_display_timing")]
            x if x == Self::PRESENT_TIMES_INFO_GOOGLE.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NVX_multiview_per_view_attributes")]
            x if x == Self::PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_viewport_swizzle")]
            x if x == Self::PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_discard_rectangles")]
            x if x == Self::PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_discard_rectangles")]
            x if x == Self::PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_conservative_rasterization")]
            x if x == Self::PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_conservative_rasterization")]
            x if x == Self::PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_depth_clip_enable")]
            x if x == Self::PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_depth_clip_enable")]
            x if x == Self::PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_hdr_metadata")]
            x if x == Self::HDR_METADATA_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_shared_presentable_image")]
            x if x == Self::SHARED_PRESENT_SURFACE_CAPABILITIES_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_external_fence_win32")]
            x if x == Self::IMPORT_FENCE_WIN32_HANDLE_INFO_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_external_fence_win32")]
            x if x == Self::EXPORT_FENCE_WIN32_HANDLE_INFO_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_external_fence_win32")]
            x if x == Self::FENCE_GET_WIN32_HANDLE_INFO_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_external_fence_fd")]
            x if x == Self::IMPORT_FENCE_FD_INFO_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_external_fence_fd")]
            x if x == Self::FENCE_GET_FD_INFO_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_performance_query")]
            x if x == Self::PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_performance_query")]
            x if x == Self::PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_performance_query")]
            x if x == Self::QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_performance_query")]
            x if x == Self::PERFORMANCE_QUERY_SUBMIT_INFO_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_performance_query")]
            x if x == Self::ACQUIRE_PROFILING_LOCK_INFO_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_performance_query")]
            x if x == Self::PERFORMANCE_COUNTER_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_performance_query")]
            x if x == Self::PERFORMANCE_COUNTER_DESCRIPTION_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_get_surface_capabilities2")]
            x if x == Self::PHYSICAL_DEVICE_SURFACE_INFO2_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_get_surface_capabilities2")]
            x if x == Self::SURFACE_CAPABILITIES2_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_get_surface_capabilities2")]
            x if x == Self::SURFACE_FORMAT2_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_get_display_properties2")]
            x if x == Self::DISPLAY_PROPERTIES2_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_get_display_properties2")]
            x if x == Self::DISPLAY_PLANE_PROPERTIES2_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_get_display_properties2")]
            x if x == Self::DISPLAY_MODE_PROPERTIES2_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_get_display_properties2")]
            x if x == Self::DISPLAY_PLANE_INFO2_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_get_display_properties2")]
            x if x == Self::DISPLAY_PLANE_CAPABILITIES2_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_MVK_ios_surface")]
            x if x == Self::IOS_SURFACE_CREATE_INFO_MVK.bits() => Some(Self(x)),
            #[cfg(feature = "VK_MVK_macos_surface")]
            x if x == Self::MACOS_SURFACE_CREATE_INFO_MVK.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_debug_utils")]
            x if x == Self::DEBUG_UTILS_OBJECT_NAME_INFO_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_debug_utils")]
            x if x == Self::DEBUG_UTILS_OBJECT_TAG_INFO_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_debug_utils")]
            x if x == Self::DEBUG_UTILS_LABEL_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_debug_utils")]
            x if x == Self::DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_debug_utils")]
            x if x == Self::DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_ANDROID_external_memory_android_hardware_buffer")]
            x if x == Self::ANDROID_HARDWARE_BUFFER_USAGE_ANDROID.bits() => Some(Self(x)),
            #[cfg(feature = "VK_ANDROID_external_memory_android_hardware_buffer")]
            x if x == Self::ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID.bits() => Some(Self(x)),
            #[cfg(feature = "VK_ANDROID_external_memory_android_hardware_buffer")]
            x if x == Self::ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID.bits() => Some(Self(x)),
            #[cfg(feature = "VK_ANDROID_external_memory_android_hardware_buffer")]
            x if x == Self::IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID.bits() => Some(Self(x)),
            #[cfg(feature = "VK_ANDROID_external_memory_android_hardware_buffer")]
            x if x == Self::MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID.bits() => Some(Self(x)),
            #[cfg(feature = "VK_ANDROID_external_memory_android_hardware_buffer")]
            x if x == Self::EXTERNAL_FORMAT_ANDROID.bits() => Some(Self(x)),
            #[cfg(feature = "VK_ANDROID_external_memory_android_hardware_buffer")]
            x if x == Self::ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES2_ANDROID.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_sample_locations")]
            x if x == Self::SAMPLE_LOCATIONS_INFO_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_sample_locations")]
            x if x == Self::RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_sample_locations")]
            x if x == Self::PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_sample_locations")]
            x if x == Self::PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_sample_locations")]
            x if x == Self::MULTISAMPLE_PROPERTIES_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_fragment_coverage_to_color")]
            x if x == Self::PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_acceleration_structure")]
            x if x == Self::WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_acceleration_structure")]
            x if x == Self::ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_acceleration_structure")]
            x if x == Self::ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_acceleration_structure")]
            x if x == Self::ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_acceleration_structure")]
            x if x == Self::ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_acceleration_structure")]
            x if x == Self::ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_acceleration_structure")]
            x if x == Self::ACCELERATION_STRUCTURE_GEOMETRY_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_acceleration_structure")]
            x if x == Self::ACCELERATION_STRUCTURE_VERSION_INFO_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_acceleration_structure")]
            x if x == Self::COPY_ACCELERATION_STRUCTURE_INFO_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_acceleration_structure")]
            x if x == Self::COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_acceleration_structure")]
            x if x == Self::COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_acceleration_structure")]
            x if x == Self::PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_acceleration_structure")]
            x if x == Self::PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_acceleration_structure")]
            x if x == Self::ACCELERATION_STRUCTURE_CREATE_INFO_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_acceleration_structure")]
            x if x == Self::ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
            x if x == Self::PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
            x if x == Self::PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
            x if x == Self::RAY_TRACING_PIPELINE_CREATE_INFO_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
            x if x == Self::RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
            x if x == Self::RAY_TRACING_PIPELINE_INTERFACE_CREATE_INFO_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_ray_query")]
            x if x == Self::PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_framebuffer_mixed_samples")]
            x if x == Self::PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_shader_sm_builtins")]
            x if x == Self::PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_shader_sm_builtins")]
            x if x == Self::PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_image_drm_format_modifier")]
            x if x == Self::DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_image_drm_format_modifier")]
            x if x == Self::PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_image_drm_format_modifier")]
            x if x == Self::IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_image_drm_format_modifier")]
            x if x == Self::IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_image_drm_format_modifier")]
            x if x == Self::IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_image_drm_format_modifier")]
            x if x == Self::DRM_FORMAT_MODIFIER_PROPERTIES_LIST2_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_validation_cache")]
            x if x == Self::VALIDATION_CACHE_CREATE_INFO_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_validation_cache")]
            x if x == Self::SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_portability_subset")]
            x if x == Self::PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_portability_subset")]
            x if x == Self::PHYSICAL_DEVICE_PORTABILITY_SUBSET_PROPERTIES_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_shading_rate_image")]
            x if x == Self::PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_shading_rate_image")]
            x if x == Self::PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_shading_rate_image")]
            x if x == Self::PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_shading_rate_image")]
            x if x == Self::PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_ray_tracing")]
            x if x == Self::RAY_TRACING_PIPELINE_CREATE_INFO_NV.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_ray_tracing")]
            x if x == Self::ACCELERATION_STRUCTURE_CREATE_INFO_NV.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_ray_tracing")]
            x if x == Self::GEOMETRY_NV.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_ray_tracing")]
            x if x == Self::GEOMETRY_TRIANGLES_NV.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_ray_tracing")]
            x if x == Self::GEOMETRY_AABB_NV.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_ray_tracing")]
            x if x == Self::BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_ray_tracing")]
            x if x == Self::WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_ray_tracing")]
            x if x == Self::ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_ray_tracing")]
            x if x == Self::PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_ray_tracing")]
            x if x == Self::RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_ray_tracing")]
            x if x == Self::ACCELERATION_STRUCTURE_INFO_NV.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_representative_fragment_test")]
            x if x == Self::PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_representative_fragment_test")]
            x if x == Self::PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_filter_cubic")]
            x if x == Self::PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_filter_cubic")]
            x if x == Self::FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_external_memory_host")]
            x if x == Self::IMPORT_MEMORY_HOST_POINTER_INFO_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_external_memory_host")]
            x if x == Self::MEMORY_HOST_POINTER_PROPERTIES_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_external_memory_host")]
            x if x == Self::PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_shader_clock")]
            x if x == Self::PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_AMD_pipeline_compiler_control")]
            x if x == Self::PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_calibrated_timestamps")]
            x if x == Self::CALIBRATED_TIMESTAMP_INFO_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_AMD_shader_core_properties")]
            x if x == Self::PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_video_decode_h265")]
            x if x == Self::VIDEO_DECODE_H265_CAPABILITIES_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_video_decode_h265")]
            x if x == Self::VIDEO_DECODE_H265_SESSION_PARAMETERS_CREATE_INFO_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_video_decode_h265")]
            x if x == Self::VIDEO_DECODE_H265_SESSION_PARAMETERS_ADD_INFO_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_video_decode_h265")]
            x if x == Self::VIDEO_DECODE_H265_PROFILE_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_video_decode_h265")]
            x if x == Self::VIDEO_DECODE_H265_PICTURE_INFO_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_video_decode_h265")]
            x if x == Self::VIDEO_DECODE_H265_DPB_SLOT_INFO_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_global_priority")]
            x if x == Self::DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_global_priority")]
            x if x == Self::PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_global_priority")]
            x if x == Self::QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_AMD_memory_overallocation_behavior")]
            x if x == Self::DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_vertex_attribute_divisor")]
            x if x == Self::PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_vertex_attribute_divisor")]
            x if x == Self::PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_vertex_attribute_divisor")]
            x if x == Self::PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_GGP_frame_token")]
            x if x == Self::PRESENT_FRAME_TOKEN_GGP.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_compute_shader_derivatives")]
            x if x == Self::PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_mesh_shader")]
            x if x == Self::PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_mesh_shader")]
            x if x == Self::PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_fragment_shader_barycentric")]
            x if x == Self::PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_NV.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_shader_image_footprint")]
            x if x == Self::PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_scissor_exclusive")]
            x if x == Self::PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_scissor_exclusive")]
            x if x == Self::PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_device_diagnostic_checkpoints")]
            x if x == Self::CHECKPOINT_DATA_NV.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_device_diagnostic_checkpoints")]
            x if x == Self::QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV.bits() => Some(Self(x)),
            #[cfg(feature = "VK_INTEL_shader_integer_functions2")]
            x if x == Self::PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS2_FEATURES_INTEL.bits() => Some(Self(x)),
            #[cfg(feature = "VK_INTEL_performance_query")]
            x if x == Self::QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL.bits() => Some(Self(x)),
            #[cfg(feature = "VK_INTEL_performance_query")]
            x if x == Self::INITIALIZE_PERFORMANCE_API_INFO_INTEL.bits() => Some(Self(x)),
            #[cfg(feature = "VK_INTEL_performance_query")]
            x if x == Self::PERFORMANCE_MARKER_INFO_INTEL.bits() => Some(Self(x)),
            #[cfg(feature = "VK_INTEL_performance_query")]
            x if x == Self::PERFORMANCE_STREAM_MARKER_INFO_INTEL.bits() => Some(Self(x)),
            #[cfg(feature = "VK_INTEL_performance_query")]
            x if x == Self::PERFORMANCE_OVERRIDE_INFO_INTEL.bits() => Some(Self(x)),
            #[cfg(feature = "VK_INTEL_performance_query")]
            x if x == Self::PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_pci_bus_info")]
            x if x == Self::PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_AMD_display_native_hdr")]
            x if x == Self::DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD.bits() => Some(Self(x)),
            #[cfg(feature = "VK_AMD_display_native_hdr")]
            x if x == Self::SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD.bits() => Some(Self(x)),
            #[cfg(feature = "VK_FUCHSIA_imagepipe_surface")]
            x if x == Self::IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_metal_surface")]
            x if x == Self::METAL_SURFACE_CREATE_INFO_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_fragment_density_map")]
            x if x == Self::PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_fragment_density_map")]
            x if x == Self::PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_fragment_density_map")]
            x if x == Self::RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_fragment_shading_rate")]
            x if x == Self::FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_fragment_shading_rate")]
            x if x == Self::PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_fragment_shading_rate")]
            x if x == Self::PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_fragment_shading_rate")]
            x if x == Self::PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_fragment_shading_rate")]
            x if x == Self::PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_AMD_shader_core_properties2")]
            x if x == Self::PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES2_AMD.bits() => Some(Self(x)),
            #[cfg(feature = "VK_AMD_device_coherent_memory")]
            x if x == Self::PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_shader_image_atomic_int64")]
            x if x == Self::PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_memory_budget")]
            x if x == Self::PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_memory_priority")]
            x if x == Self::PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_memory_priority")]
            x if x == Self::MEMORY_PRIORITY_ALLOCATE_INFO_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_surface_protected_capabilities")]
            x if x == Self::SURFACE_PROTECTED_CAPABILITIES_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_dedicated_allocation_image_aliasing")]
            x if x == Self::PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_buffer_device_address")]
            x if x == Self::PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_buffer_device_address")]
            x if x == Self::BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_validation_features")]
            x if x == Self::VALIDATION_FEATURES_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_present_wait")]
            x if x == Self::PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_cooperative_matrix")]
            x if x == Self::PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_cooperative_matrix")]
            x if x == Self::COOPERATIVE_MATRIX_PROPERTIES_NV.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_cooperative_matrix")]
            x if x == Self::PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_coverage_reduction_mode")]
            x if x == Self::PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_coverage_reduction_mode")]
            x if x == Self::PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_coverage_reduction_mode")]
            x if x == Self::FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_fragment_shader_interlock")]
            x if x == Self::PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_ycbcr_image_arrays")]
            x if x == Self::PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_provoking_vertex")]
            x if x == Self::PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_provoking_vertex")]
            x if x == Self::PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_provoking_vertex")]
            x if x == Self::PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_full_screen_exclusive")]
            x if x == Self::SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_full_screen_exclusive")]
            x if x == Self::SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_full_screen_exclusive")]
            x if x == Self::SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_headless_surface")]
            x if x == Self::HEADLESS_SURFACE_CREATE_INFO_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_line_rasterization")]
            x if x == Self::PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_line_rasterization")]
            x if x == Self::PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_line_rasterization")]
            x if x == Self::PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_shader_atomic_float")]
            x if x == Self::PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_index_type_uint8")]
            x if x == Self::PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_extended_dynamic_state")]
            x if x == Self::PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_pipeline_executable_properties")]
            x if x == Self::PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_pipeline_executable_properties")]
            x if x == Self::PIPELINE_INFO_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_pipeline_executable_properties")]
            x if x == Self::PIPELINE_EXECUTABLE_PROPERTIES_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_pipeline_executable_properties")]
            x if x == Self::PIPELINE_EXECUTABLE_INFO_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_pipeline_executable_properties")]
            x if x == Self::PIPELINE_EXECUTABLE_STATISTIC_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_pipeline_executable_properties")]
            x if x == Self::PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_shader_atomic_float2")]
            x if x == Self::PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT2_FEATURES_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_device_generated_commands")]
            x if x == Self::PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_device_generated_commands")]
            x if x == Self::GRAPHICS_SHADER_GROUP_CREATE_INFO_NV.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_device_generated_commands")]
            x if x == Self::GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_device_generated_commands")]
            x if x == Self::INDIRECT_COMMANDS_LAYOUT_TOKEN_NV.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_device_generated_commands")]
            x if x == Self::INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NV.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_device_generated_commands")]
            x if x == Self::GENERATED_COMMANDS_INFO_NV.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_device_generated_commands")]
            x if x == Self::GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_NV.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_device_generated_commands")]
            x if x == Self::PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_inherited_viewport_scissor")]
            x if x == Self::PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_inherited_viewport_scissor")]
            x if x == Self::COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_texel_buffer_alignment")]
            x if x == Self::PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_QCOM_render_pass_transform")]
            x if x == Self::COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM.bits() => Some(Self(x)),
            #[cfg(feature = "VK_QCOM_render_pass_transform")]
            x if x == Self::RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_device_memory_report")]
            x if x == Self::PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_device_memory_report")]
            x if x == Self::DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_device_memory_report")]
            x if x == Self::DEVICE_MEMORY_REPORT_CALLBACK_DATA_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_robustness2")]
            x if x == Self::PHYSICAL_DEVICE_ROBUSTNESS2_FEATURES_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_robustness2")]
            x if x == Self::PHYSICAL_DEVICE_ROBUSTNESS2_PROPERTIES_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_custom_border_color")]
            x if x == Self::SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_custom_border_color")]
            x if x == Self::PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_custom_border_color")]
            x if x == Self::PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_pipeline_library")]
            x if x == Self::PIPELINE_LIBRARY_CREATE_INFO_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_present_id")]
            x if x == Self::PRESENT_ID_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_present_id")]
            x if x == Self::PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_video_encode_queue")]
            x if x == Self::VIDEO_ENCODE_INFO_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_video_encode_queue")]
            x if x == Self::VIDEO_ENCODE_RATE_CONTROL_INFO_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_video_encode_queue")]
            x if x == Self::VIDEO_ENCODE_RATE_CONTROL_LAYER_INFO_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_video_encode_queue")]
            x if x == Self::VIDEO_ENCODE_CAPABILITIES_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_device_diagnostics_config")]
            x if x == Self::PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_device_diagnostics_config")]
            x if x == Self::DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV.bits() => Some(Self(x)),
            #[cfg(feature = "VK_QCOM_extension_310")]
            x if x == Self::RESERVED_QCOM.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_synchronization2")]
            x if x == Self::QUEUE_FAMILY_CHECKPOINT_PROPERTIES2_NV.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_synchronization2")]
            x if x == Self::CHECKPOINT_DATA2_NV.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_shader_subgroup_uniform_control_flow")]
            x if x == Self::PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_fragment_shading_rate_enums")]
            x if x == Self::PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_fragment_shading_rate_enums")]
            x if x == Self::PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_fragment_shading_rate_enums")]
            x if x == Self::PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_ray_tracing_motion_blur")]
            x if x == Self::ACCELERATION_STRUCTURE_GEOMETRY_MOTION_TRIANGLES_DATA_NV.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_ray_tracing_motion_blur")]
            x if x == Self::PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_ray_tracing_motion_blur")]
            x if x == Self::ACCELERATION_STRUCTURE_MOTION_INFO_NV.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_ycbcr_2plane_444_formats")]
            x if x == Self::PHYSICAL_DEVICE_YCBCR2_PLANE_444_FORMATS_FEATURES_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_fragment_density_map2")]
            x if x == Self::PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP2_FEATURES_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_fragment_density_map2")]
            x if x == Self::PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP2_PROPERTIES_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_QCOM_rotated_copy_commands")]
            x if x == Self::COPY_COMMAND_TRANSFORM_INFO_QCOM.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_workgroup_memory_explicit_layout")]
            x if x == Self::PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_4444_formats")]
            x if x == Self::PHYSICAL_DEVICE4444_FORMATS_FEATURES_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_ARM_rasterization_order_attachment_access")]
            x if x == Self::PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_ARM.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_rgba10x6_formats")]
            x if x == Self::PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_directfb_surface")]
            x if x == Self::DIRECTFB_SURFACE_CREATE_INFO_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_VALVE_mutable_descriptor_type")]
            x if x == Self::PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_VALVE.bits() => Some(Self(x)),
            #[cfg(feature = "VK_VALVE_mutable_descriptor_type")]
            x if x == Self::MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_VALVE.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_vertex_input_dynamic_state")]
            x if x == Self::PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_vertex_input_dynamic_state")]
            x if x == Self::VERTEX_INPUT_BINDING_DESCRIPTION2_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_vertex_input_dynamic_state")]
            x if x == Self::VERTEX_INPUT_ATTRIBUTE_DESCRIPTION2_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_physical_device_drm")]
            x if x == Self::PHYSICAL_DEVICE_DRM_PROPERTIES_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_depth_clip_control")]
            x if x == Self::PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_depth_clip_control")]
            x if x == Self::PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_primitive_topology_list_restart")]
            x if x == Self::PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_FUCHSIA_external_memory")]
            x if x == Self::IMPORT_MEMORY_ZIRCON_HANDLE_INFO_FUCHSIA.bits() => Some(Self(x)),
            #[cfg(feature = "VK_FUCHSIA_external_memory")]
            x if x == Self::MEMORY_ZIRCON_HANDLE_PROPERTIES_FUCHSIA.bits() => Some(Self(x)),
            #[cfg(feature = "VK_FUCHSIA_external_memory")]
            x if x == Self::MEMORY_GET_ZIRCON_HANDLE_INFO_FUCHSIA.bits() => Some(Self(x)),
            #[cfg(feature = "VK_FUCHSIA_external_semaphore")]
            x if x == Self::IMPORT_SEMAPHORE_ZIRCON_HANDLE_INFO_FUCHSIA.bits() => Some(Self(x)),
            #[cfg(feature = "VK_FUCHSIA_external_semaphore")]
            x if x == Self::SEMAPHORE_GET_ZIRCON_HANDLE_INFO_FUCHSIA.bits() => Some(Self(x)),
            #[cfg(feature = "VK_FUCHSIA_buffer_collection")]
            x if x == Self::BUFFER_COLLECTION_CREATE_INFO_FUCHSIA.bits() => Some(Self(x)),
            #[cfg(feature = "VK_FUCHSIA_buffer_collection")]
            x if x == Self::IMPORT_MEMORY_BUFFER_COLLECTION_FUCHSIA.bits() => Some(Self(x)),
            #[cfg(feature = "VK_FUCHSIA_buffer_collection")]
            x if x == Self::BUFFER_COLLECTION_IMAGE_CREATE_INFO_FUCHSIA.bits() => Some(Self(x)),
            #[cfg(feature = "VK_FUCHSIA_buffer_collection")]
            x if x == Self::BUFFER_COLLECTION_PROPERTIES_FUCHSIA.bits() => Some(Self(x)),
            #[cfg(feature = "VK_FUCHSIA_buffer_collection")]
            x if x == Self::BUFFER_CONSTRAINTS_INFO_FUCHSIA.bits() => Some(Self(x)),
            #[cfg(feature = "VK_FUCHSIA_buffer_collection")]
            x if x == Self::BUFFER_COLLECTION_BUFFER_CREATE_INFO_FUCHSIA.bits() => Some(Self(x)),
            #[cfg(feature = "VK_FUCHSIA_buffer_collection")]
            x if x == Self::IMAGE_CONSTRAINTS_INFO_FUCHSIA.bits() => Some(Self(x)),
            #[cfg(feature = "VK_FUCHSIA_buffer_collection")]
            x if x == Self::IMAGE_FORMAT_CONSTRAINTS_INFO_FUCHSIA.bits() => Some(Self(x)),
            #[cfg(feature = "VK_FUCHSIA_buffer_collection")]
            x if x == Self::SYSMEM_COLOR_SPACE_FUCHSIA.bits() => Some(Self(x)),
            #[cfg(feature = "VK_FUCHSIA_buffer_collection")]
            x if x == Self::BUFFER_COLLECTION_CONSTRAINTS_INFO_FUCHSIA.bits() => Some(Self(x)),
            #[cfg(feature = "VK_HUAWEI_subpass_shading")]
            x if x == Self::SUBPASS_SHADING_PIPELINE_CREATE_INFO_HUAWEI.bits() => Some(Self(x)),
            #[cfg(feature = "VK_HUAWEI_subpass_shading")]
            x if x == Self::PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI.bits() => Some(Self(x)),
            #[cfg(feature = "VK_HUAWEI_subpass_shading")]
            x if x == Self::PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI.bits() => Some(Self(x)),
            #[cfg(feature = "VK_HUAWEI_invocation_mask")]
            x if x == Self::PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_external_memory_rdma")]
            x if x == Self::MEMORY_GET_REMOTE_ADDRESS_INFO_NV.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_external_memory_rdma")]
            x if x == Self::PHYSICAL_DEVICE_EXTERNAL_MEMORY_RDMA_FEATURES_NV.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_extended_dynamic_state2")]
            x if x == Self::PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE2_FEATURES_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_QNX_screen_surface")]
            x if x == Self::SCREEN_SURFACE_CREATE_INFO_QNX.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_color_write_enable")]
            x if x == Self::PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_color_write_enable")]
            x if x == Self::PIPELINE_COLOR_WRITE_CREATE_INFO_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_image_view_min_lod")]
            x if x == Self::PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_image_view_min_lod")]
            x if x == Self::IMAGE_VIEW_MIN_LOD_CREATE_INFO_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_multi_draw")]
            x if x == Self::PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_multi_draw")]
            x if x == Self::PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_border_color_swizzle")]
            x if x == Self::PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_border_color_swizzle")]
            x if x == Self::SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_pageable_device_local_memory")]
            x if x == Self::PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_VALVE_descriptor_set_host_mapping")]
            x if x == Self::PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE.bits() => Some(Self(x)),
            #[cfg(feature = "VK_VALVE_descriptor_set_host_mapping")]
            x if x == Self::DESCRIPTOR_SET_BINDING_REFERENCE_VALVE.bits() => Some(Self(x)),
            #[cfg(feature = "VK_VALVE_descriptor_set_host_mapping")]
            x if x == Self::DESCRIPTOR_SET_LAYOUT_HOST_MAPPING_INFO_VALVE.bits() => Some(Self(x)),
            #[cfg(feature = "VK_QCOM_fragment_density_map_offset")]
            x if x == Self::PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_QCOM.bits() => Some(Self(x)),
            #[cfg(feature = "VK_QCOM_fragment_density_map_offset")]
            x if x == Self::PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_QCOM.bits() => Some(Self(x)),
            #[cfg(feature = "VK_QCOM_fragment_density_map_offset")]
            x if x == Self::SUBPASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_QCOM.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_linear_color_attachment")]
            x if x == Self::PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: i32) -> Self {
        Self(bits)
    }
}
# [doc = include_str ! ("../../../doc/VkSubpassContents.md")]
#[doc(alias = "VkSubpassContents")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct SubpassContents(i32);
impl SubpassContents {
    #[doc(alias = "VK_SUBPASS_CONTENTS_INLINE")]
    pub const INLINE: Self = Self(0);
    #[doc(alias = "VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS")]
    pub const SECONDARY_COMMAND_BUFFERS: Self = Self(1);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> i32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: i32) -> Option<Self> {
        match bits {
            x if x == Self::INLINE.bits() => Some(Self(x)),
            x if x == Self::SECONDARY_COMMAND_BUFFERS.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: i32) -> Self {
        Self(bits)
    }
}
# [doc = include_str ! ("../../../doc/VkResult.md")]
#[doc(alias = "VkResult")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct VulkanResultCodes(i32);
impl VulkanResultCodes {
    #[doc(alias = "VK_SUCCESS")]
    pub const SUCCESS: Self = Self(0);
    #[doc(alias = "VK_NOT_READY")]
    pub const NOT_READY: Self = Self(1);
    #[doc(alias = "VK_TIMEOUT")]
    pub const TIMEOUT: Self = Self(2);
    #[doc(alias = "VK_EVENT_SET")]
    pub const EVENT_SET: Self = Self(3);
    #[doc(alias = "VK_EVENT_RESET")]
    pub const EVENT_RESET: Self = Self(4);
    #[doc(alias = "VK_INCOMPLETE")]
    pub const INCOMPLETE: Self = Self(5);
    #[doc(alias = "VK_ERROR_OUT_OF_HOST_MEMORY")]
    pub const ERROR_OUT_OF_HOST_MEMORY: Self = Self(-1);
    #[doc(alias = "VK_ERROR_OUT_OF_DEVICE_MEMORY")]
    pub const ERROR_OUT_OF_DEVICE_MEMORY: Self = Self(-2);
    #[doc(alias = "VK_ERROR_INITIALIZATION_FAILED")]
    pub const ERROR_INITIALIZATION_FAILED: Self = Self(-3);
    #[doc(alias = "VK_ERROR_DEVICE_LOST")]
    pub const ERROR_DEVICE_LOST: Self = Self(-4);
    #[doc(alias = "VK_ERROR_MEMORY_MAP_FAILED")]
    pub const ERROR_MEMORY_MAP_FAILED: Self = Self(-5);
    #[doc(alias = "VK_ERROR_LAYER_NOT_PRESENT")]
    pub const ERROR_LAYER_NOT_PRESENT: Self = Self(-6);
    #[doc(alias = "VK_ERROR_EXTENSION_NOT_PRESENT")]
    pub const ERROR_EXTENSION_NOT_PRESENT: Self = Self(-7);
    #[doc(alias = "VK_ERROR_FEATURE_NOT_PRESENT")]
    pub const ERROR_FEATURE_NOT_PRESENT: Self = Self(-8);
    #[doc(alias = "VK_ERROR_INCOMPATIBLE_DRIVER")]
    pub const ERROR_INCOMPATIBLE_DRIVER: Self = Self(-9);
    #[doc(alias = "VK_ERROR_TOO_MANY_OBJECTS")]
    pub const ERROR_TOO_MANY_OBJECTS: Self = Self(-10);
    #[doc(alias = "VK_ERROR_FORMAT_NOT_SUPPORTED")]
    pub const ERROR_FORMAT_NOT_SUPPORTED: Self = Self(-11);
    #[doc(alias = "VK_ERROR_FRAGMENTED_POOL")]
    pub const ERROR_FRAGMENTED_POOL: Self = Self(-12);
    #[doc(alias = "VK_ERROR_UNKNOWN")]
    pub const ERROR_UNKNOWN: Self = Self(-13);
    #[doc(alias = "VK_ERROR_OUT_OF_POOL_MEMORY")]
    pub const ERROR_OUT_OF_POOL_MEMORY: Self = Self(-1000069000);
    #[doc(alias = "VK_ERROR_INVALID_EXTERNAL_HANDLE")]
    pub const ERROR_INVALID_EXTERNAL_HANDLE: Self = Self(-1000072003);
    #[doc(alias = "VK_ERROR_FRAGMENTATION")]
    #[cfg(feature = "VULKAN_1_2")]
    pub const ERROR_FRAGMENTATION: Self = Self(-1000161000);
    #[doc(alias = "VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS")]
    #[cfg(feature = "VULKAN_1_2")]
    pub const ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS: Self = Self(-1000257000);
    #[doc(alias = "VK_PIPELINE_COMPILE_REQUIRED")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const PIPELINE_COMPILE_REQUIRED: Self = Self(1000297000);
    #[doc(alias = "VK_ERROR_SURFACE_LOST_KHR")]
    #[cfg(feature = "VK_KHR_surface")]
    pub const ERROR_SURFACE_LOST_KHR: Self = Self(-1000000000);
    #[doc(alias = "VK_ERROR_NATIVE_WINDOW_IN_USE_KHR")]
    #[cfg(feature = "VK_KHR_surface")]
    pub const ERROR_NATIVE_WINDOW_IN_USE_KHR: Self = Self(-1000000001);
    #[doc(alias = "VK_SUBOPTIMAL_KHR")]
    #[cfg(feature = "VK_KHR_swapchain")]
    pub const SUBOPTIMAL_KHR: Self = Self(1000001003);
    #[doc(alias = "VK_ERROR_OUT_OF_DATE_KHR")]
    #[cfg(feature = "VK_KHR_swapchain")]
    pub const ERROR_OUT_OF_DATE_KHR: Self = Self(-1000001004);
    #[doc(alias = "VK_ERROR_INCOMPATIBLE_DISPLAY_KHR")]
    #[cfg(feature = "VK_KHR_display_swapchain")]
    pub const ERROR_INCOMPATIBLE_DISPLAY_KHR: Self = Self(-1000003001);
    #[doc(alias = "VK_ERROR_VALIDATION_FAILED_EXT")]
    #[cfg(feature = "VK_EXT_debug_report")]
    pub const ERROR_VALIDATION_FAILED_EXT: Self = Self(-1000011001);
    #[doc(alias = "VK_ERROR_INVALID_SHADER_NV")]
    #[cfg(feature = "VK_NV_glsl_shader")]
    pub const ERROR_INVALID_SHADER_NV: Self = Self(-1000012000);
    #[doc(alias = "VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT")]
    #[cfg(feature = "VK_EXT_image_drm_format_modifier")]
    pub const ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT: Self = Self(-1000158000);
    #[doc(alias = "VK_ERROR_NOT_PERMITTED_KHR")]
    #[cfg(feature = "VK_KHR_global_priority")]
    pub const ERROR_NOT_PERMITTED_KHR: Self = Self(-1000174001);
    #[doc(alias = "VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT")]
    #[cfg(feature = "VK_EXT_full_screen_exclusive")]
    pub const ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT: Self = Self(-1000255000);
    #[doc(alias = "VK_THREAD_IDLE_KHR")]
    #[cfg(feature = "VK_KHR_deferred_host_operations")]
    pub const THREAD_IDLE_KHR: Self = Self(1000268000);
    #[doc(alias = "VK_THREAD_DONE_KHR")]
    #[cfg(feature = "VK_KHR_deferred_host_operations")]
    pub const THREAD_DONE_KHR: Self = Self(1000268001);
    #[doc(alias = "VK_OPERATION_DEFERRED_KHR")]
    #[cfg(feature = "VK_KHR_deferred_host_operations")]
    pub const OPERATION_DEFERRED_KHR: Self = Self(1000268002);
    #[doc(alias = "VK_OPERATION_NOT_DEFERRED_KHR")]
    #[cfg(feature = "VK_KHR_deferred_host_operations")]
    pub const OPERATION_NOT_DEFERRED_KHR: Self = Self(1000268003);
    #[doc(alias = "VK_ERROR_OUT_OF_POOL_MEMORY_KHR")]
    #[cfg(feature = "VK_KHR_maintenance1")]
    pub const ERROR_OUT_OF_POOL_MEMORY_KHR: Self = Self::ERROR_OUT_OF_POOL_MEMORY;
    #[doc(alias = "VK_ERROR_INVALID_EXTERNAL_HANDLE_KHR")]
    #[cfg(feature = "VK_KHR_external_memory")]
    pub const ERROR_INVALID_EXTERNAL_HANDLE_KHR: Self = Self::ERROR_INVALID_EXTERNAL_HANDLE;
    #[doc(alias = "VK_ERROR_FRAGMENTATION_EXT")]
    #[cfg(feature = "VK_EXT_descriptor_indexing")]
    pub const ERROR_FRAGMENTATION_EXT: Self = Self::ERROR_FRAGMENTATION;
    #[doc(alias = "VK_ERROR_NOT_PERMITTED_EXT")]
    #[cfg(feature = "VK_EXT_global_priority")]
    pub const ERROR_NOT_PERMITTED_EXT: Self = Self::ERROR_NOT_PERMITTED_KHR;
    #[doc(alias = "VK_ERROR_INVALID_DEVICE_ADDRESS_EXT")]
    #[cfg(feature = "VK_EXT_buffer_device_address")]
    pub const ERROR_INVALID_DEVICE_ADDRESS_EXT: Self = Self::ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS;
    #[doc(alias = "VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS_KHR")]
    #[cfg(feature = "VK_KHR_buffer_device_address")]
    pub const ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS_KHR: Self = Self::ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS;
    #[doc(alias = "VK_PIPELINE_COMPILE_REQUIRED_EXT")]
    #[cfg(feature = "VK_EXT_pipeline_creation_cache_control")]
    pub const PIPELINE_COMPILE_REQUIRED_EXT: Self = Self::PIPELINE_COMPILE_REQUIRED;
    #[doc(alias = "VK_ERROR_PIPELINE_COMPILE_REQUIRED_EXT")]
    #[cfg(feature = "VK_EXT_pipeline_creation_cache_control")]
    pub const ERROR_PIPELINE_COMPILE_REQUIRED_EXT: Self = Self::PIPELINE_COMPILE_REQUIRED;
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> i32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: i32) -> Option<Self> {
        match bits {
            x if x == Self::SUCCESS.bits() => Some(Self(x)),
            x if x == Self::NOT_READY.bits() => Some(Self(x)),
            x if x == Self::TIMEOUT.bits() => Some(Self(x)),
            x if x == Self::EVENT_SET.bits() => Some(Self(x)),
            x if x == Self::EVENT_RESET.bits() => Some(Self(x)),
            x if x == Self::INCOMPLETE.bits() => Some(Self(x)),
            x if x == Self::ERROR_OUT_OF_HOST_MEMORY.bits() => Some(Self(x)),
            x if x == Self::ERROR_OUT_OF_DEVICE_MEMORY.bits() => Some(Self(x)),
            x if x == Self::ERROR_INITIALIZATION_FAILED.bits() => Some(Self(x)),
            x if x == Self::ERROR_DEVICE_LOST.bits() => Some(Self(x)),
            x if x == Self::ERROR_MEMORY_MAP_FAILED.bits() => Some(Self(x)),
            x if x == Self::ERROR_LAYER_NOT_PRESENT.bits() => Some(Self(x)),
            x if x == Self::ERROR_EXTENSION_NOT_PRESENT.bits() => Some(Self(x)),
            x if x == Self::ERROR_FEATURE_NOT_PRESENT.bits() => Some(Self(x)),
            x if x == Self::ERROR_INCOMPATIBLE_DRIVER.bits() => Some(Self(x)),
            x if x == Self::ERROR_TOO_MANY_OBJECTS.bits() => Some(Self(x)),
            x if x == Self::ERROR_FORMAT_NOT_SUPPORTED.bits() => Some(Self(x)),
            x if x == Self::ERROR_FRAGMENTED_POOL.bits() => Some(Self(x)),
            x if x == Self::ERROR_UNKNOWN.bits() => Some(Self(x)),
            x if x == Self::ERROR_OUT_OF_POOL_MEMORY.bits() => Some(Self(x)),
            x if x == Self::ERROR_INVALID_EXTERNAL_HANDLE.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::ERROR_FRAGMENTATION.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::PIPELINE_COMPILE_REQUIRED.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_surface")]
            x if x == Self::ERROR_SURFACE_LOST_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_surface")]
            x if x == Self::ERROR_NATIVE_WINDOW_IN_USE_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_swapchain")]
            x if x == Self::SUBOPTIMAL_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_swapchain")]
            x if x == Self::ERROR_OUT_OF_DATE_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_display_swapchain")]
            x if x == Self::ERROR_INCOMPATIBLE_DISPLAY_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_debug_report")]
            x if x == Self::ERROR_VALIDATION_FAILED_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_glsl_shader")]
            x if x == Self::ERROR_INVALID_SHADER_NV.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_image_drm_format_modifier")]
            x if x == Self::ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_global_priority")]
            x if x == Self::ERROR_NOT_PERMITTED_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_full_screen_exclusive")]
            x if x == Self::ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_deferred_host_operations")]
            x if x == Self::THREAD_IDLE_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_deferred_host_operations")]
            x if x == Self::THREAD_DONE_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_deferred_host_operations")]
            x if x == Self::OPERATION_DEFERRED_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_deferred_host_operations")]
            x if x == Self::OPERATION_NOT_DEFERRED_KHR.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: i32) -> Self {
        Self(bits)
    }
}
# [doc = include_str ! ("../../../doc/VkDynamicState.md")]
#[doc(alias = "VkDynamicState")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct DynamicState(i32);
impl DynamicState {
    #[doc(alias = "VK_DYNAMIC_STATE_VIEWPORT")]
    pub const VIEWPORT: Self = Self(0);
    #[doc(alias = "VK_DYNAMIC_STATE_SCISSOR")]
    pub const SCISSOR: Self = Self(1);
    #[doc(alias = "VK_DYNAMIC_STATE_LINE_WIDTH")]
    pub const LINE_WIDTH: Self = Self(2);
    #[doc(alias = "VK_DYNAMIC_STATE_DEPTH_BIAS")]
    pub const DEPTH_BIAS: Self = Self(3);
    #[doc(alias = "VK_DYNAMIC_STATE_BLEND_CONSTANTS")]
    pub const BLEND_CONSTANTS: Self = Self(4);
    #[doc(alias = "VK_DYNAMIC_STATE_DEPTH_BOUNDS")]
    pub const DEPTH_BOUNDS: Self = Self(5);
    #[doc(alias = "VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK")]
    pub const STENCIL_COMPARE_MASK: Self = Self(6);
    #[doc(alias = "VK_DYNAMIC_STATE_STENCIL_WRITE_MASK")]
    pub const STENCIL_WRITE_MASK: Self = Self(7);
    #[doc(alias = "VK_DYNAMIC_STATE_STENCIL_REFERENCE")]
    pub const STENCIL_REFERENCE: Self = Self(8);
    #[doc(alias = "VK_DYNAMIC_STATE_CULL_MODE")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const CULL_MODE: Self = Self(1000267000);
    #[doc(alias = "VK_DYNAMIC_STATE_FRONT_FACE")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const FRONT_FACE: Self = Self(1000267001);
    #[doc(alias = "VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const PRIMITIVE_TOPOLOGY: Self = Self(1000267002);
    #[doc(alias = "VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const VIEWPORT_WITH_COUNT: Self = Self(1000267003);
    #[doc(alias = "VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const SCISSOR_WITH_COUNT: Self = Self(1000267004);
    #[doc(alias = "VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const VERTEX_INPUT_BINDING_STRIDE: Self = Self(1000267005);
    #[doc(alias = "VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const DEPTH_TEST_ENABLE: Self = Self(1000267006);
    #[doc(alias = "VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const DEPTH_WRITE_ENABLE: Self = Self(1000267007);
    #[doc(alias = "VK_DYNAMIC_STATE_DEPTH_COMPARE_OP")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const DEPTH_COMPARE_OP: Self = Self(1000267008);
    #[doc(alias = "VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const DEPTH_BOUNDS_TEST_ENABLE: Self = Self(1000267009);
    #[doc(alias = "VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const STENCIL_TEST_ENABLE: Self = Self(1000267010);
    #[doc(alias = "VK_DYNAMIC_STATE_STENCIL_OP")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const STENCIL_OP: Self = Self(1000267011);
    #[doc(alias = "VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const RASTERIZER_DISCARD_ENABLE: Self = Self(1000377001);
    #[doc(alias = "VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const DEPTH_BIAS_ENABLE: Self = Self(1000377002);
    #[doc(alias = "VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const PRIMITIVE_RESTART_ENABLE: Self = Self(1000377004);
    #[doc(alias = "VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV")]
    #[cfg(feature = "VK_NV_clip_space_w_scaling")]
    pub const VIEWPORT_W_SCALING_NV: Self = Self(1000087000);
    #[doc(alias = "VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT")]
    #[cfg(feature = "VK_EXT_discard_rectangles")]
    pub const DISCARD_RECTANGLE_EXT: Self = Self(1000099000);
    #[doc(alias = "VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT")]
    #[cfg(feature = "VK_EXT_sample_locations")]
    pub const SAMPLE_LOCATIONS_EXT: Self = Self(1000143000);
    #[doc(alias = "VK_DYNAMIC_STATE_RAY_TRACING_PIPELINE_STACK_SIZE_KHR")]
    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
    pub const RAY_TRACING_PIPELINE_STACK_SIZE_KHR: Self = Self(1000347000);
    #[doc(alias = "VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV")]
    #[cfg(feature = "VK_NV_shading_rate_image")]
    pub const VIEWPORT_SHADING_RATE_PALETTE_NV: Self = Self(1000164004);
    #[doc(alias = "VK_DYNAMIC_STATE_VIEWPORT_COARSE_SAMPLE_ORDER_NV")]
    #[cfg(feature = "VK_NV_shading_rate_image")]
    pub const VIEWPORT_COARSE_SAMPLE_ORDER_NV: Self = Self(1000164006);
    #[doc(alias = "VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_NV")]
    #[cfg(feature = "VK_NV_scissor_exclusive")]
    pub const EXCLUSIVE_SCISSOR_NV: Self = Self(1000205001);
    #[doc(alias = "VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR")]
    #[cfg(feature = "VK_KHR_fragment_shading_rate")]
    pub const FRAGMENT_SHADING_RATE_KHR: Self = Self(1000226000);
    #[doc(alias = "VK_DYNAMIC_STATE_LINE_STIPPLE_EXT")]
    #[cfg(feature = "VK_EXT_line_rasterization")]
    pub const LINE_STIPPLE_EXT: Self = Self(1000259000);
    #[doc(alias = "VK_DYNAMIC_STATE_VERTEX_INPUT_EXT")]
    #[cfg(feature = "VK_EXT_vertex_input_dynamic_state")]
    pub const VERTEX_INPUT_EXT: Self = Self(1000352000);
    #[doc(alias = "VK_DYNAMIC_STATE_PATCH_CONTROL_POINTS_EXT")]
    #[cfg(feature = "VK_EXT_extended_dynamic_state2")]
    pub const PATCH_CONTROL_POINTS_EXT: Self = Self(1000377000);
    #[doc(alias = "VK_DYNAMIC_STATE_LOGIC_OP_EXT")]
    #[cfg(feature = "VK_EXT_extended_dynamic_state2")]
    pub const LOGIC_OP_EXT: Self = Self(1000377003);
    #[doc(alias = "VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT")]
    #[cfg(feature = "VK_EXT_color_write_enable")]
    pub const COLOR_WRITE_ENABLE_EXT: Self = Self(1000381000);
    #[doc(alias = "VK_DYNAMIC_STATE_CULL_MODE_EXT")]
    #[cfg(feature = "VK_EXT_extended_dynamic_state")]
    pub const CULL_MODE_EXT: Self = Self::CULL_MODE;
    #[doc(alias = "VK_DYNAMIC_STATE_FRONT_FACE_EXT")]
    #[cfg(feature = "VK_EXT_extended_dynamic_state")]
    pub const FRONT_FACE_EXT: Self = Self::FRONT_FACE;
    #[doc(alias = "VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY_EXT")]
    #[cfg(feature = "VK_EXT_extended_dynamic_state")]
    pub const PRIMITIVE_TOPOLOGY_EXT: Self = Self::PRIMITIVE_TOPOLOGY;
    #[doc(alias = "VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT_EXT")]
    #[cfg(feature = "VK_EXT_extended_dynamic_state")]
    pub const VIEWPORT_WITH_COUNT_EXT: Self = Self::VIEWPORT_WITH_COUNT;
    #[doc(alias = "VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT_EXT")]
    #[cfg(feature = "VK_EXT_extended_dynamic_state")]
    pub const SCISSOR_WITH_COUNT_EXT: Self = Self::SCISSOR_WITH_COUNT;
    #[doc(alias = "VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE_EXT")]
    #[cfg(feature = "VK_EXT_extended_dynamic_state")]
    pub const VERTEX_INPUT_BINDING_STRIDE_EXT: Self = Self::VERTEX_INPUT_BINDING_STRIDE;
    #[doc(alias = "VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE_EXT")]
    #[cfg(feature = "VK_EXT_extended_dynamic_state")]
    pub const DEPTH_TEST_ENABLE_EXT: Self = Self::DEPTH_TEST_ENABLE;
    #[doc(alias = "VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE_EXT")]
    #[cfg(feature = "VK_EXT_extended_dynamic_state")]
    pub const DEPTH_WRITE_ENABLE_EXT: Self = Self::DEPTH_WRITE_ENABLE;
    #[doc(alias = "VK_DYNAMIC_STATE_DEPTH_COMPARE_OP_EXT")]
    #[cfg(feature = "VK_EXT_extended_dynamic_state")]
    pub const DEPTH_COMPARE_OP_EXT: Self = Self::DEPTH_COMPARE_OP;
    #[doc(alias = "VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE_EXT")]
    #[cfg(feature = "VK_EXT_extended_dynamic_state")]
    pub const DEPTH_BOUNDS_TEST_ENABLE_EXT: Self = Self::DEPTH_BOUNDS_TEST_ENABLE;
    #[doc(alias = "VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE_EXT")]
    #[cfg(feature = "VK_EXT_extended_dynamic_state")]
    pub const STENCIL_TEST_ENABLE_EXT: Self = Self::STENCIL_TEST_ENABLE;
    #[doc(alias = "VK_DYNAMIC_STATE_STENCIL_OP_EXT")]
    #[cfg(feature = "VK_EXT_extended_dynamic_state")]
    pub const STENCIL_OP_EXT: Self = Self::STENCIL_OP;
    #[doc(alias = "VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE_EXT")]
    #[cfg(feature = "VK_EXT_extended_dynamic_state2")]
    pub const RASTERIZER_DISCARD_ENABLE_EXT: Self = Self::RASTERIZER_DISCARD_ENABLE;
    #[doc(alias = "VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE_EXT")]
    #[cfg(feature = "VK_EXT_extended_dynamic_state2")]
    pub const DEPTH_BIAS_ENABLE_EXT: Self = Self::DEPTH_BIAS_ENABLE;
    #[doc(alias = "VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE_EXT")]
    #[cfg(feature = "VK_EXT_extended_dynamic_state2")]
    pub const PRIMITIVE_RESTART_ENABLE_EXT: Self = Self::PRIMITIVE_RESTART_ENABLE;
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> i32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: i32) -> Option<Self> {
        match bits {
            x if x == Self::VIEWPORT.bits() => Some(Self(x)),
            x if x == Self::SCISSOR.bits() => Some(Self(x)),
            x if x == Self::LINE_WIDTH.bits() => Some(Self(x)),
            x if x == Self::DEPTH_BIAS.bits() => Some(Self(x)),
            x if x == Self::BLEND_CONSTANTS.bits() => Some(Self(x)),
            x if x == Self::DEPTH_BOUNDS.bits() => Some(Self(x)),
            x if x == Self::STENCIL_COMPARE_MASK.bits() => Some(Self(x)),
            x if x == Self::STENCIL_WRITE_MASK.bits() => Some(Self(x)),
            x if x == Self::STENCIL_REFERENCE.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::CULL_MODE.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::FRONT_FACE.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::PRIMITIVE_TOPOLOGY.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::VIEWPORT_WITH_COUNT.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::SCISSOR_WITH_COUNT.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::VERTEX_INPUT_BINDING_STRIDE.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::DEPTH_TEST_ENABLE.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::DEPTH_WRITE_ENABLE.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::DEPTH_COMPARE_OP.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::DEPTH_BOUNDS_TEST_ENABLE.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::STENCIL_TEST_ENABLE.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::STENCIL_OP.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::RASTERIZER_DISCARD_ENABLE.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::DEPTH_BIAS_ENABLE.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::PRIMITIVE_RESTART_ENABLE.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_clip_space_w_scaling")]
            x if x == Self::VIEWPORT_W_SCALING_NV.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_discard_rectangles")]
            x if x == Self::DISCARD_RECTANGLE_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_sample_locations")]
            x if x == Self::SAMPLE_LOCATIONS_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
            x if x == Self::RAY_TRACING_PIPELINE_STACK_SIZE_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_shading_rate_image")]
            x if x == Self::VIEWPORT_SHADING_RATE_PALETTE_NV.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_shading_rate_image")]
            x if x == Self::VIEWPORT_COARSE_SAMPLE_ORDER_NV.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_scissor_exclusive")]
            x if x == Self::EXCLUSIVE_SCISSOR_NV.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_fragment_shading_rate")]
            x if x == Self::FRAGMENT_SHADING_RATE_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_line_rasterization")]
            x if x == Self::LINE_STIPPLE_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_vertex_input_dynamic_state")]
            x if x == Self::VERTEX_INPUT_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_extended_dynamic_state2")]
            x if x == Self::PATCH_CONTROL_POINTS_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_extended_dynamic_state2")]
            x if x == Self::LOGIC_OP_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_color_write_enable")]
            x if x == Self::COLOR_WRITE_ENABLE_EXT.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: i32) -> Self {
        Self(bits)
    }
}
# [doc = include_str ! ("../../../doc/VkObjectType.md")]
#[doc(alias = "VkObjectType")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct ObjectType(i32);
impl ObjectType {
    #[doc(alias = "VK_OBJECT_TYPE_UNKNOWN")]
    pub const UNKNOWN: Self = Self(0);
    #[doc(alias = "VK_OBJECT_TYPE_INSTANCE")]
    pub const INSTANCE: Self = Self(1);
    #[doc(alias = "VK_OBJECT_TYPE_PHYSICAL_DEVICE")]
    pub const PHYSICAL_DEVICE: Self = Self(2);
    #[doc(alias = "VK_OBJECT_TYPE_DEVICE")]
    pub const DEVICE: Self = Self(3);
    #[doc(alias = "VK_OBJECT_TYPE_QUEUE")]
    pub const QUEUE: Self = Self(4);
    #[doc(alias = "VK_OBJECT_TYPE_SEMAPHORE")]
    pub const SEMAPHORE: Self = Self(5);
    #[doc(alias = "VK_OBJECT_TYPE_COMMAND_BUFFER")]
    pub const COMMAND_BUFFER: Self = Self(6);
    #[doc(alias = "VK_OBJECT_TYPE_FENCE")]
    pub const FENCE: Self = Self(7);
    #[doc(alias = "VK_OBJECT_TYPE_DEVICE_MEMORY")]
    pub const DEVICE_MEMORY: Self = Self(8);
    #[doc(alias = "VK_OBJECT_TYPE_BUFFER")]
    pub const BUFFER: Self = Self(9);
    #[doc(alias = "VK_OBJECT_TYPE_IMAGE")]
    pub const IMAGE: Self = Self(10);
    #[doc(alias = "VK_OBJECT_TYPE_EVENT")]
    pub const EVENT: Self = Self(11);
    #[doc(alias = "VK_OBJECT_TYPE_QUERY_POOL")]
    pub const QUERY_POOL: Self = Self(12);
    #[doc(alias = "VK_OBJECT_TYPE_BUFFER_VIEW")]
    pub const BUFFER_VIEW: Self = Self(13);
    #[doc(alias = "VK_OBJECT_TYPE_IMAGE_VIEW")]
    pub const IMAGE_VIEW: Self = Self(14);
    #[doc(alias = "VK_OBJECT_TYPE_SHADER_MODULE")]
    pub const SHADER_MODULE: Self = Self(15);
    #[doc(alias = "VK_OBJECT_TYPE_PIPELINE_CACHE")]
    pub const PIPELINE_CACHE: Self = Self(16);
    #[doc(alias = "VK_OBJECT_TYPE_PIPELINE_LAYOUT")]
    pub const PIPELINE_LAYOUT: Self = Self(17);
    #[doc(alias = "VK_OBJECT_TYPE_RENDER_PASS")]
    pub const RENDER_PASS: Self = Self(18);
    #[doc(alias = "VK_OBJECT_TYPE_PIPELINE")]
    pub const PIPELINE: Self = Self(19);
    #[doc(alias = "VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT")]
    pub const DESCRIPTOR_SET_LAYOUT: Self = Self(20);
    #[doc(alias = "VK_OBJECT_TYPE_SAMPLER")]
    pub const SAMPLER: Self = Self(21);
    #[doc(alias = "VK_OBJECT_TYPE_DESCRIPTOR_POOL")]
    pub const DESCRIPTOR_POOL: Self = Self(22);
    #[doc(alias = "VK_OBJECT_TYPE_DESCRIPTOR_SET")]
    pub const DESCRIPTOR_SET: Self = Self(23);
    #[doc(alias = "VK_OBJECT_TYPE_FRAMEBUFFER")]
    pub const FRAMEBUFFER: Self = Self(24);
    #[doc(alias = "VK_OBJECT_TYPE_COMMAND_POOL")]
    pub const COMMAND_POOL: Self = Self(25);
    #[doc(alias = "VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION")]
    pub const SAMPLER_YCBCR_CONVERSION: Self = Self(1000156000);
    #[doc(alias = "VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE")]
    pub const DESCRIPTOR_UPDATE_TEMPLATE: Self = Self(1000085000);
    #[doc(alias = "VK_OBJECT_TYPE_PRIVATE_DATA_SLOT")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const PRIVATE_DATA_SLOT: Self = Self(1000295000);
    #[doc(alias = "VK_OBJECT_TYPE_SURFACE_KHR")]
    #[cfg(feature = "VK_KHR_surface")]
    pub const SURFACE_KHR: Self = Self(1000000000);
    #[doc(alias = "VK_OBJECT_TYPE_SWAPCHAIN_KHR")]
    #[cfg(feature = "VK_KHR_swapchain")]
    pub const SWAPCHAIN_KHR: Self = Self(1000001000);
    #[doc(alias = "VK_OBJECT_TYPE_DISPLAY_KHR")]
    #[cfg(feature = "VK_KHR_display")]
    pub const DISPLAY_KHR: Self = Self(1000002000);
    #[doc(alias = "VK_OBJECT_TYPE_DISPLAY_MODE_KHR")]
    #[cfg(feature = "VK_KHR_display")]
    pub const DISPLAY_MODE_KHR: Self = Self(1000002001);
    #[doc(alias = "VK_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT")]
    #[cfg(feature = "VK_EXT_debug_report")]
    pub const DEBUG_REPORT_CALLBACK_EXT: Self = Self(1000011000);
    #[doc(alias = "VK_OBJECT_TYPE_VIDEO_SESSION_KHR")]
    #[cfg(feature = "VK_KHR_video_queue")]
    pub const VIDEO_SESSION_KHR: Self = Self(1000023000);
    #[doc(alias = "VK_OBJECT_TYPE_VIDEO_SESSION_PARAMETERS_KHR")]
    #[cfg(feature = "VK_KHR_video_queue")]
    pub const VIDEO_SESSION_PARAMETERS_KHR: Self = Self(1000023001);
    #[doc(alias = "VK_OBJECT_TYPE_CU_MODULE_NVX")]
    #[cfg(feature = "VK_NVX_binary_import")]
    pub const CU_MODULE_NVX: Self = Self(1000029000);
    #[doc(alias = "VK_OBJECT_TYPE_CU_FUNCTION_NVX")]
    #[cfg(feature = "VK_NVX_binary_import")]
    pub const CU_FUNCTION_NVX: Self = Self(1000029001);
    #[doc(alias = "VK_OBJECT_TYPE_DEBUG_UTILS_MESSENGER_EXT")]
    #[cfg(feature = "VK_EXT_debug_utils")]
    pub const DEBUG_UTILS_MESSENGER_EXT: Self = Self(1000128000);
    #[doc(alias = "VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR")]
    #[cfg(feature = "VK_KHR_acceleration_structure")]
    pub const ACCELERATION_STRUCTURE_KHR: Self = Self(1000150000);
    #[doc(alias = "VK_OBJECT_TYPE_VALIDATION_CACHE_EXT")]
    #[cfg(feature = "VK_EXT_validation_cache")]
    pub const VALIDATION_CACHE_EXT: Self = Self(1000160000);
    #[doc(alias = "VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV")]
    #[cfg(feature = "VK_NV_ray_tracing")]
    pub const ACCELERATION_STRUCTURE_NV: Self = Self(1000165000);
    #[doc(alias = "VK_OBJECT_TYPE_PERFORMANCE_CONFIGURATION_INTEL")]
    #[cfg(feature = "VK_INTEL_performance_query")]
    pub const PERFORMANCE_CONFIGURATION_INTEL: Self = Self(1000210000);
    #[doc(alias = "VK_OBJECT_TYPE_DEFERRED_OPERATION_KHR")]
    #[cfg(feature = "VK_KHR_deferred_host_operations")]
    pub const DEFERRED_OPERATION_KHR: Self = Self(1000268000);
    #[doc(alias = "VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NV")]
    #[cfg(feature = "VK_NV_device_generated_commands")]
    pub const INDIRECT_COMMANDS_LAYOUT_NV: Self = Self(1000277000);
    #[doc(alias = "VK_OBJECT_TYPE_BUFFER_COLLECTION_FUCHSIA")]
    #[cfg(feature = "VK_FUCHSIA_buffer_collection")]
    pub const BUFFER_COLLECTION_FUCHSIA: Self = Self(1000366000);
    #[doc(alias = "VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR")]
    #[cfg(feature = "VK_KHR_descriptor_update_template")]
    pub const DESCRIPTOR_UPDATE_TEMPLATE_KHR: Self = Self::DESCRIPTOR_UPDATE_TEMPLATE;
    #[doc(alias = "VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR")]
    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
    pub const SAMPLER_YCBCR_CONVERSION_KHR: Self = Self::SAMPLER_YCBCR_CONVERSION;
    #[doc(alias = "VK_OBJECT_TYPE_PRIVATE_DATA_SLOT_EXT")]
    #[cfg(feature = "VK_EXT_private_data")]
    pub const PRIVATE_DATA_SLOT_EXT: Self = Self::PRIVATE_DATA_SLOT;
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> i32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: i32) -> Option<Self> {
        match bits {
            x if x == Self::UNKNOWN.bits() => Some(Self(x)),
            x if x == Self::INSTANCE.bits() => Some(Self(x)),
            x if x == Self::PHYSICAL_DEVICE.bits() => Some(Self(x)),
            x if x == Self::DEVICE.bits() => Some(Self(x)),
            x if x == Self::QUEUE.bits() => Some(Self(x)),
            x if x == Self::SEMAPHORE.bits() => Some(Self(x)),
            x if x == Self::COMMAND_BUFFER.bits() => Some(Self(x)),
            x if x == Self::FENCE.bits() => Some(Self(x)),
            x if x == Self::DEVICE_MEMORY.bits() => Some(Self(x)),
            x if x == Self::BUFFER.bits() => Some(Self(x)),
            x if x == Self::IMAGE.bits() => Some(Self(x)),
            x if x == Self::EVENT.bits() => Some(Self(x)),
            x if x == Self::QUERY_POOL.bits() => Some(Self(x)),
            x if x == Self::BUFFER_VIEW.bits() => Some(Self(x)),
            x if x == Self::IMAGE_VIEW.bits() => Some(Self(x)),
            x if x == Self::SHADER_MODULE.bits() => Some(Self(x)),
            x if x == Self::PIPELINE_CACHE.bits() => Some(Self(x)),
            x if x == Self::PIPELINE_LAYOUT.bits() => Some(Self(x)),
            x if x == Self::RENDER_PASS.bits() => Some(Self(x)),
            x if x == Self::PIPELINE.bits() => Some(Self(x)),
            x if x == Self::DESCRIPTOR_SET_LAYOUT.bits() => Some(Self(x)),
            x if x == Self::SAMPLER.bits() => Some(Self(x)),
            x if x == Self::DESCRIPTOR_POOL.bits() => Some(Self(x)),
            x if x == Self::DESCRIPTOR_SET.bits() => Some(Self(x)),
            x if x == Self::FRAMEBUFFER.bits() => Some(Self(x)),
            x if x == Self::COMMAND_POOL.bits() => Some(Self(x)),
            x if x == Self::SAMPLER_YCBCR_CONVERSION.bits() => Some(Self(x)),
            x if x == Self::DESCRIPTOR_UPDATE_TEMPLATE.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::PRIVATE_DATA_SLOT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_surface")]
            x if x == Self::SURFACE_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_swapchain")]
            x if x == Self::SWAPCHAIN_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_display")]
            x if x == Self::DISPLAY_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_display")]
            x if x == Self::DISPLAY_MODE_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_debug_report")]
            x if x == Self::DEBUG_REPORT_CALLBACK_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_video_queue")]
            x if x == Self::VIDEO_SESSION_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_video_queue")]
            x if x == Self::VIDEO_SESSION_PARAMETERS_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NVX_binary_import")]
            x if x == Self::CU_MODULE_NVX.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NVX_binary_import")]
            x if x == Self::CU_FUNCTION_NVX.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_debug_utils")]
            x if x == Self::DEBUG_UTILS_MESSENGER_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_acceleration_structure")]
            x if x == Self::ACCELERATION_STRUCTURE_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_validation_cache")]
            x if x == Self::VALIDATION_CACHE_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_ray_tracing")]
            x if x == Self::ACCELERATION_STRUCTURE_NV.bits() => Some(Self(x)),
            #[cfg(feature = "VK_INTEL_performance_query")]
            x if x == Self::PERFORMANCE_CONFIGURATION_INTEL.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_deferred_host_operations")]
            x if x == Self::DEFERRED_OPERATION_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_device_generated_commands")]
            x if x == Self::INDIRECT_COMMANDS_LAYOUT_NV.bits() => Some(Self(x)),
            #[cfg(feature = "VK_FUCHSIA_buffer_collection")]
            x if x == Self::BUFFER_COLLECTION_FUCHSIA.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: i32) -> Self {
        Self(bits)
    }
}
# [doc = include_str ! ("../../../doc/VkVendorId.md")]
#[doc(alias = "VkVendorId")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct VendorId(i32);
impl VendorId {
    #[doc(alias = "VK_VENDOR_ID_VIV")]
    pub const VIV: Self = Self(65537);
    #[doc(alias = "VK_VENDOR_ID_VSI")]
    pub const VSI: Self = Self(65538);
    #[doc(alias = "VK_VENDOR_ID_KAZAN")]
    pub const KAZAN: Self = Self(65539);
    #[doc(alias = "VK_VENDOR_ID_CODEPLAY")]
    pub const CODEPLAY: Self = Self(65540);
    #[doc(alias = "VK_VENDOR_ID_MESA")]
    pub const MESA: Self = Self(65541);
    #[doc(alias = "VK_VENDOR_ID_POCL")]
    pub const POCL: Self = Self(65542);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> i32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: i32) -> Option<Self> {
        match bits {
            x if x == Self::VIV.bits() => Some(Self(x)),
            x if x == Self::VSI.bits() => Some(Self(x)),
            x if x == Self::KAZAN.bits() => Some(Self(x)),
            x if x == Self::CODEPLAY.bits() => Some(Self(x)),
            x if x == Self::MESA.bits() => Some(Self(x)),
            x if x == Self::POCL.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: i32) -> Self {
        Self(bits)
    }
}
# [doc = include_str ! ("../../../doc/vkCreateInstance.md")]
#[doc(alias = "vkCreateInstance")]
pub type FNCreateInstance = unsafe extern "system" fn(
    p_create_info: *const InstanceCreateInfo,
    p_allocator: *const AllocationCallbacks,
    p_instance: *mut Instance,
) -> VulkanResultCodes;
# [doc = include_str ! ("../../../doc/vkDestroyInstance.md")]
#[doc(alias = "vkDestroyInstance")]
pub type FNDestroyInstance = unsafe extern "system" fn(instance: Instance, p_allocator: *const AllocationCallbacks);
# [doc = include_str ! ("../../../doc/vkEnumeratePhysicalDevices.md")]
#[doc(alias = "vkEnumeratePhysicalDevices")]
pub type FNEnumeratePhysicalDevices = unsafe extern "system" fn(
    instance: Instance,
    p_physical_device_count: *mut u32,
    p_physical_devices: *mut PhysicalDevice,
) -> VulkanResultCodes;
# [doc = include_str ! ("../../../doc/vkGetDeviceProcAddr.md")]
#[doc(alias = "vkGetDeviceProcAddr")]
pub type FNGetDeviceProcAddr = unsafe extern "system" fn(device: Device, p_name: *const CStr) -> PFNVoidFunction;
# [doc = include_str ! ("../../../doc/vkGetInstanceProcAddr.md")]
#[doc(alias = "vkGetInstanceProcAddr")]
pub type FNGetInstanceProcAddr = unsafe extern "system" fn(instance: Instance, p_name: *const CStr) -> PFNVoidFunction;
# [doc = include_str ! ("../../../doc/vkGetPhysicalDeviceProperties.md")]
#[doc(alias = "vkGetPhysicalDeviceProperties")]
pub type FNGetPhysicalDeviceProperties =
    unsafe extern "system" fn(physical_device: PhysicalDevice, p_properties: *mut PhysicalDeviceProperties);
# [doc = include_str ! ("../../../doc/vkGetPhysicalDeviceQueueFamilyProperties.md")]
#[doc(alias = "vkGetPhysicalDeviceQueueFamilyProperties")]
pub type FNGetPhysicalDeviceQueueFamilyProperties = unsafe extern "system" fn(
    physical_device: PhysicalDevice,
    p_queue_family_property_count: *mut u32,
    p_queue_family_properties: *mut QueueFamilyProperties,
);
# [doc = include_str ! ("../../../doc/vkGetPhysicalDeviceMemoryProperties.md")]
#[doc(alias = "vkGetPhysicalDeviceMemoryProperties")]
pub type FNGetPhysicalDeviceMemoryProperties = unsafe extern "system" fn(
    physical_device: PhysicalDevice,
    p_memory_properties: *mut PhysicalDeviceMemoryProperties,
);
# [doc = include_str ! ("../../../doc/vkGetPhysicalDeviceFeatures.md")]
#[doc(alias = "vkGetPhysicalDeviceFeatures")]
pub type FNGetPhysicalDeviceFeatures =
    unsafe extern "system" fn(physical_device: PhysicalDevice, p_features: *mut PhysicalDeviceFeatures);
# [doc = include_str ! ("../../../doc/vkGetPhysicalDeviceFormatProperties.md")]
#[doc(alias = "vkGetPhysicalDeviceFormatProperties")]
pub type FNGetPhysicalDeviceFormatProperties = unsafe extern "system" fn(
    physical_device: PhysicalDevice,
    format: Format,
    p_format_properties: *mut FormatProperties,
);
# [doc = include_str ! ("../../../doc/vkGetPhysicalDeviceImageFormatProperties.md")]
#[doc(alias = "vkGetPhysicalDeviceImageFormatProperties")]
pub type FNGetPhysicalDeviceImageFormatProperties = unsafe extern "system" fn(
    physical_device: PhysicalDevice,
    format: Format,
    type_: ImageType,
    tiling: ImageTiling,
    usage: ImageUsageFlags,
    flags: ImageCreateFlags,
    p_image_format_properties: *mut ImageFormatProperties,
) -> VulkanResultCodes;
# [doc = include_str ! ("../../../doc/vkCreateDevice.md")]
#[doc(alias = "vkCreateDevice")]
pub type FNCreateDevice = unsafe extern "system" fn(
    physical_device: PhysicalDevice,
    p_create_info: *const DeviceCreateInfo,
    p_allocator: *const AllocationCallbacks,
    p_device: *mut Device,
) -> VulkanResultCodes;
# [doc = include_str ! ("../../../doc/vkDestroyDevice.md")]
#[doc(alias = "vkDestroyDevice")]
pub type FNDestroyDevice = unsafe extern "system" fn(device: Device, p_allocator: *const AllocationCallbacks);
# [doc = include_str ! ("../../../doc/vkEnumerateInstanceLayerProperties.md")]
#[doc(alias = "vkEnumerateInstanceLayerProperties")]
pub type FNEnumerateInstanceLayerProperties =
    unsafe extern "system" fn(p_property_count: *mut u32, p_properties: *mut LayerProperties) -> VulkanResultCodes;
# [doc = include_str ! ("../../../doc/vkEnumerateInstanceExtensionProperties.md")]
#[doc(alias = "vkEnumerateInstanceExtensionProperties")]
pub type FNEnumerateInstanceExtensionProperties = unsafe extern "system" fn(
    p_layer_name: *const CStr,
    p_property_count: *mut u32,
    p_properties: *mut ExtensionProperties,
) -> VulkanResultCodes;
# [doc = include_str ! ("../../../doc/vkEnumerateDeviceLayerProperties.md")]
#[doc(alias = "vkEnumerateDeviceLayerProperties")]
pub type FNEnumerateDeviceLayerProperties = unsafe extern "system" fn(
    physical_device: PhysicalDevice,
    p_property_count: *mut u32,
    p_properties: *mut LayerProperties,
) -> VulkanResultCodes;
# [doc = include_str ! ("../../../doc/vkEnumerateDeviceExtensionProperties.md")]
#[doc(alias = "vkEnumerateDeviceExtensionProperties")]
pub type FNEnumerateDeviceExtensionProperties = unsafe extern "system" fn(
    physical_device: PhysicalDevice,
    p_layer_name: *const CStr,
    p_property_count: *mut u32,
    p_properties: *mut ExtensionProperties,
) -> VulkanResultCodes;
# [doc = include_str ! ("../../../doc/vkGetDeviceQueue.md")]
#[doc(alias = "vkGetDeviceQueue")]
pub type FNGetDeviceQueue =
    unsafe extern "system" fn(device: Device, queue_family_index: u32, queue_index: u32, p_queue: *mut Queue);
# [doc = include_str ! ("../../../doc/vkQueueSubmit.md")]
#[doc(alias = "vkQueueSubmit")]
pub type FNQueueSubmit = unsafe extern "system" fn(
    queue: Queue,
    submit_count: u32,
    p_submits: *const SubmitInfo,
    fence: Fence,
) -> VulkanResultCodes;
# [doc = include_str ! ("../../../doc/vkQueueWaitIdle.md")]
#[doc(alias = "vkQueueWaitIdle")]
pub type FNQueueWaitIdle = unsafe extern "system" fn(queue: Queue) -> VulkanResultCodes;
# [doc = include_str ! ("../../../doc/vkDeviceWaitIdle.md")]
#[doc(alias = "vkDeviceWaitIdle")]
pub type FNDeviceWaitIdle = unsafe extern "system" fn(device: Device) -> VulkanResultCodes;
# [doc = include_str ! ("../../../doc/vkAllocateMemory.md")]
#[doc(alias = "vkAllocateMemory")]
pub type FNAllocateMemory = unsafe extern "system" fn(
    device: Device,
    p_allocate_info: *const MemoryAllocateInfo,
    p_allocator: *const AllocationCallbacks,
    p_memory: *mut DeviceMemory,
) -> VulkanResultCodes;
# [doc = include_str ! ("../../../doc/vkFreeMemory.md")]
#[doc(alias = "vkFreeMemory")]
pub type FNFreeMemory =
    unsafe extern "system" fn(device: Device, memory: DeviceMemory, p_allocator: *const AllocationCallbacks);
# [doc = include_str ! ("../../../doc/vkMapMemory.md")]
#[doc(alias = "vkMapMemory")]
pub type FNMapMemory = unsafe extern "system" fn(
    device: Device,
    memory: DeviceMemory,
    offset: DeviceSize,
    size: DeviceSize,
    flags: MemoryMapFlags,
    pp_data: *mut *mut std::ffi::c_void,
) -> VulkanResultCodes;
# [doc = include_str ! ("../../../doc/vkUnmapMemory.md")]
#[doc(alias = "vkUnmapMemory")]
pub type FNUnmapMemory = unsafe extern "system" fn(device: Device, memory: DeviceMemory);
# [doc = include_str ! ("../../../doc/vkFlushMappedMemoryRanges.md")]
#[doc(alias = "vkFlushMappedMemoryRanges")]
pub type FNFlushMappedMemoryRanges = unsafe extern "system" fn(
    device: Device,
    memory_range_count: u32,
    p_memory_ranges: *const MappedMemoryRange,
) -> VulkanResultCodes;
# [doc = include_str ! ("../../../doc/vkInvalidateMappedMemoryRanges.md")]
#[doc(alias = "vkInvalidateMappedMemoryRanges")]
pub type FNInvalidateMappedMemoryRanges = unsafe extern "system" fn(
    device: Device,
    memory_range_count: u32,
    p_memory_ranges: *const MappedMemoryRange,
) -> VulkanResultCodes;
# [doc = include_str ! ("../../../doc/vkGetDeviceMemoryCommitment.md")]
#[doc(alias = "vkGetDeviceMemoryCommitment")]
pub type FNGetDeviceMemoryCommitment =
    unsafe extern "system" fn(device: Device, memory: DeviceMemory, p_committed_memory_in_bytes: *mut DeviceSize);
# [doc = include_str ! ("../../../doc/vkGetBufferMemoryRequirements.md")]
#[doc(alias = "vkGetBufferMemoryRequirements")]
pub type FNGetBufferMemoryRequirements =
    unsafe extern "system" fn(device: Device, buffer: Buffer, p_memory_requirements: *mut MemoryRequirements);
# [doc = include_str ! ("../../../doc/vkBindBufferMemory.md")]
#[doc(alias = "vkBindBufferMemory")]
pub type FNBindBufferMemory = unsafe extern "system" fn(
    device: Device,
    buffer: Buffer,
    memory: DeviceMemory,
    memory_offset: DeviceSize,
) -> VulkanResultCodes;
# [doc = include_str ! ("../../../doc/vkGetImageMemoryRequirements.md")]
#[doc(alias = "vkGetImageMemoryRequirements")]
pub type FNGetImageMemoryRequirements =
    unsafe extern "system" fn(device: Device, image: Image, p_memory_requirements: *mut MemoryRequirements);
# [doc = include_str ! ("../../../doc/vkBindImageMemory.md")]
#[doc(alias = "vkBindImageMemory")]
pub type FNBindImageMemory = unsafe extern "system" fn(
    device: Device,
    image: Image,
    memory: DeviceMemory,
    memory_offset: DeviceSize,
) -> VulkanResultCodes;
# [doc = include_str ! ("../../../doc/vkGetImageSparseMemoryRequirements.md")]
#[doc(alias = "vkGetImageSparseMemoryRequirements")]
pub type FNGetImageSparseMemoryRequirements = unsafe extern "system" fn(
    device: Device,
    image: Image,
    p_sparse_memory_requirement_count: *mut u32,
    p_sparse_memory_requirements: *mut SparseImageMemoryRequirements,
);
# [doc = include_str ! ("../../../doc/vkGetPhysicalDeviceSparseImageFormatProperties.md")]
#[doc(alias = "vkGetPhysicalDeviceSparseImageFormatProperties")]
pub type FNGetPhysicalDeviceSparseImageFormatProperties = unsafe extern "system" fn(
    physical_device: PhysicalDevice,
    format: Format,
    type_: ImageType,
    samples: SampleCountFlagBits,
    usage: ImageUsageFlags,
    tiling: ImageTiling,
    p_property_count: *mut u32,
    p_properties: *mut SparseImageFormatProperties,
);
# [doc = include_str ! ("../../../doc/vkQueueBindSparse.md")]
#[doc(alias = "vkQueueBindSparse")]
pub type FNQueueBindSparse = unsafe extern "system" fn(
    queue: Queue,
    bind_info_count: u32,
    p_bind_info: *const BindSparseInfo,
    fence: Fence,
) -> VulkanResultCodes;
# [doc = include_str ! ("../../../doc/vkCreateFence.md")]
#[doc(alias = "vkCreateFence")]
pub type FNCreateFence = unsafe extern "system" fn(
    device: Device,
    p_create_info: *const FenceCreateInfo,
    p_allocator: *const AllocationCallbacks,
    p_fence: *mut Fence,
) -> VulkanResultCodes;
# [doc = include_str ! ("../../../doc/vkDestroyFence.md")]
#[doc(alias = "vkDestroyFence")]
pub type FNDestroyFence =
    unsafe extern "system" fn(device: Device, fence: Fence, p_allocator: *const AllocationCallbacks);
# [doc = include_str ! ("../../../doc/vkResetFences.md")]
#[doc(alias = "vkResetFences")]
pub type FNResetFences =
    unsafe extern "system" fn(device: Device, fence_count: u32, p_fences: *const Fence) -> VulkanResultCodes;
# [doc = include_str ! ("../../../doc/vkGetFenceStatus.md")]
#[doc(alias = "vkGetFenceStatus")]
pub type FNGetFenceStatus = unsafe extern "system" fn(device: Device, fence: Fence) -> VulkanResultCodes;
# [doc = include_str ! ("../../../doc/vkWaitForFences.md")]
#[doc(alias = "vkWaitForFences")]
pub type FNWaitForFences = unsafe extern "system" fn(
    device: Device,
    fence_count: u32,
    p_fences: *const Fence,
    wait_all: Bool32,
    timeout: u64,
) -> VulkanResultCodes;
# [doc = include_str ! ("../../../doc/vkCreateSemaphore.md")]
#[doc(alias = "vkCreateSemaphore")]
pub type FNCreateSemaphore = unsafe extern "system" fn(
    device: Device,
    p_create_info: *const SemaphoreCreateInfo,
    p_allocator: *const AllocationCallbacks,
    p_semaphore: *mut Semaphore,
) -> VulkanResultCodes;
# [doc = include_str ! ("../../../doc/vkDestroySemaphore.md")]
#[doc(alias = "vkDestroySemaphore")]
pub type FNDestroySemaphore =
    unsafe extern "system" fn(device: Device, semaphore: Semaphore, p_allocator: *const AllocationCallbacks);
# [doc = include_str ! ("../../../doc/vkCreateEvent.md")]
#[doc(alias = "vkCreateEvent")]
pub type FNCreateEvent = unsafe extern "system" fn(
    device: Device,
    p_create_info: *const EventCreateInfo,
    p_allocator: *const AllocationCallbacks,
    p_event: *mut Event,
) -> VulkanResultCodes;
# [doc = include_str ! ("../../../doc/vkDestroyEvent.md")]
#[doc(alias = "vkDestroyEvent")]
pub type FNDestroyEvent =
    unsafe extern "system" fn(device: Device, event: Event, p_allocator: *const AllocationCallbacks);
# [doc = include_str ! ("../../../doc/vkGetEventStatus.md")]
#[doc(alias = "vkGetEventStatus")]
pub type FNGetEventStatus = unsafe extern "system" fn(device: Device, event: Event) -> VulkanResultCodes;
# [doc = include_str ! ("../../../doc/vkSetEvent.md")]
#[doc(alias = "vkSetEvent")]
pub type FNSetEvent = unsafe extern "system" fn(device: Device, event: Event) -> VulkanResultCodes;
# [doc = include_str ! ("../../../doc/vkResetEvent.md")]
#[doc(alias = "vkResetEvent")]
pub type FNResetEvent = unsafe extern "system" fn(device: Device, event: Event) -> VulkanResultCodes;
# [doc = include_str ! ("../../../doc/vkCreateQueryPool.md")]
#[doc(alias = "vkCreateQueryPool")]
pub type FNCreateQueryPool = unsafe extern "system" fn(
    device: Device,
    p_create_info: *const QueryPoolCreateInfo,
    p_allocator: *const AllocationCallbacks,
    p_query_pool: *mut QueryPool,
) -> VulkanResultCodes;
# [doc = include_str ! ("../../../doc/vkDestroyQueryPool.md")]
#[doc(alias = "vkDestroyQueryPool")]
pub type FNDestroyQueryPool =
    unsafe extern "system" fn(device: Device, query_pool: QueryPool, p_allocator: *const AllocationCallbacks);
# [doc = include_str ! ("../../../doc/vkGetQueryPoolResults.md")]
#[doc(alias = "vkGetQueryPoolResults")]
pub type FNGetQueryPoolResults = unsafe extern "system" fn(
    device: Device,
    query_pool: QueryPool,
    first_query: u32,
    query_count: u32,
    data_size: usize,
    p_data: *mut std::ffi::c_void,
    stride: DeviceSize,
    flags: QueryResultFlags,
) -> VulkanResultCodes;
# [doc = include_str ! ("../../../doc/vkCreateBuffer.md")]
#[doc(alias = "vkCreateBuffer")]
pub type FNCreateBuffer = unsafe extern "system" fn(
    device: Device,
    p_create_info: *const BufferCreateInfo,
    p_allocator: *const AllocationCallbacks,
    p_buffer: *mut Buffer,
) -> VulkanResultCodes;
# [doc = include_str ! ("../../../doc/vkDestroyBuffer.md")]
#[doc(alias = "vkDestroyBuffer")]
pub type FNDestroyBuffer =
    unsafe extern "system" fn(device: Device, buffer: Buffer, p_allocator: *const AllocationCallbacks);
# [doc = include_str ! ("../../../doc/vkCreateBufferView.md")]
#[doc(alias = "vkCreateBufferView")]
pub type FNCreateBufferView = unsafe extern "system" fn(
    device: Device,
    p_create_info: *const BufferViewCreateInfo,
    p_allocator: *const AllocationCallbacks,
    p_view: *mut BufferView,
) -> VulkanResultCodes;
# [doc = include_str ! ("../../../doc/vkDestroyBufferView.md")]
#[doc(alias = "vkDestroyBufferView")]
pub type FNDestroyBufferView =
    unsafe extern "system" fn(device: Device, buffer_view: BufferView, p_allocator: *const AllocationCallbacks);
# [doc = include_str ! ("../../../doc/vkCreateImage.md")]
#[doc(alias = "vkCreateImage")]
pub type FNCreateImage = unsafe extern "system" fn(
    device: Device,
    p_create_info: *const ImageCreateInfo,
    p_allocator: *const AllocationCallbacks,
    p_image: *mut Image,
) -> VulkanResultCodes;
# [doc = include_str ! ("../../../doc/vkDestroyImage.md")]
#[doc(alias = "vkDestroyImage")]
pub type FNDestroyImage =
    unsafe extern "system" fn(device: Device, image: Image, p_allocator: *const AllocationCallbacks);
# [doc = include_str ! ("../../../doc/vkGetImageSubresourceLayout.md")]
#[doc(alias = "vkGetImageSubresourceLayout")]
pub type FNGetImageSubresourceLayout = unsafe extern "system" fn(
    device: Device,
    image: Image,
    p_subresource: *const ImageSubresource,
    p_layout: *mut SubresourceLayout,
);
# [doc = include_str ! ("../../../doc/vkCreateImageView.md")]
#[doc(alias = "vkCreateImageView")]
pub type FNCreateImageView = unsafe extern "system" fn(
    device: Device,
    p_create_info: *const ImageViewCreateInfo,
    p_allocator: *const AllocationCallbacks,
    p_view: *mut ImageView,
) -> VulkanResultCodes;
# [doc = include_str ! ("../../../doc/vkDestroyImageView.md")]
#[doc(alias = "vkDestroyImageView")]
pub type FNDestroyImageView =
    unsafe extern "system" fn(device: Device, image_view: ImageView, p_allocator: *const AllocationCallbacks);
# [doc = include_str ! ("../../../doc/vkCreateShaderModule.md")]
#[doc(alias = "vkCreateShaderModule")]
pub type FNCreateShaderModule = unsafe extern "system" fn(
    device: Device,
    p_create_info: *const ShaderModuleCreateInfo,
    p_allocator: *const AllocationCallbacks,
    p_shader_module: *mut ShaderModule,
) -> VulkanResultCodes;
# [doc = include_str ! ("../../../doc/vkDestroyShaderModule.md")]
#[doc(alias = "vkDestroyShaderModule")]
pub type FNDestroyShaderModule =
    unsafe extern "system" fn(device: Device, shader_module: ShaderModule, p_allocator: *const AllocationCallbacks);
# [doc = include_str ! ("../../../doc/vkCreatePipelineCache.md")]
#[doc(alias = "vkCreatePipelineCache")]
pub type FNCreatePipelineCache = unsafe extern "system" fn(
    device: Device,
    p_create_info: *const PipelineCacheCreateInfo,
    p_allocator: *const AllocationCallbacks,
    p_pipeline_cache: *mut PipelineCache,
) -> VulkanResultCodes;
# [doc = include_str ! ("../../../doc/vkDestroyPipelineCache.md")]
#[doc(alias = "vkDestroyPipelineCache")]
pub type FNDestroyPipelineCache =
    unsafe extern "system" fn(device: Device, pipeline_cache: PipelineCache, p_allocator: *const AllocationCallbacks);
# [doc = include_str ! ("../../../doc/vkGetPipelineCacheData.md")]
#[doc(alias = "vkGetPipelineCacheData")]
pub type FNGetPipelineCacheData = unsafe extern "system" fn(
    device: Device,
    pipeline_cache: PipelineCache,
    p_data_size: *mut usize,
    p_data: *mut std::ffi::c_void,
) -> VulkanResultCodes;
# [doc = include_str ! ("../../../doc/vkMergePipelineCaches.md")]
#[doc(alias = "vkMergePipelineCaches")]
pub type FNMergePipelineCaches = unsafe extern "system" fn(
    device: Device,
    dst_cache: PipelineCache,
    src_cache_count: u32,
    p_src_caches: *const PipelineCache,
) -> VulkanResultCodes;
# [doc = include_str ! ("../../../doc/vkCreateGraphicsPipelines.md")]
#[doc(alias = "vkCreateGraphicsPipelines")]
pub type FNCreateGraphicsPipelines = unsafe extern "system" fn(
    device: Device,
    pipeline_cache: PipelineCache,
    create_info_count: u32,
    p_create_infos: *const GraphicsPipelineCreateInfo,
    p_allocator: *const AllocationCallbacks,
    p_pipelines: *mut Pipeline,
) -> VulkanResultCodes;
# [doc = include_str ! ("../../../doc/vkCreateComputePipelines.md")]
#[doc(alias = "vkCreateComputePipelines")]
pub type FNCreateComputePipelines = unsafe extern "system" fn(
    device: Device,
    pipeline_cache: PipelineCache,
    create_info_count: u32,
    p_create_infos: *const ComputePipelineCreateInfo,
    p_allocator: *const AllocationCallbacks,
    p_pipelines: *mut Pipeline,
) -> VulkanResultCodes;
# [doc = include_str ! ("../../../doc/vkDestroyPipeline.md")]
#[doc(alias = "vkDestroyPipeline")]
pub type FNDestroyPipeline =
    unsafe extern "system" fn(device: Device, pipeline: Pipeline, p_allocator: *const AllocationCallbacks);
# [doc = include_str ! ("../../../doc/vkCreatePipelineLayout.md")]
#[doc(alias = "vkCreatePipelineLayout")]
pub type FNCreatePipelineLayout = unsafe extern "system" fn(
    device: Device,
    p_create_info: *const PipelineLayoutCreateInfo,
    p_allocator: *const AllocationCallbacks,
    p_pipeline_layout: *mut PipelineLayout,
) -> VulkanResultCodes;
# [doc = include_str ! ("../../../doc/vkDestroyPipelineLayout.md")]
#[doc(alias = "vkDestroyPipelineLayout")]
pub type FNDestroyPipelineLayout =
    unsafe extern "system" fn(device: Device, pipeline_layout: PipelineLayout, p_allocator: *const AllocationCallbacks);
# [doc = include_str ! ("../../../doc/vkCreateSampler.md")]
#[doc(alias = "vkCreateSampler")]
pub type FNCreateSampler = unsafe extern "system" fn(
    device: Device,
    p_create_info: *const SamplerCreateInfo,
    p_allocator: *const AllocationCallbacks,
    p_sampler: *mut Sampler,
) -> VulkanResultCodes;
# [doc = include_str ! ("../../../doc/vkDestroySampler.md")]
#[doc(alias = "vkDestroySampler")]
pub type FNDestroySampler =
    unsafe extern "system" fn(device: Device, sampler: Sampler, p_allocator: *const AllocationCallbacks);
# [doc = include_str ! ("../../../doc/vkCreateDescriptorSetLayout.md")]
#[doc(alias = "vkCreateDescriptorSetLayout")]
pub type FNCreateDescriptorSetLayout = unsafe extern "system" fn(
    device: Device,
    p_create_info: *const DescriptorSetLayoutCreateInfo,
    p_allocator: *const AllocationCallbacks,
    p_set_layout: *mut DescriptorSetLayout,
) -> VulkanResultCodes;
# [doc = include_str ! ("../../../doc/vkDestroyDescriptorSetLayout.md")]
#[doc(alias = "vkDestroyDescriptorSetLayout")]
pub type FNDestroyDescriptorSetLayout = unsafe extern "system" fn(
    device: Device,
    descriptor_set_layout: DescriptorSetLayout,
    p_allocator: *const AllocationCallbacks,
);
# [doc = include_str ! ("../../../doc/vkCreateDescriptorPool.md")]
#[doc(alias = "vkCreateDescriptorPool")]
pub type FNCreateDescriptorPool = unsafe extern "system" fn(
    device: Device,
    p_create_info: *const DescriptorPoolCreateInfo,
    p_allocator: *const AllocationCallbacks,
    p_descriptor_pool: *mut DescriptorPool,
) -> VulkanResultCodes;
# [doc = include_str ! ("../../../doc/vkDestroyDescriptorPool.md")]
#[doc(alias = "vkDestroyDescriptorPool")]
pub type FNDestroyDescriptorPool =
    unsafe extern "system" fn(device: Device, descriptor_pool: DescriptorPool, p_allocator: *const AllocationCallbacks);
# [doc = include_str ! ("../../../doc/vkResetDescriptorPool.md")]
#[doc(alias = "vkResetDescriptorPool")]
pub type FNResetDescriptorPool = unsafe extern "system" fn(
    device: Device,
    descriptor_pool: DescriptorPool,
    flags: DescriptorPoolResetFlags,
) -> VulkanResultCodes;
# [doc = include_str ! ("../../../doc/vkAllocateDescriptorSets.md")]
#[doc(alias = "vkAllocateDescriptorSets")]
pub type FNAllocateDescriptorSets = unsafe extern "system" fn(
    device: Device,
    p_allocate_info: *const DescriptorSetAllocateInfo,
    p_descriptor_sets: *mut DescriptorSet,
) -> VulkanResultCodes;
# [doc = include_str ! ("../../../doc/vkFreeDescriptorSets.md")]
#[doc(alias = "vkFreeDescriptorSets")]
pub type FNFreeDescriptorSets = unsafe extern "system" fn(
    device: Device,
    descriptor_pool: DescriptorPool,
    descriptor_set_count: u32,
    p_descriptor_sets: *const DescriptorSet,
) -> VulkanResultCodes;
# [doc = include_str ! ("../../../doc/vkUpdateDescriptorSets.md")]
#[doc(alias = "vkUpdateDescriptorSets")]
pub type FNUpdateDescriptorSets = unsafe extern "system" fn(
    device: Device,
    descriptor_write_count: u32,
    p_descriptor_writes: *const WriteDescriptorSet,
    descriptor_copy_count: u32,
    p_descriptor_copies: *const CopyDescriptorSet,
);
# [doc = include_str ! ("../../../doc/vkCreateFramebuffer.md")]
#[doc(alias = "vkCreateFramebuffer")]
pub type FNCreateFramebuffer = unsafe extern "system" fn(
    device: Device,
    p_create_info: *const FramebufferCreateInfo,
    p_allocator: *const AllocationCallbacks,
    p_framebuffer: *mut Framebuffer,
) -> VulkanResultCodes;
# [doc = include_str ! ("../../../doc/vkDestroyFramebuffer.md")]
#[doc(alias = "vkDestroyFramebuffer")]
pub type FNDestroyFramebuffer =
    unsafe extern "system" fn(device: Device, framebuffer: Framebuffer, p_allocator: *const AllocationCallbacks);
# [doc = include_str ! ("../../../doc/vkCreateRenderPass.md")]
#[doc(alias = "vkCreateRenderPass")]
pub type FNCreateRenderPass = unsafe extern "system" fn(
    device: Device,
    p_create_info: *const RenderPassCreateInfo,
    p_allocator: *const AllocationCallbacks,
    p_render_pass: *mut RenderPass,
) -> VulkanResultCodes;
# [doc = include_str ! ("../../../doc/vkDestroyRenderPass.md")]
#[doc(alias = "vkDestroyRenderPass")]
pub type FNDestroyRenderPass =
    unsafe extern "system" fn(device: Device, render_pass: RenderPass, p_allocator: *const AllocationCallbacks);
# [doc = include_str ! ("../../../doc/vkGetRenderAreaGranularity.md")]
#[doc(alias = "vkGetRenderAreaGranularity")]
pub type FNGetRenderAreaGranularity =
    unsafe extern "system" fn(device: Device, render_pass: RenderPass, p_granularity: *mut Extent2D);
# [doc = include_str ! ("../../../doc/vkCreateCommandPool.md")]
#[doc(alias = "vkCreateCommandPool")]
pub type FNCreateCommandPool = unsafe extern "system" fn(
    device: Device,
    p_create_info: *const CommandPoolCreateInfo,
    p_allocator: *const AllocationCallbacks,
    p_command_pool: *mut CommandPool,
) -> VulkanResultCodes;
# [doc = include_str ! ("../../../doc/vkDestroyCommandPool.md")]
#[doc(alias = "vkDestroyCommandPool")]
pub type FNDestroyCommandPool =
    unsafe extern "system" fn(device: Device, command_pool: CommandPool, p_allocator: *const AllocationCallbacks);
# [doc = include_str ! ("../../../doc/vkResetCommandPool.md")]
#[doc(alias = "vkResetCommandPool")]
pub type FNResetCommandPool = unsafe extern "system" fn(
    device: Device,
    command_pool: CommandPool,
    flags: CommandPoolResetFlags,
) -> VulkanResultCodes;
# [doc = include_str ! ("../../../doc/vkAllocateCommandBuffers.md")]
#[doc(alias = "vkAllocateCommandBuffers")]
pub type FNAllocateCommandBuffers = unsafe extern "system" fn(
    device: Device,
    p_allocate_info: *const CommandBufferAllocateInfo,
    p_command_buffers: *mut CommandBuffer,
) -> VulkanResultCodes;
# [doc = include_str ! ("../../../doc/vkFreeCommandBuffers.md")]
#[doc(alias = "vkFreeCommandBuffers")]
pub type FNFreeCommandBuffers = unsafe extern "system" fn(
    device: Device,
    command_pool: CommandPool,
    command_buffer_count: u32,
    p_command_buffers: *const CommandBuffer,
);
# [doc = include_str ! ("../../../doc/vkBeginCommandBuffer.md")]
#[doc(alias = "vkBeginCommandBuffer")]
pub type FNBeginCommandBuffer = unsafe extern "system" fn(
    command_buffer: CommandBuffer,
    p_begin_info: *const CommandBufferBeginInfo,
) -> VulkanResultCodes;
# [doc = include_str ! ("../../../doc/vkEndCommandBuffer.md")]
#[doc(alias = "vkEndCommandBuffer")]
pub type FNEndCommandBuffer = unsafe extern "system" fn(command_buffer: CommandBuffer) -> VulkanResultCodes;
# [doc = include_str ! ("../../../doc/vkResetCommandBuffer.md")]
#[doc(alias = "vkResetCommandBuffer")]
pub type FNResetCommandBuffer =
    unsafe extern "system" fn(command_buffer: CommandBuffer, flags: CommandBufferResetFlags) -> VulkanResultCodes;
# [doc = include_str ! ("../../../doc/vkCmdBindPipeline.md")]
#[doc(alias = "vkCmdBindPipeline")]
pub type FNCmdBindPipeline = unsafe extern "system" fn(
    command_buffer: CommandBuffer,
    pipeline_bind_point: PipelineBindPoint,
    pipeline: Pipeline,
);
# [doc = include_str ! ("../../../doc/vkCmdSetViewport.md")]
#[doc(alias = "vkCmdSetViewport")]
pub type FNCmdSetViewport = unsafe extern "system" fn(
    command_buffer: CommandBuffer,
    first_viewport: u32,
    viewport_count: u32,
    p_viewports: *const Viewport,
);
# [doc = include_str ! ("../../../doc/vkCmdSetScissor.md")]
#[doc(alias = "vkCmdSetScissor")]
pub type FNCmdSetScissor = unsafe extern "system" fn(
    command_buffer: CommandBuffer,
    first_scissor: u32,
    scissor_count: u32,
    p_scissors: *const Rect2D,
);
# [doc = include_str ! ("../../../doc/vkCmdSetLineWidth.md")]
#[doc(alias = "vkCmdSetLineWidth")]
pub type FNCmdSetLineWidth = unsafe extern "system" fn(command_buffer: CommandBuffer, line_width: f32);
# [doc = include_str ! ("../../../doc/vkCmdSetDepthBias.md")]
#[doc(alias = "vkCmdSetDepthBias")]
pub type FNCmdSetDepthBias = unsafe extern "system" fn(
    command_buffer: CommandBuffer,
    depth_bias_constant_factor: f32,
    depth_bias_clamp: f32,
    depth_bias_slope_factor: f32,
);
# [doc = include_str ! ("../../../doc/vkCmdSetBlendConstants.md")]
#[doc(alias = "vkCmdSetBlendConstants")]
pub type FNCmdSetBlendConstants =
    unsafe extern "system" fn(command_buffer: CommandBuffer, blend_constants: [f32; 4 as usize]);
# [doc = include_str ! ("../../../doc/vkCmdSetDepthBounds.md")]
#[doc(alias = "vkCmdSetDepthBounds")]
pub type FNCmdSetDepthBounds =
    unsafe extern "system" fn(command_buffer: CommandBuffer, min_depth_bounds: f32, max_depth_bounds: f32);
# [doc = include_str ! ("../../../doc/vkCmdSetStencilCompareMask.md")]
#[doc(alias = "vkCmdSetStencilCompareMask")]
pub type FNCmdSetStencilCompareMask =
    unsafe extern "system" fn(command_buffer: CommandBuffer, face_mask: StencilFaceFlags, compare_mask: u32);
# [doc = include_str ! ("../../../doc/vkCmdSetStencilWriteMask.md")]
#[doc(alias = "vkCmdSetStencilWriteMask")]
pub type FNCmdSetStencilWriteMask =
    unsafe extern "system" fn(command_buffer: CommandBuffer, face_mask: StencilFaceFlags, write_mask: u32);
# [doc = include_str ! ("../../../doc/vkCmdSetStencilReference.md")]
#[doc(alias = "vkCmdSetStencilReference")]
pub type FNCmdSetStencilReference =
    unsafe extern "system" fn(command_buffer: CommandBuffer, face_mask: StencilFaceFlags, reference: u32);
# [doc = include_str ! ("../../../doc/vkCmdBindDescriptorSets.md")]
#[doc(alias = "vkCmdBindDescriptorSets")]
pub type FNCmdBindDescriptorSets = unsafe extern "system" fn(
    command_buffer: CommandBuffer,
    pipeline_bind_point: PipelineBindPoint,
    layout: PipelineLayout,
    first_set: u32,
    descriptor_set_count: u32,
    p_descriptor_sets: *const DescriptorSet,
    dynamic_offset_count: u32,
    p_dynamic_offsets: *const u32,
);
# [doc = include_str ! ("../../../doc/vkCmdBindIndexBuffer.md")]
#[doc(alias = "vkCmdBindIndexBuffer")]
pub type FNCmdBindIndexBuffer =
    unsafe extern "system" fn(command_buffer: CommandBuffer, buffer: Buffer, offset: DeviceSize, index_type: IndexType);
# [doc = include_str ! ("../../../doc/vkCmdBindVertexBuffers.md")]
#[doc(alias = "vkCmdBindVertexBuffers")]
pub type FNCmdBindVertexBuffers = unsafe extern "system" fn(
    command_buffer: CommandBuffer,
    first_binding: u32,
    binding_count: u32,
    p_buffers: *const Buffer,
    p_offsets: *const DeviceSize,
);
# [doc = include_str ! ("../../../doc/vkCmdDraw.md")]
#[doc(alias = "vkCmdDraw")]
pub type FNCmdDraw = unsafe extern "system" fn(
    command_buffer: CommandBuffer,
    vertex_count: u32,
    instance_count: u32,
    first_vertex: u32,
    first_instance: u32,
);
# [doc = include_str ! ("../../../doc/vkCmdDrawIndexed.md")]
#[doc(alias = "vkCmdDrawIndexed")]
pub type FNCmdDrawIndexed = unsafe extern "system" fn(
    command_buffer: CommandBuffer,
    index_count: u32,
    instance_count: u32,
    first_index: u32,
    vertex_offset: i32,
    first_instance: u32,
);
# [doc = include_str ! ("../../../doc/vkCmdDrawIndirect.md")]
#[doc(alias = "vkCmdDrawIndirect")]
pub type FNCmdDrawIndirect = unsafe extern "system" fn(
    command_buffer: CommandBuffer,
    buffer: Buffer,
    offset: DeviceSize,
    draw_count: u32,
    stride: u32,
);
# [doc = include_str ! ("../../../doc/vkCmdDrawIndexedIndirect.md")]
#[doc(alias = "vkCmdDrawIndexedIndirect")]
pub type FNCmdDrawIndexedIndirect = unsafe extern "system" fn(
    command_buffer: CommandBuffer,
    buffer: Buffer,
    offset: DeviceSize,
    draw_count: u32,
    stride: u32,
);
# [doc = include_str ! ("../../../doc/vkCmdDispatch.md")]
#[doc(alias = "vkCmdDispatch")]
pub type FNCmdDispatch = unsafe extern "system" fn(
    command_buffer: CommandBuffer,
    group_count_x: u32,
    group_count_y: u32,
    group_count_z: u32,
);
# [doc = include_str ! ("../../../doc/vkCmdDispatchIndirect.md")]
#[doc(alias = "vkCmdDispatchIndirect")]
pub type FNCmdDispatchIndirect =
    unsafe extern "system" fn(command_buffer: CommandBuffer, buffer: Buffer, offset: DeviceSize);
# [doc = include_str ! ("../../../doc/vkCmdCopyBuffer.md")]
#[doc(alias = "vkCmdCopyBuffer")]
pub type FNCmdCopyBuffer = unsafe extern "system" fn(
    command_buffer: CommandBuffer,
    src_buffer: Buffer,
    dst_buffer: Buffer,
    region_count: u32,
    p_regions: *const BufferCopy,
);
# [doc = include_str ! ("../../../doc/vkCmdCopyImage.md")]
#[doc(alias = "vkCmdCopyImage")]
pub type FNCmdCopyImage = unsafe extern "system" fn(
    command_buffer: CommandBuffer,
    src_image: Image,
    src_image_layout: ImageLayout,
    dst_image: Image,
    dst_image_layout: ImageLayout,
    region_count: u32,
    p_regions: *const ImageCopy,
);
# [doc = include_str ! ("../../../doc/vkCmdBlitImage.md")]
#[doc(alias = "vkCmdBlitImage")]
pub type FNCmdBlitImage = unsafe extern "system" fn(
    command_buffer: CommandBuffer,
    src_image: Image,
    src_image_layout: ImageLayout,
    dst_image: Image,
    dst_image_layout: ImageLayout,
    region_count: u32,
    p_regions: *const ImageBlit,
    filter: Filter,
);
# [doc = include_str ! ("../../../doc/vkCmdCopyBufferToImage.md")]
#[doc(alias = "vkCmdCopyBufferToImage")]
pub type FNCmdCopyBufferToImage = unsafe extern "system" fn(
    command_buffer: CommandBuffer,
    src_buffer: Buffer,
    dst_image: Image,
    dst_image_layout: ImageLayout,
    region_count: u32,
    p_regions: *const BufferImageCopy,
);
# [doc = include_str ! ("../../../doc/vkCmdCopyImageToBuffer.md")]
#[doc(alias = "vkCmdCopyImageToBuffer")]
pub type FNCmdCopyImageToBuffer = unsafe extern "system" fn(
    command_buffer: CommandBuffer,
    src_image: Image,
    src_image_layout: ImageLayout,
    dst_buffer: Buffer,
    region_count: u32,
    p_regions: *const BufferImageCopy,
);
# [doc = include_str ! ("../../../doc/vkCmdUpdateBuffer.md")]
#[doc(alias = "vkCmdUpdateBuffer")]
pub type FNCmdUpdateBuffer = unsafe extern "system" fn(
    command_buffer: CommandBuffer,
    dst_buffer: Buffer,
    dst_offset: DeviceSize,
    data_size: DeviceSize,
    p_data: *const std::ffi::c_void,
);
# [doc = include_str ! ("../../../doc/vkCmdFillBuffer.md")]
#[doc(alias = "vkCmdFillBuffer")]
pub type FNCmdFillBuffer = unsafe extern "system" fn(
    command_buffer: CommandBuffer,
    dst_buffer: Buffer,
    dst_offset: DeviceSize,
    size: DeviceSize,
    data: u32,
);
# [doc = include_str ! ("../../../doc/vkCmdClearColorImage.md")]
#[doc(alias = "vkCmdClearColorImage")]
pub type FNCmdClearColorImage = unsafe extern "system" fn(
    command_buffer: CommandBuffer,
    image: Image,
    image_layout: ImageLayout,
    p_color: *const ClearColorValue,
    range_count: u32,
    p_ranges: *const ImageSubresourceRange,
);
# [doc = include_str ! ("../../../doc/vkCmdClearDepthStencilImage.md")]
#[doc(alias = "vkCmdClearDepthStencilImage")]
pub type FNCmdClearDepthStencilImage = unsafe extern "system" fn(
    command_buffer: CommandBuffer,
    image: Image,
    image_layout: ImageLayout,
    p_depth_stencil: *const ClearDepthStencilValue,
    range_count: u32,
    p_ranges: *const ImageSubresourceRange,
);
# [doc = include_str ! ("../../../doc/vkCmdClearAttachments.md")]
#[doc(alias = "vkCmdClearAttachments")]
pub type FNCmdClearAttachments = unsafe extern "system" fn(
    command_buffer: CommandBuffer,
    attachment_count: u32,
    p_attachments: *const ClearAttachment,
    rect_count: u32,
    p_rects: *const ClearRect,
);
# [doc = include_str ! ("../../../doc/vkCmdResolveImage.md")]
#[doc(alias = "vkCmdResolveImage")]
pub type FNCmdResolveImage = unsafe extern "system" fn(
    command_buffer: CommandBuffer,
    src_image: Image,
    src_image_layout: ImageLayout,
    dst_image: Image,
    dst_image_layout: ImageLayout,
    region_count: u32,
    p_regions: *const ImageResolve,
);
# [doc = include_str ! ("../../../doc/vkCmdSetEvent.md")]
#[doc(alias = "vkCmdSetEvent")]
pub type FNCmdSetEvent =
    unsafe extern "system" fn(command_buffer: CommandBuffer, event: Event, stage_mask: PipelineStageFlags);
# [doc = include_str ! ("../../../doc/vkCmdResetEvent.md")]
#[doc(alias = "vkCmdResetEvent")]
pub type FNCmdResetEvent =
    unsafe extern "system" fn(command_buffer: CommandBuffer, event: Event, stage_mask: PipelineStageFlags);
# [doc = include_str ! ("../../../doc/vkCmdWaitEvents.md")]
#[doc(alias = "vkCmdWaitEvents")]
pub type FNCmdWaitEvents = unsafe extern "system" fn(
    command_buffer: CommandBuffer,
    event_count: u32,
    p_events: *const Event,
    src_stage_mask: PipelineStageFlags,
    dst_stage_mask: PipelineStageFlags,
    memory_barrier_count: u32,
    p_memory_barriers: *const MemoryBarrier,
    buffer_memory_barrier_count: u32,
    p_buffer_memory_barriers: *const BufferMemoryBarrier,
    image_memory_barrier_count: u32,
    p_image_memory_barriers: *const ImageMemoryBarrier,
);
# [doc = include_str ! ("../../../doc/vkCmdPipelineBarrier.md")]
#[doc(alias = "vkCmdPipelineBarrier")]
pub type FNCmdPipelineBarrier = unsafe extern "system" fn(
    command_buffer: CommandBuffer,
    src_stage_mask: PipelineStageFlags,
    dst_stage_mask: PipelineStageFlags,
    dependency_flags: DependencyFlags,
    memory_barrier_count: u32,
    p_memory_barriers: *const MemoryBarrier,
    buffer_memory_barrier_count: u32,
    p_buffer_memory_barriers: *const BufferMemoryBarrier,
    image_memory_barrier_count: u32,
    p_image_memory_barriers: *const ImageMemoryBarrier,
);
# [doc = include_str ! ("../../../doc/vkCmdBeginQuery.md")]
#[doc(alias = "vkCmdBeginQuery")]
pub type FNCmdBeginQuery = unsafe extern "system" fn(
    command_buffer: CommandBuffer,
    query_pool: QueryPool,
    query: u32,
    flags: QueryControlFlags,
);
# [doc = include_str ! ("../../../doc/vkCmdEndQuery.md")]
#[doc(alias = "vkCmdEndQuery")]
pub type FNCmdEndQuery = unsafe extern "system" fn(command_buffer: CommandBuffer, query_pool: QueryPool, query: u32);
# [doc = include_str ! ("../../../doc/vkCmdResetQueryPool.md")]
#[doc(alias = "vkCmdResetQueryPool")]
pub type FNCmdResetQueryPool =
    unsafe extern "system" fn(command_buffer: CommandBuffer, query_pool: QueryPool, first_query: u32, query_count: u32);
# [doc = include_str ! ("../../../doc/vkCmdWriteTimestamp.md")]
#[doc(alias = "vkCmdWriteTimestamp")]
pub type FNCmdWriteTimestamp = unsafe extern "system" fn(
    command_buffer: CommandBuffer,
    pipeline_stage: PipelineStageFlagBits,
    query_pool: QueryPool,
    query: u32,
);
# [doc = include_str ! ("../../../doc/vkCmdCopyQueryPoolResults.md")]
#[doc(alias = "vkCmdCopyQueryPoolResults")]
pub type FNCmdCopyQueryPoolResults = unsafe extern "system" fn(
    command_buffer: CommandBuffer,
    query_pool: QueryPool,
    first_query: u32,
    query_count: u32,
    dst_buffer: Buffer,
    dst_offset: DeviceSize,
    stride: DeviceSize,
    flags: QueryResultFlags,
);
# [doc = include_str ! ("../../../doc/vkCmdPushConstants.md")]
#[doc(alias = "vkCmdPushConstants")]
pub type FNCmdPushConstants = unsafe extern "system" fn(
    command_buffer: CommandBuffer,
    layout: PipelineLayout,
    stage_flags: ShaderStageFlags,
    offset: u32,
    size: u32,
    p_values: *const std::ffi::c_void,
);
# [doc = include_str ! ("../../../doc/vkCmdBeginRenderPass.md")]
#[doc(alias = "vkCmdBeginRenderPass")]
pub type FNCmdBeginRenderPass = unsafe extern "system" fn(
    command_buffer: CommandBuffer,
    p_render_pass_begin: *const RenderPassBeginInfo,
    contents: SubpassContents,
);
# [doc = include_str ! ("../../../doc/vkCmdNextSubpass.md")]
#[doc(alias = "vkCmdNextSubpass")]
pub type FNCmdNextSubpass = unsafe extern "system" fn(command_buffer: CommandBuffer, contents: SubpassContents);
# [doc = include_str ! ("../../../doc/vkCmdEndRenderPass.md")]
#[doc(alias = "vkCmdEndRenderPass")]
pub type FNCmdEndRenderPass = unsafe extern "system" fn(command_buffer: CommandBuffer);
# [doc = include_str ! ("../../../doc/vkCmdExecuteCommands.md")]
#[doc(alias = "vkCmdExecuteCommands")]
pub type FNCmdExecuteCommands = unsafe extern "system" fn(
    command_buffer: CommandBuffer,
    command_buffer_count: u32,
    p_command_buffers: *const CommandBuffer,
);
