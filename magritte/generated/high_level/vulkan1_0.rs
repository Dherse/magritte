pub use crate::common::vulkan1_0::{
    AccessFlagBits, AccessFlags, AttachmentDescription, AttachmentDescriptionFlagBits, AttachmentDescriptionFlags,
    AttachmentLoadOp, AttachmentReference, AttachmentStoreOp, BlendFactor, BlendOp, Bool32, BorderColor, BufferCopy,
    BufferCreateFlagBits, BufferCreateFlags, BufferImageCopy, BufferUsageFlagBits, BufferUsageFlags,
    BufferViewCreateFlags, ClearDepthStencilValue, ClearRect, ColorComponentFlagBits, ColorComponentFlags,
    CommandBufferLevel, CommandBufferResetFlagBits, CommandBufferResetFlags, CommandBufferUsageFlagBits,
    CommandBufferUsageFlags, CommandPoolCreateFlagBits, CommandPoolCreateFlags, CommandPoolResetFlagBits,
    CommandPoolResetFlags, CompareOp, ComponentMapping, ComponentSwizzle, CullModeFlagBits, CullModeFlags,
    DependencyFlagBits, DependencyFlags, DescriptorPoolCreateFlagBits, DescriptorPoolCreateFlags,
    DescriptorPoolResetFlags, DescriptorPoolSize, DescriptorSetLayoutCreateFlagBits, DescriptorSetLayoutCreateFlags,
    DescriptorType, DeviceAddress, DeviceCreateFlags, DeviceQueueCreateFlags, DeviceSize, DispatchIndirectCommand,
    DrawIndexedIndirectCommand, DrawIndirectCommand, DynamicState, EventCreateFlagBits, EventCreateFlags, Extent2D,
    Extent3D, FenceCreateFlagBits, FenceCreateFlags, Filter, Flags, Format, FormatFeatureFlagBits, FormatFeatureFlags,
    FormatProperties, FramebufferCreateFlagBits, FramebufferCreateFlags, FrontFace, ImageAspectFlagBits,
    ImageAspectFlags, ImageBlit, ImageCopy, ImageCreateFlagBits, ImageCreateFlags, ImageFormatProperties, ImageLayout,
    ImageResolve, ImageSubresource, ImageSubresourceLayers, ImageSubresourceRange, ImageTiling, ImageType,
    ImageUsageFlagBits, ImageUsageFlags, ImageViewCreateFlagBits, ImageViewCreateFlags, ImageViewType, IndexType,
    InstanceCreateFlagBits, InstanceCreateFlags, InternalAllocationType, LogicOp, MemoryHeap, MemoryHeapFlagBits,
    MemoryHeapFlags, MemoryMapFlags, MemoryPropertyFlagBits, MemoryPropertyFlags, MemoryRequirements, MemoryType,
    ObjectType, Offset2D, Offset3D, PhysicalDeviceMemoryProperties, PhysicalDeviceType, PipelineBindPoint,
    PipelineCacheCreateFlags, PipelineCacheHeaderVersion, PipelineCacheHeaderVersionOne,
    PipelineColorBlendStateCreateFlags, PipelineCreateFlagBits, PipelineCreateFlags,
    PipelineDepthStencilStateCreateFlags, PipelineDynamicStateCreateFlags, PipelineInputAssemblyStateCreateFlags,
    PipelineLayoutCreateFlags, PipelineMultisampleStateCreateFlags, PipelineRasterizationStateCreateFlags,
    PipelineShaderStageCreateFlagBits, PipelineShaderStageCreateFlags, PipelineStageFlagBits, PipelineStageFlags,
    PipelineTessellationStateCreateFlags, PipelineVertexInputStateCreateFlags, PipelineViewportStateCreateFlags,
    PolygonMode, PrimitiveTopology, PushConstantRange, QueryControlFlagBits, QueryControlFlags,
    QueryPipelineStatisticFlagBits, QueryPipelineStatisticFlags, QueryPoolCreateFlags, QueryResultFlagBits,
    QueryResultFlags, QueryType, QueueFamilyProperties, QueueFlagBits, QueueFlags, Rect2D, RenderPassCreateFlagBits,
    RenderPassCreateFlags, SampleCountFlagBits, SampleCountFlags, SampleMask, SamplerAddressMode,
    SamplerCreateFlagBits, SamplerCreateFlags, SamplerMipmapMode, SemaphoreCreateFlags, ShaderModuleCreateFlags,
    ShaderStageFlagBits, ShaderStageFlags, SharingMode, SparseImageFormatFlagBits, SparseImageFormatFlags,
    SparseImageFormatProperties, SparseImageMemoryRequirements, SparseMemoryBindFlagBits, SparseMemoryBindFlags,
    SpecializationMapEntry, StencilFaceFlagBits, StencilFaceFlags, StencilOp, StencilOpState, StructureType,
    SubpassContents, SubpassDependency, SubpassDescriptionFlagBits, SubpassDescriptionFlags, SubresourceLayout,
    SystemAllocationScope, VendorId, VertexInputAttributeDescription, VertexInputBindingDescription, VertexInputRate,
    Viewport, VulkanResultCodes, ATTACHMENT_UNUSED, FALSE, LOD_CLAMP_NONE, LUID_SIZE, MAX_DESCRIPTION_SIZE,
    MAX_DEVICE_GROUP_SIZE, MAX_DRIVER_INFO_SIZE, MAX_DRIVER_NAME_SIZE, MAX_EXTENSION_NAME_SIZE,
    MAX_GLOBAL_PRIORITY_SIZE_KHR, MAX_MEMORY_HEAPS, MAX_MEMORY_TYPES, MAX_PHYSICAL_DEVICE_NAME_SIZE,
    QUEUE_FAMILY_EXTERNAL, QUEUE_FAMILY_FOREIGN_EXT, QUEUE_FAMILY_IGNORED, REMAINING_ARRAY_LAYERS,
    REMAINING_MIP_LEVELS, SHADER_UNUSED_KHR, SUBPASS_EXTERNAL, TRUE, UUID_SIZE, WHOLE_SIZE,
};
#[cfg(feature = "VK_AMD_device_coherent_memory")]
use crate::extensions::amd_device_coherent_memory::PhysicalDeviceCoherentMemoryFeaturesAMD;
#[cfg(feature = "VK_AMD_memory_overallocation_behavior")]
use crate::extensions::amd_memory_overallocation_behavior::DeviceMemoryOverallocationCreateInfoAMD;
#[cfg(feature = "VK_AMD_pipeline_compiler_control")]
use crate::extensions::amd_pipeline_compiler_control::PipelineCompilerControlCreateInfoAMD;
#[cfg(feature = "VK_AMD_rasterization_order")]
use crate::extensions::amd_rasterization_order::PipelineRasterizationStateRasterizationOrderAMD;
#[cfg(feature = "VK_ANDROID_external_memory_android_hardware_buffer")]
use crate::extensions::android_external_memory_android_hardware_buffer::ExternalFormatANDROID;
#[cfg(feature = "VK_ANDROID_external_memory_android_hardware_buffer")]
use crate::extensions::android_external_memory_android_hardware_buffer::ImportAndroidHardwareBufferInfoANDROID;
#[cfg(feature = "VK_ARM_rasterization_order_attachment_access")]
use crate::extensions::arm_rasterization_order_attachment_access::PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesARM;
#[cfg(feature = "VK_EXT_4444_formats")]
use crate::extensions::ext_4444_formats::PhysicalDevice4444FormatsFeaturesEXT;
#[cfg(feature = "VK_EXT_astc_decode_mode")]
use crate::extensions::ext_astc_decode_mode::ImageViewAstcDecodeModeEXT;
#[cfg(feature = "VK_EXT_astc_decode_mode")]
use crate::extensions::ext_astc_decode_mode::PhysicalDeviceAstcDecodeFeaturesEXT;
#[cfg(feature = "VK_EXT_blend_operation_advanced")]
use crate::extensions::ext_blend_operation_advanced::PhysicalDeviceBlendOperationAdvancedFeaturesEXT;
#[cfg(feature = "VK_EXT_blend_operation_advanced")]
use crate::extensions::ext_blend_operation_advanced::PipelineColorBlendAdvancedStateCreateInfoEXT;
#[cfg(feature = "VK_EXT_border_color_swizzle")]
use crate::extensions::ext_border_color_swizzle::PhysicalDeviceBorderColorSwizzleFeaturesEXT;
#[cfg(feature = "VK_EXT_border_color_swizzle")]
use crate::extensions::ext_border_color_swizzle::SamplerBorderColorComponentMappingCreateInfoEXT;
#[cfg(feature = "VK_EXT_buffer_device_address")]
use crate::extensions::ext_buffer_device_address::BufferDeviceAddressCreateInfoEXT;
#[cfg(feature = "VK_EXT_buffer_device_address")]
use crate::extensions::ext_buffer_device_address::PhysicalDeviceBufferDeviceAddressFeaturesEXT;
#[cfg(feature = "VK_EXT_calibrated_timestamps")]
use crate::extensions::ext_calibrated_timestamps::CalibratedTimestampInfoEXT;
#[cfg(feature = "VK_EXT_calibrated_timestamps")]
use crate::extensions::ext_calibrated_timestamps::TimeDomainEXT;
#[cfg(feature = "VK_EXT_color_write_enable")]
use crate::extensions::ext_color_write_enable::PhysicalDeviceColorWriteEnableFeaturesEXT;
#[cfg(feature = "VK_EXT_color_write_enable")]
use crate::extensions::ext_color_write_enable::PipelineColorWriteCreateInfoEXT;
#[cfg(feature = "VK_EXT_conditional_rendering")]
use crate::extensions::ext_conditional_rendering::CommandBufferInheritanceConditionalRenderingInfoEXT;
#[cfg(feature = "VK_EXT_conditional_rendering")]
use crate::extensions::ext_conditional_rendering::ConditionalRenderingBeginInfoEXT;
#[cfg(feature = "VK_EXT_conditional_rendering")]
use crate::extensions::ext_conditional_rendering::PhysicalDeviceConditionalRenderingFeaturesEXT;
#[cfg(feature = "VK_EXT_conservative_rasterization")]
use crate::extensions::ext_conservative_rasterization::PipelineRasterizationConservativeStateCreateInfoEXT;
#[cfg(feature = "VK_EXT_custom_border_color")]
use crate::extensions::ext_custom_border_color::PhysicalDeviceCustomBorderColorFeaturesEXT;
#[cfg(feature = "VK_EXT_custom_border_color")]
use crate::extensions::ext_custom_border_color::SamplerCustomBorderColorCreateInfoEXT;
#[cfg(feature = "VK_EXT_debug_marker")]
use crate::extensions::ext_debug_marker::DebugMarkerMarkerInfoEXT;
#[cfg(feature = "VK_EXT_debug_marker")]
use crate::extensions::ext_debug_marker::DebugMarkerObjectNameInfoEXT;
#[cfg(feature = "VK_EXT_debug_marker")]
use crate::extensions::ext_debug_marker::DebugMarkerObjectTagInfoEXT;
#[cfg(feature = "VK_EXT_debug_marker")]
use crate::extensions::ext_debug_marker::DebugReportObjectTypeEXT;
#[cfg(feature = "VK_EXT_debug_report")]
use crate::extensions::ext_debug_report::DebugReportCallbackCreateInfoEXT;
#[cfg(feature = "VK_EXT_debug_report")]
use crate::extensions::ext_debug_report::DebugReportFlagsEXT;
#[cfg(feature = "VK_EXT_debug_utils")]
use crate::extensions::ext_debug_utils::DebugUtilsLabelEXT;
#[cfg(feature = "VK_EXT_debug_utils")]
use crate::extensions::ext_debug_utils::DebugUtilsMessageSeverityFlagBitsEXT;
#[cfg(feature = "VK_EXT_debug_utils")]
use crate::extensions::ext_debug_utils::DebugUtilsMessageTypeFlagsEXT;
#[cfg(feature = "VK_EXT_debug_utils")]
use crate::extensions::ext_debug_utils::DebugUtilsMessengerCallbackDataEXT;
#[cfg(feature = "VK_EXT_debug_utils")]
use crate::extensions::ext_debug_utils::DebugUtilsMessengerCreateInfoEXT;
#[cfg(feature = "VK_EXT_debug_utils")]
use crate::extensions::ext_debug_utils::DebugUtilsObjectNameInfoEXT;
#[cfg(feature = "VK_EXT_debug_utils")]
use crate::extensions::ext_debug_utils::DebugUtilsObjectTagInfoEXT;
#[cfg(feature = "VK_EXT_depth_clip_control")]
use crate::extensions::ext_depth_clip_control::PhysicalDeviceDepthClipControlFeaturesEXT;
#[cfg(feature = "VK_EXT_depth_clip_control")]
use crate::extensions::ext_depth_clip_control::PipelineViewportDepthClipControlCreateInfoEXT;
#[cfg(feature = "VK_EXT_depth_clip_enable")]
use crate::extensions::ext_depth_clip_enable::PhysicalDeviceDepthClipEnableFeaturesEXT;
#[cfg(feature = "VK_EXT_depth_clip_enable")]
use crate::extensions::ext_depth_clip_enable::PipelineRasterizationDepthClipStateCreateInfoEXT;
#[cfg(feature = "VK_EXT_device_memory_report")]
use crate::extensions::ext_device_memory_report::DeviceDeviceMemoryReportCreateInfoEXT;
#[cfg(feature = "VK_EXT_device_memory_report")]
use crate::extensions::ext_device_memory_report::PhysicalDeviceDeviceMemoryReportFeaturesEXT;
#[cfg(feature = "VK_EXT_discard_rectangles")]
use crate::extensions::ext_discard_rectangles::PipelineDiscardRectangleStateCreateInfoEXT;
#[cfg(feature = "VK_EXT_display_control")]
use crate::extensions::ext_display_control::DisplayPowerInfoEXT;
#[cfg(feature = "VK_EXT_display_surface_counter")]
use crate::extensions::ext_display_surface_counter::SurfaceCapabilities2EXT;
#[cfg(feature = "VK_EXT_display_surface_counter")]
use crate::extensions::ext_display_surface_counter::SurfaceCounterFlagBitsEXT;
#[cfg(feature = "VK_EXT_extended_dynamic_state")]
use crate::extensions::ext_extended_dynamic_state::PhysicalDeviceExtendedDynamicStateFeaturesEXT;
#[cfg(feature = "VK_EXT_extended_dynamic_state2")]
use crate::extensions::ext_extended_dynamic_state2::PhysicalDeviceExtendedDynamicState2FeaturesEXT;
#[cfg(feature = "VK_EXT_external_memory_host")]
use crate::extensions::ext_external_memory_host::ImportMemoryHostPointerInfoEXT;
#[cfg(feature = "VK_EXT_fragment_density_map")]
use crate::extensions::ext_fragment_density_map::PhysicalDeviceFragmentDensityMapFeaturesEXT;
#[cfg(feature = "VK_EXT_fragment_density_map")]
use crate::extensions::ext_fragment_density_map::RenderPassFragmentDensityMapCreateInfoEXT;
#[cfg(feature = "VK_EXT_fragment_density_map2")]
use crate::extensions::ext_fragment_density_map2::PhysicalDeviceFragmentDensityMap2FeaturesEXT;
#[cfg(feature = "VK_EXT_fragment_shader_interlock")]
use crate::extensions::ext_fragment_shader_interlock::PhysicalDeviceFragmentShaderInterlockFeaturesEXT;
#[cfg(feature = "VK_EXT_hdr_metadata")]
use crate::extensions::ext_hdr_metadata::HdrMetadataEXT;
#[cfg(feature = "VK_EXT_image_drm_format_modifier")]
use crate::extensions::ext_image_drm_format_modifier::ImageDrmFormatModifierExplicitCreateInfoEXT;
#[cfg(feature = "VK_EXT_image_drm_format_modifier")]
use crate::extensions::ext_image_drm_format_modifier::ImageDrmFormatModifierListCreateInfoEXT;
#[cfg(feature = "VK_EXT_image_drm_format_modifier")]
use crate::extensions::ext_image_drm_format_modifier::ImageDrmFormatModifierPropertiesEXT;
#[cfg(feature = "VK_EXT_image_view_min_lod")]
use crate::extensions::ext_image_view_min_lod::ImageViewMinLodCreateInfoEXT;
#[cfg(feature = "VK_EXT_image_view_min_lod")]
use crate::extensions::ext_image_view_min_lod::PhysicalDeviceImageViewMinLodFeaturesEXT;
#[cfg(feature = "VK_EXT_index_type_uint8")]
use crate::extensions::ext_index_type_uint8::PhysicalDeviceIndexTypeUint8FeaturesEXT;
#[cfg(feature = "VK_EXT_line_rasterization")]
use crate::extensions::ext_line_rasterization::PhysicalDeviceLineRasterizationFeaturesEXT;
#[cfg(feature = "VK_EXT_line_rasterization")]
use crate::extensions::ext_line_rasterization::PipelineRasterizationLineStateCreateInfoEXT;
#[cfg(feature = "VK_EXT_memory_priority")]
use crate::extensions::ext_memory_priority::MemoryPriorityAllocateInfoEXT;
#[cfg(feature = "VK_EXT_memory_priority")]
use crate::extensions::ext_memory_priority::PhysicalDeviceMemoryPriorityFeaturesEXT;
#[cfg(feature = "VK_EXT_multi_draw")]
use crate::extensions::ext_multi_draw::MultiDrawIndexedInfoEXT;
#[cfg(feature = "VK_EXT_multi_draw")]
use crate::extensions::ext_multi_draw::MultiDrawInfoEXT;
#[cfg(feature = "VK_EXT_multi_draw")]
use crate::extensions::ext_multi_draw::PhysicalDeviceMultiDrawFeaturesEXT;
#[cfg(feature = "VK_EXT_pageable_device_local_memory")]
use crate::extensions::ext_pageable_device_local_memory::PhysicalDevicePageableDeviceLocalMemoryFeaturesEXT;
#[cfg(feature = "VK_EXT_primitive_topology_list_restart")]
use crate::extensions::ext_primitive_topology_list_restart::PhysicalDevicePrimitiveTopologyListRestartFeaturesEXT;
#[cfg(feature = "VK_EXT_provoking_vertex")]
use crate::extensions::ext_provoking_vertex::PhysicalDeviceProvokingVertexFeaturesEXT;
#[cfg(feature = "VK_EXT_provoking_vertex")]
use crate::extensions::ext_provoking_vertex::PipelineRasterizationProvokingVertexStateCreateInfoEXT;
#[cfg(feature = "VK_EXT_rgba10x6_formats")]
use crate::extensions::ext_rgba10x6_formats::PhysicalDeviceRgba10x6FormatsFeaturesEXT;
#[cfg(feature = "VK_EXT_robustness2")]
use crate::extensions::ext_robustness2::PhysicalDeviceRobustness2FeaturesEXT;
#[cfg(feature = "VK_EXT_sample_locations")]
use crate::extensions::ext_sample_locations::MultisamplePropertiesEXT;
#[cfg(feature = "VK_EXT_sample_locations")]
use crate::extensions::ext_sample_locations::PipelineSampleLocationsStateCreateInfoEXT;
#[cfg(feature = "VK_EXT_sample_locations")]
use crate::extensions::ext_sample_locations::RenderPassSampleLocationsBeginInfoEXT;
#[cfg(feature = "VK_EXT_sample_locations")]
use crate::extensions::ext_sample_locations::SampleLocationsInfoEXT;
#[cfg(feature = "VK_EXT_shader_atomic_float")]
use crate::extensions::ext_shader_atomic_float::PhysicalDeviceShaderAtomicFloatFeaturesEXT;
#[cfg(feature = "VK_EXT_shader_atomic_float2")]
use crate::extensions::ext_shader_atomic_float2::PhysicalDeviceShaderAtomicFloat2FeaturesEXT;
#[cfg(feature = "VK_EXT_shader_image_atomic_int64")]
use crate::extensions::ext_shader_image_atomic_int64::PhysicalDeviceShaderImageAtomicInt64FeaturesEXT;
#[cfg(feature = "VK_EXT_texel_buffer_alignment")]
use crate::extensions::ext_texel_buffer_alignment::PhysicalDeviceTexelBufferAlignmentFeaturesEXT;
#[cfg(feature = "VK_EXT_transform_feedback")]
use crate::extensions::ext_transform_feedback::PhysicalDeviceTransformFeedbackFeaturesEXT;
#[cfg(feature = "VK_EXT_transform_feedback")]
use crate::extensions::ext_transform_feedback::PipelineRasterizationStateStreamCreateInfoEXT;
#[cfg(feature = "VK_EXT_validation_cache")]
use crate::extensions::ext_validation_cache::ShaderModuleValidationCacheCreateInfoEXT;
#[cfg(feature = "VK_EXT_validation_cache")]
use crate::extensions::ext_validation_cache::ValidationCacheEXT;
#[cfg(feature = "VK_EXT_validation_features")]
use crate::extensions::ext_validation_features::ValidationFeaturesEXT;
#[cfg(feature = "VK_EXT_validation_flags")]
use crate::extensions::ext_validation_flags::ValidationFlagsEXT;
#[cfg(feature = "VK_EXT_vertex_attribute_divisor")]
use crate::extensions::ext_vertex_attribute_divisor::PhysicalDeviceVertexAttributeDivisorFeaturesEXT;
#[cfg(feature = "VK_EXT_vertex_attribute_divisor")]
use crate::extensions::ext_vertex_attribute_divisor::PipelineVertexInputDivisorStateCreateInfoEXT;
#[cfg(feature = "VK_EXT_vertex_input_dynamic_state")]
use crate::extensions::ext_vertex_input_dynamic_state::PhysicalDeviceVertexInputDynamicStateFeaturesEXT;
#[cfg(feature = "VK_EXT_vertex_input_dynamic_state")]
use crate::extensions::ext_vertex_input_dynamic_state::VertexInputAttributeDescription2EXT;
#[cfg(feature = "VK_EXT_vertex_input_dynamic_state")]
use crate::extensions::ext_vertex_input_dynamic_state::VertexInputBindingDescription2EXT;
#[cfg(feature = "VK_EXT_ycbcr_2plane_444_formats")]
use crate::extensions::ext_ycbcr_2plane_444_formats::PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT;
#[cfg(feature = "VK_EXT_ycbcr_image_arrays")]
use crate::extensions::ext_ycbcr_image_arrays::PhysicalDeviceYcbcrImageArraysFeaturesEXT;
#[cfg(feature = "VK_FUCHSIA_buffer_collection")]
use crate::extensions::fuchsia_buffer_collection::BufferCollectionBufferCreateInfoFUCHSIA;
#[cfg(feature = "VK_FUCHSIA_buffer_collection")]
use crate::extensions::fuchsia_buffer_collection::BufferCollectionFUCHSIA;
#[cfg(feature = "VK_FUCHSIA_buffer_collection")]
use crate::extensions::fuchsia_buffer_collection::BufferCollectionImageCreateInfoFUCHSIA;
#[cfg(feature = "VK_FUCHSIA_buffer_collection")]
use crate::extensions::fuchsia_buffer_collection::BufferCollectionPropertiesFUCHSIA;
#[cfg(feature = "VK_FUCHSIA_buffer_collection")]
use crate::extensions::fuchsia_buffer_collection::BufferConstraintsInfoFUCHSIA;
#[cfg(feature = "VK_FUCHSIA_buffer_collection")]
use crate::extensions::fuchsia_buffer_collection::ImageConstraintsInfoFUCHSIA;
#[cfg(feature = "VK_FUCHSIA_buffer_collection")]
use crate::extensions::fuchsia_buffer_collection::ImportMemoryBufferCollectionFUCHSIA;
#[cfg(feature = "VK_FUCHSIA_external_memory")]
use crate::extensions::fuchsia_external_memory::ImportMemoryZirconHandleInfoFUCHSIA;
#[cfg(feature = "VK_GOOGLE_display_timing")]
use crate::extensions::google_display_timing::PastPresentationTimingGOOGLE;
#[cfg(feature = "VK_GOOGLE_display_timing")]
use crate::extensions::google_display_timing::RefreshCycleDurationGOOGLE;
#[cfg(feature = "VK_HUAWEI_invocation_mask")]
use crate::extensions::huawei_invocation_mask::PhysicalDeviceInvocationMaskFeaturesHUAWEI;
#[cfg(feature = "VK_HUAWEI_subpass_shading")]
use crate::extensions::huawei_subpass_shading::PhysicalDeviceSubpassShadingFeaturesHUAWEI;
#[cfg(feature = "VK_HUAWEI_subpass_shading")]
use crate::extensions::huawei_subpass_shading::SubpassShadingPipelineCreateInfoHUAWEI;
#[cfg(feature = "VK_INTEL_performance_query")]
use crate::extensions::intel_performance_query::InitializePerformanceApiInfoINTEL;
#[cfg(feature = "VK_INTEL_performance_query")]
use crate::extensions::intel_performance_query::PerformanceConfigurationAcquireInfoINTEL;
#[cfg(feature = "VK_INTEL_performance_query")]
use crate::extensions::intel_performance_query::PerformanceConfigurationINTEL;
#[cfg(feature = "VK_INTEL_performance_query")]
use crate::extensions::intel_performance_query::PerformanceMarkerInfoINTEL;
#[cfg(feature = "VK_INTEL_performance_query")]
use crate::extensions::intel_performance_query::PerformanceOverrideInfoINTEL;
#[cfg(feature = "VK_INTEL_performance_query")]
use crate::extensions::intel_performance_query::PerformanceParameterTypeINTEL;
#[cfg(feature = "VK_INTEL_performance_query")]
use crate::extensions::intel_performance_query::PerformanceStreamMarkerInfoINTEL;
#[cfg(feature = "VK_INTEL_performance_query")]
use crate::extensions::intel_performance_query::PerformanceValueINTEL;
#[cfg(feature = "VK_INTEL_performance_query")]
use crate::extensions::intel_performance_query::QueryPoolPerformanceQueryCreateInfoINTEL;
#[cfg(feature = "VK_INTEL_shader_integer_functions2")]
use crate::extensions::intel_shader_integer_functions2::PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL;
#[cfg(feature = "VK_KHR_acceleration_structure")]
use crate::extensions::khr_acceleration_structure::AccelerationStructureBuildGeometryInfoKHR;
#[cfg(feature = "VK_KHR_acceleration_structure")]
use crate::extensions::khr_acceleration_structure::AccelerationStructureBuildRangeInfoKHR;
#[cfg(feature = "VK_KHR_acceleration_structure")]
use crate::extensions::khr_acceleration_structure::AccelerationStructureBuildSizesInfoKHR;
#[cfg(feature = "VK_KHR_acceleration_structure")]
use crate::extensions::khr_acceleration_structure::AccelerationStructureBuildTypeKHR;
#[cfg(feature = "VK_KHR_acceleration_structure")]
use crate::extensions::khr_acceleration_structure::AccelerationStructureCompatibilityKHR;
#[cfg(feature = "VK_KHR_acceleration_structure")]
use crate::extensions::khr_acceleration_structure::AccelerationStructureDeviceAddressInfoKHR;
#[cfg(feature = "VK_KHR_acceleration_structure")]
use crate::extensions::khr_acceleration_structure::AccelerationStructureKHR;
#[cfg(feature = "VK_KHR_acceleration_structure")]
use crate::extensions::khr_acceleration_structure::AccelerationStructureVersionInfoKHR;
#[cfg(feature = "VK_KHR_acceleration_structure")]
use crate::extensions::khr_acceleration_structure::CopyAccelerationStructureInfoKHR;
#[cfg(feature = "VK_KHR_acceleration_structure")]
use crate::extensions::khr_acceleration_structure::CopyAccelerationStructureModeKHR;
#[cfg(feature = "VK_KHR_acceleration_structure")]
use crate::extensions::khr_acceleration_structure::CopyAccelerationStructureToMemoryInfoKHR;
#[cfg(feature = "VK_KHR_acceleration_structure")]
use crate::extensions::khr_acceleration_structure::CopyMemoryToAccelerationStructureInfoKHR;
#[cfg(feature = "VK_KHR_acceleration_structure")]
use crate::extensions::khr_acceleration_structure::PhysicalDeviceAccelerationStructureFeaturesKHR;
#[cfg(feature = "VK_KHR_acceleration_structure")]
use crate::extensions::khr_acceleration_structure::WriteDescriptorSetAccelerationStructureKHR;
#[cfg(feature = "VK_KHR_deferred_host_operations")]
use crate::extensions::khr_deferred_host_operations::DeferredOperationKHR;
#[cfg(feature = "VK_KHR_device_group")]
use crate::extensions::khr_device_group::AcquireNextImageInfoKHR;
#[cfg(feature = "VK_KHR_device_group")]
use crate::extensions::khr_device_group::DeviceGroupPresentCapabilitiesKHR;
#[cfg(feature = "VK_KHR_device_group")]
use crate::extensions::khr_device_group::DeviceGroupPresentModeFlagsKHR;
#[cfg(feature = "VK_KHR_device_group")]
use crate::extensions::khr_device_group::ImageSwapchainCreateInfoKHR;
#[cfg(feature = "VK_KHR_display")]
use crate::extensions::khr_display::DisplayKHR;
#[cfg(feature = "VK_KHR_display")]
use crate::extensions::khr_display::DisplayModeKHR;
#[cfg(feature = "VK_KHR_display")]
use crate::extensions::khr_display::DisplayModePropertiesKHR;
#[cfg(feature = "VK_KHR_display")]
use crate::extensions::khr_display::DisplayPlaneCapabilitiesKHR;
#[cfg(feature = "VK_KHR_display")]
use crate::extensions::khr_display::DisplayPlanePropertiesKHR;
#[cfg(feature = "VK_KHR_display")]
use crate::extensions::khr_display::DisplayPropertiesKHR;
#[cfg(feature = "VK_KHR_dynamic_rendering")]
use crate::extensions::khr_dynamic_rendering::AttachmentSampleCountInfoAMD;
#[cfg(feature = "VK_KHR_dynamic_rendering")]
use crate::extensions::khr_dynamic_rendering::MultiviewPerViewAttributesInfoNVX;
#[cfg(feature = "VK_KHR_external_fence_fd")]
use crate::extensions::khr_external_fence_fd::FenceGetFdInfoKHR;
#[cfg(feature = "VK_KHR_external_fence_fd")]
use crate::extensions::khr_external_fence_fd::ImportFenceFdInfoKHR;
#[cfg(feature = "VK_KHR_external_fence_win32")]
use crate::extensions::khr_external_fence_win32::ExportFenceWin32HandleInfoKHR;
#[cfg(feature = "VK_KHR_external_memory_fd")]
use crate::extensions::khr_external_memory_fd::ImportMemoryFdInfoKHR;
#[cfg(feature = "VK_KHR_external_memory_fd")]
use crate::extensions::khr_external_memory_fd::MemoryFdPropertiesKHR;
#[cfg(feature = "VK_KHR_external_memory_fd")]
use crate::extensions::khr_external_memory_fd::MemoryGetFdInfoKHR;
#[cfg(feature = "VK_KHR_external_memory_win32")]
use crate::extensions::khr_external_memory_win32::ExportMemoryWin32HandleInfoKHR;
#[cfg(feature = "VK_KHR_external_memory_win32")]
use crate::extensions::khr_external_memory_win32::ImportMemoryWin32HandleInfoKHR;
#[cfg(feature = "VK_KHR_external_semaphore_fd")]
use crate::extensions::khr_external_semaphore_fd::ImportSemaphoreFdInfoKHR;
#[cfg(feature = "VK_KHR_external_semaphore_fd")]
use crate::extensions::khr_external_semaphore_fd::SemaphoreGetFdInfoKHR;
#[cfg(feature = "VK_KHR_external_semaphore_win32")]
use crate::extensions::khr_external_semaphore_win32::D3d12FenceSubmitInfoKHR;
#[cfg(feature = "VK_KHR_external_semaphore_win32")]
use crate::extensions::khr_external_semaphore_win32::ExportSemaphoreWin32HandleInfoKHR;
#[cfg(feature = "VK_KHR_fragment_shading_rate")]
use crate::extensions::khr_fragment_shading_rate::FragmentShadingRateCombinerOpKHR;
#[cfg(feature = "VK_KHR_fragment_shading_rate")]
use crate::extensions::khr_fragment_shading_rate::PhysicalDeviceFragmentShadingRateFeaturesKHR;
#[cfg(feature = "VK_KHR_fragment_shading_rate")]
use crate::extensions::khr_fragment_shading_rate::PhysicalDeviceFragmentShadingRateKHR;
#[cfg(feature = "VK_KHR_fragment_shading_rate")]
use crate::extensions::khr_fragment_shading_rate::PipelineFragmentShadingRateStateCreateInfoKHR;
#[cfg(feature = "VK_KHR_get_display_properties2")]
use crate::extensions::khr_get_display_properties2::DisplayModeProperties2KHR;
#[cfg(feature = "VK_KHR_get_display_properties2")]
use crate::extensions::khr_get_display_properties2::DisplayPlaneCapabilities2KHR;
#[cfg(feature = "VK_KHR_get_display_properties2")]
use crate::extensions::khr_get_display_properties2::DisplayPlaneInfo2KHR;
#[cfg(feature = "VK_KHR_get_display_properties2")]
use crate::extensions::khr_get_display_properties2::DisplayPlaneProperties2KHR;
#[cfg(feature = "VK_KHR_get_display_properties2")]
use crate::extensions::khr_get_display_properties2::DisplayProperties2KHR;
#[cfg(feature = "VK_KHR_get_surface_capabilities2")]
use crate::extensions::khr_get_surface_capabilities2::PhysicalDeviceSurfaceInfo2KHR;
#[cfg(feature = "VK_KHR_get_surface_capabilities2")]
use crate::extensions::khr_get_surface_capabilities2::SurfaceCapabilities2KHR;
#[cfg(feature = "VK_KHR_get_surface_capabilities2")]
use crate::extensions::khr_get_surface_capabilities2::SurfaceFormat2KHR;
#[cfg(feature = "VK_KHR_global_priority")]
use crate::extensions::khr_global_priority::DeviceQueueGlobalPriorityCreateInfoKHR;
#[cfg(feature = "VK_KHR_global_priority")]
use crate::extensions::khr_global_priority::PhysicalDeviceGlobalPriorityQueryFeaturesKHR;
#[cfg(feature = "VK_KHR_performance_query")]
use crate::extensions::khr_performance_query::AcquireProfilingLockInfoKHR;
#[cfg(feature = "VK_KHR_performance_query")]
use crate::extensions::khr_performance_query::PerformanceCounterDescriptionKHR;
#[cfg(feature = "VK_KHR_performance_query")]
use crate::extensions::khr_performance_query::PerformanceCounterKHR;
#[cfg(feature = "VK_KHR_performance_query")]
use crate::extensions::khr_performance_query::PerformanceQuerySubmitInfoKHR;
#[cfg(feature = "VK_KHR_performance_query")]
use crate::extensions::khr_performance_query::PhysicalDevicePerformanceQueryFeaturesKHR;
#[cfg(feature = "VK_KHR_performance_query")]
use crate::extensions::khr_performance_query::QueryPoolPerformanceCreateInfoKHR;
#[cfg(feature = "VK_KHR_pipeline_executable_properties")]
use crate::extensions::khr_pipeline_executable_properties::PhysicalDevicePipelineExecutablePropertiesFeaturesKHR;
#[cfg(feature = "VK_KHR_pipeline_executable_properties")]
use crate::extensions::khr_pipeline_executable_properties::PipelineExecutableInfoKHR;
#[cfg(feature = "VK_KHR_pipeline_executable_properties")]
use crate::extensions::khr_pipeline_executable_properties::PipelineExecutableInternalRepresentationKHR;
#[cfg(feature = "VK_KHR_pipeline_executable_properties")]
use crate::extensions::khr_pipeline_executable_properties::PipelineExecutablePropertiesKHR;
#[cfg(feature = "VK_KHR_pipeline_executable_properties")]
use crate::extensions::khr_pipeline_executable_properties::PipelineExecutableStatisticKHR;
#[cfg(feature = "VK_KHR_pipeline_executable_properties")]
use crate::extensions::khr_pipeline_executable_properties::PipelineInfoKHR;
#[cfg(feature = "VK_KHR_portability_subset")]
use crate::extensions::khr_portability_subset::PhysicalDevicePortabilitySubsetFeaturesKHR;
#[cfg(feature = "VK_KHR_present_id")]
use crate::extensions::khr_present_id::PhysicalDevicePresentIdFeaturesKHR;
#[cfg(feature = "VK_KHR_present_wait")]
use crate::extensions::khr_present_wait::PhysicalDevicePresentWaitFeaturesKHR;
#[cfg(feature = "VK_KHR_ray_query")]
use crate::extensions::khr_ray_query::PhysicalDeviceRayQueryFeaturesKHR;
#[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
use crate::extensions::khr_ray_tracing_pipeline::PhysicalDeviceRayTracingPipelineFeaturesKHR;
#[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
use crate::extensions::khr_ray_tracing_pipeline::ShaderGroupShaderKHR;
#[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
use crate::extensions::khr_ray_tracing_pipeline::StridedDeviceAddressRegionKHR;
#[cfg(feature = "VK_KHR_shader_clock")]
use crate::extensions::khr_shader_clock::PhysicalDeviceShaderClockFeaturesKHR;
#[cfg(feature = "VK_KHR_shader_subgroup_uniform_control_flow")]
use crate::extensions::khr_shader_subgroup_uniform_control_flow::PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR;
#[cfg(feature = "VK_KHR_surface")]
use crate::extensions::khr_surface::PresentModeKHR;
#[cfg(feature = "VK_KHR_surface")]
use crate::extensions::khr_surface::SurfaceCapabilitiesKHR;
#[cfg(feature = "VK_KHR_surface")]
use crate::extensions::khr_surface::SurfaceFormatKHR;
#[cfg(feature = "VK_KHR_surface")]
use crate::extensions::khr_surface::SurfaceKHR;
#[cfg(feature = "VK_KHR_swapchain")]
use crate::extensions::khr_swapchain::PresentInfoKHR;
#[cfg(feature = "VK_KHR_swapchain")]
use crate::extensions::khr_swapchain::SwapchainKHR;
#[cfg(feature = "VK_KHR_video_decode_queue")]
use crate::extensions::khr_video_decode_queue::VideoDecodeInfoKHR;
#[cfg(feature = "VK_KHR_video_encode_queue")]
use crate::extensions::khr_video_encode_queue::VideoEncodeInfoKHR;
#[cfg(feature = "VK_KHR_video_queue")]
use crate::extensions::khr_video_queue::PhysicalDeviceVideoFormatInfoKHR;
#[cfg(feature = "VK_KHR_video_queue")]
use crate::extensions::khr_video_queue::VideoBeginCodingInfoKHR;
#[cfg(feature = "VK_KHR_video_queue")]
use crate::extensions::khr_video_queue::VideoBindMemoryKHR;
#[cfg(feature = "VK_KHR_video_queue")]
use crate::extensions::khr_video_queue::VideoCapabilitiesKHR;
#[cfg(feature = "VK_KHR_video_queue")]
use crate::extensions::khr_video_queue::VideoCodingControlInfoKHR;
#[cfg(feature = "VK_KHR_video_queue")]
use crate::extensions::khr_video_queue::VideoEndCodingInfoKHR;
#[cfg(feature = "VK_KHR_video_queue")]
use crate::extensions::khr_video_queue::VideoFormatPropertiesKHR;
#[cfg(feature = "VK_KHR_video_queue")]
use crate::extensions::khr_video_queue::VideoGetMemoryPropertiesKHR;
#[cfg(feature = "VK_KHR_video_queue")]
use crate::extensions::khr_video_queue::VideoProfileKHR;
#[cfg(feature = "VK_KHR_video_queue")]
use crate::extensions::khr_video_queue::VideoProfilesKHR;
#[cfg(feature = "VK_KHR_video_queue")]
use crate::extensions::khr_video_queue::VideoSessionKHR;
#[cfg(feature = "VK_KHR_video_queue")]
use crate::extensions::khr_video_queue::VideoSessionParametersKHR;
#[cfg(feature = "VK_KHR_video_queue")]
use crate::extensions::khr_video_queue::VideoSessionParametersUpdateInfoKHR;
#[cfg(feature = "VK_KHR_win32_keyed_mutex")]
use crate::extensions::khr_win32_keyed_mutex::Win32KeyedMutexAcquireReleaseInfoKHR;
#[cfg(feature = "VK_KHR_workgroup_memory_explicit_layout")]
use crate::extensions::khr_workgroup_memory_explicit_layout::PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR;
#[cfg(feature = "VK_NV_clip_space_w_scaling")]
use crate::extensions::nv_clip_space_w_scaling::PipelineViewportWScalingStateCreateInfoNV;
#[cfg(feature = "VK_NV_clip_space_w_scaling")]
use crate::extensions::nv_clip_space_w_scaling::ViewportWScalingNV;
#[cfg(feature = "VK_NV_compute_shader_derivatives")]
use crate::extensions::nv_compute_shader_derivatives::PhysicalDeviceComputeShaderDerivativesFeaturesNV;
#[cfg(feature = "VK_NV_cooperative_matrix")]
use crate::extensions::nv_cooperative_matrix::CooperativeMatrixPropertiesNV;
#[cfg(feature = "VK_NV_cooperative_matrix")]
use crate::extensions::nv_cooperative_matrix::PhysicalDeviceCooperativeMatrixFeaturesNV;
#[cfg(feature = "VK_NV_corner_sampled_image")]
use crate::extensions::nv_corner_sampled_image::PhysicalDeviceCornerSampledImageFeaturesNV;
#[cfg(feature = "VK_NV_coverage_reduction_mode")]
use crate::extensions::nv_coverage_reduction_mode::FramebufferMixedSamplesCombinationNV;
#[cfg(feature = "VK_NV_coverage_reduction_mode")]
use crate::extensions::nv_coverage_reduction_mode::PhysicalDeviceCoverageReductionModeFeaturesNV;
#[cfg(feature = "VK_NV_coverage_reduction_mode")]
use crate::extensions::nv_coverage_reduction_mode::PipelineCoverageReductionStateCreateInfoNV;
#[cfg(feature = "VK_NV_dedicated_allocation")]
use crate::extensions::nv_dedicated_allocation::DedicatedAllocationBufferCreateInfoNV;
#[cfg(feature = "VK_NV_dedicated_allocation")]
use crate::extensions::nv_dedicated_allocation::DedicatedAllocationImageCreateInfoNV;
#[cfg(feature = "VK_NV_dedicated_allocation")]
use crate::extensions::nv_dedicated_allocation::DedicatedAllocationMemoryAllocateInfoNV;
#[cfg(feature = "VK_NV_dedicated_allocation_image_aliasing")]
use crate::extensions::nv_dedicated_allocation_image_aliasing::PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV;
#[cfg(feature = "VK_NV_device_diagnostics_config")]
use crate::extensions::nv_device_diagnostics_config::DeviceDiagnosticsConfigCreateInfoNV;
#[cfg(feature = "VK_NV_device_diagnostics_config")]
use crate::extensions::nv_device_diagnostics_config::PhysicalDeviceDiagnosticsConfigFeaturesNV;
#[cfg(feature = "VK_NV_device_generated_commands")]
use crate::extensions::nv_device_generated_commands::GeneratedCommandsInfoNV;
#[cfg(feature = "VK_NV_device_generated_commands")]
use crate::extensions::nv_device_generated_commands::GeneratedCommandsMemoryRequirementsInfoNV;
#[cfg(feature = "VK_NV_device_generated_commands")]
use crate::extensions::nv_device_generated_commands::GraphicsPipelineShaderGroupsCreateInfoNV;
#[cfg(feature = "VK_NV_device_generated_commands")]
use crate::extensions::nv_device_generated_commands::PhysicalDeviceDeviceGeneratedCommandsFeaturesNV;
#[cfg(feature = "VK_NV_external_memory")]
use crate::extensions::nv_external_memory::ExportMemoryAllocateInfoNV;
#[cfg(feature = "VK_NV_external_memory")]
use crate::extensions::nv_external_memory::ExternalMemoryImageCreateInfoNV;
#[cfg(feature = "VK_NV_external_memory_capabilities")]
use crate::extensions::nv_external_memory_capabilities::ExternalImageFormatPropertiesNV;
#[cfg(feature = "VK_NV_external_memory_capabilities")]
use crate::extensions::nv_external_memory_capabilities::ExternalMemoryHandleTypeFlagsNV;
#[cfg(feature = "VK_NV_external_memory_rdma")]
use crate::extensions::nv_external_memory_rdma::PhysicalDeviceExternalMemoryRdmaFeaturesNV;
#[cfg(feature = "VK_NV_external_memory_win32")]
use crate::extensions::nv_external_memory_win32::ExportMemoryWin32HandleInfoNV;
#[cfg(feature = "VK_NV_external_memory_win32")]
use crate::extensions::nv_external_memory_win32::ImportMemoryWin32HandleInfoNV;
#[cfg(feature = "VK_NV_fragment_coverage_to_color")]
use crate::extensions::nv_fragment_coverage_to_color::PipelineCoverageToColorStateCreateInfoNV;
#[cfg(feature = "VK_NV_fragment_shader_barycentric")]
use crate::extensions::nv_fragment_shader_barycentric::PhysicalDeviceFragmentShaderBarycentricFeaturesNV;
#[cfg(feature = "VK_NV_fragment_shading_rate_enums")]
use crate::extensions::nv_fragment_shading_rate_enums::FragmentShadingRateNV;
#[cfg(feature = "VK_NV_fragment_shading_rate_enums")]
use crate::extensions::nv_fragment_shading_rate_enums::PhysicalDeviceFragmentShadingRateEnumsFeaturesNV;
#[cfg(feature = "VK_NV_fragment_shading_rate_enums")]
use crate::extensions::nv_fragment_shading_rate_enums::PipelineFragmentShadingRateEnumStateCreateInfoNV;
#[cfg(feature = "VK_NV_framebuffer_mixed_samples")]
use crate::extensions::nv_framebuffer_mixed_samples::PipelineCoverageModulationStateCreateInfoNV;
#[cfg(feature = "VK_NV_inherited_viewport_scissor")]
use crate::extensions::nv_inherited_viewport_scissor::CommandBufferInheritanceViewportScissorInfoNV;
#[cfg(feature = "VK_NV_inherited_viewport_scissor")]
use crate::extensions::nv_inherited_viewport_scissor::PhysicalDeviceInheritedViewportScissorFeaturesNV;
#[cfg(feature = "VK_NV_linear_color_attachment")]
use crate::extensions::nv_linear_color_attachment::PhysicalDeviceLinearColorAttachmentFeaturesNV;
#[cfg(feature = "VK_NV_mesh_shader")]
use crate::extensions::nv_mesh_shader::PhysicalDeviceMeshShaderFeaturesNV;
#[cfg(feature = "VK_NV_ray_tracing")]
use crate::extensions::nv_ray_tracing::AccelerationStructureInfoNV;
#[cfg(feature = "VK_NV_ray_tracing")]
use crate::extensions::nv_ray_tracing::AccelerationStructureMemoryRequirementsInfoNV;
#[cfg(feature = "VK_NV_ray_tracing")]
use crate::extensions::nv_ray_tracing::AccelerationStructureNV;
#[cfg(feature = "VK_NV_ray_tracing")]
use crate::extensions::nv_ray_tracing::BindAccelerationStructureMemoryInfoNV;
#[cfg(feature = "VK_NV_ray_tracing")]
use crate::extensions::nv_ray_tracing::WriteDescriptorSetAccelerationStructureNV;
#[cfg(feature = "VK_NV_ray_tracing_motion_blur")]
use crate::extensions::nv_ray_tracing_motion_blur::PhysicalDeviceRayTracingMotionBlurFeaturesNV;
#[cfg(feature = "VK_NV_representative_fragment_test")]
use crate::extensions::nv_representative_fragment_test::PhysicalDeviceRepresentativeFragmentTestFeaturesNV;
#[cfg(feature = "VK_NV_representative_fragment_test")]
use crate::extensions::nv_representative_fragment_test::PipelineRepresentativeFragmentTestStateCreateInfoNV;
#[cfg(feature = "VK_NV_scissor_exclusive")]
use crate::extensions::nv_scissor_exclusive::PhysicalDeviceExclusiveScissorFeaturesNV;
#[cfg(feature = "VK_NV_scissor_exclusive")]
use crate::extensions::nv_scissor_exclusive::PipelineViewportExclusiveScissorStateCreateInfoNV;
#[cfg(feature = "VK_NV_shader_image_footprint")]
use crate::extensions::nv_shader_image_footprint::PhysicalDeviceShaderImageFootprintFeaturesNV;
#[cfg(feature = "VK_NV_shader_sm_builtins")]
use crate::extensions::nv_shader_sm_builtins::PhysicalDeviceShaderSmBuiltinsFeaturesNV;
#[cfg(feature = "VK_NV_shading_rate_image")]
use crate::extensions::nv_shading_rate_image::CoarseSampleOrderCustomNV;
#[cfg(feature = "VK_NV_shading_rate_image")]
use crate::extensions::nv_shading_rate_image::CoarseSampleOrderTypeNV;
#[cfg(feature = "VK_NV_shading_rate_image")]
use crate::extensions::nv_shading_rate_image::PhysicalDeviceShadingRateImageFeaturesNV;
#[cfg(feature = "VK_NV_shading_rate_image")]
use crate::extensions::nv_shading_rate_image::PipelineViewportCoarseSampleOrderStateCreateInfoNV;
#[cfg(feature = "VK_NV_shading_rate_image")]
use crate::extensions::nv_shading_rate_image::PipelineViewportShadingRateImageStateCreateInfoNV;
#[cfg(feature = "VK_NV_shading_rate_image")]
use crate::extensions::nv_shading_rate_image::ShadingRatePaletteNV;
#[cfg(feature = "VK_NV_viewport_swizzle")]
use crate::extensions::nv_viewport_swizzle::PipelineViewportSwizzleStateCreateInfoNV;
#[cfg(feature = "VK_NV_win32_keyed_mutex")]
use crate::extensions::nv_win32_keyed_mutex::Win32KeyedMutexAcquireReleaseInfoNV;
#[cfg(feature = "VK_NVX_image_view_handle")]
use crate::extensions::nvx_image_view_handle::ImageViewAddressPropertiesNVX;
#[cfg(feature = "VK_NVX_image_view_handle")]
use crate::extensions::nvx_image_view_handle::ImageViewHandleInfoNVX;
#[cfg(feature = "VK_VALVE_mutable_descriptor_type")]
use crate::extensions::valve_mutable_descriptor_type::MutableDescriptorTypeCreateInfoVALVE;
#[cfg(feature = "VK_VALVE_mutable_descriptor_type")]
use crate::extensions::valve_mutable_descriptor_type::PhysicalDeviceMutableDescriptorTypeFeaturesVALVE;
#[cfg(feature = "VULKAN_1_2")]
use crate::vulkan1_2::BufferDeviceAddressInfo;
#[cfg(feature = "VULKAN_1_2")]
use crate::vulkan1_2::BufferOpaqueCaptureAddressCreateInfo;
#[cfg(feature = "VULKAN_1_2")]
use crate::vulkan1_2::DescriptorSetLayoutBindingFlagsCreateInfo;
#[cfg(feature = "VULKAN_1_2")]
use crate::vulkan1_2::DescriptorSetVariableDescriptorCountAllocateInfo;
#[cfg(feature = "VULKAN_1_2")]
use crate::vulkan1_2::DeviceMemoryOpaqueCaptureAddressInfo;
#[cfg(feature = "VULKAN_1_2")]
use crate::vulkan1_2::FramebufferAttachmentsCreateInfo;
#[cfg(feature = "VULKAN_1_2")]
use crate::vulkan1_2::ImageFormatListCreateInfo;
#[cfg(feature = "VULKAN_1_2")]
use crate::vulkan1_2::ImageStencilUsageCreateInfo;
#[cfg(feature = "VULKAN_1_2")]
use crate::vulkan1_2::MemoryOpaqueCaptureAddressAllocateInfo;
#[cfg(feature = "VULKAN_1_2")]
use crate::vulkan1_2::PhysicalDevice8BitStorageFeatures;
#[cfg(feature = "VULKAN_1_2")]
use crate::vulkan1_2::PhysicalDeviceBufferDeviceAddressFeatures;
#[cfg(feature = "VULKAN_1_2")]
use crate::vulkan1_2::PhysicalDeviceDescriptorIndexingFeatures;
#[cfg(feature = "VULKAN_1_2")]
use crate::vulkan1_2::PhysicalDeviceHostQueryResetFeatures;
#[cfg(feature = "VULKAN_1_2")]
use crate::vulkan1_2::PhysicalDeviceImagelessFramebufferFeatures;
#[cfg(feature = "VULKAN_1_2")]
use crate::vulkan1_2::PhysicalDeviceScalarBlockLayoutFeatures;
#[cfg(feature = "VULKAN_1_2")]
use crate::vulkan1_2::PhysicalDeviceSeparateDepthStencilLayoutsFeatures;
#[cfg(feature = "VULKAN_1_2")]
use crate::vulkan1_2::PhysicalDeviceShaderAtomicInt64Features;
#[cfg(feature = "VULKAN_1_2")]
use crate::vulkan1_2::PhysicalDeviceShaderFloat16Int8Features;
#[cfg(feature = "VULKAN_1_2")]
use crate::vulkan1_2::PhysicalDeviceShaderSubgroupExtendedTypesFeatures;
#[cfg(feature = "VULKAN_1_2")]
use crate::vulkan1_2::PhysicalDeviceTimelineSemaphoreFeatures;
#[cfg(feature = "VULKAN_1_2")]
use crate::vulkan1_2::PhysicalDeviceUniformBufferStandardLayoutFeatures;
#[cfg(feature = "VULKAN_1_2")]
use crate::vulkan1_2::PhysicalDeviceVulkan11Features;
#[cfg(feature = "VULKAN_1_2")]
use crate::vulkan1_2::PhysicalDeviceVulkan12Features;
#[cfg(feature = "VULKAN_1_2")]
use crate::vulkan1_2::PhysicalDeviceVulkanMemoryModelFeatures;
#[cfg(feature = "VULKAN_1_2")]
use crate::vulkan1_2::RenderPassAttachmentBeginInfo;
#[cfg(feature = "VULKAN_1_2")]
use crate::vulkan1_2::SamplerReductionModeCreateInfo;
#[cfg(feature = "VULKAN_1_2")]
use crate::vulkan1_2::SemaphoreSignalInfo;
#[cfg(feature = "VULKAN_1_2")]
use crate::vulkan1_2::SemaphoreTypeCreateInfo;
#[cfg(feature = "VULKAN_1_2")]
use crate::vulkan1_2::SemaphoreWaitInfo;
#[cfg(feature = "VULKAN_1_2")]
use crate::vulkan1_2::SubpassBeginInfo;
#[cfg(feature = "VULKAN_1_2")]
use crate::vulkan1_2::SubpassEndInfo;
#[cfg(feature = "VULKAN_1_2")]
use crate::vulkan1_2::TimelineSemaphoreSubmitInfo;
#[cfg(feature = "VULKAN_1_3")]
use crate::vulkan1_3::BlitImageInfo2;
#[cfg(feature = "VULKAN_1_3")]
use crate::vulkan1_3::CommandBufferInheritanceRenderingInfo;
#[cfg(feature = "VULKAN_1_3")]
use crate::vulkan1_3::CopyBufferInfo2;
#[cfg(feature = "VULKAN_1_3")]
use crate::vulkan1_3::CopyBufferToImageInfo2;
#[cfg(feature = "VULKAN_1_3")]
use crate::vulkan1_3::CopyImageInfo2;
#[cfg(feature = "VULKAN_1_3")]
use crate::vulkan1_3::CopyImageToBufferInfo2;
#[cfg(feature = "VULKAN_1_3")]
use crate::vulkan1_3::DependencyInfo;
#[cfg(feature = "VULKAN_1_3")]
use crate::vulkan1_3::DescriptorPoolInlineUniformBlockCreateInfo;
#[cfg(feature = "VULKAN_1_3")]
use crate::vulkan1_3::DeviceBufferMemoryRequirements;
#[cfg(feature = "VULKAN_1_3")]
use crate::vulkan1_3::DeviceImageMemoryRequirements;
#[cfg(feature = "VULKAN_1_3")]
use crate::vulkan1_3::DevicePrivateDataCreateInfo;
#[cfg(feature = "VULKAN_1_3")]
use crate::vulkan1_3::PhysicalDeviceDynamicRenderingFeatures;
#[cfg(feature = "VULKAN_1_3")]
use crate::vulkan1_3::PhysicalDeviceImageRobustnessFeatures;
#[cfg(feature = "VULKAN_1_3")]
use crate::vulkan1_3::PhysicalDeviceInlineUniformBlockFeatures;
#[cfg(feature = "VULKAN_1_3")]
use crate::vulkan1_3::PhysicalDeviceMaintenance4Features;
#[cfg(feature = "VULKAN_1_3")]
use crate::vulkan1_3::PhysicalDevicePipelineCreationCacheControlFeatures;
#[cfg(feature = "VULKAN_1_3")]
use crate::vulkan1_3::PhysicalDevicePrivateDataFeatures;
#[cfg(feature = "VULKAN_1_3")]
use crate::vulkan1_3::PhysicalDeviceShaderDemoteToHelperInvocationFeatures;
#[cfg(feature = "VULKAN_1_3")]
use crate::vulkan1_3::PhysicalDeviceShaderIntegerDotProductFeatures;
#[cfg(feature = "VULKAN_1_3")]
use crate::vulkan1_3::PhysicalDeviceShaderTerminateInvocationFeatures;
#[cfg(feature = "VULKAN_1_3")]
use crate::vulkan1_3::PhysicalDeviceSubgroupSizeControlFeatures;
#[cfg(feature = "VULKAN_1_3")]
use crate::vulkan1_3::PhysicalDeviceSynchronization2Features;
#[cfg(feature = "VULKAN_1_3")]
use crate::vulkan1_3::PhysicalDeviceTextureCompressionAstchdrFeatures;
#[cfg(feature = "VULKAN_1_3")]
use crate::vulkan1_3::PhysicalDeviceToolProperties;
#[cfg(feature = "VULKAN_1_3")]
use crate::vulkan1_3::PhysicalDeviceVulkan13Features;
#[cfg(feature = "VULKAN_1_3")]
use crate::vulkan1_3::PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures;
#[cfg(feature = "VULKAN_1_3")]
use crate::vulkan1_3::PipelineCreationFeedbackCreateInfo;
#[cfg(feature = "VULKAN_1_3")]
use crate::vulkan1_3::PipelineRenderingCreateInfo;
#[cfg(feature = "VULKAN_1_3")]
use crate::vulkan1_3::PipelineShaderStageRequiredSubgroupSizeCreateInfo;
#[cfg(feature = "VULKAN_1_3")]
use crate::vulkan1_3::PipelineStageFlags2;
#[cfg(feature = "VULKAN_1_3")]
use crate::vulkan1_3::PrivateDataSlot;
#[cfg(feature = "VULKAN_1_3")]
use crate::vulkan1_3::RenderingInfo;
#[cfg(feature = "VULKAN_1_3")]
use crate::vulkan1_3::ResolveImageInfo2;
#[cfg(feature = "VULKAN_1_3")]
use crate::vulkan1_3::SubmitInfo2;
#[cfg(feature = "VULKAN_1_3")]
use crate::vulkan1_3::WriteDescriptorSetInlineUniformBlock;
use crate::{
    context::{Container, Context, Error, ObjectId},
    vulkan1_1::{
        BindBufferMemoryInfo, BindImageMemoryInfo, BufferMemoryRequirementsInfo2, CommandPoolTrimFlags,
        DescriptorSetLayoutSupport, DeviceGroupBindSparseInfo, DeviceGroupCommandBufferBeginInfo,
        DeviceGroupDeviceCreateInfo, DeviceGroupRenderPassBeginInfo, DeviceGroupSubmitInfo, DeviceQueueInfo2,
        ExportFenceCreateInfo, ExportMemoryAllocateInfo, ExportSemaphoreCreateInfo, ExternalBufferProperties,
        ExternalFenceProperties, ExternalMemoryBufferCreateInfo, ExternalMemoryHandleTypeFlagBits,
        ExternalMemoryImageCreateInfo, ExternalSemaphoreProperties, FormatProperties2, ImageFormatProperties2,
        ImageMemoryRequirementsInfo2, ImageSparseMemoryRequirementsInfo2, ImageViewUsageCreateInfo,
        MemoryAllocateFlagsInfo, MemoryDedicatedAllocateInfo, MemoryRequirements2, PeerMemoryFeatureFlags,
        PhysicalDevice16BitStorageFeatures, PhysicalDeviceExternalBufferInfo, PhysicalDeviceExternalFenceInfo,
        PhysicalDeviceExternalSemaphoreInfo, PhysicalDeviceFeatures2, PhysicalDeviceGroupProperties,
        PhysicalDeviceImageFormatInfo2, PhysicalDeviceMemoryProperties2, PhysicalDeviceMultiviewFeatures,
        PhysicalDeviceProperties2, PhysicalDeviceProtectedMemoryFeatures, PhysicalDeviceSamplerYcbcrConversionFeatures,
        PhysicalDeviceShaderDrawParametersFeatures, PhysicalDeviceSparseImageFormatInfo2,
        PhysicalDeviceVariablePointersFeatures, PipelineTessellationDomainOriginStateCreateInfo, ProtectedSubmitInfo,
        QueueFamilyProperties2, RenderPassInputAttachmentAspectCreateInfo, RenderPassMultiviewCreateInfo,
        SamplerYcbcrConversionInfo, SparseImageFormatProperties2, SparseImageMemoryRequirements2,
    },
};
#[cfg(feature = "serde")]
use serde::{Deserialize, Serialize};
use smallvec::SmallVec;
use std::sync::Arc;
impl Offset2D {
    ///Get a reference to the `x` field.
    pub fn x(&self) -> i32 {
        self.x
    }
    ///Get a reference to the `y` field.
    pub fn y(&self) -> i32 {
        self.y
    }
    ///Get a mutable reference to the `x` field.
    pub fn x_mut(&mut self) -> &mut i32 {
        &mut self.x
    }
    ///Get a mutable reference to the `y` field.
    pub fn y_mut(&mut self) -> &mut i32 {
        &mut self.y
    }
    ///Sets the `x` field.
    pub fn set_x(&mut self, x: i32) -> &mut Self {
        self.x = x;
        self
    }
    ///Sets the `y` field.
    pub fn set_y(&mut self, y: i32) -> &mut Self {
        self.y = y;
        self
    }
    ///Sets the `x` field in a builder way.
    pub fn with_x(mut self, x: i32) -> Self {
        self.x = x;
        self
    }
    ///Sets the `y` field in a builder way.
    pub fn with_y(mut self, y: i32) -> Self {
        self.y = y;
        self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for Offset2D {
    type LowLevel = crate::native::vulkan1_0::Offset2D;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        crate::native::vulkan1_0::Offset2D {
            x: self.x.into_low_level(context, bump),
            y: self.y.into_low_level(context, bump),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for Offset2D {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        Self {
            x: crate::conv::FromLowLevel::from_low_level(context, value.x),
            y: crate::conv::FromLowLevel::from_low_level(context, value.y),
        }
    }
}
impl Offset3D {
    ///Get a reference to the `x` field.
    pub fn x(&self) -> i32 {
        self.x
    }
    ///Get a reference to the `y` field.
    pub fn y(&self) -> i32 {
        self.y
    }
    ///Get a reference to the `z` field.
    pub fn z(&self) -> i32 {
        self.z
    }
    ///Get a mutable reference to the `x` field.
    pub fn x_mut(&mut self) -> &mut i32 {
        &mut self.x
    }
    ///Get a mutable reference to the `y` field.
    pub fn y_mut(&mut self) -> &mut i32 {
        &mut self.y
    }
    ///Get a mutable reference to the `z` field.
    pub fn z_mut(&mut self) -> &mut i32 {
        &mut self.z
    }
    ///Sets the `x` field.
    pub fn set_x(&mut self, x: i32) -> &mut Self {
        self.x = x;
        self
    }
    ///Sets the `y` field.
    pub fn set_y(&mut self, y: i32) -> &mut Self {
        self.y = y;
        self
    }
    ///Sets the `z` field.
    pub fn set_z(&mut self, z: i32) -> &mut Self {
        self.z = z;
        self
    }
    ///Sets the `x` field in a builder way.
    pub fn with_x(mut self, x: i32) -> Self {
        self.x = x;
        self
    }
    ///Sets the `y` field in a builder way.
    pub fn with_y(mut self, y: i32) -> Self {
        self.y = y;
        self
    }
    ///Sets the `z` field in a builder way.
    pub fn with_z(mut self, z: i32) -> Self {
        self.z = z;
        self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for Offset3D {
    type LowLevel = crate::native::vulkan1_0::Offset3D;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        crate::native::vulkan1_0::Offset3D {
            x: self.x.into_low_level(context, bump),
            y: self.y.into_low_level(context, bump),
            z: self.z.into_low_level(context, bump),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for Offset3D {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        Self {
            x: crate::conv::FromLowLevel::from_low_level(context, value.x),
            y: crate::conv::FromLowLevel::from_low_level(context, value.y),
            z: crate::conv::FromLowLevel::from_low_level(context, value.z),
        }
    }
}
impl Extent2D {
    ///Get a reference to the `width` field.
    pub fn width(&self) -> u32 {
        self.width
    }
    ///Get a reference to the `height` field.
    pub fn height(&self) -> u32 {
        self.height
    }
    ///Get a mutable reference to the `width` field.
    pub fn width_mut(&mut self) -> &mut u32 {
        &mut self.width
    }
    ///Get a mutable reference to the `height` field.
    pub fn height_mut(&mut self) -> &mut u32 {
        &mut self.height
    }
    ///Sets the `width` field.
    pub fn set_width(&mut self, width: u32) -> &mut Self {
        self.width = width;
        self
    }
    ///Sets the `height` field.
    pub fn set_height(&mut self, height: u32) -> &mut Self {
        self.height = height;
        self
    }
    ///Sets the `width` field in a builder way.
    pub fn with_width(mut self, width: u32) -> Self {
        self.width = width;
        self
    }
    ///Sets the `height` field in a builder way.
    pub fn with_height(mut self, height: u32) -> Self {
        self.height = height;
        self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for Extent2D {
    type LowLevel = crate::native::vulkan1_0::Extent2D;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        crate::native::vulkan1_0::Extent2D {
            width: self.width.into_low_level(context, bump),
            height: self.height.into_low_level(context, bump),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for Extent2D {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        Self {
            width: crate::conv::FromLowLevel::from_low_level(context, value.width),
            height: crate::conv::FromLowLevel::from_low_level(context, value.height),
        }
    }
}
impl Extent3D {
    ///Get a reference to the `width` field.
    pub fn width(&self) -> u32 {
        self.width
    }
    ///Get a reference to the `height` field.
    pub fn height(&self) -> u32 {
        self.height
    }
    ///Get a reference to the `depth` field.
    pub fn depth(&self) -> u32 {
        self.depth
    }
    ///Get a mutable reference to the `width` field.
    pub fn width_mut(&mut self) -> &mut u32 {
        &mut self.width
    }
    ///Get a mutable reference to the `height` field.
    pub fn height_mut(&mut self) -> &mut u32 {
        &mut self.height
    }
    ///Get a mutable reference to the `depth` field.
    pub fn depth_mut(&mut self) -> &mut u32 {
        &mut self.depth
    }
    ///Sets the `width` field.
    pub fn set_width(&mut self, width: u32) -> &mut Self {
        self.width = width;
        self
    }
    ///Sets the `height` field.
    pub fn set_height(&mut self, height: u32) -> &mut Self {
        self.height = height;
        self
    }
    ///Sets the `depth` field.
    pub fn set_depth(&mut self, depth: u32) -> &mut Self {
        self.depth = depth;
        self
    }
    ///Sets the `width` field in a builder way.
    pub fn with_width(mut self, width: u32) -> Self {
        self.width = width;
        self
    }
    ///Sets the `height` field in a builder way.
    pub fn with_height(mut self, height: u32) -> Self {
        self.height = height;
        self
    }
    ///Sets the `depth` field in a builder way.
    pub fn with_depth(mut self, depth: u32) -> Self {
        self.depth = depth;
        self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for Extent3D {
    type LowLevel = crate::native::vulkan1_0::Extent3D;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        crate::native::vulkan1_0::Extent3D {
            width: self.width.into_low_level(context, bump),
            height: self.height.into_low_level(context, bump),
            depth: self.depth.into_low_level(context, bump),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for Extent3D {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        Self {
            width: crate::conv::FromLowLevel::from_low_level(context, value.width),
            height: crate::conv::FromLowLevel::from_low_level(context, value.height),
            depth: crate::conv::FromLowLevel::from_low_level(context, value.depth),
        }
    }
}
impl Viewport {
    ///Get a reference to the `x` field.
    pub fn x(&self) -> f32 {
        self.x
    }
    ///Get a reference to the `y` field.
    pub fn y(&self) -> f32 {
        self.y
    }
    ///Get a reference to the `width` field.
    pub fn width(&self) -> f32 {
        self.width
    }
    ///Get a reference to the `height` field.
    pub fn height(&self) -> f32 {
        self.height
    }
    ///Get a reference to the `min_depth` field.
    pub fn min_depth(&self) -> f32 {
        self.min_depth
    }
    ///Get a reference to the `max_depth` field.
    pub fn max_depth(&self) -> f32 {
        self.max_depth
    }
    ///Get a mutable reference to the `x` field.
    pub fn x_mut(&mut self) -> &mut f32 {
        &mut self.x
    }
    ///Get a mutable reference to the `y` field.
    pub fn y_mut(&mut self) -> &mut f32 {
        &mut self.y
    }
    ///Get a mutable reference to the `width` field.
    pub fn width_mut(&mut self) -> &mut f32 {
        &mut self.width
    }
    ///Get a mutable reference to the `height` field.
    pub fn height_mut(&mut self) -> &mut f32 {
        &mut self.height
    }
    ///Get a mutable reference to the `min_depth` field.
    pub fn min_depth_mut(&mut self) -> &mut f32 {
        &mut self.min_depth
    }
    ///Get a mutable reference to the `max_depth` field.
    pub fn max_depth_mut(&mut self) -> &mut f32 {
        &mut self.max_depth
    }
    ///Sets the `x` field.
    pub fn set_x(&mut self, x: f32) -> &mut Self {
        self.x = x;
        self
    }
    ///Sets the `y` field.
    pub fn set_y(&mut self, y: f32) -> &mut Self {
        self.y = y;
        self
    }
    ///Sets the `width` field.
    pub fn set_width(&mut self, width: f32) -> &mut Self {
        self.width = width;
        self
    }
    ///Sets the `height` field.
    pub fn set_height(&mut self, height: f32) -> &mut Self {
        self.height = height;
        self
    }
    ///Sets the `min_depth` field.
    pub fn set_min_depth(&mut self, min_depth: f32) -> &mut Self {
        self.min_depth = min_depth;
        self
    }
    ///Sets the `max_depth` field.
    pub fn set_max_depth(&mut self, max_depth: f32) -> &mut Self {
        self.max_depth = max_depth;
        self
    }
    ///Sets the `x` field in a builder way.
    pub fn with_x(mut self, x: f32) -> Self {
        self.x = x;
        self
    }
    ///Sets the `y` field in a builder way.
    pub fn with_y(mut self, y: f32) -> Self {
        self.y = y;
        self
    }
    ///Sets the `width` field in a builder way.
    pub fn with_width(mut self, width: f32) -> Self {
        self.width = width;
        self
    }
    ///Sets the `height` field in a builder way.
    pub fn with_height(mut self, height: f32) -> Self {
        self.height = height;
        self
    }
    ///Sets the `min_depth` field in a builder way.
    pub fn with_min_depth(mut self, min_depth: f32) -> Self {
        self.min_depth = min_depth;
        self
    }
    ///Sets the `max_depth` field in a builder way.
    pub fn with_max_depth(mut self, max_depth: f32) -> Self {
        self.max_depth = max_depth;
        self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for Viewport {
    type LowLevel = crate::native::vulkan1_0::Viewport;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        crate::native::vulkan1_0::Viewport {
            x: self.x.into_low_level(context, bump),
            y: self.y.into_low_level(context, bump),
            width: self.width.into_low_level(context, bump),
            height: self.height.into_low_level(context, bump),
            min_depth: self.min_depth.into_low_level(context, bump),
            max_depth: self.max_depth.into_low_level(context, bump),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for Viewport {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        Self {
            x: crate::conv::FromLowLevel::from_low_level(context, value.x),
            y: crate::conv::FromLowLevel::from_low_level(context, value.y),
            width: crate::conv::FromLowLevel::from_low_level(context, value.width),
            height: crate::conv::FromLowLevel::from_low_level(context, value.height),
            min_depth: crate::conv::FromLowLevel::from_low_level(context, value.min_depth),
            max_depth: crate::conv::FromLowLevel::from_low_level(context, value.max_depth),
        }
    }
}
impl Rect2D {
    ///Get a reference to the `offset` field.
    pub fn offset(&self) -> Offset2D {
        self.offset
    }
    ///Get a reference to the `extent` field.
    pub fn extent(&self) -> Extent2D {
        self.extent
    }
    ///Get a mutable reference to the `offset` field.
    pub fn offset_mut(&mut self) -> &mut Offset2D {
        &mut self.offset
    }
    ///Get a mutable reference to the `extent` field.
    pub fn extent_mut(&mut self) -> &mut Extent2D {
        &mut self.extent
    }
    ///Sets the `offset` field.
    pub fn set_offset(&mut self, offset: Offset2D) -> &mut Self {
        self.offset = offset;
        self
    }
    ///Sets the `extent` field.
    pub fn set_extent(&mut self, extent: Extent2D) -> &mut Self {
        self.extent = extent;
        self
    }
    ///Sets the `offset` field in a builder way.
    pub fn with_offset(mut self, offset: Offset2D) -> Self {
        self.offset = offset;
        self
    }
    ///Sets the `extent` field in a builder way.
    pub fn with_extent(mut self, extent: Extent2D) -> Self {
        self.extent = extent;
        self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for Rect2D {
    type LowLevel = crate::native::vulkan1_0::Rect2D;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        crate::native::vulkan1_0::Rect2D {
            offset: self.offset.into_low_level(context, bump),
            extent: self.extent.into_low_level(context, bump),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for Rect2D {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        Self {
            offset: crate::conv::FromLowLevel::from_low_level(context, value.offset),
            extent: crate::conv::FromLowLevel::from_low_level(context, value.extent),
        }
    }
}
impl ClearRect {
    ///Get a reference to the `rect` field.
    pub fn rect(&self) -> Rect2D {
        self.rect
    }
    ///Get a reference to the `base_array_layer` field.
    pub fn base_array_layer(&self) -> u32 {
        self.base_array_layer
    }
    ///Get a reference to the `layer_count` field.
    pub fn layer_count(&self) -> u32 {
        self.layer_count
    }
    ///Get a mutable reference to the `rect` field.
    pub fn rect_mut(&mut self) -> &mut Rect2D {
        &mut self.rect
    }
    ///Get a mutable reference to the `base_array_layer` field.
    pub fn base_array_layer_mut(&mut self) -> &mut u32 {
        &mut self.base_array_layer
    }
    ///Get a mutable reference to the `layer_count` field.
    pub fn layer_count_mut(&mut self) -> &mut u32 {
        &mut self.layer_count
    }
    ///Sets the `rect` field.
    pub fn set_rect(&mut self, rect: Rect2D) -> &mut Self {
        self.rect = rect;
        self
    }
    ///Sets the `base_array_layer` field.
    pub fn set_base_array_layer(&mut self, base_array_layer: u32) -> &mut Self {
        self.base_array_layer = base_array_layer;
        self
    }
    ///Sets the `layer_count` field.
    pub fn set_layer_count(&mut self, layer_count: u32) -> &mut Self {
        self.layer_count = layer_count;
        self
    }
    ///Sets the `rect` field in a builder way.
    pub fn with_rect(mut self, rect: Rect2D) -> Self {
        self.rect = rect;
        self
    }
    ///Sets the `base_array_layer` field in a builder way.
    pub fn with_base_array_layer(mut self, base_array_layer: u32) -> Self {
        self.base_array_layer = base_array_layer;
        self
    }
    ///Sets the `layer_count` field in a builder way.
    pub fn with_layer_count(mut self, layer_count: u32) -> Self {
        self.layer_count = layer_count;
        self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for ClearRect {
    type LowLevel = crate::native::vulkan1_0::ClearRect;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        crate::native::vulkan1_0::ClearRect {
            rect: self.rect.into_low_level(context, bump),
            base_array_layer: self.base_array_layer.into_low_level(context, bump),
            layer_count: self.layer_count.into_low_level(context, bump),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for ClearRect {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        Self {
            rect: crate::conv::FromLowLevel::from_low_level(context, value.rect),
            base_array_layer: crate::conv::FromLowLevel::from_low_level(context, value.base_array_layer),
            layer_count: crate::conv::FromLowLevel::from_low_level(context, value.layer_count),
        }
    }
}
impl ComponentMapping {
    ///Get a reference to the `r` field.
    pub fn r(&self) -> ComponentSwizzle {
        self.r
    }
    ///Get a reference to the `g` field.
    pub fn g(&self) -> ComponentSwizzle {
        self.g
    }
    ///Get a reference to the `b` field.
    pub fn b(&self) -> ComponentSwizzle {
        self.b
    }
    ///Get a reference to the `a` field.
    pub fn a(&self) -> ComponentSwizzle {
        self.a
    }
    ///Get a mutable reference to the `r` field.
    pub fn r_mut(&mut self) -> &mut ComponentSwizzle {
        &mut self.r
    }
    ///Get a mutable reference to the `g` field.
    pub fn g_mut(&mut self) -> &mut ComponentSwizzle {
        &mut self.g
    }
    ///Get a mutable reference to the `b` field.
    pub fn b_mut(&mut self) -> &mut ComponentSwizzle {
        &mut self.b
    }
    ///Get a mutable reference to the `a` field.
    pub fn a_mut(&mut self) -> &mut ComponentSwizzle {
        &mut self.a
    }
    ///Sets the `r` field.
    pub fn set_r(&mut self, r: ComponentSwizzle) -> &mut Self {
        self.r = r;
        self
    }
    ///Sets the `g` field.
    pub fn set_g(&mut self, g: ComponentSwizzle) -> &mut Self {
        self.g = g;
        self
    }
    ///Sets the `b` field.
    pub fn set_b(&mut self, b: ComponentSwizzle) -> &mut Self {
        self.b = b;
        self
    }
    ///Sets the `a` field.
    pub fn set_a(&mut self, a: ComponentSwizzle) -> &mut Self {
        self.a = a;
        self
    }
    ///Sets the `r` field in a builder way.
    pub fn with_r(mut self, r: ComponentSwizzle) -> Self {
        self.r = r;
        self
    }
    ///Sets the `g` field in a builder way.
    pub fn with_g(mut self, g: ComponentSwizzle) -> Self {
        self.g = g;
        self
    }
    ///Sets the `b` field in a builder way.
    pub fn with_b(mut self, b: ComponentSwizzle) -> Self {
        self.b = b;
        self
    }
    ///Sets the `a` field in a builder way.
    pub fn with_a(mut self, a: ComponentSwizzle) -> Self {
        self.a = a;
        self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for ComponentMapping {
    type LowLevel = crate::native::vulkan1_0::ComponentMapping;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        crate::native::vulkan1_0::ComponentMapping {
            r: self.r.into_low_level(context, bump),
            g: self.g.into_low_level(context, bump),
            b: self.b.into_low_level(context, bump),
            a: self.a.into_low_level(context, bump),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for ComponentMapping {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        Self {
            r: crate::conv::FromLowLevel::from_low_level(context, value.r),
            g: crate::conv::FromLowLevel::from_low_level(context, value.g),
            b: crate::conv::FromLowLevel::from_low_level(context, value.b),
            a: crate::conv::FromLowLevel::from_low_level(context, value.a),
        }
    }
}
#[doc(alias = "VkPhysicalDeviceProperties")]
#[derive(Clone, PartialEq, Debug, Default)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct PhysicalDeviceProperties {
    #[doc(alias = "apiVersion")]
    pub api_version: u32,
    #[doc(alias = "driverVersion")]
    pub driver_version: u32,
    #[doc(alias = "vendorID")]
    pub vendor_id: u32,
    #[doc(alias = "deviceID")]
    pub device_id: u32,
    #[doc(alias = "deviceType")]
    pub device_type: PhysicalDeviceType,
    #[doc(alias = "deviceName")]
    pub device_name: String,
    #[doc(alias = "pipelineCacheUUID")]
    pub pipeline_cache_uuid: uuid::Uuid,
    pub limits: PhysicalDeviceLimits,
    #[doc(alias = "sparseProperties")]
    pub sparse_properties: PhysicalDeviceSparseProperties,
}
impl PhysicalDeviceProperties {
    ///Get a reference to the `api_version` field.
    pub fn api_version(&self) -> u32 {
        self.api_version
    }
    ///Get a reference to the `driver_version` field.
    pub fn driver_version(&self) -> u32 {
        self.driver_version
    }
    ///Get a reference to the `vendor_id` field.
    pub fn vendor_id(&self) -> u32 {
        self.vendor_id
    }
    ///Get a reference to the `device_id` field.
    pub fn device_id(&self) -> u32 {
        self.device_id
    }
    ///Get a reference to the `device_type` field.
    pub fn device_type(&self) -> PhysicalDeviceType {
        self.device_type
    }
    ///Get a reference to the `device_name` field.
    pub fn device_name(&self) -> &String {
        &self.device_name
    }
    ///Get a reference to the `pipeline_cache_uuid` field.
    pub fn pipeline_cache_uuid(&self) -> uuid::Uuid {
        self.pipeline_cache_uuid
    }
    ///Get a reference to the `limits` field.
    pub fn limits(&self) -> &PhysicalDeviceLimits {
        &self.limits
    }
    ///Get a reference to the `sparse_properties` field.
    pub fn sparse_properties(&self) -> &PhysicalDeviceSparseProperties {
        &self.sparse_properties
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for PhysicalDeviceProperties {
    type LowLevel = crate::native::vulkan1_0::PhysicalDeviceProperties;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        let device_name_bytes = self.device_name.as_bytes();
        debug_assert!(
            memchr::memchr(0, device_name_bytes).is_none(),
            "string array contains null characters"
        );
        debug_assert!(
            device_name_bytes.len() <= MAX_PHYSICAL_DEVICE_NAME_SIZE as usize,
            "string is too long for the backing array"
        );
        let mut device_name: [std::ffi::c_char; MAX_PHYSICAL_DEVICE_NAME_SIZE as usize] =
            [0; MAX_PHYSICAL_DEVICE_NAME_SIZE as usize];
        device_name[0..device_name_bytes.len()].copy_from_slice(std::slice::from_raw_parts(
            device_name_bytes.as_ptr() as *const std::ffi::c_char,
            device_name_bytes.len(),
        ));
        crate::native::vulkan1_0::PhysicalDeviceProperties {
            api_version: self.api_version.into_low_level(context, bump),
            driver_version: self.driver_version.into_low_level(context, bump),
            vendor_id: self.vendor_id.into_low_level(context, bump),
            device_id: self.device_id.into_low_level(context, bump),
            device_type: self.device_type.into_low_level(context, bump),
            device_name: device_name,
            pipeline_cache_uuid: self.pipeline_cache_uuid.into_low_level(context, bump),
            limits: self.limits.into_low_level(context, bump),
            sparse_properties: self.sparse_properties.into_low_level(context, bump),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for PhysicalDeviceProperties {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        let device_name_cstr = std::ffi::CStr::from_ptr(value.device_name.as_ptr());
        let device_name = device_name_cstr.to_string_lossy().into_owned();
        Self {
            api_version: crate::conv::FromLowLevel::from_low_level(context, value.api_version),
            driver_version: crate::conv::FromLowLevel::from_low_level(context, value.driver_version),
            vendor_id: crate::conv::FromLowLevel::from_low_level(context, value.vendor_id),
            device_id: crate::conv::FromLowLevel::from_low_level(context, value.device_id),
            device_type: crate::conv::FromLowLevel::from_low_level(context, value.device_type),
            device_name: device_name,
            pipeline_cache_uuid: crate::conv::FromLowLevel::from_low_level(context, value.pipeline_cache_uuid),
            limits: crate::conv::FromLowLevel::from_low_level(context, value.limits),
            sparse_properties: crate::conv::FromLowLevel::from_low_level(context, value.sparse_properties),
        }
    }
}
#[doc(alias = "VkExtensionProperties")]
#[derive(Clone, PartialEq, Debug, Default)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct ExtensionProperties {
    #[doc(alias = "extensionName")]
    pub extension_name: String,
    #[doc(alias = "specVersion")]
    pub spec_version: u32,
}
impl ExtensionProperties {
    ///Get a reference to the `extension_name` field.
    pub fn extension_name(&self) -> &String {
        &self.extension_name
    }
    ///Get a reference to the `spec_version` field.
    pub fn spec_version(&self) -> u32 {
        self.spec_version
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for ExtensionProperties {
    type LowLevel = crate::native::vulkan1_0::ExtensionProperties;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        let extension_name_bytes = self.extension_name.as_bytes();
        debug_assert!(
            memchr::memchr(0, extension_name_bytes).is_none(),
            "string array contains null characters"
        );
        debug_assert!(
            extension_name_bytes.len() <= MAX_EXTENSION_NAME_SIZE as usize,
            "string is too long for the backing array"
        );
        let mut extension_name: [std::ffi::c_char; MAX_EXTENSION_NAME_SIZE as usize] =
            [0; MAX_EXTENSION_NAME_SIZE as usize];
        extension_name[0..extension_name_bytes.len()].copy_from_slice(std::slice::from_raw_parts(
            extension_name_bytes.as_ptr() as *const std::ffi::c_char,
            extension_name_bytes.len(),
        ));
        crate::native::vulkan1_0::ExtensionProperties {
            extension_name: extension_name,
            spec_version: self.spec_version.into_low_level(context, bump),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for ExtensionProperties {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        let extension_name_cstr = std::ffi::CStr::from_ptr(value.extension_name.as_ptr());
        let extension_name = extension_name_cstr.to_string_lossy().into_owned();
        Self {
            extension_name: extension_name,
            spec_version: crate::conv::FromLowLevel::from_low_level(context, value.spec_version),
        }
    }
}
#[doc(alias = "VkLayerProperties")]
#[derive(Clone, PartialEq, Debug, Default)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct LayerProperties {
    #[doc(alias = "layerName")]
    pub layer_name: String,
    #[doc(alias = "specVersion")]
    pub spec_version: u32,
    #[doc(alias = "implementationVersion")]
    pub implementation_version: u32,
    pub description: String,
}
impl LayerProperties {
    ///Get a reference to the `layer_name` field.
    pub fn layer_name(&self) -> &String {
        &self.layer_name
    }
    ///Get a reference to the `spec_version` field.
    pub fn spec_version(&self) -> u32 {
        self.spec_version
    }
    ///Get a reference to the `implementation_version` field.
    pub fn implementation_version(&self) -> u32 {
        self.implementation_version
    }
    ///Get a reference to the `description` field.
    pub fn description(&self) -> &String {
        &self.description
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for LayerProperties {
    type LowLevel = crate::native::vulkan1_0::LayerProperties;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        let layer_name_bytes = self.layer_name.as_bytes();
        debug_assert!(
            memchr::memchr(0, layer_name_bytes).is_none(),
            "string array contains null characters"
        );
        debug_assert!(
            layer_name_bytes.len() <= MAX_EXTENSION_NAME_SIZE as usize,
            "string is too long for the backing array"
        );
        let mut layer_name: [std::ffi::c_char; MAX_EXTENSION_NAME_SIZE as usize] =
            [0; MAX_EXTENSION_NAME_SIZE as usize];
        layer_name[0..layer_name_bytes.len()].copy_from_slice(std::slice::from_raw_parts(
            layer_name_bytes.as_ptr() as *const std::ffi::c_char,
            layer_name_bytes.len(),
        ));
        let description_bytes = self.description.as_bytes();
        debug_assert!(
            memchr::memchr(0, description_bytes).is_none(),
            "string array contains null characters"
        );
        debug_assert!(
            description_bytes.len() <= MAX_DESCRIPTION_SIZE as usize,
            "string is too long for the backing array"
        );
        let mut description: [std::ffi::c_char; MAX_DESCRIPTION_SIZE as usize] = [0; MAX_DESCRIPTION_SIZE as usize];
        description[0..description_bytes.len()].copy_from_slice(std::slice::from_raw_parts(
            description_bytes.as_ptr() as *const std::ffi::c_char,
            description_bytes.len(),
        ));
        crate::native::vulkan1_0::LayerProperties {
            layer_name: layer_name,
            spec_version: self.spec_version.into_low_level(context, bump),
            implementation_version: self.implementation_version.into_low_level(context, bump),
            description: description,
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for LayerProperties {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        let layer_name_cstr = std::ffi::CStr::from_ptr(value.layer_name.as_ptr());
        let layer_name = layer_name_cstr.to_string_lossy().into_owned();
        let description_cstr = std::ffi::CStr::from_ptr(value.description.as_ptr());
        let description = description_cstr.to_string_lossy().into_owned();
        Self {
            layer_name: layer_name,
            spec_version: crate::conv::FromLowLevel::from_low_level(context, value.spec_version),
            implementation_version: crate::conv::FromLowLevel::from_low_level(context, value.implementation_version),
            description: description,
        }
    }
}
#[doc(alias = "VkApplicationInfo")]
#[derive(Clone, PartialEq, Debug, Default)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct ApplicationInfo {
    #[doc(alias = "pApplicationName")]
    pub application_name: Option<String>,
    #[doc(alias = "applicationVersion")]
    pub application_version: u32,
    #[doc(alias = "pEngineName")]
    pub engine_name: Option<String>,
    #[doc(alias = "engineVersion")]
    pub engine_version: u32,
    #[doc(alias = "apiVersion")]
    pub api_version: u32,
}
impl ApplicationInfo {
    ///Get a reference to the `application_name` field.
    pub fn application_name(&self) -> &Option<String> {
        &self.application_name
    }
    ///Get a reference to the `application_version` field.
    pub fn application_version(&self) -> u32 {
        self.application_version
    }
    ///Get a reference to the `engine_name` field.
    pub fn engine_name(&self) -> &Option<String> {
        &self.engine_name
    }
    ///Get a reference to the `engine_version` field.
    pub fn engine_version(&self) -> u32 {
        self.engine_version
    }
    ///Get a reference to the `api_version` field.
    pub fn api_version(&self) -> u32 {
        self.api_version
    }
    ///Get a mutable reference to the `application_name` field.
    pub fn application_name_mut(&mut self) -> &mut Option<String> {
        &mut self.application_name
    }
    ///Get a mutable reference to the `application_version` field.
    pub fn application_version_mut(&mut self) -> &mut u32 {
        &mut self.application_version
    }
    ///Get a mutable reference to the `engine_name` field.
    pub fn engine_name_mut(&mut self) -> &mut Option<String> {
        &mut self.engine_name
    }
    ///Get a mutable reference to the `engine_version` field.
    pub fn engine_version_mut(&mut self) -> &mut u32 {
        &mut self.engine_version
    }
    ///Get a mutable reference to the `api_version` field.
    pub fn api_version_mut(&mut self) -> &mut u32 {
        &mut self.api_version
    }
    ///Sets the `application_name` field.
    pub fn set_application_name(&mut self, application_name: Option<String>) -> &mut Self {
        self.application_name = application_name;
        self
    }
    ///Sets the `application_version` field.
    pub fn set_application_version(&mut self, application_version: u32) -> &mut Self {
        self.application_version = application_version;
        self
    }
    ///Sets the `engine_name` field.
    pub fn set_engine_name(&mut self, engine_name: Option<String>) -> &mut Self {
        self.engine_name = engine_name;
        self
    }
    ///Sets the `engine_version` field.
    pub fn set_engine_version(&mut self, engine_version: u32) -> &mut Self {
        self.engine_version = engine_version;
        self
    }
    ///Sets the `api_version` field.
    pub fn set_api_version(&mut self, api_version: u32) -> &mut Self {
        self.api_version = api_version;
        self
    }
    ///Sets the `application_name` field in a builder way.
    pub fn with_application_name(mut self, application_name: Option<String>) -> Self {
        self.application_name = application_name;
        self
    }
    ///Sets the `application_version` field in a builder way.
    pub fn with_application_version(mut self, application_version: u32) -> Self {
        self.application_version = application_version;
        self
    }
    ///Sets the `engine_name` field in a builder way.
    pub fn with_engine_name(mut self, engine_name: Option<String>) -> Self {
        self.engine_name = engine_name;
        self
    }
    ///Sets the `engine_version` field in a builder way.
    pub fn with_engine_version(mut self, engine_version: u32) -> Self {
        self.engine_version = engine_version;
        self
    }
    ///Sets the `api_version` field in a builder way.
    pub fn with_api_version(mut self, api_version: u32) -> Self {
        self.api_version = api_version;
        self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for ApplicationInfo {
    type LowLevel = crate::native::vulkan1_0::ApplicationInfo;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        crate::native::vulkan1_0::ApplicationInfo {
            s_type: StructureType::ApplicationInfo,
            p_next: std::ptr::null(),
            application_name: self
                .application_name
                .as_ref()
                .map(|v| v.into_low_level(context, bump))
                .unwrap_or_else(std::ptr::null),
            application_version: self.application_version.into_low_level(context, bump),
            engine_name: self
                .engine_name
                .as_ref()
                .map(|v| v.into_low_level(context, bump))
                .unwrap_or_else(std::ptr::null),
            engine_version: self.engine_version.into_low_level(context, bump),
            api_version: self.api_version.into_low_level(context, bump),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for ApplicationInfo {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        Self {
            application_name: crate::conv::FromLowLevel::from_low_level(context, value.application_name),
            application_version: crate::conv::FromLowLevel::from_low_level(context, value.application_version),
            engine_name: crate::conv::FromLowLevel::from_low_level(context, value.engine_name),
            engine_version: crate::conv::FromLowLevel::from_low_level(context, value.engine_version),
            api_version: crate::conv::FromLowLevel::from_low_level(context, value.api_version),
        }
    }
}
#[doc(alias = "VkDeviceQueueCreateInfo")]
#[derive(Clone, PartialEq, Debug, Default)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct DeviceQueueCreateInfo {
    #[doc(alias = "pNext")]
    pub extensions: SmallVec<[DeviceQueueCreateInfoExtension; 1]>,
    pub flags: DeviceQueueCreateFlags,
    #[doc(alias = "queueFamilyIndex")]
    pub queue_family_index: u32,
    #[doc(alias = "pQueuePriorities")]
    pub queue_priorities: SmallVec<[f32; 8]>,
}
impl DeviceQueueCreateInfo {
    ///Adds an extension to the struct
    pub fn with_extension(mut self, ext: impl Into<DeviceQueueCreateInfoExtension>) -> Self {
        self.extensions.push(ext.into());
        self
    }
    ///Get a reference to the `extensions` field.
    pub fn extensions(&self) -> &SmallVec<[DeviceQueueCreateInfoExtension; 1]> {
        &self.extensions
    }
    ///Get a reference to the `flags` field.
    pub fn flags(&self) -> DeviceQueueCreateFlags {
        self.flags
    }
    ///Get a reference to the `queue_family_index` field.
    pub fn queue_family_index(&self) -> u32 {
        self.queue_family_index
    }
    ///Get a reference to the `queue_priorities` field.
    pub fn queue_priorities(&self) -> &SmallVec<[f32; 8]> {
        &self.queue_priorities
    }
    ///Get a mutable reference to the `extensions` field.
    pub fn extensions_mut(&mut self) -> &mut SmallVec<[DeviceQueueCreateInfoExtension; 1]> {
        &mut self.extensions
    }
    ///Get a mutable reference to the `flags` field.
    pub fn flags_mut(&mut self) -> &mut DeviceQueueCreateFlags {
        &mut self.flags
    }
    ///Get a mutable reference to the `queue_family_index` field.
    pub fn queue_family_index_mut(&mut self) -> &mut u32 {
        &mut self.queue_family_index
    }
    ///Get a mutable reference to the `queue_priorities` field.
    pub fn queue_priorities_mut(&mut self) -> &mut SmallVec<[f32; 8]> {
        &mut self.queue_priorities
    }
    ///Sets the `extensions` field.
    pub fn set_extensions(&mut self, extensions: SmallVec<[DeviceQueueCreateInfoExtension; 1]>) -> &mut Self {
        self.extensions = extensions;
        self
    }
    ///Sets the `flags` field.
    pub fn set_flags(&mut self, flags: DeviceQueueCreateFlags) -> &mut Self {
        self.flags = flags;
        self
    }
    ///Sets the `queue_family_index` field.
    pub fn set_queue_family_index(&mut self, queue_family_index: u32) -> &mut Self {
        self.queue_family_index = queue_family_index;
        self
    }
    ///Sets the `queue_priorities` field.
    pub fn set_queue_priorities(&mut self, queue_priorities: SmallVec<[f32; 8]>) -> &mut Self {
        self.queue_priorities = queue_priorities;
        self
    }
    ///Sets the `extensions` field in a builder way.
    pub fn with_extensions(mut self, extensions: SmallVec<[DeviceQueueCreateInfoExtension; 1]>) -> Self {
        self.extensions = extensions;
        self
    }
    ///Sets the `flags` field in a builder way.
    pub fn with_flags(mut self, flags: DeviceQueueCreateFlags) -> Self {
        self.flags = flags;
        self
    }
    ///Sets the `queue_family_index` field in a builder way.
    pub fn with_queue_family_index(mut self, queue_family_index: u32) -> Self {
        self.queue_family_index = queue_family_index;
        self
    }
    ///Sets the `queue_priorities` field in a builder way.
    pub fn with_queue_priorities(mut self, queue_priorities: SmallVec<[f32; 8]>) -> Self {
        self.queue_priorities = queue_priorities;
        self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for DeviceQueueCreateInfo {
    type LowLevel = crate::native::vulkan1_0::DeviceQueueCreateInfo;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        let mut next = std::ptr::null();
        let mut extensions = self.extensions.iter();
        while let Some(ext) = extensions.next() {
            let ext = ext.into_low_level(context, bump);
            (*ext).next = next;
            next = ext;
        }
        let len_queue_priorities = self.queue_priorities.len() as u32;
        let queue_priorities = bump
            .alloc_slice_fill_iter(self.queue_priorities.iter().map(|x| x.into_low_level(context, bump)))
            .as_ptr()
            .cast();
        crate::native::vulkan1_0::DeviceQueueCreateInfo {
            s_type: StructureType::DeviceQueueCreateInfo,
            p_next: next,
            flags: self.flags.into_low_level(context, bump),
            queue_family_index: self.queue_family_index.into_low_level(context, bump),
            queue_count: len_queue_priorities,
            queue_priorities: queue_priorities,
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for DeviceQueueCreateInfo {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        let mut next = value.p_next;
        let mut extensions = SmallVec::new();
        while !next.is_null() {
            extensions.push(crate::conv::FromLowLevel::from_low_level(context, next));
            next = std::ptr::read(next).next;
        }
        let queue_priorities_len = value.queue_count;
        let mut queue_priorities = SmallVec::with_capacity(queue_priorities_len as usize);
        for i in 0..queue_priorities_len {
            queue_priorities.push(crate::conv::FromLowLevel::from_low_level(
                context,
                value.queue_priorities.add(i as usize).read(),
            ));
        }
        Self {
            extensions: extensions,
            flags: crate::conv::FromLowLevel::from_low_level(context, value.flags),
            queue_family_index: crate::conv::FromLowLevel::from_low_level(context, value.queue_family_index),
            queue_priorities: queue_priorities,
        }
    }
}
#[derive(Clone, PartialEq, Debug, Copy)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
///Extensions for [`DeviceQueueCreateInfo`]
pub enum DeviceQueueCreateInfoExtension {
    #[cfg(feature = "VK_KHR_global_priority")]
    ///Contains a type [`DeviceQueueGlobalPriorityCreateInfoKHR`] for extending
    /// [`DeviceQueueCreateInfo`]
    DeviceQueueGlobalPriorityCreateInfoKHR(DeviceQueueGlobalPriorityCreateInfoKHR),
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for DeviceQueueCreateInfoExtension {
    type LowLevel = *const crate::native::vulkan1_0::BaseInStructure;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        match self {
            #[cfg(feature = "VK_KHR_global_priority")]
            Self::DeviceQueueGlobalPriorityCreateInfoKHR(ext) => (bump.alloc(ext.into_low_level(context, bump))
                as *mut crate::native::extensions::khr_global_priority::DeviceQueueGlobalPriorityCreateInfoKHR)
                .cast(),
            other => unreachable!("unexpected variant {:?}", other),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for DeviceQueueCreateInfoExtension {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        assert!(!value.is_null());
        match (* value) . s_type { # [cfg (feature = "VK_KHR_global_priority")] crate :: native :: vulkan1_0 :: StructureType :: DeviceQueueGlobalPriorityCreateInfoKhr => Self :: DeviceQueueGlobalPriorityCreateInfoKHR (DeviceQueueGlobalPriorityCreateInfoKHR :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: khr_global_priority :: DeviceQueueGlobalPriorityCreateInfoKHR > ()))) , other => panic ! ("Structure type {:?} is not a member of {}" , other , stringify ! (DeviceQueueCreateInfo)) }
    }
}
#[cfg(feature = "VK_KHR_global_priority")]
impl From<DeviceQueueGlobalPriorityCreateInfoKHR> for DeviceQueueCreateInfoExtension {
    fn from(ext: DeviceQueueGlobalPriorityCreateInfoKHR) -> Self {
        Self::DeviceQueueGlobalPriorityCreateInfoKHR(ext)
    }
}
#[cfg(feature = "VK_KHR_global_priority")]
impl TryInto<DeviceQueueGlobalPriorityCreateInfoKHR> for DeviceQueueCreateInfoExtension {
    type Error = DeviceQueueCreateInfoExtension;
    fn try_into(self) -> Result<DeviceQueueGlobalPriorityCreateInfoKHR, Self::Error> {
        match self {
            Self::DeviceQueueGlobalPriorityCreateInfoKHR(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[doc(alias = "VkDeviceCreateInfo")]
#[derive(Clone, PartialEq, Debug, Default)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct DeviceCreateInfo {
    #[doc(alias = "pNext")]
    pub extensions: SmallVec<[DeviceCreateInfoExtension; 1]>,
    pub flags: DeviceCreateFlags,
    #[doc(alias = "pQueueCreateInfos")]
    pub queue_create_infos: SmallVec<[DeviceQueueCreateInfo; 8]>,
    #[doc(alias = "ppEnabledLayerNames")]
    pub pp_enabled_layer_names: SmallVec<[String; 8]>,
    #[doc(alias = "ppEnabledExtensionNames")]
    pub pp_enabled_extension_names: SmallVec<[String; 8]>,
    #[doc(alias = "pEnabledFeatures")]
    pub enabled_features: Option<PhysicalDeviceFeatures>,
}
impl DeviceCreateInfo {
    ///Adds an extension to the struct
    pub fn with_extension(mut self, ext: impl Into<DeviceCreateInfoExtension>) -> Self {
        self.extensions.push(ext.into());
        self
    }
    ///Get a reference to the `extensions` field.
    pub fn extensions(&self) -> &SmallVec<[DeviceCreateInfoExtension; 1]> {
        &self.extensions
    }
    ///Get a reference to the `flags` field.
    pub fn flags(&self) -> DeviceCreateFlags {
        self.flags
    }
    ///Get a reference to the `queue_create_infos` field.
    pub fn queue_create_infos(&self) -> &SmallVec<[DeviceQueueCreateInfo; 8]> {
        &self.queue_create_infos
    }
    ///Get a reference to the `pp_enabled_layer_names` field.
    pub fn pp_enabled_layer_names(&self) -> &SmallVec<[String; 8]> {
        &self.pp_enabled_layer_names
    }
    ///Get a reference to the `pp_enabled_extension_names` field.
    pub fn pp_enabled_extension_names(&self) -> &SmallVec<[String; 8]> {
        &self.pp_enabled_extension_names
    }
    ///Get a reference to the `enabled_features` field.
    pub fn enabled_features(&self) -> &Option<PhysicalDeviceFeatures> {
        &self.enabled_features
    }
    ///Get a mutable reference to the `extensions` field.
    pub fn extensions_mut(&mut self) -> &mut SmallVec<[DeviceCreateInfoExtension; 1]> {
        &mut self.extensions
    }
    ///Get a mutable reference to the `flags` field.
    pub fn flags_mut(&mut self) -> &mut DeviceCreateFlags {
        &mut self.flags
    }
    ///Get a mutable reference to the `queue_create_infos` field.
    pub fn queue_create_infos_mut(&mut self) -> &mut SmallVec<[DeviceQueueCreateInfo; 8]> {
        &mut self.queue_create_infos
    }
    ///Get a mutable reference to the `pp_enabled_layer_names` field.
    pub fn pp_enabled_layer_names_mut(&mut self) -> &mut SmallVec<[String; 8]> {
        &mut self.pp_enabled_layer_names
    }
    ///Get a mutable reference to the `pp_enabled_extension_names` field.
    pub fn pp_enabled_extension_names_mut(&mut self) -> &mut SmallVec<[String; 8]> {
        &mut self.pp_enabled_extension_names
    }
    ///Get a mutable reference to the `enabled_features` field.
    pub fn enabled_features_mut(&mut self) -> &mut Option<PhysicalDeviceFeatures> {
        &mut self.enabled_features
    }
    ///Sets the `extensions` field.
    pub fn set_extensions(&mut self, extensions: SmallVec<[DeviceCreateInfoExtension; 1]>) -> &mut Self {
        self.extensions = extensions;
        self
    }
    ///Sets the `flags` field.
    pub fn set_flags(&mut self, flags: DeviceCreateFlags) -> &mut Self {
        self.flags = flags;
        self
    }
    ///Sets the `queue_create_infos` field.
    pub fn set_queue_create_infos(&mut self, queue_create_infos: SmallVec<[DeviceQueueCreateInfo; 8]>) -> &mut Self {
        self.queue_create_infos = queue_create_infos;
        self
    }
    ///Sets the `pp_enabled_layer_names` field.
    pub fn set_pp_enabled_layer_names(&mut self, pp_enabled_layer_names: SmallVec<[String; 8]>) -> &mut Self {
        self.pp_enabled_layer_names = pp_enabled_layer_names;
        self
    }
    ///Sets the `pp_enabled_extension_names` field.
    pub fn set_pp_enabled_extension_names(&mut self, pp_enabled_extension_names: SmallVec<[String; 8]>) -> &mut Self {
        self.pp_enabled_extension_names = pp_enabled_extension_names;
        self
    }
    ///Sets the `enabled_features` field.
    pub fn set_enabled_features(&mut self, enabled_features: Option<PhysicalDeviceFeatures>) -> &mut Self {
        self.enabled_features = enabled_features;
        self
    }
    ///Sets the `extensions` field in a builder way.
    pub fn with_extensions(mut self, extensions: SmallVec<[DeviceCreateInfoExtension; 1]>) -> Self {
        self.extensions = extensions;
        self
    }
    ///Sets the `flags` field in a builder way.
    pub fn with_flags(mut self, flags: DeviceCreateFlags) -> Self {
        self.flags = flags;
        self
    }
    ///Sets the `queue_create_infos` field in a builder way.
    pub fn with_queue_create_infos(mut self, queue_create_infos: SmallVec<[DeviceQueueCreateInfo; 8]>) -> Self {
        self.queue_create_infos = queue_create_infos;
        self
    }
    ///Sets the `pp_enabled_layer_names` field in a builder way.
    pub fn with_pp_enabled_layer_names(mut self, pp_enabled_layer_names: SmallVec<[String; 8]>) -> Self {
        self.pp_enabled_layer_names = pp_enabled_layer_names;
        self
    }
    ///Sets the `pp_enabled_extension_names` field in a builder way.
    pub fn with_pp_enabled_extension_names(mut self, pp_enabled_extension_names: SmallVec<[String; 8]>) -> Self {
        self.pp_enabled_extension_names = pp_enabled_extension_names;
        self
    }
    ///Sets the `enabled_features` field in a builder way.
    pub fn with_enabled_features(mut self, enabled_features: Option<PhysicalDeviceFeatures>) -> Self {
        self.enabled_features = enabled_features;
        self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for DeviceCreateInfo {
    type LowLevel = crate::native::vulkan1_0::DeviceCreateInfo;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        let mut next = std::ptr::null();
        let mut extensions = self.extensions.iter();
        while let Some(ext) = extensions.next() {
            let ext = ext.into_low_level(context, bump);
            (*ext).next = next;
            next = ext;
        }
        let len_queue_create_infos = self.queue_create_infos.len() as u32;
        let queue_create_infos = bump
            .alloc_slice_fill_iter(self.queue_create_infos.iter().map(|x| x.into_low_level(context, bump)))
            .as_ptr()
            .cast();
        let len_pp_enabled_layer_names = self.pp_enabled_layer_names.len() as u32;
        let pp_enabled_layer_names = bump
            .alloc_slice_fill_iter(
                self.pp_enabled_layer_names
                    .iter()
                    .map(|x| x.into_low_level(context, bump)),
            )
            .as_ptr()
            .cast();
        let len_pp_enabled_extension_names = self.pp_enabled_extension_names.len() as u32;
        let pp_enabled_extension_names = bump
            .alloc_slice_fill_iter(
                self.pp_enabled_extension_names
                    .iter()
                    .map(|x| x.into_low_level(context, bump)),
            )
            .as_ptr()
            .cast();
        crate::native::vulkan1_0::DeviceCreateInfo {
            s_type: StructureType::DeviceCreateInfo,
            p_next: next,
            flags: self.flags.into_low_level(context, bump),
            queue_create_info_count: len_queue_create_infos,
            queue_create_infos: queue_create_infos,
            enabled_layer_count: len_pp_enabled_layer_names,
            pp_enabled_layer_names: pp_enabled_layer_names,
            enabled_extension_count: len_pp_enabled_extension_names,
            pp_enabled_extension_names: pp_enabled_extension_names,
            enabled_features: self
                .enabled_features
                .as_ref()
                .map(|v| bump.alloc(v.into_low_level(context, bump)) as *const _)
                .unwrap_or_else(std::ptr::null),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for DeviceCreateInfo {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        let mut next = value.p_next;
        let mut extensions = SmallVec::new();
        while !next.is_null() {
            extensions.push(crate::conv::FromLowLevel::from_low_level(context, next));
            next = std::ptr::read(next).next;
        }
        let queue_create_infos_len = value.queue_create_info_count;
        let mut queue_create_infos = SmallVec::with_capacity(queue_create_infos_len as usize);
        for i in 0..queue_create_infos_len {
            queue_create_infos.push(crate::conv::FromLowLevel::from_low_level(
                context,
                value.queue_create_infos.add(i as usize).read(),
            ));
        }
        let pp_enabled_layer_names_len = value.enabled_layer_count;
        let mut pp_enabled_layer_names = SmallVec::with_capacity(pp_enabled_layer_names_len as usize);
        for i in 0..pp_enabled_layer_names_len {
            pp_enabled_layer_names.push(crate::conv::FromLowLevel::from_low_level(
                context,
                value.pp_enabled_layer_names.add(i as usize).read(),
            ));
        }
        let pp_enabled_extension_names_len = value.enabled_extension_count;
        let mut pp_enabled_extension_names = SmallVec::with_capacity(pp_enabled_extension_names_len as usize);
        for i in 0..pp_enabled_extension_names_len {
            pp_enabled_extension_names.push(crate::conv::FromLowLevel::from_low_level(
                context,
                value.pp_enabled_extension_names.add(i as usize).read(),
            ));
        }
        Self {
            extensions: extensions,
            flags: crate::conv::FromLowLevel::from_low_level(context, value.flags),
            queue_create_infos: queue_create_infos,
            pp_enabled_layer_names: pp_enabled_layer_names,
            pp_enabled_extension_names: pp_enabled_extension_names,
            enabled_features: crate::conv::FromLowLevel::from_low_level(context, *value.enabled_features),
        }
    }
}
#[derive(Clone, PartialEq, Debug)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
///Extensions for [`DeviceCreateInfo`]
pub enum DeviceCreateInfoExtension {
    #[cfg(feature = "VK_NV_device_generated_commands")]
    ///Contains a type [`PhysicalDeviceDeviceGeneratedCommandsFeaturesNV`] for extending
    /// [`DeviceCreateInfo`]
    PhysicalDeviceDeviceGeneratedCommandsFeaturesNV(PhysicalDeviceDeviceGeneratedCommandsFeaturesNV),
    #[cfg(feature = "VULKAN_1_3")]
    ///Contains a type [`DevicePrivateDataCreateInfo`] for extending [`DeviceCreateInfo`]
    DevicePrivateDataCreateInfo(DevicePrivateDataCreateInfo),
    #[cfg(feature = "VULKAN_1_3")]
    ///Contains a type [`PhysicalDevicePrivateDataFeatures`] for extending [`DeviceCreateInfo`]
    PhysicalDevicePrivateDataFeatures(PhysicalDevicePrivateDataFeatures),
    ///Contains a type [`PhysicalDeviceFeatures2`] for extending [`DeviceCreateInfo`]
    PhysicalDeviceFeatures2(PhysicalDeviceFeatures2),
    ///Contains a type [`PhysicalDeviceVariablePointersFeatures`] for extending
    /// [`DeviceCreateInfo`]
    PhysicalDeviceVariablePointersFeatures(PhysicalDeviceVariablePointersFeatures),
    ///Contains a type [`PhysicalDeviceMultiviewFeatures`] for extending [`DeviceCreateInfo`]
    PhysicalDeviceMultiviewFeatures(PhysicalDeviceMultiviewFeatures),
    ///Contains a type [`DeviceGroupDeviceCreateInfo`] for extending [`DeviceCreateInfo`]
    DeviceGroupDeviceCreateInfo(DeviceGroupDeviceCreateInfo),
    #[cfg(feature = "VK_KHR_present_id")]
    ///Contains a type [`PhysicalDevicePresentIdFeaturesKHR`] for extending [`DeviceCreateInfo`]
    PhysicalDevicePresentIdFeaturesKHR(PhysicalDevicePresentIdFeaturesKHR),
    #[cfg(feature = "VK_KHR_present_wait")]
    ///Contains a type [`PhysicalDevicePresentWaitFeaturesKHR`] for extending [`DeviceCreateInfo`]
    PhysicalDevicePresentWaitFeaturesKHR(PhysicalDevicePresentWaitFeaturesKHR),
    ///Contains a type [`PhysicalDevice16BitStorageFeatures`] for extending [`DeviceCreateInfo`]
    PhysicalDevice16BitStorageFeatures(PhysicalDevice16BitStorageFeatures),
    #[cfg(feature = "VULKAN_1_2")]
    ///Contains a type [`PhysicalDeviceShaderSubgroupExtendedTypesFeatures`] for extending
    /// [`DeviceCreateInfo`]
    PhysicalDeviceShaderSubgroupExtendedTypesFeatures(PhysicalDeviceShaderSubgroupExtendedTypesFeatures),
    ///Contains a type [`PhysicalDeviceSamplerYcbcrConversionFeatures`] for extending
    /// [`DeviceCreateInfo`]
    PhysicalDeviceSamplerYcbcrConversionFeatures(PhysicalDeviceSamplerYcbcrConversionFeatures),
    ///Contains a type [`PhysicalDeviceProtectedMemoryFeatures`] for extending [`DeviceCreateInfo`]
    PhysicalDeviceProtectedMemoryFeatures(PhysicalDeviceProtectedMemoryFeatures),
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    ///Contains a type [`PhysicalDeviceBlendOperationAdvancedFeaturesEXT`] for extending
    /// [`DeviceCreateInfo`]
    PhysicalDeviceBlendOperationAdvancedFeaturesEXT(PhysicalDeviceBlendOperationAdvancedFeaturesEXT),
    #[cfg(feature = "VK_EXT_multi_draw")]
    ///Contains a type [`PhysicalDeviceMultiDrawFeaturesEXT`] for extending [`DeviceCreateInfo`]
    PhysicalDeviceMultiDrawFeaturesEXT(PhysicalDeviceMultiDrawFeaturesEXT),
    #[cfg(feature = "VULKAN_1_3")]
    ///Contains a type [`PhysicalDeviceInlineUniformBlockFeatures`] for extending
    /// [`DeviceCreateInfo`]
    PhysicalDeviceInlineUniformBlockFeatures(PhysicalDeviceInlineUniformBlockFeatures),
    #[cfg(feature = "VULKAN_1_3")]
    ///Contains a type [`PhysicalDeviceMaintenance4Features`] for extending [`DeviceCreateInfo`]
    PhysicalDeviceMaintenance4Features(PhysicalDeviceMaintenance4Features),
    ///Contains a type [`PhysicalDeviceShaderDrawParametersFeatures`] for extending
    /// [`DeviceCreateInfo`]
    PhysicalDeviceShaderDrawParametersFeatures(PhysicalDeviceShaderDrawParametersFeatures),
    #[cfg(feature = "VULKAN_1_2")]
    ///Contains a type [`PhysicalDeviceShaderFloat16Int8Features`] for extending
    /// [`DeviceCreateInfo`]
    PhysicalDeviceShaderFloat16Int8Features(PhysicalDeviceShaderFloat16Int8Features),
    #[cfg(feature = "VULKAN_1_2")]
    ///Contains a type [`PhysicalDeviceHostQueryResetFeatures`] for extending [`DeviceCreateInfo`]
    PhysicalDeviceHostQueryResetFeatures(PhysicalDeviceHostQueryResetFeatures),
    #[cfg(feature = "VK_KHR_global_priority")]
    ///Contains a type [`PhysicalDeviceGlobalPriorityQueryFeaturesKHR`] for extending
    /// [`DeviceCreateInfo`]
    PhysicalDeviceGlobalPriorityQueryFeaturesKHR(PhysicalDeviceGlobalPriorityQueryFeaturesKHR),
    #[cfg(feature = "VK_EXT_device_memory_report")]
    ///Contains a type [`PhysicalDeviceDeviceMemoryReportFeaturesEXT`] for extending
    /// [`DeviceCreateInfo`]
    PhysicalDeviceDeviceMemoryReportFeaturesEXT(PhysicalDeviceDeviceMemoryReportFeaturesEXT),
    #[cfg(feature = "VK_EXT_device_memory_report")]
    ///Contains a type [`DeviceDeviceMemoryReportCreateInfoEXT`] for extending [`DeviceCreateInfo`]
    DeviceDeviceMemoryReportCreateInfoEXT(DeviceDeviceMemoryReportCreateInfoEXT),
    #[cfg(feature = "VULKAN_1_2")]
    ///Contains a type [`PhysicalDeviceDescriptorIndexingFeatures`] for extending
    /// [`DeviceCreateInfo`]
    PhysicalDeviceDescriptorIndexingFeatures(PhysicalDeviceDescriptorIndexingFeatures),
    #[cfg(feature = "VULKAN_1_2")]
    ///Contains a type [`PhysicalDeviceTimelineSemaphoreFeatures`] for extending
    /// [`DeviceCreateInfo`]
    PhysicalDeviceTimelineSemaphoreFeatures(PhysicalDeviceTimelineSemaphoreFeatures),
    #[cfg(feature = "VULKAN_1_2")]
    ///Contains a type [`PhysicalDevice8BitStorageFeatures`] for extending [`DeviceCreateInfo`]
    PhysicalDevice8BitStorageFeatures(PhysicalDevice8BitStorageFeatures),
    #[cfg(feature = "VK_EXT_conditional_rendering")]
    ///Contains a type [`PhysicalDeviceConditionalRenderingFeaturesEXT`] for extending
    /// [`DeviceCreateInfo`]
    PhysicalDeviceConditionalRenderingFeaturesEXT(PhysicalDeviceConditionalRenderingFeaturesEXT),
    #[cfg(feature = "VULKAN_1_2")]
    ///Contains a type [`PhysicalDeviceVulkanMemoryModelFeatures`] for extending
    /// [`DeviceCreateInfo`]
    PhysicalDeviceVulkanMemoryModelFeatures(PhysicalDeviceVulkanMemoryModelFeatures),
    #[cfg(feature = "VULKAN_1_2")]
    ///Contains a type [`PhysicalDeviceShaderAtomicInt64Features`] for extending
    /// [`DeviceCreateInfo`]
    PhysicalDeviceShaderAtomicInt64Features(PhysicalDeviceShaderAtomicInt64Features),
    #[cfg(feature = "VK_EXT_shader_atomic_float")]
    ///Contains a type [`PhysicalDeviceShaderAtomicFloatFeaturesEXT`] for extending
    /// [`DeviceCreateInfo`]
    PhysicalDeviceShaderAtomicFloatFeaturesEXT(PhysicalDeviceShaderAtomicFloatFeaturesEXT),
    #[cfg(feature = "VK_EXT_shader_atomic_float2")]
    ///Contains a type [`PhysicalDeviceShaderAtomicFloat2FeaturesEXT`] for extending
    /// [`DeviceCreateInfo`]
    PhysicalDeviceShaderAtomicFloat2FeaturesEXT(PhysicalDeviceShaderAtomicFloat2FeaturesEXT),
    #[cfg(feature = "VK_EXT_vertex_attribute_divisor")]
    ///Contains a type [`PhysicalDeviceVertexAttributeDivisorFeaturesEXT`] for extending
    /// [`DeviceCreateInfo`]
    PhysicalDeviceVertexAttributeDivisorFeaturesEXT(PhysicalDeviceVertexAttributeDivisorFeaturesEXT),
    #[cfg(feature = "VK_EXT_astc_decode_mode")]
    ///Contains a type [`PhysicalDeviceAstcDecodeFeaturesEXT`] for extending [`DeviceCreateInfo`]
    PhysicalDeviceAstcDecodeFeaturesEXT(PhysicalDeviceAstcDecodeFeaturesEXT),
    #[cfg(feature = "VK_EXT_transform_feedback")]
    ///Contains a type [`PhysicalDeviceTransformFeedbackFeaturesEXT`] for extending
    /// [`DeviceCreateInfo`]
    PhysicalDeviceTransformFeedbackFeaturesEXT(PhysicalDeviceTransformFeedbackFeaturesEXT),
    #[cfg(feature = "VK_NV_representative_fragment_test")]
    ///Contains a type [`PhysicalDeviceRepresentativeFragmentTestFeaturesNV`] for extending
    /// [`DeviceCreateInfo`]
    PhysicalDeviceRepresentativeFragmentTestFeaturesNV(PhysicalDeviceRepresentativeFragmentTestFeaturesNV),
    #[cfg(feature = "VK_NV_scissor_exclusive")]
    ///Contains a type [`PhysicalDeviceExclusiveScissorFeaturesNV`] for extending
    /// [`DeviceCreateInfo`]
    PhysicalDeviceExclusiveScissorFeaturesNV(PhysicalDeviceExclusiveScissorFeaturesNV),
    #[cfg(feature = "VK_NV_corner_sampled_image")]
    ///Contains a type [`PhysicalDeviceCornerSampledImageFeaturesNV`] for extending
    /// [`DeviceCreateInfo`]
    PhysicalDeviceCornerSampledImageFeaturesNV(PhysicalDeviceCornerSampledImageFeaturesNV),
    #[cfg(feature = "VK_NV_compute_shader_derivatives")]
    ///Contains a type [`PhysicalDeviceComputeShaderDerivativesFeaturesNV`] for extending
    /// [`DeviceCreateInfo`]
    PhysicalDeviceComputeShaderDerivativesFeaturesNV(PhysicalDeviceComputeShaderDerivativesFeaturesNV),
    #[cfg(feature = "VK_NV_fragment_shader_barycentric")]
    ///Contains a type [`PhysicalDeviceFragmentShaderBarycentricFeaturesNV`] for extending
    /// [`DeviceCreateInfo`]
    PhysicalDeviceFragmentShaderBarycentricFeaturesNV(PhysicalDeviceFragmentShaderBarycentricFeaturesNV),
    #[cfg(feature = "VK_NV_shader_image_footprint")]
    ///Contains a type [`PhysicalDeviceShaderImageFootprintFeaturesNV`] for extending
    /// [`DeviceCreateInfo`]
    PhysicalDeviceShaderImageFootprintFeaturesNV(PhysicalDeviceShaderImageFootprintFeaturesNV),
    #[cfg(feature = "VK_NV_dedicated_allocation_image_aliasing")]
    ///Contains a type [`PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV`] for extending
    /// [`DeviceCreateInfo`]
    PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV(PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV),
    #[cfg(feature = "VK_NV_shading_rate_image")]
    ///Contains a type [`PhysicalDeviceShadingRateImageFeaturesNV`] for extending
    /// [`DeviceCreateInfo`]
    PhysicalDeviceShadingRateImageFeaturesNV(PhysicalDeviceShadingRateImageFeaturesNV),
    #[cfg(feature = "VK_HUAWEI_invocation_mask")]
    ///Contains a type [`PhysicalDeviceInvocationMaskFeaturesHUAWEI`] for extending
    /// [`DeviceCreateInfo`]
    PhysicalDeviceInvocationMaskFeaturesHUAWEI(PhysicalDeviceInvocationMaskFeaturesHUAWEI),
    #[cfg(feature = "VK_NV_mesh_shader")]
    ///Contains a type [`PhysicalDeviceMeshShaderFeaturesNV`] for extending [`DeviceCreateInfo`]
    PhysicalDeviceMeshShaderFeaturesNV(PhysicalDeviceMeshShaderFeaturesNV),
    #[cfg(feature = "VK_KHR_acceleration_structure")]
    ///Contains a type [`PhysicalDeviceAccelerationStructureFeaturesKHR`] for extending
    /// [`DeviceCreateInfo`]
    PhysicalDeviceAccelerationStructureFeaturesKHR(PhysicalDeviceAccelerationStructureFeaturesKHR),
    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
    ///Contains a type [`PhysicalDeviceRayTracingPipelineFeaturesKHR`] for extending
    /// [`DeviceCreateInfo`]
    PhysicalDeviceRayTracingPipelineFeaturesKHR(PhysicalDeviceRayTracingPipelineFeaturesKHR),
    #[cfg(feature = "VK_KHR_ray_query")]
    ///Contains a type [`PhysicalDeviceRayQueryFeaturesKHR`] for extending [`DeviceCreateInfo`]
    PhysicalDeviceRayQueryFeaturesKHR(PhysicalDeviceRayQueryFeaturesKHR),
    #[cfg(feature = "VK_AMD_memory_overallocation_behavior")]
    ///Contains a type [`DeviceMemoryOverallocationCreateInfoAMD`] for extending
    /// [`DeviceCreateInfo`]
    DeviceMemoryOverallocationCreateInfoAMD(DeviceMemoryOverallocationCreateInfoAMD),
    #[cfg(feature = "VK_EXT_fragment_density_map")]
    ///Contains a type [`PhysicalDeviceFragmentDensityMapFeaturesEXT`] for extending
    /// [`DeviceCreateInfo`]
    PhysicalDeviceFragmentDensityMapFeaturesEXT(PhysicalDeviceFragmentDensityMapFeaturesEXT),
    #[cfg(feature = "VK_EXT_fragment_density_map2")]
    ///Contains a type [`PhysicalDeviceFragmentDensityMap2FeaturesEXT`] for extending
    /// [`DeviceCreateInfo`]
    PhysicalDeviceFragmentDensityMap2FeaturesEXT(PhysicalDeviceFragmentDensityMap2FeaturesEXT),
    #[cfg(feature = "VULKAN_1_2")]
    ///Contains a type [`PhysicalDeviceScalarBlockLayoutFeatures`] for extending
    /// [`DeviceCreateInfo`]
    PhysicalDeviceScalarBlockLayoutFeatures(PhysicalDeviceScalarBlockLayoutFeatures),
    #[cfg(feature = "VULKAN_1_2")]
    ///Contains a type [`PhysicalDeviceUniformBufferStandardLayoutFeatures`] for extending
    /// [`DeviceCreateInfo`]
    PhysicalDeviceUniformBufferStandardLayoutFeatures(PhysicalDeviceUniformBufferStandardLayoutFeatures),
    #[cfg(feature = "VK_EXT_depth_clip_enable")]
    ///Contains a type [`PhysicalDeviceDepthClipEnableFeaturesEXT`] for extending
    /// [`DeviceCreateInfo`]
    PhysicalDeviceDepthClipEnableFeaturesEXT(PhysicalDeviceDepthClipEnableFeaturesEXT),
    #[cfg(feature = "VK_EXT_memory_priority")]
    ///Contains a type [`PhysicalDeviceMemoryPriorityFeaturesEXT`] for extending
    /// [`DeviceCreateInfo`]
    PhysicalDeviceMemoryPriorityFeaturesEXT(PhysicalDeviceMemoryPriorityFeaturesEXT),
    #[cfg(feature = "VK_EXT_pageable_device_local_memory")]
    ///Contains a type [`PhysicalDevicePageableDeviceLocalMemoryFeaturesEXT`] for extending
    /// [`DeviceCreateInfo`]
    PhysicalDevicePageableDeviceLocalMemoryFeaturesEXT(PhysicalDevicePageableDeviceLocalMemoryFeaturesEXT),
    #[cfg(feature = "VULKAN_1_2")]
    ///Contains a type [`PhysicalDeviceBufferDeviceAddressFeatures`] for extending
    /// [`DeviceCreateInfo`]
    PhysicalDeviceBufferDeviceAddressFeatures(PhysicalDeviceBufferDeviceAddressFeatures),
    #[cfg(feature = "VK_EXT_buffer_device_address")]
    ///Contains a type [`PhysicalDeviceBufferDeviceAddressFeaturesEXT`] for extending
    /// [`DeviceCreateInfo`]
    PhysicalDeviceBufferDeviceAddressFeaturesEXT(PhysicalDeviceBufferDeviceAddressFeaturesEXT),
    #[cfg(feature = "VULKAN_1_2")]
    ///Contains a type [`PhysicalDeviceImagelessFramebufferFeatures`] for extending
    /// [`DeviceCreateInfo`]
    PhysicalDeviceImagelessFramebufferFeatures(PhysicalDeviceImagelessFramebufferFeatures),
    #[cfg(feature = "VULKAN_1_3")]
    ///Contains a type [`PhysicalDeviceTextureCompressionAstchdrFeatures`] for extending
    /// [`DeviceCreateInfo`]
    PhysicalDeviceTextureCompressionAstchdrFeatures(PhysicalDeviceTextureCompressionAstchdrFeatures),
    #[cfg(feature = "VK_NV_cooperative_matrix")]
    ///Contains a type [`PhysicalDeviceCooperativeMatrixFeaturesNV`] for extending
    /// [`DeviceCreateInfo`]
    PhysicalDeviceCooperativeMatrixFeaturesNV(PhysicalDeviceCooperativeMatrixFeaturesNV),
    #[cfg(feature = "VK_EXT_ycbcr_image_arrays")]
    ///Contains a type [`PhysicalDeviceYcbcrImageArraysFeaturesEXT`] for extending
    /// [`DeviceCreateInfo`]
    PhysicalDeviceYcbcrImageArraysFeaturesEXT(PhysicalDeviceYcbcrImageArraysFeaturesEXT),
    #[cfg(feature = "VK_KHR_performance_query")]
    ///Contains a type [`PhysicalDevicePerformanceQueryFeaturesKHR`] for extending
    /// [`DeviceCreateInfo`]
    PhysicalDevicePerformanceQueryFeaturesKHR(PhysicalDevicePerformanceQueryFeaturesKHR),
    #[cfg(feature = "VK_NV_coverage_reduction_mode")]
    ///Contains a type [`PhysicalDeviceCoverageReductionModeFeaturesNV`] for extending
    /// [`DeviceCreateInfo`]
    PhysicalDeviceCoverageReductionModeFeaturesNV(PhysicalDeviceCoverageReductionModeFeaturesNV),
    #[cfg(feature = "VK_INTEL_shader_integer_functions2")]
    ///Contains a type [`PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL`] for extending
    /// [`DeviceCreateInfo`]
    PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL(PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL),
    #[cfg(feature = "VK_KHR_shader_clock")]
    ///Contains a type [`PhysicalDeviceShaderClockFeaturesKHR`] for extending [`DeviceCreateInfo`]
    PhysicalDeviceShaderClockFeaturesKHR(PhysicalDeviceShaderClockFeaturesKHR),
    #[cfg(feature = "VK_EXT_index_type_uint8")]
    ///Contains a type [`PhysicalDeviceIndexTypeUint8FeaturesEXT`] for extending
    /// [`DeviceCreateInfo`]
    PhysicalDeviceIndexTypeUint8FeaturesEXT(PhysicalDeviceIndexTypeUint8FeaturesEXT),
    #[cfg(feature = "VK_NV_shader_sm_builtins")]
    ///Contains a type [`PhysicalDeviceShaderSmBuiltinsFeaturesNV`] for extending
    /// [`DeviceCreateInfo`]
    PhysicalDeviceShaderSmBuiltinsFeaturesNV(PhysicalDeviceShaderSmBuiltinsFeaturesNV),
    #[cfg(feature = "VK_EXT_fragment_shader_interlock")]
    ///Contains a type [`PhysicalDeviceFragmentShaderInterlockFeaturesEXT`] for extending
    /// [`DeviceCreateInfo`]
    PhysicalDeviceFragmentShaderInterlockFeaturesEXT(PhysicalDeviceFragmentShaderInterlockFeaturesEXT),
    #[cfg(feature = "VULKAN_1_2")]
    ///Contains a type [`PhysicalDeviceSeparateDepthStencilLayoutsFeatures`] for extending
    /// [`DeviceCreateInfo`]
    PhysicalDeviceSeparateDepthStencilLayoutsFeatures(PhysicalDeviceSeparateDepthStencilLayoutsFeatures),
    #[cfg(feature = "VK_EXT_primitive_topology_list_restart")]
    ///Contains a type [`PhysicalDevicePrimitiveTopologyListRestartFeaturesEXT`] for extending
    /// [`DeviceCreateInfo`]
    PhysicalDevicePrimitiveTopologyListRestartFeaturesEXT(PhysicalDevicePrimitiveTopologyListRestartFeaturesEXT),
    #[cfg(feature = "VK_KHR_pipeline_executable_properties")]
    ///Contains a type [`PhysicalDevicePipelineExecutablePropertiesFeaturesKHR`] for extending
    /// [`DeviceCreateInfo`]
    PhysicalDevicePipelineExecutablePropertiesFeaturesKHR(PhysicalDevicePipelineExecutablePropertiesFeaturesKHR),
    #[cfg(feature = "VULKAN_1_3")]
    ///Contains a type [`PhysicalDeviceShaderDemoteToHelperInvocationFeatures`] for extending
    /// [`DeviceCreateInfo`]
    PhysicalDeviceShaderDemoteToHelperInvocationFeatures(PhysicalDeviceShaderDemoteToHelperInvocationFeatures),
    #[cfg(feature = "VK_EXT_texel_buffer_alignment")]
    ///Contains a type [`PhysicalDeviceTexelBufferAlignmentFeaturesEXT`] for extending
    /// [`DeviceCreateInfo`]
    PhysicalDeviceTexelBufferAlignmentFeaturesEXT(PhysicalDeviceTexelBufferAlignmentFeaturesEXT),
    #[cfg(feature = "VULKAN_1_3")]
    ///Contains a type [`PhysicalDeviceSubgroupSizeControlFeatures`] for extending
    /// [`DeviceCreateInfo`]
    PhysicalDeviceSubgroupSizeControlFeatures(PhysicalDeviceSubgroupSizeControlFeatures),
    #[cfg(feature = "VK_EXT_line_rasterization")]
    ///Contains a type [`PhysicalDeviceLineRasterizationFeaturesEXT`] for extending
    /// [`DeviceCreateInfo`]
    PhysicalDeviceLineRasterizationFeaturesEXT(PhysicalDeviceLineRasterizationFeaturesEXT),
    #[cfg(feature = "VULKAN_1_3")]
    ///Contains a type [`PhysicalDevicePipelineCreationCacheControlFeatures`] for extending
    /// [`DeviceCreateInfo`]
    PhysicalDevicePipelineCreationCacheControlFeatures(PhysicalDevicePipelineCreationCacheControlFeatures),
    #[cfg(feature = "VULKAN_1_2")]
    ///Contains a type [`PhysicalDeviceVulkan11Features`] for extending [`DeviceCreateInfo`]
    PhysicalDeviceVulkan11Features(PhysicalDeviceVulkan11Features),
    #[cfg(feature = "VULKAN_1_2")]
    ///Contains a type [`PhysicalDeviceVulkan12Features`] for extending [`DeviceCreateInfo`]
    PhysicalDeviceVulkan12Features(PhysicalDeviceVulkan12Features),
    #[cfg(feature = "VULKAN_1_3")]
    ///Contains a type [`PhysicalDeviceVulkan13Features`] for extending [`DeviceCreateInfo`]
    PhysicalDeviceVulkan13Features(PhysicalDeviceVulkan13Features),
    #[cfg(feature = "VK_AMD_device_coherent_memory")]
    ///Contains a type [`PhysicalDeviceCoherentMemoryFeaturesAMD`] for extending
    /// [`DeviceCreateInfo`]
    PhysicalDeviceCoherentMemoryFeaturesAMD(PhysicalDeviceCoherentMemoryFeaturesAMD),
    #[cfg(feature = "VK_EXT_custom_border_color")]
    ///Contains a type [`PhysicalDeviceCustomBorderColorFeaturesEXT`] for extending
    /// [`DeviceCreateInfo`]
    PhysicalDeviceCustomBorderColorFeaturesEXT(PhysicalDeviceCustomBorderColorFeaturesEXT),
    #[cfg(feature = "VK_EXT_border_color_swizzle")]
    ///Contains a type [`PhysicalDeviceBorderColorSwizzleFeaturesEXT`] for extending
    /// [`DeviceCreateInfo`]
    PhysicalDeviceBorderColorSwizzleFeaturesEXT(PhysicalDeviceBorderColorSwizzleFeaturesEXT),
    #[cfg(feature = "VK_EXT_extended_dynamic_state")]
    ///Contains a type [`PhysicalDeviceExtendedDynamicStateFeaturesEXT`] for extending
    /// [`DeviceCreateInfo`]
    PhysicalDeviceExtendedDynamicStateFeaturesEXT(PhysicalDeviceExtendedDynamicStateFeaturesEXT),
    #[cfg(feature = "VK_EXT_extended_dynamic_state2")]
    ///Contains a type [`PhysicalDeviceExtendedDynamicState2FeaturesEXT`] for extending
    /// [`DeviceCreateInfo`]
    PhysicalDeviceExtendedDynamicState2FeaturesEXT(PhysicalDeviceExtendedDynamicState2FeaturesEXT),
    #[cfg(feature = "VK_NV_device_diagnostics_config")]
    ///Contains a type [`PhysicalDeviceDiagnosticsConfigFeaturesNV`] for extending
    /// [`DeviceCreateInfo`]
    PhysicalDeviceDiagnosticsConfigFeaturesNV(PhysicalDeviceDiagnosticsConfigFeaturesNV),
    #[cfg(feature = "VK_NV_device_diagnostics_config")]
    ///Contains a type [`DeviceDiagnosticsConfigCreateInfoNV`] for extending [`DeviceCreateInfo`]
    DeviceDiagnosticsConfigCreateInfoNV(DeviceDiagnosticsConfigCreateInfoNV),
    #[cfg(feature = "VULKAN_1_3")]
    ///Contains a type [`PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures`] for extending
    /// [`DeviceCreateInfo`]
    PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures(PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures),
    #[cfg(feature = "VK_KHR_shader_subgroup_uniform_control_flow")]
    ///Contains a type [`PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR`] for extending
    /// [`DeviceCreateInfo`]
    PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR(
        PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR,
    ),
    #[cfg(feature = "VK_EXT_robustness2")]
    ///Contains a type [`PhysicalDeviceRobustness2FeaturesEXT`] for extending [`DeviceCreateInfo`]
    PhysicalDeviceRobustness2FeaturesEXT(PhysicalDeviceRobustness2FeaturesEXT),
    #[cfg(feature = "VULKAN_1_3")]
    ///Contains a type [`PhysicalDeviceImageRobustnessFeatures`] for extending [`DeviceCreateInfo`]
    PhysicalDeviceImageRobustnessFeatures(PhysicalDeviceImageRobustnessFeatures),
    #[cfg(feature = "VK_KHR_workgroup_memory_explicit_layout")]
    ///Contains a type [`PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR`] for extending
    /// [`DeviceCreateInfo`]
    PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR(PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR),
    #[cfg(feature = "VK_KHR_portability_subset")]
    ///Contains a type [`PhysicalDevicePortabilitySubsetFeaturesKHR`] for extending
    /// [`DeviceCreateInfo`]
    PhysicalDevicePortabilitySubsetFeaturesKHR(PhysicalDevicePortabilitySubsetFeaturesKHR),
    #[cfg(feature = "VK_EXT_4444_formats")]
    ///Contains a type [`PhysicalDevice4444FormatsFeaturesEXT`] for extending [`DeviceCreateInfo`]
    PhysicalDevice4444FormatsFeaturesEXT(PhysicalDevice4444FormatsFeaturesEXT),
    #[cfg(feature = "VK_HUAWEI_subpass_shading")]
    ///Contains a type [`PhysicalDeviceSubpassShadingFeaturesHUAWEI`] for extending
    /// [`DeviceCreateInfo`]
    PhysicalDeviceSubpassShadingFeaturesHUAWEI(PhysicalDeviceSubpassShadingFeaturesHUAWEI),
    #[cfg(feature = "VK_EXT_shader_image_atomic_int64")]
    ///Contains a type [`PhysicalDeviceShaderImageAtomicInt64FeaturesEXT`] for extending
    /// [`DeviceCreateInfo`]
    PhysicalDeviceShaderImageAtomicInt64FeaturesEXT(PhysicalDeviceShaderImageAtomicInt64FeaturesEXT),
    #[cfg(feature = "VK_KHR_fragment_shading_rate")]
    ///Contains a type [`PhysicalDeviceFragmentShadingRateFeaturesKHR`] for extending
    /// [`DeviceCreateInfo`]
    PhysicalDeviceFragmentShadingRateFeaturesKHR(PhysicalDeviceFragmentShadingRateFeaturesKHR),
    #[cfg(feature = "VULKAN_1_3")]
    ///Contains a type [`PhysicalDeviceShaderTerminateInvocationFeatures`] for extending
    /// [`DeviceCreateInfo`]
    PhysicalDeviceShaderTerminateInvocationFeatures(PhysicalDeviceShaderTerminateInvocationFeatures),
    #[cfg(feature = "VK_NV_fragment_shading_rate_enums")]
    ///Contains a type [`PhysicalDeviceFragmentShadingRateEnumsFeaturesNV`] for extending
    /// [`DeviceCreateInfo`]
    PhysicalDeviceFragmentShadingRateEnumsFeaturesNV(PhysicalDeviceFragmentShadingRateEnumsFeaturesNV),
    #[cfg(feature = "VK_VALVE_mutable_descriptor_type")]
    ///Contains a type [`PhysicalDeviceMutableDescriptorTypeFeaturesVALVE`] for extending
    /// [`DeviceCreateInfo`]
    PhysicalDeviceMutableDescriptorTypeFeaturesVALVE(PhysicalDeviceMutableDescriptorTypeFeaturesVALVE),
    #[cfg(feature = "VK_EXT_depth_clip_control")]
    ///Contains a type [`PhysicalDeviceDepthClipControlFeaturesEXT`] for extending
    /// [`DeviceCreateInfo`]
    PhysicalDeviceDepthClipControlFeaturesEXT(PhysicalDeviceDepthClipControlFeaturesEXT),
    #[cfg(feature = "VK_EXT_vertex_input_dynamic_state")]
    ///Contains a type [`PhysicalDeviceVertexInputDynamicStateFeaturesEXT`] for extending
    /// [`DeviceCreateInfo`]
    PhysicalDeviceVertexInputDynamicStateFeaturesEXT(PhysicalDeviceVertexInputDynamicStateFeaturesEXT),
    #[cfg(feature = "VK_NV_external_memory_rdma")]
    ///Contains a type [`PhysicalDeviceExternalMemoryRdmaFeaturesNV`] for extending
    /// [`DeviceCreateInfo`]
    PhysicalDeviceExternalMemoryRdmaFeaturesNV(PhysicalDeviceExternalMemoryRdmaFeaturesNV),
    #[cfg(feature = "VK_EXT_color_write_enable")]
    ///Contains a type [`PhysicalDeviceColorWriteEnableFeaturesEXT`] for extending
    /// [`DeviceCreateInfo`]
    PhysicalDeviceColorWriteEnableFeaturesEXT(PhysicalDeviceColorWriteEnableFeaturesEXT),
    #[cfg(feature = "VULKAN_1_3")]
    ///Contains a type [`PhysicalDeviceSynchronization2Features`] for extending
    /// [`DeviceCreateInfo`]
    PhysicalDeviceSynchronization2Features(PhysicalDeviceSynchronization2Features),
    #[cfg(feature = "VK_NV_inherited_viewport_scissor")]
    ///Contains a type [`PhysicalDeviceInheritedViewportScissorFeaturesNV`] for extending
    /// [`DeviceCreateInfo`]
    PhysicalDeviceInheritedViewportScissorFeaturesNV(PhysicalDeviceInheritedViewportScissorFeaturesNV),
    #[cfg(feature = "VK_EXT_ycbcr_2plane_444_formats")]
    ///Contains a type [`PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT`] for extending
    /// [`DeviceCreateInfo`]
    PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT(PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT),
    #[cfg(feature = "VK_EXT_provoking_vertex")]
    ///Contains a type [`PhysicalDeviceProvokingVertexFeaturesEXT`] for extending
    /// [`DeviceCreateInfo`]
    PhysicalDeviceProvokingVertexFeaturesEXT(PhysicalDeviceProvokingVertexFeaturesEXT),
    #[cfg(feature = "VULKAN_1_3")]
    ///Contains a type [`PhysicalDeviceShaderIntegerDotProductFeatures`] for extending
    /// [`DeviceCreateInfo`]
    PhysicalDeviceShaderIntegerDotProductFeatures(PhysicalDeviceShaderIntegerDotProductFeatures),
    #[cfg(feature = "VK_NV_ray_tracing_motion_blur")]
    ///Contains a type [`PhysicalDeviceRayTracingMotionBlurFeaturesNV`] for extending
    /// [`DeviceCreateInfo`]
    PhysicalDeviceRayTracingMotionBlurFeaturesNV(PhysicalDeviceRayTracingMotionBlurFeaturesNV),
    #[cfg(feature = "VK_EXT_rgba10x6_formats")]
    ///Contains a type [`PhysicalDeviceRgba10x6FormatsFeaturesEXT`] for extending
    /// [`DeviceCreateInfo`]
    PhysicalDeviceRgba10x6FormatsFeaturesEXT(PhysicalDeviceRgba10x6FormatsFeaturesEXT),
    #[cfg(feature = "VULKAN_1_3")]
    ///Contains a type [`PhysicalDeviceDynamicRenderingFeatures`] for extending
    /// [`DeviceCreateInfo`]
    PhysicalDeviceDynamicRenderingFeatures(PhysicalDeviceDynamicRenderingFeatures),
    #[cfg(feature = "VK_EXT_image_view_min_lod")]
    ///Contains a type [`PhysicalDeviceImageViewMinLodFeaturesEXT`] for extending
    /// [`DeviceCreateInfo`]
    PhysicalDeviceImageViewMinLodFeaturesEXT(PhysicalDeviceImageViewMinLodFeaturesEXT),
    #[cfg(feature = "VK_ARM_rasterization_order_attachment_access")]
    ///Contains a type [`PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesARM`] for
    /// extending [`DeviceCreateInfo`]
    PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesARM(
        PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesARM,
    ),
    #[cfg(feature = "VK_NV_linear_color_attachment")]
    ///Contains a type [`PhysicalDeviceLinearColorAttachmentFeaturesNV`] for extending
    /// [`DeviceCreateInfo`]
    PhysicalDeviceLinearColorAttachmentFeaturesNV(PhysicalDeviceLinearColorAttachmentFeaturesNV),
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for DeviceCreateInfoExtension {
    type LowLevel = *const crate::native::vulkan1_0::BaseInStructure;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        match self { # [cfg (feature = "VK_NV_device_generated_commands")] Self :: PhysicalDeviceDeviceGeneratedCommandsFeaturesNV (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: nv_device_generated_commands :: PhysicalDeviceDeviceGeneratedCommandsFeaturesNV) . cast () , # [cfg (feature = "VULKAN_1_3")] Self :: DevicePrivateDataCreateInfo (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: vulkan1_3 :: DevicePrivateDataCreateInfo) . cast () , # [cfg (feature = "VULKAN_1_3")] Self :: PhysicalDevicePrivateDataFeatures (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: vulkan1_3 :: PhysicalDevicePrivateDataFeatures) . cast () , Self :: PhysicalDeviceFeatures2 (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: vulkan1_1 :: PhysicalDeviceFeatures2) . cast () , Self :: PhysicalDeviceVariablePointersFeatures (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: vulkan1_1 :: PhysicalDeviceVariablePointersFeatures) . cast () , Self :: PhysicalDeviceMultiviewFeatures (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: vulkan1_1 :: PhysicalDeviceMultiviewFeatures) . cast () , Self :: DeviceGroupDeviceCreateInfo (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: vulkan1_1 :: DeviceGroupDeviceCreateInfo) . cast () , # [cfg (feature = "VK_KHR_present_id")] Self :: PhysicalDevicePresentIdFeaturesKHR (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: khr_present_id :: PhysicalDevicePresentIdFeaturesKHR) . cast () , # [cfg (feature = "VK_KHR_present_wait")] Self :: PhysicalDevicePresentWaitFeaturesKHR (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: khr_present_wait :: PhysicalDevicePresentWaitFeaturesKHR) . cast () , Self :: PhysicalDevice16BitStorageFeatures (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: vulkan1_1 :: PhysicalDevice16BitStorageFeatures) . cast () , # [cfg (feature = "VULKAN_1_2")] Self :: PhysicalDeviceShaderSubgroupExtendedTypesFeatures (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: vulkan1_2 :: PhysicalDeviceShaderSubgroupExtendedTypesFeatures) . cast () , Self :: PhysicalDeviceSamplerYcbcrConversionFeatures (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: vulkan1_1 :: PhysicalDeviceSamplerYcbcrConversionFeatures) . cast () , Self :: PhysicalDeviceProtectedMemoryFeatures (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: vulkan1_1 :: PhysicalDeviceProtectedMemoryFeatures) . cast () , # [cfg (feature = "VK_EXT_blend_operation_advanced")] Self :: PhysicalDeviceBlendOperationAdvancedFeaturesEXT (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: ext_blend_operation_advanced :: PhysicalDeviceBlendOperationAdvancedFeaturesEXT) . cast () , # [cfg (feature = "VK_EXT_multi_draw")] Self :: PhysicalDeviceMultiDrawFeaturesEXT (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: ext_multi_draw :: PhysicalDeviceMultiDrawFeaturesEXT) . cast () , # [cfg (feature = "VULKAN_1_3")] Self :: PhysicalDeviceInlineUniformBlockFeatures (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: vulkan1_3 :: PhysicalDeviceInlineUniformBlockFeatures) . cast () , # [cfg (feature = "VULKAN_1_3")] Self :: PhysicalDeviceMaintenance4Features (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: vulkan1_3 :: PhysicalDeviceMaintenance4Features) . cast () , Self :: PhysicalDeviceShaderDrawParametersFeatures (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: vulkan1_1 :: PhysicalDeviceShaderDrawParametersFeatures) . cast () , # [cfg (feature = "VULKAN_1_2")] Self :: PhysicalDeviceShaderFloat16Int8Features (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: vulkan1_2 :: PhysicalDeviceShaderFloat16Int8Features) . cast () , # [cfg (feature = "VULKAN_1_2")] Self :: PhysicalDeviceHostQueryResetFeatures (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: vulkan1_2 :: PhysicalDeviceHostQueryResetFeatures) . cast () , # [cfg (feature = "VK_KHR_global_priority")] Self :: PhysicalDeviceGlobalPriorityQueryFeaturesKHR (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: khr_global_priority :: PhysicalDeviceGlobalPriorityQueryFeaturesKHR) . cast () , # [cfg (feature = "VK_EXT_device_memory_report")] Self :: PhysicalDeviceDeviceMemoryReportFeaturesEXT (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: ext_device_memory_report :: PhysicalDeviceDeviceMemoryReportFeaturesEXT) . cast () , # [cfg (feature = "VK_EXT_device_memory_report")] Self :: DeviceDeviceMemoryReportCreateInfoEXT (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: ext_device_memory_report :: DeviceDeviceMemoryReportCreateInfoEXT) . cast () , # [cfg (feature = "VULKAN_1_2")] Self :: PhysicalDeviceDescriptorIndexingFeatures (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: vulkan1_2 :: PhysicalDeviceDescriptorIndexingFeatures) . cast () , # [cfg (feature = "VULKAN_1_2")] Self :: PhysicalDeviceTimelineSemaphoreFeatures (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: vulkan1_2 :: PhysicalDeviceTimelineSemaphoreFeatures) . cast () , # [cfg (feature = "VULKAN_1_2")] Self :: PhysicalDevice8BitStorageFeatures (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: vulkan1_2 :: PhysicalDevice8BitStorageFeatures) . cast () , # [cfg (feature = "VK_EXT_conditional_rendering")] Self :: PhysicalDeviceConditionalRenderingFeaturesEXT (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: ext_conditional_rendering :: PhysicalDeviceConditionalRenderingFeaturesEXT) . cast () , # [cfg (feature = "VULKAN_1_2")] Self :: PhysicalDeviceVulkanMemoryModelFeatures (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: vulkan1_2 :: PhysicalDeviceVulkanMemoryModelFeatures) . cast () , # [cfg (feature = "VULKAN_1_2")] Self :: PhysicalDeviceShaderAtomicInt64Features (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: vulkan1_2 :: PhysicalDeviceShaderAtomicInt64Features) . cast () , # [cfg (feature = "VK_EXT_shader_atomic_float")] Self :: PhysicalDeviceShaderAtomicFloatFeaturesEXT (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: ext_shader_atomic_float :: PhysicalDeviceShaderAtomicFloatFeaturesEXT) . cast () , # [cfg (feature = "VK_EXT_shader_atomic_float2")] Self :: PhysicalDeviceShaderAtomicFloat2FeaturesEXT (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: ext_shader_atomic_float2 :: PhysicalDeviceShaderAtomicFloat2FeaturesEXT) . cast () , # [cfg (feature = "VK_EXT_vertex_attribute_divisor")] Self :: PhysicalDeviceVertexAttributeDivisorFeaturesEXT (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: ext_vertex_attribute_divisor :: PhysicalDeviceVertexAttributeDivisorFeaturesEXT) . cast () , # [cfg (feature = "VK_EXT_astc_decode_mode")] Self :: PhysicalDeviceAstcDecodeFeaturesEXT (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: ext_astc_decode_mode :: PhysicalDeviceAstcDecodeFeaturesEXT) . cast () , # [cfg (feature = "VK_EXT_transform_feedback")] Self :: PhysicalDeviceTransformFeedbackFeaturesEXT (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: ext_transform_feedback :: PhysicalDeviceTransformFeedbackFeaturesEXT) . cast () , # [cfg (feature = "VK_NV_representative_fragment_test")] Self :: PhysicalDeviceRepresentativeFragmentTestFeaturesNV (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: nv_representative_fragment_test :: PhysicalDeviceRepresentativeFragmentTestFeaturesNV) . cast () , # [cfg (feature = "VK_NV_scissor_exclusive")] Self :: PhysicalDeviceExclusiveScissorFeaturesNV (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: nv_scissor_exclusive :: PhysicalDeviceExclusiveScissorFeaturesNV) . cast () , # [cfg (feature = "VK_NV_corner_sampled_image")] Self :: PhysicalDeviceCornerSampledImageFeaturesNV (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: nv_corner_sampled_image :: PhysicalDeviceCornerSampledImageFeaturesNV) . cast () , # [cfg (feature = "VK_NV_compute_shader_derivatives")] Self :: PhysicalDeviceComputeShaderDerivativesFeaturesNV (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: nv_compute_shader_derivatives :: PhysicalDeviceComputeShaderDerivativesFeaturesNV) . cast () , # [cfg (feature = "VK_NV_fragment_shader_barycentric")] Self :: PhysicalDeviceFragmentShaderBarycentricFeaturesNV (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: nv_fragment_shader_barycentric :: PhysicalDeviceFragmentShaderBarycentricFeaturesNV) . cast () , # [cfg (feature = "VK_NV_shader_image_footprint")] Self :: PhysicalDeviceShaderImageFootprintFeaturesNV (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: nv_shader_image_footprint :: PhysicalDeviceShaderImageFootprintFeaturesNV) . cast () , # [cfg (feature = "VK_NV_dedicated_allocation_image_aliasing")] Self :: PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: nv_dedicated_allocation_image_aliasing :: PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV) . cast () , # [cfg (feature = "VK_NV_shading_rate_image")] Self :: PhysicalDeviceShadingRateImageFeaturesNV (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: nv_shading_rate_image :: PhysicalDeviceShadingRateImageFeaturesNV) . cast () , # [cfg (feature = "VK_HUAWEI_invocation_mask")] Self :: PhysicalDeviceInvocationMaskFeaturesHUAWEI (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: huawei_invocation_mask :: PhysicalDeviceInvocationMaskFeaturesHUAWEI) . cast () , # [cfg (feature = "VK_NV_mesh_shader")] Self :: PhysicalDeviceMeshShaderFeaturesNV (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: nv_mesh_shader :: PhysicalDeviceMeshShaderFeaturesNV) . cast () , # [cfg (feature = "VK_KHR_acceleration_structure")] Self :: PhysicalDeviceAccelerationStructureFeaturesKHR (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: khr_acceleration_structure :: PhysicalDeviceAccelerationStructureFeaturesKHR) . cast () , # [cfg (feature = "VK_KHR_ray_tracing_pipeline")] Self :: PhysicalDeviceRayTracingPipelineFeaturesKHR (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: khr_ray_tracing_pipeline :: PhysicalDeviceRayTracingPipelineFeaturesKHR) . cast () , # [cfg (feature = "VK_KHR_ray_query")] Self :: PhysicalDeviceRayQueryFeaturesKHR (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: khr_ray_query :: PhysicalDeviceRayQueryFeaturesKHR) . cast () , # [cfg (feature = "VK_AMD_memory_overallocation_behavior")] Self :: DeviceMemoryOverallocationCreateInfoAMD (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: amd_memory_overallocation_behavior :: DeviceMemoryOverallocationCreateInfoAMD) . cast () , # [cfg (feature = "VK_EXT_fragment_density_map")] Self :: PhysicalDeviceFragmentDensityMapFeaturesEXT (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: ext_fragment_density_map :: PhysicalDeviceFragmentDensityMapFeaturesEXT) . cast () , # [cfg (feature = "VK_EXT_fragment_density_map2")] Self :: PhysicalDeviceFragmentDensityMap2FeaturesEXT (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: ext_fragment_density_map2 :: PhysicalDeviceFragmentDensityMap2FeaturesEXT) . cast () , # [cfg (feature = "VULKAN_1_2")] Self :: PhysicalDeviceScalarBlockLayoutFeatures (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: vulkan1_2 :: PhysicalDeviceScalarBlockLayoutFeatures) . cast () , # [cfg (feature = "VULKAN_1_2")] Self :: PhysicalDeviceUniformBufferStandardLayoutFeatures (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: vulkan1_2 :: PhysicalDeviceUniformBufferStandardLayoutFeatures) . cast () , # [cfg (feature = "VK_EXT_depth_clip_enable")] Self :: PhysicalDeviceDepthClipEnableFeaturesEXT (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: ext_depth_clip_enable :: PhysicalDeviceDepthClipEnableFeaturesEXT) . cast () , # [cfg (feature = "VK_EXT_memory_priority")] Self :: PhysicalDeviceMemoryPriorityFeaturesEXT (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: ext_memory_priority :: PhysicalDeviceMemoryPriorityFeaturesEXT) . cast () , # [cfg (feature = "VK_EXT_pageable_device_local_memory")] Self :: PhysicalDevicePageableDeviceLocalMemoryFeaturesEXT (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: ext_pageable_device_local_memory :: PhysicalDevicePageableDeviceLocalMemoryFeaturesEXT) . cast () , # [cfg (feature = "VULKAN_1_2")] Self :: PhysicalDeviceBufferDeviceAddressFeatures (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: vulkan1_2 :: PhysicalDeviceBufferDeviceAddressFeatures) . cast () , # [cfg (feature = "VK_EXT_buffer_device_address")] Self :: PhysicalDeviceBufferDeviceAddressFeaturesEXT (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: ext_buffer_device_address :: PhysicalDeviceBufferDeviceAddressFeaturesEXT) . cast () , # [cfg (feature = "VULKAN_1_2")] Self :: PhysicalDeviceImagelessFramebufferFeatures (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: vulkan1_2 :: PhysicalDeviceImagelessFramebufferFeatures) . cast () , # [cfg (feature = "VULKAN_1_3")] Self :: PhysicalDeviceTextureCompressionAstchdrFeatures (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: vulkan1_3 :: PhysicalDeviceTextureCompressionAstchdrFeatures) . cast () , # [cfg (feature = "VK_NV_cooperative_matrix")] Self :: PhysicalDeviceCooperativeMatrixFeaturesNV (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: nv_cooperative_matrix :: PhysicalDeviceCooperativeMatrixFeaturesNV) . cast () , # [cfg (feature = "VK_EXT_ycbcr_image_arrays")] Self :: PhysicalDeviceYcbcrImageArraysFeaturesEXT (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: ext_ycbcr_image_arrays :: PhysicalDeviceYcbcrImageArraysFeaturesEXT) . cast () , # [cfg (feature = "VK_KHR_performance_query")] Self :: PhysicalDevicePerformanceQueryFeaturesKHR (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: khr_performance_query :: PhysicalDevicePerformanceQueryFeaturesKHR) . cast () , # [cfg (feature = "VK_NV_coverage_reduction_mode")] Self :: PhysicalDeviceCoverageReductionModeFeaturesNV (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: nv_coverage_reduction_mode :: PhysicalDeviceCoverageReductionModeFeaturesNV) . cast () , # [cfg (feature = "VK_INTEL_shader_integer_functions2")] Self :: PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: intel_shader_integer_functions2 :: PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL) . cast () , # [cfg (feature = "VK_KHR_shader_clock")] Self :: PhysicalDeviceShaderClockFeaturesKHR (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: khr_shader_clock :: PhysicalDeviceShaderClockFeaturesKHR) . cast () , # [cfg (feature = "VK_EXT_index_type_uint8")] Self :: PhysicalDeviceIndexTypeUint8FeaturesEXT (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: ext_index_type_uint8 :: PhysicalDeviceIndexTypeUint8FeaturesEXT) . cast () , # [cfg (feature = "VK_NV_shader_sm_builtins")] Self :: PhysicalDeviceShaderSmBuiltinsFeaturesNV (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: nv_shader_sm_builtins :: PhysicalDeviceShaderSmBuiltinsFeaturesNV) . cast () , # [cfg (feature = "VK_EXT_fragment_shader_interlock")] Self :: PhysicalDeviceFragmentShaderInterlockFeaturesEXT (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: ext_fragment_shader_interlock :: PhysicalDeviceFragmentShaderInterlockFeaturesEXT) . cast () , # [cfg (feature = "VULKAN_1_2")] Self :: PhysicalDeviceSeparateDepthStencilLayoutsFeatures (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: vulkan1_2 :: PhysicalDeviceSeparateDepthStencilLayoutsFeatures) . cast () , # [cfg (feature = "VK_EXT_primitive_topology_list_restart")] Self :: PhysicalDevicePrimitiveTopologyListRestartFeaturesEXT (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: ext_primitive_topology_list_restart :: PhysicalDevicePrimitiveTopologyListRestartFeaturesEXT) . cast () , # [cfg (feature = "VK_KHR_pipeline_executable_properties")] Self :: PhysicalDevicePipelineExecutablePropertiesFeaturesKHR (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: khr_pipeline_executable_properties :: PhysicalDevicePipelineExecutablePropertiesFeaturesKHR) . cast () , # [cfg (feature = "VULKAN_1_3")] Self :: PhysicalDeviceShaderDemoteToHelperInvocationFeatures (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: vulkan1_3 :: PhysicalDeviceShaderDemoteToHelperInvocationFeatures) . cast () , # [cfg (feature = "VK_EXT_texel_buffer_alignment")] Self :: PhysicalDeviceTexelBufferAlignmentFeaturesEXT (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: ext_texel_buffer_alignment :: PhysicalDeviceTexelBufferAlignmentFeaturesEXT) . cast () , # [cfg (feature = "VULKAN_1_3")] Self :: PhysicalDeviceSubgroupSizeControlFeatures (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: vulkan1_3 :: PhysicalDeviceSubgroupSizeControlFeatures) . cast () , # [cfg (feature = "VK_EXT_line_rasterization")] Self :: PhysicalDeviceLineRasterizationFeaturesEXT (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: ext_line_rasterization :: PhysicalDeviceLineRasterizationFeaturesEXT) . cast () , # [cfg (feature = "VULKAN_1_3")] Self :: PhysicalDevicePipelineCreationCacheControlFeatures (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: vulkan1_3 :: PhysicalDevicePipelineCreationCacheControlFeatures) . cast () , # [cfg (feature = "VULKAN_1_2")] Self :: PhysicalDeviceVulkan11Features (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: vulkan1_2 :: PhysicalDeviceVulkan11Features) . cast () , # [cfg (feature = "VULKAN_1_2")] Self :: PhysicalDeviceVulkan12Features (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: vulkan1_2 :: PhysicalDeviceVulkan12Features) . cast () , # [cfg (feature = "VULKAN_1_3")] Self :: PhysicalDeviceVulkan13Features (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: vulkan1_3 :: PhysicalDeviceVulkan13Features) . cast () , # [cfg (feature = "VK_AMD_device_coherent_memory")] Self :: PhysicalDeviceCoherentMemoryFeaturesAMD (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: amd_device_coherent_memory :: PhysicalDeviceCoherentMemoryFeaturesAMD) . cast () , # [cfg (feature = "VK_EXT_custom_border_color")] Self :: PhysicalDeviceCustomBorderColorFeaturesEXT (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: ext_custom_border_color :: PhysicalDeviceCustomBorderColorFeaturesEXT) . cast () , # [cfg (feature = "VK_EXT_border_color_swizzle")] Self :: PhysicalDeviceBorderColorSwizzleFeaturesEXT (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: ext_border_color_swizzle :: PhysicalDeviceBorderColorSwizzleFeaturesEXT) . cast () , # [cfg (feature = "VK_EXT_extended_dynamic_state")] Self :: PhysicalDeviceExtendedDynamicStateFeaturesEXT (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: ext_extended_dynamic_state :: PhysicalDeviceExtendedDynamicStateFeaturesEXT) . cast () , # [cfg (feature = "VK_EXT_extended_dynamic_state2")] Self :: PhysicalDeviceExtendedDynamicState2FeaturesEXT (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: ext_extended_dynamic_state2 :: PhysicalDeviceExtendedDynamicState2FeaturesEXT) . cast () , # [cfg (feature = "VK_NV_device_diagnostics_config")] Self :: PhysicalDeviceDiagnosticsConfigFeaturesNV (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: nv_device_diagnostics_config :: PhysicalDeviceDiagnosticsConfigFeaturesNV) . cast () , # [cfg (feature = "VK_NV_device_diagnostics_config")] Self :: DeviceDiagnosticsConfigCreateInfoNV (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: nv_device_diagnostics_config :: DeviceDiagnosticsConfigCreateInfoNV) . cast () , # [cfg (feature = "VULKAN_1_3")] Self :: PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: vulkan1_3 :: PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures) . cast () , # [cfg (feature = "VK_KHR_shader_subgroup_uniform_control_flow")] Self :: PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: khr_shader_subgroup_uniform_control_flow :: PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR) . cast () , # [cfg (feature = "VK_EXT_robustness2")] Self :: PhysicalDeviceRobustness2FeaturesEXT (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: ext_robustness2 :: PhysicalDeviceRobustness2FeaturesEXT) . cast () , # [cfg (feature = "VULKAN_1_3")] Self :: PhysicalDeviceImageRobustnessFeatures (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: vulkan1_3 :: PhysicalDeviceImageRobustnessFeatures) . cast () , # [cfg (feature = "VK_KHR_workgroup_memory_explicit_layout")] Self :: PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: khr_workgroup_memory_explicit_layout :: PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR) . cast () , # [cfg (feature = "VK_KHR_portability_subset")] Self :: PhysicalDevicePortabilitySubsetFeaturesKHR (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: khr_portability_subset :: PhysicalDevicePortabilitySubsetFeaturesKHR) . cast () , # [cfg (feature = "VK_EXT_4444_formats")] Self :: PhysicalDevice4444FormatsFeaturesEXT (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: ext_4444_formats :: PhysicalDevice4444FormatsFeaturesEXT) . cast () , # [cfg (feature = "VK_HUAWEI_subpass_shading")] Self :: PhysicalDeviceSubpassShadingFeaturesHUAWEI (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: huawei_subpass_shading :: PhysicalDeviceSubpassShadingFeaturesHUAWEI) . cast () , # [cfg (feature = "VK_EXT_shader_image_atomic_int64")] Self :: PhysicalDeviceShaderImageAtomicInt64FeaturesEXT (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: ext_shader_image_atomic_int64 :: PhysicalDeviceShaderImageAtomicInt64FeaturesEXT) . cast () , # [cfg (feature = "VK_KHR_fragment_shading_rate")] Self :: PhysicalDeviceFragmentShadingRateFeaturesKHR (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: khr_fragment_shading_rate :: PhysicalDeviceFragmentShadingRateFeaturesKHR) . cast () , # [cfg (feature = "VULKAN_1_3")] Self :: PhysicalDeviceShaderTerminateInvocationFeatures (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: vulkan1_3 :: PhysicalDeviceShaderTerminateInvocationFeatures) . cast () , # [cfg (feature = "VK_NV_fragment_shading_rate_enums")] Self :: PhysicalDeviceFragmentShadingRateEnumsFeaturesNV (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: nv_fragment_shading_rate_enums :: PhysicalDeviceFragmentShadingRateEnumsFeaturesNV) . cast () , # [cfg (feature = "VK_VALVE_mutable_descriptor_type")] Self :: PhysicalDeviceMutableDescriptorTypeFeaturesVALVE (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: valve_mutable_descriptor_type :: PhysicalDeviceMutableDescriptorTypeFeaturesVALVE) . cast () , # [cfg (feature = "VK_EXT_depth_clip_control")] Self :: PhysicalDeviceDepthClipControlFeaturesEXT (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: ext_depth_clip_control :: PhysicalDeviceDepthClipControlFeaturesEXT) . cast () , # [cfg (feature = "VK_EXT_vertex_input_dynamic_state")] Self :: PhysicalDeviceVertexInputDynamicStateFeaturesEXT (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: ext_vertex_input_dynamic_state :: PhysicalDeviceVertexInputDynamicStateFeaturesEXT) . cast () , # [cfg (feature = "VK_NV_external_memory_rdma")] Self :: PhysicalDeviceExternalMemoryRdmaFeaturesNV (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: nv_external_memory_rdma :: PhysicalDeviceExternalMemoryRdmaFeaturesNV) . cast () , # [cfg (feature = "VK_EXT_color_write_enable")] Self :: PhysicalDeviceColorWriteEnableFeaturesEXT (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: ext_color_write_enable :: PhysicalDeviceColorWriteEnableFeaturesEXT) . cast () , # [cfg (feature = "VULKAN_1_3")] Self :: PhysicalDeviceSynchronization2Features (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: vulkan1_3 :: PhysicalDeviceSynchronization2Features) . cast () , # [cfg (feature = "VK_NV_inherited_viewport_scissor")] Self :: PhysicalDeviceInheritedViewportScissorFeaturesNV (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: nv_inherited_viewport_scissor :: PhysicalDeviceInheritedViewportScissorFeaturesNV) . cast () , # [cfg (feature = "VK_EXT_ycbcr_2plane_444_formats")] Self :: PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: ext_ycbcr_2plane_444_formats :: PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT) . cast () , # [cfg (feature = "VK_EXT_provoking_vertex")] Self :: PhysicalDeviceProvokingVertexFeaturesEXT (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: ext_provoking_vertex :: PhysicalDeviceProvokingVertexFeaturesEXT) . cast () , # [cfg (feature = "VULKAN_1_3")] Self :: PhysicalDeviceShaderIntegerDotProductFeatures (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: vulkan1_3 :: PhysicalDeviceShaderIntegerDotProductFeatures) . cast () , # [cfg (feature = "VK_NV_ray_tracing_motion_blur")] Self :: PhysicalDeviceRayTracingMotionBlurFeaturesNV (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: nv_ray_tracing_motion_blur :: PhysicalDeviceRayTracingMotionBlurFeaturesNV) . cast () , # [cfg (feature = "VK_EXT_rgba10x6_formats")] Self :: PhysicalDeviceRgba10x6FormatsFeaturesEXT (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: ext_rgba10x6_formats :: PhysicalDeviceRgba10x6FormatsFeaturesEXT) . cast () , # [cfg (feature = "VULKAN_1_3")] Self :: PhysicalDeviceDynamicRenderingFeatures (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: vulkan1_3 :: PhysicalDeviceDynamicRenderingFeatures) . cast () , # [cfg (feature = "VK_EXT_image_view_min_lod")] Self :: PhysicalDeviceImageViewMinLodFeaturesEXT (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: ext_image_view_min_lod :: PhysicalDeviceImageViewMinLodFeaturesEXT) . cast () , # [cfg (feature = "VK_ARM_rasterization_order_attachment_access")] Self :: PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesARM (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: arm_rasterization_order_attachment_access :: PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesARM) . cast () , # [cfg (feature = "VK_NV_linear_color_attachment")] Self :: PhysicalDeviceLinearColorAttachmentFeaturesNV (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: nv_linear_color_attachment :: PhysicalDeviceLinearColorAttachmentFeaturesNV) . cast () , other => unreachable ! ("unexpected variant {:?}" , other) }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for DeviceCreateInfoExtension {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        assert!(!value.is_null());
        match (* value) . s_type { # [cfg (feature = "VK_NV_device_generated_commands")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDeviceDeviceGeneratedCommandsFeaturesNv => Self :: PhysicalDeviceDeviceGeneratedCommandsFeaturesNV (PhysicalDeviceDeviceGeneratedCommandsFeaturesNV :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: nv_device_generated_commands :: PhysicalDeviceDeviceGeneratedCommandsFeaturesNV > ()))) , # [cfg (feature = "VULKAN_1_3")] crate :: native :: vulkan1_0 :: StructureType :: DevicePrivateDataCreateInfo => Self :: DevicePrivateDataCreateInfo (DevicePrivateDataCreateInfo :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: vulkan1_3 :: DevicePrivateDataCreateInfo > ()))) , # [cfg (feature = "VULKAN_1_3")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDevicePrivateDataFeatures => Self :: PhysicalDevicePrivateDataFeatures (PhysicalDevicePrivateDataFeatures :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: vulkan1_3 :: PhysicalDevicePrivateDataFeatures > ()))) , crate :: native :: vulkan1_0 :: StructureType :: PhysicalDeviceFeatures2 => Self :: PhysicalDeviceFeatures2 (PhysicalDeviceFeatures2 :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: vulkan1_1 :: PhysicalDeviceFeatures2 > ()))) , crate :: native :: vulkan1_0 :: StructureType :: PhysicalDeviceVariablePointersFeatures => Self :: PhysicalDeviceVariablePointersFeatures (PhysicalDeviceVariablePointersFeatures :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: vulkan1_1 :: PhysicalDeviceVariablePointersFeatures > ()))) , crate :: native :: vulkan1_0 :: StructureType :: PhysicalDeviceMultiviewFeatures => Self :: PhysicalDeviceMultiviewFeatures (PhysicalDeviceMultiviewFeatures :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: vulkan1_1 :: PhysicalDeviceMultiviewFeatures > ()))) , crate :: native :: vulkan1_0 :: StructureType :: DeviceGroupDeviceCreateInfo => Self :: DeviceGroupDeviceCreateInfo (DeviceGroupDeviceCreateInfo :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: vulkan1_1 :: DeviceGroupDeviceCreateInfo > ()))) , # [cfg (feature = "VK_KHR_present_id")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDevicePresentIdFeaturesKhr => Self :: PhysicalDevicePresentIdFeaturesKHR (PhysicalDevicePresentIdFeaturesKHR :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: khr_present_id :: PhysicalDevicePresentIdFeaturesKHR > ()))) , # [cfg (feature = "VK_KHR_present_wait")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDevicePresentWaitFeaturesKhr => Self :: PhysicalDevicePresentWaitFeaturesKHR (PhysicalDevicePresentWaitFeaturesKHR :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: khr_present_wait :: PhysicalDevicePresentWaitFeaturesKHR > ()))) , crate :: native :: vulkan1_0 :: StructureType :: PhysicalDevice16bitStorageFeatures => Self :: PhysicalDevice16BitStorageFeatures (PhysicalDevice16BitStorageFeatures :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: vulkan1_1 :: PhysicalDevice16BitStorageFeatures > ()))) , # [cfg (feature = "VULKAN_1_2")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDeviceShaderSubgroupExtendedTypesFeatures => Self :: PhysicalDeviceShaderSubgroupExtendedTypesFeatures (PhysicalDeviceShaderSubgroupExtendedTypesFeatures :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: vulkan1_2 :: PhysicalDeviceShaderSubgroupExtendedTypesFeatures > ()))) , crate :: native :: vulkan1_0 :: StructureType :: PhysicalDeviceSamplerYcbcrConversionFeatures => Self :: PhysicalDeviceSamplerYcbcrConversionFeatures (PhysicalDeviceSamplerYcbcrConversionFeatures :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: vulkan1_1 :: PhysicalDeviceSamplerYcbcrConversionFeatures > ()))) , crate :: native :: vulkan1_0 :: StructureType :: PhysicalDeviceProtectedMemoryFeatures => Self :: PhysicalDeviceProtectedMemoryFeatures (PhysicalDeviceProtectedMemoryFeatures :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: vulkan1_1 :: PhysicalDeviceProtectedMemoryFeatures > ()))) , # [cfg (feature = "VK_EXT_blend_operation_advanced")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDeviceBlendOperationAdvancedFeaturesExt => Self :: PhysicalDeviceBlendOperationAdvancedFeaturesEXT (PhysicalDeviceBlendOperationAdvancedFeaturesEXT :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: ext_blend_operation_advanced :: PhysicalDeviceBlendOperationAdvancedFeaturesEXT > ()))) , # [cfg (feature = "VK_EXT_multi_draw")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDeviceMultiDrawFeaturesExt => Self :: PhysicalDeviceMultiDrawFeaturesEXT (PhysicalDeviceMultiDrawFeaturesEXT :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: ext_multi_draw :: PhysicalDeviceMultiDrawFeaturesEXT > ()))) , # [cfg (feature = "VULKAN_1_3")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDeviceInlineUniformBlockFeatures => Self :: PhysicalDeviceInlineUniformBlockFeatures (PhysicalDeviceInlineUniformBlockFeatures :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: vulkan1_3 :: PhysicalDeviceInlineUniformBlockFeatures > ()))) , # [cfg (feature = "VULKAN_1_3")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDeviceMaintenance4Features => Self :: PhysicalDeviceMaintenance4Features (PhysicalDeviceMaintenance4Features :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: vulkan1_3 :: PhysicalDeviceMaintenance4Features > ()))) , crate :: native :: vulkan1_0 :: StructureType :: PhysicalDeviceShaderDrawParametersFeatures => Self :: PhysicalDeviceShaderDrawParametersFeatures (PhysicalDeviceShaderDrawParametersFeatures :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: vulkan1_1 :: PhysicalDeviceShaderDrawParametersFeatures > ()))) , # [cfg (feature = "VULKAN_1_2")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDeviceShaderFloat16Int8Features => Self :: PhysicalDeviceShaderFloat16Int8Features (PhysicalDeviceShaderFloat16Int8Features :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: vulkan1_2 :: PhysicalDeviceShaderFloat16Int8Features > ()))) , # [cfg (feature = "VULKAN_1_2")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDeviceHostQueryResetFeatures => Self :: PhysicalDeviceHostQueryResetFeatures (PhysicalDeviceHostQueryResetFeatures :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: vulkan1_2 :: PhysicalDeviceHostQueryResetFeatures > ()))) , # [cfg (feature = "VK_KHR_global_priority")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDeviceGlobalPriorityQueryFeaturesKhr => Self :: PhysicalDeviceGlobalPriorityQueryFeaturesKHR (PhysicalDeviceGlobalPriorityQueryFeaturesKHR :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: khr_global_priority :: PhysicalDeviceGlobalPriorityQueryFeaturesKHR > ()))) , # [cfg (feature = "VK_EXT_device_memory_report")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDeviceDeviceMemoryReportFeaturesExt => Self :: PhysicalDeviceDeviceMemoryReportFeaturesEXT (PhysicalDeviceDeviceMemoryReportFeaturesEXT :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: ext_device_memory_report :: PhysicalDeviceDeviceMemoryReportFeaturesEXT > ()))) , # [cfg (feature = "VK_EXT_device_memory_report")] crate :: native :: vulkan1_0 :: StructureType :: DeviceDeviceMemoryReportCreateInfoExt => Self :: DeviceDeviceMemoryReportCreateInfoEXT (DeviceDeviceMemoryReportCreateInfoEXT :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: ext_device_memory_report :: DeviceDeviceMemoryReportCreateInfoEXT > ()))) , # [cfg (feature = "VULKAN_1_2")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDeviceDescriptorIndexingFeatures => Self :: PhysicalDeviceDescriptorIndexingFeatures (PhysicalDeviceDescriptorIndexingFeatures :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: vulkan1_2 :: PhysicalDeviceDescriptorIndexingFeatures > ()))) , # [cfg (feature = "VULKAN_1_2")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDeviceTimelineSemaphoreFeatures => Self :: PhysicalDeviceTimelineSemaphoreFeatures (PhysicalDeviceTimelineSemaphoreFeatures :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: vulkan1_2 :: PhysicalDeviceTimelineSemaphoreFeatures > ()))) , # [cfg (feature = "VULKAN_1_2")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDevice8bitStorageFeatures => Self :: PhysicalDevice8BitStorageFeatures (PhysicalDevice8BitStorageFeatures :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: vulkan1_2 :: PhysicalDevice8BitStorageFeatures > ()))) , # [cfg (feature = "VK_EXT_conditional_rendering")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDeviceConditionalRenderingFeaturesExt => Self :: PhysicalDeviceConditionalRenderingFeaturesEXT (PhysicalDeviceConditionalRenderingFeaturesEXT :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: ext_conditional_rendering :: PhysicalDeviceConditionalRenderingFeaturesEXT > ()))) , # [cfg (feature = "VULKAN_1_2")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDeviceVulkanMemoryModelFeatures => Self :: PhysicalDeviceVulkanMemoryModelFeatures (PhysicalDeviceVulkanMemoryModelFeatures :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: vulkan1_2 :: PhysicalDeviceVulkanMemoryModelFeatures > ()))) , # [cfg (feature = "VULKAN_1_2")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDeviceShaderAtomicInt64Features => Self :: PhysicalDeviceShaderAtomicInt64Features (PhysicalDeviceShaderAtomicInt64Features :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: vulkan1_2 :: PhysicalDeviceShaderAtomicInt64Features > ()))) , # [cfg (feature = "VK_EXT_shader_atomic_float")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDeviceShaderAtomicFloatFeaturesExt => Self :: PhysicalDeviceShaderAtomicFloatFeaturesEXT (PhysicalDeviceShaderAtomicFloatFeaturesEXT :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: ext_shader_atomic_float :: PhysicalDeviceShaderAtomicFloatFeaturesEXT > ()))) , # [cfg (feature = "VK_EXT_shader_atomic_float2")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDeviceShaderAtomicFloat2FeaturesExt => Self :: PhysicalDeviceShaderAtomicFloat2FeaturesEXT (PhysicalDeviceShaderAtomicFloat2FeaturesEXT :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: ext_shader_atomic_float2 :: PhysicalDeviceShaderAtomicFloat2FeaturesEXT > ()))) , # [cfg (feature = "VK_EXT_vertex_attribute_divisor")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDeviceVertexAttributeDivisorFeaturesExt => Self :: PhysicalDeviceVertexAttributeDivisorFeaturesEXT (PhysicalDeviceVertexAttributeDivisorFeaturesEXT :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: ext_vertex_attribute_divisor :: PhysicalDeviceVertexAttributeDivisorFeaturesEXT > ()))) , # [cfg (feature = "VK_EXT_astc_decode_mode")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDeviceAstcDecodeFeaturesExt => Self :: PhysicalDeviceAstcDecodeFeaturesEXT (PhysicalDeviceAstcDecodeFeaturesEXT :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: ext_astc_decode_mode :: PhysicalDeviceAstcDecodeFeaturesEXT > ()))) , # [cfg (feature = "VK_EXT_transform_feedback")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDeviceTransformFeedbackFeaturesExt => Self :: PhysicalDeviceTransformFeedbackFeaturesEXT (PhysicalDeviceTransformFeedbackFeaturesEXT :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: ext_transform_feedback :: PhysicalDeviceTransformFeedbackFeaturesEXT > ()))) , # [cfg (feature = "VK_NV_representative_fragment_test")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDeviceRepresentativeFragmentTestFeaturesNv => Self :: PhysicalDeviceRepresentativeFragmentTestFeaturesNV (PhysicalDeviceRepresentativeFragmentTestFeaturesNV :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: nv_representative_fragment_test :: PhysicalDeviceRepresentativeFragmentTestFeaturesNV > ()))) , # [cfg (feature = "VK_NV_scissor_exclusive")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDeviceExclusiveScissorFeaturesNv => Self :: PhysicalDeviceExclusiveScissorFeaturesNV (PhysicalDeviceExclusiveScissorFeaturesNV :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: nv_scissor_exclusive :: PhysicalDeviceExclusiveScissorFeaturesNV > ()))) , # [cfg (feature = "VK_NV_corner_sampled_image")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDeviceCornerSampledImageFeaturesNv => Self :: PhysicalDeviceCornerSampledImageFeaturesNV (PhysicalDeviceCornerSampledImageFeaturesNV :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: nv_corner_sampled_image :: PhysicalDeviceCornerSampledImageFeaturesNV > ()))) , # [cfg (feature = "VK_NV_compute_shader_derivatives")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDeviceComputeShaderDerivativesFeaturesNv => Self :: PhysicalDeviceComputeShaderDerivativesFeaturesNV (PhysicalDeviceComputeShaderDerivativesFeaturesNV :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: nv_compute_shader_derivatives :: PhysicalDeviceComputeShaderDerivativesFeaturesNV > ()))) , # [cfg (feature = "VK_NV_fragment_shader_barycentric")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDeviceFragmentShaderBarycentricFeaturesNv => Self :: PhysicalDeviceFragmentShaderBarycentricFeaturesNV (PhysicalDeviceFragmentShaderBarycentricFeaturesNV :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: nv_fragment_shader_barycentric :: PhysicalDeviceFragmentShaderBarycentricFeaturesNV > ()))) , # [cfg (feature = "VK_NV_shader_image_footprint")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDeviceShaderImageFootprintFeaturesNv => Self :: PhysicalDeviceShaderImageFootprintFeaturesNV (PhysicalDeviceShaderImageFootprintFeaturesNV :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: nv_shader_image_footprint :: PhysicalDeviceShaderImageFootprintFeaturesNV > ()))) , # [cfg (feature = "VK_NV_dedicated_allocation_image_aliasing")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNv => Self :: PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV (PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: nv_dedicated_allocation_image_aliasing :: PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV > ()))) , # [cfg (feature = "VK_NV_shading_rate_image")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDeviceShadingRateImageFeaturesNv => Self :: PhysicalDeviceShadingRateImageFeaturesNV (PhysicalDeviceShadingRateImageFeaturesNV :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: nv_shading_rate_image :: PhysicalDeviceShadingRateImageFeaturesNV > ()))) , # [cfg (feature = "VK_HUAWEI_invocation_mask")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDeviceInvocationMaskFeaturesHuawei => Self :: PhysicalDeviceInvocationMaskFeaturesHUAWEI (PhysicalDeviceInvocationMaskFeaturesHUAWEI :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: huawei_invocation_mask :: PhysicalDeviceInvocationMaskFeaturesHUAWEI > ()))) , # [cfg (feature = "VK_NV_mesh_shader")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDeviceMeshShaderFeaturesNv => Self :: PhysicalDeviceMeshShaderFeaturesNV (PhysicalDeviceMeshShaderFeaturesNV :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: nv_mesh_shader :: PhysicalDeviceMeshShaderFeaturesNV > ()))) , # [cfg (feature = "VK_KHR_acceleration_structure")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDeviceAccelerationStructureFeaturesKhr => Self :: PhysicalDeviceAccelerationStructureFeaturesKHR (PhysicalDeviceAccelerationStructureFeaturesKHR :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: khr_acceleration_structure :: PhysicalDeviceAccelerationStructureFeaturesKHR > ()))) , # [cfg (feature = "VK_KHR_ray_tracing_pipeline")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDeviceRayTracingPipelineFeaturesKhr => Self :: PhysicalDeviceRayTracingPipelineFeaturesKHR (PhysicalDeviceRayTracingPipelineFeaturesKHR :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: khr_ray_tracing_pipeline :: PhysicalDeviceRayTracingPipelineFeaturesKHR > ()))) , # [cfg (feature = "VK_KHR_ray_query")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDeviceRayQueryFeaturesKhr => Self :: PhysicalDeviceRayQueryFeaturesKHR (PhysicalDeviceRayQueryFeaturesKHR :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: khr_ray_query :: PhysicalDeviceRayQueryFeaturesKHR > ()))) , # [cfg (feature = "VK_AMD_memory_overallocation_behavior")] crate :: native :: vulkan1_0 :: StructureType :: DeviceMemoryOverallocationCreateInfoAmd => Self :: DeviceMemoryOverallocationCreateInfoAMD (DeviceMemoryOverallocationCreateInfoAMD :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: amd_memory_overallocation_behavior :: DeviceMemoryOverallocationCreateInfoAMD > ()))) , # [cfg (feature = "VK_EXT_fragment_density_map")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDeviceFragmentDensityMapFeaturesExt => Self :: PhysicalDeviceFragmentDensityMapFeaturesEXT (PhysicalDeviceFragmentDensityMapFeaturesEXT :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: ext_fragment_density_map :: PhysicalDeviceFragmentDensityMapFeaturesEXT > ()))) , # [cfg (feature = "VK_EXT_fragment_density_map2")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDeviceFragmentDensityMap2FeaturesExt => Self :: PhysicalDeviceFragmentDensityMap2FeaturesEXT (PhysicalDeviceFragmentDensityMap2FeaturesEXT :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: ext_fragment_density_map2 :: PhysicalDeviceFragmentDensityMap2FeaturesEXT > ()))) , # [cfg (feature = "VULKAN_1_2")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDeviceScalarBlockLayoutFeatures => Self :: PhysicalDeviceScalarBlockLayoutFeatures (PhysicalDeviceScalarBlockLayoutFeatures :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: vulkan1_2 :: PhysicalDeviceScalarBlockLayoutFeatures > ()))) , # [cfg (feature = "VULKAN_1_2")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDeviceUniformBufferStandardLayoutFeatures => Self :: PhysicalDeviceUniformBufferStandardLayoutFeatures (PhysicalDeviceUniformBufferStandardLayoutFeatures :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: vulkan1_2 :: PhysicalDeviceUniformBufferStandardLayoutFeatures > ()))) , # [cfg (feature = "VK_EXT_depth_clip_enable")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDeviceDepthClipEnableFeaturesExt => Self :: PhysicalDeviceDepthClipEnableFeaturesEXT (PhysicalDeviceDepthClipEnableFeaturesEXT :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: ext_depth_clip_enable :: PhysicalDeviceDepthClipEnableFeaturesEXT > ()))) , # [cfg (feature = "VK_EXT_memory_priority")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDeviceMemoryPriorityFeaturesExt => Self :: PhysicalDeviceMemoryPriorityFeaturesEXT (PhysicalDeviceMemoryPriorityFeaturesEXT :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: ext_memory_priority :: PhysicalDeviceMemoryPriorityFeaturesEXT > ()))) , # [cfg (feature = "VK_EXT_pageable_device_local_memory")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDevicePageableDeviceLocalMemoryFeaturesExt => Self :: PhysicalDevicePageableDeviceLocalMemoryFeaturesEXT (PhysicalDevicePageableDeviceLocalMemoryFeaturesEXT :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: ext_pageable_device_local_memory :: PhysicalDevicePageableDeviceLocalMemoryFeaturesEXT > ()))) , # [cfg (feature = "VULKAN_1_2")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDeviceBufferDeviceAddressFeatures => Self :: PhysicalDeviceBufferDeviceAddressFeatures (PhysicalDeviceBufferDeviceAddressFeatures :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: vulkan1_2 :: PhysicalDeviceBufferDeviceAddressFeatures > ()))) , # [cfg (feature = "VK_EXT_buffer_device_address")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDeviceBufferDeviceAddressFeaturesExt => Self :: PhysicalDeviceBufferDeviceAddressFeaturesEXT (PhysicalDeviceBufferDeviceAddressFeaturesEXT :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: ext_buffer_device_address :: PhysicalDeviceBufferDeviceAddressFeaturesEXT > ()))) , # [cfg (feature = "VULKAN_1_2")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDeviceImagelessFramebufferFeatures => Self :: PhysicalDeviceImagelessFramebufferFeatures (PhysicalDeviceImagelessFramebufferFeatures :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: vulkan1_2 :: PhysicalDeviceImagelessFramebufferFeatures > ()))) , # [cfg (feature = "VULKAN_1_3")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDeviceTextureCompressionAstcHdrFeatures => Self :: PhysicalDeviceTextureCompressionAstchdrFeatures (PhysicalDeviceTextureCompressionAstchdrFeatures :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: vulkan1_3 :: PhysicalDeviceTextureCompressionAstchdrFeatures > ()))) , # [cfg (feature = "VK_NV_cooperative_matrix")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDeviceCooperativeMatrixFeaturesNv => Self :: PhysicalDeviceCooperativeMatrixFeaturesNV (PhysicalDeviceCooperativeMatrixFeaturesNV :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: nv_cooperative_matrix :: PhysicalDeviceCooperativeMatrixFeaturesNV > ()))) , # [cfg (feature = "VK_EXT_ycbcr_image_arrays")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDeviceYcbcrImageArraysFeaturesExt => Self :: PhysicalDeviceYcbcrImageArraysFeaturesEXT (PhysicalDeviceYcbcrImageArraysFeaturesEXT :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: ext_ycbcr_image_arrays :: PhysicalDeviceYcbcrImageArraysFeaturesEXT > ()))) , # [cfg (feature = "VK_KHR_performance_query")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDevicePerformanceQueryFeaturesKhr => Self :: PhysicalDevicePerformanceQueryFeaturesKHR (PhysicalDevicePerformanceQueryFeaturesKHR :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: khr_performance_query :: PhysicalDevicePerformanceQueryFeaturesKHR > ()))) , # [cfg (feature = "VK_NV_coverage_reduction_mode")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDeviceCoverageReductionModeFeaturesNv => Self :: PhysicalDeviceCoverageReductionModeFeaturesNV (PhysicalDeviceCoverageReductionModeFeaturesNV :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: nv_coverage_reduction_mode :: PhysicalDeviceCoverageReductionModeFeaturesNV > ()))) , # [cfg (feature = "VK_INTEL_shader_integer_functions2")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDeviceShaderIntegerFunctions2FeaturesIntel => Self :: PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL (PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: intel_shader_integer_functions2 :: PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL > ()))) , # [cfg (feature = "VK_KHR_shader_clock")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDeviceShaderClockFeaturesKhr => Self :: PhysicalDeviceShaderClockFeaturesKHR (PhysicalDeviceShaderClockFeaturesKHR :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: khr_shader_clock :: PhysicalDeviceShaderClockFeaturesKHR > ()))) , # [cfg (feature = "VK_EXT_index_type_uint8")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDeviceIndexTypeUint8FeaturesExt => Self :: PhysicalDeviceIndexTypeUint8FeaturesEXT (PhysicalDeviceIndexTypeUint8FeaturesEXT :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: ext_index_type_uint8 :: PhysicalDeviceIndexTypeUint8FeaturesEXT > ()))) , # [cfg (feature = "VK_NV_shader_sm_builtins")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDeviceShaderSmBuiltinsFeaturesNv => Self :: PhysicalDeviceShaderSmBuiltinsFeaturesNV (PhysicalDeviceShaderSmBuiltinsFeaturesNV :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: nv_shader_sm_builtins :: PhysicalDeviceShaderSmBuiltinsFeaturesNV > ()))) , # [cfg (feature = "VK_EXT_fragment_shader_interlock")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDeviceFragmentShaderInterlockFeaturesExt => Self :: PhysicalDeviceFragmentShaderInterlockFeaturesEXT (PhysicalDeviceFragmentShaderInterlockFeaturesEXT :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: ext_fragment_shader_interlock :: PhysicalDeviceFragmentShaderInterlockFeaturesEXT > ()))) , # [cfg (feature = "VULKAN_1_2")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDeviceSeparateDepthStencilLayoutsFeatures => Self :: PhysicalDeviceSeparateDepthStencilLayoutsFeatures (PhysicalDeviceSeparateDepthStencilLayoutsFeatures :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: vulkan1_2 :: PhysicalDeviceSeparateDepthStencilLayoutsFeatures > ()))) , # [cfg (feature = "VK_EXT_primitive_topology_list_restart")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDevicePrimitiveTopologyListRestartFeaturesExt => Self :: PhysicalDevicePrimitiveTopologyListRestartFeaturesEXT (PhysicalDevicePrimitiveTopologyListRestartFeaturesEXT :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: ext_primitive_topology_list_restart :: PhysicalDevicePrimitiveTopologyListRestartFeaturesEXT > ()))) , # [cfg (feature = "VK_KHR_pipeline_executable_properties")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDevicePipelineExecutablePropertiesFeaturesKhr => Self :: PhysicalDevicePipelineExecutablePropertiesFeaturesKHR (PhysicalDevicePipelineExecutablePropertiesFeaturesKHR :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: khr_pipeline_executable_properties :: PhysicalDevicePipelineExecutablePropertiesFeaturesKHR > ()))) , # [cfg (feature = "VULKAN_1_3")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDeviceShaderDemoteToHelperInvocationFeatures => Self :: PhysicalDeviceShaderDemoteToHelperInvocationFeatures (PhysicalDeviceShaderDemoteToHelperInvocationFeatures :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: vulkan1_3 :: PhysicalDeviceShaderDemoteToHelperInvocationFeatures > ()))) , # [cfg (feature = "VK_EXT_texel_buffer_alignment")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDeviceTexelBufferAlignmentFeaturesExt => Self :: PhysicalDeviceTexelBufferAlignmentFeaturesEXT (PhysicalDeviceTexelBufferAlignmentFeaturesEXT :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: ext_texel_buffer_alignment :: PhysicalDeviceTexelBufferAlignmentFeaturesEXT > ()))) , # [cfg (feature = "VULKAN_1_3")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDeviceSubgroupSizeControlFeatures => Self :: PhysicalDeviceSubgroupSizeControlFeatures (PhysicalDeviceSubgroupSizeControlFeatures :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: vulkan1_3 :: PhysicalDeviceSubgroupSizeControlFeatures > ()))) , # [cfg (feature = "VK_EXT_line_rasterization")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDeviceLineRasterizationFeaturesExt => Self :: PhysicalDeviceLineRasterizationFeaturesEXT (PhysicalDeviceLineRasterizationFeaturesEXT :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: ext_line_rasterization :: PhysicalDeviceLineRasterizationFeaturesEXT > ()))) , # [cfg (feature = "VULKAN_1_3")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDevicePipelineCreationCacheControlFeatures => Self :: PhysicalDevicePipelineCreationCacheControlFeatures (PhysicalDevicePipelineCreationCacheControlFeatures :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: vulkan1_3 :: PhysicalDevicePipelineCreationCacheControlFeatures > ()))) , # [cfg (feature = "VULKAN_1_2")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDeviceVulkan11Features => Self :: PhysicalDeviceVulkan11Features (PhysicalDeviceVulkan11Features :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: vulkan1_2 :: PhysicalDeviceVulkan11Features > ()))) , # [cfg (feature = "VULKAN_1_2")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDeviceVulkan12Features => Self :: PhysicalDeviceVulkan12Features (PhysicalDeviceVulkan12Features :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: vulkan1_2 :: PhysicalDeviceVulkan12Features > ()))) , # [cfg (feature = "VULKAN_1_3")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDeviceVulkan13Features => Self :: PhysicalDeviceVulkan13Features (PhysicalDeviceVulkan13Features :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: vulkan1_3 :: PhysicalDeviceVulkan13Features > ()))) , # [cfg (feature = "VK_AMD_device_coherent_memory")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDeviceCoherentMemoryFeaturesAmd => Self :: PhysicalDeviceCoherentMemoryFeaturesAMD (PhysicalDeviceCoherentMemoryFeaturesAMD :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: amd_device_coherent_memory :: PhysicalDeviceCoherentMemoryFeaturesAMD > ()))) , # [cfg (feature = "VK_EXT_custom_border_color")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDeviceCustomBorderColorFeaturesExt => Self :: PhysicalDeviceCustomBorderColorFeaturesEXT (PhysicalDeviceCustomBorderColorFeaturesEXT :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: ext_custom_border_color :: PhysicalDeviceCustomBorderColorFeaturesEXT > ()))) , # [cfg (feature = "VK_EXT_border_color_swizzle")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDeviceBorderColorSwizzleFeaturesExt => Self :: PhysicalDeviceBorderColorSwizzleFeaturesEXT (PhysicalDeviceBorderColorSwizzleFeaturesEXT :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: ext_border_color_swizzle :: PhysicalDeviceBorderColorSwizzleFeaturesEXT > ()))) , # [cfg (feature = "VK_EXT_extended_dynamic_state")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDeviceExtendedDynamicStateFeaturesExt => Self :: PhysicalDeviceExtendedDynamicStateFeaturesEXT (PhysicalDeviceExtendedDynamicStateFeaturesEXT :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: ext_extended_dynamic_state :: PhysicalDeviceExtendedDynamicStateFeaturesEXT > ()))) , # [cfg (feature = "VK_EXT_extended_dynamic_state2")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDeviceExtendedDynamicState2FeaturesExt => Self :: PhysicalDeviceExtendedDynamicState2FeaturesEXT (PhysicalDeviceExtendedDynamicState2FeaturesEXT :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: ext_extended_dynamic_state2 :: PhysicalDeviceExtendedDynamicState2FeaturesEXT > ()))) , # [cfg (feature = "VK_NV_device_diagnostics_config")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDeviceDiagnosticsConfigFeaturesNv => Self :: PhysicalDeviceDiagnosticsConfigFeaturesNV (PhysicalDeviceDiagnosticsConfigFeaturesNV :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: nv_device_diagnostics_config :: PhysicalDeviceDiagnosticsConfigFeaturesNV > ()))) , # [cfg (feature = "VK_NV_device_diagnostics_config")] crate :: native :: vulkan1_0 :: StructureType :: DeviceDiagnosticsConfigCreateInfoNv => Self :: DeviceDiagnosticsConfigCreateInfoNV (DeviceDiagnosticsConfigCreateInfoNV :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: nv_device_diagnostics_config :: DeviceDiagnosticsConfigCreateInfoNV > ()))) , # [cfg (feature = "VULKAN_1_3")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures => Self :: PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures (PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: vulkan1_3 :: PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures > ()))) , # [cfg (feature = "VK_KHR_shader_subgroup_uniform_control_flow")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKhr => Self :: PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR (PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: khr_shader_subgroup_uniform_control_flow :: PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR > ()))) , # [cfg (feature = "VK_EXT_robustness2")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDeviceRobustness2FeaturesExt => Self :: PhysicalDeviceRobustness2FeaturesEXT (PhysicalDeviceRobustness2FeaturesEXT :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: ext_robustness2 :: PhysicalDeviceRobustness2FeaturesEXT > ()))) , # [cfg (feature = "VULKAN_1_3")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDeviceImageRobustnessFeatures => Self :: PhysicalDeviceImageRobustnessFeatures (PhysicalDeviceImageRobustnessFeatures :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: vulkan1_3 :: PhysicalDeviceImageRobustnessFeatures > ()))) , # [cfg (feature = "VK_KHR_workgroup_memory_explicit_layout")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKhr => Self :: PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR (PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: khr_workgroup_memory_explicit_layout :: PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR > ()))) , # [cfg (feature = "VK_KHR_portability_subset")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDevicePortabilitySubsetFeaturesKhr => Self :: PhysicalDevicePortabilitySubsetFeaturesKHR (PhysicalDevicePortabilitySubsetFeaturesKHR :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: khr_portability_subset :: PhysicalDevicePortabilitySubsetFeaturesKHR > ()))) , # [cfg (feature = "VK_EXT_4444_formats")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDevice4444FormatsFeaturesExt => Self :: PhysicalDevice4444FormatsFeaturesEXT (PhysicalDevice4444FormatsFeaturesEXT :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: ext_4444_formats :: PhysicalDevice4444FormatsFeaturesEXT > ()))) , # [cfg (feature = "VK_HUAWEI_subpass_shading")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDeviceSubpassShadingFeaturesHuawei => Self :: PhysicalDeviceSubpassShadingFeaturesHUAWEI (PhysicalDeviceSubpassShadingFeaturesHUAWEI :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: huawei_subpass_shading :: PhysicalDeviceSubpassShadingFeaturesHUAWEI > ()))) , # [cfg (feature = "VK_EXT_shader_image_atomic_int64")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDeviceShaderImageAtomicInt64FeaturesExt => Self :: PhysicalDeviceShaderImageAtomicInt64FeaturesEXT (PhysicalDeviceShaderImageAtomicInt64FeaturesEXT :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: ext_shader_image_atomic_int64 :: PhysicalDeviceShaderImageAtomicInt64FeaturesEXT > ()))) , # [cfg (feature = "VK_KHR_fragment_shading_rate")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDeviceFragmentShadingRateFeaturesKhr => Self :: PhysicalDeviceFragmentShadingRateFeaturesKHR (PhysicalDeviceFragmentShadingRateFeaturesKHR :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: khr_fragment_shading_rate :: PhysicalDeviceFragmentShadingRateFeaturesKHR > ()))) , # [cfg (feature = "VULKAN_1_3")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDeviceShaderTerminateInvocationFeatures => Self :: PhysicalDeviceShaderTerminateInvocationFeatures (PhysicalDeviceShaderTerminateInvocationFeatures :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: vulkan1_3 :: PhysicalDeviceShaderTerminateInvocationFeatures > ()))) , # [cfg (feature = "VK_NV_fragment_shading_rate_enums")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDeviceFragmentShadingRateEnumsFeaturesNv => Self :: PhysicalDeviceFragmentShadingRateEnumsFeaturesNV (PhysicalDeviceFragmentShadingRateEnumsFeaturesNV :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: nv_fragment_shading_rate_enums :: PhysicalDeviceFragmentShadingRateEnumsFeaturesNV > ()))) , # [cfg (feature = "VK_VALVE_mutable_descriptor_type")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDeviceMutableDescriptorTypeFeaturesValve => Self :: PhysicalDeviceMutableDescriptorTypeFeaturesVALVE (PhysicalDeviceMutableDescriptorTypeFeaturesVALVE :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: valve_mutable_descriptor_type :: PhysicalDeviceMutableDescriptorTypeFeaturesVALVE > ()))) , # [cfg (feature = "VK_EXT_depth_clip_control")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDeviceDepthClipControlFeaturesExt => Self :: PhysicalDeviceDepthClipControlFeaturesEXT (PhysicalDeviceDepthClipControlFeaturesEXT :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: ext_depth_clip_control :: PhysicalDeviceDepthClipControlFeaturesEXT > ()))) , # [cfg (feature = "VK_EXT_vertex_input_dynamic_state")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDeviceVertexInputDynamicStateFeaturesExt => Self :: PhysicalDeviceVertexInputDynamicStateFeaturesEXT (PhysicalDeviceVertexInputDynamicStateFeaturesEXT :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: ext_vertex_input_dynamic_state :: PhysicalDeviceVertexInputDynamicStateFeaturesEXT > ()))) , # [cfg (feature = "VK_NV_external_memory_rdma")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDeviceExternalMemoryRdmaFeaturesNv => Self :: PhysicalDeviceExternalMemoryRdmaFeaturesNV (PhysicalDeviceExternalMemoryRdmaFeaturesNV :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: nv_external_memory_rdma :: PhysicalDeviceExternalMemoryRdmaFeaturesNV > ()))) , # [cfg (feature = "VK_EXT_color_write_enable")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDeviceColorWriteEnableFeaturesExt => Self :: PhysicalDeviceColorWriteEnableFeaturesEXT (PhysicalDeviceColorWriteEnableFeaturesEXT :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: ext_color_write_enable :: PhysicalDeviceColorWriteEnableFeaturesEXT > ()))) , # [cfg (feature = "VULKAN_1_3")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDeviceSynchronization2Features => Self :: PhysicalDeviceSynchronization2Features (PhysicalDeviceSynchronization2Features :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: vulkan1_3 :: PhysicalDeviceSynchronization2Features > ()))) , # [cfg (feature = "VK_NV_inherited_viewport_scissor")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDeviceInheritedViewportScissorFeaturesNv => Self :: PhysicalDeviceInheritedViewportScissorFeaturesNV (PhysicalDeviceInheritedViewportScissorFeaturesNV :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: nv_inherited_viewport_scissor :: PhysicalDeviceInheritedViewportScissorFeaturesNV > ()))) , # [cfg (feature = "VK_EXT_ycbcr_2plane_444_formats")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDeviceYcbcr2Plane444FormatsFeaturesExt => Self :: PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT (PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: ext_ycbcr_2plane_444_formats :: PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT > ()))) , # [cfg (feature = "VK_EXT_provoking_vertex")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDeviceProvokingVertexFeaturesExt => Self :: PhysicalDeviceProvokingVertexFeaturesEXT (PhysicalDeviceProvokingVertexFeaturesEXT :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: ext_provoking_vertex :: PhysicalDeviceProvokingVertexFeaturesEXT > ()))) , # [cfg (feature = "VULKAN_1_3")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDeviceShaderIntegerDotProductFeatures => Self :: PhysicalDeviceShaderIntegerDotProductFeatures (PhysicalDeviceShaderIntegerDotProductFeatures :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: vulkan1_3 :: PhysicalDeviceShaderIntegerDotProductFeatures > ()))) , # [cfg (feature = "VK_NV_ray_tracing_motion_blur")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDeviceRayTracingMotionBlurFeaturesNv => Self :: PhysicalDeviceRayTracingMotionBlurFeaturesNV (PhysicalDeviceRayTracingMotionBlurFeaturesNV :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: nv_ray_tracing_motion_blur :: PhysicalDeviceRayTracingMotionBlurFeaturesNV > ()))) , # [cfg (feature = "VK_EXT_rgba10x6_formats")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDeviceRgba10x6FormatsFeaturesExt => Self :: PhysicalDeviceRgba10x6FormatsFeaturesEXT (PhysicalDeviceRgba10x6FormatsFeaturesEXT :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: ext_rgba10x6_formats :: PhysicalDeviceRgba10x6FormatsFeaturesEXT > ()))) , # [cfg (feature = "VULKAN_1_3")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDeviceDynamicRenderingFeatures => Self :: PhysicalDeviceDynamicRenderingFeatures (PhysicalDeviceDynamicRenderingFeatures :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: vulkan1_3 :: PhysicalDeviceDynamicRenderingFeatures > ()))) , # [cfg (feature = "VK_EXT_image_view_min_lod")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDeviceImageViewMinLodFeaturesExt => Self :: PhysicalDeviceImageViewMinLodFeaturesEXT (PhysicalDeviceImageViewMinLodFeaturesEXT :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: ext_image_view_min_lod :: PhysicalDeviceImageViewMinLodFeaturesEXT > ()))) , # [cfg (feature = "VK_ARM_rasterization_order_attachment_access")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesArm => Self :: PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesARM (PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesARM :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: arm_rasterization_order_attachment_access :: PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesARM > ()))) , # [cfg (feature = "VK_NV_linear_color_attachment")] crate :: native :: vulkan1_0 :: StructureType :: PhysicalDeviceLinearColorAttachmentFeaturesNv => Self :: PhysicalDeviceLinearColorAttachmentFeaturesNV (PhysicalDeviceLinearColorAttachmentFeaturesNV :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: nv_linear_color_attachment :: PhysicalDeviceLinearColorAttachmentFeaturesNV > ()))) , other => panic ! ("Structure type {:?} is not a member of {}" , other , stringify ! (DeviceCreateInfo)) }
    }
}
#[cfg(feature = "VK_NV_device_generated_commands")]
impl From<PhysicalDeviceDeviceGeneratedCommandsFeaturesNV> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDeviceDeviceGeneratedCommandsFeaturesNV) -> Self {
        Self::PhysicalDeviceDeviceGeneratedCommandsFeaturesNV(ext)
    }
}
#[cfg(feature = "VK_NV_device_generated_commands")]
impl TryInto<PhysicalDeviceDeviceGeneratedCommandsFeaturesNV> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDeviceDeviceGeneratedCommandsFeaturesNV, Self::Error> {
        match self {
            Self::PhysicalDeviceDeviceGeneratedCommandsFeaturesNV(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VULKAN_1_3")]
impl From<DevicePrivateDataCreateInfo> for DeviceCreateInfoExtension {
    fn from(ext: DevicePrivateDataCreateInfo) -> Self {
        Self::DevicePrivateDataCreateInfo(ext)
    }
}
#[cfg(feature = "VULKAN_1_3")]
impl TryInto<DevicePrivateDataCreateInfo> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<DevicePrivateDataCreateInfo, Self::Error> {
        match self {
            Self::DevicePrivateDataCreateInfo(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VULKAN_1_3")]
impl From<PhysicalDevicePrivateDataFeatures> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDevicePrivateDataFeatures) -> Self {
        Self::PhysicalDevicePrivateDataFeatures(ext)
    }
}
#[cfg(feature = "VULKAN_1_3")]
impl TryInto<PhysicalDevicePrivateDataFeatures> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDevicePrivateDataFeatures, Self::Error> {
        match self {
            Self::PhysicalDevicePrivateDataFeatures(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
impl From<PhysicalDeviceFeatures2> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDeviceFeatures2) -> Self {
        Self::PhysicalDeviceFeatures2(ext)
    }
}
impl TryInto<PhysicalDeviceFeatures2> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDeviceFeatures2, Self::Error> {
        match self {
            Self::PhysicalDeviceFeatures2(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
impl From<PhysicalDeviceVariablePointersFeatures> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDeviceVariablePointersFeatures) -> Self {
        Self::PhysicalDeviceVariablePointersFeatures(ext)
    }
}
impl TryInto<PhysicalDeviceVariablePointersFeatures> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDeviceVariablePointersFeatures, Self::Error> {
        match self {
            Self::PhysicalDeviceVariablePointersFeatures(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
impl From<PhysicalDeviceMultiviewFeatures> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDeviceMultiviewFeatures) -> Self {
        Self::PhysicalDeviceMultiviewFeatures(ext)
    }
}
impl TryInto<PhysicalDeviceMultiviewFeatures> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDeviceMultiviewFeatures, Self::Error> {
        match self {
            Self::PhysicalDeviceMultiviewFeatures(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
impl From<DeviceGroupDeviceCreateInfo> for DeviceCreateInfoExtension {
    fn from(ext: DeviceGroupDeviceCreateInfo) -> Self {
        Self::DeviceGroupDeviceCreateInfo(ext)
    }
}
impl TryInto<DeviceGroupDeviceCreateInfo> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<DeviceGroupDeviceCreateInfo, Self::Error> {
        match self {
            Self::DeviceGroupDeviceCreateInfo(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_KHR_present_id")]
impl From<PhysicalDevicePresentIdFeaturesKHR> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDevicePresentIdFeaturesKHR) -> Self {
        Self::PhysicalDevicePresentIdFeaturesKHR(ext)
    }
}
#[cfg(feature = "VK_KHR_present_id")]
impl TryInto<PhysicalDevicePresentIdFeaturesKHR> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDevicePresentIdFeaturesKHR, Self::Error> {
        match self {
            Self::PhysicalDevicePresentIdFeaturesKHR(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_KHR_present_wait")]
impl From<PhysicalDevicePresentWaitFeaturesKHR> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDevicePresentWaitFeaturesKHR) -> Self {
        Self::PhysicalDevicePresentWaitFeaturesKHR(ext)
    }
}
#[cfg(feature = "VK_KHR_present_wait")]
impl TryInto<PhysicalDevicePresentWaitFeaturesKHR> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDevicePresentWaitFeaturesKHR, Self::Error> {
        match self {
            Self::PhysicalDevicePresentWaitFeaturesKHR(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
impl From<PhysicalDevice16BitStorageFeatures> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDevice16BitStorageFeatures) -> Self {
        Self::PhysicalDevice16BitStorageFeatures(ext)
    }
}
impl TryInto<PhysicalDevice16BitStorageFeatures> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDevice16BitStorageFeatures, Self::Error> {
        match self {
            Self::PhysicalDevice16BitStorageFeatures(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VULKAN_1_2")]
impl From<PhysicalDeviceShaderSubgroupExtendedTypesFeatures> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDeviceShaderSubgroupExtendedTypesFeatures) -> Self {
        Self::PhysicalDeviceShaderSubgroupExtendedTypesFeatures(ext)
    }
}
#[cfg(feature = "VULKAN_1_2")]
impl TryInto<PhysicalDeviceShaderSubgroupExtendedTypesFeatures> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDeviceShaderSubgroupExtendedTypesFeatures, Self::Error> {
        match self {
            Self::PhysicalDeviceShaderSubgroupExtendedTypesFeatures(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
impl From<PhysicalDeviceSamplerYcbcrConversionFeatures> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDeviceSamplerYcbcrConversionFeatures) -> Self {
        Self::PhysicalDeviceSamplerYcbcrConversionFeatures(ext)
    }
}
impl TryInto<PhysicalDeviceSamplerYcbcrConversionFeatures> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDeviceSamplerYcbcrConversionFeatures, Self::Error> {
        match self {
            Self::PhysicalDeviceSamplerYcbcrConversionFeatures(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
impl From<PhysicalDeviceProtectedMemoryFeatures> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDeviceProtectedMemoryFeatures) -> Self {
        Self::PhysicalDeviceProtectedMemoryFeatures(ext)
    }
}
impl TryInto<PhysicalDeviceProtectedMemoryFeatures> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDeviceProtectedMemoryFeatures, Self::Error> {
        match self {
            Self::PhysicalDeviceProtectedMemoryFeatures(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_EXT_blend_operation_advanced")]
impl From<PhysicalDeviceBlendOperationAdvancedFeaturesEXT> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDeviceBlendOperationAdvancedFeaturesEXT) -> Self {
        Self::PhysicalDeviceBlendOperationAdvancedFeaturesEXT(ext)
    }
}
#[cfg(feature = "VK_EXT_blend_operation_advanced")]
impl TryInto<PhysicalDeviceBlendOperationAdvancedFeaturesEXT> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDeviceBlendOperationAdvancedFeaturesEXT, Self::Error> {
        match self {
            Self::PhysicalDeviceBlendOperationAdvancedFeaturesEXT(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_EXT_multi_draw")]
impl From<PhysicalDeviceMultiDrawFeaturesEXT> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDeviceMultiDrawFeaturesEXT) -> Self {
        Self::PhysicalDeviceMultiDrawFeaturesEXT(ext)
    }
}
#[cfg(feature = "VK_EXT_multi_draw")]
impl TryInto<PhysicalDeviceMultiDrawFeaturesEXT> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDeviceMultiDrawFeaturesEXT, Self::Error> {
        match self {
            Self::PhysicalDeviceMultiDrawFeaturesEXT(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VULKAN_1_3")]
impl From<PhysicalDeviceInlineUniformBlockFeatures> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDeviceInlineUniformBlockFeatures) -> Self {
        Self::PhysicalDeviceInlineUniformBlockFeatures(ext)
    }
}
#[cfg(feature = "VULKAN_1_3")]
impl TryInto<PhysicalDeviceInlineUniformBlockFeatures> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDeviceInlineUniformBlockFeatures, Self::Error> {
        match self {
            Self::PhysicalDeviceInlineUniformBlockFeatures(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VULKAN_1_3")]
impl From<PhysicalDeviceMaintenance4Features> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDeviceMaintenance4Features) -> Self {
        Self::PhysicalDeviceMaintenance4Features(ext)
    }
}
#[cfg(feature = "VULKAN_1_3")]
impl TryInto<PhysicalDeviceMaintenance4Features> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDeviceMaintenance4Features, Self::Error> {
        match self {
            Self::PhysicalDeviceMaintenance4Features(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
impl From<PhysicalDeviceShaderDrawParametersFeatures> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDeviceShaderDrawParametersFeatures) -> Self {
        Self::PhysicalDeviceShaderDrawParametersFeatures(ext)
    }
}
impl TryInto<PhysicalDeviceShaderDrawParametersFeatures> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDeviceShaderDrawParametersFeatures, Self::Error> {
        match self {
            Self::PhysicalDeviceShaderDrawParametersFeatures(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VULKAN_1_2")]
impl From<PhysicalDeviceShaderFloat16Int8Features> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDeviceShaderFloat16Int8Features) -> Self {
        Self::PhysicalDeviceShaderFloat16Int8Features(ext)
    }
}
#[cfg(feature = "VULKAN_1_2")]
impl TryInto<PhysicalDeviceShaderFloat16Int8Features> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDeviceShaderFloat16Int8Features, Self::Error> {
        match self {
            Self::PhysicalDeviceShaderFloat16Int8Features(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VULKAN_1_2")]
impl From<PhysicalDeviceHostQueryResetFeatures> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDeviceHostQueryResetFeatures) -> Self {
        Self::PhysicalDeviceHostQueryResetFeatures(ext)
    }
}
#[cfg(feature = "VULKAN_1_2")]
impl TryInto<PhysicalDeviceHostQueryResetFeatures> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDeviceHostQueryResetFeatures, Self::Error> {
        match self {
            Self::PhysicalDeviceHostQueryResetFeatures(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_KHR_global_priority")]
impl From<PhysicalDeviceGlobalPriorityQueryFeaturesKHR> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDeviceGlobalPriorityQueryFeaturesKHR) -> Self {
        Self::PhysicalDeviceGlobalPriorityQueryFeaturesKHR(ext)
    }
}
#[cfg(feature = "VK_KHR_global_priority")]
impl TryInto<PhysicalDeviceGlobalPriorityQueryFeaturesKHR> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDeviceGlobalPriorityQueryFeaturesKHR, Self::Error> {
        match self {
            Self::PhysicalDeviceGlobalPriorityQueryFeaturesKHR(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_EXT_device_memory_report")]
impl From<PhysicalDeviceDeviceMemoryReportFeaturesEXT> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDeviceDeviceMemoryReportFeaturesEXT) -> Self {
        Self::PhysicalDeviceDeviceMemoryReportFeaturesEXT(ext)
    }
}
#[cfg(feature = "VK_EXT_device_memory_report")]
impl TryInto<PhysicalDeviceDeviceMemoryReportFeaturesEXT> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDeviceDeviceMemoryReportFeaturesEXT, Self::Error> {
        match self {
            Self::PhysicalDeviceDeviceMemoryReportFeaturesEXT(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_EXT_device_memory_report")]
impl From<DeviceDeviceMemoryReportCreateInfoEXT> for DeviceCreateInfoExtension {
    fn from(ext: DeviceDeviceMemoryReportCreateInfoEXT) -> Self {
        Self::DeviceDeviceMemoryReportCreateInfoEXT(ext)
    }
}
#[cfg(feature = "VK_EXT_device_memory_report")]
impl TryInto<DeviceDeviceMemoryReportCreateInfoEXT> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<DeviceDeviceMemoryReportCreateInfoEXT, Self::Error> {
        match self {
            Self::DeviceDeviceMemoryReportCreateInfoEXT(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VULKAN_1_2")]
impl From<PhysicalDeviceDescriptorIndexingFeatures> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDeviceDescriptorIndexingFeatures) -> Self {
        Self::PhysicalDeviceDescriptorIndexingFeatures(ext)
    }
}
#[cfg(feature = "VULKAN_1_2")]
impl TryInto<PhysicalDeviceDescriptorIndexingFeatures> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDeviceDescriptorIndexingFeatures, Self::Error> {
        match self {
            Self::PhysicalDeviceDescriptorIndexingFeatures(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VULKAN_1_2")]
impl From<PhysicalDeviceTimelineSemaphoreFeatures> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDeviceTimelineSemaphoreFeatures) -> Self {
        Self::PhysicalDeviceTimelineSemaphoreFeatures(ext)
    }
}
#[cfg(feature = "VULKAN_1_2")]
impl TryInto<PhysicalDeviceTimelineSemaphoreFeatures> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDeviceTimelineSemaphoreFeatures, Self::Error> {
        match self {
            Self::PhysicalDeviceTimelineSemaphoreFeatures(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VULKAN_1_2")]
impl From<PhysicalDevice8BitStorageFeatures> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDevice8BitStorageFeatures) -> Self {
        Self::PhysicalDevice8BitStorageFeatures(ext)
    }
}
#[cfg(feature = "VULKAN_1_2")]
impl TryInto<PhysicalDevice8BitStorageFeatures> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDevice8BitStorageFeatures, Self::Error> {
        match self {
            Self::PhysicalDevice8BitStorageFeatures(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_EXT_conditional_rendering")]
impl From<PhysicalDeviceConditionalRenderingFeaturesEXT> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDeviceConditionalRenderingFeaturesEXT) -> Self {
        Self::PhysicalDeviceConditionalRenderingFeaturesEXT(ext)
    }
}
#[cfg(feature = "VK_EXT_conditional_rendering")]
impl TryInto<PhysicalDeviceConditionalRenderingFeaturesEXT> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDeviceConditionalRenderingFeaturesEXT, Self::Error> {
        match self {
            Self::PhysicalDeviceConditionalRenderingFeaturesEXT(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VULKAN_1_2")]
impl From<PhysicalDeviceVulkanMemoryModelFeatures> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDeviceVulkanMemoryModelFeatures) -> Self {
        Self::PhysicalDeviceVulkanMemoryModelFeatures(ext)
    }
}
#[cfg(feature = "VULKAN_1_2")]
impl TryInto<PhysicalDeviceVulkanMemoryModelFeatures> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDeviceVulkanMemoryModelFeatures, Self::Error> {
        match self {
            Self::PhysicalDeviceVulkanMemoryModelFeatures(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VULKAN_1_2")]
impl From<PhysicalDeviceShaderAtomicInt64Features> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDeviceShaderAtomicInt64Features) -> Self {
        Self::PhysicalDeviceShaderAtomicInt64Features(ext)
    }
}
#[cfg(feature = "VULKAN_1_2")]
impl TryInto<PhysicalDeviceShaderAtomicInt64Features> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDeviceShaderAtomicInt64Features, Self::Error> {
        match self {
            Self::PhysicalDeviceShaderAtomicInt64Features(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_EXT_shader_atomic_float")]
impl From<PhysicalDeviceShaderAtomicFloatFeaturesEXT> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDeviceShaderAtomicFloatFeaturesEXT) -> Self {
        Self::PhysicalDeviceShaderAtomicFloatFeaturesEXT(ext)
    }
}
#[cfg(feature = "VK_EXT_shader_atomic_float")]
impl TryInto<PhysicalDeviceShaderAtomicFloatFeaturesEXT> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDeviceShaderAtomicFloatFeaturesEXT, Self::Error> {
        match self {
            Self::PhysicalDeviceShaderAtomicFloatFeaturesEXT(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_EXT_shader_atomic_float2")]
impl From<PhysicalDeviceShaderAtomicFloat2FeaturesEXT> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDeviceShaderAtomicFloat2FeaturesEXT) -> Self {
        Self::PhysicalDeviceShaderAtomicFloat2FeaturesEXT(ext)
    }
}
#[cfg(feature = "VK_EXT_shader_atomic_float2")]
impl TryInto<PhysicalDeviceShaderAtomicFloat2FeaturesEXT> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDeviceShaderAtomicFloat2FeaturesEXT, Self::Error> {
        match self {
            Self::PhysicalDeviceShaderAtomicFloat2FeaturesEXT(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_EXT_vertex_attribute_divisor")]
impl From<PhysicalDeviceVertexAttributeDivisorFeaturesEXT> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDeviceVertexAttributeDivisorFeaturesEXT) -> Self {
        Self::PhysicalDeviceVertexAttributeDivisorFeaturesEXT(ext)
    }
}
#[cfg(feature = "VK_EXT_vertex_attribute_divisor")]
impl TryInto<PhysicalDeviceVertexAttributeDivisorFeaturesEXT> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDeviceVertexAttributeDivisorFeaturesEXT, Self::Error> {
        match self {
            Self::PhysicalDeviceVertexAttributeDivisorFeaturesEXT(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_EXT_astc_decode_mode")]
impl From<PhysicalDeviceAstcDecodeFeaturesEXT> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDeviceAstcDecodeFeaturesEXT) -> Self {
        Self::PhysicalDeviceAstcDecodeFeaturesEXT(ext)
    }
}
#[cfg(feature = "VK_EXT_astc_decode_mode")]
impl TryInto<PhysicalDeviceAstcDecodeFeaturesEXT> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDeviceAstcDecodeFeaturesEXT, Self::Error> {
        match self {
            Self::PhysicalDeviceAstcDecodeFeaturesEXT(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_EXT_transform_feedback")]
impl From<PhysicalDeviceTransformFeedbackFeaturesEXT> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDeviceTransformFeedbackFeaturesEXT) -> Self {
        Self::PhysicalDeviceTransformFeedbackFeaturesEXT(ext)
    }
}
#[cfg(feature = "VK_EXT_transform_feedback")]
impl TryInto<PhysicalDeviceTransformFeedbackFeaturesEXT> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDeviceTransformFeedbackFeaturesEXT, Self::Error> {
        match self {
            Self::PhysicalDeviceTransformFeedbackFeaturesEXT(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_NV_representative_fragment_test")]
impl From<PhysicalDeviceRepresentativeFragmentTestFeaturesNV> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDeviceRepresentativeFragmentTestFeaturesNV) -> Self {
        Self::PhysicalDeviceRepresentativeFragmentTestFeaturesNV(ext)
    }
}
#[cfg(feature = "VK_NV_representative_fragment_test")]
impl TryInto<PhysicalDeviceRepresentativeFragmentTestFeaturesNV> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDeviceRepresentativeFragmentTestFeaturesNV, Self::Error> {
        match self {
            Self::PhysicalDeviceRepresentativeFragmentTestFeaturesNV(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_NV_scissor_exclusive")]
impl From<PhysicalDeviceExclusiveScissorFeaturesNV> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDeviceExclusiveScissorFeaturesNV) -> Self {
        Self::PhysicalDeviceExclusiveScissorFeaturesNV(ext)
    }
}
#[cfg(feature = "VK_NV_scissor_exclusive")]
impl TryInto<PhysicalDeviceExclusiveScissorFeaturesNV> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDeviceExclusiveScissorFeaturesNV, Self::Error> {
        match self {
            Self::PhysicalDeviceExclusiveScissorFeaturesNV(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_NV_corner_sampled_image")]
impl From<PhysicalDeviceCornerSampledImageFeaturesNV> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDeviceCornerSampledImageFeaturesNV) -> Self {
        Self::PhysicalDeviceCornerSampledImageFeaturesNV(ext)
    }
}
#[cfg(feature = "VK_NV_corner_sampled_image")]
impl TryInto<PhysicalDeviceCornerSampledImageFeaturesNV> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDeviceCornerSampledImageFeaturesNV, Self::Error> {
        match self {
            Self::PhysicalDeviceCornerSampledImageFeaturesNV(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_NV_compute_shader_derivatives")]
impl From<PhysicalDeviceComputeShaderDerivativesFeaturesNV> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDeviceComputeShaderDerivativesFeaturesNV) -> Self {
        Self::PhysicalDeviceComputeShaderDerivativesFeaturesNV(ext)
    }
}
#[cfg(feature = "VK_NV_compute_shader_derivatives")]
impl TryInto<PhysicalDeviceComputeShaderDerivativesFeaturesNV> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDeviceComputeShaderDerivativesFeaturesNV, Self::Error> {
        match self {
            Self::PhysicalDeviceComputeShaderDerivativesFeaturesNV(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_NV_fragment_shader_barycentric")]
impl From<PhysicalDeviceFragmentShaderBarycentricFeaturesNV> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDeviceFragmentShaderBarycentricFeaturesNV) -> Self {
        Self::PhysicalDeviceFragmentShaderBarycentricFeaturesNV(ext)
    }
}
#[cfg(feature = "VK_NV_fragment_shader_barycentric")]
impl TryInto<PhysicalDeviceFragmentShaderBarycentricFeaturesNV> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDeviceFragmentShaderBarycentricFeaturesNV, Self::Error> {
        match self {
            Self::PhysicalDeviceFragmentShaderBarycentricFeaturesNV(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_NV_shader_image_footprint")]
impl From<PhysicalDeviceShaderImageFootprintFeaturesNV> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDeviceShaderImageFootprintFeaturesNV) -> Self {
        Self::PhysicalDeviceShaderImageFootprintFeaturesNV(ext)
    }
}
#[cfg(feature = "VK_NV_shader_image_footprint")]
impl TryInto<PhysicalDeviceShaderImageFootprintFeaturesNV> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDeviceShaderImageFootprintFeaturesNV, Self::Error> {
        match self {
            Self::PhysicalDeviceShaderImageFootprintFeaturesNV(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_NV_dedicated_allocation_image_aliasing")]
impl From<PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV) -> Self {
        Self::PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV(ext)
    }
}
#[cfg(feature = "VK_NV_dedicated_allocation_image_aliasing")]
impl TryInto<PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV, Self::Error> {
        match self {
            Self::PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_NV_shading_rate_image")]
impl From<PhysicalDeviceShadingRateImageFeaturesNV> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDeviceShadingRateImageFeaturesNV) -> Self {
        Self::PhysicalDeviceShadingRateImageFeaturesNV(ext)
    }
}
#[cfg(feature = "VK_NV_shading_rate_image")]
impl TryInto<PhysicalDeviceShadingRateImageFeaturesNV> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDeviceShadingRateImageFeaturesNV, Self::Error> {
        match self {
            Self::PhysicalDeviceShadingRateImageFeaturesNV(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_HUAWEI_invocation_mask")]
impl From<PhysicalDeviceInvocationMaskFeaturesHUAWEI> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDeviceInvocationMaskFeaturesHUAWEI) -> Self {
        Self::PhysicalDeviceInvocationMaskFeaturesHUAWEI(ext)
    }
}
#[cfg(feature = "VK_HUAWEI_invocation_mask")]
impl TryInto<PhysicalDeviceInvocationMaskFeaturesHUAWEI> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDeviceInvocationMaskFeaturesHUAWEI, Self::Error> {
        match self {
            Self::PhysicalDeviceInvocationMaskFeaturesHUAWEI(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_NV_mesh_shader")]
impl From<PhysicalDeviceMeshShaderFeaturesNV> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDeviceMeshShaderFeaturesNV) -> Self {
        Self::PhysicalDeviceMeshShaderFeaturesNV(ext)
    }
}
#[cfg(feature = "VK_NV_mesh_shader")]
impl TryInto<PhysicalDeviceMeshShaderFeaturesNV> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDeviceMeshShaderFeaturesNV, Self::Error> {
        match self {
            Self::PhysicalDeviceMeshShaderFeaturesNV(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_KHR_acceleration_structure")]
impl From<PhysicalDeviceAccelerationStructureFeaturesKHR> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDeviceAccelerationStructureFeaturesKHR) -> Self {
        Self::PhysicalDeviceAccelerationStructureFeaturesKHR(ext)
    }
}
#[cfg(feature = "VK_KHR_acceleration_structure")]
impl TryInto<PhysicalDeviceAccelerationStructureFeaturesKHR> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDeviceAccelerationStructureFeaturesKHR, Self::Error> {
        match self {
            Self::PhysicalDeviceAccelerationStructureFeaturesKHR(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
impl From<PhysicalDeviceRayTracingPipelineFeaturesKHR> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDeviceRayTracingPipelineFeaturesKHR) -> Self {
        Self::PhysicalDeviceRayTracingPipelineFeaturesKHR(ext)
    }
}
#[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
impl TryInto<PhysicalDeviceRayTracingPipelineFeaturesKHR> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDeviceRayTracingPipelineFeaturesKHR, Self::Error> {
        match self {
            Self::PhysicalDeviceRayTracingPipelineFeaturesKHR(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_KHR_ray_query")]
impl From<PhysicalDeviceRayQueryFeaturesKHR> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDeviceRayQueryFeaturesKHR) -> Self {
        Self::PhysicalDeviceRayQueryFeaturesKHR(ext)
    }
}
#[cfg(feature = "VK_KHR_ray_query")]
impl TryInto<PhysicalDeviceRayQueryFeaturesKHR> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDeviceRayQueryFeaturesKHR, Self::Error> {
        match self {
            Self::PhysicalDeviceRayQueryFeaturesKHR(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_AMD_memory_overallocation_behavior")]
impl From<DeviceMemoryOverallocationCreateInfoAMD> for DeviceCreateInfoExtension {
    fn from(ext: DeviceMemoryOverallocationCreateInfoAMD) -> Self {
        Self::DeviceMemoryOverallocationCreateInfoAMD(ext)
    }
}
#[cfg(feature = "VK_AMD_memory_overallocation_behavior")]
impl TryInto<DeviceMemoryOverallocationCreateInfoAMD> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<DeviceMemoryOverallocationCreateInfoAMD, Self::Error> {
        match self {
            Self::DeviceMemoryOverallocationCreateInfoAMD(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_EXT_fragment_density_map")]
impl From<PhysicalDeviceFragmentDensityMapFeaturesEXT> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDeviceFragmentDensityMapFeaturesEXT) -> Self {
        Self::PhysicalDeviceFragmentDensityMapFeaturesEXT(ext)
    }
}
#[cfg(feature = "VK_EXT_fragment_density_map")]
impl TryInto<PhysicalDeviceFragmentDensityMapFeaturesEXT> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDeviceFragmentDensityMapFeaturesEXT, Self::Error> {
        match self {
            Self::PhysicalDeviceFragmentDensityMapFeaturesEXT(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_EXT_fragment_density_map2")]
impl From<PhysicalDeviceFragmentDensityMap2FeaturesEXT> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDeviceFragmentDensityMap2FeaturesEXT) -> Self {
        Self::PhysicalDeviceFragmentDensityMap2FeaturesEXT(ext)
    }
}
#[cfg(feature = "VK_EXT_fragment_density_map2")]
impl TryInto<PhysicalDeviceFragmentDensityMap2FeaturesEXT> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDeviceFragmentDensityMap2FeaturesEXT, Self::Error> {
        match self {
            Self::PhysicalDeviceFragmentDensityMap2FeaturesEXT(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VULKAN_1_2")]
impl From<PhysicalDeviceScalarBlockLayoutFeatures> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDeviceScalarBlockLayoutFeatures) -> Self {
        Self::PhysicalDeviceScalarBlockLayoutFeatures(ext)
    }
}
#[cfg(feature = "VULKAN_1_2")]
impl TryInto<PhysicalDeviceScalarBlockLayoutFeatures> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDeviceScalarBlockLayoutFeatures, Self::Error> {
        match self {
            Self::PhysicalDeviceScalarBlockLayoutFeatures(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VULKAN_1_2")]
impl From<PhysicalDeviceUniformBufferStandardLayoutFeatures> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDeviceUniformBufferStandardLayoutFeatures) -> Self {
        Self::PhysicalDeviceUniformBufferStandardLayoutFeatures(ext)
    }
}
#[cfg(feature = "VULKAN_1_2")]
impl TryInto<PhysicalDeviceUniformBufferStandardLayoutFeatures> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDeviceUniformBufferStandardLayoutFeatures, Self::Error> {
        match self {
            Self::PhysicalDeviceUniformBufferStandardLayoutFeatures(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_EXT_depth_clip_enable")]
impl From<PhysicalDeviceDepthClipEnableFeaturesEXT> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDeviceDepthClipEnableFeaturesEXT) -> Self {
        Self::PhysicalDeviceDepthClipEnableFeaturesEXT(ext)
    }
}
#[cfg(feature = "VK_EXT_depth_clip_enable")]
impl TryInto<PhysicalDeviceDepthClipEnableFeaturesEXT> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDeviceDepthClipEnableFeaturesEXT, Self::Error> {
        match self {
            Self::PhysicalDeviceDepthClipEnableFeaturesEXT(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_EXT_memory_priority")]
impl From<PhysicalDeviceMemoryPriorityFeaturesEXT> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDeviceMemoryPriorityFeaturesEXT) -> Self {
        Self::PhysicalDeviceMemoryPriorityFeaturesEXT(ext)
    }
}
#[cfg(feature = "VK_EXT_memory_priority")]
impl TryInto<PhysicalDeviceMemoryPriorityFeaturesEXT> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDeviceMemoryPriorityFeaturesEXT, Self::Error> {
        match self {
            Self::PhysicalDeviceMemoryPriorityFeaturesEXT(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_EXT_pageable_device_local_memory")]
impl From<PhysicalDevicePageableDeviceLocalMemoryFeaturesEXT> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDevicePageableDeviceLocalMemoryFeaturesEXT) -> Self {
        Self::PhysicalDevicePageableDeviceLocalMemoryFeaturesEXT(ext)
    }
}
#[cfg(feature = "VK_EXT_pageable_device_local_memory")]
impl TryInto<PhysicalDevicePageableDeviceLocalMemoryFeaturesEXT> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDevicePageableDeviceLocalMemoryFeaturesEXT, Self::Error> {
        match self {
            Self::PhysicalDevicePageableDeviceLocalMemoryFeaturesEXT(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VULKAN_1_2")]
impl From<PhysicalDeviceBufferDeviceAddressFeatures> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDeviceBufferDeviceAddressFeatures) -> Self {
        Self::PhysicalDeviceBufferDeviceAddressFeatures(ext)
    }
}
#[cfg(feature = "VULKAN_1_2")]
impl TryInto<PhysicalDeviceBufferDeviceAddressFeatures> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDeviceBufferDeviceAddressFeatures, Self::Error> {
        match self {
            Self::PhysicalDeviceBufferDeviceAddressFeatures(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_EXT_buffer_device_address")]
impl From<PhysicalDeviceBufferDeviceAddressFeaturesEXT> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDeviceBufferDeviceAddressFeaturesEXT) -> Self {
        Self::PhysicalDeviceBufferDeviceAddressFeaturesEXT(ext)
    }
}
#[cfg(feature = "VK_EXT_buffer_device_address")]
impl TryInto<PhysicalDeviceBufferDeviceAddressFeaturesEXT> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDeviceBufferDeviceAddressFeaturesEXT, Self::Error> {
        match self {
            Self::PhysicalDeviceBufferDeviceAddressFeaturesEXT(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VULKAN_1_2")]
impl From<PhysicalDeviceImagelessFramebufferFeatures> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDeviceImagelessFramebufferFeatures) -> Self {
        Self::PhysicalDeviceImagelessFramebufferFeatures(ext)
    }
}
#[cfg(feature = "VULKAN_1_2")]
impl TryInto<PhysicalDeviceImagelessFramebufferFeatures> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDeviceImagelessFramebufferFeatures, Self::Error> {
        match self {
            Self::PhysicalDeviceImagelessFramebufferFeatures(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VULKAN_1_3")]
impl From<PhysicalDeviceTextureCompressionAstchdrFeatures> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDeviceTextureCompressionAstchdrFeatures) -> Self {
        Self::PhysicalDeviceTextureCompressionAstchdrFeatures(ext)
    }
}
#[cfg(feature = "VULKAN_1_3")]
impl TryInto<PhysicalDeviceTextureCompressionAstchdrFeatures> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDeviceTextureCompressionAstchdrFeatures, Self::Error> {
        match self {
            Self::PhysicalDeviceTextureCompressionAstchdrFeatures(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_NV_cooperative_matrix")]
impl From<PhysicalDeviceCooperativeMatrixFeaturesNV> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDeviceCooperativeMatrixFeaturesNV) -> Self {
        Self::PhysicalDeviceCooperativeMatrixFeaturesNV(ext)
    }
}
#[cfg(feature = "VK_NV_cooperative_matrix")]
impl TryInto<PhysicalDeviceCooperativeMatrixFeaturesNV> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDeviceCooperativeMatrixFeaturesNV, Self::Error> {
        match self {
            Self::PhysicalDeviceCooperativeMatrixFeaturesNV(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_EXT_ycbcr_image_arrays")]
impl From<PhysicalDeviceYcbcrImageArraysFeaturesEXT> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDeviceYcbcrImageArraysFeaturesEXT) -> Self {
        Self::PhysicalDeviceYcbcrImageArraysFeaturesEXT(ext)
    }
}
#[cfg(feature = "VK_EXT_ycbcr_image_arrays")]
impl TryInto<PhysicalDeviceYcbcrImageArraysFeaturesEXT> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDeviceYcbcrImageArraysFeaturesEXT, Self::Error> {
        match self {
            Self::PhysicalDeviceYcbcrImageArraysFeaturesEXT(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_KHR_performance_query")]
impl From<PhysicalDevicePerformanceQueryFeaturesKHR> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDevicePerformanceQueryFeaturesKHR) -> Self {
        Self::PhysicalDevicePerformanceQueryFeaturesKHR(ext)
    }
}
#[cfg(feature = "VK_KHR_performance_query")]
impl TryInto<PhysicalDevicePerformanceQueryFeaturesKHR> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDevicePerformanceQueryFeaturesKHR, Self::Error> {
        match self {
            Self::PhysicalDevicePerformanceQueryFeaturesKHR(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_NV_coverage_reduction_mode")]
impl From<PhysicalDeviceCoverageReductionModeFeaturesNV> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDeviceCoverageReductionModeFeaturesNV) -> Self {
        Self::PhysicalDeviceCoverageReductionModeFeaturesNV(ext)
    }
}
#[cfg(feature = "VK_NV_coverage_reduction_mode")]
impl TryInto<PhysicalDeviceCoverageReductionModeFeaturesNV> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDeviceCoverageReductionModeFeaturesNV, Self::Error> {
        match self {
            Self::PhysicalDeviceCoverageReductionModeFeaturesNV(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_INTEL_shader_integer_functions2")]
impl From<PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL) -> Self {
        Self::PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL(ext)
    }
}
#[cfg(feature = "VK_INTEL_shader_integer_functions2")]
impl TryInto<PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL, Self::Error> {
        match self {
            Self::PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_KHR_shader_clock")]
impl From<PhysicalDeviceShaderClockFeaturesKHR> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDeviceShaderClockFeaturesKHR) -> Self {
        Self::PhysicalDeviceShaderClockFeaturesKHR(ext)
    }
}
#[cfg(feature = "VK_KHR_shader_clock")]
impl TryInto<PhysicalDeviceShaderClockFeaturesKHR> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDeviceShaderClockFeaturesKHR, Self::Error> {
        match self {
            Self::PhysicalDeviceShaderClockFeaturesKHR(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_EXT_index_type_uint8")]
impl From<PhysicalDeviceIndexTypeUint8FeaturesEXT> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDeviceIndexTypeUint8FeaturesEXT) -> Self {
        Self::PhysicalDeviceIndexTypeUint8FeaturesEXT(ext)
    }
}
#[cfg(feature = "VK_EXT_index_type_uint8")]
impl TryInto<PhysicalDeviceIndexTypeUint8FeaturesEXT> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDeviceIndexTypeUint8FeaturesEXT, Self::Error> {
        match self {
            Self::PhysicalDeviceIndexTypeUint8FeaturesEXT(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_NV_shader_sm_builtins")]
impl From<PhysicalDeviceShaderSmBuiltinsFeaturesNV> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDeviceShaderSmBuiltinsFeaturesNV) -> Self {
        Self::PhysicalDeviceShaderSmBuiltinsFeaturesNV(ext)
    }
}
#[cfg(feature = "VK_NV_shader_sm_builtins")]
impl TryInto<PhysicalDeviceShaderSmBuiltinsFeaturesNV> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDeviceShaderSmBuiltinsFeaturesNV, Self::Error> {
        match self {
            Self::PhysicalDeviceShaderSmBuiltinsFeaturesNV(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_EXT_fragment_shader_interlock")]
impl From<PhysicalDeviceFragmentShaderInterlockFeaturesEXT> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDeviceFragmentShaderInterlockFeaturesEXT) -> Self {
        Self::PhysicalDeviceFragmentShaderInterlockFeaturesEXT(ext)
    }
}
#[cfg(feature = "VK_EXT_fragment_shader_interlock")]
impl TryInto<PhysicalDeviceFragmentShaderInterlockFeaturesEXT> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDeviceFragmentShaderInterlockFeaturesEXT, Self::Error> {
        match self {
            Self::PhysicalDeviceFragmentShaderInterlockFeaturesEXT(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VULKAN_1_2")]
impl From<PhysicalDeviceSeparateDepthStencilLayoutsFeatures> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDeviceSeparateDepthStencilLayoutsFeatures) -> Self {
        Self::PhysicalDeviceSeparateDepthStencilLayoutsFeatures(ext)
    }
}
#[cfg(feature = "VULKAN_1_2")]
impl TryInto<PhysicalDeviceSeparateDepthStencilLayoutsFeatures> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDeviceSeparateDepthStencilLayoutsFeatures, Self::Error> {
        match self {
            Self::PhysicalDeviceSeparateDepthStencilLayoutsFeatures(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_EXT_primitive_topology_list_restart")]
impl From<PhysicalDevicePrimitiveTopologyListRestartFeaturesEXT> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDevicePrimitiveTopologyListRestartFeaturesEXT) -> Self {
        Self::PhysicalDevicePrimitiveTopologyListRestartFeaturesEXT(ext)
    }
}
#[cfg(feature = "VK_EXT_primitive_topology_list_restart")]
impl TryInto<PhysicalDevicePrimitiveTopologyListRestartFeaturesEXT> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDevicePrimitiveTopologyListRestartFeaturesEXT, Self::Error> {
        match self {
            Self::PhysicalDevicePrimitiveTopologyListRestartFeaturesEXT(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_KHR_pipeline_executable_properties")]
impl From<PhysicalDevicePipelineExecutablePropertiesFeaturesKHR> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDevicePipelineExecutablePropertiesFeaturesKHR) -> Self {
        Self::PhysicalDevicePipelineExecutablePropertiesFeaturesKHR(ext)
    }
}
#[cfg(feature = "VK_KHR_pipeline_executable_properties")]
impl TryInto<PhysicalDevicePipelineExecutablePropertiesFeaturesKHR> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDevicePipelineExecutablePropertiesFeaturesKHR, Self::Error> {
        match self {
            Self::PhysicalDevicePipelineExecutablePropertiesFeaturesKHR(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VULKAN_1_3")]
impl From<PhysicalDeviceShaderDemoteToHelperInvocationFeatures> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDeviceShaderDemoteToHelperInvocationFeatures) -> Self {
        Self::PhysicalDeviceShaderDemoteToHelperInvocationFeatures(ext)
    }
}
#[cfg(feature = "VULKAN_1_3")]
impl TryInto<PhysicalDeviceShaderDemoteToHelperInvocationFeatures> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDeviceShaderDemoteToHelperInvocationFeatures, Self::Error> {
        match self {
            Self::PhysicalDeviceShaderDemoteToHelperInvocationFeatures(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_EXT_texel_buffer_alignment")]
impl From<PhysicalDeviceTexelBufferAlignmentFeaturesEXT> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDeviceTexelBufferAlignmentFeaturesEXT) -> Self {
        Self::PhysicalDeviceTexelBufferAlignmentFeaturesEXT(ext)
    }
}
#[cfg(feature = "VK_EXT_texel_buffer_alignment")]
impl TryInto<PhysicalDeviceTexelBufferAlignmentFeaturesEXT> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDeviceTexelBufferAlignmentFeaturesEXT, Self::Error> {
        match self {
            Self::PhysicalDeviceTexelBufferAlignmentFeaturesEXT(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VULKAN_1_3")]
impl From<PhysicalDeviceSubgroupSizeControlFeatures> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDeviceSubgroupSizeControlFeatures) -> Self {
        Self::PhysicalDeviceSubgroupSizeControlFeatures(ext)
    }
}
#[cfg(feature = "VULKAN_1_3")]
impl TryInto<PhysicalDeviceSubgroupSizeControlFeatures> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDeviceSubgroupSizeControlFeatures, Self::Error> {
        match self {
            Self::PhysicalDeviceSubgroupSizeControlFeatures(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_EXT_line_rasterization")]
impl From<PhysicalDeviceLineRasterizationFeaturesEXT> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDeviceLineRasterizationFeaturesEXT) -> Self {
        Self::PhysicalDeviceLineRasterizationFeaturesEXT(ext)
    }
}
#[cfg(feature = "VK_EXT_line_rasterization")]
impl TryInto<PhysicalDeviceLineRasterizationFeaturesEXT> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDeviceLineRasterizationFeaturesEXT, Self::Error> {
        match self {
            Self::PhysicalDeviceLineRasterizationFeaturesEXT(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VULKAN_1_3")]
impl From<PhysicalDevicePipelineCreationCacheControlFeatures> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDevicePipelineCreationCacheControlFeatures) -> Self {
        Self::PhysicalDevicePipelineCreationCacheControlFeatures(ext)
    }
}
#[cfg(feature = "VULKAN_1_3")]
impl TryInto<PhysicalDevicePipelineCreationCacheControlFeatures> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDevicePipelineCreationCacheControlFeatures, Self::Error> {
        match self {
            Self::PhysicalDevicePipelineCreationCacheControlFeatures(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VULKAN_1_2")]
impl From<PhysicalDeviceVulkan11Features> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDeviceVulkan11Features) -> Self {
        Self::PhysicalDeviceVulkan11Features(ext)
    }
}
#[cfg(feature = "VULKAN_1_2")]
impl TryInto<PhysicalDeviceVulkan11Features> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDeviceVulkan11Features, Self::Error> {
        match self {
            Self::PhysicalDeviceVulkan11Features(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VULKAN_1_2")]
impl From<PhysicalDeviceVulkan12Features> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDeviceVulkan12Features) -> Self {
        Self::PhysicalDeviceVulkan12Features(ext)
    }
}
#[cfg(feature = "VULKAN_1_2")]
impl TryInto<PhysicalDeviceVulkan12Features> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDeviceVulkan12Features, Self::Error> {
        match self {
            Self::PhysicalDeviceVulkan12Features(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VULKAN_1_3")]
impl From<PhysicalDeviceVulkan13Features> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDeviceVulkan13Features) -> Self {
        Self::PhysicalDeviceVulkan13Features(ext)
    }
}
#[cfg(feature = "VULKAN_1_3")]
impl TryInto<PhysicalDeviceVulkan13Features> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDeviceVulkan13Features, Self::Error> {
        match self {
            Self::PhysicalDeviceVulkan13Features(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_AMD_device_coherent_memory")]
impl From<PhysicalDeviceCoherentMemoryFeaturesAMD> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDeviceCoherentMemoryFeaturesAMD) -> Self {
        Self::PhysicalDeviceCoherentMemoryFeaturesAMD(ext)
    }
}
#[cfg(feature = "VK_AMD_device_coherent_memory")]
impl TryInto<PhysicalDeviceCoherentMemoryFeaturesAMD> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDeviceCoherentMemoryFeaturesAMD, Self::Error> {
        match self {
            Self::PhysicalDeviceCoherentMemoryFeaturesAMD(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_EXT_custom_border_color")]
impl From<PhysicalDeviceCustomBorderColorFeaturesEXT> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDeviceCustomBorderColorFeaturesEXT) -> Self {
        Self::PhysicalDeviceCustomBorderColorFeaturesEXT(ext)
    }
}
#[cfg(feature = "VK_EXT_custom_border_color")]
impl TryInto<PhysicalDeviceCustomBorderColorFeaturesEXT> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDeviceCustomBorderColorFeaturesEXT, Self::Error> {
        match self {
            Self::PhysicalDeviceCustomBorderColorFeaturesEXT(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_EXT_border_color_swizzle")]
impl From<PhysicalDeviceBorderColorSwizzleFeaturesEXT> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDeviceBorderColorSwizzleFeaturesEXT) -> Self {
        Self::PhysicalDeviceBorderColorSwizzleFeaturesEXT(ext)
    }
}
#[cfg(feature = "VK_EXT_border_color_swizzle")]
impl TryInto<PhysicalDeviceBorderColorSwizzleFeaturesEXT> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDeviceBorderColorSwizzleFeaturesEXT, Self::Error> {
        match self {
            Self::PhysicalDeviceBorderColorSwizzleFeaturesEXT(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_EXT_extended_dynamic_state")]
impl From<PhysicalDeviceExtendedDynamicStateFeaturesEXT> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDeviceExtendedDynamicStateFeaturesEXT) -> Self {
        Self::PhysicalDeviceExtendedDynamicStateFeaturesEXT(ext)
    }
}
#[cfg(feature = "VK_EXT_extended_dynamic_state")]
impl TryInto<PhysicalDeviceExtendedDynamicStateFeaturesEXT> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDeviceExtendedDynamicStateFeaturesEXT, Self::Error> {
        match self {
            Self::PhysicalDeviceExtendedDynamicStateFeaturesEXT(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_EXT_extended_dynamic_state2")]
impl From<PhysicalDeviceExtendedDynamicState2FeaturesEXT> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDeviceExtendedDynamicState2FeaturesEXT) -> Self {
        Self::PhysicalDeviceExtendedDynamicState2FeaturesEXT(ext)
    }
}
#[cfg(feature = "VK_EXT_extended_dynamic_state2")]
impl TryInto<PhysicalDeviceExtendedDynamicState2FeaturesEXT> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDeviceExtendedDynamicState2FeaturesEXT, Self::Error> {
        match self {
            Self::PhysicalDeviceExtendedDynamicState2FeaturesEXT(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_NV_device_diagnostics_config")]
impl From<PhysicalDeviceDiagnosticsConfigFeaturesNV> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDeviceDiagnosticsConfigFeaturesNV) -> Self {
        Self::PhysicalDeviceDiagnosticsConfigFeaturesNV(ext)
    }
}
#[cfg(feature = "VK_NV_device_diagnostics_config")]
impl TryInto<PhysicalDeviceDiagnosticsConfigFeaturesNV> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDeviceDiagnosticsConfigFeaturesNV, Self::Error> {
        match self {
            Self::PhysicalDeviceDiagnosticsConfigFeaturesNV(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_NV_device_diagnostics_config")]
impl From<DeviceDiagnosticsConfigCreateInfoNV> for DeviceCreateInfoExtension {
    fn from(ext: DeviceDiagnosticsConfigCreateInfoNV) -> Self {
        Self::DeviceDiagnosticsConfigCreateInfoNV(ext)
    }
}
#[cfg(feature = "VK_NV_device_diagnostics_config")]
impl TryInto<DeviceDiagnosticsConfigCreateInfoNV> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<DeviceDiagnosticsConfigCreateInfoNV, Self::Error> {
        match self {
            Self::DeviceDiagnosticsConfigCreateInfoNV(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VULKAN_1_3")]
impl From<PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures) -> Self {
        Self::PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures(ext)
    }
}
#[cfg(feature = "VULKAN_1_3")]
impl TryInto<PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures, Self::Error> {
        match self {
            Self::PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_KHR_shader_subgroup_uniform_control_flow")]
impl From<PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR) -> Self {
        Self::PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR(ext)
    }
}
#[cfg(feature = "VK_KHR_shader_subgroup_uniform_control_flow")]
impl TryInto<PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR, Self::Error> {
        match self {
            Self::PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_EXT_robustness2")]
impl From<PhysicalDeviceRobustness2FeaturesEXT> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDeviceRobustness2FeaturesEXT) -> Self {
        Self::PhysicalDeviceRobustness2FeaturesEXT(ext)
    }
}
#[cfg(feature = "VK_EXT_robustness2")]
impl TryInto<PhysicalDeviceRobustness2FeaturesEXT> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDeviceRobustness2FeaturesEXT, Self::Error> {
        match self {
            Self::PhysicalDeviceRobustness2FeaturesEXT(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VULKAN_1_3")]
impl From<PhysicalDeviceImageRobustnessFeatures> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDeviceImageRobustnessFeatures) -> Self {
        Self::PhysicalDeviceImageRobustnessFeatures(ext)
    }
}
#[cfg(feature = "VULKAN_1_3")]
impl TryInto<PhysicalDeviceImageRobustnessFeatures> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDeviceImageRobustnessFeatures, Self::Error> {
        match self {
            Self::PhysicalDeviceImageRobustnessFeatures(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_KHR_workgroup_memory_explicit_layout")]
impl From<PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR) -> Self {
        Self::PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR(ext)
    }
}
#[cfg(feature = "VK_KHR_workgroup_memory_explicit_layout")]
impl TryInto<PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR, Self::Error> {
        match self {
            Self::PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_KHR_portability_subset")]
impl From<PhysicalDevicePortabilitySubsetFeaturesKHR> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDevicePortabilitySubsetFeaturesKHR) -> Self {
        Self::PhysicalDevicePortabilitySubsetFeaturesKHR(ext)
    }
}
#[cfg(feature = "VK_KHR_portability_subset")]
impl TryInto<PhysicalDevicePortabilitySubsetFeaturesKHR> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDevicePortabilitySubsetFeaturesKHR, Self::Error> {
        match self {
            Self::PhysicalDevicePortabilitySubsetFeaturesKHR(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_EXT_4444_formats")]
impl From<PhysicalDevice4444FormatsFeaturesEXT> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDevice4444FormatsFeaturesEXT) -> Self {
        Self::PhysicalDevice4444FormatsFeaturesEXT(ext)
    }
}
#[cfg(feature = "VK_EXT_4444_formats")]
impl TryInto<PhysicalDevice4444FormatsFeaturesEXT> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDevice4444FormatsFeaturesEXT, Self::Error> {
        match self {
            Self::PhysicalDevice4444FormatsFeaturesEXT(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_HUAWEI_subpass_shading")]
impl From<PhysicalDeviceSubpassShadingFeaturesHUAWEI> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDeviceSubpassShadingFeaturesHUAWEI) -> Self {
        Self::PhysicalDeviceSubpassShadingFeaturesHUAWEI(ext)
    }
}
#[cfg(feature = "VK_HUAWEI_subpass_shading")]
impl TryInto<PhysicalDeviceSubpassShadingFeaturesHUAWEI> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDeviceSubpassShadingFeaturesHUAWEI, Self::Error> {
        match self {
            Self::PhysicalDeviceSubpassShadingFeaturesHUAWEI(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_EXT_shader_image_atomic_int64")]
impl From<PhysicalDeviceShaderImageAtomicInt64FeaturesEXT> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDeviceShaderImageAtomicInt64FeaturesEXT) -> Self {
        Self::PhysicalDeviceShaderImageAtomicInt64FeaturesEXT(ext)
    }
}
#[cfg(feature = "VK_EXT_shader_image_atomic_int64")]
impl TryInto<PhysicalDeviceShaderImageAtomicInt64FeaturesEXT> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDeviceShaderImageAtomicInt64FeaturesEXT, Self::Error> {
        match self {
            Self::PhysicalDeviceShaderImageAtomicInt64FeaturesEXT(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_KHR_fragment_shading_rate")]
impl From<PhysicalDeviceFragmentShadingRateFeaturesKHR> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDeviceFragmentShadingRateFeaturesKHR) -> Self {
        Self::PhysicalDeviceFragmentShadingRateFeaturesKHR(ext)
    }
}
#[cfg(feature = "VK_KHR_fragment_shading_rate")]
impl TryInto<PhysicalDeviceFragmentShadingRateFeaturesKHR> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDeviceFragmentShadingRateFeaturesKHR, Self::Error> {
        match self {
            Self::PhysicalDeviceFragmentShadingRateFeaturesKHR(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VULKAN_1_3")]
impl From<PhysicalDeviceShaderTerminateInvocationFeatures> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDeviceShaderTerminateInvocationFeatures) -> Self {
        Self::PhysicalDeviceShaderTerminateInvocationFeatures(ext)
    }
}
#[cfg(feature = "VULKAN_1_3")]
impl TryInto<PhysicalDeviceShaderTerminateInvocationFeatures> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDeviceShaderTerminateInvocationFeatures, Self::Error> {
        match self {
            Self::PhysicalDeviceShaderTerminateInvocationFeatures(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_NV_fragment_shading_rate_enums")]
impl From<PhysicalDeviceFragmentShadingRateEnumsFeaturesNV> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDeviceFragmentShadingRateEnumsFeaturesNV) -> Self {
        Self::PhysicalDeviceFragmentShadingRateEnumsFeaturesNV(ext)
    }
}
#[cfg(feature = "VK_NV_fragment_shading_rate_enums")]
impl TryInto<PhysicalDeviceFragmentShadingRateEnumsFeaturesNV> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDeviceFragmentShadingRateEnumsFeaturesNV, Self::Error> {
        match self {
            Self::PhysicalDeviceFragmentShadingRateEnumsFeaturesNV(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_VALVE_mutable_descriptor_type")]
impl From<PhysicalDeviceMutableDescriptorTypeFeaturesVALVE> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDeviceMutableDescriptorTypeFeaturesVALVE) -> Self {
        Self::PhysicalDeviceMutableDescriptorTypeFeaturesVALVE(ext)
    }
}
#[cfg(feature = "VK_VALVE_mutable_descriptor_type")]
impl TryInto<PhysicalDeviceMutableDescriptorTypeFeaturesVALVE> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDeviceMutableDescriptorTypeFeaturesVALVE, Self::Error> {
        match self {
            Self::PhysicalDeviceMutableDescriptorTypeFeaturesVALVE(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_EXT_depth_clip_control")]
impl From<PhysicalDeviceDepthClipControlFeaturesEXT> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDeviceDepthClipControlFeaturesEXT) -> Self {
        Self::PhysicalDeviceDepthClipControlFeaturesEXT(ext)
    }
}
#[cfg(feature = "VK_EXT_depth_clip_control")]
impl TryInto<PhysicalDeviceDepthClipControlFeaturesEXT> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDeviceDepthClipControlFeaturesEXT, Self::Error> {
        match self {
            Self::PhysicalDeviceDepthClipControlFeaturesEXT(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_EXT_vertex_input_dynamic_state")]
impl From<PhysicalDeviceVertexInputDynamicStateFeaturesEXT> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDeviceVertexInputDynamicStateFeaturesEXT) -> Self {
        Self::PhysicalDeviceVertexInputDynamicStateFeaturesEXT(ext)
    }
}
#[cfg(feature = "VK_EXT_vertex_input_dynamic_state")]
impl TryInto<PhysicalDeviceVertexInputDynamicStateFeaturesEXT> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDeviceVertexInputDynamicStateFeaturesEXT, Self::Error> {
        match self {
            Self::PhysicalDeviceVertexInputDynamicStateFeaturesEXT(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_NV_external_memory_rdma")]
impl From<PhysicalDeviceExternalMemoryRdmaFeaturesNV> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDeviceExternalMemoryRdmaFeaturesNV) -> Self {
        Self::PhysicalDeviceExternalMemoryRdmaFeaturesNV(ext)
    }
}
#[cfg(feature = "VK_NV_external_memory_rdma")]
impl TryInto<PhysicalDeviceExternalMemoryRdmaFeaturesNV> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDeviceExternalMemoryRdmaFeaturesNV, Self::Error> {
        match self {
            Self::PhysicalDeviceExternalMemoryRdmaFeaturesNV(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_EXT_color_write_enable")]
impl From<PhysicalDeviceColorWriteEnableFeaturesEXT> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDeviceColorWriteEnableFeaturesEXT) -> Self {
        Self::PhysicalDeviceColorWriteEnableFeaturesEXT(ext)
    }
}
#[cfg(feature = "VK_EXT_color_write_enable")]
impl TryInto<PhysicalDeviceColorWriteEnableFeaturesEXT> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDeviceColorWriteEnableFeaturesEXT, Self::Error> {
        match self {
            Self::PhysicalDeviceColorWriteEnableFeaturesEXT(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VULKAN_1_3")]
impl From<PhysicalDeviceSynchronization2Features> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDeviceSynchronization2Features) -> Self {
        Self::PhysicalDeviceSynchronization2Features(ext)
    }
}
#[cfg(feature = "VULKAN_1_3")]
impl TryInto<PhysicalDeviceSynchronization2Features> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDeviceSynchronization2Features, Self::Error> {
        match self {
            Self::PhysicalDeviceSynchronization2Features(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_NV_inherited_viewport_scissor")]
impl From<PhysicalDeviceInheritedViewportScissorFeaturesNV> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDeviceInheritedViewportScissorFeaturesNV) -> Self {
        Self::PhysicalDeviceInheritedViewportScissorFeaturesNV(ext)
    }
}
#[cfg(feature = "VK_NV_inherited_viewport_scissor")]
impl TryInto<PhysicalDeviceInheritedViewportScissorFeaturesNV> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDeviceInheritedViewportScissorFeaturesNV, Self::Error> {
        match self {
            Self::PhysicalDeviceInheritedViewportScissorFeaturesNV(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_EXT_ycbcr_2plane_444_formats")]
impl From<PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT) -> Self {
        Self::PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT(ext)
    }
}
#[cfg(feature = "VK_EXT_ycbcr_2plane_444_formats")]
impl TryInto<PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT, Self::Error> {
        match self {
            Self::PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_EXT_provoking_vertex")]
impl From<PhysicalDeviceProvokingVertexFeaturesEXT> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDeviceProvokingVertexFeaturesEXT) -> Self {
        Self::PhysicalDeviceProvokingVertexFeaturesEXT(ext)
    }
}
#[cfg(feature = "VK_EXT_provoking_vertex")]
impl TryInto<PhysicalDeviceProvokingVertexFeaturesEXT> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDeviceProvokingVertexFeaturesEXT, Self::Error> {
        match self {
            Self::PhysicalDeviceProvokingVertexFeaturesEXT(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VULKAN_1_3")]
impl From<PhysicalDeviceShaderIntegerDotProductFeatures> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDeviceShaderIntegerDotProductFeatures) -> Self {
        Self::PhysicalDeviceShaderIntegerDotProductFeatures(ext)
    }
}
#[cfg(feature = "VULKAN_1_3")]
impl TryInto<PhysicalDeviceShaderIntegerDotProductFeatures> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDeviceShaderIntegerDotProductFeatures, Self::Error> {
        match self {
            Self::PhysicalDeviceShaderIntegerDotProductFeatures(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_NV_ray_tracing_motion_blur")]
impl From<PhysicalDeviceRayTracingMotionBlurFeaturesNV> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDeviceRayTracingMotionBlurFeaturesNV) -> Self {
        Self::PhysicalDeviceRayTracingMotionBlurFeaturesNV(ext)
    }
}
#[cfg(feature = "VK_NV_ray_tracing_motion_blur")]
impl TryInto<PhysicalDeviceRayTracingMotionBlurFeaturesNV> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDeviceRayTracingMotionBlurFeaturesNV, Self::Error> {
        match self {
            Self::PhysicalDeviceRayTracingMotionBlurFeaturesNV(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_EXT_rgba10x6_formats")]
impl From<PhysicalDeviceRgba10x6FormatsFeaturesEXT> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDeviceRgba10x6FormatsFeaturesEXT) -> Self {
        Self::PhysicalDeviceRgba10x6FormatsFeaturesEXT(ext)
    }
}
#[cfg(feature = "VK_EXT_rgba10x6_formats")]
impl TryInto<PhysicalDeviceRgba10x6FormatsFeaturesEXT> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDeviceRgba10x6FormatsFeaturesEXT, Self::Error> {
        match self {
            Self::PhysicalDeviceRgba10x6FormatsFeaturesEXT(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VULKAN_1_3")]
impl From<PhysicalDeviceDynamicRenderingFeatures> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDeviceDynamicRenderingFeatures) -> Self {
        Self::PhysicalDeviceDynamicRenderingFeatures(ext)
    }
}
#[cfg(feature = "VULKAN_1_3")]
impl TryInto<PhysicalDeviceDynamicRenderingFeatures> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDeviceDynamicRenderingFeatures, Self::Error> {
        match self {
            Self::PhysicalDeviceDynamicRenderingFeatures(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_EXT_image_view_min_lod")]
impl From<PhysicalDeviceImageViewMinLodFeaturesEXT> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDeviceImageViewMinLodFeaturesEXT) -> Self {
        Self::PhysicalDeviceImageViewMinLodFeaturesEXT(ext)
    }
}
#[cfg(feature = "VK_EXT_image_view_min_lod")]
impl TryInto<PhysicalDeviceImageViewMinLodFeaturesEXT> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDeviceImageViewMinLodFeaturesEXT, Self::Error> {
        match self {
            Self::PhysicalDeviceImageViewMinLodFeaturesEXT(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_ARM_rasterization_order_attachment_access")]
impl From<PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesARM> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesARM) -> Self {
        Self::PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesARM(ext)
    }
}
#[cfg(feature = "VK_ARM_rasterization_order_attachment_access")]
impl TryInto<PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesARM> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesARM, Self::Error> {
        match self {
            Self::PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesARM(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_NV_linear_color_attachment")]
impl From<PhysicalDeviceLinearColorAttachmentFeaturesNV> for DeviceCreateInfoExtension {
    fn from(ext: PhysicalDeviceLinearColorAttachmentFeaturesNV) -> Self {
        Self::PhysicalDeviceLinearColorAttachmentFeaturesNV(ext)
    }
}
#[cfg(feature = "VK_NV_linear_color_attachment")]
impl TryInto<PhysicalDeviceLinearColorAttachmentFeaturesNV> for DeviceCreateInfoExtension {
    type Error = DeviceCreateInfoExtension;
    fn try_into(self) -> Result<PhysicalDeviceLinearColorAttachmentFeaturesNV, Self::Error> {
        match self {
            Self::PhysicalDeviceLinearColorAttachmentFeaturesNV(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[doc(alias = "VkInstanceCreateInfo")]
#[derive(Clone, PartialEq, Debug, Default)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct InstanceCreateInfo {
    #[doc(alias = "pNext")]
    pub extensions: SmallVec<[InstanceCreateInfoExtension; 1]>,
    pub flags: InstanceCreateFlags,
    #[doc(alias = "pApplicationInfo")]
    pub application_info: Option<ApplicationInfo>,
    #[doc(alias = "ppEnabledLayerNames")]
    pub pp_enabled_layer_names: SmallVec<[String; 8]>,
    #[doc(alias = "ppEnabledExtensionNames")]
    pub pp_enabled_extension_names: SmallVec<[String; 8]>,
}
impl InstanceCreateInfo {
    ///Adds an extension to the struct
    pub fn with_extension(mut self, ext: impl Into<InstanceCreateInfoExtension>) -> Self {
        self.extensions.push(ext.into());
        self
    }
    ///Get a reference to the `extensions` field.
    pub fn extensions(&self) -> &SmallVec<[InstanceCreateInfoExtension; 1]> {
        &self.extensions
    }
    ///Get a reference to the `flags` field.
    pub fn flags(&self) -> InstanceCreateFlags {
        self.flags
    }
    ///Get a reference to the `application_info` field.
    pub fn application_info(&self) -> &Option<ApplicationInfo> {
        &self.application_info
    }
    ///Get a reference to the `pp_enabled_layer_names` field.
    pub fn pp_enabled_layer_names(&self) -> &SmallVec<[String; 8]> {
        &self.pp_enabled_layer_names
    }
    ///Get a reference to the `pp_enabled_extension_names` field.
    pub fn pp_enabled_extension_names(&self) -> &SmallVec<[String; 8]> {
        &self.pp_enabled_extension_names
    }
    ///Get a mutable reference to the `extensions` field.
    pub fn extensions_mut(&mut self) -> &mut SmallVec<[InstanceCreateInfoExtension; 1]> {
        &mut self.extensions
    }
    ///Get a mutable reference to the `flags` field.
    pub fn flags_mut(&mut self) -> &mut InstanceCreateFlags {
        &mut self.flags
    }
    ///Get a mutable reference to the `application_info` field.
    pub fn application_info_mut(&mut self) -> &mut Option<ApplicationInfo> {
        &mut self.application_info
    }
    ///Get a mutable reference to the `pp_enabled_layer_names` field.
    pub fn pp_enabled_layer_names_mut(&mut self) -> &mut SmallVec<[String; 8]> {
        &mut self.pp_enabled_layer_names
    }
    ///Get a mutable reference to the `pp_enabled_extension_names` field.
    pub fn pp_enabled_extension_names_mut(&mut self) -> &mut SmallVec<[String; 8]> {
        &mut self.pp_enabled_extension_names
    }
    ///Sets the `extensions` field.
    pub fn set_extensions(&mut self, extensions: SmallVec<[InstanceCreateInfoExtension; 1]>) -> &mut Self {
        self.extensions = extensions;
        self
    }
    ///Sets the `flags` field.
    pub fn set_flags(&mut self, flags: InstanceCreateFlags) -> &mut Self {
        self.flags = flags;
        self
    }
    ///Sets the `application_info` field.
    pub fn set_application_info(&mut self, application_info: Option<ApplicationInfo>) -> &mut Self {
        self.application_info = application_info;
        self
    }
    ///Sets the `pp_enabled_layer_names` field.
    pub fn set_pp_enabled_layer_names(&mut self, pp_enabled_layer_names: SmallVec<[String; 8]>) -> &mut Self {
        self.pp_enabled_layer_names = pp_enabled_layer_names;
        self
    }
    ///Sets the `pp_enabled_extension_names` field.
    pub fn set_pp_enabled_extension_names(&mut self, pp_enabled_extension_names: SmallVec<[String; 8]>) -> &mut Self {
        self.pp_enabled_extension_names = pp_enabled_extension_names;
        self
    }
    ///Sets the `extensions` field in a builder way.
    pub fn with_extensions(mut self, extensions: SmallVec<[InstanceCreateInfoExtension; 1]>) -> Self {
        self.extensions = extensions;
        self
    }
    ///Sets the `flags` field in a builder way.
    pub fn with_flags(mut self, flags: InstanceCreateFlags) -> Self {
        self.flags = flags;
        self
    }
    ///Sets the `application_info` field in a builder way.
    pub fn with_application_info(mut self, application_info: Option<ApplicationInfo>) -> Self {
        self.application_info = application_info;
        self
    }
    ///Sets the `pp_enabled_layer_names` field in a builder way.
    pub fn with_pp_enabled_layer_names(mut self, pp_enabled_layer_names: SmallVec<[String; 8]>) -> Self {
        self.pp_enabled_layer_names = pp_enabled_layer_names;
        self
    }
    ///Sets the `pp_enabled_extension_names` field in a builder way.
    pub fn with_pp_enabled_extension_names(mut self, pp_enabled_extension_names: SmallVec<[String; 8]>) -> Self {
        self.pp_enabled_extension_names = pp_enabled_extension_names;
        self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for InstanceCreateInfo {
    type LowLevel = crate::native::vulkan1_0::InstanceCreateInfo;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        let mut next = std::ptr::null();
        let mut extensions = self.extensions.iter();
        while let Some(ext) = extensions.next() {
            let ext = ext.into_low_level(context, bump);
            (*ext).next = next;
            next = ext;
        }
        let len_pp_enabled_layer_names = self.pp_enabled_layer_names.len() as u32;
        let pp_enabled_layer_names = bump
            .alloc_slice_fill_iter(
                self.pp_enabled_layer_names
                    .iter()
                    .map(|x| x.into_low_level(context, bump)),
            )
            .as_ptr()
            .cast();
        let len_pp_enabled_extension_names = self.pp_enabled_extension_names.len() as u32;
        let pp_enabled_extension_names = bump
            .alloc_slice_fill_iter(
                self.pp_enabled_extension_names
                    .iter()
                    .map(|x| x.into_low_level(context, bump)),
            )
            .as_ptr()
            .cast();
        crate::native::vulkan1_0::InstanceCreateInfo {
            s_type: StructureType::InstanceCreateInfo,
            p_next: next,
            flags: self.flags.into_low_level(context, bump),
            application_info: self
                .application_info
                .as_ref()
                .map(|v| bump.alloc(v.into_low_level(context, bump)) as *const _)
                .unwrap_or_else(std::ptr::null),
            enabled_layer_count: len_pp_enabled_layer_names,
            pp_enabled_layer_names: pp_enabled_layer_names,
            enabled_extension_count: len_pp_enabled_extension_names,
            pp_enabled_extension_names: pp_enabled_extension_names,
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for InstanceCreateInfo {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        let mut next = value.p_next;
        let mut extensions = SmallVec::new();
        while !next.is_null() {
            extensions.push(crate::conv::FromLowLevel::from_low_level(context, next));
            next = std::ptr::read(next).next;
        }
        let pp_enabled_layer_names_len = value.enabled_layer_count;
        let mut pp_enabled_layer_names = SmallVec::with_capacity(pp_enabled_layer_names_len as usize);
        for i in 0..pp_enabled_layer_names_len {
            pp_enabled_layer_names.push(crate::conv::FromLowLevel::from_low_level(
                context,
                value.pp_enabled_layer_names.add(i as usize).read(),
            ));
        }
        let pp_enabled_extension_names_len = value.enabled_extension_count;
        let mut pp_enabled_extension_names = SmallVec::with_capacity(pp_enabled_extension_names_len as usize);
        for i in 0..pp_enabled_extension_names_len {
            pp_enabled_extension_names.push(crate::conv::FromLowLevel::from_low_level(
                context,
                value.pp_enabled_extension_names.add(i as usize).read(),
            ));
        }
        Self {
            extensions: extensions,
            flags: crate::conv::FromLowLevel::from_low_level(context, value.flags),
            application_info: crate::conv::FromLowLevel::from_low_level(context, *value.application_info),
            pp_enabled_layer_names: pp_enabled_layer_names,
            pp_enabled_extension_names: pp_enabled_extension_names,
        }
    }
}
#[derive(Clone, PartialEq, Debug)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
///Extensions for [`InstanceCreateInfo`]
pub enum InstanceCreateInfoExtension {
    #[cfg(feature = "VK_EXT_debug_report")]
    ///Contains a type [`DebugReportCallbackCreateInfoEXT`] for extending [`InstanceCreateInfo`]
    DebugReportCallbackCreateInfoEXT(DebugReportCallbackCreateInfoEXT),
    #[cfg(feature = "VK_EXT_validation_flags")]
    ///Contains a type [`ValidationFlagsEXT`] for extending [`InstanceCreateInfo`]
    ValidationFlagsEXT(ValidationFlagsEXT),
    #[cfg(feature = "VK_EXT_validation_features")]
    ///Contains a type [`ValidationFeaturesEXT`] for extending [`InstanceCreateInfo`]
    ValidationFeaturesEXT(ValidationFeaturesEXT),
    #[cfg(feature = "VK_EXT_debug_utils")]
    ///Contains a type [`DebugUtilsMessengerCreateInfoEXT`] for extending [`InstanceCreateInfo`]
    DebugUtilsMessengerCreateInfoEXT(DebugUtilsMessengerCreateInfoEXT),
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for InstanceCreateInfoExtension {
    type LowLevel = *const crate::native::vulkan1_0::BaseInStructure;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        match self {
            #[cfg(feature = "VK_EXT_debug_report")]
            Self::DebugReportCallbackCreateInfoEXT(ext) => (bump.alloc(ext.into_low_level(context, bump))
                as *mut crate::native::extensions::ext_debug_report::DebugReportCallbackCreateInfoEXT)
                .cast(),
            #[cfg(feature = "VK_EXT_validation_flags")]
            Self::ValidationFlagsEXT(ext) => (bump.alloc(ext.into_low_level(context, bump))
                as *mut crate::native::extensions::ext_validation_flags::ValidationFlagsEXT)
                .cast(),
            #[cfg(feature = "VK_EXT_validation_features")]
            Self::ValidationFeaturesEXT(ext) => (bump.alloc(ext.into_low_level(context, bump))
                as *mut crate::native::extensions::ext_validation_features::ValidationFeaturesEXT)
                .cast(),
            #[cfg(feature = "VK_EXT_debug_utils")]
            Self::DebugUtilsMessengerCreateInfoEXT(ext) => (bump.alloc(ext.into_low_level(context, bump))
                as *mut crate::native::extensions::ext_debug_utils::DebugUtilsMessengerCreateInfoEXT)
                .cast(),
            other => unreachable!("unexpected variant {:?}", other),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for InstanceCreateInfoExtension {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        assert!(!value.is_null());
        match (*value).s_type {
            #[cfg(feature = "VK_EXT_debug_report")]
            crate::native::vulkan1_0::StructureType::DebugReportCallbackCreateInfoExt => {
                Self::DebugReportCallbackCreateInfoEXT(DebugReportCallbackCreateInfoEXT::from_low_level(
                    context,
                    std::ptr::read(
                        value.cast::<crate::native::extensions::ext_debug_report::DebugReportCallbackCreateInfoEXT>(),
                    ),
                ))
            },
            #[cfg(feature = "VK_EXT_validation_flags")]
            crate::native::vulkan1_0::StructureType::ValidationFlagsExt => {
                Self::ValidationFlagsEXT(ValidationFlagsEXT::from_low_level(
                    context,
                    std::ptr::read(value.cast::<crate::native::extensions::ext_validation_flags::ValidationFlagsEXT>()),
                ))
            },
            #[cfg(feature = "VK_EXT_validation_features")]
            crate::native::vulkan1_0::StructureType::ValidationFeaturesExt => {
                Self::ValidationFeaturesEXT(ValidationFeaturesEXT::from_low_level(
                    context,
                    std::ptr::read(
                        value.cast::<crate::native::extensions::ext_validation_features::ValidationFeaturesEXT>(),
                    ),
                ))
            },
            #[cfg(feature = "VK_EXT_debug_utils")]
            crate::native::vulkan1_0::StructureType::DebugUtilsMessengerCreateInfoExt => {
                Self::DebugUtilsMessengerCreateInfoEXT(DebugUtilsMessengerCreateInfoEXT::from_low_level(
                    context,
                    std::ptr::read(
                        value.cast::<crate::native::extensions::ext_debug_utils::DebugUtilsMessengerCreateInfoEXT>(),
                    ),
                ))
            },
            other => panic!(
                "Structure type {:?} is not a member of {}",
                other,
                stringify!(InstanceCreateInfo)
            ),
        }
    }
}
#[cfg(feature = "VK_EXT_debug_report")]
impl From<DebugReportCallbackCreateInfoEXT> for InstanceCreateInfoExtension {
    fn from(ext: DebugReportCallbackCreateInfoEXT) -> Self {
        Self::DebugReportCallbackCreateInfoEXT(ext)
    }
}
#[cfg(feature = "VK_EXT_debug_report")]
impl TryInto<DebugReportCallbackCreateInfoEXT> for InstanceCreateInfoExtension {
    type Error = InstanceCreateInfoExtension;
    fn try_into(self) -> Result<DebugReportCallbackCreateInfoEXT, Self::Error> {
        match self {
            Self::DebugReportCallbackCreateInfoEXT(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_EXT_validation_flags")]
impl From<ValidationFlagsEXT> for InstanceCreateInfoExtension {
    fn from(ext: ValidationFlagsEXT) -> Self {
        Self::ValidationFlagsEXT(ext)
    }
}
#[cfg(feature = "VK_EXT_validation_flags")]
impl TryInto<ValidationFlagsEXT> for InstanceCreateInfoExtension {
    type Error = InstanceCreateInfoExtension;
    fn try_into(self) -> Result<ValidationFlagsEXT, Self::Error> {
        match self {
            Self::ValidationFlagsEXT(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_EXT_validation_features")]
impl From<ValidationFeaturesEXT> for InstanceCreateInfoExtension {
    fn from(ext: ValidationFeaturesEXT) -> Self {
        Self::ValidationFeaturesEXT(ext)
    }
}
#[cfg(feature = "VK_EXT_validation_features")]
impl TryInto<ValidationFeaturesEXT> for InstanceCreateInfoExtension {
    type Error = InstanceCreateInfoExtension;
    fn try_into(self) -> Result<ValidationFeaturesEXT, Self::Error> {
        match self {
            Self::ValidationFeaturesEXT(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_EXT_debug_utils")]
impl From<DebugUtilsMessengerCreateInfoEXT> for InstanceCreateInfoExtension {
    fn from(ext: DebugUtilsMessengerCreateInfoEXT) -> Self {
        Self::DebugUtilsMessengerCreateInfoEXT(ext)
    }
}
#[cfg(feature = "VK_EXT_debug_utils")]
impl TryInto<DebugUtilsMessengerCreateInfoEXT> for InstanceCreateInfoExtension {
    type Error = InstanceCreateInfoExtension;
    fn try_into(self) -> Result<DebugUtilsMessengerCreateInfoEXT, Self::Error> {
        match self {
            Self::DebugUtilsMessengerCreateInfoEXT(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
impl QueueFamilyProperties {
    ///Get a reference to the `queue_flags` field.
    pub fn queue_flags(&self) -> QueueFlags {
        self.queue_flags
    }
    ///Get a reference to the `queue_count` field.
    pub fn queue_count(&self) -> u32 {
        self.queue_count
    }
    ///Get a reference to the `timestamp_valid_bits` field.
    pub fn timestamp_valid_bits(&self) -> u32 {
        self.timestamp_valid_bits
    }
    ///Get a reference to the `min_image_transfer_granularity` field.
    pub fn min_image_transfer_granularity(&self) -> Extent3D {
        self.min_image_transfer_granularity
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for QueueFamilyProperties {
    type LowLevel = crate::native::vulkan1_0::QueueFamilyProperties;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        crate::native::vulkan1_0::QueueFamilyProperties {
            queue_flags: self.queue_flags.into_low_level(context, bump),
            queue_count: self.queue_count.into_low_level(context, bump),
            timestamp_valid_bits: self.timestamp_valid_bits.into_low_level(context, bump),
            min_image_transfer_granularity: self.min_image_transfer_granularity.into_low_level(context, bump),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for QueueFamilyProperties {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        Self {
            queue_flags: crate::conv::FromLowLevel::from_low_level(context, value.queue_flags),
            queue_count: crate::conv::FromLowLevel::from_low_level(context, value.queue_count),
            timestamp_valid_bits: crate::conv::FromLowLevel::from_low_level(context, value.timestamp_valid_bits),
            min_image_transfer_granularity: crate::conv::FromLowLevel::from_low_level(
                context,
                value.min_image_transfer_granularity,
            ),
        }
    }
}
impl PhysicalDeviceMemoryProperties {
    ///Get a reference to the `memory_type_count` field.
    pub fn memory_type_count(&self) -> u32 {
        self.memory_type_count
    }
    ///Get a reference to the `memory_types` field.
    pub fn memory_types(&self) -> [MemoryType; MAX_MEMORY_TYPES as usize] {
        self.memory_types
    }
    ///Get a reference to the `memory_heap_count` field.
    pub fn memory_heap_count(&self) -> u32 {
        self.memory_heap_count
    }
    ///Get a reference to the `memory_heaps` field.
    pub fn memory_heaps(&self) -> &[MemoryHeap; MAX_MEMORY_HEAPS as usize] {
        &self.memory_heaps
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for PhysicalDeviceMemoryProperties {
    type LowLevel = crate::native::vulkan1_0::PhysicalDeviceMemoryProperties;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        crate::native::vulkan1_0::PhysicalDeviceMemoryProperties {
            memory_type_count: self.memory_type_count.into_low_level(context, bump),
            memory_types: self.memory_types.into_low_level(context, bump),
            memory_heap_count: self.memory_heap_count.into_low_level(context, bump),
            memory_heaps: self.memory_heaps.into_low_level(context, bump),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for PhysicalDeviceMemoryProperties {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        Self {
            memory_type_count: crate::conv::FromLowLevel::from_low_level(context, value.memory_type_count),
            memory_types: crate::conv::FromLowLevel::from_low_level(context, value.memory_types),
            memory_heap_count: crate::conv::FromLowLevel::from_low_level(context, value.memory_heap_count),
            memory_heaps: crate::conv::FromLowLevel::from_low_level(context, value.memory_heaps),
        }
    }
}
#[doc(alias = "VkMemoryAllocateInfo")]
#[derive(Clone, PartialEq, Debug, Default)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct MemoryAllocateInfo {
    #[doc(alias = "pNext")]
    pub extensions: SmallVec<[MemoryAllocateInfoExtension; 1]>,
    #[doc(alias = "allocationSize")]
    pub allocation_size: DeviceSize,
    #[doc(alias = "memoryTypeIndex")]
    pub memory_type_index: u32,
}
impl MemoryAllocateInfo {
    ///Adds an extension to the struct
    pub fn with_extension(mut self, ext: impl Into<MemoryAllocateInfoExtension>) -> Self {
        self.extensions.push(ext.into());
        self
    }
    ///Get a reference to the `extensions` field.
    pub fn extensions(&self) -> &SmallVec<[MemoryAllocateInfoExtension; 1]> {
        &self.extensions
    }
    ///Get a reference to the `allocation_size` field.
    pub fn allocation_size(&self) -> &DeviceSize {
        &self.allocation_size
    }
    ///Get a reference to the `memory_type_index` field.
    pub fn memory_type_index(&self) -> u32 {
        self.memory_type_index
    }
    ///Get a mutable reference to the `extensions` field.
    pub fn extensions_mut(&mut self) -> &mut SmallVec<[MemoryAllocateInfoExtension; 1]> {
        &mut self.extensions
    }
    ///Get a mutable reference to the `allocation_size` field.
    pub fn allocation_size_mut(&mut self) -> &mut DeviceSize {
        &mut self.allocation_size
    }
    ///Get a mutable reference to the `memory_type_index` field.
    pub fn memory_type_index_mut(&mut self) -> &mut u32 {
        &mut self.memory_type_index
    }
    ///Sets the `extensions` field.
    pub fn set_extensions(&mut self, extensions: SmallVec<[MemoryAllocateInfoExtension; 1]>) -> &mut Self {
        self.extensions = extensions;
        self
    }
    ///Sets the `allocation_size` field.
    pub fn set_allocation_size(&mut self, allocation_size: DeviceSize) -> &mut Self {
        self.allocation_size = allocation_size;
        self
    }
    ///Sets the `memory_type_index` field.
    pub fn set_memory_type_index(&mut self, memory_type_index: u32) -> &mut Self {
        self.memory_type_index = memory_type_index;
        self
    }
    ///Sets the `extensions` field in a builder way.
    pub fn with_extensions(mut self, extensions: SmallVec<[MemoryAllocateInfoExtension; 1]>) -> Self {
        self.extensions = extensions;
        self
    }
    ///Sets the `allocation_size` field in a builder way.
    pub fn with_allocation_size(mut self, allocation_size: DeviceSize) -> Self {
        self.allocation_size = allocation_size;
        self
    }
    ///Sets the `memory_type_index` field in a builder way.
    pub fn with_memory_type_index(mut self, memory_type_index: u32) -> Self {
        self.memory_type_index = memory_type_index;
        self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for MemoryAllocateInfo {
    type LowLevel = crate::native::vulkan1_0::MemoryAllocateInfo;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        let mut next = std::ptr::null();
        let mut extensions = self.extensions.iter();
        while let Some(ext) = extensions.next() {
            let ext = ext.into_low_level(context, bump);
            (*ext).next = next;
            next = ext;
        }
        crate::native::vulkan1_0::MemoryAllocateInfo {
            s_type: StructureType::MemoryAllocateInfo,
            p_next: next,
            allocation_size: self.allocation_size.into_low_level(context, bump),
            memory_type_index: self.memory_type_index.into_low_level(context, bump),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for MemoryAllocateInfo {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        let mut next = value.p_next;
        let mut extensions = SmallVec::new();
        while !next.is_null() {
            extensions.push(crate::conv::FromLowLevel::from_low_level(context, next));
            next = std::ptr::read(next).next;
        }
        Self {
            extensions: extensions,
            allocation_size: crate::conv::FromLowLevel::from_low_level(context, value.allocation_size),
            memory_type_index: crate::conv::FromLowLevel::from_low_level(context, value.memory_type_index),
        }
    }
}
#[derive(Clone, PartialEq, Debug)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
///Extensions for [`MemoryAllocateInfo`]
pub enum MemoryAllocateInfoExtension {
    #[cfg(feature = "VK_NV_dedicated_allocation")]
    ///Contains a type [`DedicatedAllocationMemoryAllocateInfoNV`] for extending
    /// [`MemoryAllocateInfo`]
    DedicatedAllocationMemoryAllocateInfoNV(DedicatedAllocationMemoryAllocateInfoNV),
    #[cfg(feature = "VK_NV_external_memory")]
    ///Contains a type [`ExportMemoryAllocateInfoNV`] for extending [`MemoryAllocateInfo`]
    ExportMemoryAllocateInfoNV(ExportMemoryAllocateInfoNV),
    #[cfg(feature = "VK_NV_external_memory_win32")]
    ///Contains a type [`ImportMemoryWin32HandleInfoNV`] for extending [`MemoryAllocateInfo`]
    ImportMemoryWin32HandleInfoNV(ImportMemoryWin32HandleInfoNV),
    #[cfg(feature = "VK_NV_external_memory_win32")]
    ///Contains a type [`ExportMemoryWin32HandleInfoNV`] for extending [`MemoryAllocateInfo`]
    ExportMemoryWin32HandleInfoNV(ExportMemoryWin32HandleInfoNV),
    ///Contains a type [`ExportMemoryAllocateInfo`] for extending [`MemoryAllocateInfo`]
    ExportMemoryAllocateInfo(ExportMemoryAllocateInfo),
    #[cfg(feature = "VK_KHR_external_memory_win32")]
    ///Contains a type [`ImportMemoryWin32HandleInfoKHR`] for extending [`MemoryAllocateInfo`]
    ImportMemoryWin32HandleInfoKHR(ImportMemoryWin32HandleInfoKHR),
    #[cfg(feature = "VK_KHR_external_memory_win32")]
    ///Contains a type [`ExportMemoryWin32HandleInfoKHR`] for extending [`MemoryAllocateInfo`]
    ExportMemoryWin32HandleInfoKHR(ExportMemoryWin32HandleInfoKHR),
    #[cfg(feature = "VK_FUCHSIA_external_memory")]
    ///Contains a type [`ImportMemoryZirconHandleInfoFUCHSIA`] for extending [`MemoryAllocateInfo`]
    ImportMemoryZirconHandleInfoFUCHSIA(ImportMemoryZirconHandleInfoFUCHSIA),
    #[cfg(feature = "VK_KHR_external_memory_fd")]
    ///Contains a type [`ImportMemoryFdInfoKHR`] for extending [`MemoryAllocateInfo`]
    ImportMemoryFdInfoKHR(ImportMemoryFdInfoKHR),
    ///Contains a type [`MemoryAllocateFlagsInfo`] for extending [`MemoryAllocateInfo`]
    MemoryAllocateFlagsInfo(MemoryAllocateFlagsInfo),
    ///Contains a type [`MemoryDedicatedAllocateInfo`] for extending [`MemoryAllocateInfo`]
    MemoryDedicatedAllocateInfo(MemoryDedicatedAllocateInfo),
    #[cfg(feature = "VK_EXT_external_memory_host")]
    ///Contains a type [`ImportMemoryHostPointerInfoEXT`] for extending [`MemoryAllocateInfo`]
    ImportMemoryHostPointerInfoEXT(ImportMemoryHostPointerInfoEXT),
    #[cfg(feature = "VK_ANDROID_external_memory_android_hardware_buffer")]
    ///Contains a type [`ImportAndroidHardwareBufferInfoANDROID`] for extending
    /// [`MemoryAllocateInfo`]
    ImportAndroidHardwareBufferInfoANDROID(ImportAndroidHardwareBufferInfoANDROID),
    #[cfg(feature = "VK_EXT_memory_priority")]
    ///Contains a type [`MemoryPriorityAllocateInfoEXT`] for extending [`MemoryAllocateInfo`]
    MemoryPriorityAllocateInfoEXT(MemoryPriorityAllocateInfoEXT),
    #[cfg(feature = "VULKAN_1_2")]
    ///Contains a type [`MemoryOpaqueCaptureAddressAllocateInfo`] for extending
    /// [`MemoryAllocateInfo`]
    MemoryOpaqueCaptureAddressAllocateInfo(MemoryOpaqueCaptureAddressAllocateInfo),
    #[cfg(feature = "VK_FUCHSIA_buffer_collection")]
    ///Contains a type [`ImportMemoryBufferCollectionFUCHSIA`] for extending [`MemoryAllocateInfo`]
    ImportMemoryBufferCollectionFUCHSIA(ImportMemoryBufferCollectionFUCHSIA),
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for MemoryAllocateInfoExtension {
    type LowLevel = *const crate::native::vulkan1_0::BaseInStructure;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        match self { # [cfg (feature = "VK_NV_dedicated_allocation")] Self :: DedicatedAllocationMemoryAllocateInfoNV (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: nv_dedicated_allocation :: DedicatedAllocationMemoryAllocateInfoNV) . cast () , # [cfg (feature = "VK_NV_external_memory")] Self :: ExportMemoryAllocateInfoNV (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: nv_external_memory :: ExportMemoryAllocateInfoNV) . cast () , # [cfg (feature = "VK_NV_external_memory_win32")] Self :: ImportMemoryWin32HandleInfoNV (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: nv_external_memory_win32 :: ImportMemoryWin32HandleInfoNV) . cast () , # [cfg (feature = "VK_NV_external_memory_win32")] Self :: ExportMemoryWin32HandleInfoNV (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: nv_external_memory_win32 :: ExportMemoryWin32HandleInfoNV) . cast () , Self :: ExportMemoryAllocateInfo (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: vulkan1_1 :: ExportMemoryAllocateInfo) . cast () , # [cfg (feature = "VK_KHR_external_memory_win32")] Self :: ImportMemoryWin32HandleInfoKHR (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: khr_external_memory_win32 :: ImportMemoryWin32HandleInfoKHR) . cast () , # [cfg (feature = "VK_KHR_external_memory_win32")] Self :: ExportMemoryWin32HandleInfoKHR (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: khr_external_memory_win32 :: ExportMemoryWin32HandleInfoKHR) . cast () , # [cfg (feature = "VK_FUCHSIA_external_memory")] Self :: ImportMemoryZirconHandleInfoFUCHSIA (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: fuchsia_external_memory :: ImportMemoryZirconHandleInfoFUCHSIA) . cast () , # [cfg (feature = "VK_KHR_external_memory_fd")] Self :: ImportMemoryFdInfoKHR (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: khr_external_memory_fd :: ImportMemoryFdInfoKHR) . cast () , Self :: MemoryAllocateFlagsInfo (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: vulkan1_1 :: MemoryAllocateFlagsInfo) . cast () , Self :: MemoryDedicatedAllocateInfo (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: vulkan1_1 :: MemoryDedicatedAllocateInfo) . cast () , # [cfg (feature = "VK_EXT_external_memory_host")] Self :: ImportMemoryHostPointerInfoEXT (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: ext_external_memory_host :: ImportMemoryHostPointerInfoEXT) . cast () , # [cfg (feature = "VK_ANDROID_external_memory_android_hardware_buffer")] Self :: ImportAndroidHardwareBufferInfoANDROID (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: android_external_memory_android_hardware_buffer :: ImportAndroidHardwareBufferInfoANDROID) . cast () , # [cfg (feature = "VK_EXT_memory_priority")] Self :: MemoryPriorityAllocateInfoEXT (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: ext_memory_priority :: MemoryPriorityAllocateInfoEXT) . cast () , # [cfg (feature = "VULKAN_1_2")] Self :: MemoryOpaqueCaptureAddressAllocateInfo (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: vulkan1_2 :: MemoryOpaqueCaptureAddressAllocateInfo) . cast () , # [cfg (feature = "VK_FUCHSIA_buffer_collection")] Self :: ImportMemoryBufferCollectionFUCHSIA (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: fuchsia_buffer_collection :: ImportMemoryBufferCollectionFUCHSIA) . cast () , other => unreachable ! ("unexpected variant {:?}" , other) }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for MemoryAllocateInfoExtension {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        assert!(!value.is_null());
        match (* value) . s_type { # [cfg (feature = "VK_NV_dedicated_allocation")] crate :: native :: vulkan1_0 :: StructureType :: DedicatedAllocationMemoryAllocateInfoNv => Self :: DedicatedAllocationMemoryAllocateInfoNV (DedicatedAllocationMemoryAllocateInfoNV :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: nv_dedicated_allocation :: DedicatedAllocationMemoryAllocateInfoNV > ()))) , # [cfg (feature = "VK_NV_external_memory")] crate :: native :: vulkan1_0 :: StructureType :: ExportMemoryAllocateInfoNv => Self :: ExportMemoryAllocateInfoNV (ExportMemoryAllocateInfoNV :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: nv_external_memory :: ExportMemoryAllocateInfoNV > ()))) , # [cfg (feature = "VK_NV_external_memory_win32")] crate :: native :: vulkan1_0 :: StructureType :: ImportMemoryWin32HandleInfoNv => Self :: ImportMemoryWin32HandleInfoNV (ImportMemoryWin32HandleInfoNV :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: nv_external_memory_win32 :: ImportMemoryWin32HandleInfoNV > ()))) , # [cfg (feature = "VK_NV_external_memory_win32")] crate :: native :: vulkan1_0 :: StructureType :: ExportMemoryWin32HandleInfoNv => Self :: ExportMemoryWin32HandleInfoNV (ExportMemoryWin32HandleInfoNV :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: nv_external_memory_win32 :: ExportMemoryWin32HandleInfoNV > ()))) , crate :: native :: vulkan1_0 :: StructureType :: ExportMemoryAllocateInfo => Self :: ExportMemoryAllocateInfo (ExportMemoryAllocateInfo :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: vulkan1_1 :: ExportMemoryAllocateInfo > ()))) , # [cfg (feature = "VK_KHR_external_memory_win32")] crate :: native :: vulkan1_0 :: StructureType :: ImportMemoryWin32HandleInfoKhr => Self :: ImportMemoryWin32HandleInfoKHR (ImportMemoryWin32HandleInfoKHR :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: khr_external_memory_win32 :: ImportMemoryWin32HandleInfoKHR > ()))) , # [cfg (feature = "VK_KHR_external_memory_win32")] crate :: native :: vulkan1_0 :: StructureType :: ExportMemoryWin32HandleInfoKhr => Self :: ExportMemoryWin32HandleInfoKHR (ExportMemoryWin32HandleInfoKHR :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: khr_external_memory_win32 :: ExportMemoryWin32HandleInfoKHR > ()))) , # [cfg (feature = "VK_FUCHSIA_external_memory")] crate :: native :: vulkan1_0 :: StructureType :: ImportMemoryZirconHandleInfoFuchsia => Self :: ImportMemoryZirconHandleInfoFUCHSIA (ImportMemoryZirconHandleInfoFUCHSIA :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: fuchsia_external_memory :: ImportMemoryZirconHandleInfoFUCHSIA > ()))) , # [cfg (feature = "VK_KHR_external_memory_fd")] crate :: native :: vulkan1_0 :: StructureType :: ImportMemoryFdInfoKhr => Self :: ImportMemoryFdInfoKHR (ImportMemoryFdInfoKHR :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: khr_external_memory_fd :: ImportMemoryFdInfoKHR > ()))) , crate :: native :: vulkan1_0 :: StructureType :: MemoryAllocateFlagsInfo => Self :: MemoryAllocateFlagsInfo (MemoryAllocateFlagsInfo :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: vulkan1_1 :: MemoryAllocateFlagsInfo > ()))) , crate :: native :: vulkan1_0 :: StructureType :: MemoryDedicatedAllocateInfo => Self :: MemoryDedicatedAllocateInfo (MemoryDedicatedAllocateInfo :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: vulkan1_1 :: MemoryDedicatedAllocateInfo > ()))) , # [cfg (feature = "VK_EXT_external_memory_host")] crate :: native :: vulkan1_0 :: StructureType :: ImportMemoryHostPointerInfoExt => Self :: ImportMemoryHostPointerInfoEXT (ImportMemoryHostPointerInfoEXT :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: ext_external_memory_host :: ImportMemoryHostPointerInfoEXT > ()))) , # [cfg (feature = "VK_ANDROID_external_memory_android_hardware_buffer")] crate :: native :: vulkan1_0 :: StructureType :: ImportAndroidHardwareBufferInfoAndroid => Self :: ImportAndroidHardwareBufferInfoANDROID (ImportAndroidHardwareBufferInfoANDROID :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: android_external_memory_android_hardware_buffer :: ImportAndroidHardwareBufferInfoANDROID > ()))) , # [cfg (feature = "VK_EXT_memory_priority")] crate :: native :: vulkan1_0 :: StructureType :: MemoryPriorityAllocateInfoExt => Self :: MemoryPriorityAllocateInfoEXT (MemoryPriorityAllocateInfoEXT :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: ext_memory_priority :: MemoryPriorityAllocateInfoEXT > ()))) , # [cfg (feature = "VULKAN_1_2")] crate :: native :: vulkan1_0 :: StructureType :: MemoryOpaqueCaptureAddressAllocateInfo => Self :: MemoryOpaqueCaptureAddressAllocateInfo (MemoryOpaqueCaptureAddressAllocateInfo :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: vulkan1_2 :: MemoryOpaqueCaptureAddressAllocateInfo > ()))) , # [cfg (feature = "VK_FUCHSIA_buffer_collection")] crate :: native :: vulkan1_0 :: StructureType :: ImportMemoryBufferCollectionFuchsia => Self :: ImportMemoryBufferCollectionFUCHSIA (ImportMemoryBufferCollectionFUCHSIA :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: fuchsia_buffer_collection :: ImportMemoryBufferCollectionFUCHSIA > ()))) , other => panic ! ("Structure type {:?} is not a member of {}" , other , stringify ! (MemoryAllocateInfo)) }
    }
}
#[cfg(feature = "VK_NV_dedicated_allocation")]
impl From<DedicatedAllocationMemoryAllocateInfoNV> for MemoryAllocateInfoExtension {
    fn from(ext: DedicatedAllocationMemoryAllocateInfoNV) -> Self {
        Self::DedicatedAllocationMemoryAllocateInfoNV(ext)
    }
}
#[cfg(feature = "VK_NV_dedicated_allocation")]
impl TryInto<DedicatedAllocationMemoryAllocateInfoNV> for MemoryAllocateInfoExtension {
    type Error = MemoryAllocateInfoExtension;
    fn try_into(self) -> Result<DedicatedAllocationMemoryAllocateInfoNV, Self::Error> {
        match self {
            Self::DedicatedAllocationMemoryAllocateInfoNV(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_NV_external_memory")]
impl From<ExportMemoryAllocateInfoNV> for MemoryAllocateInfoExtension {
    fn from(ext: ExportMemoryAllocateInfoNV) -> Self {
        Self::ExportMemoryAllocateInfoNV(ext)
    }
}
#[cfg(feature = "VK_NV_external_memory")]
impl TryInto<ExportMemoryAllocateInfoNV> for MemoryAllocateInfoExtension {
    type Error = MemoryAllocateInfoExtension;
    fn try_into(self) -> Result<ExportMemoryAllocateInfoNV, Self::Error> {
        match self {
            Self::ExportMemoryAllocateInfoNV(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_NV_external_memory_win32")]
impl From<ImportMemoryWin32HandleInfoNV> for MemoryAllocateInfoExtension {
    fn from(ext: ImportMemoryWin32HandleInfoNV) -> Self {
        Self::ImportMemoryWin32HandleInfoNV(ext)
    }
}
#[cfg(feature = "VK_NV_external_memory_win32")]
impl TryInto<ImportMemoryWin32HandleInfoNV> for MemoryAllocateInfoExtension {
    type Error = MemoryAllocateInfoExtension;
    fn try_into(self) -> Result<ImportMemoryWin32HandleInfoNV, Self::Error> {
        match self {
            Self::ImportMemoryWin32HandleInfoNV(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_NV_external_memory_win32")]
impl From<ExportMemoryWin32HandleInfoNV> for MemoryAllocateInfoExtension {
    fn from(ext: ExportMemoryWin32HandleInfoNV) -> Self {
        Self::ExportMemoryWin32HandleInfoNV(ext)
    }
}
#[cfg(feature = "VK_NV_external_memory_win32")]
impl TryInto<ExportMemoryWin32HandleInfoNV> for MemoryAllocateInfoExtension {
    type Error = MemoryAllocateInfoExtension;
    fn try_into(self) -> Result<ExportMemoryWin32HandleInfoNV, Self::Error> {
        match self {
            Self::ExportMemoryWin32HandleInfoNV(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
impl From<ExportMemoryAllocateInfo> for MemoryAllocateInfoExtension {
    fn from(ext: ExportMemoryAllocateInfo) -> Self {
        Self::ExportMemoryAllocateInfo(ext)
    }
}
impl TryInto<ExportMemoryAllocateInfo> for MemoryAllocateInfoExtension {
    type Error = MemoryAllocateInfoExtension;
    fn try_into(self) -> Result<ExportMemoryAllocateInfo, Self::Error> {
        match self {
            Self::ExportMemoryAllocateInfo(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_KHR_external_memory_win32")]
impl From<ImportMemoryWin32HandleInfoKHR> for MemoryAllocateInfoExtension {
    fn from(ext: ImportMemoryWin32HandleInfoKHR) -> Self {
        Self::ImportMemoryWin32HandleInfoKHR(ext)
    }
}
#[cfg(feature = "VK_KHR_external_memory_win32")]
impl TryInto<ImportMemoryWin32HandleInfoKHR> for MemoryAllocateInfoExtension {
    type Error = MemoryAllocateInfoExtension;
    fn try_into(self) -> Result<ImportMemoryWin32HandleInfoKHR, Self::Error> {
        match self {
            Self::ImportMemoryWin32HandleInfoKHR(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_KHR_external_memory_win32")]
impl From<ExportMemoryWin32HandleInfoKHR> for MemoryAllocateInfoExtension {
    fn from(ext: ExportMemoryWin32HandleInfoKHR) -> Self {
        Self::ExportMemoryWin32HandleInfoKHR(ext)
    }
}
#[cfg(feature = "VK_KHR_external_memory_win32")]
impl TryInto<ExportMemoryWin32HandleInfoKHR> for MemoryAllocateInfoExtension {
    type Error = MemoryAllocateInfoExtension;
    fn try_into(self) -> Result<ExportMemoryWin32HandleInfoKHR, Self::Error> {
        match self {
            Self::ExportMemoryWin32HandleInfoKHR(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_FUCHSIA_external_memory")]
impl From<ImportMemoryZirconHandleInfoFUCHSIA> for MemoryAllocateInfoExtension {
    fn from(ext: ImportMemoryZirconHandleInfoFUCHSIA) -> Self {
        Self::ImportMemoryZirconHandleInfoFUCHSIA(ext)
    }
}
#[cfg(feature = "VK_FUCHSIA_external_memory")]
impl TryInto<ImportMemoryZirconHandleInfoFUCHSIA> for MemoryAllocateInfoExtension {
    type Error = MemoryAllocateInfoExtension;
    fn try_into(self) -> Result<ImportMemoryZirconHandleInfoFUCHSIA, Self::Error> {
        match self {
            Self::ImportMemoryZirconHandleInfoFUCHSIA(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_KHR_external_memory_fd")]
impl From<ImportMemoryFdInfoKHR> for MemoryAllocateInfoExtension {
    fn from(ext: ImportMemoryFdInfoKHR) -> Self {
        Self::ImportMemoryFdInfoKHR(ext)
    }
}
#[cfg(feature = "VK_KHR_external_memory_fd")]
impl TryInto<ImportMemoryFdInfoKHR> for MemoryAllocateInfoExtension {
    type Error = MemoryAllocateInfoExtension;
    fn try_into(self) -> Result<ImportMemoryFdInfoKHR, Self::Error> {
        match self {
            Self::ImportMemoryFdInfoKHR(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
impl From<MemoryAllocateFlagsInfo> for MemoryAllocateInfoExtension {
    fn from(ext: MemoryAllocateFlagsInfo) -> Self {
        Self::MemoryAllocateFlagsInfo(ext)
    }
}
impl TryInto<MemoryAllocateFlagsInfo> for MemoryAllocateInfoExtension {
    type Error = MemoryAllocateInfoExtension;
    fn try_into(self) -> Result<MemoryAllocateFlagsInfo, Self::Error> {
        match self {
            Self::MemoryAllocateFlagsInfo(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
impl From<MemoryDedicatedAllocateInfo> for MemoryAllocateInfoExtension {
    fn from(ext: MemoryDedicatedAllocateInfo) -> Self {
        Self::MemoryDedicatedAllocateInfo(ext)
    }
}
impl TryInto<MemoryDedicatedAllocateInfo> for MemoryAllocateInfoExtension {
    type Error = MemoryAllocateInfoExtension;
    fn try_into(self) -> Result<MemoryDedicatedAllocateInfo, Self::Error> {
        match self {
            Self::MemoryDedicatedAllocateInfo(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_EXT_external_memory_host")]
impl From<ImportMemoryHostPointerInfoEXT> for MemoryAllocateInfoExtension {
    fn from(ext: ImportMemoryHostPointerInfoEXT) -> Self {
        Self::ImportMemoryHostPointerInfoEXT(ext)
    }
}
#[cfg(feature = "VK_EXT_external_memory_host")]
impl TryInto<ImportMemoryHostPointerInfoEXT> for MemoryAllocateInfoExtension {
    type Error = MemoryAllocateInfoExtension;
    fn try_into(self) -> Result<ImportMemoryHostPointerInfoEXT, Self::Error> {
        match self {
            Self::ImportMemoryHostPointerInfoEXT(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_ANDROID_external_memory_android_hardware_buffer")]
impl From<ImportAndroidHardwareBufferInfoANDROID> for MemoryAllocateInfoExtension {
    fn from(ext: ImportAndroidHardwareBufferInfoANDROID) -> Self {
        Self::ImportAndroidHardwareBufferInfoANDROID(ext)
    }
}
#[cfg(feature = "VK_ANDROID_external_memory_android_hardware_buffer")]
impl TryInto<ImportAndroidHardwareBufferInfoANDROID> for MemoryAllocateInfoExtension {
    type Error = MemoryAllocateInfoExtension;
    fn try_into(self) -> Result<ImportAndroidHardwareBufferInfoANDROID, Self::Error> {
        match self {
            Self::ImportAndroidHardwareBufferInfoANDROID(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_EXT_memory_priority")]
impl From<MemoryPriorityAllocateInfoEXT> for MemoryAllocateInfoExtension {
    fn from(ext: MemoryPriorityAllocateInfoEXT) -> Self {
        Self::MemoryPriorityAllocateInfoEXT(ext)
    }
}
#[cfg(feature = "VK_EXT_memory_priority")]
impl TryInto<MemoryPriorityAllocateInfoEXT> for MemoryAllocateInfoExtension {
    type Error = MemoryAllocateInfoExtension;
    fn try_into(self) -> Result<MemoryPriorityAllocateInfoEXT, Self::Error> {
        match self {
            Self::MemoryPriorityAllocateInfoEXT(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VULKAN_1_2")]
impl From<MemoryOpaqueCaptureAddressAllocateInfo> for MemoryAllocateInfoExtension {
    fn from(ext: MemoryOpaqueCaptureAddressAllocateInfo) -> Self {
        Self::MemoryOpaqueCaptureAddressAllocateInfo(ext)
    }
}
#[cfg(feature = "VULKAN_1_2")]
impl TryInto<MemoryOpaqueCaptureAddressAllocateInfo> for MemoryAllocateInfoExtension {
    type Error = MemoryAllocateInfoExtension;
    fn try_into(self) -> Result<MemoryOpaqueCaptureAddressAllocateInfo, Self::Error> {
        match self {
            Self::MemoryOpaqueCaptureAddressAllocateInfo(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_FUCHSIA_buffer_collection")]
impl From<ImportMemoryBufferCollectionFUCHSIA> for MemoryAllocateInfoExtension {
    fn from(ext: ImportMemoryBufferCollectionFUCHSIA) -> Self {
        Self::ImportMemoryBufferCollectionFUCHSIA(ext)
    }
}
#[cfg(feature = "VK_FUCHSIA_buffer_collection")]
impl TryInto<ImportMemoryBufferCollectionFUCHSIA> for MemoryAllocateInfoExtension {
    type Error = MemoryAllocateInfoExtension;
    fn try_into(self) -> Result<ImportMemoryBufferCollectionFUCHSIA, Self::Error> {
        match self {
            Self::ImportMemoryBufferCollectionFUCHSIA(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
impl MemoryRequirements {
    ///Get a reference to the `size` field.
    pub fn size(&self) -> &DeviceSize {
        &self.size
    }
    ///Get a reference to the `alignment` field.
    pub fn alignment(&self) -> &DeviceSize {
        &self.alignment
    }
    ///Get a reference to the `memory_type_bits` field.
    pub fn memory_type_bits(&self) -> u32 {
        self.memory_type_bits
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for MemoryRequirements {
    type LowLevel = crate::native::vulkan1_0::MemoryRequirements;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        crate::native::vulkan1_0::MemoryRequirements {
            size: self.size.into_low_level(context, bump),
            alignment: self.alignment.into_low_level(context, bump),
            memory_type_bits: self.memory_type_bits.into_low_level(context, bump),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for MemoryRequirements {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        Self {
            size: crate::conv::FromLowLevel::from_low_level(context, value.size),
            alignment: crate::conv::FromLowLevel::from_low_level(context, value.alignment),
            memory_type_bits: crate::conv::FromLowLevel::from_low_level(context, value.memory_type_bits),
        }
    }
}
impl SparseImageFormatProperties {
    ///Get a reference to the `aspect_mask` field.
    pub fn aspect_mask(&self) -> ImageAspectFlags {
        self.aspect_mask
    }
    ///Get a reference to the `image_granularity` field.
    pub fn image_granularity(&self) -> Extent3D {
        self.image_granularity
    }
    ///Get a reference to the `flags` field.
    pub fn flags(&self) -> SparseImageFormatFlags {
        self.flags
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for SparseImageFormatProperties {
    type LowLevel = crate::native::vulkan1_0::SparseImageFormatProperties;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        crate::native::vulkan1_0::SparseImageFormatProperties {
            aspect_mask: self.aspect_mask.into_low_level(context, bump),
            image_granularity: self.image_granularity.into_low_level(context, bump),
            flags: self.flags.into_low_level(context, bump),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for SparseImageFormatProperties {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        Self {
            aspect_mask: crate::conv::FromLowLevel::from_low_level(context, value.aspect_mask),
            image_granularity: crate::conv::FromLowLevel::from_low_level(context, value.image_granularity),
            flags: crate::conv::FromLowLevel::from_low_level(context, value.flags),
        }
    }
}
impl SparseImageMemoryRequirements {
    ///Get a reference to the `format_properties` field.
    pub fn format_properties(&self) -> SparseImageFormatProperties {
        self.format_properties
    }
    ///Get a reference to the `image_mip_tail_first_lod` field.
    pub fn image_mip_tail_first_lod(&self) -> u32 {
        self.image_mip_tail_first_lod
    }
    ///Get a reference to the `image_mip_tail_size` field.
    pub fn image_mip_tail_size(&self) -> &DeviceSize {
        &self.image_mip_tail_size
    }
    ///Get a reference to the `image_mip_tail_offset` field.
    pub fn image_mip_tail_offset(&self) -> &DeviceSize {
        &self.image_mip_tail_offset
    }
    ///Get a reference to the `image_mip_tail_stride` field.
    pub fn image_mip_tail_stride(&self) -> &DeviceSize {
        &self.image_mip_tail_stride
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for SparseImageMemoryRequirements {
    type LowLevel = crate::native::vulkan1_0::SparseImageMemoryRequirements;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        crate::native::vulkan1_0::SparseImageMemoryRequirements {
            format_properties: self.format_properties.into_low_level(context, bump),
            image_mip_tail_first_lod: self.image_mip_tail_first_lod.into_low_level(context, bump),
            image_mip_tail_size: self.image_mip_tail_size.into_low_level(context, bump),
            image_mip_tail_offset: self.image_mip_tail_offset.into_low_level(context, bump),
            image_mip_tail_stride: self.image_mip_tail_stride.into_low_level(context, bump),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for SparseImageMemoryRequirements {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        Self {
            format_properties: crate::conv::FromLowLevel::from_low_level(context, value.format_properties),
            image_mip_tail_first_lod: crate::conv::FromLowLevel::from_low_level(
                context,
                value.image_mip_tail_first_lod,
            ),
            image_mip_tail_size: crate::conv::FromLowLevel::from_low_level(context, value.image_mip_tail_size),
            image_mip_tail_offset: crate::conv::FromLowLevel::from_low_level(context, value.image_mip_tail_offset),
            image_mip_tail_stride: crate::conv::FromLowLevel::from_low_level(context, value.image_mip_tail_stride),
        }
    }
}
impl MemoryType {
    ///Get a reference to the `property_flags` field.
    pub fn property_flags(&self) -> MemoryPropertyFlags {
        self.property_flags
    }
    ///Get a reference to the `heap_index` field.
    pub fn heap_index(&self) -> u32 {
        self.heap_index
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for MemoryType {
    type LowLevel = crate::native::vulkan1_0::MemoryType;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        crate::native::vulkan1_0::MemoryType {
            property_flags: self.property_flags.into_low_level(context, bump),
            heap_index: self.heap_index.into_low_level(context, bump),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for MemoryType {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        Self {
            property_flags: crate::conv::FromLowLevel::from_low_level(context, value.property_flags),
            heap_index: crate::conv::FromLowLevel::from_low_level(context, value.heap_index),
        }
    }
}
impl MemoryHeap {
    ///Get a reference to the `size` field.
    pub fn size(&self) -> &DeviceSize {
        &self.size
    }
    ///Get a reference to the `flags` field.
    pub fn flags(&self) -> MemoryHeapFlags {
        self.flags
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for MemoryHeap {
    type LowLevel = crate::native::vulkan1_0::MemoryHeap;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        crate::native::vulkan1_0::MemoryHeap {
            size: self.size.into_low_level(context, bump),
            flags: self.flags.into_low_level(context, bump),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for MemoryHeap {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        Self {
            size: crate::conv::FromLowLevel::from_low_level(context, value.size),
            flags: crate::conv::FromLowLevel::from_low_level(context, value.flags),
        }
    }
}
#[doc(alias = "VkMappedMemoryRange")]
#[derive(Clone, PartialEq, Debug)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct MappedMemoryRange {
    pub memory: DeviceMemory,
    pub offset: DeviceSize,
    pub size: DeviceSize,
}
impl MappedMemoryRange {
    ///Get a reference to the `memory` field.
    pub fn memory(&self) -> &DeviceMemory {
        &self.memory
    }
    ///Get a reference to the `offset` field.
    pub fn offset(&self) -> &DeviceSize {
        &self.offset
    }
    ///Get a reference to the `size` field.
    pub fn size(&self) -> &DeviceSize {
        &self.size
    }
    ///Get a mutable reference to the `memory` field.
    pub fn memory_mut(&mut self) -> &mut DeviceMemory {
        &mut self.memory
    }
    ///Get a mutable reference to the `offset` field.
    pub fn offset_mut(&mut self) -> &mut DeviceSize {
        &mut self.offset
    }
    ///Get a mutable reference to the `size` field.
    pub fn size_mut(&mut self) -> &mut DeviceSize {
        &mut self.size
    }
    ///Sets the `memory` field.
    pub fn set_memory(&mut self, memory: DeviceMemory) -> &mut Self {
        self.memory = memory;
        self
    }
    ///Sets the `offset` field.
    pub fn set_offset(&mut self, offset: DeviceSize) -> &mut Self {
        self.offset = offset;
        self
    }
    ///Sets the `size` field.
    pub fn set_size(&mut self, size: DeviceSize) -> &mut Self {
        self.size = size;
        self
    }
    ///Sets the `memory` field in a builder way.
    pub fn with_memory(mut self, memory: DeviceMemory) -> Self {
        self.memory = memory;
        self
    }
    ///Sets the `offset` field in a builder way.
    pub fn with_offset(mut self, offset: DeviceSize) -> Self {
        self.offset = offset;
        self
    }
    ///Sets the `size` field in a builder way.
    pub fn with_size(mut self, size: DeviceSize) -> Self {
        self.size = size;
        self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for MappedMemoryRange {
    type LowLevel = crate::native::vulkan1_0::MappedMemoryRange;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        crate::native::vulkan1_0::MappedMemoryRange {
            s_type: StructureType::MappedMemoryRange,
            p_next: std::ptr::null(),
            memory: self.memory.into_low_level(context, bump),
            offset: self.offset.into_low_level(context, bump),
            size: self.size.into_low_level(context, bump),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for MappedMemoryRange {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        Self {
            memory: crate::conv::FromLowLevel::from_low_level(context, value.memory),
            offset: crate::conv::FromLowLevel::from_low_level(context, value.offset),
            size: crate::conv::FromLowLevel::from_low_level(context, value.size),
        }
    }
}
impl FormatProperties {
    ///Get a reference to the `linear_tiling_features` field.
    pub fn linear_tiling_features(&self) -> FormatFeatureFlags {
        self.linear_tiling_features
    }
    ///Get a reference to the `optimal_tiling_features` field.
    pub fn optimal_tiling_features(&self) -> FormatFeatureFlags {
        self.optimal_tiling_features
    }
    ///Get a reference to the `buffer_features` field.
    pub fn buffer_features(&self) -> FormatFeatureFlags {
        self.buffer_features
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for FormatProperties {
    type LowLevel = crate::native::vulkan1_0::FormatProperties;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        crate::native::vulkan1_0::FormatProperties {
            linear_tiling_features: self.linear_tiling_features.into_low_level(context, bump),
            optimal_tiling_features: self.optimal_tiling_features.into_low_level(context, bump),
            buffer_features: self.buffer_features.into_low_level(context, bump),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for FormatProperties {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        Self {
            linear_tiling_features: crate::conv::FromLowLevel::from_low_level(context, value.linear_tiling_features),
            optimal_tiling_features: crate::conv::FromLowLevel::from_low_level(context, value.optimal_tiling_features),
            buffer_features: crate::conv::FromLowLevel::from_low_level(context, value.buffer_features),
        }
    }
}
impl ImageFormatProperties {
    ///Get a reference to the `max_extent` field.
    pub fn max_extent(&self) -> Extent3D {
        self.max_extent
    }
    ///Get a reference to the `max_mip_levels` field.
    pub fn max_mip_levels(&self) -> u32 {
        self.max_mip_levels
    }
    ///Get a reference to the `max_array_layers` field.
    pub fn max_array_layers(&self) -> u32 {
        self.max_array_layers
    }
    ///Get a reference to the `sample_counts` field.
    pub fn sample_counts(&self) -> SampleCountFlags {
        self.sample_counts
    }
    ///Get a reference to the `max_resource_size` field.
    pub fn max_resource_size(&self) -> &DeviceSize {
        &self.max_resource_size
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for ImageFormatProperties {
    type LowLevel = crate::native::vulkan1_0::ImageFormatProperties;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        crate::native::vulkan1_0::ImageFormatProperties {
            max_extent: self.max_extent.into_low_level(context, bump),
            max_mip_levels: self.max_mip_levels.into_low_level(context, bump),
            max_array_layers: self.max_array_layers.into_low_level(context, bump),
            sample_counts: self.sample_counts.into_low_level(context, bump),
            max_resource_size: self.max_resource_size.into_low_level(context, bump),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for ImageFormatProperties {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        Self {
            max_extent: crate::conv::FromLowLevel::from_low_level(context, value.max_extent),
            max_mip_levels: crate::conv::FromLowLevel::from_low_level(context, value.max_mip_levels),
            max_array_layers: crate::conv::FromLowLevel::from_low_level(context, value.max_array_layers),
            sample_counts: crate::conv::FromLowLevel::from_low_level(context, value.sample_counts),
            max_resource_size: crate::conv::FromLowLevel::from_low_level(context, value.max_resource_size),
        }
    }
}
#[doc(alias = "VkDescriptorBufferInfo")]
#[derive(Clone, PartialEq, Debug, Default)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct DescriptorBufferInfo {
    pub buffer: Option<Buffer>,
    pub offset: DeviceSize,
    pub range: DeviceSize,
}
impl DescriptorBufferInfo {
    ///Get a reference to the `buffer` field.
    pub fn buffer(&self) -> &Option<Buffer> {
        &self.buffer
    }
    ///Get a reference to the `offset` field.
    pub fn offset(&self) -> &DeviceSize {
        &self.offset
    }
    ///Get a reference to the `range` field.
    pub fn range(&self) -> &DeviceSize {
        &self.range
    }
    ///Get a mutable reference to the `buffer` field.
    pub fn buffer_mut(&mut self) -> &mut Option<Buffer> {
        &mut self.buffer
    }
    ///Get a mutable reference to the `offset` field.
    pub fn offset_mut(&mut self) -> &mut DeviceSize {
        &mut self.offset
    }
    ///Get a mutable reference to the `range` field.
    pub fn range_mut(&mut self) -> &mut DeviceSize {
        &mut self.range
    }
    ///Sets the `buffer` field.
    pub fn set_buffer(&mut self, buffer: Option<Buffer>) -> &mut Self {
        self.buffer = buffer;
        self
    }
    ///Sets the `offset` field.
    pub fn set_offset(&mut self, offset: DeviceSize) -> &mut Self {
        self.offset = offset;
        self
    }
    ///Sets the `range` field.
    pub fn set_range(&mut self, range: DeviceSize) -> &mut Self {
        self.range = range;
        self
    }
    ///Sets the `buffer` field in a builder way.
    pub fn with_buffer(mut self, buffer: Option<Buffer>) -> Self {
        self.buffer = buffer;
        self
    }
    ///Sets the `offset` field in a builder way.
    pub fn with_offset(mut self, offset: DeviceSize) -> Self {
        self.offset = offset;
        self
    }
    ///Sets the `range` field in a builder way.
    pub fn with_range(mut self, range: DeviceSize) -> Self {
        self.range = range;
        self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for DescriptorBufferInfo {
    type LowLevel = crate::native::vulkan1_0::DescriptorBufferInfo;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        crate::native::vulkan1_0::DescriptorBufferInfo {
            buffer: self
                .buffer
                .as_ref()
                .map(|v| v.into_low_level(context, bump))
                .unwrap_or_else(Default::default),
            offset: self.offset.into_low_level(context, bump),
            range: self.range.into_low_level(context, bump),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for DescriptorBufferInfo {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        Self {
            buffer: if value.buffer == crate::native::vulkan1_0::Buffer::null() {
                None
            } else {
                Some(crate::conv::FromLowLevel::from_low_level(context, value.buffer))
            },
            offset: crate::conv::FromLowLevel::from_low_level(context, value.offset),
            range: crate::conv::FromLowLevel::from_low_level(context, value.range),
        }
    }
}
#[doc(alias = "VkDescriptorImageInfo")]
#[derive(Clone, PartialEq, Debug)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct DescriptorImageInfo {
    pub sampler: Sampler,
    #[doc(alias = "imageView")]
    pub image_view: ImageView,
    #[doc(alias = "imageLayout")]
    pub image_layout: ImageLayout,
}
impl DescriptorImageInfo {
    ///Get a reference to the `sampler` field.
    pub fn sampler(&self) -> &Sampler {
        &self.sampler
    }
    ///Get a reference to the `image_view` field.
    pub fn image_view(&self) -> &ImageView {
        &self.image_view
    }
    ///Get a reference to the `image_layout` field.
    pub fn image_layout(&self) -> ImageLayout {
        self.image_layout
    }
    ///Get a mutable reference to the `sampler` field.
    pub fn sampler_mut(&mut self) -> &mut Sampler {
        &mut self.sampler
    }
    ///Get a mutable reference to the `image_view` field.
    pub fn image_view_mut(&mut self) -> &mut ImageView {
        &mut self.image_view
    }
    ///Get a mutable reference to the `image_layout` field.
    pub fn image_layout_mut(&mut self) -> &mut ImageLayout {
        &mut self.image_layout
    }
    ///Sets the `sampler` field.
    pub fn set_sampler(&mut self, sampler: Sampler) -> &mut Self {
        self.sampler = sampler;
        self
    }
    ///Sets the `image_view` field.
    pub fn set_image_view(&mut self, image_view: ImageView) -> &mut Self {
        self.image_view = image_view;
        self
    }
    ///Sets the `image_layout` field.
    pub fn set_image_layout(&mut self, image_layout: ImageLayout) -> &mut Self {
        self.image_layout = image_layout;
        self
    }
    ///Sets the `sampler` field in a builder way.
    pub fn with_sampler(mut self, sampler: Sampler) -> Self {
        self.sampler = sampler;
        self
    }
    ///Sets the `image_view` field in a builder way.
    pub fn with_image_view(mut self, image_view: ImageView) -> Self {
        self.image_view = image_view;
        self
    }
    ///Sets the `image_layout` field in a builder way.
    pub fn with_image_layout(mut self, image_layout: ImageLayout) -> Self {
        self.image_layout = image_layout;
        self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for DescriptorImageInfo {
    type LowLevel = crate::native::vulkan1_0::DescriptorImageInfo;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        crate::native::vulkan1_0::DescriptorImageInfo {
            sampler: self.sampler.into_low_level(context, bump),
            image_view: self.image_view.into_low_level(context, bump),
            image_layout: self.image_layout.into_low_level(context, bump),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for DescriptorImageInfo {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        Self {
            sampler: crate::conv::FromLowLevel::from_low_level(context, value.sampler),
            image_view: crate::conv::FromLowLevel::from_low_level(context, value.image_view),
            image_layout: crate::conv::FromLowLevel::from_low_level(context, value.image_layout),
        }
    }
}
#[doc(alias = "VkWriteDescriptorSet")]
#[derive(Clone, PartialEq, Debug)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct WriteDescriptorSet {
    #[doc(alias = "pNext")]
    pub extensions: SmallVec<[WriteDescriptorSetExtension; 1]>,
    #[doc(alias = "dstSet")]
    pub dst_set: DescriptorSet,
    #[doc(alias = "dstBinding")]
    pub dst_binding: u32,
    #[doc(alias = "dstArrayElement")]
    pub dst_array_element: u32,
    #[doc(alias = "descriptorType")]
    pub descriptor_type: DescriptorType,
    #[doc(alias = "pImageInfo")]
    pub image_info: SmallVec<[DescriptorImageInfo; 8]>,
    #[doc(alias = "pBufferInfo")]
    pub buffer_info: SmallVec<[DescriptorBufferInfo; 8]>,
    #[doc(alias = "pTexelBufferView")]
    pub texel_buffer_view: SmallVec<[BufferView; 8]>,
}
impl WriteDescriptorSet {
    ///Adds an extension to the struct
    pub fn with_extension(mut self, ext: impl Into<WriteDescriptorSetExtension>) -> Self {
        self.extensions.push(ext.into());
        self
    }
    ///Get a reference to the `extensions` field.
    pub fn extensions(&self) -> &SmallVec<[WriteDescriptorSetExtension; 1]> {
        &self.extensions
    }
    ///Get a reference to the `dst_set` field.
    pub fn dst_set(&self) -> &DescriptorSet {
        &self.dst_set
    }
    ///Get a reference to the `dst_binding` field.
    pub fn dst_binding(&self) -> u32 {
        self.dst_binding
    }
    ///Get a reference to the `dst_array_element` field.
    pub fn dst_array_element(&self) -> u32 {
        self.dst_array_element
    }
    ///Get a reference to the `descriptor_type` field.
    pub fn descriptor_type(&self) -> DescriptorType {
        self.descriptor_type
    }
    ///Get a reference to the `image_info` field.
    pub fn image_info(&self) -> &SmallVec<[DescriptorImageInfo; 8]> {
        &self.image_info
    }
    ///Get a reference to the `buffer_info` field.
    pub fn buffer_info(&self) -> &SmallVec<[DescriptorBufferInfo; 8]> {
        &self.buffer_info
    }
    ///Get a reference to the `texel_buffer_view` field.
    pub fn texel_buffer_view(&self) -> &SmallVec<[BufferView; 8]> {
        &self.texel_buffer_view
    }
    ///Get a mutable reference to the `extensions` field.
    pub fn extensions_mut(&mut self) -> &mut SmallVec<[WriteDescriptorSetExtension; 1]> {
        &mut self.extensions
    }
    ///Get a mutable reference to the `dst_set` field.
    pub fn dst_set_mut(&mut self) -> &mut DescriptorSet {
        &mut self.dst_set
    }
    ///Get a mutable reference to the `dst_binding` field.
    pub fn dst_binding_mut(&mut self) -> &mut u32 {
        &mut self.dst_binding
    }
    ///Get a mutable reference to the `dst_array_element` field.
    pub fn dst_array_element_mut(&mut self) -> &mut u32 {
        &mut self.dst_array_element
    }
    ///Get a mutable reference to the `descriptor_type` field.
    pub fn descriptor_type_mut(&mut self) -> &mut DescriptorType {
        &mut self.descriptor_type
    }
    ///Get a mutable reference to the `image_info` field.
    pub fn image_info_mut(&mut self) -> &mut SmallVec<[DescriptorImageInfo; 8]> {
        &mut self.image_info
    }
    ///Get a mutable reference to the `buffer_info` field.
    pub fn buffer_info_mut(&mut self) -> &mut SmallVec<[DescriptorBufferInfo; 8]> {
        &mut self.buffer_info
    }
    ///Get a mutable reference to the `texel_buffer_view` field.
    pub fn texel_buffer_view_mut(&mut self) -> &mut SmallVec<[BufferView; 8]> {
        &mut self.texel_buffer_view
    }
    ///Sets the `extensions` field.
    pub fn set_extensions(&mut self, extensions: SmallVec<[WriteDescriptorSetExtension; 1]>) -> &mut Self {
        self.extensions = extensions;
        self
    }
    ///Sets the `dst_set` field.
    pub fn set_dst_set(&mut self, dst_set: DescriptorSet) -> &mut Self {
        self.dst_set = dst_set;
        self
    }
    ///Sets the `dst_binding` field.
    pub fn set_dst_binding(&mut self, dst_binding: u32) -> &mut Self {
        self.dst_binding = dst_binding;
        self
    }
    ///Sets the `dst_array_element` field.
    pub fn set_dst_array_element(&mut self, dst_array_element: u32) -> &mut Self {
        self.dst_array_element = dst_array_element;
        self
    }
    ///Sets the `descriptor_type` field.
    pub fn set_descriptor_type(&mut self, descriptor_type: DescriptorType) -> &mut Self {
        self.descriptor_type = descriptor_type;
        self
    }
    ///Sets the `image_info` field.
    pub fn set_image_info(&mut self, image_info: SmallVec<[DescriptorImageInfo; 8]>) -> &mut Self {
        self.image_info = image_info;
        self
    }
    ///Sets the `buffer_info` field.
    pub fn set_buffer_info(&mut self, buffer_info: SmallVec<[DescriptorBufferInfo; 8]>) -> &mut Self {
        self.buffer_info = buffer_info;
        self
    }
    ///Sets the `texel_buffer_view` field.
    pub fn set_texel_buffer_view(&mut self, texel_buffer_view: SmallVec<[BufferView; 8]>) -> &mut Self {
        self.texel_buffer_view = texel_buffer_view;
        self
    }
    ///Sets the `extensions` field in a builder way.
    pub fn with_extensions(mut self, extensions: SmallVec<[WriteDescriptorSetExtension; 1]>) -> Self {
        self.extensions = extensions;
        self
    }
    ///Sets the `dst_set` field in a builder way.
    pub fn with_dst_set(mut self, dst_set: DescriptorSet) -> Self {
        self.dst_set = dst_set;
        self
    }
    ///Sets the `dst_binding` field in a builder way.
    pub fn with_dst_binding(mut self, dst_binding: u32) -> Self {
        self.dst_binding = dst_binding;
        self
    }
    ///Sets the `dst_array_element` field in a builder way.
    pub fn with_dst_array_element(mut self, dst_array_element: u32) -> Self {
        self.dst_array_element = dst_array_element;
        self
    }
    ///Sets the `descriptor_type` field in a builder way.
    pub fn with_descriptor_type(mut self, descriptor_type: DescriptorType) -> Self {
        self.descriptor_type = descriptor_type;
        self
    }
    ///Sets the `image_info` field in a builder way.
    pub fn with_image_info(mut self, image_info: SmallVec<[DescriptorImageInfo; 8]>) -> Self {
        self.image_info = image_info;
        self
    }
    ///Sets the `buffer_info` field in a builder way.
    pub fn with_buffer_info(mut self, buffer_info: SmallVec<[DescriptorBufferInfo; 8]>) -> Self {
        self.buffer_info = buffer_info;
        self
    }
    ///Sets the `texel_buffer_view` field in a builder way.
    pub fn with_texel_buffer_view(mut self, texel_buffer_view: SmallVec<[BufferView; 8]>) -> Self {
        self.texel_buffer_view = texel_buffer_view;
        self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for WriteDescriptorSet {
    type LowLevel = crate::native::vulkan1_0::WriteDescriptorSet;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        let mut next = std::ptr::null();
        let mut extensions = self.extensions.iter();
        while let Some(ext) = extensions.next() {
            let ext = ext.into_low_level(context, bump);
            (*ext).next = next;
            next = ext;
        }
        let len_image_info = self.image_info.len() as u32;
        let image_info = bump
            .alloc_slice_fill_iter(self.image_info.iter().map(|x| x.into_low_level(context, bump)))
            .as_ptr()
            .cast();
        let buffer_info = bump
            .alloc_slice_fill_iter(self.buffer_info.iter().map(|x| x.into_low_level(context, bump)))
            .as_ptr()
            .cast();
        let texel_buffer_view = bump
            .alloc_slice_fill_iter(self.texel_buffer_view.iter().map(|x| x.into_low_level(context, bump)))
            .as_ptr()
            .cast();
        crate::native::vulkan1_0::WriteDescriptorSet {
            s_type: StructureType::WriteDescriptorSet,
            p_next: next,
            dst_set: self.dst_set.into_low_level(context, bump),
            dst_binding: self.dst_binding.into_low_level(context, bump),
            dst_array_element: self.dst_array_element.into_low_level(context, bump),
            descriptor_count: len_image_info,
            descriptor_type: self.descriptor_type.into_low_level(context, bump),
            image_info: image_info,
            buffer_info: buffer_info,
            texel_buffer_view: texel_buffer_view,
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for WriteDescriptorSet {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        let mut next = value.p_next;
        let mut extensions = SmallVec::new();
        while !next.is_null() {
            extensions.push(crate::conv::FromLowLevel::from_low_level(context, next));
            next = std::ptr::read(next).next;
        }
        let image_info_len = value.descriptor_count;
        let mut image_info = SmallVec::with_capacity(image_info_len as usize);
        for i in 0..image_info_len {
            image_info.push(crate::conv::FromLowLevel::from_low_level(
                context,
                value.image_info.add(i as usize).read(),
            ));
        }
        let buffer_info_len = value.descriptor_count;
        let mut buffer_info = SmallVec::with_capacity(buffer_info_len as usize);
        for i in 0..buffer_info_len {
            buffer_info.push(crate::conv::FromLowLevel::from_low_level(
                context,
                value.buffer_info.add(i as usize).read(),
            ));
        }
        let texel_buffer_view_len = value.descriptor_count;
        let mut texel_buffer_view = SmallVec::with_capacity(texel_buffer_view_len as usize);
        for i in 0..texel_buffer_view_len {
            texel_buffer_view.push(crate::conv::FromLowLevel::from_low_level(
                context,
                value.texel_buffer_view.add(i as usize).read(),
            ));
        }
        Self {
            extensions: extensions,
            dst_set: crate::conv::FromLowLevel::from_low_level(context, value.dst_set),
            dst_binding: crate::conv::FromLowLevel::from_low_level(context, value.dst_binding),
            dst_array_element: crate::conv::FromLowLevel::from_low_level(context, value.dst_array_element),
            descriptor_type: crate::conv::FromLowLevel::from_low_level(context, value.descriptor_type),
            image_info: image_info,
            buffer_info: buffer_info,
            texel_buffer_view: texel_buffer_view,
        }
    }
}
#[derive(Clone, PartialEq, Debug)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
///Extensions for [`WriteDescriptorSet`]
pub enum WriteDescriptorSetExtension {
    #[cfg(feature = "VULKAN_1_3")]
    ///Contains a type [`WriteDescriptorSetInlineUniformBlock`] for extending
    /// [`WriteDescriptorSet`]
    WriteDescriptorSetInlineUniformBlock(WriteDescriptorSetInlineUniformBlock),
    #[cfg(feature = "VK_KHR_acceleration_structure")]
    ///Contains a type [`WriteDescriptorSetAccelerationStructureKHR`] for extending
    /// [`WriteDescriptorSet`]
    WriteDescriptorSetAccelerationStructureKHR(WriteDescriptorSetAccelerationStructureKHR),
    #[cfg(feature = "VK_NV_ray_tracing")]
    ///Contains a type [`WriteDescriptorSetAccelerationStructureNV`] for extending
    /// [`WriteDescriptorSet`]
    WriteDescriptorSetAccelerationStructureNV(WriteDescriptorSetAccelerationStructureNV),
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for WriteDescriptorSetExtension {
    type LowLevel = *const crate::native::vulkan1_0::BaseInStructure;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        match self { # [cfg (feature = "VULKAN_1_3")] Self :: WriteDescriptorSetInlineUniformBlock (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: vulkan1_3 :: WriteDescriptorSetInlineUniformBlock) . cast () , # [cfg (feature = "VK_KHR_acceleration_structure")] Self :: WriteDescriptorSetAccelerationStructureKHR (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: khr_acceleration_structure :: WriteDescriptorSetAccelerationStructureKHR) . cast () , # [cfg (feature = "VK_NV_ray_tracing")] Self :: WriteDescriptorSetAccelerationStructureNV (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: nv_ray_tracing :: WriteDescriptorSetAccelerationStructureNV) . cast () , other => unreachable ! ("unexpected variant {:?}" , other) }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for WriteDescriptorSetExtension {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        assert!(!value.is_null());
        match (* value) . s_type { # [cfg (feature = "VULKAN_1_3")] crate :: native :: vulkan1_0 :: StructureType :: WriteDescriptorSetInlineUniformBlock => Self :: WriteDescriptorSetInlineUniformBlock (WriteDescriptorSetInlineUniformBlock :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: vulkan1_3 :: WriteDescriptorSetInlineUniformBlock > ()))) , # [cfg (feature = "VK_KHR_acceleration_structure")] crate :: native :: vulkan1_0 :: StructureType :: WriteDescriptorSetAccelerationStructureKhr => Self :: WriteDescriptorSetAccelerationStructureKHR (WriteDescriptorSetAccelerationStructureKHR :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: khr_acceleration_structure :: WriteDescriptorSetAccelerationStructureKHR > ()))) , # [cfg (feature = "VK_NV_ray_tracing")] crate :: native :: vulkan1_0 :: StructureType :: WriteDescriptorSetAccelerationStructureNv => Self :: WriteDescriptorSetAccelerationStructureNV (WriteDescriptorSetAccelerationStructureNV :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: nv_ray_tracing :: WriteDescriptorSetAccelerationStructureNV > ()))) , other => panic ! ("Structure type {:?} is not a member of {}" , other , stringify ! (WriteDescriptorSet)) }
    }
}
#[cfg(feature = "VULKAN_1_3")]
impl From<WriteDescriptorSetInlineUniformBlock> for WriteDescriptorSetExtension {
    fn from(ext: WriteDescriptorSetInlineUniformBlock) -> Self {
        Self::WriteDescriptorSetInlineUniformBlock(ext)
    }
}
#[cfg(feature = "VULKAN_1_3")]
impl TryInto<WriteDescriptorSetInlineUniformBlock> for WriteDescriptorSetExtension {
    type Error = WriteDescriptorSetExtension;
    fn try_into(self) -> Result<WriteDescriptorSetInlineUniformBlock, Self::Error> {
        match self {
            Self::WriteDescriptorSetInlineUniformBlock(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_KHR_acceleration_structure")]
impl From<WriteDescriptorSetAccelerationStructureKHR> for WriteDescriptorSetExtension {
    fn from(ext: WriteDescriptorSetAccelerationStructureKHR) -> Self {
        Self::WriteDescriptorSetAccelerationStructureKHR(ext)
    }
}
#[cfg(feature = "VK_KHR_acceleration_structure")]
impl TryInto<WriteDescriptorSetAccelerationStructureKHR> for WriteDescriptorSetExtension {
    type Error = WriteDescriptorSetExtension;
    fn try_into(self) -> Result<WriteDescriptorSetAccelerationStructureKHR, Self::Error> {
        match self {
            Self::WriteDescriptorSetAccelerationStructureKHR(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_NV_ray_tracing")]
impl From<WriteDescriptorSetAccelerationStructureNV> for WriteDescriptorSetExtension {
    fn from(ext: WriteDescriptorSetAccelerationStructureNV) -> Self {
        Self::WriteDescriptorSetAccelerationStructureNV(ext)
    }
}
#[cfg(feature = "VK_NV_ray_tracing")]
impl TryInto<WriteDescriptorSetAccelerationStructureNV> for WriteDescriptorSetExtension {
    type Error = WriteDescriptorSetExtension;
    fn try_into(self) -> Result<WriteDescriptorSetAccelerationStructureNV, Self::Error> {
        match self {
            Self::WriteDescriptorSetAccelerationStructureNV(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[doc(alias = "VkCopyDescriptorSet")]
#[derive(Clone, PartialEq, Debug)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct CopyDescriptorSet {
    #[doc(alias = "srcSet")]
    pub src_set: DescriptorSet,
    #[doc(alias = "srcBinding")]
    pub src_binding: u32,
    #[doc(alias = "srcArrayElement")]
    pub src_array_element: u32,
    #[doc(alias = "dstSet")]
    pub dst_set: DescriptorSet,
    #[doc(alias = "dstBinding")]
    pub dst_binding: u32,
    #[doc(alias = "dstArrayElement")]
    pub dst_array_element: u32,
    #[doc(alias = "descriptorCount")]
    pub descriptor_count: u32,
}
impl CopyDescriptorSet {
    ///Get a reference to the `src_set` field.
    pub fn src_set(&self) -> &DescriptorSet {
        &self.src_set
    }
    ///Get a reference to the `src_binding` field.
    pub fn src_binding(&self) -> u32 {
        self.src_binding
    }
    ///Get a reference to the `src_array_element` field.
    pub fn src_array_element(&self) -> u32 {
        self.src_array_element
    }
    ///Get a reference to the `dst_set` field.
    pub fn dst_set(&self) -> &DescriptorSet {
        &self.dst_set
    }
    ///Get a reference to the `dst_binding` field.
    pub fn dst_binding(&self) -> u32 {
        self.dst_binding
    }
    ///Get a reference to the `dst_array_element` field.
    pub fn dst_array_element(&self) -> u32 {
        self.dst_array_element
    }
    ///Get a reference to the `descriptor_count` field.
    pub fn descriptor_count(&self) -> u32 {
        self.descriptor_count
    }
    ///Get a mutable reference to the `src_set` field.
    pub fn src_set_mut(&mut self) -> &mut DescriptorSet {
        &mut self.src_set
    }
    ///Get a mutable reference to the `src_binding` field.
    pub fn src_binding_mut(&mut self) -> &mut u32 {
        &mut self.src_binding
    }
    ///Get a mutable reference to the `src_array_element` field.
    pub fn src_array_element_mut(&mut self) -> &mut u32 {
        &mut self.src_array_element
    }
    ///Get a mutable reference to the `dst_set` field.
    pub fn dst_set_mut(&mut self) -> &mut DescriptorSet {
        &mut self.dst_set
    }
    ///Get a mutable reference to the `dst_binding` field.
    pub fn dst_binding_mut(&mut self) -> &mut u32 {
        &mut self.dst_binding
    }
    ///Get a mutable reference to the `dst_array_element` field.
    pub fn dst_array_element_mut(&mut self) -> &mut u32 {
        &mut self.dst_array_element
    }
    ///Get a mutable reference to the `descriptor_count` field.
    pub fn descriptor_count_mut(&mut self) -> &mut u32 {
        &mut self.descriptor_count
    }
    ///Sets the `src_set` field.
    pub fn set_src_set(&mut self, src_set: DescriptorSet) -> &mut Self {
        self.src_set = src_set;
        self
    }
    ///Sets the `src_binding` field.
    pub fn set_src_binding(&mut self, src_binding: u32) -> &mut Self {
        self.src_binding = src_binding;
        self
    }
    ///Sets the `src_array_element` field.
    pub fn set_src_array_element(&mut self, src_array_element: u32) -> &mut Self {
        self.src_array_element = src_array_element;
        self
    }
    ///Sets the `dst_set` field.
    pub fn set_dst_set(&mut self, dst_set: DescriptorSet) -> &mut Self {
        self.dst_set = dst_set;
        self
    }
    ///Sets the `dst_binding` field.
    pub fn set_dst_binding(&mut self, dst_binding: u32) -> &mut Self {
        self.dst_binding = dst_binding;
        self
    }
    ///Sets the `dst_array_element` field.
    pub fn set_dst_array_element(&mut self, dst_array_element: u32) -> &mut Self {
        self.dst_array_element = dst_array_element;
        self
    }
    ///Sets the `descriptor_count` field.
    pub fn set_descriptor_count(&mut self, descriptor_count: u32) -> &mut Self {
        self.descriptor_count = descriptor_count;
        self
    }
    ///Sets the `src_set` field in a builder way.
    pub fn with_src_set(mut self, src_set: DescriptorSet) -> Self {
        self.src_set = src_set;
        self
    }
    ///Sets the `src_binding` field in a builder way.
    pub fn with_src_binding(mut self, src_binding: u32) -> Self {
        self.src_binding = src_binding;
        self
    }
    ///Sets the `src_array_element` field in a builder way.
    pub fn with_src_array_element(mut self, src_array_element: u32) -> Self {
        self.src_array_element = src_array_element;
        self
    }
    ///Sets the `dst_set` field in a builder way.
    pub fn with_dst_set(mut self, dst_set: DescriptorSet) -> Self {
        self.dst_set = dst_set;
        self
    }
    ///Sets the `dst_binding` field in a builder way.
    pub fn with_dst_binding(mut self, dst_binding: u32) -> Self {
        self.dst_binding = dst_binding;
        self
    }
    ///Sets the `dst_array_element` field in a builder way.
    pub fn with_dst_array_element(mut self, dst_array_element: u32) -> Self {
        self.dst_array_element = dst_array_element;
        self
    }
    ///Sets the `descriptor_count` field in a builder way.
    pub fn with_descriptor_count(mut self, descriptor_count: u32) -> Self {
        self.descriptor_count = descriptor_count;
        self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for CopyDescriptorSet {
    type LowLevel = crate::native::vulkan1_0::CopyDescriptorSet;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        crate::native::vulkan1_0::CopyDescriptorSet {
            s_type: StructureType::CopyDescriptorSet,
            p_next: std::ptr::null(),
            src_set: self.src_set.into_low_level(context, bump),
            src_binding: self.src_binding.into_low_level(context, bump),
            src_array_element: self.src_array_element.into_low_level(context, bump),
            dst_set: self.dst_set.into_low_level(context, bump),
            dst_binding: self.dst_binding.into_low_level(context, bump),
            dst_array_element: self.dst_array_element.into_low_level(context, bump),
            descriptor_count: self.descriptor_count.into_low_level(context, bump),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for CopyDescriptorSet {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        Self {
            src_set: crate::conv::FromLowLevel::from_low_level(context, value.src_set),
            src_binding: crate::conv::FromLowLevel::from_low_level(context, value.src_binding),
            src_array_element: crate::conv::FromLowLevel::from_low_level(context, value.src_array_element),
            dst_set: crate::conv::FromLowLevel::from_low_level(context, value.dst_set),
            dst_binding: crate::conv::FromLowLevel::from_low_level(context, value.dst_binding),
            dst_array_element: crate::conv::FromLowLevel::from_low_level(context, value.dst_array_element),
            descriptor_count: crate::conv::FromLowLevel::from_low_level(context, value.descriptor_count),
        }
    }
}
#[doc(alias = "VkBufferCreateInfo")]
#[derive(Clone, PartialEq, Debug, Default)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct BufferCreateInfo {
    #[doc(alias = "pNext")]
    pub extensions: SmallVec<[BufferCreateInfoExtension; 1]>,
    pub flags: BufferCreateFlags,
    pub size: DeviceSize,
    pub usage: BufferUsageFlags,
    #[doc(alias = "sharingMode")]
    pub sharing_mode: SharingMode,
    #[doc(alias = "pQueueFamilyIndices")]
    pub queue_family_indices: SmallVec<[u32; 8]>,
}
impl BufferCreateInfo {
    ///Adds an extension to the struct
    pub fn with_extension(mut self, ext: impl Into<BufferCreateInfoExtension>) -> Self {
        self.extensions.push(ext.into());
        self
    }
    ///Get a reference to the `extensions` field.
    pub fn extensions(&self) -> &SmallVec<[BufferCreateInfoExtension; 1]> {
        &self.extensions
    }
    ///Get a reference to the `flags` field.
    pub fn flags(&self) -> BufferCreateFlags {
        self.flags
    }
    ///Get a reference to the `size` field.
    pub fn size(&self) -> &DeviceSize {
        &self.size
    }
    ///Get a reference to the `usage` field.
    pub fn usage(&self) -> BufferUsageFlags {
        self.usage
    }
    ///Get a reference to the `sharing_mode` field.
    pub fn sharing_mode(&self) -> SharingMode {
        self.sharing_mode
    }
    ///Get a reference to the `queue_family_indices` field.
    pub fn queue_family_indices(&self) -> &SmallVec<[u32; 8]> {
        &self.queue_family_indices
    }
    ///Get a mutable reference to the `extensions` field.
    pub fn extensions_mut(&mut self) -> &mut SmallVec<[BufferCreateInfoExtension; 1]> {
        &mut self.extensions
    }
    ///Get a mutable reference to the `flags` field.
    pub fn flags_mut(&mut self) -> &mut BufferCreateFlags {
        &mut self.flags
    }
    ///Get a mutable reference to the `size` field.
    pub fn size_mut(&mut self) -> &mut DeviceSize {
        &mut self.size
    }
    ///Get a mutable reference to the `usage` field.
    pub fn usage_mut(&mut self) -> &mut BufferUsageFlags {
        &mut self.usage
    }
    ///Get a mutable reference to the `sharing_mode` field.
    pub fn sharing_mode_mut(&mut self) -> &mut SharingMode {
        &mut self.sharing_mode
    }
    ///Get a mutable reference to the `queue_family_indices` field.
    pub fn queue_family_indices_mut(&mut self) -> &mut SmallVec<[u32; 8]> {
        &mut self.queue_family_indices
    }
    ///Sets the `extensions` field.
    pub fn set_extensions(&mut self, extensions: SmallVec<[BufferCreateInfoExtension; 1]>) -> &mut Self {
        self.extensions = extensions;
        self
    }
    ///Sets the `flags` field.
    pub fn set_flags(&mut self, flags: BufferCreateFlags) -> &mut Self {
        self.flags = flags;
        self
    }
    ///Sets the `size` field.
    pub fn set_size(&mut self, size: DeviceSize) -> &mut Self {
        self.size = size;
        self
    }
    ///Sets the `usage` field.
    pub fn set_usage(&mut self, usage: BufferUsageFlags) -> &mut Self {
        self.usage = usage;
        self
    }
    ///Sets the `sharing_mode` field.
    pub fn set_sharing_mode(&mut self, sharing_mode: SharingMode) -> &mut Self {
        self.sharing_mode = sharing_mode;
        self
    }
    ///Sets the `queue_family_indices` field.
    pub fn set_queue_family_indices(&mut self, queue_family_indices: SmallVec<[u32; 8]>) -> &mut Self {
        self.queue_family_indices = queue_family_indices;
        self
    }
    ///Sets the `extensions` field in a builder way.
    pub fn with_extensions(mut self, extensions: SmallVec<[BufferCreateInfoExtension; 1]>) -> Self {
        self.extensions = extensions;
        self
    }
    ///Sets the `flags` field in a builder way.
    pub fn with_flags(mut self, flags: BufferCreateFlags) -> Self {
        self.flags = flags;
        self
    }
    ///Sets the `size` field in a builder way.
    pub fn with_size(mut self, size: DeviceSize) -> Self {
        self.size = size;
        self
    }
    ///Sets the `usage` field in a builder way.
    pub fn with_usage(mut self, usage: BufferUsageFlags) -> Self {
        self.usage = usage;
        self
    }
    ///Sets the `sharing_mode` field in a builder way.
    pub fn with_sharing_mode(mut self, sharing_mode: SharingMode) -> Self {
        self.sharing_mode = sharing_mode;
        self
    }
    ///Sets the `queue_family_indices` field in a builder way.
    pub fn with_queue_family_indices(mut self, queue_family_indices: SmallVec<[u32; 8]>) -> Self {
        self.queue_family_indices = queue_family_indices;
        self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for BufferCreateInfo {
    type LowLevel = crate::native::vulkan1_0::BufferCreateInfo;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        let mut next = std::ptr::null();
        let mut extensions = self.extensions.iter();
        while let Some(ext) = extensions.next() {
            let ext = ext.into_low_level(context, bump);
            (*ext).next = next;
            next = ext;
        }
        let len_queue_family_indices = self.queue_family_indices.len() as u32;
        let queue_family_indices = bump
            .alloc_slice_fill_iter(
                self.queue_family_indices
                    .iter()
                    .map(|x| x.into_low_level(context, bump)),
            )
            .as_ptr()
            .cast();
        crate::native::vulkan1_0::BufferCreateInfo {
            s_type: StructureType::BufferCreateInfo,
            p_next: next,
            flags: self.flags.into_low_level(context, bump),
            size: self.size.into_low_level(context, bump),
            usage: self.usage.into_low_level(context, bump),
            sharing_mode: self.sharing_mode.into_low_level(context, bump),
            queue_family_index_count: len_queue_family_indices,
            queue_family_indices: queue_family_indices,
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for BufferCreateInfo {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        let mut next = value.p_next;
        let mut extensions = SmallVec::new();
        while !next.is_null() {
            extensions.push(crate::conv::FromLowLevel::from_low_level(context, next));
            next = std::ptr::read(next).next;
        }
        let queue_family_indices_len = value.queue_family_index_count;
        let mut queue_family_indices = SmallVec::with_capacity(queue_family_indices_len as usize);
        for i in 0..queue_family_indices_len {
            queue_family_indices.push(crate::conv::FromLowLevel::from_low_level(
                context,
                value.queue_family_indices.add(i as usize).read(),
            ));
        }
        Self {
            extensions: extensions,
            flags: crate::conv::FromLowLevel::from_low_level(context, value.flags),
            size: crate::conv::FromLowLevel::from_low_level(context, value.size),
            usage: crate::conv::FromLowLevel::from_low_level(context, value.usage),
            sharing_mode: crate::conv::FromLowLevel::from_low_level(context, value.sharing_mode),
            queue_family_indices: queue_family_indices,
        }
    }
}
#[derive(Clone, PartialEq, Debug)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
///Extensions for [`BufferCreateInfo`]
pub enum BufferCreateInfoExtension {
    #[cfg(feature = "VK_NV_dedicated_allocation")]
    ///Contains a type [`DedicatedAllocationBufferCreateInfoNV`] for extending [`BufferCreateInfo`]
    DedicatedAllocationBufferCreateInfoNV(DedicatedAllocationBufferCreateInfoNV),
    ///Contains a type [`ExternalMemoryBufferCreateInfo`] for extending [`BufferCreateInfo`]
    ExternalMemoryBufferCreateInfo(ExternalMemoryBufferCreateInfo),
    #[cfg(feature = "VULKAN_1_2")]
    ///Contains a type [`BufferOpaqueCaptureAddressCreateInfo`] for extending [`BufferCreateInfo`]
    BufferOpaqueCaptureAddressCreateInfo(BufferOpaqueCaptureAddressCreateInfo),
    #[cfg(feature = "VK_EXT_buffer_device_address")]
    ///Contains a type [`BufferDeviceAddressCreateInfoEXT`] for extending [`BufferCreateInfo`]
    BufferDeviceAddressCreateInfoEXT(BufferDeviceAddressCreateInfoEXT),
    #[cfg(feature = "VK_KHR_video_queue")]
    ///Contains a type [`VideoProfilesKHR`] for extending [`BufferCreateInfo`]
    VideoProfilesKHR(VideoProfilesKHR),
    #[cfg(feature = "VK_KHR_video_queue")]
    ///Contains a type [`VideoProfileKHR`] for extending [`BufferCreateInfo`]
    VideoProfileKHR(VideoProfileKHR),
    #[cfg(feature = "VK_FUCHSIA_buffer_collection")]
    ///Contains a type [`BufferCollectionBufferCreateInfoFUCHSIA`] for extending
    /// [`BufferCreateInfo`]
    BufferCollectionBufferCreateInfoFUCHSIA(BufferCollectionBufferCreateInfoFUCHSIA),
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for BufferCreateInfoExtension {
    type LowLevel = *const crate::native::vulkan1_0::BaseInStructure;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        match self {
            #[cfg(feature = "VK_NV_dedicated_allocation")]
            Self::DedicatedAllocationBufferCreateInfoNV(ext) => (bump.alloc(ext.into_low_level(context, bump))
                as *mut crate::native::extensions::nv_dedicated_allocation::DedicatedAllocationBufferCreateInfoNV)
                .cast(),
            Self::ExternalMemoryBufferCreateInfo(ext) => (bump.alloc(ext.into_low_level(context, bump))
                as *mut crate::native::vulkan1_1::ExternalMemoryBufferCreateInfo)
                .cast(),
            #[cfg(feature = "VULKAN_1_2")]
            Self::BufferOpaqueCaptureAddressCreateInfo(ext) => (bump.alloc(ext.into_low_level(context, bump))
                as *mut crate::native::vulkan1_2::BufferOpaqueCaptureAddressCreateInfo)
                .cast(),
            #[cfg(feature = "VK_EXT_buffer_device_address")]
            Self::BufferDeviceAddressCreateInfoEXT(ext) => (bump.alloc(ext.into_low_level(context, bump))
                as *mut crate::native::extensions::ext_buffer_device_address::BufferDeviceAddressCreateInfoEXT)
                .cast(),
            #[cfg(feature = "VK_KHR_video_queue")]
            Self::VideoProfilesKHR(ext) => (bump.alloc(ext.into_low_level(context, bump))
                as *mut crate::native::extensions::khr_video_queue::VideoProfilesKHR)
                .cast(),
            #[cfg(feature = "VK_KHR_video_queue")]
            Self::VideoProfileKHR(ext) => (bump.alloc(ext.into_low_level(context, bump))
                as *mut crate::native::extensions::khr_video_queue::VideoProfileKHR)
                .cast(),
            #[cfg(feature = "VK_FUCHSIA_buffer_collection")]
            Self::BufferCollectionBufferCreateInfoFUCHSIA(ext) => (bump.alloc(ext.into_low_level(context, bump))
                as *mut crate::native::extensions::fuchsia_buffer_collection::BufferCollectionBufferCreateInfoFUCHSIA)
                .cast(),
            other => unreachable!("unexpected variant {:?}", other),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for BufferCreateInfoExtension {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        assert!(!value.is_null());
        match (* value) . s_type { # [cfg (feature = "VK_NV_dedicated_allocation")] crate :: native :: vulkan1_0 :: StructureType :: DedicatedAllocationBufferCreateInfoNv => Self :: DedicatedAllocationBufferCreateInfoNV (DedicatedAllocationBufferCreateInfoNV :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: nv_dedicated_allocation :: DedicatedAllocationBufferCreateInfoNV > ()))) , crate :: native :: vulkan1_0 :: StructureType :: ExternalMemoryBufferCreateInfo => Self :: ExternalMemoryBufferCreateInfo (ExternalMemoryBufferCreateInfo :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: vulkan1_1 :: ExternalMemoryBufferCreateInfo > ()))) , # [cfg (feature = "VULKAN_1_2")] crate :: native :: vulkan1_0 :: StructureType :: BufferOpaqueCaptureAddressCreateInfo => Self :: BufferOpaqueCaptureAddressCreateInfo (BufferOpaqueCaptureAddressCreateInfo :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: vulkan1_2 :: BufferOpaqueCaptureAddressCreateInfo > ()))) , # [cfg (feature = "VK_EXT_buffer_device_address")] crate :: native :: vulkan1_0 :: StructureType :: BufferDeviceAddressCreateInfoExt => Self :: BufferDeviceAddressCreateInfoEXT (BufferDeviceAddressCreateInfoEXT :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: ext_buffer_device_address :: BufferDeviceAddressCreateInfoEXT > ()))) , # [cfg (feature = "VK_KHR_video_queue")] crate :: native :: vulkan1_0 :: StructureType :: VideoProfilesKhr => Self :: VideoProfilesKHR (VideoProfilesKHR :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: khr_video_queue :: VideoProfilesKHR > ()))) , # [cfg (feature = "VK_KHR_video_queue")] crate :: native :: vulkan1_0 :: StructureType :: VideoProfileKhr => Self :: VideoProfileKHR (VideoProfileKHR :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: khr_video_queue :: VideoProfileKHR > ()))) , # [cfg (feature = "VK_FUCHSIA_buffer_collection")] crate :: native :: vulkan1_0 :: StructureType :: BufferCollectionBufferCreateInfoFuchsia => Self :: BufferCollectionBufferCreateInfoFUCHSIA (BufferCollectionBufferCreateInfoFUCHSIA :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: fuchsia_buffer_collection :: BufferCollectionBufferCreateInfoFUCHSIA > ()))) , other => panic ! ("Structure type {:?} is not a member of {}" , other , stringify ! (BufferCreateInfo)) }
    }
}
#[cfg(feature = "VK_NV_dedicated_allocation")]
impl From<DedicatedAllocationBufferCreateInfoNV> for BufferCreateInfoExtension {
    fn from(ext: DedicatedAllocationBufferCreateInfoNV) -> Self {
        Self::DedicatedAllocationBufferCreateInfoNV(ext)
    }
}
#[cfg(feature = "VK_NV_dedicated_allocation")]
impl TryInto<DedicatedAllocationBufferCreateInfoNV> for BufferCreateInfoExtension {
    type Error = BufferCreateInfoExtension;
    fn try_into(self) -> Result<DedicatedAllocationBufferCreateInfoNV, Self::Error> {
        match self {
            Self::DedicatedAllocationBufferCreateInfoNV(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
impl From<ExternalMemoryBufferCreateInfo> for BufferCreateInfoExtension {
    fn from(ext: ExternalMemoryBufferCreateInfo) -> Self {
        Self::ExternalMemoryBufferCreateInfo(ext)
    }
}
impl TryInto<ExternalMemoryBufferCreateInfo> for BufferCreateInfoExtension {
    type Error = BufferCreateInfoExtension;
    fn try_into(self) -> Result<ExternalMemoryBufferCreateInfo, Self::Error> {
        match self {
            Self::ExternalMemoryBufferCreateInfo(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VULKAN_1_2")]
impl From<BufferOpaqueCaptureAddressCreateInfo> for BufferCreateInfoExtension {
    fn from(ext: BufferOpaqueCaptureAddressCreateInfo) -> Self {
        Self::BufferOpaqueCaptureAddressCreateInfo(ext)
    }
}
#[cfg(feature = "VULKAN_1_2")]
impl TryInto<BufferOpaqueCaptureAddressCreateInfo> for BufferCreateInfoExtension {
    type Error = BufferCreateInfoExtension;
    fn try_into(self) -> Result<BufferOpaqueCaptureAddressCreateInfo, Self::Error> {
        match self {
            Self::BufferOpaqueCaptureAddressCreateInfo(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_EXT_buffer_device_address")]
impl From<BufferDeviceAddressCreateInfoEXT> for BufferCreateInfoExtension {
    fn from(ext: BufferDeviceAddressCreateInfoEXT) -> Self {
        Self::BufferDeviceAddressCreateInfoEXT(ext)
    }
}
#[cfg(feature = "VK_EXT_buffer_device_address")]
impl TryInto<BufferDeviceAddressCreateInfoEXT> for BufferCreateInfoExtension {
    type Error = BufferCreateInfoExtension;
    fn try_into(self) -> Result<BufferDeviceAddressCreateInfoEXT, Self::Error> {
        match self {
            Self::BufferDeviceAddressCreateInfoEXT(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_KHR_video_queue")]
impl From<VideoProfilesKHR> for BufferCreateInfoExtension {
    fn from(ext: VideoProfilesKHR) -> Self {
        Self::VideoProfilesKHR(ext)
    }
}
#[cfg(feature = "VK_KHR_video_queue")]
impl TryInto<VideoProfilesKHR> for BufferCreateInfoExtension {
    type Error = BufferCreateInfoExtension;
    fn try_into(self) -> Result<VideoProfilesKHR, Self::Error> {
        match self {
            Self::VideoProfilesKHR(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_KHR_video_queue")]
impl From<VideoProfileKHR> for BufferCreateInfoExtension {
    fn from(ext: VideoProfileKHR) -> Self {
        Self::VideoProfileKHR(ext)
    }
}
#[cfg(feature = "VK_KHR_video_queue")]
impl TryInto<VideoProfileKHR> for BufferCreateInfoExtension {
    type Error = BufferCreateInfoExtension;
    fn try_into(self) -> Result<VideoProfileKHR, Self::Error> {
        match self {
            Self::VideoProfileKHR(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_FUCHSIA_buffer_collection")]
impl From<BufferCollectionBufferCreateInfoFUCHSIA> for BufferCreateInfoExtension {
    fn from(ext: BufferCollectionBufferCreateInfoFUCHSIA) -> Self {
        Self::BufferCollectionBufferCreateInfoFUCHSIA(ext)
    }
}
#[cfg(feature = "VK_FUCHSIA_buffer_collection")]
impl TryInto<BufferCollectionBufferCreateInfoFUCHSIA> for BufferCreateInfoExtension {
    type Error = BufferCreateInfoExtension;
    fn try_into(self) -> Result<BufferCollectionBufferCreateInfoFUCHSIA, Self::Error> {
        match self {
            Self::BufferCollectionBufferCreateInfoFUCHSIA(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[doc(alias = "VkBufferViewCreateInfo")]
#[derive(Clone, PartialEq, Debug)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct BufferViewCreateInfo {
    pub flags: BufferViewCreateFlags,
    pub buffer: Buffer,
    pub format: Format,
    pub offset: DeviceSize,
    pub range: DeviceSize,
}
impl BufferViewCreateInfo {
    ///Get a reference to the `flags` field.
    pub fn flags(&self) -> BufferViewCreateFlags {
        self.flags
    }
    ///Get a reference to the `buffer` field.
    pub fn buffer(&self) -> &Buffer {
        &self.buffer
    }
    ///Get a reference to the `format` field.
    pub fn format(&self) -> Format {
        self.format
    }
    ///Get a reference to the `offset` field.
    pub fn offset(&self) -> &DeviceSize {
        &self.offset
    }
    ///Get a reference to the `range` field.
    pub fn range(&self) -> &DeviceSize {
        &self.range
    }
    ///Get a mutable reference to the `flags` field.
    pub fn flags_mut(&mut self) -> &mut BufferViewCreateFlags {
        &mut self.flags
    }
    ///Get a mutable reference to the `buffer` field.
    pub fn buffer_mut(&mut self) -> &mut Buffer {
        &mut self.buffer
    }
    ///Get a mutable reference to the `format` field.
    pub fn format_mut(&mut self) -> &mut Format {
        &mut self.format
    }
    ///Get a mutable reference to the `offset` field.
    pub fn offset_mut(&mut self) -> &mut DeviceSize {
        &mut self.offset
    }
    ///Get a mutable reference to the `range` field.
    pub fn range_mut(&mut self) -> &mut DeviceSize {
        &mut self.range
    }
    ///Sets the `flags` field.
    pub fn set_flags(&mut self, flags: BufferViewCreateFlags) -> &mut Self {
        self.flags = flags;
        self
    }
    ///Sets the `buffer` field.
    pub fn set_buffer(&mut self, buffer: Buffer) -> &mut Self {
        self.buffer = buffer;
        self
    }
    ///Sets the `format` field.
    pub fn set_format(&mut self, format: Format) -> &mut Self {
        self.format = format;
        self
    }
    ///Sets the `offset` field.
    pub fn set_offset(&mut self, offset: DeviceSize) -> &mut Self {
        self.offset = offset;
        self
    }
    ///Sets the `range` field.
    pub fn set_range(&mut self, range: DeviceSize) -> &mut Self {
        self.range = range;
        self
    }
    ///Sets the `flags` field in a builder way.
    pub fn with_flags(mut self, flags: BufferViewCreateFlags) -> Self {
        self.flags = flags;
        self
    }
    ///Sets the `buffer` field in a builder way.
    pub fn with_buffer(mut self, buffer: Buffer) -> Self {
        self.buffer = buffer;
        self
    }
    ///Sets the `format` field in a builder way.
    pub fn with_format(mut self, format: Format) -> Self {
        self.format = format;
        self
    }
    ///Sets the `offset` field in a builder way.
    pub fn with_offset(mut self, offset: DeviceSize) -> Self {
        self.offset = offset;
        self
    }
    ///Sets the `range` field in a builder way.
    pub fn with_range(mut self, range: DeviceSize) -> Self {
        self.range = range;
        self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for BufferViewCreateInfo {
    type LowLevel = crate::native::vulkan1_0::BufferViewCreateInfo;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        crate::native::vulkan1_0::BufferViewCreateInfo {
            s_type: StructureType::BufferViewCreateInfo,
            p_next: std::ptr::null(),
            flags: self.flags.into_low_level(context, bump),
            buffer: self.buffer.into_low_level(context, bump),
            format: self.format.into_low_level(context, bump),
            offset: self.offset.into_low_level(context, bump),
            range: self.range.into_low_level(context, bump),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for BufferViewCreateInfo {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        Self {
            flags: crate::conv::FromLowLevel::from_low_level(context, value.flags),
            buffer: crate::conv::FromLowLevel::from_low_level(context, value.buffer),
            format: crate::conv::FromLowLevel::from_low_level(context, value.format),
            offset: crate::conv::FromLowLevel::from_low_level(context, value.offset),
            range: crate::conv::FromLowLevel::from_low_level(context, value.range),
        }
    }
}
impl ImageSubresource {
    ///Get a reference to the `aspect_mask` field.
    pub fn aspect_mask(&self) -> ImageAspectFlags {
        self.aspect_mask
    }
    ///Get a reference to the `mip_level` field.
    pub fn mip_level(&self) -> u32 {
        self.mip_level
    }
    ///Get a reference to the `array_layer` field.
    pub fn array_layer(&self) -> u32 {
        self.array_layer
    }
    ///Get a mutable reference to the `aspect_mask` field.
    pub fn aspect_mask_mut(&mut self) -> &mut ImageAspectFlags {
        &mut self.aspect_mask
    }
    ///Get a mutable reference to the `mip_level` field.
    pub fn mip_level_mut(&mut self) -> &mut u32 {
        &mut self.mip_level
    }
    ///Get a mutable reference to the `array_layer` field.
    pub fn array_layer_mut(&mut self) -> &mut u32 {
        &mut self.array_layer
    }
    ///Sets the `aspect_mask` field.
    pub fn set_aspect_mask(&mut self, aspect_mask: ImageAspectFlags) -> &mut Self {
        self.aspect_mask = aspect_mask;
        self
    }
    ///Sets the `mip_level` field.
    pub fn set_mip_level(&mut self, mip_level: u32) -> &mut Self {
        self.mip_level = mip_level;
        self
    }
    ///Sets the `array_layer` field.
    pub fn set_array_layer(&mut self, array_layer: u32) -> &mut Self {
        self.array_layer = array_layer;
        self
    }
    ///Sets the `aspect_mask` field in a builder way.
    pub fn with_aspect_mask(mut self, aspect_mask: ImageAspectFlags) -> Self {
        self.aspect_mask = aspect_mask;
        self
    }
    ///Sets the `mip_level` field in a builder way.
    pub fn with_mip_level(mut self, mip_level: u32) -> Self {
        self.mip_level = mip_level;
        self
    }
    ///Sets the `array_layer` field in a builder way.
    pub fn with_array_layer(mut self, array_layer: u32) -> Self {
        self.array_layer = array_layer;
        self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for ImageSubresource {
    type LowLevel = crate::native::vulkan1_0::ImageSubresource;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        crate::native::vulkan1_0::ImageSubresource {
            aspect_mask: self.aspect_mask.into_low_level(context, bump),
            mip_level: self.mip_level.into_low_level(context, bump),
            array_layer: self.array_layer.into_low_level(context, bump),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for ImageSubresource {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        Self {
            aspect_mask: crate::conv::FromLowLevel::from_low_level(context, value.aspect_mask),
            mip_level: crate::conv::FromLowLevel::from_low_level(context, value.mip_level),
            array_layer: crate::conv::FromLowLevel::from_low_level(context, value.array_layer),
        }
    }
}
impl ImageSubresourceLayers {
    ///Get a reference to the `aspect_mask` field.
    pub fn aspect_mask(&self) -> ImageAspectFlags {
        self.aspect_mask
    }
    ///Get a reference to the `mip_level` field.
    pub fn mip_level(&self) -> u32 {
        self.mip_level
    }
    ///Get a reference to the `base_array_layer` field.
    pub fn base_array_layer(&self) -> u32 {
        self.base_array_layer
    }
    ///Get a reference to the `layer_count` field.
    pub fn layer_count(&self) -> u32 {
        self.layer_count
    }
    ///Get a mutable reference to the `aspect_mask` field.
    pub fn aspect_mask_mut(&mut self) -> &mut ImageAspectFlags {
        &mut self.aspect_mask
    }
    ///Get a mutable reference to the `mip_level` field.
    pub fn mip_level_mut(&mut self) -> &mut u32 {
        &mut self.mip_level
    }
    ///Get a mutable reference to the `base_array_layer` field.
    pub fn base_array_layer_mut(&mut self) -> &mut u32 {
        &mut self.base_array_layer
    }
    ///Get a mutable reference to the `layer_count` field.
    pub fn layer_count_mut(&mut self) -> &mut u32 {
        &mut self.layer_count
    }
    ///Sets the `aspect_mask` field.
    pub fn set_aspect_mask(&mut self, aspect_mask: ImageAspectFlags) -> &mut Self {
        self.aspect_mask = aspect_mask;
        self
    }
    ///Sets the `mip_level` field.
    pub fn set_mip_level(&mut self, mip_level: u32) -> &mut Self {
        self.mip_level = mip_level;
        self
    }
    ///Sets the `base_array_layer` field.
    pub fn set_base_array_layer(&mut self, base_array_layer: u32) -> &mut Self {
        self.base_array_layer = base_array_layer;
        self
    }
    ///Sets the `layer_count` field.
    pub fn set_layer_count(&mut self, layer_count: u32) -> &mut Self {
        self.layer_count = layer_count;
        self
    }
    ///Sets the `aspect_mask` field in a builder way.
    pub fn with_aspect_mask(mut self, aspect_mask: ImageAspectFlags) -> Self {
        self.aspect_mask = aspect_mask;
        self
    }
    ///Sets the `mip_level` field in a builder way.
    pub fn with_mip_level(mut self, mip_level: u32) -> Self {
        self.mip_level = mip_level;
        self
    }
    ///Sets the `base_array_layer` field in a builder way.
    pub fn with_base_array_layer(mut self, base_array_layer: u32) -> Self {
        self.base_array_layer = base_array_layer;
        self
    }
    ///Sets the `layer_count` field in a builder way.
    pub fn with_layer_count(mut self, layer_count: u32) -> Self {
        self.layer_count = layer_count;
        self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for ImageSubresourceLayers {
    type LowLevel = crate::native::vulkan1_0::ImageSubresourceLayers;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        crate::native::vulkan1_0::ImageSubresourceLayers {
            aspect_mask: self.aspect_mask.into_low_level(context, bump),
            mip_level: self.mip_level.into_low_level(context, bump),
            base_array_layer: self.base_array_layer.into_low_level(context, bump),
            layer_count: self.layer_count.into_low_level(context, bump),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for ImageSubresourceLayers {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        Self {
            aspect_mask: crate::conv::FromLowLevel::from_low_level(context, value.aspect_mask),
            mip_level: crate::conv::FromLowLevel::from_low_level(context, value.mip_level),
            base_array_layer: crate::conv::FromLowLevel::from_low_level(context, value.base_array_layer),
            layer_count: crate::conv::FromLowLevel::from_low_level(context, value.layer_count),
        }
    }
}
impl ImageSubresourceRange {
    ///Get a reference to the `aspect_mask` field.
    pub fn aspect_mask(&self) -> ImageAspectFlags {
        self.aspect_mask
    }
    ///Get a reference to the `base_mip_level` field.
    pub fn base_mip_level(&self) -> u32 {
        self.base_mip_level
    }
    ///Get a reference to the `level_count` field.
    pub fn level_count(&self) -> u32 {
        self.level_count
    }
    ///Get a reference to the `base_array_layer` field.
    pub fn base_array_layer(&self) -> u32 {
        self.base_array_layer
    }
    ///Get a reference to the `layer_count` field.
    pub fn layer_count(&self) -> u32 {
        self.layer_count
    }
    ///Get a mutable reference to the `aspect_mask` field.
    pub fn aspect_mask_mut(&mut self) -> &mut ImageAspectFlags {
        &mut self.aspect_mask
    }
    ///Get a mutable reference to the `base_mip_level` field.
    pub fn base_mip_level_mut(&mut self) -> &mut u32 {
        &mut self.base_mip_level
    }
    ///Get a mutable reference to the `level_count` field.
    pub fn level_count_mut(&mut self) -> &mut u32 {
        &mut self.level_count
    }
    ///Get a mutable reference to the `base_array_layer` field.
    pub fn base_array_layer_mut(&mut self) -> &mut u32 {
        &mut self.base_array_layer
    }
    ///Get a mutable reference to the `layer_count` field.
    pub fn layer_count_mut(&mut self) -> &mut u32 {
        &mut self.layer_count
    }
    ///Sets the `aspect_mask` field.
    pub fn set_aspect_mask(&mut self, aspect_mask: ImageAspectFlags) -> &mut Self {
        self.aspect_mask = aspect_mask;
        self
    }
    ///Sets the `base_mip_level` field.
    pub fn set_base_mip_level(&mut self, base_mip_level: u32) -> &mut Self {
        self.base_mip_level = base_mip_level;
        self
    }
    ///Sets the `level_count` field.
    pub fn set_level_count(&mut self, level_count: u32) -> &mut Self {
        self.level_count = level_count;
        self
    }
    ///Sets the `base_array_layer` field.
    pub fn set_base_array_layer(&mut self, base_array_layer: u32) -> &mut Self {
        self.base_array_layer = base_array_layer;
        self
    }
    ///Sets the `layer_count` field.
    pub fn set_layer_count(&mut self, layer_count: u32) -> &mut Self {
        self.layer_count = layer_count;
        self
    }
    ///Sets the `aspect_mask` field in a builder way.
    pub fn with_aspect_mask(mut self, aspect_mask: ImageAspectFlags) -> Self {
        self.aspect_mask = aspect_mask;
        self
    }
    ///Sets the `base_mip_level` field in a builder way.
    pub fn with_base_mip_level(mut self, base_mip_level: u32) -> Self {
        self.base_mip_level = base_mip_level;
        self
    }
    ///Sets the `level_count` field in a builder way.
    pub fn with_level_count(mut self, level_count: u32) -> Self {
        self.level_count = level_count;
        self
    }
    ///Sets the `base_array_layer` field in a builder way.
    pub fn with_base_array_layer(mut self, base_array_layer: u32) -> Self {
        self.base_array_layer = base_array_layer;
        self
    }
    ///Sets the `layer_count` field in a builder way.
    pub fn with_layer_count(mut self, layer_count: u32) -> Self {
        self.layer_count = layer_count;
        self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for ImageSubresourceRange {
    type LowLevel = crate::native::vulkan1_0::ImageSubresourceRange;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        crate::native::vulkan1_0::ImageSubresourceRange {
            aspect_mask: self.aspect_mask.into_low_level(context, bump),
            base_mip_level: self.base_mip_level.into_low_level(context, bump),
            level_count: self.level_count.into_low_level(context, bump),
            base_array_layer: self.base_array_layer.into_low_level(context, bump),
            layer_count: self.layer_count.into_low_level(context, bump),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for ImageSubresourceRange {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        Self {
            aspect_mask: crate::conv::FromLowLevel::from_low_level(context, value.aspect_mask),
            base_mip_level: crate::conv::FromLowLevel::from_low_level(context, value.base_mip_level),
            level_count: crate::conv::FromLowLevel::from_low_level(context, value.level_count),
            base_array_layer: crate::conv::FromLowLevel::from_low_level(context, value.base_array_layer),
            layer_count: crate::conv::FromLowLevel::from_low_level(context, value.layer_count),
        }
    }
}
#[doc(alias = "VkMemoryBarrier")]
#[derive(Clone, PartialEq, Debug, Copy, Default)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct MemoryBarrier {
    #[doc(alias = "srcAccessMask")]
    pub src_access_mask: AccessFlags,
    #[doc(alias = "dstAccessMask")]
    pub dst_access_mask: AccessFlags,
}
impl MemoryBarrier {
    ///Get a reference to the `src_access_mask` field.
    pub fn src_access_mask(&self) -> AccessFlags {
        self.src_access_mask
    }
    ///Get a reference to the `dst_access_mask` field.
    pub fn dst_access_mask(&self) -> AccessFlags {
        self.dst_access_mask
    }
    ///Get a mutable reference to the `src_access_mask` field.
    pub fn src_access_mask_mut(&mut self) -> &mut AccessFlags {
        &mut self.src_access_mask
    }
    ///Get a mutable reference to the `dst_access_mask` field.
    pub fn dst_access_mask_mut(&mut self) -> &mut AccessFlags {
        &mut self.dst_access_mask
    }
    ///Sets the `src_access_mask` field.
    pub fn set_src_access_mask(&mut self, src_access_mask: AccessFlags) -> &mut Self {
        self.src_access_mask = src_access_mask;
        self
    }
    ///Sets the `dst_access_mask` field.
    pub fn set_dst_access_mask(&mut self, dst_access_mask: AccessFlags) -> &mut Self {
        self.dst_access_mask = dst_access_mask;
        self
    }
    ///Sets the `src_access_mask` field in a builder way.
    pub fn with_src_access_mask(mut self, src_access_mask: AccessFlags) -> Self {
        self.src_access_mask = src_access_mask;
        self
    }
    ///Sets the `dst_access_mask` field in a builder way.
    pub fn with_dst_access_mask(mut self, dst_access_mask: AccessFlags) -> Self {
        self.dst_access_mask = dst_access_mask;
        self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for MemoryBarrier {
    type LowLevel = crate::native::vulkan1_0::MemoryBarrier;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        crate::native::vulkan1_0::MemoryBarrier {
            s_type: StructureType::MemoryBarrier,
            p_next: std::ptr::null(),
            src_access_mask: self.src_access_mask.into_low_level(context, bump),
            dst_access_mask: self.dst_access_mask.into_low_level(context, bump),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for MemoryBarrier {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        Self {
            src_access_mask: crate::conv::FromLowLevel::from_low_level(context, value.src_access_mask),
            dst_access_mask: crate::conv::FromLowLevel::from_low_level(context, value.dst_access_mask),
        }
    }
}
#[doc(alias = "VkBufferMemoryBarrier")]
#[derive(Clone, PartialEq, Debug)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct BufferMemoryBarrier {
    #[doc(alias = "srcAccessMask")]
    pub src_access_mask: AccessFlags,
    #[doc(alias = "dstAccessMask")]
    pub dst_access_mask: AccessFlags,
    #[doc(alias = "srcQueueFamilyIndex")]
    pub src_queue_family_index: u32,
    #[doc(alias = "dstQueueFamilyIndex")]
    pub dst_queue_family_index: u32,
    pub buffer: Buffer,
    pub offset: DeviceSize,
    pub size: DeviceSize,
}
impl BufferMemoryBarrier {
    ///Get a reference to the `src_access_mask` field.
    pub fn src_access_mask(&self) -> AccessFlags {
        self.src_access_mask
    }
    ///Get a reference to the `dst_access_mask` field.
    pub fn dst_access_mask(&self) -> AccessFlags {
        self.dst_access_mask
    }
    ///Get a reference to the `src_queue_family_index` field.
    pub fn src_queue_family_index(&self) -> u32 {
        self.src_queue_family_index
    }
    ///Get a reference to the `dst_queue_family_index` field.
    pub fn dst_queue_family_index(&self) -> u32 {
        self.dst_queue_family_index
    }
    ///Get a reference to the `buffer` field.
    pub fn buffer(&self) -> &Buffer {
        &self.buffer
    }
    ///Get a reference to the `offset` field.
    pub fn offset(&self) -> &DeviceSize {
        &self.offset
    }
    ///Get a reference to the `size` field.
    pub fn size(&self) -> &DeviceSize {
        &self.size
    }
    ///Get a mutable reference to the `src_access_mask` field.
    pub fn src_access_mask_mut(&mut self) -> &mut AccessFlags {
        &mut self.src_access_mask
    }
    ///Get a mutable reference to the `dst_access_mask` field.
    pub fn dst_access_mask_mut(&mut self) -> &mut AccessFlags {
        &mut self.dst_access_mask
    }
    ///Get a mutable reference to the `src_queue_family_index` field.
    pub fn src_queue_family_index_mut(&mut self) -> &mut u32 {
        &mut self.src_queue_family_index
    }
    ///Get a mutable reference to the `dst_queue_family_index` field.
    pub fn dst_queue_family_index_mut(&mut self) -> &mut u32 {
        &mut self.dst_queue_family_index
    }
    ///Get a mutable reference to the `buffer` field.
    pub fn buffer_mut(&mut self) -> &mut Buffer {
        &mut self.buffer
    }
    ///Get a mutable reference to the `offset` field.
    pub fn offset_mut(&mut self) -> &mut DeviceSize {
        &mut self.offset
    }
    ///Get a mutable reference to the `size` field.
    pub fn size_mut(&mut self) -> &mut DeviceSize {
        &mut self.size
    }
    ///Sets the `src_access_mask` field.
    pub fn set_src_access_mask(&mut self, src_access_mask: AccessFlags) -> &mut Self {
        self.src_access_mask = src_access_mask;
        self
    }
    ///Sets the `dst_access_mask` field.
    pub fn set_dst_access_mask(&mut self, dst_access_mask: AccessFlags) -> &mut Self {
        self.dst_access_mask = dst_access_mask;
        self
    }
    ///Sets the `src_queue_family_index` field.
    pub fn set_src_queue_family_index(&mut self, src_queue_family_index: u32) -> &mut Self {
        self.src_queue_family_index = src_queue_family_index;
        self
    }
    ///Sets the `dst_queue_family_index` field.
    pub fn set_dst_queue_family_index(&mut self, dst_queue_family_index: u32) -> &mut Self {
        self.dst_queue_family_index = dst_queue_family_index;
        self
    }
    ///Sets the `buffer` field.
    pub fn set_buffer(&mut self, buffer: Buffer) -> &mut Self {
        self.buffer = buffer;
        self
    }
    ///Sets the `offset` field.
    pub fn set_offset(&mut self, offset: DeviceSize) -> &mut Self {
        self.offset = offset;
        self
    }
    ///Sets the `size` field.
    pub fn set_size(&mut self, size: DeviceSize) -> &mut Self {
        self.size = size;
        self
    }
    ///Sets the `src_access_mask` field in a builder way.
    pub fn with_src_access_mask(mut self, src_access_mask: AccessFlags) -> Self {
        self.src_access_mask = src_access_mask;
        self
    }
    ///Sets the `dst_access_mask` field in a builder way.
    pub fn with_dst_access_mask(mut self, dst_access_mask: AccessFlags) -> Self {
        self.dst_access_mask = dst_access_mask;
        self
    }
    ///Sets the `src_queue_family_index` field in a builder way.
    pub fn with_src_queue_family_index(mut self, src_queue_family_index: u32) -> Self {
        self.src_queue_family_index = src_queue_family_index;
        self
    }
    ///Sets the `dst_queue_family_index` field in a builder way.
    pub fn with_dst_queue_family_index(mut self, dst_queue_family_index: u32) -> Self {
        self.dst_queue_family_index = dst_queue_family_index;
        self
    }
    ///Sets the `buffer` field in a builder way.
    pub fn with_buffer(mut self, buffer: Buffer) -> Self {
        self.buffer = buffer;
        self
    }
    ///Sets the `offset` field in a builder way.
    pub fn with_offset(mut self, offset: DeviceSize) -> Self {
        self.offset = offset;
        self
    }
    ///Sets the `size` field in a builder way.
    pub fn with_size(mut self, size: DeviceSize) -> Self {
        self.size = size;
        self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for BufferMemoryBarrier {
    type LowLevel = crate::native::vulkan1_0::BufferMemoryBarrier;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        crate::native::vulkan1_0::BufferMemoryBarrier {
            s_type: StructureType::BufferMemoryBarrier,
            p_next: std::ptr::null(),
            src_access_mask: self.src_access_mask.into_low_level(context, bump),
            dst_access_mask: self.dst_access_mask.into_low_level(context, bump),
            src_queue_family_index: self.src_queue_family_index.into_low_level(context, bump),
            dst_queue_family_index: self.dst_queue_family_index.into_low_level(context, bump),
            buffer: self.buffer.into_low_level(context, bump),
            offset: self.offset.into_low_level(context, bump),
            size: self.size.into_low_level(context, bump),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for BufferMemoryBarrier {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        Self {
            src_access_mask: crate::conv::FromLowLevel::from_low_level(context, value.src_access_mask),
            dst_access_mask: crate::conv::FromLowLevel::from_low_level(context, value.dst_access_mask),
            src_queue_family_index: crate::conv::FromLowLevel::from_low_level(context, value.src_queue_family_index),
            dst_queue_family_index: crate::conv::FromLowLevel::from_low_level(context, value.dst_queue_family_index),
            buffer: crate::conv::FromLowLevel::from_low_level(context, value.buffer),
            offset: crate::conv::FromLowLevel::from_low_level(context, value.offset),
            size: crate::conv::FromLowLevel::from_low_level(context, value.size),
        }
    }
}
#[doc(alias = "VkImageMemoryBarrier")]
#[derive(Clone, PartialEq, Debug)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct ImageMemoryBarrier {
    #[doc(alias = "pNext")]
    pub extensions: SmallVec<[ImageMemoryBarrierExtension; 1]>,
    #[doc(alias = "srcAccessMask")]
    pub src_access_mask: AccessFlags,
    #[doc(alias = "dstAccessMask")]
    pub dst_access_mask: AccessFlags,
    #[doc(alias = "oldLayout")]
    pub old_layout: ImageLayout,
    #[doc(alias = "newLayout")]
    pub new_layout: ImageLayout,
    #[doc(alias = "srcQueueFamilyIndex")]
    pub src_queue_family_index: u32,
    #[doc(alias = "dstQueueFamilyIndex")]
    pub dst_queue_family_index: u32,
    pub image: Image,
    #[doc(alias = "subresourceRange")]
    pub subresource_range: ImageSubresourceRange,
}
impl ImageMemoryBarrier {
    ///Adds an extension to the struct
    pub fn with_extension(mut self, ext: impl Into<ImageMemoryBarrierExtension>) -> Self {
        self.extensions.push(ext.into());
        self
    }
    ///Get a reference to the `extensions` field.
    pub fn extensions(&self) -> &SmallVec<[ImageMemoryBarrierExtension; 1]> {
        &self.extensions
    }
    ///Get a reference to the `src_access_mask` field.
    pub fn src_access_mask(&self) -> AccessFlags {
        self.src_access_mask
    }
    ///Get a reference to the `dst_access_mask` field.
    pub fn dst_access_mask(&self) -> AccessFlags {
        self.dst_access_mask
    }
    ///Get a reference to the `old_layout` field.
    pub fn old_layout(&self) -> ImageLayout {
        self.old_layout
    }
    ///Get a reference to the `new_layout` field.
    pub fn new_layout(&self) -> ImageLayout {
        self.new_layout
    }
    ///Get a reference to the `src_queue_family_index` field.
    pub fn src_queue_family_index(&self) -> u32 {
        self.src_queue_family_index
    }
    ///Get a reference to the `dst_queue_family_index` field.
    pub fn dst_queue_family_index(&self) -> u32 {
        self.dst_queue_family_index
    }
    ///Get a reference to the `image` field.
    pub fn image(&self) -> &Image {
        &self.image
    }
    ///Get a reference to the `subresource_range` field.
    pub fn subresource_range(&self) -> ImageSubresourceRange {
        self.subresource_range
    }
    ///Get a mutable reference to the `extensions` field.
    pub fn extensions_mut(&mut self) -> &mut SmallVec<[ImageMemoryBarrierExtension; 1]> {
        &mut self.extensions
    }
    ///Get a mutable reference to the `src_access_mask` field.
    pub fn src_access_mask_mut(&mut self) -> &mut AccessFlags {
        &mut self.src_access_mask
    }
    ///Get a mutable reference to the `dst_access_mask` field.
    pub fn dst_access_mask_mut(&mut self) -> &mut AccessFlags {
        &mut self.dst_access_mask
    }
    ///Get a mutable reference to the `old_layout` field.
    pub fn old_layout_mut(&mut self) -> &mut ImageLayout {
        &mut self.old_layout
    }
    ///Get a mutable reference to the `new_layout` field.
    pub fn new_layout_mut(&mut self) -> &mut ImageLayout {
        &mut self.new_layout
    }
    ///Get a mutable reference to the `src_queue_family_index` field.
    pub fn src_queue_family_index_mut(&mut self) -> &mut u32 {
        &mut self.src_queue_family_index
    }
    ///Get a mutable reference to the `dst_queue_family_index` field.
    pub fn dst_queue_family_index_mut(&mut self) -> &mut u32 {
        &mut self.dst_queue_family_index
    }
    ///Get a mutable reference to the `image` field.
    pub fn image_mut(&mut self) -> &mut Image {
        &mut self.image
    }
    ///Get a mutable reference to the `subresource_range` field.
    pub fn subresource_range_mut(&mut self) -> &mut ImageSubresourceRange {
        &mut self.subresource_range
    }
    ///Sets the `extensions` field.
    pub fn set_extensions(&mut self, extensions: SmallVec<[ImageMemoryBarrierExtension; 1]>) -> &mut Self {
        self.extensions = extensions;
        self
    }
    ///Sets the `src_access_mask` field.
    pub fn set_src_access_mask(&mut self, src_access_mask: AccessFlags) -> &mut Self {
        self.src_access_mask = src_access_mask;
        self
    }
    ///Sets the `dst_access_mask` field.
    pub fn set_dst_access_mask(&mut self, dst_access_mask: AccessFlags) -> &mut Self {
        self.dst_access_mask = dst_access_mask;
        self
    }
    ///Sets the `old_layout` field.
    pub fn set_old_layout(&mut self, old_layout: ImageLayout) -> &mut Self {
        self.old_layout = old_layout;
        self
    }
    ///Sets the `new_layout` field.
    pub fn set_new_layout(&mut self, new_layout: ImageLayout) -> &mut Self {
        self.new_layout = new_layout;
        self
    }
    ///Sets the `src_queue_family_index` field.
    pub fn set_src_queue_family_index(&mut self, src_queue_family_index: u32) -> &mut Self {
        self.src_queue_family_index = src_queue_family_index;
        self
    }
    ///Sets the `dst_queue_family_index` field.
    pub fn set_dst_queue_family_index(&mut self, dst_queue_family_index: u32) -> &mut Self {
        self.dst_queue_family_index = dst_queue_family_index;
        self
    }
    ///Sets the `image` field.
    pub fn set_image(&mut self, image: Image) -> &mut Self {
        self.image = image;
        self
    }
    ///Sets the `subresource_range` field.
    pub fn set_subresource_range(&mut self, subresource_range: ImageSubresourceRange) -> &mut Self {
        self.subresource_range = subresource_range;
        self
    }
    ///Sets the `extensions` field in a builder way.
    pub fn with_extensions(mut self, extensions: SmallVec<[ImageMemoryBarrierExtension; 1]>) -> Self {
        self.extensions = extensions;
        self
    }
    ///Sets the `src_access_mask` field in a builder way.
    pub fn with_src_access_mask(mut self, src_access_mask: AccessFlags) -> Self {
        self.src_access_mask = src_access_mask;
        self
    }
    ///Sets the `dst_access_mask` field in a builder way.
    pub fn with_dst_access_mask(mut self, dst_access_mask: AccessFlags) -> Self {
        self.dst_access_mask = dst_access_mask;
        self
    }
    ///Sets the `old_layout` field in a builder way.
    pub fn with_old_layout(mut self, old_layout: ImageLayout) -> Self {
        self.old_layout = old_layout;
        self
    }
    ///Sets the `new_layout` field in a builder way.
    pub fn with_new_layout(mut self, new_layout: ImageLayout) -> Self {
        self.new_layout = new_layout;
        self
    }
    ///Sets the `src_queue_family_index` field in a builder way.
    pub fn with_src_queue_family_index(mut self, src_queue_family_index: u32) -> Self {
        self.src_queue_family_index = src_queue_family_index;
        self
    }
    ///Sets the `dst_queue_family_index` field in a builder way.
    pub fn with_dst_queue_family_index(mut self, dst_queue_family_index: u32) -> Self {
        self.dst_queue_family_index = dst_queue_family_index;
        self
    }
    ///Sets the `image` field in a builder way.
    pub fn with_image(mut self, image: Image) -> Self {
        self.image = image;
        self
    }
    ///Sets the `subresource_range` field in a builder way.
    pub fn with_subresource_range(mut self, subresource_range: ImageSubresourceRange) -> Self {
        self.subresource_range = subresource_range;
        self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for ImageMemoryBarrier {
    type LowLevel = crate::native::vulkan1_0::ImageMemoryBarrier;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        let mut next = std::ptr::null();
        let mut extensions = self.extensions.iter();
        while let Some(ext) = extensions.next() {
            let ext = ext.into_low_level(context, bump);
            (*ext).next = next;
            next = ext;
        }
        crate::native::vulkan1_0::ImageMemoryBarrier {
            s_type: StructureType::ImageMemoryBarrier,
            p_next: next,
            src_access_mask: self.src_access_mask.into_low_level(context, bump),
            dst_access_mask: self.dst_access_mask.into_low_level(context, bump),
            old_layout: self.old_layout.into_low_level(context, bump),
            new_layout: self.new_layout.into_low_level(context, bump),
            src_queue_family_index: self.src_queue_family_index.into_low_level(context, bump),
            dst_queue_family_index: self.dst_queue_family_index.into_low_level(context, bump),
            image: self.image.into_low_level(context, bump),
            subresource_range: self.subresource_range.into_low_level(context, bump),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for ImageMemoryBarrier {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        let mut next = value.p_next;
        let mut extensions = SmallVec::new();
        while !next.is_null() {
            extensions.push(crate::conv::FromLowLevel::from_low_level(context, next));
            next = std::ptr::read(next).next;
        }
        Self {
            extensions: extensions,
            src_access_mask: crate::conv::FromLowLevel::from_low_level(context, value.src_access_mask),
            dst_access_mask: crate::conv::FromLowLevel::from_low_level(context, value.dst_access_mask),
            old_layout: crate::conv::FromLowLevel::from_low_level(context, value.old_layout),
            new_layout: crate::conv::FromLowLevel::from_low_level(context, value.new_layout),
            src_queue_family_index: crate::conv::FromLowLevel::from_low_level(context, value.src_queue_family_index),
            dst_queue_family_index: crate::conv::FromLowLevel::from_low_level(context, value.dst_queue_family_index),
            image: crate::conv::FromLowLevel::from_low_level(context, value.image),
            subresource_range: crate::conv::FromLowLevel::from_low_level(context, value.subresource_range),
        }
    }
}
#[derive(Clone, PartialEq, Debug)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
///Extensions for [`ImageMemoryBarrier`]
pub enum ImageMemoryBarrierExtension {
    #[cfg(feature = "VK_EXT_sample_locations")]
    ///Contains a type [`SampleLocationsInfoEXT`] for extending [`ImageMemoryBarrier`]
    SampleLocationsInfoEXT(SampleLocationsInfoEXT),
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for ImageMemoryBarrierExtension {
    type LowLevel = *const crate::native::vulkan1_0::BaseInStructure;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        match self {
            #[cfg(feature = "VK_EXT_sample_locations")]
            Self::SampleLocationsInfoEXT(ext) => (bump.alloc(ext.into_low_level(context, bump))
                as *mut crate::native::extensions::ext_sample_locations::SampleLocationsInfoEXT)
                .cast(),
            other => unreachable!("unexpected variant {:?}", other),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for ImageMemoryBarrierExtension {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        assert!(!value.is_null());
        match (*value).s_type {
            #[cfg(feature = "VK_EXT_sample_locations")]
            crate::native::vulkan1_0::StructureType::SampleLocationsInfoExt => {
                Self::SampleLocationsInfoEXT(SampleLocationsInfoEXT::from_low_level(
                    context,
                    std::ptr::read(
                        value.cast::<crate::native::extensions::ext_sample_locations::SampleLocationsInfoEXT>(),
                    ),
                ))
            },
            other => panic!(
                "Structure type {:?} is not a member of {}",
                other,
                stringify!(ImageMemoryBarrier)
            ),
        }
    }
}
#[cfg(feature = "VK_EXT_sample_locations")]
impl From<SampleLocationsInfoEXT> for ImageMemoryBarrierExtension {
    fn from(ext: SampleLocationsInfoEXT) -> Self {
        Self::SampleLocationsInfoEXT(ext)
    }
}
#[cfg(feature = "VK_EXT_sample_locations")]
impl TryInto<SampleLocationsInfoEXT> for ImageMemoryBarrierExtension {
    type Error = ImageMemoryBarrierExtension;
    fn try_into(self) -> Result<SampleLocationsInfoEXT, Self::Error> {
        match self {
            Self::SampleLocationsInfoEXT(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[doc(alias = "VkImageCreateInfo")]
#[derive(Clone, PartialEq, Debug, Default)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct ImageCreateInfo {
    #[doc(alias = "pNext")]
    pub extensions: SmallVec<[ImageCreateInfoExtension; 1]>,
    pub flags: ImageCreateFlags,
    #[doc(alias = "imageType")]
    pub image_type: ImageType,
    pub format: Format,
    pub extent: Extent3D,
    #[doc(alias = "mipLevels")]
    pub mip_levels: u32,
    #[doc(alias = "arrayLayers")]
    pub array_layers: u32,
    pub samples: SampleCountFlagBits,
    pub tiling: ImageTiling,
    pub usage: ImageUsageFlags,
    #[doc(alias = "sharingMode")]
    pub sharing_mode: SharingMode,
    #[doc(alias = "pQueueFamilyIndices")]
    pub queue_family_indices: SmallVec<[u32; 8]>,
    #[doc(alias = "initialLayout")]
    pub initial_layout: ImageLayout,
}
impl ImageCreateInfo {
    ///Adds an extension to the struct
    pub fn with_extension(mut self, ext: impl Into<ImageCreateInfoExtension>) -> Self {
        self.extensions.push(ext.into());
        self
    }
    ///Get a reference to the `extensions` field.
    pub fn extensions(&self) -> &SmallVec<[ImageCreateInfoExtension; 1]> {
        &self.extensions
    }
    ///Get a reference to the `flags` field.
    pub fn flags(&self) -> ImageCreateFlags {
        self.flags
    }
    ///Get a reference to the `image_type` field.
    pub fn image_type(&self) -> ImageType {
        self.image_type
    }
    ///Get a reference to the `format` field.
    pub fn format(&self) -> Format {
        self.format
    }
    ///Get a reference to the `extent` field.
    pub fn extent(&self) -> Extent3D {
        self.extent
    }
    ///Get a reference to the `mip_levels` field.
    pub fn mip_levels(&self) -> u32 {
        self.mip_levels
    }
    ///Get a reference to the `array_layers` field.
    pub fn array_layers(&self) -> u32 {
        self.array_layers
    }
    ///Get a reference to the `samples` field.
    pub fn samples(&self) -> SampleCountFlagBits {
        self.samples
    }
    ///Get a reference to the `tiling` field.
    pub fn tiling(&self) -> ImageTiling {
        self.tiling
    }
    ///Get a reference to the `usage` field.
    pub fn usage(&self) -> ImageUsageFlags {
        self.usage
    }
    ///Get a reference to the `sharing_mode` field.
    pub fn sharing_mode(&self) -> SharingMode {
        self.sharing_mode
    }
    ///Get a reference to the `queue_family_indices` field.
    pub fn queue_family_indices(&self) -> &SmallVec<[u32; 8]> {
        &self.queue_family_indices
    }
    ///Get a reference to the `initial_layout` field.
    pub fn initial_layout(&self) -> ImageLayout {
        self.initial_layout
    }
    ///Get a mutable reference to the `extensions` field.
    pub fn extensions_mut(&mut self) -> &mut SmallVec<[ImageCreateInfoExtension; 1]> {
        &mut self.extensions
    }
    ///Get a mutable reference to the `flags` field.
    pub fn flags_mut(&mut self) -> &mut ImageCreateFlags {
        &mut self.flags
    }
    ///Get a mutable reference to the `image_type` field.
    pub fn image_type_mut(&mut self) -> &mut ImageType {
        &mut self.image_type
    }
    ///Get a mutable reference to the `format` field.
    pub fn format_mut(&mut self) -> &mut Format {
        &mut self.format
    }
    ///Get a mutable reference to the `extent` field.
    pub fn extent_mut(&mut self) -> &mut Extent3D {
        &mut self.extent
    }
    ///Get a mutable reference to the `mip_levels` field.
    pub fn mip_levels_mut(&mut self) -> &mut u32 {
        &mut self.mip_levels
    }
    ///Get a mutable reference to the `array_layers` field.
    pub fn array_layers_mut(&mut self) -> &mut u32 {
        &mut self.array_layers
    }
    ///Get a mutable reference to the `samples` field.
    pub fn samples_mut(&mut self) -> &mut SampleCountFlagBits {
        &mut self.samples
    }
    ///Get a mutable reference to the `tiling` field.
    pub fn tiling_mut(&mut self) -> &mut ImageTiling {
        &mut self.tiling
    }
    ///Get a mutable reference to the `usage` field.
    pub fn usage_mut(&mut self) -> &mut ImageUsageFlags {
        &mut self.usage
    }
    ///Get a mutable reference to the `sharing_mode` field.
    pub fn sharing_mode_mut(&mut self) -> &mut SharingMode {
        &mut self.sharing_mode
    }
    ///Get a mutable reference to the `queue_family_indices` field.
    pub fn queue_family_indices_mut(&mut self) -> &mut SmallVec<[u32; 8]> {
        &mut self.queue_family_indices
    }
    ///Get a mutable reference to the `initial_layout` field.
    pub fn initial_layout_mut(&mut self) -> &mut ImageLayout {
        &mut self.initial_layout
    }
    ///Sets the `extensions` field.
    pub fn set_extensions(&mut self, extensions: SmallVec<[ImageCreateInfoExtension; 1]>) -> &mut Self {
        self.extensions = extensions;
        self
    }
    ///Sets the `flags` field.
    pub fn set_flags(&mut self, flags: ImageCreateFlags) -> &mut Self {
        self.flags = flags;
        self
    }
    ///Sets the `image_type` field.
    pub fn set_image_type(&mut self, image_type: ImageType) -> &mut Self {
        self.image_type = image_type;
        self
    }
    ///Sets the `format` field.
    pub fn set_format(&mut self, format: Format) -> &mut Self {
        self.format = format;
        self
    }
    ///Sets the `extent` field.
    pub fn set_extent(&mut self, extent: Extent3D) -> &mut Self {
        self.extent = extent;
        self
    }
    ///Sets the `mip_levels` field.
    pub fn set_mip_levels(&mut self, mip_levels: u32) -> &mut Self {
        self.mip_levels = mip_levels;
        self
    }
    ///Sets the `array_layers` field.
    pub fn set_array_layers(&mut self, array_layers: u32) -> &mut Self {
        self.array_layers = array_layers;
        self
    }
    ///Sets the `samples` field.
    pub fn set_samples(&mut self, samples: SampleCountFlagBits) -> &mut Self {
        self.samples = samples;
        self
    }
    ///Sets the `tiling` field.
    pub fn set_tiling(&mut self, tiling: ImageTiling) -> &mut Self {
        self.tiling = tiling;
        self
    }
    ///Sets the `usage` field.
    pub fn set_usage(&mut self, usage: ImageUsageFlags) -> &mut Self {
        self.usage = usage;
        self
    }
    ///Sets the `sharing_mode` field.
    pub fn set_sharing_mode(&mut self, sharing_mode: SharingMode) -> &mut Self {
        self.sharing_mode = sharing_mode;
        self
    }
    ///Sets the `queue_family_indices` field.
    pub fn set_queue_family_indices(&mut self, queue_family_indices: SmallVec<[u32; 8]>) -> &mut Self {
        self.queue_family_indices = queue_family_indices;
        self
    }
    ///Sets the `initial_layout` field.
    pub fn set_initial_layout(&mut self, initial_layout: ImageLayout) -> &mut Self {
        self.initial_layout = initial_layout;
        self
    }
    ///Sets the `extensions` field in a builder way.
    pub fn with_extensions(mut self, extensions: SmallVec<[ImageCreateInfoExtension; 1]>) -> Self {
        self.extensions = extensions;
        self
    }
    ///Sets the `flags` field in a builder way.
    pub fn with_flags(mut self, flags: ImageCreateFlags) -> Self {
        self.flags = flags;
        self
    }
    ///Sets the `image_type` field in a builder way.
    pub fn with_image_type(mut self, image_type: ImageType) -> Self {
        self.image_type = image_type;
        self
    }
    ///Sets the `format` field in a builder way.
    pub fn with_format(mut self, format: Format) -> Self {
        self.format = format;
        self
    }
    ///Sets the `extent` field in a builder way.
    pub fn with_extent(mut self, extent: Extent3D) -> Self {
        self.extent = extent;
        self
    }
    ///Sets the `mip_levels` field in a builder way.
    pub fn with_mip_levels(mut self, mip_levels: u32) -> Self {
        self.mip_levels = mip_levels;
        self
    }
    ///Sets the `array_layers` field in a builder way.
    pub fn with_array_layers(mut self, array_layers: u32) -> Self {
        self.array_layers = array_layers;
        self
    }
    ///Sets the `samples` field in a builder way.
    pub fn with_samples(mut self, samples: SampleCountFlagBits) -> Self {
        self.samples = samples;
        self
    }
    ///Sets the `tiling` field in a builder way.
    pub fn with_tiling(mut self, tiling: ImageTiling) -> Self {
        self.tiling = tiling;
        self
    }
    ///Sets the `usage` field in a builder way.
    pub fn with_usage(mut self, usage: ImageUsageFlags) -> Self {
        self.usage = usage;
        self
    }
    ///Sets the `sharing_mode` field in a builder way.
    pub fn with_sharing_mode(mut self, sharing_mode: SharingMode) -> Self {
        self.sharing_mode = sharing_mode;
        self
    }
    ///Sets the `queue_family_indices` field in a builder way.
    pub fn with_queue_family_indices(mut self, queue_family_indices: SmallVec<[u32; 8]>) -> Self {
        self.queue_family_indices = queue_family_indices;
        self
    }
    ///Sets the `initial_layout` field in a builder way.
    pub fn with_initial_layout(mut self, initial_layout: ImageLayout) -> Self {
        self.initial_layout = initial_layout;
        self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for ImageCreateInfo {
    type LowLevel = crate::native::vulkan1_0::ImageCreateInfo;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        let mut next = std::ptr::null();
        let mut extensions = self.extensions.iter();
        while let Some(ext) = extensions.next() {
            let ext = ext.into_low_level(context, bump);
            (*ext).next = next;
            next = ext;
        }
        let len_queue_family_indices = self.queue_family_indices.len() as u32;
        let queue_family_indices = bump
            .alloc_slice_fill_iter(
                self.queue_family_indices
                    .iter()
                    .map(|x| x.into_low_level(context, bump)),
            )
            .as_ptr()
            .cast();
        crate::native::vulkan1_0::ImageCreateInfo {
            s_type: StructureType::ImageCreateInfo,
            p_next: next,
            flags: self.flags.into_low_level(context, bump),
            image_type: self.image_type.into_low_level(context, bump),
            format: self.format.into_low_level(context, bump),
            extent: self.extent.into_low_level(context, bump),
            mip_levels: self.mip_levels.into_low_level(context, bump),
            array_layers: self.array_layers.into_low_level(context, bump),
            samples: self.samples.into_low_level(context, bump),
            tiling: self.tiling.into_low_level(context, bump),
            usage: self.usage.into_low_level(context, bump),
            sharing_mode: self.sharing_mode.into_low_level(context, bump),
            queue_family_index_count: len_queue_family_indices,
            queue_family_indices: queue_family_indices,
            initial_layout: self.initial_layout.into_low_level(context, bump),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for ImageCreateInfo {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        let mut next = value.p_next;
        let mut extensions = SmallVec::new();
        while !next.is_null() {
            extensions.push(crate::conv::FromLowLevel::from_low_level(context, next));
            next = std::ptr::read(next).next;
        }
        let queue_family_indices_len = value.queue_family_index_count;
        let mut queue_family_indices = SmallVec::with_capacity(queue_family_indices_len as usize);
        for i in 0..queue_family_indices_len {
            queue_family_indices.push(crate::conv::FromLowLevel::from_low_level(
                context,
                value.queue_family_indices.add(i as usize).read(),
            ));
        }
        Self {
            extensions: extensions,
            flags: crate::conv::FromLowLevel::from_low_level(context, value.flags),
            image_type: crate::conv::FromLowLevel::from_low_level(context, value.image_type),
            format: crate::conv::FromLowLevel::from_low_level(context, value.format),
            extent: crate::conv::FromLowLevel::from_low_level(context, value.extent),
            mip_levels: crate::conv::FromLowLevel::from_low_level(context, value.mip_levels),
            array_layers: crate::conv::FromLowLevel::from_low_level(context, value.array_layers),
            samples: crate::conv::FromLowLevel::from_low_level(context, value.samples),
            tiling: crate::conv::FromLowLevel::from_low_level(context, value.tiling),
            usage: crate::conv::FromLowLevel::from_low_level(context, value.usage),
            sharing_mode: crate::conv::FromLowLevel::from_low_level(context, value.sharing_mode),
            queue_family_indices: queue_family_indices,
            initial_layout: crate::conv::FromLowLevel::from_low_level(context, value.initial_layout),
        }
    }
}
#[derive(Clone, PartialEq, Debug)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
///Extensions for [`ImageCreateInfo`]
pub enum ImageCreateInfoExtension {
    #[cfg(feature = "VK_NV_dedicated_allocation")]
    ///Contains a type [`DedicatedAllocationImageCreateInfoNV`] for extending [`ImageCreateInfo`]
    DedicatedAllocationImageCreateInfoNV(DedicatedAllocationImageCreateInfoNV),
    #[cfg(feature = "VK_NV_external_memory")]
    ///Contains a type [`ExternalMemoryImageCreateInfoNV`] for extending [`ImageCreateInfo`]
    ExternalMemoryImageCreateInfoNV(ExternalMemoryImageCreateInfoNV),
    ///Contains a type [`ExternalMemoryImageCreateInfo`] for extending [`ImageCreateInfo`]
    ExternalMemoryImageCreateInfo(ExternalMemoryImageCreateInfo),
    #[cfg(feature = "VK_KHR_device_group")]
    ///Contains a type [`ImageSwapchainCreateInfoKHR`] for extending [`ImageCreateInfo`]
    ImageSwapchainCreateInfoKHR(ImageSwapchainCreateInfoKHR),
    #[cfg(feature = "VULKAN_1_2")]
    ///Contains a type [`ImageFormatListCreateInfo`] for extending [`ImageCreateInfo`]
    ImageFormatListCreateInfo(ImageFormatListCreateInfo),
    #[cfg(feature = "VK_ANDROID_external_memory_android_hardware_buffer")]
    ///Contains a type [`ExternalFormatANDROID`] for extending [`ImageCreateInfo`]
    ExternalFormatANDROID(ExternalFormatANDROID),
    #[cfg(feature = "VK_EXT_image_drm_format_modifier")]
    ///Contains a type [`ImageDrmFormatModifierListCreateInfoEXT`] for extending
    /// [`ImageCreateInfo`]
    ImageDrmFormatModifierListCreateInfoEXT(ImageDrmFormatModifierListCreateInfoEXT),
    #[cfg(feature = "VK_EXT_image_drm_format_modifier")]
    ///Contains a type [`ImageDrmFormatModifierExplicitCreateInfoEXT`] for extending
    /// [`ImageCreateInfo`]
    ImageDrmFormatModifierExplicitCreateInfoEXT(ImageDrmFormatModifierExplicitCreateInfoEXT),
    #[cfg(feature = "VULKAN_1_2")]
    ///Contains a type [`ImageStencilUsageCreateInfo`] for extending [`ImageCreateInfo`]
    ImageStencilUsageCreateInfo(ImageStencilUsageCreateInfo),
    #[cfg(feature = "VK_KHR_video_queue")]
    ///Contains a type [`VideoProfilesKHR`] for extending [`ImageCreateInfo`]
    VideoProfilesKHR(VideoProfilesKHR),
    #[cfg(feature = "VK_KHR_video_queue")]
    ///Contains a type [`VideoProfileKHR`] for extending [`ImageCreateInfo`]
    VideoProfileKHR(VideoProfileKHR),
    #[cfg(feature = "VK_FUCHSIA_buffer_collection")]
    ///Contains a type [`BufferCollectionImageCreateInfoFUCHSIA`] for extending [`ImageCreateInfo`]
    BufferCollectionImageCreateInfoFUCHSIA(BufferCollectionImageCreateInfoFUCHSIA),
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for ImageCreateInfoExtension {
    type LowLevel = *const crate::native::vulkan1_0::BaseInStructure;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        match self { # [cfg (feature = "VK_NV_dedicated_allocation")] Self :: DedicatedAllocationImageCreateInfoNV (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: nv_dedicated_allocation :: DedicatedAllocationImageCreateInfoNV) . cast () , # [cfg (feature = "VK_NV_external_memory")] Self :: ExternalMemoryImageCreateInfoNV (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: nv_external_memory :: ExternalMemoryImageCreateInfoNV) . cast () , Self :: ExternalMemoryImageCreateInfo (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: vulkan1_1 :: ExternalMemoryImageCreateInfo) . cast () , # [cfg (feature = "VK_KHR_device_group")] Self :: ImageSwapchainCreateInfoKHR (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: khr_device_group :: ImageSwapchainCreateInfoKHR) . cast () , # [cfg (feature = "VULKAN_1_2")] Self :: ImageFormatListCreateInfo (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: vulkan1_2 :: ImageFormatListCreateInfo) . cast () , # [cfg (feature = "VK_ANDROID_external_memory_android_hardware_buffer")] Self :: ExternalFormatANDROID (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: android_external_memory_android_hardware_buffer :: ExternalFormatANDROID) . cast () , # [cfg (feature = "VK_EXT_image_drm_format_modifier")] Self :: ImageDrmFormatModifierListCreateInfoEXT (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: ext_image_drm_format_modifier :: ImageDrmFormatModifierListCreateInfoEXT) . cast () , # [cfg (feature = "VK_EXT_image_drm_format_modifier")] Self :: ImageDrmFormatModifierExplicitCreateInfoEXT (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: ext_image_drm_format_modifier :: ImageDrmFormatModifierExplicitCreateInfoEXT) . cast () , # [cfg (feature = "VULKAN_1_2")] Self :: ImageStencilUsageCreateInfo (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: vulkan1_2 :: ImageStencilUsageCreateInfo) . cast () , # [cfg (feature = "VK_KHR_video_queue")] Self :: VideoProfilesKHR (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: khr_video_queue :: VideoProfilesKHR) . cast () , # [cfg (feature = "VK_KHR_video_queue")] Self :: VideoProfileKHR (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: khr_video_queue :: VideoProfileKHR) . cast () , # [cfg (feature = "VK_FUCHSIA_buffer_collection")] Self :: BufferCollectionImageCreateInfoFUCHSIA (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: fuchsia_buffer_collection :: BufferCollectionImageCreateInfoFUCHSIA) . cast () , other => unreachable ! ("unexpected variant {:?}" , other) }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for ImageCreateInfoExtension {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        assert!(!value.is_null());
        match (* value) . s_type { # [cfg (feature = "VK_NV_dedicated_allocation")] crate :: native :: vulkan1_0 :: StructureType :: DedicatedAllocationImageCreateInfoNv => Self :: DedicatedAllocationImageCreateInfoNV (DedicatedAllocationImageCreateInfoNV :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: nv_dedicated_allocation :: DedicatedAllocationImageCreateInfoNV > ()))) , # [cfg (feature = "VK_NV_external_memory")] crate :: native :: vulkan1_0 :: StructureType :: ExternalMemoryImageCreateInfoNv => Self :: ExternalMemoryImageCreateInfoNV (ExternalMemoryImageCreateInfoNV :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: nv_external_memory :: ExternalMemoryImageCreateInfoNV > ()))) , crate :: native :: vulkan1_0 :: StructureType :: ExternalMemoryImageCreateInfo => Self :: ExternalMemoryImageCreateInfo (ExternalMemoryImageCreateInfo :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: vulkan1_1 :: ExternalMemoryImageCreateInfo > ()))) , # [cfg (feature = "VK_KHR_device_group")] crate :: native :: vulkan1_0 :: StructureType :: ImageSwapchainCreateInfoKhr => Self :: ImageSwapchainCreateInfoKHR (ImageSwapchainCreateInfoKHR :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: khr_device_group :: ImageSwapchainCreateInfoKHR > ()))) , # [cfg (feature = "VULKAN_1_2")] crate :: native :: vulkan1_0 :: StructureType :: ImageFormatListCreateInfo => Self :: ImageFormatListCreateInfo (ImageFormatListCreateInfo :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: vulkan1_2 :: ImageFormatListCreateInfo > ()))) , # [cfg (feature = "VK_ANDROID_external_memory_android_hardware_buffer")] crate :: native :: vulkan1_0 :: StructureType :: ExternalFormatAndroid => Self :: ExternalFormatANDROID (ExternalFormatANDROID :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: android_external_memory_android_hardware_buffer :: ExternalFormatANDROID > ()))) , # [cfg (feature = "VK_EXT_image_drm_format_modifier")] crate :: native :: vulkan1_0 :: StructureType :: ImageDrmFormatModifierListCreateInfoExt => Self :: ImageDrmFormatModifierListCreateInfoEXT (ImageDrmFormatModifierListCreateInfoEXT :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: ext_image_drm_format_modifier :: ImageDrmFormatModifierListCreateInfoEXT > ()))) , # [cfg (feature = "VK_EXT_image_drm_format_modifier")] crate :: native :: vulkan1_0 :: StructureType :: ImageDrmFormatModifierExplicitCreateInfoExt => Self :: ImageDrmFormatModifierExplicitCreateInfoEXT (ImageDrmFormatModifierExplicitCreateInfoEXT :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: ext_image_drm_format_modifier :: ImageDrmFormatModifierExplicitCreateInfoEXT > ()))) , # [cfg (feature = "VULKAN_1_2")] crate :: native :: vulkan1_0 :: StructureType :: ImageStencilUsageCreateInfo => Self :: ImageStencilUsageCreateInfo (ImageStencilUsageCreateInfo :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: vulkan1_2 :: ImageStencilUsageCreateInfo > ()))) , # [cfg (feature = "VK_KHR_video_queue")] crate :: native :: vulkan1_0 :: StructureType :: VideoProfilesKhr => Self :: VideoProfilesKHR (VideoProfilesKHR :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: khr_video_queue :: VideoProfilesKHR > ()))) , # [cfg (feature = "VK_KHR_video_queue")] crate :: native :: vulkan1_0 :: StructureType :: VideoProfileKhr => Self :: VideoProfileKHR (VideoProfileKHR :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: khr_video_queue :: VideoProfileKHR > ()))) , # [cfg (feature = "VK_FUCHSIA_buffer_collection")] crate :: native :: vulkan1_0 :: StructureType :: BufferCollectionImageCreateInfoFuchsia => Self :: BufferCollectionImageCreateInfoFUCHSIA (BufferCollectionImageCreateInfoFUCHSIA :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: fuchsia_buffer_collection :: BufferCollectionImageCreateInfoFUCHSIA > ()))) , other => panic ! ("Structure type {:?} is not a member of {}" , other , stringify ! (ImageCreateInfo)) }
    }
}
#[cfg(feature = "VK_NV_dedicated_allocation")]
impl From<DedicatedAllocationImageCreateInfoNV> for ImageCreateInfoExtension {
    fn from(ext: DedicatedAllocationImageCreateInfoNV) -> Self {
        Self::DedicatedAllocationImageCreateInfoNV(ext)
    }
}
#[cfg(feature = "VK_NV_dedicated_allocation")]
impl TryInto<DedicatedAllocationImageCreateInfoNV> for ImageCreateInfoExtension {
    type Error = ImageCreateInfoExtension;
    fn try_into(self) -> Result<DedicatedAllocationImageCreateInfoNV, Self::Error> {
        match self {
            Self::DedicatedAllocationImageCreateInfoNV(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_NV_external_memory")]
impl From<ExternalMemoryImageCreateInfoNV> for ImageCreateInfoExtension {
    fn from(ext: ExternalMemoryImageCreateInfoNV) -> Self {
        Self::ExternalMemoryImageCreateInfoNV(ext)
    }
}
#[cfg(feature = "VK_NV_external_memory")]
impl TryInto<ExternalMemoryImageCreateInfoNV> for ImageCreateInfoExtension {
    type Error = ImageCreateInfoExtension;
    fn try_into(self) -> Result<ExternalMemoryImageCreateInfoNV, Self::Error> {
        match self {
            Self::ExternalMemoryImageCreateInfoNV(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
impl From<ExternalMemoryImageCreateInfo> for ImageCreateInfoExtension {
    fn from(ext: ExternalMemoryImageCreateInfo) -> Self {
        Self::ExternalMemoryImageCreateInfo(ext)
    }
}
impl TryInto<ExternalMemoryImageCreateInfo> for ImageCreateInfoExtension {
    type Error = ImageCreateInfoExtension;
    fn try_into(self) -> Result<ExternalMemoryImageCreateInfo, Self::Error> {
        match self {
            Self::ExternalMemoryImageCreateInfo(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_KHR_device_group")]
impl From<ImageSwapchainCreateInfoKHR> for ImageCreateInfoExtension {
    fn from(ext: ImageSwapchainCreateInfoKHR) -> Self {
        Self::ImageSwapchainCreateInfoKHR(ext)
    }
}
#[cfg(feature = "VK_KHR_device_group")]
impl TryInto<ImageSwapchainCreateInfoKHR> for ImageCreateInfoExtension {
    type Error = ImageCreateInfoExtension;
    fn try_into(self) -> Result<ImageSwapchainCreateInfoKHR, Self::Error> {
        match self {
            Self::ImageSwapchainCreateInfoKHR(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VULKAN_1_2")]
impl From<ImageFormatListCreateInfo> for ImageCreateInfoExtension {
    fn from(ext: ImageFormatListCreateInfo) -> Self {
        Self::ImageFormatListCreateInfo(ext)
    }
}
#[cfg(feature = "VULKAN_1_2")]
impl TryInto<ImageFormatListCreateInfo> for ImageCreateInfoExtension {
    type Error = ImageCreateInfoExtension;
    fn try_into(self) -> Result<ImageFormatListCreateInfo, Self::Error> {
        match self {
            Self::ImageFormatListCreateInfo(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_ANDROID_external_memory_android_hardware_buffer")]
impl From<ExternalFormatANDROID> for ImageCreateInfoExtension {
    fn from(ext: ExternalFormatANDROID) -> Self {
        Self::ExternalFormatANDROID(ext)
    }
}
#[cfg(feature = "VK_ANDROID_external_memory_android_hardware_buffer")]
impl TryInto<ExternalFormatANDROID> for ImageCreateInfoExtension {
    type Error = ImageCreateInfoExtension;
    fn try_into(self) -> Result<ExternalFormatANDROID, Self::Error> {
        match self {
            Self::ExternalFormatANDROID(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_EXT_image_drm_format_modifier")]
impl From<ImageDrmFormatModifierListCreateInfoEXT> for ImageCreateInfoExtension {
    fn from(ext: ImageDrmFormatModifierListCreateInfoEXT) -> Self {
        Self::ImageDrmFormatModifierListCreateInfoEXT(ext)
    }
}
#[cfg(feature = "VK_EXT_image_drm_format_modifier")]
impl TryInto<ImageDrmFormatModifierListCreateInfoEXT> for ImageCreateInfoExtension {
    type Error = ImageCreateInfoExtension;
    fn try_into(self) -> Result<ImageDrmFormatModifierListCreateInfoEXT, Self::Error> {
        match self {
            Self::ImageDrmFormatModifierListCreateInfoEXT(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_EXT_image_drm_format_modifier")]
impl From<ImageDrmFormatModifierExplicitCreateInfoEXT> for ImageCreateInfoExtension {
    fn from(ext: ImageDrmFormatModifierExplicitCreateInfoEXT) -> Self {
        Self::ImageDrmFormatModifierExplicitCreateInfoEXT(ext)
    }
}
#[cfg(feature = "VK_EXT_image_drm_format_modifier")]
impl TryInto<ImageDrmFormatModifierExplicitCreateInfoEXT> for ImageCreateInfoExtension {
    type Error = ImageCreateInfoExtension;
    fn try_into(self) -> Result<ImageDrmFormatModifierExplicitCreateInfoEXT, Self::Error> {
        match self {
            Self::ImageDrmFormatModifierExplicitCreateInfoEXT(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VULKAN_1_2")]
impl From<ImageStencilUsageCreateInfo> for ImageCreateInfoExtension {
    fn from(ext: ImageStencilUsageCreateInfo) -> Self {
        Self::ImageStencilUsageCreateInfo(ext)
    }
}
#[cfg(feature = "VULKAN_1_2")]
impl TryInto<ImageStencilUsageCreateInfo> for ImageCreateInfoExtension {
    type Error = ImageCreateInfoExtension;
    fn try_into(self) -> Result<ImageStencilUsageCreateInfo, Self::Error> {
        match self {
            Self::ImageStencilUsageCreateInfo(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_KHR_video_queue")]
impl From<VideoProfilesKHR> for ImageCreateInfoExtension {
    fn from(ext: VideoProfilesKHR) -> Self {
        Self::VideoProfilesKHR(ext)
    }
}
#[cfg(feature = "VK_KHR_video_queue")]
impl TryInto<VideoProfilesKHR> for ImageCreateInfoExtension {
    type Error = ImageCreateInfoExtension;
    fn try_into(self) -> Result<VideoProfilesKHR, Self::Error> {
        match self {
            Self::VideoProfilesKHR(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_KHR_video_queue")]
impl From<VideoProfileKHR> for ImageCreateInfoExtension {
    fn from(ext: VideoProfileKHR) -> Self {
        Self::VideoProfileKHR(ext)
    }
}
#[cfg(feature = "VK_KHR_video_queue")]
impl TryInto<VideoProfileKHR> for ImageCreateInfoExtension {
    type Error = ImageCreateInfoExtension;
    fn try_into(self) -> Result<VideoProfileKHR, Self::Error> {
        match self {
            Self::VideoProfileKHR(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_FUCHSIA_buffer_collection")]
impl From<BufferCollectionImageCreateInfoFUCHSIA> for ImageCreateInfoExtension {
    fn from(ext: BufferCollectionImageCreateInfoFUCHSIA) -> Self {
        Self::BufferCollectionImageCreateInfoFUCHSIA(ext)
    }
}
#[cfg(feature = "VK_FUCHSIA_buffer_collection")]
impl TryInto<BufferCollectionImageCreateInfoFUCHSIA> for ImageCreateInfoExtension {
    type Error = ImageCreateInfoExtension;
    fn try_into(self) -> Result<BufferCollectionImageCreateInfoFUCHSIA, Self::Error> {
        match self {
            Self::BufferCollectionImageCreateInfoFUCHSIA(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
impl SubresourceLayout {
    ///Get a reference to the `offset` field.
    pub fn offset(&self) -> &DeviceSize {
        &self.offset
    }
    ///Get a reference to the `size` field.
    pub fn size(&self) -> &DeviceSize {
        &self.size
    }
    ///Get a reference to the `row_pitch` field.
    pub fn row_pitch(&self) -> &DeviceSize {
        &self.row_pitch
    }
    ///Get a reference to the `array_pitch` field.
    pub fn array_pitch(&self) -> &DeviceSize {
        &self.array_pitch
    }
    ///Get a reference to the `depth_pitch` field.
    pub fn depth_pitch(&self) -> &DeviceSize {
        &self.depth_pitch
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for SubresourceLayout {
    type LowLevel = crate::native::vulkan1_0::SubresourceLayout;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        crate::native::vulkan1_0::SubresourceLayout {
            offset: self.offset.into_low_level(context, bump),
            size: self.size.into_low_level(context, bump),
            row_pitch: self.row_pitch.into_low_level(context, bump),
            array_pitch: self.array_pitch.into_low_level(context, bump),
            depth_pitch: self.depth_pitch.into_low_level(context, bump),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for SubresourceLayout {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        Self {
            offset: crate::conv::FromLowLevel::from_low_level(context, value.offset),
            size: crate::conv::FromLowLevel::from_low_level(context, value.size),
            row_pitch: crate::conv::FromLowLevel::from_low_level(context, value.row_pitch),
            array_pitch: crate::conv::FromLowLevel::from_low_level(context, value.array_pitch),
            depth_pitch: crate::conv::FromLowLevel::from_low_level(context, value.depth_pitch),
        }
    }
}
#[doc(alias = "VkImageViewCreateInfo")]
#[derive(Clone, PartialEq, Debug)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct ImageViewCreateInfo {
    #[doc(alias = "pNext")]
    pub extensions: SmallVec<[ImageViewCreateInfoExtension; 1]>,
    pub flags: ImageViewCreateFlags,
    pub image: Image,
    #[doc(alias = "viewType")]
    pub view_type: ImageViewType,
    pub format: Format,
    pub components: ComponentMapping,
    #[doc(alias = "subresourceRange")]
    pub subresource_range: ImageSubresourceRange,
}
impl ImageViewCreateInfo {
    ///Adds an extension to the struct
    pub fn with_extension(mut self, ext: impl Into<ImageViewCreateInfoExtension>) -> Self {
        self.extensions.push(ext.into());
        self
    }
    ///Get a reference to the `extensions` field.
    pub fn extensions(&self) -> &SmallVec<[ImageViewCreateInfoExtension; 1]> {
        &self.extensions
    }
    ///Get a reference to the `flags` field.
    pub fn flags(&self) -> ImageViewCreateFlags {
        self.flags
    }
    ///Get a reference to the `image` field.
    pub fn image(&self) -> &Image {
        &self.image
    }
    ///Get a reference to the `view_type` field.
    pub fn view_type(&self) -> ImageViewType {
        self.view_type
    }
    ///Get a reference to the `format` field.
    pub fn format(&self) -> Format {
        self.format
    }
    ///Get a reference to the `components` field.
    pub fn components(&self) -> ComponentMapping {
        self.components
    }
    ///Get a reference to the `subresource_range` field.
    pub fn subresource_range(&self) -> ImageSubresourceRange {
        self.subresource_range
    }
    ///Get a mutable reference to the `extensions` field.
    pub fn extensions_mut(&mut self) -> &mut SmallVec<[ImageViewCreateInfoExtension; 1]> {
        &mut self.extensions
    }
    ///Get a mutable reference to the `flags` field.
    pub fn flags_mut(&mut self) -> &mut ImageViewCreateFlags {
        &mut self.flags
    }
    ///Get a mutable reference to the `image` field.
    pub fn image_mut(&mut self) -> &mut Image {
        &mut self.image
    }
    ///Get a mutable reference to the `view_type` field.
    pub fn view_type_mut(&mut self) -> &mut ImageViewType {
        &mut self.view_type
    }
    ///Get a mutable reference to the `format` field.
    pub fn format_mut(&mut self) -> &mut Format {
        &mut self.format
    }
    ///Get a mutable reference to the `components` field.
    pub fn components_mut(&mut self) -> &mut ComponentMapping {
        &mut self.components
    }
    ///Get a mutable reference to the `subresource_range` field.
    pub fn subresource_range_mut(&mut self) -> &mut ImageSubresourceRange {
        &mut self.subresource_range
    }
    ///Sets the `extensions` field.
    pub fn set_extensions(&mut self, extensions: SmallVec<[ImageViewCreateInfoExtension; 1]>) -> &mut Self {
        self.extensions = extensions;
        self
    }
    ///Sets the `flags` field.
    pub fn set_flags(&mut self, flags: ImageViewCreateFlags) -> &mut Self {
        self.flags = flags;
        self
    }
    ///Sets the `image` field.
    pub fn set_image(&mut self, image: Image) -> &mut Self {
        self.image = image;
        self
    }
    ///Sets the `view_type` field.
    pub fn set_view_type(&mut self, view_type: ImageViewType) -> &mut Self {
        self.view_type = view_type;
        self
    }
    ///Sets the `format` field.
    pub fn set_format(&mut self, format: Format) -> &mut Self {
        self.format = format;
        self
    }
    ///Sets the `components` field.
    pub fn set_components(&mut self, components: ComponentMapping) -> &mut Self {
        self.components = components;
        self
    }
    ///Sets the `subresource_range` field.
    pub fn set_subresource_range(&mut self, subresource_range: ImageSubresourceRange) -> &mut Self {
        self.subresource_range = subresource_range;
        self
    }
    ///Sets the `extensions` field in a builder way.
    pub fn with_extensions(mut self, extensions: SmallVec<[ImageViewCreateInfoExtension; 1]>) -> Self {
        self.extensions = extensions;
        self
    }
    ///Sets the `flags` field in a builder way.
    pub fn with_flags(mut self, flags: ImageViewCreateFlags) -> Self {
        self.flags = flags;
        self
    }
    ///Sets the `image` field in a builder way.
    pub fn with_image(mut self, image: Image) -> Self {
        self.image = image;
        self
    }
    ///Sets the `view_type` field in a builder way.
    pub fn with_view_type(mut self, view_type: ImageViewType) -> Self {
        self.view_type = view_type;
        self
    }
    ///Sets the `format` field in a builder way.
    pub fn with_format(mut self, format: Format) -> Self {
        self.format = format;
        self
    }
    ///Sets the `components` field in a builder way.
    pub fn with_components(mut self, components: ComponentMapping) -> Self {
        self.components = components;
        self
    }
    ///Sets the `subresource_range` field in a builder way.
    pub fn with_subresource_range(mut self, subresource_range: ImageSubresourceRange) -> Self {
        self.subresource_range = subresource_range;
        self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for ImageViewCreateInfo {
    type LowLevel = crate::native::vulkan1_0::ImageViewCreateInfo;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        let mut next = std::ptr::null();
        let mut extensions = self.extensions.iter();
        while let Some(ext) = extensions.next() {
            let ext = ext.into_low_level(context, bump);
            (*ext).next = next;
            next = ext;
        }
        crate::native::vulkan1_0::ImageViewCreateInfo {
            s_type: StructureType::ImageViewCreateInfo,
            p_next: next,
            flags: self.flags.into_low_level(context, bump),
            image: self.image.into_low_level(context, bump),
            view_type: self.view_type.into_low_level(context, bump),
            format: self.format.into_low_level(context, bump),
            components: self.components.into_low_level(context, bump),
            subresource_range: self.subresource_range.into_low_level(context, bump),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for ImageViewCreateInfo {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        let mut next = value.p_next;
        let mut extensions = SmallVec::new();
        while !next.is_null() {
            extensions.push(crate::conv::FromLowLevel::from_low_level(context, next));
            next = std::ptr::read(next).next;
        }
        Self {
            extensions: extensions,
            flags: crate::conv::FromLowLevel::from_low_level(context, value.flags),
            image: crate::conv::FromLowLevel::from_low_level(context, value.image),
            view_type: crate::conv::FromLowLevel::from_low_level(context, value.view_type),
            format: crate::conv::FromLowLevel::from_low_level(context, value.format),
            components: crate::conv::FromLowLevel::from_low_level(context, value.components),
            subresource_range: crate::conv::FromLowLevel::from_low_level(context, value.subresource_range),
        }
    }
}
#[derive(Clone, PartialEq, Debug)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
///Extensions for [`ImageViewCreateInfo`]
pub enum ImageViewCreateInfoExtension {
    ///Contains a type [`ImageViewUsageCreateInfo`] for extending [`ImageViewCreateInfo`]
    ImageViewUsageCreateInfo(ImageViewUsageCreateInfo),
    ///Contains a type [`SamplerYcbcrConversionInfo`] for extending [`ImageViewCreateInfo`]
    SamplerYcbcrConversionInfo(SamplerYcbcrConversionInfo),
    #[cfg(feature = "VK_EXT_astc_decode_mode")]
    ///Contains a type [`ImageViewAstcDecodeModeEXT`] for extending [`ImageViewCreateInfo`]
    ImageViewAstcDecodeModeEXT(ImageViewAstcDecodeModeEXT),
    #[cfg(feature = "VK_KHR_video_queue")]
    ///Contains a type [`VideoProfilesKHR`] for extending [`ImageViewCreateInfo`]
    VideoProfilesKHR(VideoProfilesKHR),
    #[cfg(feature = "VK_KHR_video_queue")]
    ///Contains a type [`VideoProfileKHR`] for extending [`ImageViewCreateInfo`]
    VideoProfileKHR(VideoProfileKHR),
    #[cfg(feature = "VK_EXT_image_view_min_lod")]
    ///Contains a type [`ImageViewMinLodCreateInfoEXT`] for extending [`ImageViewCreateInfo`]
    ImageViewMinLodCreateInfoEXT(ImageViewMinLodCreateInfoEXT),
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for ImageViewCreateInfoExtension {
    type LowLevel = *const crate::native::vulkan1_0::BaseInStructure;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        match self {
            Self::ImageViewUsageCreateInfo(ext) => (bump.alloc(ext.into_low_level(context, bump))
                as *mut crate::native::vulkan1_1::ImageViewUsageCreateInfo)
                .cast(),
            Self::SamplerYcbcrConversionInfo(ext) => (bump.alloc(ext.into_low_level(context, bump))
                as *mut crate::native::vulkan1_1::SamplerYcbcrConversionInfo)
                .cast(),
            #[cfg(feature = "VK_EXT_astc_decode_mode")]
            Self::ImageViewAstcDecodeModeEXT(ext) => (bump.alloc(ext.into_low_level(context, bump))
                as *mut crate::native::extensions::ext_astc_decode_mode::ImageViewAstcDecodeModeEXT)
                .cast(),
            #[cfg(feature = "VK_KHR_video_queue")]
            Self::VideoProfilesKHR(ext) => (bump.alloc(ext.into_low_level(context, bump))
                as *mut crate::native::extensions::khr_video_queue::VideoProfilesKHR)
                .cast(),
            #[cfg(feature = "VK_KHR_video_queue")]
            Self::VideoProfileKHR(ext) => (bump.alloc(ext.into_low_level(context, bump))
                as *mut crate::native::extensions::khr_video_queue::VideoProfileKHR)
                .cast(),
            #[cfg(feature = "VK_EXT_image_view_min_lod")]
            Self::ImageViewMinLodCreateInfoEXT(ext) => (bump.alloc(ext.into_low_level(context, bump))
                as *mut crate::native::extensions::ext_image_view_min_lod::ImageViewMinLodCreateInfoEXT)
                .cast(),
            other => unreachable!("unexpected variant {:?}", other),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for ImageViewCreateInfoExtension {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        assert!(!value.is_null());
        match (*value).s_type {
            crate::native::vulkan1_0::StructureType::ImageViewUsageCreateInfo => {
                Self::ImageViewUsageCreateInfo(ImageViewUsageCreateInfo::from_low_level(
                    context,
                    std::ptr::read(value.cast::<crate::native::vulkan1_1::ImageViewUsageCreateInfo>()),
                ))
            },
            crate::native::vulkan1_0::StructureType::SamplerYcbcrConversionInfo => {
                Self::SamplerYcbcrConversionInfo(SamplerYcbcrConversionInfo::from_low_level(
                    context,
                    std::ptr::read(value.cast::<crate::native::vulkan1_1::SamplerYcbcrConversionInfo>()),
                ))
            },
            #[cfg(feature = "VK_EXT_astc_decode_mode")]
            crate::native::vulkan1_0::StructureType::ImageViewAstcDecodeModeExt => {
                Self::ImageViewAstcDecodeModeEXT(ImageViewAstcDecodeModeEXT::from_low_level(
                    context,
                    std::ptr::read(
                        value.cast::<crate::native::extensions::ext_astc_decode_mode::ImageViewAstcDecodeModeEXT>(),
                    ),
                ))
            },
            #[cfg(feature = "VK_KHR_video_queue")]
            crate::native::vulkan1_0::StructureType::VideoProfilesKhr => {
                Self::VideoProfilesKHR(VideoProfilesKHR::from_low_level(
                    context,
                    std::ptr::read(value.cast::<crate::native::extensions::khr_video_queue::VideoProfilesKHR>()),
                ))
            },
            #[cfg(feature = "VK_KHR_video_queue")]
            crate::native::vulkan1_0::StructureType::VideoProfileKhr => {
                Self::VideoProfileKHR(VideoProfileKHR::from_low_level(
                    context,
                    std::ptr::read(value.cast::<crate::native::extensions::khr_video_queue::VideoProfileKHR>()),
                ))
            },
            #[cfg(feature = "VK_EXT_image_view_min_lod")]
            crate::native::vulkan1_0::StructureType::ImageViewMinLodCreateInfoExt => {
                Self::ImageViewMinLodCreateInfoEXT(ImageViewMinLodCreateInfoEXT::from_low_level(
                    context,
                    std::ptr::read(
                        value.cast::<crate::native::extensions::ext_image_view_min_lod::ImageViewMinLodCreateInfoEXT>(),
                    ),
                ))
            },
            other => panic!(
                "Structure type {:?} is not a member of {}",
                other,
                stringify!(ImageViewCreateInfo)
            ),
        }
    }
}
impl From<ImageViewUsageCreateInfo> for ImageViewCreateInfoExtension {
    fn from(ext: ImageViewUsageCreateInfo) -> Self {
        Self::ImageViewUsageCreateInfo(ext)
    }
}
impl TryInto<ImageViewUsageCreateInfo> for ImageViewCreateInfoExtension {
    type Error = ImageViewCreateInfoExtension;
    fn try_into(self) -> Result<ImageViewUsageCreateInfo, Self::Error> {
        match self {
            Self::ImageViewUsageCreateInfo(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
impl From<SamplerYcbcrConversionInfo> for ImageViewCreateInfoExtension {
    fn from(ext: SamplerYcbcrConversionInfo) -> Self {
        Self::SamplerYcbcrConversionInfo(ext)
    }
}
impl TryInto<SamplerYcbcrConversionInfo> for ImageViewCreateInfoExtension {
    type Error = ImageViewCreateInfoExtension;
    fn try_into(self) -> Result<SamplerYcbcrConversionInfo, Self::Error> {
        match self {
            Self::SamplerYcbcrConversionInfo(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_EXT_astc_decode_mode")]
impl From<ImageViewAstcDecodeModeEXT> for ImageViewCreateInfoExtension {
    fn from(ext: ImageViewAstcDecodeModeEXT) -> Self {
        Self::ImageViewAstcDecodeModeEXT(ext)
    }
}
#[cfg(feature = "VK_EXT_astc_decode_mode")]
impl TryInto<ImageViewAstcDecodeModeEXT> for ImageViewCreateInfoExtension {
    type Error = ImageViewCreateInfoExtension;
    fn try_into(self) -> Result<ImageViewAstcDecodeModeEXT, Self::Error> {
        match self {
            Self::ImageViewAstcDecodeModeEXT(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_KHR_video_queue")]
impl From<VideoProfilesKHR> for ImageViewCreateInfoExtension {
    fn from(ext: VideoProfilesKHR) -> Self {
        Self::VideoProfilesKHR(ext)
    }
}
#[cfg(feature = "VK_KHR_video_queue")]
impl TryInto<VideoProfilesKHR> for ImageViewCreateInfoExtension {
    type Error = ImageViewCreateInfoExtension;
    fn try_into(self) -> Result<VideoProfilesKHR, Self::Error> {
        match self {
            Self::VideoProfilesKHR(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_KHR_video_queue")]
impl From<VideoProfileKHR> for ImageViewCreateInfoExtension {
    fn from(ext: VideoProfileKHR) -> Self {
        Self::VideoProfileKHR(ext)
    }
}
#[cfg(feature = "VK_KHR_video_queue")]
impl TryInto<VideoProfileKHR> for ImageViewCreateInfoExtension {
    type Error = ImageViewCreateInfoExtension;
    fn try_into(self) -> Result<VideoProfileKHR, Self::Error> {
        match self {
            Self::VideoProfileKHR(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_EXT_image_view_min_lod")]
impl From<ImageViewMinLodCreateInfoEXT> for ImageViewCreateInfoExtension {
    fn from(ext: ImageViewMinLodCreateInfoEXT) -> Self {
        Self::ImageViewMinLodCreateInfoEXT(ext)
    }
}
#[cfg(feature = "VK_EXT_image_view_min_lod")]
impl TryInto<ImageViewMinLodCreateInfoEXT> for ImageViewCreateInfoExtension {
    type Error = ImageViewCreateInfoExtension;
    fn try_into(self) -> Result<ImageViewMinLodCreateInfoEXT, Self::Error> {
        match self {
            Self::ImageViewMinLodCreateInfoEXT(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
impl BufferCopy {
    ///Get a reference to the `src_offset` field.
    pub fn src_offset(&self) -> &DeviceSize {
        &self.src_offset
    }
    ///Get a reference to the `dst_offset` field.
    pub fn dst_offset(&self) -> &DeviceSize {
        &self.dst_offset
    }
    ///Get a reference to the `size` field.
    pub fn size(&self) -> &DeviceSize {
        &self.size
    }
    ///Get a mutable reference to the `src_offset` field.
    pub fn src_offset_mut(&mut self) -> &mut DeviceSize {
        &mut self.src_offset
    }
    ///Get a mutable reference to the `dst_offset` field.
    pub fn dst_offset_mut(&mut self) -> &mut DeviceSize {
        &mut self.dst_offset
    }
    ///Get a mutable reference to the `size` field.
    pub fn size_mut(&mut self) -> &mut DeviceSize {
        &mut self.size
    }
    ///Sets the `src_offset` field.
    pub fn set_src_offset(&mut self, src_offset: DeviceSize) -> &mut Self {
        self.src_offset = src_offset;
        self
    }
    ///Sets the `dst_offset` field.
    pub fn set_dst_offset(&mut self, dst_offset: DeviceSize) -> &mut Self {
        self.dst_offset = dst_offset;
        self
    }
    ///Sets the `size` field.
    pub fn set_size(&mut self, size: DeviceSize) -> &mut Self {
        self.size = size;
        self
    }
    ///Sets the `src_offset` field in a builder way.
    pub fn with_src_offset(mut self, src_offset: DeviceSize) -> Self {
        self.src_offset = src_offset;
        self
    }
    ///Sets the `dst_offset` field in a builder way.
    pub fn with_dst_offset(mut self, dst_offset: DeviceSize) -> Self {
        self.dst_offset = dst_offset;
        self
    }
    ///Sets the `size` field in a builder way.
    pub fn with_size(mut self, size: DeviceSize) -> Self {
        self.size = size;
        self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for BufferCopy {
    type LowLevel = crate::native::vulkan1_0::BufferCopy;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        crate::native::vulkan1_0::BufferCopy {
            src_offset: self.src_offset.into_low_level(context, bump),
            dst_offset: self.dst_offset.into_low_level(context, bump),
            size: self.size.into_low_level(context, bump),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for BufferCopy {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        Self {
            src_offset: crate::conv::FromLowLevel::from_low_level(context, value.src_offset),
            dst_offset: crate::conv::FromLowLevel::from_low_level(context, value.dst_offset),
            size: crate::conv::FromLowLevel::from_low_level(context, value.size),
        }
    }
}
#[doc(alias = "VkSparseMemoryBind")]
#[derive(Clone, PartialEq, Debug, Default)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct SparseMemoryBind {
    #[doc(alias = "resourceOffset")]
    pub resource_offset: DeviceSize,
    pub size: DeviceSize,
    pub memory: Option<DeviceMemory>,
    #[doc(alias = "memoryOffset")]
    pub memory_offset: DeviceSize,
    pub flags: SparseMemoryBindFlags,
}
impl SparseMemoryBind {
    ///Get a reference to the `resource_offset` field.
    pub fn resource_offset(&self) -> &DeviceSize {
        &self.resource_offset
    }
    ///Get a reference to the `size` field.
    pub fn size(&self) -> &DeviceSize {
        &self.size
    }
    ///Get a reference to the `memory` field.
    pub fn memory(&self) -> &Option<DeviceMemory> {
        &self.memory
    }
    ///Get a reference to the `memory_offset` field.
    pub fn memory_offset(&self) -> &DeviceSize {
        &self.memory_offset
    }
    ///Get a reference to the `flags` field.
    pub fn flags(&self) -> SparseMemoryBindFlags {
        self.flags
    }
    ///Get a mutable reference to the `resource_offset` field.
    pub fn resource_offset_mut(&mut self) -> &mut DeviceSize {
        &mut self.resource_offset
    }
    ///Get a mutable reference to the `size` field.
    pub fn size_mut(&mut self) -> &mut DeviceSize {
        &mut self.size
    }
    ///Get a mutable reference to the `memory` field.
    pub fn memory_mut(&mut self) -> &mut Option<DeviceMemory> {
        &mut self.memory
    }
    ///Get a mutable reference to the `memory_offset` field.
    pub fn memory_offset_mut(&mut self) -> &mut DeviceSize {
        &mut self.memory_offset
    }
    ///Get a mutable reference to the `flags` field.
    pub fn flags_mut(&mut self) -> &mut SparseMemoryBindFlags {
        &mut self.flags
    }
    ///Sets the `resource_offset` field.
    pub fn set_resource_offset(&mut self, resource_offset: DeviceSize) -> &mut Self {
        self.resource_offset = resource_offset;
        self
    }
    ///Sets the `size` field.
    pub fn set_size(&mut self, size: DeviceSize) -> &mut Self {
        self.size = size;
        self
    }
    ///Sets the `memory` field.
    pub fn set_memory(&mut self, memory: Option<DeviceMemory>) -> &mut Self {
        self.memory = memory;
        self
    }
    ///Sets the `memory_offset` field.
    pub fn set_memory_offset(&mut self, memory_offset: DeviceSize) -> &mut Self {
        self.memory_offset = memory_offset;
        self
    }
    ///Sets the `flags` field.
    pub fn set_flags(&mut self, flags: SparseMemoryBindFlags) -> &mut Self {
        self.flags = flags;
        self
    }
    ///Sets the `resource_offset` field in a builder way.
    pub fn with_resource_offset(mut self, resource_offset: DeviceSize) -> Self {
        self.resource_offset = resource_offset;
        self
    }
    ///Sets the `size` field in a builder way.
    pub fn with_size(mut self, size: DeviceSize) -> Self {
        self.size = size;
        self
    }
    ///Sets the `memory` field in a builder way.
    pub fn with_memory(mut self, memory: Option<DeviceMemory>) -> Self {
        self.memory = memory;
        self
    }
    ///Sets the `memory_offset` field in a builder way.
    pub fn with_memory_offset(mut self, memory_offset: DeviceSize) -> Self {
        self.memory_offset = memory_offset;
        self
    }
    ///Sets the `flags` field in a builder way.
    pub fn with_flags(mut self, flags: SparseMemoryBindFlags) -> Self {
        self.flags = flags;
        self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for SparseMemoryBind {
    type LowLevel = crate::native::vulkan1_0::SparseMemoryBind;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        crate::native::vulkan1_0::SparseMemoryBind {
            resource_offset: self.resource_offset.into_low_level(context, bump),
            size: self.size.into_low_level(context, bump),
            memory: self
                .memory
                .as_ref()
                .map(|v| v.into_low_level(context, bump))
                .unwrap_or_else(Default::default),
            memory_offset: self.memory_offset.into_low_level(context, bump),
            flags: self.flags.into_low_level(context, bump),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for SparseMemoryBind {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        Self {
            resource_offset: crate::conv::FromLowLevel::from_low_level(context, value.resource_offset),
            size: crate::conv::FromLowLevel::from_low_level(context, value.size),
            memory: if value.memory == crate::native::vulkan1_0::DeviceMemory::null() {
                None
            } else {
                Some(crate::conv::FromLowLevel::from_low_level(context, value.memory))
            },
            memory_offset: crate::conv::FromLowLevel::from_low_level(context, value.memory_offset),
            flags: crate::conv::FromLowLevel::from_low_level(context, value.flags),
        }
    }
}
#[doc(alias = "VkSparseImageMemoryBind")]
#[derive(Clone, PartialEq, Debug, Default)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct SparseImageMemoryBind {
    pub subresource: ImageSubresource,
    pub offset: Offset3D,
    pub extent: Extent3D,
    pub memory: Option<DeviceMemory>,
    #[doc(alias = "memoryOffset")]
    pub memory_offset: DeviceSize,
    pub flags: SparseMemoryBindFlags,
}
impl SparseImageMemoryBind {
    ///Get a reference to the `subresource` field.
    pub fn subresource(&self) -> ImageSubresource {
        self.subresource
    }
    ///Get a reference to the `offset` field.
    pub fn offset(&self) -> Offset3D {
        self.offset
    }
    ///Get a reference to the `extent` field.
    pub fn extent(&self) -> Extent3D {
        self.extent
    }
    ///Get a reference to the `memory` field.
    pub fn memory(&self) -> &Option<DeviceMemory> {
        &self.memory
    }
    ///Get a reference to the `memory_offset` field.
    pub fn memory_offset(&self) -> &DeviceSize {
        &self.memory_offset
    }
    ///Get a reference to the `flags` field.
    pub fn flags(&self) -> SparseMemoryBindFlags {
        self.flags
    }
    ///Get a mutable reference to the `subresource` field.
    pub fn subresource_mut(&mut self) -> &mut ImageSubresource {
        &mut self.subresource
    }
    ///Get a mutable reference to the `offset` field.
    pub fn offset_mut(&mut self) -> &mut Offset3D {
        &mut self.offset
    }
    ///Get a mutable reference to the `extent` field.
    pub fn extent_mut(&mut self) -> &mut Extent3D {
        &mut self.extent
    }
    ///Get a mutable reference to the `memory` field.
    pub fn memory_mut(&mut self) -> &mut Option<DeviceMemory> {
        &mut self.memory
    }
    ///Get a mutable reference to the `memory_offset` field.
    pub fn memory_offset_mut(&mut self) -> &mut DeviceSize {
        &mut self.memory_offset
    }
    ///Get a mutable reference to the `flags` field.
    pub fn flags_mut(&mut self) -> &mut SparseMemoryBindFlags {
        &mut self.flags
    }
    ///Sets the `subresource` field.
    pub fn set_subresource(&mut self, subresource: ImageSubresource) -> &mut Self {
        self.subresource = subresource;
        self
    }
    ///Sets the `offset` field.
    pub fn set_offset(&mut self, offset: Offset3D) -> &mut Self {
        self.offset = offset;
        self
    }
    ///Sets the `extent` field.
    pub fn set_extent(&mut self, extent: Extent3D) -> &mut Self {
        self.extent = extent;
        self
    }
    ///Sets the `memory` field.
    pub fn set_memory(&mut self, memory: Option<DeviceMemory>) -> &mut Self {
        self.memory = memory;
        self
    }
    ///Sets the `memory_offset` field.
    pub fn set_memory_offset(&mut self, memory_offset: DeviceSize) -> &mut Self {
        self.memory_offset = memory_offset;
        self
    }
    ///Sets the `flags` field.
    pub fn set_flags(&mut self, flags: SparseMemoryBindFlags) -> &mut Self {
        self.flags = flags;
        self
    }
    ///Sets the `subresource` field in a builder way.
    pub fn with_subresource(mut self, subresource: ImageSubresource) -> Self {
        self.subresource = subresource;
        self
    }
    ///Sets the `offset` field in a builder way.
    pub fn with_offset(mut self, offset: Offset3D) -> Self {
        self.offset = offset;
        self
    }
    ///Sets the `extent` field in a builder way.
    pub fn with_extent(mut self, extent: Extent3D) -> Self {
        self.extent = extent;
        self
    }
    ///Sets the `memory` field in a builder way.
    pub fn with_memory(mut self, memory: Option<DeviceMemory>) -> Self {
        self.memory = memory;
        self
    }
    ///Sets the `memory_offset` field in a builder way.
    pub fn with_memory_offset(mut self, memory_offset: DeviceSize) -> Self {
        self.memory_offset = memory_offset;
        self
    }
    ///Sets the `flags` field in a builder way.
    pub fn with_flags(mut self, flags: SparseMemoryBindFlags) -> Self {
        self.flags = flags;
        self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for SparseImageMemoryBind {
    type LowLevel = crate::native::vulkan1_0::SparseImageMemoryBind;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        crate::native::vulkan1_0::SparseImageMemoryBind {
            subresource: self.subresource.into_low_level(context, bump),
            offset: self.offset.into_low_level(context, bump),
            extent: self.extent.into_low_level(context, bump),
            memory: self
                .memory
                .as_ref()
                .map(|v| v.into_low_level(context, bump))
                .unwrap_or_else(Default::default),
            memory_offset: self.memory_offset.into_low_level(context, bump),
            flags: self.flags.into_low_level(context, bump),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for SparseImageMemoryBind {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        Self {
            subresource: crate::conv::FromLowLevel::from_low_level(context, value.subresource),
            offset: crate::conv::FromLowLevel::from_low_level(context, value.offset),
            extent: crate::conv::FromLowLevel::from_low_level(context, value.extent),
            memory: if value.memory == crate::native::vulkan1_0::DeviceMemory::null() {
                None
            } else {
                Some(crate::conv::FromLowLevel::from_low_level(context, value.memory))
            },
            memory_offset: crate::conv::FromLowLevel::from_low_level(context, value.memory_offset),
            flags: crate::conv::FromLowLevel::from_low_level(context, value.flags),
        }
    }
}
#[doc(alias = "VkSparseBufferMemoryBindInfo")]
#[derive(Clone, PartialEq, Debug)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct SparseBufferMemoryBindInfo {
    pub buffer: Buffer,
    #[doc(alias = "pBinds")]
    pub binds: SmallVec<[SparseMemoryBind; 8]>,
}
impl SparseBufferMemoryBindInfo {
    ///Get a reference to the `buffer` field.
    pub fn buffer(&self) -> &Buffer {
        &self.buffer
    }
    ///Get a reference to the `binds` field.
    pub fn binds(&self) -> &SmallVec<[SparseMemoryBind; 8]> {
        &self.binds
    }
    ///Get a mutable reference to the `buffer` field.
    pub fn buffer_mut(&mut self) -> &mut Buffer {
        &mut self.buffer
    }
    ///Get a mutable reference to the `binds` field.
    pub fn binds_mut(&mut self) -> &mut SmallVec<[SparseMemoryBind; 8]> {
        &mut self.binds
    }
    ///Sets the `buffer` field.
    pub fn set_buffer(&mut self, buffer: Buffer) -> &mut Self {
        self.buffer = buffer;
        self
    }
    ///Sets the `binds` field.
    pub fn set_binds(&mut self, binds: SmallVec<[SparseMemoryBind; 8]>) -> &mut Self {
        self.binds = binds;
        self
    }
    ///Sets the `buffer` field in a builder way.
    pub fn with_buffer(mut self, buffer: Buffer) -> Self {
        self.buffer = buffer;
        self
    }
    ///Sets the `binds` field in a builder way.
    pub fn with_binds(mut self, binds: SmallVec<[SparseMemoryBind; 8]>) -> Self {
        self.binds = binds;
        self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for SparseBufferMemoryBindInfo {
    type LowLevel = crate::native::vulkan1_0::SparseBufferMemoryBindInfo;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        let len_binds = self.binds.len() as u32;
        let binds = bump
            .alloc_slice_fill_iter(self.binds.iter().map(|x| x.into_low_level(context, bump)))
            .as_ptr()
            .cast();
        crate::native::vulkan1_0::SparseBufferMemoryBindInfo {
            buffer: self.buffer.into_low_level(context, bump),
            bind_count: len_binds,
            binds: binds,
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for SparseBufferMemoryBindInfo {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        let binds_len = value.bind_count;
        let mut binds = SmallVec::with_capacity(binds_len as usize);
        for i in 0..binds_len {
            binds.push(crate::conv::FromLowLevel::from_low_level(
                context,
                value.binds.add(i as usize).read(),
            ));
        }
        Self {
            buffer: crate::conv::FromLowLevel::from_low_level(context, value.buffer),
            binds: binds,
        }
    }
}
#[doc(alias = "VkSparseImageOpaqueMemoryBindInfo")]
#[derive(Clone, PartialEq, Debug)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct SparseImageOpaqueMemoryBindInfo {
    pub image: Image,
    #[doc(alias = "pBinds")]
    pub binds: SmallVec<[SparseMemoryBind; 8]>,
}
impl SparseImageOpaqueMemoryBindInfo {
    ///Get a reference to the `image` field.
    pub fn image(&self) -> &Image {
        &self.image
    }
    ///Get a reference to the `binds` field.
    pub fn binds(&self) -> &SmallVec<[SparseMemoryBind; 8]> {
        &self.binds
    }
    ///Get a mutable reference to the `image` field.
    pub fn image_mut(&mut self) -> &mut Image {
        &mut self.image
    }
    ///Get a mutable reference to the `binds` field.
    pub fn binds_mut(&mut self) -> &mut SmallVec<[SparseMemoryBind; 8]> {
        &mut self.binds
    }
    ///Sets the `image` field.
    pub fn set_image(&mut self, image: Image) -> &mut Self {
        self.image = image;
        self
    }
    ///Sets the `binds` field.
    pub fn set_binds(&mut self, binds: SmallVec<[SparseMemoryBind; 8]>) -> &mut Self {
        self.binds = binds;
        self
    }
    ///Sets the `image` field in a builder way.
    pub fn with_image(mut self, image: Image) -> Self {
        self.image = image;
        self
    }
    ///Sets the `binds` field in a builder way.
    pub fn with_binds(mut self, binds: SmallVec<[SparseMemoryBind; 8]>) -> Self {
        self.binds = binds;
        self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for SparseImageOpaqueMemoryBindInfo {
    type LowLevel = crate::native::vulkan1_0::SparseImageOpaqueMemoryBindInfo;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        let len_binds = self.binds.len() as u32;
        let binds = bump
            .alloc_slice_fill_iter(self.binds.iter().map(|x| x.into_low_level(context, bump)))
            .as_ptr()
            .cast();
        crate::native::vulkan1_0::SparseImageOpaqueMemoryBindInfo {
            image: self.image.into_low_level(context, bump),
            bind_count: len_binds,
            binds: binds,
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for SparseImageOpaqueMemoryBindInfo {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        let binds_len = value.bind_count;
        let mut binds = SmallVec::with_capacity(binds_len as usize);
        for i in 0..binds_len {
            binds.push(crate::conv::FromLowLevel::from_low_level(
                context,
                value.binds.add(i as usize).read(),
            ));
        }
        Self {
            image: crate::conv::FromLowLevel::from_low_level(context, value.image),
            binds: binds,
        }
    }
}
#[doc(alias = "VkSparseImageMemoryBindInfo")]
#[derive(Clone, PartialEq, Debug)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct SparseImageMemoryBindInfo {
    pub image: Image,
    #[doc(alias = "pBinds")]
    pub binds: SmallVec<[SparseImageMemoryBind; 8]>,
}
impl SparseImageMemoryBindInfo {
    ///Get a reference to the `image` field.
    pub fn image(&self) -> &Image {
        &self.image
    }
    ///Get a reference to the `binds` field.
    pub fn binds(&self) -> &SmallVec<[SparseImageMemoryBind; 8]> {
        &self.binds
    }
    ///Get a mutable reference to the `image` field.
    pub fn image_mut(&mut self) -> &mut Image {
        &mut self.image
    }
    ///Get a mutable reference to the `binds` field.
    pub fn binds_mut(&mut self) -> &mut SmallVec<[SparseImageMemoryBind; 8]> {
        &mut self.binds
    }
    ///Sets the `image` field.
    pub fn set_image(&mut self, image: Image) -> &mut Self {
        self.image = image;
        self
    }
    ///Sets the `binds` field.
    pub fn set_binds(&mut self, binds: SmallVec<[SparseImageMemoryBind; 8]>) -> &mut Self {
        self.binds = binds;
        self
    }
    ///Sets the `image` field in a builder way.
    pub fn with_image(mut self, image: Image) -> Self {
        self.image = image;
        self
    }
    ///Sets the `binds` field in a builder way.
    pub fn with_binds(mut self, binds: SmallVec<[SparseImageMemoryBind; 8]>) -> Self {
        self.binds = binds;
        self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for SparseImageMemoryBindInfo {
    type LowLevel = crate::native::vulkan1_0::SparseImageMemoryBindInfo;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        let len_binds = self.binds.len() as u32;
        let binds = bump
            .alloc_slice_fill_iter(self.binds.iter().map(|x| x.into_low_level(context, bump)))
            .as_ptr()
            .cast();
        crate::native::vulkan1_0::SparseImageMemoryBindInfo {
            image: self.image.into_low_level(context, bump),
            bind_count: len_binds,
            binds: binds,
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for SparseImageMemoryBindInfo {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        let binds_len = value.bind_count;
        let mut binds = SmallVec::with_capacity(binds_len as usize);
        for i in 0..binds_len {
            binds.push(crate::conv::FromLowLevel::from_low_level(
                context,
                value.binds.add(i as usize).read(),
            ));
        }
        Self {
            image: crate::conv::FromLowLevel::from_low_level(context, value.image),
            binds: binds,
        }
    }
}
#[doc(alias = "VkBindSparseInfo")]
#[derive(Clone, PartialEq, Debug, Default)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct BindSparseInfo {
    #[doc(alias = "pNext")]
    pub extensions: SmallVec<[BindSparseInfoExtension; 1]>,
    #[doc(alias = "pWaitSemaphores")]
    pub wait_semaphores: SmallVec<[Semaphore; 8]>,
    #[doc(alias = "pBufferBinds")]
    pub buffer_binds: SmallVec<[SparseBufferMemoryBindInfo; 8]>,
    #[doc(alias = "pImageOpaqueBinds")]
    pub image_opaque_binds: SmallVec<[SparseImageOpaqueMemoryBindInfo; 8]>,
    #[doc(alias = "pImageBinds")]
    pub image_binds: SmallVec<[SparseImageMemoryBindInfo; 8]>,
    #[doc(alias = "pSignalSemaphores")]
    pub signal_semaphores: SmallVec<[Semaphore; 8]>,
}
impl BindSparseInfo {
    ///Adds an extension to the struct
    pub fn with_extension(mut self, ext: impl Into<BindSparseInfoExtension>) -> Self {
        self.extensions.push(ext.into());
        self
    }
    ///Get a reference to the `extensions` field.
    pub fn extensions(&self) -> &SmallVec<[BindSparseInfoExtension; 1]> {
        &self.extensions
    }
    ///Get a reference to the `wait_semaphores` field.
    pub fn wait_semaphores(&self) -> &SmallVec<[Semaphore; 8]> {
        &self.wait_semaphores
    }
    ///Get a reference to the `buffer_binds` field.
    pub fn buffer_binds(&self) -> &SmallVec<[SparseBufferMemoryBindInfo; 8]> {
        &self.buffer_binds
    }
    ///Get a reference to the `image_opaque_binds` field.
    pub fn image_opaque_binds(&self) -> &SmallVec<[SparseImageOpaqueMemoryBindInfo; 8]> {
        &self.image_opaque_binds
    }
    ///Get a reference to the `image_binds` field.
    pub fn image_binds(&self) -> &SmallVec<[SparseImageMemoryBindInfo; 8]> {
        &self.image_binds
    }
    ///Get a reference to the `signal_semaphores` field.
    pub fn signal_semaphores(&self) -> &SmallVec<[Semaphore; 8]> {
        &self.signal_semaphores
    }
    ///Get a mutable reference to the `extensions` field.
    pub fn extensions_mut(&mut self) -> &mut SmallVec<[BindSparseInfoExtension; 1]> {
        &mut self.extensions
    }
    ///Get a mutable reference to the `wait_semaphores` field.
    pub fn wait_semaphores_mut(&mut self) -> &mut SmallVec<[Semaphore; 8]> {
        &mut self.wait_semaphores
    }
    ///Get a mutable reference to the `buffer_binds` field.
    pub fn buffer_binds_mut(&mut self) -> &mut SmallVec<[SparseBufferMemoryBindInfo; 8]> {
        &mut self.buffer_binds
    }
    ///Get a mutable reference to the `image_opaque_binds` field.
    pub fn image_opaque_binds_mut(&mut self) -> &mut SmallVec<[SparseImageOpaqueMemoryBindInfo; 8]> {
        &mut self.image_opaque_binds
    }
    ///Get a mutable reference to the `image_binds` field.
    pub fn image_binds_mut(&mut self) -> &mut SmallVec<[SparseImageMemoryBindInfo; 8]> {
        &mut self.image_binds
    }
    ///Get a mutable reference to the `signal_semaphores` field.
    pub fn signal_semaphores_mut(&mut self) -> &mut SmallVec<[Semaphore; 8]> {
        &mut self.signal_semaphores
    }
    ///Sets the `extensions` field.
    pub fn set_extensions(&mut self, extensions: SmallVec<[BindSparseInfoExtension; 1]>) -> &mut Self {
        self.extensions = extensions;
        self
    }
    ///Sets the `wait_semaphores` field.
    pub fn set_wait_semaphores(&mut self, wait_semaphores: SmallVec<[Semaphore; 8]>) -> &mut Self {
        self.wait_semaphores = wait_semaphores;
        self
    }
    ///Sets the `buffer_binds` field.
    pub fn set_buffer_binds(&mut self, buffer_binds: SmallVec<[SparseBufferMemoryBindInfo; 8]>) -> &mut Self {
        self.buffer_binds = buffer_binds;
        self
    }
    ///Sets the `image_opaque_binds` field.
    pub fn set_image_opaque_binds(
        &mut self,
        image_opaque_binds: SmallVec<[SparseImageOpaqueMemoryBindInfo; 8]>,
    ) -> &mut Self {
        self.image_opaque_binds = image_opaque_binds;
        self
    }
    ///Sets the `image_binds` field.
    pub fn set_image_binds(&mut self, image_binds: SmallVec<[SparseImageMemoryBindInfo; 8]>) -> &mut Self {
        self.image_binds = image_binds;
        self
    }
    ///Sets the `signal_semaphores` field.
    pub fn set_signal_semaphores(&mut self, signal_semaphores: SmallVec<[Semaphore; 8]>) -> &mut Self {
        self.signal_semaphores = signal_semaphores;
        self
    }
    ///Sets the `extensions` field in a builder way.
    pub fn with_extensions(mut self, extensions: SmallVec<[BindSparseInfoExtension; 1]>) -> Self {
        self.extensions = extensions;
        self
    }
    ///Sets the `wait_semaphores` field in a builder way.
    pub fn with_wait_semaphores(mut self, wait_semaphores: SmallVec<[Semaphore; 8]>) -> Self {
        self.wait_semaphores = wait_semaphores;
        self
    }
    ///Sets the `buffer_binds` field in a builder way.
    pub fn with_buffer_binds(mut self, buffer_binds: SmallVec<[SparseBufferMemoryBindInfo; 8]>) -> Self {
        self.buffer_binds = buffer_binds;
        self
    }
    ///Sets the `image_opaque_binds` field in a builder way.
    pub fn with_image_opaque_binds(
        mut self,
        image_opaque_binds: SmallVec<[SparseImageOpaqueMemoryBindInfo; 8]>,
    ) -> Self {
        self.image_opaque_binds = image_opaque_binds;
        self
    }
    ///Sets the `image_binds` field in a builder way.
    pub fn with_image_binds(mut self, image_binds: SmallVec<[SparseImageMemoryBindInfo; 8]>) -> Self {
        self.image_binds = image_binds;
        self
    }
    ///Sets the `signal_semaphores` field in a builder way.
    pub fn with_signal_semaphores(mut self, signal_semaphores: SmallVec<[Semaphore; 8]>) -> Self {
        self.signal_semaphores = signal_semaphores;
        self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for BindSparseInfo {
    type LowLevel = crate::native::vulkan1_0::BindSparseInfo;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        let mut next = std::ptr::null();
        let mut extensions = self.extensions.iter();
        while let Some(ext) = extensions.next() {
            let ext = ext.into_low_level(context, bump);
            (*ext).next = next;
            next = ext;
        }
        let len_wait_semaphores = self.wait_semaphores.len() as u32;
        let wait_semaphores = bump
            .alloc_slice_fill_iter(self.wait_semaphores.iter().map(|x| x.into_low_level(context, bump)))
            .as_ptr()
            .cast();
        let len_buffer_binds = self.buffer_binds.len() as u32;
        let buffer_binds = bump
            .alloc_slice_fill_iter(self.buffer_binds.iter().map(|x| x.into_low_level(context, bump)))
            .as_ptr()
            .cast();
        let len_image_opaque_binds = self.image_opaque_binds.len() as u32;
        let image_opaque_binds = bump
            .alloc_slice_fill_iter(self.image_opaque_binds.iter().map(|x| x.into_low_level(context, bump)))
            .as_ptr()
            .cast();
        let len_image_binds = self.image_binds.len() as u32;
        let image_binds = bump
            .alloc_slice_fill_iter(self.image_binds.iter().map(|x| x.into_low_level(context, bump)))
            .as_ptr()
            .cast();
        let len_signal_semaphores = self.signal_semaphores.len() as u32;
        let signal_semaphores = bump
            .alloc_slice_fill_iter(self.signal_semaphores.iter().map(|x| x.into_low_level(context, bump)))
            .as_ptr()
            .cast();
        crate::native::vulkan1_0::BindSparseInfo {
            s_type: StructureType::BindSparseInfo,
            p_next: next,
            wait_semaphore_count: len_wait_semaphores,
            wait_semaphores: wait_semaphores,
            buffer_bind_count: len_buffer_binds,
            buffer_binds: buffer_binds,
            image_opaque_bind_count: len_image_opaque_binds,
            image_opaque_binds: image_opaque_binds,
            image_bind_count: len_image_binds,
            image_binds: image_binds,
            signal_semaphore_count: len_signal_semaphores,
            signal_semaphores: signal_semaphores,
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for BindSparseInfo {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        let mut next = value.p_next;
        let mut extensions = SmallVec::new();
        while !next.is_null() {
            extensions.push(crate::conv::FromLowLevel::from_low_level(context, next));
            next = std::ptr::read(next).next;
        }
        let wait_semaphores_len = value.wait_semaphore_count;
        let mut wait_semaphores = SmallVec::with_capacity(wait_semaphores_len as usize);
        for i in 0..wait_semaphores_len {
            wait_semaphores.push(crate::conv::FromLowLevel::from_low_level(
                context,
                value.wait_semaphores.add(i as usize).read(),
            ));
        }
        let buffer_binds_len = value.buffer_bind_count;
        let mut buffer_binds = SmallVec::with_capacity(buffer_binds_len as usize);
        for i in 0..buffer_binds_len {
            buffer_binds.push(crate::conv::FromLowLevel::from_low_level(
                context,
                value.buffer_binds.add(i as usize).read(),
            ));
        }
        let image_opaque_binds_len = value.image_opaque_bind_count;
        let mut image_opaque_binds = SmallVec::with_capacity(image_opaque_binds_len as usize);
        for i in 0..image_opaque_binds_len {
            image_opaque_binds.push(crate::conv::FromLowLevel::from_low_level(
                context,
                value.image_opaque_binds.add(i as usize).read(),
            ));
        }
        let image_binds_len = value.image_bind_count;
        let mut image_binds = SmallVec::with_capacity(image_binds_len as usize);
        for i in 0..image_binds_len {
            image_binds.push(crate::conv::FromLowLevel::from_low_level(
                context,
                value.image_binds.add(i as usize).read(),
            ));
        }
        let signal_semaphores_len = value.signal_semaphore_count;
        let mut signal_semaphores = SmallVec::with_capacity(signal_semaphores_len as usize);
        for i in 0..signal_semaphores_len {
            signal_semaphores.push(crate::conv::FromLowLevel::from_low_level(
                context,
                value.signal_semaphores.add(i as usize).read(),
            ));
        }
        Self {
            extensions: extensions,
            wait_semaphores: wait_semaphores,
            buffer_binds: buffer_binds,
            image_opaque_binds: image_opaque_binds,
            image_binds: image_binds,
            signal_semaphores: signal_semaphores,
        }
    }
}
#[derive(Clone, PartialEq, Debug)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
///Extensions for [`BindSparseInfo`]
pub enum BindSparseInfoExtension {
    ///Contains a type [`DeviceGroupBindSparseInfo`] for extending [`BindSparseInfo`]
    DeviceGroupBindSparseInfo(DeviceGroupBindSparseInfo),
    #[cfg(feature = "VULKAN_1_2")]
    ///Contains a type [`TimelineSemaphoreSubmitInfo`] for extending [`BindSparseInfo`]
    TimelineSemaphoreSubmitInfo(TimelineSemaphoreSubmitInfo),
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for BindSparseInfoExtension {
    type LowLevel = *const crate::native::vulkan1_0::BaseInStructure;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        match self {
            Self::DeviceGroupBindSparseInfo(ext) => (bump.alloc(ext.into_low_level(context, bump))
                as *mut crate::native::vulkan1_1::DeviceGroupBindSparseInfo)
                .cast(),
            #[cfg(feature = "VULKAN_1_2")]
            Self::TimelineSemaphoreSubmitInfo(ext) => (bump.alloc(ext.into_low_level(context, bump))
                as *mut crate::native::vulkan1_2::TimelineSemaphoreSubmitInfo)
                .cast(),
            other => unreachable!("unexpected variant {:?}", other),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for BindSparseInfoExtension {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        assert!(!value.is_null());
        match (*value).s_type {
            crate::native::vulkan1_0::StructureType::DeviceGroupBindSparseInfo => {
                Self::DeviceGroupBindSparseInfo(DeviceGroupBindSparseInfo::from_low_level(
                    context,
                    std::ptr::read(value.cast::<crate::native::vulkan1_1::DeviceGroupBindSparseInfo>()),
                ))
            },
            #[cfg(feature = "VULKAN_1_2")]
            crate::native::vulkan1_0::StructureType::TimelineSemaphoreSubmitInfo => {
                Self::TimelineSemaphoreSubmitInfo(TimelineSemaphoreSubmitInfo::from_low_level(
                    context,
                    std::ptr::read(value.cast::<crate::native::vulkan1_2::TimelineSemaphoreSubmitInfo>()),
                ))
            },
            other => panic!(
                "Structure type {:?} is not a member of {}",
                other,
                stringify!(BindSparseInfo)
            ),
        }
    }
}
impl From<DeviceGroupBindSparseInfo> for BindSparseInfoExtension {
    fn from(ext: DeviceGroupBindSparseInfo) -> Self {
        Self::DeviceGroupBindSparseInfo(ext)
    }
}
impl TryInto<DeviceGroupBindSparseInfo> for BindSparseInfoExtension {
    type Error = BindSparseInfoExtension;
    fn try_into(self) -> Result<DeviceGroupBindSparseInfo, Self::Error> {
        match self {
            Self::DeviceGroupBindSparseInfo(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VULKAN_1_2")]
impl From<TimelineSemaphoreSubmitInfo> for BindSparseInfoExtension {
    fn from(ext: TimelineSemaphoreSubmitInfo) -> Self {
        Self::TimelineSemaphoreSubmitInfo(ext)
    }
}
#[cfg(feature = "VULKAN_1_2")]
impl TryInto<TimelineSemaphoreSubmitInfo> for BindSparseInfoExtension {
    type Error = BindSparseInfoExtension;
    fn try_into(self) -> Result<TimelineSemaphoreSubmitInfo, Self::Error> {
        match self {
            Self::TimelineSemaphoreSubmitInfo(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
impl ImageCopy {
    ///Get a reference to the `src_subresource` field.
    pub fn src_subresource(&self) -> ImageSubresourceLayers {
        self.src_subresource
    }
    ///Get a reference to the `src_offset` field.
    pub fn src_offset(&self) -> Offset3D {
        self.src_offset
    }
    ///Get a reference to the `dst_subresource` field.
    pub fn dst_subresource(&self) -> ImageSubresourceLayers {
        self.dst_subresource
    }
    ///Get a reference to the `dst_offset` field.
    pub fn dst_offset(&self) -> Offset3D {
        self.dst_offset
    }
    ///Get a reference to the `extent` field.
    pub fn extent(&self) -> Extent3D {
        self.extent
    }
    ///Get a mutable reference to the `src_subresource` field.
    pub fn src_subresource_mut(&mut self) -> &mut ImageSubresourceLayers {
        &mut self.src_subresource
    }
    ///Get a mutable reference to the `src_offset` field.
    pub fn src_offset_mut(&mut self) -> &mut Offset3D {
        &mut self.src_offset
    }
    ///Get a mutable reference to the `dst_subresource` field.
    pub fn dst_subresource_mut(&mut self) -> &mut ImageSubresourceLayers {
        &mut self.dst_subresource
    }
    ///Get a mutable reference to the `dst_offset` field.
    pub fn dst_offset_mut(&mut self) -> &mut Offset3D {
        &mut self.dst_offset
    }
    ///Get a mutable reference to the `extent` field.
    pub fn extent_mut(&mut self) -> &mut Extent3D {
        &mut self.extent
    }
    ///Sets the `src_subresource` field.
    pub fn set_src_subresource(&mut self, src_subresource: ImageSubresourceLayers) -> &mut Self {
        self.src_subresource = src_subresource;
        self
    }
    ///Sets the `src_offset` field.
    pub fn set_src_offset(&mut self, src_offset: Offset3D) -> &mut Self {
        self.src_offset = src_offset;
        self
    }
    ///Sets the `dst_subresource` field.
    pub fn set_dst_subresource(&mut self, dst_subresource: ImageSubresourceLayers) -> &mut Self {
        self.dst_subresource = dst_subresource;
        self
    }
    ///Sets the `dst_offset` field.
    pub fn set_dst_offset(&mut self, dst_offset: Offset3D) -> &mut Self {
        self.dst_offset = dst_offset;
        self
    }
    ///Sets the `extent` field.
    pub fn set_extent(&mut self, extent: Extent3D) -> &mut Self {
        self.extent = extent;
        self
    }
    ///Sets the `src_subresource` field in a builder way.
    pub fn with_src_subresource(mut self, src_subresource: ImageSubresourceLayers) -> Self {
        self.src_subresource = src_subresource;
        self
    }
    ///Sets the `src_offset` field in a builder way.
    pub fn with_src_offset(mut self, src_offset: Offset3D) -> Self {
        self.src_offset = src_offset;
        self
    }
    ///Sets the `dst_subresource` field in a builder way.
    pub fn with_dst_subresource(mut self, dst_subresource: ImageSubresourceLayers) -> Self {
        self.dst_subresource = dst_subresource;
        self
    }
    ///Sets the `dst_offset` field in a builder way.
    pub fn with_dst_offset(mut self, dst_offset: Offset3D) -> Self {
        self.dst_offset = dst_offset;
        self
    }
    ///Sets the `extent` field in a builder way.
    pub fn with_extent(mut self, extent: Extent3D) -> Self {
        self.extent = extent;
        self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for ImageCopy {
    type LowLevel = crate::native::vulkan1_0::ImageCopy;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        crate::native::vulkan1_0::ImageCopy {
            src_subresource: self.src_subresource.into_low_level(context, bump),
            src_offset: self.src_offset.into_low_level(context, bump),
            dst_subresource: self.dst_subresource.into_low_level(context, bump),
            dst_offset: self.dst_offset.into_low_level(context, bump),
            extent: self.extent.into_low_level(context, bump),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for ImageCopy {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        Self {
            src_subresource: crate::conv::FromLowLevel::from_low_level(context, value.src_subresource),
            src_offset: crate::conv::FromLowLevel::from_low_level(context, value.src_offset),
            dst_subresource: crate::conv::FromLowLevel::from_low_level(context, value.dst_subresource),
            dst_offset: crate::conv::FromLowLevel::from_low_level(context, value.dst_offset),
            extent: crate::conv::FromLowLevel::from_low_level(context, value.extent),
        }
    }
}
impl ImageBlit {
    ///Get a reference to the `src_subresource` field.
    pub fn src_subresource(&self) -> ImageSubresourceLayers {
        self.src_subresource
    }
    ///Get a reference to the `src_offsets` field.
    pub fn src_offsets(&self) -> [Offset3D; 2 as usize] {
        self.src_offsets
    }
    ///Get a reference to the `dst_subresource` field.
    pub fn dst_subresource(&self) -> ImageSubresourceLayers {
        self.dst_subresource
    }
    ///Get a reference to the `dst_offsets` field.
    pub fn dst_offsets(&self) -> [Offset3D; 2 as usize] {
        self.dst_offsets
    }
    ///Get a mutable reference to the `src_subresource` field.
    pub fn src_subresource_mut(&mut self) -> &mut ImageSubresourceLayers {
        &mut self.src_subresource
    }
    ///Get a mutable reference to the `src_offsets` field.
    pub fn src_offsets_mut(&mut self) -> &mut [Offset3D; 2 as usize] {
        &mut self.src_offsets
    }
    ///Get a mutable reference to the `dst_subresource` field.
    pub fn dst_subresource_mut(&mut self) -> &mut ImageSubresourceLayers {
        &mut self.dst_subresource
    }
    ///Get a mutable reference to the `dst_offsets` field.
    pub fn dst_offsets_mut(&mut self) -> &mut [Offset3D; 2 as usize] {
        &mut self.dst_offsets
    }
    ///Sets the `src_subresource` field.
    pub fn set_src_subresource(&mut self, src_subresource: ImageSubresourceLayers) -> &mut Self {
        self.src_subresource = src_subresource;
        self
    }
    ///Sets the `src_offsets` field.
    pub fn set_src_offsets(&mut self, src_offsets: [Offset3D; 2 as usize]) -> &mut Self {
        self.src_offsets = src_offsets;
        self
    }
    ///Sets the `dst_subresource` field.
    pub fn set_dst_subresource(&mut self, dst_subresource: ImageSubresourceLayers) -> &mut Self {
        self.dst_subresource = dst_subresource;
        self
    }
    ///Sets the `dst_offsets` field.
    pub fn set_dst_offsets(&mut self, dst_offsets: [Offset3D; 2 as usize]) -> &mut Self {
        self.dst_offsets = dst_offsets;
        self
    }
    ///Sets the `src_subresource` field in a builder way.
    pub fn with_src_subresource(mut self, src_subresource: ImageSubresourceLayers) -> Self {
        self.src_subresource = src_subresource;
        self
    }
    ///Sets the `src_offsets` field in a builder way.
    pub fn with_src_offsets(mut self, src_offsets: [Offset3D; 2 as usize]) -> Self {
        self.src_offsets = src_offsets;
        self
    }
    ///Sets the `dst_subresource` field in a builder way.
    pub fn with_dst_subresource(mut self, dst_subresource: ImageSubresourceLayers) -> Self {
        self.dst_subresource = dst_subresource;
        self
    }
    ///Sets the `dst_offsets` field in a builder way.
    pub fn with_dst_offsets(mut self, dst_offsets: [Offset3D; 2 as usize]) -> Self {
        self.dst_offsets = dst_offsets;
        self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for ImageBlit {
    type LowLevel = crate::native::vulkan1_0::ImageBlit;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        crate::native::vulkan1_0::ImageBlit {
            src_subresource: self.src_subresource.into_low_level(context, bump),
            src_offsets: self.src_offsets.into_low_level(context, bump),
            dst_subresource: self.dst_subresource.into_low_level(context, bump),
            dst_offsets: self.dst_offsets.into_low_level(context, bump),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for ImageBlit {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        Self {
            src_subresource: crate::conv::FromLowLevel::from_low_level(context, value.src_subresource),
            src_offsets: crate::conv::FromLowLevel::from_low_level(context, value.src_offsets),
            dst_subresource: crate::conv::FromLowLevel::from_low_level(context, value.dst_subresource),
            dst_offsets: crate::conv::FromLowLevel::from_low_level(context, value.dst_offsets),
        }
    }
}
impl BufferImageCopy {
    ///Get a reference to the `buffer_offset` field.
    pub fn buffer_offset(&self) -> &DeviceSize {
        &self.buffer_offset
    }
    ///Get a reference to the `buffer_row_length` field.
    pub fn buffer_row_length(&self) -> u32 {
        self.buffer_row_length
    }
    ///Get a reference to the `buffer_image_height` field.
    pub fn buffer_image_height(&self) -> u32 {
        self.buffer_image_height
    }
    ///Get a reference to the `image_subresource` field.
    pub fn image_subresource(&self) -> ImageSubresourceLayers {
        self.image_subresource
    }
    ///Get a reference to the `image_offset` field.
    pub fn image_offset(&self) -> Offset3D {
        self.image_offset
    }
    ///Get a reference to the `image_extent` field.
    pub fn image_extent(&self) -> Extent3D {
        self.image_extent
    }
    ///Get a mutable reference to the `buffer_offset` field.
    pub fn buffer_offset_mut(&mut self) -> &mut DeviceSize {
        &mut self.buffer_offset
    }
    ///Get a mutable reference to the `buffer_row_length` field.
    pub fn buffer_row_length_mut(&mut self) -> &mut u32 {
        &mut self.buffer_row_length
    }
    ///Get a mutable reference to the `buffer_image_height` field.
    pub fn buffer_image_height_mut(&mut self) -> &mut u32 {
        &mut self.buffer_image_height
    }
    ///Get a mutable reference to the `image_subresource` field.
    pub fn image_subresource_mut(&mut self) -> &mut ImageSubresourceLayers {
        &mut self.image_subresource
    }
    ///Get a mutable reference to the `image_offset` field.
    pub fn image_offset_mut(&mut self) -> &mut Offset3D {
        &mut self.image_offset
    }
    ///Get a mutable reference to the `image_extent` field.
    pub fn image_extent_mut(&mut self) -> &mut Extent3D {
        &mut self.image_extent
    }
    ///Sets the `buffer_offset` field.
    pub fn set_buffer_offset(&mut self, buffer_offset: DeviceSize) -> &mut Self {
        self.buffer_offset = buffer_offset;
        self
    }
    ///Sets the `buffer_row_length` field.
    pub fn set_buffer_row_length(&mut self, buffer_row_length: u32) -> &mut Self {
        self.buffer_row_length = buffer_row_length;
        self
    }
    ///Sets the `buffer_image_height` field.
    pub fn set_buffer_image_height(&mut self, buffer_image_height: u32) -> &mut Self {
        self.buffer_image_height = buffer_image_height;
        self
    }
    ///Sets the `image_subresource` field.
    pub fn set_image_subresource(&mut self, image_subresource: ImageSubresourceLayers) -> &mut Self {
        self.image_subresource = image_subresource;
        self
    }
    ///Sets the `image_offset` field.
    pub fn set_image_offset(&mut self, image_offset: Offset3D) -> &mut Self {
        self.image_offset = image_offset;
        self
    }
    ///Sets the `image_extent` field.
    pub fn set_image_extent(&mut self, image_extent: Extent3D) -> &mut Self {
        self.image_extent = image_extent;
        self
    }
    ///Sets the `buffer_offset` field in a builder way.
    pub fn with_buffer_offset(mut self, buffer_offset: DeviceSize) -> Self {
        self.buffer_offset = buffer_offset;
        self
    }
    ///Sets the `buffer_row_length` field in a builder way.
    pub fn with_buffer_row_length(mut self, buffer_row_length: u32) -> Self {
        self.buffer_row_length = buffer_row_length;
        self
    }
    ///Sets the `buffer_image_height` field in a builder way.
    pub fn with_buffer_image_height(mut self, buffer_image_height: u32) -> Self {
        self.buffer_image_height = buffer_image_height;
        self
    }
    ///Sets the `image_subresource` field in a builder way.
    pub fn with_image_subresource(mut self, image_subresource: ImageSubresourceLayers) -> Self {
        self.image_subresource = image_subresource;
        self
    }
    ///Sets the `image_offset` field in a builder way.
    pub fn with_image_offset(mut self, image_offset: Offset3D) -> Self {
        self.image_offset = image_offset;
        self
    }
    ///Sets the `image_extent` field in a builder way.
    pub fn with_image_extent(mut self, image_extent: Extent3D) -> Self {
        self.image_extent = image_extent;
        self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for BufferImageCopy {
    type LowLevel = crate::native::vulkan1_0::BufferImageCopy;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        crate::native::vulkan1_0::BufferImageCopy {
            buffer_offset: self.buffer_offset.into_low_level(context, bump),
            buffer_row_length: self.buffer_row_length.into_low_level(context, bump),
            buffer_image_height: self.buffer_image_height.into_low_level(context, bump),
            image_subresource: self.image_subresource.into_low_level(context, bump),
            image_offset: self.image_offset.into_low_level(context, bump),
            image_extent: self.image_extent.into_low_level(context, bump),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for BufferImageCopy {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        Self {
            buffer_offset: crate::conv::FromLowLevel::from_low_level(context, value.buffer_offset),
            buffer_row_length: crate::conv::FromLowLevel::from_low_level(context, value.buffer_row_length),
            buffer_image_height: crate::conv::FromLowLevel::from_low_level(context, value.buffer_image_height),
            image_subresource: crate::conv::FromLowLevel::from_low_level(context, value.image_subresource),
            image_offset: crate::conv::FromLowLevel::from_low_level(context, value.image_offset),
            image_extent: crate::conv::FromLowLevel::from_low_level(context, value.image_extent),
        }
    }
}
impl ImageResolve {
    ///Get a reference to the `src_subresource` field.
    pub fn src_subresource(&self) -> ImageSubresourceLayers {
        self.src_subresource
    }
    ///Get a reference to the `src_offset` field.
    pub fn src_offset(&self) -> Offset3D {
        self.src_offset
    }
    ///Get a reference to the `dst_subresource` field.
    pub fn dst_subresource(&self) -> ImageSubresourceLayers {
        self.dst_subresource
    }
    ///Get a reference to the `dst_offset` field.
    pub fn dst_offset(&self) -> Offset3D {
        self.dst_offset
    }
    ///Get a reference to the `extent` field.
    pub fn extent(&self) -> Extent3D {
        self.extent
    }
    ///Get a mutable reference to the `src_subresource` field.
    pub fn src_subresource_mut(&mut self) -> &mut ImageSubresourceLayers {
        &mut self.src_subresource
    }
    ///Get a mutable reference to the `src_offset` field.
    pub fn src_offset_mut(&mut self) -> &mut Offset3D {
        &mut self.src_offset
    }
    ///Get a mutable reference to the `dst_subresource` field.
    pub fn dst_subresource_mut(&mut self) -> &mut ImageSubresourceLayers {
        &mut self.dst_subresource
    }
    ///Get a mutable reference to the `dst_offset` field.
    pub fn dst_offset_mut(&mut self) -> &mut Offset3D {
        &mut self.dst_offset
    }
    ///Get a mutable reference to the `extent` field.
    pub fn extent_mut(&mut self) -> &mut Extent3D {
        &mut self.extent
    }
    ///Sets the `src_subresource` field.
    pub fn set_src_subresource(&mut self, src_subresource: ImageSubresourceLayers) -> &mut Self {
        self.src_subresource = src_subresource;
        self
    }
    ///Sets the `src_offset` field.
    pub fn set_src_offset(&mut self, src_offset: Offset3D) -> &mut Self {
        self.src_offset = src_offset;
        self
    }
    ///Sets the `dst_subresource` field.
    pub fn set_dst_subresource(&mut self, dst_subresource: ImageSubresourceLayers) -> &mut Self {
        self.dst_subresource = dst_subresource;
        self
    }
    ///Sets the `dst_offset` field.
    pub fn set_dst_offset(&mut self, dst_offset: Offset3D) -> &mut Self {
        self.dst_offset = dst_offset;
        self
    }
    ///Sets the `extent` field.
    pub fn set_extent(&mut self, extent: Extent3D) -> &mut Self {
        self.extent = extent;
        self
    }
    ///Sets the `src_subresource` field in a builder way.
    pub fn with_src_subresource(mut self, src_subresource: ImageSubresourceLayers) -> Self {
        self.src_subresource = src_subresource;
        self
    }
    ///Sets the `src_offset` field in a builder way.
    pub fn with_src_offset(mut self, src_offset: Offset3D) -> Self {
        self.src_offset = src_offset;
        self
    }
    ///Sets the `dst_subresource` field in a builder way.
    pub fn with_dst_subresource(mut self, dst_subresource: ImageSubresourceLayers) -> Self {
        self.dst_subresource = dst_subresource;
        self
    }
    ///Sets the `dst_offset` field in a builder way.
    pub fn with_dst_offset(mut self, dst_offset: Offset3D) -> Self {
        self.dst_offset = dst_offset;
        self
    }
    ///Sets the `extent` field in a builder way.
    pub fn with_extent(mut self, extent: Extent3D) -> Self {
        self.extent = extent;
        self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for ImageResolve {
    type LowLevel = crate::native::vulkan1_0::ImageResolve;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        crate::native::vulkan1_0::ImageResolve {
            src_subresource: self.src_subresource.into_low_level(context, bump),
            src_offset: self.src_offset.into_low_level(context, bump),
            dst_subresource: self.dst_subresource.into_low_level(context, bump),
            dst_offset: self.dst_offset.into_low_level(context, bump),
            extent: self.extent.into_low_level(context, bump),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for ImageResolve {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        Self {
            src_subresource: crate::conv::FromLowLevel::from_low_level(context, value.src_subresource),
            src_offset: crate::conv::FromLowLevel::from_low_level(context, value.src_offset),
            dst_subresource: crate::conv::FromLowLevel::from_low_level(context, value.dst_subresource),
            dst_offset: crate::conv::FromLowLevel::from_low_level(context, value.dst_offset),
            extent: crate::conv::FromLowLevel::from_low_level(context, value.extent),
        }
    }
}
#[doc(alias = "VkShaderModuleCreateInfo")]
#[derive(Clone, PartialEq, Debug, Default)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct ShaderModuleCreateInfo {
    #[doc(alias = "pNext")]
    pub extensions: SmallVec<[ShaderModuleCreateInfoExtension; 1]>,
    pub flags: ShaderModuleCreateFlags,
    #[doc(alias = "pCode")]
    pub code: SmallVec<[u32; 8]>,
}
impl ShaderModuleCreateInfo {
    ///Adds an extension to the struct
    pub fn with_extension(mut self, ext: impl Into<ShaderModuleCreateInfoExtension>) -> Self {
        self.extensions.push(ext.into());
        self
    }
    ///Get a reference to the `extensions` field.
    pub fn extensions(&self) -> &SmallVec<[ShaderModuleCreateInfoExtension; 1]> {
        &self.extensions
    }
    ///Get a reference to the `flags` field.
    pub fn flags(&self) -> ShaderModuleCreateFlags {
        self.flags
    }
    ///Get a reference to the `code` field.
    pub fn code(&self) -> &SmallVec<[u32; 8]> {
        &self.code
    }
    ///Get a mutable reference to the `extensions` field.
    pub fn extensions_mut(&mut self) -> &mut SmallVec<[ShaderModuleCreateInfoExtension; 1]> {
        &mut self.extensions
    }
    ///Get a mutable reference to the `flags` field.
    pub fn flags_mut(&mut self) -> &mut ShaderModuleCreateFlags {
        &mut self.flags
    }
    ///Get a mutable reference to the `code` field.
    pub fn code_mut(&mut self) -> &mut SmallVec<[u32; 8]> {
        &mut self.code
    }
    ///Sets the `extensions` field.
    pub fn set_extensions(&mut self, extensions: SmallVec<[ShaderModuleCreateInfoExtension; 1]>) -> &mut Self {
        self.extensions = extensions;
        self
    }
    ///Sets the `flags` field.
    pub fn set_flags(&mut self, flags: ShaderModuleCreateFlags) -> &mut Self {
        self.flags = flags;
        self
    }
    ///Sets the `code` field.
    pub fn set_code(&mut self, code: SmallVec<[u32; 8]>) -> &mut Self {
        self.code = code;
        self
    }
    ///Sets the `extensions` field in a builder way.
    pub fn with_extensions(mut self, extensions: SmallVec<[ShaderModuleCreateInfoExtension; 1]>) -> Self {
        self.extensions = extensions;
        self
    }
    ///Sets the `flags` field in a builder way.
    pub fn with_flags(mut self, flags: ShaderModuleCreateFlags) -> Self {
        self.flags = flags;
        self
    }
    ///Sets the `code` field in a builder way.
    pub fn with_code(mut self, code: SmallVec<[u32; 8]>) -> Self {
        self.code = code;
        self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for ShaderModuleCreateInfo {
    type LowLevel = crate::native::vulkan1_0::ShaderModuleCreateInfo;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        let mut next = std::ptr::null();
        let mut extensions = self.extensions.iter();
        while let Some(ext) = extensions.next() {
            let ext = ext.into_low_level(context, bump);
            (*ext).next = next;
            next = ext;
        }
        let len_code = self.code.len() as usize;
        let code = bump
            .alloc_slice_fill_iter(self.code.iter().map(|x| x.into_low_level(context, bump)))
            .as_ptr()
            .cast();
        crate::native::vulkan1_0::ShaderModuleCreateInfo {
            s_type: StructureType::ShaderModuleCreateInfo,
            p_next: next,
            flags: self.flags.into_low_level(context, bump),
            code_size: (4) * (len_code),
            code: code,
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for ShaderModuleCreateInfo {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        let mut next = value.p_next;
        let mut extensions = SmallVec::new();
        while !next.is_null() {
            extensions.push(crate::conv::FromLowLevel::from_low_level(context, next));
            next = std::ptr::read(next).next;
        }
        let code_len = (value.code_size) / (4);
        let mut code = SmallVec::with_capacity(code_len as usize);
        for i in 0..code_len {
            code.push(crate::conv::FromLowLevel::from_low_level(
                context,
                value.code.add(i as usize).read(),
            ));
        }
        Self {
            extensions: extensions,
            flags: crate::conv::FromLowLevel::from_low_level(context, value.flags),
            code: code,
        }
    }
}
#[derive(Clone, PartialEq, Debug)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
///Extensions for [`ShaderModuleCreateInfo`]
pub enum ShaderModuleCreateInfoExtension {
    #[cfg(feature = "VK_EXT_validation_cache")]
    ///Contains a type [`ShaderModuleValidationCacheCreateInfoEXT`] for extending
    /// [`ShaderModuleCreateInfo`]
    ShaderModuleValidationCacheCreateInfoEXT(ShaderModuleValidationCacheCreateInfoEXT),
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for ShaderModuleCreateInfoExtension {
    type LowLevel = *const crate::native::vulkan1_0::BaseInStructure;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        match self {
            #[cfg(feature = "VK_EXT_validation_cache")]
            Self::ShaderModuleValidationCacheCreateInfoEXT(ext) => (bump.alloc(ext.into_low_level(context, bump))
                as *mut crate::native::extensions::ext_validation_cache::ShaderModuleValidationCacheCreateInfoEXT)
                .cast(),
            other => unreachable!("unexpected variant {:?}", other),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for ShaderModuleCreateInfoExtension {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        assert!(!value.is_null());
        match (* value) . s_type { # [cfg (feature = "VK_EXT_validation_cache")] crate :: native :: vulkan1_0 :: StructureType :: ShaderModuleValidationCacheCreateInfoExt => Self :: ShaderModuleValidationCacheCreateInfoEXT (ShaderModuleValidationCacheCreateInfoEXT :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: ext_validation_cache :: ShaderModuleValidationCacheCreateInfoEXT > ()))) , other => panic ! ("Structure type {:?} is not a member of {}" , other , stringify ! (ShaderModuleCreateInfo)) }
    }
}
#[cfg(feature = "VK_EXT_validation_cache")]
impl From<ShaderModuleValidationCacheCreateInfoEXT> for ShaderModuleCreateInfoExtension {
    fn from(ext: ShaderModuleValidationCacheCreateInfoEXT) -> Self {
        Self::ShaderModuleValidationCacheCreateInfoEXT(ext)
    }
}
#[cfg(feature = "VK_EXT_validation_cache")]
impl TryInto<ShaderModuleValidationCacheCreateInfoEXT> for ShaderModuleCreateInfoExtension {
    type Error = ShaderModuleCreateInfoExtension;
    fn try_into(self) -> Result<ShaderModuleValidationCacheCreateInfoEXT, Self::Error> {
        match self {
            Self::ShaderModuleValidationCacheCreateInfoEXT(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[doc(alias = "VkDescriptorSetLayoutBinding")]
#[derive(Clone, PartialEq, Debug, Default)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct DescriptorSetLayoutBinding {
    pub binding: u32,
    #[doc(alias = "descriptorType")]
    pub descriptor_type: DescriptorType,
    #[doc(alias = "stageFlags")]
    pub stage_flags: ShaderStageFlags,
    #[doc(alias = "pImmutableSamplers")]
    pub immutable_samplers: SmallVec<[Sampler; 8]>,
}
impl DescriptorSetLayoutBinding {
    ///Get a reference to the `binding` field.
    pub fn binding(&self) -> u32 {
        self.binding
    }
    ///Get a reference to the `descriptor_type` field.
    pub fn descriptor_type(&self) -> DescriptorType {
        self.descriptor_type
    }
    ///Get a reference to the `stage_flags` field.
    pub fn stage_flags(&self) -> ShaderStageFlags {
        self.stage_flags
    }
    ///Get a reference to the `immutable_samplers` field.
    pub fn immutable_samplers(&self) -> &SmallVec<[Sampler; 8]> {
        &self.immutable_samplers
    }
    ///Get a mutable reference to the `binding` field.
    pub fn binding_mut(&mut self) -> &mut u32 {
        &mut self.binding
    }
    ///Get a mutable reference to the `descriptor_type` field.
    pub fn descriptor_type_mut(&mut self) -> &mut DescriptorType {
        &mut self.descriptor_type
    }
    ///Get a mutable reference to the `stage_flags` field.
    pub fn stage_flags_mut(&mut self) -> &mut ShaderStageFlags {
        &mut self.stage_flags
    }
    ///Get a mutable reference to the `immutable_samplers` field.
    pub fn immutable_samplers_mut(&mut self) -> &mut SmallVec<[Sampler; 8]> {
        &mut self.immutable_samplers
    }
    ///Sets the `binding` field.
    pub fn set_binding(&mut self, binding: u32) -> &mut Self {
        self.binding = binding;
        self
    }
    ///Sets the `descriptor_type` field.
    pub fn set_descriptor_type(&mut self, descriptor_type: DescriptorType) -> &mut Self {
        self.descriptor_type = descriptor_type;
        self
    }
    ///Sets the `stage_flags` field.
    pub fn set_stage_flags(&mut self, stage_flags: ShaderStageFlags) -> &mut Self {
        self.stage_flags = stage_flags;
        self
    }
    ///Sets the `immutable_samplers` field.
    pub fn set_immutable_samplers(&mut self, immutable_samplers: SmallVec<[Sampler; 8]>) -> &mut Self {
        self.immutable_samplers = immutable_samplers;
        self
    }
    ///Sets the `binding` field in a builder way.
    pub fn with_binding(mut self, binding: u32) -> Self {
        self.binding = binding;
        self
    }
    ///Sets the `descriptor_type` field in a builder way.
    pub fn with_descriptor_type(mut self, descriptor_type: DescriptorType) -> Self {
        self.descriptor_type = descriptor_type;
        self
    }
    ///Sets the `stage_flags` field in a builder way.
    pub fn with_stage_flags(mut self, stage_flags: ShaderStageFlags) -> Self {
        self.stage_flags = stage_flags;
        self
    }
    ///Sets the `immutable_samplers` field in a builder way.
    pub fn with_immutable_samplers(mut self, immutable_samplers: SmallVec<[Sampler; 8]>) -> Self {
        self.immutable_samplers = immutable_samplers;
        self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for DescriptorSetLayoutBinding {
    type LowLevel = crate::native::vulkan1_0::DescriptorSetLayoutBinding;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        let len_immutable_samplers = self.immutable_samplers.len() as u32;
        let immutable_samplers = bump
            .alloc_slice_fill_iter(self.immutable_samplers.iter().map(|x| x.into_low_level(context, bump)))
            .as_ptr()
            .cast();
        crate::native::vulkan1_0::DescriptorSetLayoutBinding {
            binding: self.binding.into_low_level(context, bump),
            descriptor_type: self.descriptor_type.into_low_level(context, bump),
            descriptor_count: len_immutable_samplers,
            stage_flags: self.stage_flags.into_low_level(context, bump),
            immutable_samplers: immutable_samplers,
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for DescriptorSetLayoutBinding {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        let immutable_samplers_len = value.descriptor_count;
        let mut immutable_samplers = SmallVec::with_capacity(immutable_samplers_len as usize);
        for i in 0..immutable_samplers_len {
            immutable_samplers.push(crate::conv::FromLowLevel::from_low_level(
                context,
                value.immutable_samplers.add(i as usize).read(),
            ));
        }
        Self {
            binding: crate::conv::FromLowLevel::from_low_level(context, value.binding),
            descriptor_type: crate::conv::FromLowLevel::from_low_level(context, value.descriptor_type),
            stage_flags: crate::conv::FromLowLevel::from_low_level(context, value.stage_flags),
            immutable_samplers: immutable_samplers,
        }
    }
}
#[doc(alias = "VkDescriptorSetLayoutCreateInfo")]
#[derive(Clone, PartialEq, Debug, Default)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct DescriptorSetLayoutCreateInfo {
    #[doc(alias = "pNext")]
    pub extensions: SmallVec<[DescriptorSetLayoutCreateInfoExtension; 1]>,
    pub flags: DescriptorSetLayoutCreateFlags,
    #[doc(alias = "pBindings")]
    pub bindings: SmallVec<[DescriptorSetLayoutBinding; 8]>,
}
impl DescriptorSetLayoutCreateInfo {
    ///Adds an extension to the struct
    pub fn with_extension(mut self, ext: impl Into<DescriptorSetLayoutCreateInfoExtension>) -> Self {
        self.extensions.push(ext.into());
        self
    }
    ///Get a reference to the `extensions` field.
    pub fn extensions(&self) -> &SmallVec<[DescriptorSetLayoutCreateInfoExtension; 1]> {
        &self.extensions
    }
    ///Get a reference to the `flags` field.
    pub fn flags(&self) -> DescriptorSetLayoutCreateFlags {
        self.flags
    }
    ///Get a reference to the `bindings` field.
    pub fn bindings(&self) -> &SmallVec<[DescriptorSetLayoutBinding; 8]> {
        &self.bindings
    }
    ///Get a mutable reference to the `extensions` field.
    pub fn extensions_mut(&mut self) -> &mut SmallVec<[DescriptorSetLayoutCreateInfoExtension; 1]> {
        &mut self.extensions
    }
    ///Get a mutable reference to the `flags` field.
    pub fn flags_mut(&mut self) -> &mut DescriptorSetLayoutCreateFlags {
        &mut self.flags
    }
    ///Get a mutable reference to the `bindings` field.
    pub fn bindings_mut(&mut self) -> &mut SmallVec<[DescriptorSetLayoutBinding; 8]> {
        &mut self.bindings
    }
    ///Sets the `extensions` field.
    pub fn set_extensions(&mut self, extensions: SmallVec<[DescriptorSetLayoutCreateInfoExtension; 1]>) -> &mut Self {
        self.extensions = extensions;
        self
    }
    ///Sets the `flags` field.
    pub fn set_flags(&mut self, flags: DescriptorSetLayoutCreateFlags) -> &mut Self {
        self.flags = flags;
        self
    }
    ///Sets the `bindings` field.
    pub fn set_bindings(&mut self, bindings: SmallVec<[DescriptorSetLayoutBinding; 8]>) -> &mut Self {
        self.bindings = bindings;
        self
    }
    ///Sets the `extensions` field in a builder way.
    pub fn with_extensions(mut self, extensions: SmallVec<[DescriptorSetLayoutCreateInfoExtension; 1]>) -> Self {
        self.extensions = extensions;
        self
    }
    ///Sets the `flags` field in a builder way.
    pub fn with_flags(mut self, flags: DescriptorSetLayoutCreateFlags) -> Self {
        self.flags = flags;
        self
    }
    ///Sets the `bindings` field in a builder way.
    pub fn with_bindings(mut self, bindings: SmallVec<[DescriptorSetLayoutBinding; 8]>) -> Self {
        self.bindings = bindings;
        self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for DescriptorSetLayoutCreateInfo {
    type LowLevel = crate::native::vulkan1_0::DescriptorSetLayoutCreateInfo;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        let mut next = std::ptr::null();
        let mut extensions = self.extensions.iter();
        while let Some(ext) = extensions.next() {
            let ext = ext.into_low_level(context, bump);
            (*ext).next = next;
            next = ext;
        }
        let len_bindings = self.bindings.len() as u32;
        let bindings = bump
            .alloc_slice_fill_iter(self.bindings.iter().map(|x| x.into_low_level(context, bump)))
            .as_ptr()
            .cast();
        crate::native::vulkan1_0::DescriptorSetLayoutCreateInfo {
            s_type: StructureType::DescriptorSetLayoutCreateInfo,
            p_next: next,
            flags: self.flags.into_low_level(context, bump),
            binding_count: len_bindings,
            bindings: bindings,
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for DescriptorSetLayoutCreateInfo {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        let mut next = value.p_next;
        let mut extensions = SmallVec::new();
        while !next.is_null() {
            extensions.push(crate::conv::FromLowLevel::from_low_level(context, next));
            next = std::ptr::read(next).next;
        }
        let bindings_len = value.binding_count;
        let mut bindings = SmallVec::with_capacity(bindings_len as usize);
        for i in 0..bindings_len {
            bindings.push(crate::conv::FromLowLevel::from_low_level(
                context,
                value.bindings.add(i as usize).read(),
            ));
        }
        Self {
            extensions: extensions,
            flags: crate::conv::FromLowLevel::from_low_level(context, value.flags),
            bindings: bindings,
        }
    }
}
#[derive(Clone, PartialEq, Debug)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
///Extensions for [`DescriptorSetLayoutCreateInfo`]
pub enum DescriptorSetLayoutCreateInfoExtension {
    #[cfg(feature = "VULKAN_1_2")]
    ///Contains a type [`DescriptorSetLayoutBindingFlagsCreateInfo`] for extending
    /// [`DescriptorSetLayoutCreateInfo`]
    DescriptorSetLayoutBindingFlagsCreateInfo(DescriptorSetLayoutBindingFlagsCreateInfo),
    #[cfg(feature = "VK_VALVE_mutable_descriptor_type")]
    ///Contains a type [`MutableDescriptorTypeCreateInfoVALVE`] for extending
    /// [`DescriptorSetLayoutCreateInfo`]
    MutableDescriptorTypeCreateInfoVALVE(MutableDescriptorTypeCreateInfoVALVE),
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for DescriptorSetLayoutCreateInfoExtension {
    type LowLevel = *const crate::native::vulkan1_0::BaseInStructure;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        match self {
            #[cfg(feature = "VULKAN_1_2")]
            Self::DescriptorSetLayoutBindingFlagsCreateInfo(ext) => (bump.alloc(ext.into_low_level(context, bump))
                as *mut crate::native::vulkan1_2::DescriptorSetLayoutBindingFlagsCreateInfo)
                .cast(),
            #[cfg(feature = "VK_VALVE_mutable_descriptor_type")]
            Self::MutableDescriptorTypeCreateInfoVALVE(ext) => (bump.alloc(ext.into_low_level(context, bump))
                as *mut crate::native::extensions::valve_mutable_descriptor_type::MutableDescriptorTypeCreateInfoVALVE)
                .cast(),
            other => unreachable!("unexpected variant {:?}", other),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for DescriptorSetLayoutCreateInfoExtension {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        assert!(!value.is_null());
        match (* value) . s_type { # [cfg (feature = "VULKAN_1_2")] crate :: native :: vulkan1_0 :: StructureType :: DescriptorSetLayoutBindingFlagsCreateInfo => Self :: DescriptorSetLayoutBindingFlagsCreateInfo (DescriptorSetLayoutBindingFlagsCreateInfo :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: vulkan1_2 :: DescriptorSetLayoutBindingFlagsCreateInfo > ()))) , # [cfg (feature = "VK_VALVE_mutable_descriptor_type")] crate :: native :: vulkan1_0 :: StructureType :: MutableDescriptorTypeCreateInfoValve => Self :: MutableDescriptorTypeCreateInfoVALVE (MutableDescriptorTypeCreateInfoVALVE :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: valve_mutable_descriptor_type :: MutableDescriptorTypeCreateInfoVALVE > ()))) , other => panic ! ("Structure type {:?} is not a member of {}" , other , stringify ! (DescriptorSetLayoutCreateInfo)) }
    }
}
#[cfg(feature = "VULKAN_1_2")]
impl From<DescriptorSetLayoutBindingFlagsCreateInfo> for DescriptorSetLayoutCreateInfoExtension {
    fn from(ext: DescriptorSetLayoutBindingFlagsCreateInfo) -> Self {
        Self::DescriptorSetLayoutBindingFlagsCreateInfo(ext)
    }
}
#[cfg(feature = "VULKAN_1_2")]
impl TryInto<DescriptorSetLayoutBindingFlagsCreateInfo> for DescriptorSetLayoutCreateInfoExtension {
    type Error = DescriptorSetLayoutCreateInfoExtension;
    fn try_into(self) -> Result<DescriptorSetLayoutBindingFlagsCreateInfo, Self::Error> {
        match self {
            Self::DescriptorSetLayoutBindingFlagsCreateInfo(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_VALVE_mutable_descriptor_type")]
impl From<MutableDescriptorTypeCreateInfoVALVE> for DescriptorSetLayoutCreateInfoExtension {
    fn from(ext: MutableDescriptorTypeCreateInfoVALVE) -> Self {
        Self::MutableDescriptorTypeCreateInfoVALVE(ext)
    }
}
#[cfg(feature = "VK_VALVE_mutable_descriptor_type")]
impl TryInto<MutableDescriptorTypeCreateInfoVALVE> for DescriptorSetLayoutCreateInfoExtension {
    type Error = DescriptorSetLayoutCreateInfoExtension;
    fn try_into(self) -> Result<MutableDescriptorTypeCreateInfoVALVE, Self::Error> {
        match self {
            Self::MutableDescriptorTypeCreateInfoVALVE(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
impl DescriptorPoolSize {
    ///Get a reference to the `type_` field.
    pub fn type_(&self) -> DescriptorType {
        self.type_
    }
    ///Get a reference to the `descriptor_count` field.
    pub fn descriptor_count(&self) -> u32 {
        self.descriptor_count
    }
    ///Get a mutable reference to the `type_` field.
    pub fn type__mut(&mut self) -> &mut DescriptorType {
        &mut self.type_
    }
    ///Get a mutable reference to the `descriptor_count` field.
    pub fn descriptor_count_mut(&mut self) -> &mut u32 {
        &mut self.descriptor_count
    }
    ///Sets the `type_` field.
    pub fn set_type_(&mut self, type_: DescriptorType) -> &mut Self {
        self.type_ = type_;
        self
    }
    ///Sets the `descriptor_count` field.
    pub fn set_descriptor_count(&mut self, descriptor_count: u32) -> &mut Self {
        self.descriptor_count = descriptor_count;
        self
    }
    ///Sets the `type_` field in a builder way.
    pub fn with_type_(mut self, type_: DescriptorType) -> Self {
        self.type_ = type_;
        self
    }
    ///Sets the `descriptor_count` field in a builder way.
    pub fn with_descriptor_count(mut self, descriptor_count: u32) -> Self {
        self.descriptor_count = descriptor_count;
        self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for DescriptorPoolSize {
    type LowLevel = crate::native::vulkan1_0::DescriptorPoolSize;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        crate::native::vulkan1_0::DescriptorPoolSize {
            type_: self.type_.into_low_level(context, bump),
            descriptor_count: self.descriptor_count.into_low_level(context, bump),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for DescriptorPoolSize {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        Self {
            type_: crate::conv::FromLowLevel::from_low_level(context, value.type_),
            descriptor_count: crate::conv::FromLowLevel::from_low_level(context, value.descriptor_count),
        }
    }
}
#[doc(alias = "VkDescriptorPoolCreateInfo")]
#[derive(Clone, PartialEq, Debug, Default)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct DescriptorPoolCreateInfo {
    #[doc(alias = "pNext")]
    pub extensions: SmallVec<[DescriptorPoolCreateInfoExtension; 1]>,
    pub flags: DescriptorPoolCreateFlags,
    #[doc(alias = "maxSets")]
    pub max_sets: u32,
    #[doc(alias = "pPoolSizes")]
    pub pool_sizes: SmallVec<[DescriptorPoolSize; 8]>,
}
impl DescriptorPoolCreateInfo {
    ///Adds an extension to the struct
    pub fn with_extension(mut self, ext: impl Into<DescriptorPoolCreateInfoExtension>) -> Self {
        self.extensions.push(ext.into());
        self
    }
    ///Get a reference to the `extensions` field.
    pub fn extensions(&self) -> &SmallVec<[DescriptorPoolCreateInfoExtension; 1]> {
        &self.extensions
    }
    ///Get a reference to the `flags` field.
    pub fn flags(&self) -> DescriptorPoolCreateFlags {
        self.flags
    }
    ///Get a reference to the `max_sets` field.
    pub fn max_sets(&self) -> u32 {
        self.max_sets
    }
    ///Get a reference to the `pool_sizes` field.
    pub fn pool_sizes(&self) -> &SmallVec<[DescriptorPoolSize; 8]> {
        &self.pool_sizes
    }
    ///Get a mutable reference to the `extensions` field.
    pub fn extensions_mut(&mut self) -> &mut SmallVec<[DescriptorPoolCreateInfoExtension; 1]> {
        &mut self.extensions
    }
    ///Get a mutable reference to the `flags` field.
    pub fn flags_mut(&mut self) -> &mut DescriptorPoolCreateFlags {
        &mut self.flags
    }
    ///Get a mutable reference to the `max_sets` field.
    pub fn max_sets_mut(&mut self) -> &mut u32 {
        &mut self.max_sets
    }
    ///Get a mutable reference to the `pool_sizes` field.
    pub fn pool_sizes_mut(&mut self) -> &mut SmallVec<[DescriptorPoolSize; 8]> {
        &mut self.pool_sizes
    }
    ///Sets the `extensions` field.
    pub fn set_extensions(&mut self, extensions: SmallVec<[DescriptorPoolCreateInfoExtension; 1]>) -> &mut Self {
        self.extensions = extensions;
        self
    }
    ///Sets the `flags` field.
    pub fn set_flags(&mut self, flags: DescriptorPoolCreateFlags) -> &mut Self {
        self.flags = flags;
        self
    }
    ///Sets the `max_sets` field.
    pub fn set_max_sets(&mut self, max_sets: u32) -> &mut Self {
        self.max_sets = max_sets;
        self
    }
    ///Sets the `pool_sizes` field.
    pub fn set_pool_sizes(&mut self, pool_sizes: SmallVec<[DescriptorPoolSize; 8]>) -> &mut Self {
        self.pool_sizes = pool_sizes;
        self
    }
    ///Sets the `extensions` field in a builder way.
    pub fn with_extensions(mut self, extensions: SmallVec<[DescriptorPoolCreateInfoExtension; 1]>) -> Self {
        self.extensions = extensions;
        self
    }
    ///Sets the `flags` field in a builder way.
    pub fn with_flags(mut self, flags: DescriptorPoolCreateFlags) -> Self {
        self.flags = flags;
        self
    }
    ///Sets the `max_sets` field in a builder way.
    pub fn with_max_sets(mut self, max_sets: u32) -> Self {
        self.max_sets = max_sets;
        self
    }
    ///Sets the `pool_sizes` field in a builder way.
    pub fn with_pool_sizes(mut self, pool_sizes: SmallVec<[DescriptorPoolSize; 8]>) -> Self {
        self.pool_sizes = pool_sizes;
        self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for DescriptorPoolCreateInfo {
    type LowLevel = crate::native::vulkan1_0::DescriptorPoolCreateInfo;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        let mut next = std::ptr::null();
        let mut extensions = self.extensions.iter();
        while let Some(ext) = extensions.next() {
            let ext = ext.into_low_level(context, bump);
            (*ext).next = next;
            next = ext;
        }
        let len_pool_sizes = self.pool_sizes.len() as u32;
        let pool_sizes = bump
            .alloc_slice_fill_iter(self.pool_sizes.iter().map(|x| x.into_low_level(context, bump)))
            .as_ptr()
            .cast();
        crate::native::vulkan1_0::DescriptorPoolCreateInfo {
            s_type: StructureType::DescriptorPoolCreateInfo,
            p_next: next,
            flags: self.flags.into_low_level(context, bump),
            max_sets: self.max_sets.into_low_level(context, bump),
            pool_size_count: len_pool_sizes,
            pool_sizes: pool_sizes,
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for DescriptorPoolCreateInfo {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        let mut next = value.p_next;
        let mut extensions = SmallVec::new();
        while !next.is_null() {
            extensions.push(crate::conv::FromLowLevel::from_low_level(context, next));
            next = std::ptr::read(next).next;
        }
        let pool_sizes_len = value.pool_size_count;
        let mut pool_sizes = SmallVec::with_capacity(pool_sizes_len as usize);
        for i in 0..pool_sizes_len {
            pool_sizes.push(crate::conv::FromLowLevel::from_low_level(
                context,
                value.pool_sizes.add(i as usize).read(),
            ));
        }
        Self {
            extensions: extensions,
            flags: crate::conv::FromLowLevel::from_low_level(context, value.flags),
            max_sets: crate::conv::FromLowLevel::from_low_level(context, value.max_sets),
            pool_sizes: pool_sizes,
        }
    }
}
#[derive(Clone, PartialEq, Debug)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
///Extensions for [`DescriptorPoolCreateInfo`]
pub enum DescriptorPoolCreateInfoExtension {
    #[cfg(feature = "VULKAN_1_3")]
    ///Contains a type [`DescriptorPoolInlineUniformBlockCreateInfo`] for extending
    /// [`DescriptorPoolCreateInfo`]
    DescriptorPoolInlineUniformBlockCreateInfo(DescriptorPoolInlineUniformBlockCreateInfo),
    #[cfg(feature = "VK_VALVE_mutable_descriptor_type")]
    ///Contains a type [`MutableDescriptorTypeCreateInfoVALVE`] for extending
    /// [`DescriptorPoolCreateInfo`]
    MutableDescriptorTypeCreateInfoVALVE(MutableDescriptorTypeCreateInfoVALVE),
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for DescriptorPoolCreateInfoExtension {
    type LowLevel = *const crate::native::vulkan1_0::BaseInStructure;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        match self {
            #[cfg(feature = "VULKAN_1_3")]
            Self::DescriptorPoolInlineUniformBlockCreateInfo(ext) => (bump.alloc(ext.into_low_level(context, bump))
                as *mut crate::native::vulkan1_3::DescriptorPoolInlineUniformBlockCreateInfo)
                .cast(),
            #[cfg(feature = "VK_VALVE_mutable_descriptor_type")]
            Self::MutableDescriptorTypeCreateInfoVALVE(ext) => (bump.alloc(ext.into_low_level(context, bump))
                as *mut crate::native::extensions::valve_mutable_descriptor_type::MutableDescriptorTypeCreateInfoVALVE)
                .cast(),
            other => unreachable!("unexpected variant {:?}", other),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for DescriptorPoolCreateInfoExtension {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        assert!(!value.is_null());
        match (* value) . s_type { # [cfg (feature = "VULKAN_1_3")] crate :: native :: vulkan1_0 :: StructureType :: DescriptorPoolInlineUniformBlockCreateInfo => Self :: DescriptorPoolInlineUniformBlockCreateInfo (DescriptorPoolInlineUniformBlockCreateInfo :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: vulkan1_3 :: DescriptorPoolInlineUniformBlockCreateInfo > ()))) , # [cfg (feature = "VK_VALVE_mutable_descriptor_type")] crate :: native :: vulkan1_0 :: StructureType :: MutableDescriptorTypeCreateInfoValve => Self :: MutableDescriptorTypeCreateInfoVALVE (MutableDescriptorTypeCreateInfoVALVE :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: valve_mutable_descriptor_type :: MutableDescriptorTypeCreateInfoVALVE > ()))) , other => panic ! ("Structure type {:?} is not a member of {}" , other , stringify ! (DescriptorPoolCreateInfo)) }
    }
}
#[cfg(feature = "VULKAN_1_3")]
impl From<DescriptorPoolInlineUniformBlockCreateInfo> for DescriptorPoolCreateInfoExtension {
    fn from(ext: DescriptorPoolInlineUniformBlockCreateInfo) -> Self {
        Self::DescriptorPoolInlineUniformBlockCreateInfo(ext)
    }
}
#[cfg(feature = "VULKAN_1_3")]
impl TryInto<DescriptorPoolInlineUniformBlockCreateInfo> for DescriptorPoolCreateInfoExtension {
    type Error = DescriptorPoolCreateInfoExtension;
    fn try_into(self) -> Result<DescriptorPoolInlineUniformBlockCreateInfo, Self::Error> {
        match self {
            Self::DescriptorPoolInlineUniformBlockCreateInfo(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_VALVE_mutable_descriptor_type")]
impl From<MutableDescriptorTypeCreateInfoVALVE> for DescriptorPoolCreateInfoExtension {
    fn from(ext: MutableDescriptorTypeCreateInfoVALVE) -> Self {
        Self::MutableDescriptorTypeCreateInfoVALVE(ext)
    }
}
#[cfg(feature = "VK_VALVE_mutable_descriptor_type")]
impl TryInto<MutableDescriptorTypeCreateInfoVALVE> for DescriptorPoolCreateInfoExtension {
    type Error = DescriptorPoolCreateInfoExtension;
    fn try_into(self) -> Result<MutableDescriptorTypeCreateInfoVALVE, Self::Error> {
        match self {
            Self::MutableDescriptorTypeCreateInfoVALVE(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[doc(alias = "VkDescriptorSetAllocateInfo")]
#[derive(Clone, PartialEq, Debug)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct DescriptorSetAllocateInfo {
    #[doc(alias = "pNext")]
    pub extensions: SmallVec<[DescriptorSetAllocateInfoExtension; 1]>,
    #[doc(alias = "descriptorPool")]
    pub descriptor_pool: DescriptorPool,
    #[doc(alias = "pSetLayouts")]
    pub set_layouts: SmallVec<[DescriptorSetLayout; 8]>,
}
impl DescriptorSetAllocateInfo {
    ///Adds an extension to the struct
    pub fn with_extension(mut self, ext: impl Into<DescriptorSetAllocateInfoExtension>) -> Self {
        self.extensions.push(ext.into());
        self
    }
    ///Get a reference to the `extensions` field.
    pub fn extensions(&self) -> &SmallVec<[DescriptorSetAllocateInfoExtension; 1]> {
        &self.extensions
    }
    ///Get a reference to the `descriptor_pool` field.
    pub fn descriptor_pool(&self) -> &DescriptorPool {
        &self.descriptor_pool
    }
    ///Get a reference to the `set_layouts` field.
    pub fn set_layouts(&self) -> &SmallVec<[DescriptorSetLayout; 8]> {
        &self.set_layouts
    }
    ///Get a mutable reference to the `extensions` field.
    pub fn extensions_mut(&mut self) -> &mut SmallVec<[DescriptorSetAllocateInfoExtension; 1]> {
        &mut self.extensions
    }
    ///Get a mutable reference to the `descriptor_pool` field.
    pub fn descriptor_pool_mut(&mut self) -> &mut DescriptorPool {
        &mut self.descriptor_pool
    }
    ///Get a mutable reference to the `set_layouts` field.
    pub fn set_layouts_mut(&mut self) -> &mut SmallVec<[DescriptorSetLayout; 8]> {
        &mut self.set_layouts
    }
    ///Sets the `extensions` field.
    pub fn set_extensions(&mut self, extensions: SmallVec<[DescriptorSetAllocateInfoExtension; 1]>) -> &mut Self {
        self.extensions = extensions;
        self
    }
    ///Sets the `descriptor_pool` field.
    pub fn set_descriptor_pool(&mut self, descriptor_pool: DescriptorPool) -> &mut Self {
        self.descriptor_pool = descriptor_pool;
        self
    }
    ///Sets the `set_layouts` field.
    pub fn set_set_layouts(&mut self, set_layouts: SmallVec<[DescriptorSetLayout; 8]>) -> &mut Self {
        self.set_layouts = set_layouts;
        self
    }
    ///Sets the `extensions` field in a builder way.
    pub fn with_extensions(mut self, extensions: SmallVec<[DescriptorSetAllocateInfoExtension; 1]>) -> Self {
        self.extensions = extensions;
        self
    }
    ///Sets the `descriptor_pool` field in a builder way.
    pub fn with_descriptor_pool(mut self, descriptor_pool: DescriptorPool) -> Self {
        self.descriptor_pool = descriptor_pool;
        self
    }
    ///Sets the `set_layouts` field in a builder way.
    pub fn with_set_layouts(mut self, set_layouts: SmallVec<[DescriptorSetLayout; 8]>) -> Self {
        self.set_layouts = set_layouts;
        self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for DescriptorSetAllocateInfo {
    type LowLevel = crate::native::vulkan1_0::DescriptorSetAllocateInfo;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        let mut next = std::ptr::null();
        let mut extensions = self.extensions.iter();
        while let Some(ext) = extensions.next() {
            let ext = ext.into_low_level(context, bump);
            (*ext).next = next;
            next = ext;
        }
        let len_set_layouts = self.set_layouts.len() as u32;
        let set_layouts = bump
            .alloc_slice_fill_iter(self.set_layouts.iter().map(|x| x.into_low_level(context, bump)))
            .as_ptr()
            .cast();
        crate::native::vulkan1_0::DescriptorSetAllocateInfo {
            s_type: StructureType::DescriptorSetAllocateInfo,
            p_next: next,
            descriptor_pool: self.descriptor_pool.into_low_level(context, bump),
            descriptor_set_count: len_set_layouts,
            set_layouts: set_layouts,
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for DescriptorSetAllocateInfo {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        let mut next = value.p_next;
        let mut extensions = SmallVec::new();
        while !next.is_null() {
            extensions.push(crate::conv::FromLowLevel::from_low_level(context, next));
            next = std::ptr::read(next).next;
        }
        let set_layouts_len = value.descriptor_set_count;
        let mut set_layouts = SmallVec::with_capacity(set_layouts_len as usize);
        for i in 0..set_layouts_len {
            set_layouts.push(crate::conv::FromLowLevel::from_low_level(
                context,
                value.set_layouts.add(i as usize).read(),
            ));
        }
        Self {
            extensions: extensions,
            descriptor_pool: crate::conv::FromLowLevel::from_low_level(context, value.descriptor_pool),
            set_layouts: set_layouts,
        }
    }
}
#[derive(Clone, PartialEq, Debug)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
///Extensions for [`DescriptorSetAllocateInfo`]
pub enum DescriptorSetAllocateInfoExtension {
    #[cfg(feature = "VULKAN_1_2")]
    ///Contains a type [`DescriptorSetVariableDescriptorCountAllocateInfo`] for extending
    /// [`DescriptorSetAllocateInfo`]
    DescriptorSetVariableDescriptorCountAllocateInfo(DescriptorSetVariableDescriptorCountAllocateInfo),
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for DescriptorSetAllocateInfoExtension {
    type LowLevel = *const crate::native::vulkan1_0::BaseInStructure;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        match self {
            #[cfg(feature = "VULKAN_1_2")]
            Self::DescriptorSetVariableDescriptorCountAllocateInfo(ext) => (bump
                .alloc(ext.into_low_level(context, bump))
                as *mut crate::native::vulkan1_2::DescriptorSetVariableDescriptorCountAllocateInfo)
                .cast(),
            other => unreachable!("unexpected variant {:?}", other),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for DescriptorSetAllocateInfoExtension {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        assert!(!value.is_null());
        match (*value).s_type {
            #[cfg(feature = "VULKAN_1_2")]
            crate::native::vulkan1_0::StructureType::DescriptorSetVariableDescriptorCountAllocateInfo => {
                Self::DescriptorSetVariableDescriptorCountAllocateInfo(
                    DescriptorSetVariableDescriptorCountAllocateInfo::from_low_level(
                        context,
                        std::ptr::read(
                            value.cast::<crate::native::vulkan1_2::DescriptorSetVariableDescriptorCountAllocateInfo>(),
                        ),
                    ),
                )
            },
            other => panic!(
                "Structure type {:?} is not a member of {}",
                other,
                stringify!(DescriptorSetAllocateInfo)
            ),
        }
    }
}
#[cfg(feature = "VULKAN_1_2")]
impl From<DescriptorSetVariableDescriptorCountAllocateInfo> for DescriptorSetAllocateInfoExtension {
    fn from(ext: DescriptorSetVariableDescriptorCountAllocateInfo) -> Self {
        Self::DescriptorSetVariableDescriptorCountAllocateInfo(ext)
    }
}
#[cfg(feature = "VULKAN_1_2")]
impl TryInto<DescriptorSetVariableDescriptorCountAllocateInfo> for DescriptorSetAllocateInfoExtension {
    type Error = DescriptorSetAllocateInfoExtension;
    fn try_into(self) -> Result<DescriptorSetVariableDescriptorCountAllocateInfo, Self::Error> {
        match self {
            Self::DescriptorSetVariableDescriptorCountAllocateInfo(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
impl SpecializationMapEntry {
    ///Get a reference to the `constant_id` field.
    pub fn constant_id(&self) -> u32 {
        self.constant_id
    }
    ///Get a reference to the `offset` field.
    pub fn offset(&self) -> u32 {
        self.offset
    }
    ///Get a reference to the `size` field.
    pub fn size(&self) -> usize {
        self.size
    }
    ///Get a mutable reference to the `constant_id` field.
    pub fn constant_id_mut(&mut self) -> &mut u32 {
        &mut self.constant_id
    }
    ///Get a mutable reference to the `offset` field.
    pub fn offset_mut(&mut self) -> &mut u32 {
        &mut self.offset
    }
    ///Get a mutable reference to the `size` field.
    pub fn size_mut(&mut self) -> &mut usize {
        &mut self.size
    }
    ///Sets the `constant_id` field.
    pub fn set_constant_id(&mut self, constant_id: u32) -> &mut Self {
        self.constant_id = constant_id;
        self
    }
    ///Sets the `offset` field.
    pub fn set_offset(&mut self, offset: u32) -> &mut Self {
        self.offset = offset;
        self
    }
    ///Sets the `size` field.
    pub fn set_size(&mut self, size: usize) -> &mut Self {
        self.size = size;
        self
    }
    ///Sets the `constant_id` field in a builder way.
    pub fn with_constant_id(mut self, constant_id: u32) -> Self {
        self.constant_id = constant_id;
        self
    }
    ///Sets the `offset` field in a builder way.
    pub fn with_offset(mut self, offset: u32) -> Self {
        self.offset = offset;
        self
    }
    ///Sets the `size` field in a builder way.
    pub fn with_size(mut self, size: usize) -> Self {
        self.size = size;
        self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for SpecializationMapEntry {
    type LowLevel = crate::native::vulkan1_0::SpecializationMapEntry;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        crate::native::vulkan1_0::SpecializationMapEntry {
            constant_id: self.constant_id.into_low_level(context, bump),
            offset: self.offset.into_low_level(context, bump),
            size: self.size.into_low_level(context, bump),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for SpecializationMapEntry {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        Self {
            constant_id: crate::conv::FromLowLevel::from_low_level(context, value.constant_id),
            offset: crate::conv::FromLowLevel::from_low_level(context, value.offset),
            size: crate::conv::FromLowLevel::from_low_level(context, value.size),
        }
    }
}
#[doc(alias = "VkSpecializationInfo")]
#[derive(Clone, PartialEq, Debug, Default)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct SpecializationInfo {
    #[doc(alias = "pMapEntries")]
    pub map_entries: SmallVec<[SpecializationMapEntry; 8]>,
    #[doc(alias = "pData")]
    pub data: Vec<u8>,
}
impl SpecializationInfo {
    ///Get a reference to the `map_entries` field.
    pub fn map_entries(&self) -> &SmallVec<[SpecializationMapEntry; 8]> {
        &self.map_entries
    }
    ///Get a reference to the `data` field.
    pub fn data(&self) -> &Vec<u8> {
        &self.data
    }
    ///Get a mutable reference to the `map_entries` field.
    pub fn map_entries_mut(&mut self) -> &mut SmallVec<[SpecializationMapEntry; 8]> {
        &mut self.map_entries
    }
    ///Get a mutable reference to the `data` field.
    pub fn data_mut(&mut self) -> &mut Vec<u8> {
        &mut self.data
    }
    ///Sets the `map_entries` field.
    pub fn set_map_entries(&mut self, map_entries: SmallVec<[SpecializationMapEntry; 8]>) -> &mut Self {
        self.map_entries = map_entries;
        self
    }
    ///Sets the `data` field.
    pub fn set_data(&mut self, data: Vec<u8>) -> &mut Self {
        self.data = data;
        self
    }
    ///Sets the `map_entries` field in a builder way.
    pub fn with_map_entries(mut self, map_entries: SmallVec<[SpecializationMapEntry; 8]>) -> Self {
        self.map_entries = map_entries;
        self
    }
    ///Sets the `data` field in a builder way.
    pub fn with_data(mut self, data: Vec<u8>) -> Self {
        self.data = data;
        self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for SpecializationInfo {
    type LowLevel = crate::native::vulkan1_0::SpecializationInfo;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        let len_map_entries = self.map_entries.len() as u32;
        let map_entries = bump
            .alloc_slice_fill_iter(self.map_entries.iter().map(|x| x.into_low_level(context, bump)))
            .as_ptr()
            .cast();
        let len_data = self.data.len() as usize;
        crate::native::vulkan1_0::SpecializationInfo {
            map_entry_count: len_map_entries,
            map_entries: map_entries,
            data_size: len_data,
            data: self.data.as_ptr().cast(),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for SpecializationInfo {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        let map_entries_len = value.map_entry_count;
        let mut map_entries = SmallVec::with_capacity(map_entries_len as usize);
        for i in 0..map_entries_len {
            map_entries.push(crate::conv::FromLowLevel::from_low_level(
                context,
                value.map_entries.add(i as usize).read(),
            ));
        }
        let data_len = value.data_size;
        let mut data = Vec::with_capacity(data_len as usize);
        let data_ptr = value.data as *const u8;
        for i in 0..data_len {
            data.push(crate::conv::FromLowLevel::from_low_level(
                context,
                data_ptr.add(i as usize).read(),
            ));
        }
        Self {
            map_entries: map_entries,
            data: data,
        }
    }
}
#[doc(alias = "VkPipelineShaderStageCreateInfo")]
#[derive(Clone, PartialEq, Debug)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct PipelineShaderStageCreateInfo {
    #[doc(alias = "pNext")]
    pub extensions: SmallVec<[PipelineShaderStageCreateInfoExtension; 1]>,
    pub flags: PipelineShaderStageCreateFlags,
    pub stage: ShaderStageFlagBits,
    pub module: ShaderModule,
    #[doc(alias = "pName")]
    pub name: String,
    #[doc(alias = "pSpecializationInfo")]
    pub specialization_info: Option<SpecializationInfo>,
}
impl PipelineShaderStageCreateInfo {
    ///Adds an extension to the struct
    pub fn with_extension(mut self, ext: impl Into<PipelineShaderStageCreateInfoExtension>) -> Self {
        self.extensions.push(ext.into());
        self
    }
    ///Get a reference to the `extensions` field.
    pub fn extensions(&self) -> &SmallVec<[PipelineShaderStageCreateInfoExtension; 1]> {
        &self.extensions
    }
    ///Get a reference to the `flags` field.
    pub fn flags(&self) -> PipelineShaderStageCreateFlags {
        self.flags
    }
    ///Get a reference to the `stage` field.
    pub fn stage(&self) -> ShaderStageFlagBits {
        self.stage
    }
    ///Get a reference to the `module` field.
    pub fn module(&self) -> &ShaderModule {
        &self.module
    }
    ///Get a reference to the `name` field.
    pub fn name(&self) -> &String {
        &self.name
    }
    ///Get a reference to the `specialization_info` field.
    pub fn specialization_info(&self) -> &Option<SpecializationInfo> {
        &self.specialization_info
    }
    ///Get a mutable reference to the `extensions` field.
    pub fn extensions_mut(&mut self) -> &mut SmallVec<[PipelineShaderStageCreateInfoExtension; 1]> {
        &mut self.extensions
    }
    ///Get a mutable reference to the `flags` field.
    pub fn flags_mut(&mut self) -> &mut PipelineShaderStageCreateFlags {
        &mut self.flags
    }
    ///Get a mutable reference to the `stage` field.
    pub fn stage_mut(&mut self) -> &mut ShaderStageFlagBits {
        &mut self.stage
    }
    ///Get a mutable reference to the `module` field.
    pub fn module_mut(&mut self) -> &mut ShaderModule {
        &mut self.module
    }
    ///Get a mutable reference to the `name` field.
    pub fn name_mut(&mut self) -> &mut String {
        &mut self.name
    }
    ///Get a mutable reference to the `specialization_info` field.
    pub fn specialization_info_mut(&mut self) -> &mut Option<SpecializationInfo> {
        &mut self.specialization_info
    }
    ///Sets the `extensions` field.
    pub fn set_extensions(&mut self, extensions: SmallVec<[PipelineShaderStageCreateInfoExtension; 1]>) -> &mut Self {
        self.extensions = extensions;
        self
    }
    ///Sets the `flags` field.
    pub fn set_flags(&mut self, flags: PipelineShaderStageCreateFlags) -> &mut Self {
        self.flags = flags;
        self
    }
    ///Sets the `stage` field.
    pub fn set_stage(&mut self, stage: ShaderStageFlagBits) -> &mut Self {
        self.stage = stage;
        self
    }
    ///Sets the `module` field.
    pub fn set_module(&mut self, module: ShaderModule) -> &mut Self {
        self.module = module;
        self
    }
    ///Sets the `name` field.
    pub fn set_name(&mut self, name: String) -> &mut Self {
        self.name = name;
        self
    }
    ///Sets the `specialization_info` field.
    pub fn set_specialization_info(&mut self, specialization_info: Option<SpecializationInfo>) -> &mut Self {
        self.specialization_info = specialization_info;
        self
    }
    ///Sets the `extensions` field in a builder way.
    pub fn with_extensions(mut self, extensions: SmallVec<[PipelineShaderStageCreateInfoExtension; 1]>) -> Self {
        self.extensions = extensions;
        self
    }
    ///Sets the `flags` field in a builder way.
    pub fn with_flags(mut self, flags: PipelineShaderStageCreateFlags) -> Self {
        self.flags = flags;
        self
    }
    ///Sets the `stage` field in a builder way.
    pub fn with_stage(mut self, stage: ShaderStageFlagBits) -> Self {
        self.stage = stage;
        self
    }
    ///Sets the `module` field in a builder way.
    pub fn with_module(mut self, module: ShaderModule) -> Self {
        self.module = module;
        self
    }
    ///Sets the `name` field in a builder way.
    pub fn with_name(mut self, name: String) -> Self {
        self.name = name;
        self
    }
    ///Sets the `specialization_info` field in a builder way.
    pub fn with_specialization_info(mut self, specialization_info: Option<SpecializationInfo>) -> Self {
        self.specialization_info = specialization_info;
        self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for PipelineShaderStageCreateInfo {
    type LowLevel = crate::native::vulkan1_0::PipelineShaderStageCreateInfo;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        let mut next = std::ptr::null();
        let mut extensions = self.extensions.iter();
        while let Some(ext) = extensions.next() {
            let ext = ext.into_low_level(context, bump);
            (*ext).next = next;
            next = ext;
        }
        crate::native::vulkan1_0::PipelineShaderStageCreateInfo {
            s_type: StructureType::PipelineShaderStageCreateInfo,
            p_next: next,
            flags: self.flags.into_low_level(context, bump),
            stage: self.stage.into_low_level(context, bump),
            module: self.module.into_low_level(context, bump),
            name: self.name.into_low_level(context, bump),
            specialization_info: self
                .specialization_info
                .as_ref()
                .map(|v| bump.alloc(v.into_low_level(context, bump)) as *const _)
                .unwrap_or_else(std::ptr::null),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for PipelineShaderStageCreateInfo {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        let mut next = value.p_next;
        let mut extensions = SmallVec::new();
        while !next.is_null() {
            extensions.push(crate::conv::FromLowLevel::from_low_level(context, next));
            next = std::ptr::read(next).next;
        }
        Self {
            extensions: extensions,
            flags: crate::conv::FromLowLevel::from_low_level(context, value.flags),
            stage: crate::conv::FromLowLevel::from_low_level(context, value.stage),
            module: crate::conv::FromLowLevel::from_low_level(context, value.module),
            name: crate::conv::FromLowLevel::from_low_level(context, value.name),
            specialization_info: crate::conv::FromLowLevel::from_low_level(context, *value.specialization_info),
        }
    }
}
#[derive(Clone, PartialEq, Debug, Copy)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
///Extensions for [`PipelineShaderStageCreateInfo`]
pub enum PipelineShaderStageCreateInfoExtension {
    #[cfg(feature = "VULKAN_1_3")]
    ///Contains a type [`PipelineShaderStageRequiredSubgroupSizeCreateInfo`] for extending
    /// [`PipelineShaderStageCreateInfo`]
    PipelineShaderStageRequiredSubgroupSizeCreateInfo(PipelineShaderStageRequiredSubgroupSizeCreateInfo),
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for PipelineShaderStageCreateInfoExtension {
    type LowLevel = *const crate::native::vulkan1_0::BaseInStructure;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        match self {
            #[cfg(feature = "VULKAN_1_3")]
            Self::PipelineShaderStageRequiredSubgroupSizeCreateInfo(ext) => (bump
                .alloc(ext.into_low_level(context, bump))
                as *mut crate::native::vulkan1_3::PipelineShaderStageRequiredSubgroupSizeCreateInfo)
                .cast(),
            other => unreachable!("unexpected variant {:?}", other),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for PipelineShaderStageCreateInfoExtension {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        assert!(!value.is_null());
        match (*value).s_type {
            #[cfg(feature = "VULKAN_1_3")]
            crate::native::vulkan1_0::StructureType::PipelineShaderStageRequiredSubgroupSizeCreateInfo => {
                Self::PipelineShaderStageRequiredSubgroupSizeCreateInfo(
                    PipelineShaderStageRequiredSubgroupSizeCreateInfo::from_low_level(
                        context,
                        std::ptr::read(
                            value.cast::<crate::native::vulkan1_3::PipelineShaderStageRequiredSubgroupSizeCreateInfo>(),
                        ),
                    ),
                )
            },
            other => panic!(
                "Structure type {:?} is not a member of {}",
                other,
                stringify!(PipelineShaderStageCreateInfo)
            ),
        }
    }
}
#[cfg(feature = "VULKAN_1_3")]
impl From<PipelineShaderStageRequiredSubgroupSizeCreateInfo> for PipelineShaderStageCreateInfoExtension {
    fn from(ext: PipelineShaderStageRequiredSubgroupSizeCreateInfo) -> Self {
        Self::PipelineShaderStageRequiredSubgroupSizeCreateInfo(ext)
    }
}
#[cfg(feature = "VULKAN_1_3")]
impl TryInto<PipelineShaderStageRequiredSubgroupSizeCreateInfo> for PipelineShaderStageCreateInfoExtension {
    type Error = PipelineShaderStageCreateInfoExtension;
    fn try_into(self) -> Result<PipelineShaderStageRequiredSubgroupSizeCreateInfo, Self::Error> {
        match self {
            Self::PipelineShaderStageRequiredSubgroupSizeCreateInfo(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[doc(alias = "VkComputePipelineCreateInfo")]
#[derive(Clone, PartialEq, Debug)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct ComputePipelineCreateInfo {
    #[doc(alias = "pNext")]
    pub extensions: SmallVec<[ComputePipelineCreateInfoExtension; 1]>,
    pub flags: PipelineCreateFlags,
    pub stage: PipelineShaderStageCreateInfo,
    pub layout: PipelineLayout,
    #[doc(alias = "basePipelineHandle")]
    pub base_pipeline_handle: Option<Pipeline>,
    #[doc(alias = "basePipelineIndex")]
    pub base_pipeline_index: i32,
}
impl ComputePipelineCreateInfo {
    ///Adds an extension to the struct
    pub fn with_extension(mut self, ext: impl Into<ComputePipelineCreateInfoExtension>) -> Self {
        self.extensions.push(ext.into());
        self
    }
    ///Get a reference to the `extensions` field.
    pub fn extensions(&self) -> &SmallVec<[ComputePipelineCreateInfoExtension; 1]> {
        &self.extensions
    }
    ///Get a reference to the `flags` field.
    pub fn flags(&self) -> PipelineCreateFlags {
        self.flags
    }
    ///Get a reference to the `stage` field.
    pub fn stage(&self) -> &PipelineShaderStageCreateInfo {
        &self.stage
    }
    ///Get a reference to the `layout` field.
    pub fn layout(&self) -> &PipelineLayout {
        &self.layout
    }
    ///Get a reference to the `base_pipeline_handle` field.
    pub fn base_pipeline_handle(&self) -> &Option<Pipeline> {
        &self.base_pipeline_handle
    }
    ///Get a reference to the `base_pipeline_index` field.
    pub fn base_pipeline_index(&self) -> i32 {
        self.base_pipeline_index
    }
    ///Get a mutable reference to the `extensions` field.
    pub fn extensions_mut(&mut self) -> &mut SmallVec<[ComputePipelineCreateInfoExtension; 1]> {
        &mut self.extensions
    }
    ///Get a mutable reference to the `flags` field.
    pub fn flags_mut(&mut self) -> &mut PipelineCreateFlags {
        &mut self.flags
    }
    ///Get a mutable reference to the `stage` field.
    pub fn stage_mut(&mut self) -> &mut PipelineShaderStageCreateInfo {
        &mut self.stage
    }
    ///Get a mutable reference to the `layout` field.
    pub fn layout_mut(&mut self) -> &mut PipelineLayout {
        &mut self.layout
    }
    ///Get a mutable reference to the `base_pipeline_handle` field.
    pub fn base_pipeline_handle_mut(&mut self) -> &mut Option<Pipeline> {
        &mut self.base_pipeline_handle
    }
    ///Get a mutable reference to the `base_pipeline_index` field.
    pub fn base_pipeline_index_mut(&mut self) -> &mut i32 {
        &mut self.base_pipeline_index
    }
    ///Sets the `extensions` field.
    pub fn set_extensions(&mut self, extensions: SmallVec<[ComputePipelineCreateInfoExtension; 1]>) -> &mut Self {
        self.extensions = extensions;
        self
    }
    ///Sets the `flags` field.
    pub fn set_flags(&mut self, flags: PipelineCreateFlags) -> &mut Self {
        self.flags = flags;
        self
    }
    ///Sets the `stage` field.
    pub fn set_stage(&mut self, stage: PipelineShaderStageCreateInfo) -> &mut Self {
        self.stage = stage;
        self
    }
    ///Sets the `layout` field.
    pub fn set_layout(&mut self, layout: PipelineLayout) -> &mut Self {
        self.layout = layout;
        self
    }
    ///Sets the `base_pipeline_handle` field.
    pub fn set_base_pipeline_handle(&mut self, base_pipeline_handle: Option<Pipeline>) -> &mut Self {
        self.base_pipeline_handle = base_pipeline_handle;
        self
    }
    ///Sets the `base_pipeline_index` field.
    pub fn set_base_pipeline_index(&mut self, base_pipeline_index: i32) -> &mut Self {
        self.base_pipeline_index = base_pipeline_index;
        self
    }
    ///Sets the `extensions` field in a builder way.
    pub fn with_extensions(mut self, extensions: SmallVec<[ComputePipelineCreateInfoExtension; 1]>) -> Self {
        self.extensions = extensions;
        self
    }
    ///Sets the `flags` field in a builder way.
    pub fn with_flags(mut self, flags: PipelineCreateFlags) -> Self {
        self.flags = flags;
        self
    }
    ///Sets the `stage` field in a builder way.
    pub fn with_stage(mut self, stage: PipelineShaderStageCreateInfo) -> Self {
        self.stage = stage;
        self
    }
    ///Sets the `layout` field in a builder way.
    pub fn with_layout(mut self, layout: PipelineLayout) -> Self {
        self.layout = layout;
        self
    }
    ///Sets the `base_pipeline_handle` field in a builder way.
    pub fn with_base_pipeline_handle(mut self, base_pipeline_handle: Option<Pipeline>) -> Self {
        self.base_pipeline_handle = base_pipeline_handle;
        self
    }
    ///Sets the `base_pipeline_index` field in a builder way.
    pub fn with_base_pipeline_index(mut self, base_pipeline_index: i32) -> Self {
        self.base_pipeline_index = base_pipeline_index;
        self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for ComputePipelineCreateInfo {
    type LowLevel = crate::native::vulkan1_0::ComputePipelineCreateInfo;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        let mut next = std::ptr::null();
        let mut extensions = self.extensions.iter();
        while let Some(ext) = extensions.next() {
            let ext = ext.into_low_level(context, bump);
            (*ext).next = next;
            next = ext;
        }
        crate::native::vulkan1_0::ComputePipelineCreateInfo {
            s_type: StructureType::ComputePipelineCreateInfo,
            p_next: next,
            flags: self.flags.into_low_level(context, bump),
            stage: self.stage.into_low_level(context, bump),
            layout: self.layout.into_low_level(context, bump),
            base_pipeline_handle: self
                .base_pipeline_handle
                .as_ref()
                .map(|v| v.into_low_level(context, bump))
                .unwrap_or_else(Default::default),
            base_pipeline_index: self.base_pipeline_index.into_low_level(context, bump),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for ComputePipelineCreateInfo {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        let mut next = value.p_next;
        let mut extensions = SmallVec::new();
        while !next.is_null() {
            extensions.push(crate::conv::FromLowLevel::from_low_level(context, next));
            next = std::ptr::read(next).next;
        }
        Self {
            extensions: extensions,
            flags: crate::conv::FromLowLevel::from_low_level(context, value.flags),
            stage: crate::conv::FromLowLevel::from_low_level(context, value.stage),
            layout: crate::conv::FromLowLevel::from_low_level(context, value.layout),
            base_pipeline_handle: if value.base_pipeline_handle == crate::native::vulkan1_0::Pipeline::null() {
                None
            } else {
                Some(crate::conv::FromLowLevel::from_low_level(
                    context,
                    value.base_pipeline_handle,
                ))
            },
            base_pipeline_index: crate::conv::FromLowLevel::from_low_level(context, value.base_pipeline_index),
        }
    }
}
#[derive(Clone, PartialEq, Debug)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
///Extensions for [`ComputePipelineCreateInfo`]
pub enum ComputePipelineCreateInfoExtension {
    #[cfg(feature = "VULKAN_1_3")]
    ///Contains a type [`PipelineCreationFeedbackCreateInfo`] for extending
    /// [`ComputePipelineCreateInfo`]
    PipelineCreationFeedbackCreateInfo(PipelineCreationFeedbackCreateInfo),
    #[cfg(feature = "VK_HUAWEI_subpass_shading")]
    ///Contains a type [`SubpassShadingPipelineCreateInfoHUAWEI`] for extending
    /// [`ComputePipelineCreateInfo`]
    SubpassShadingPipelineCreateInfoHUAWEI(SubpassShadingPipelineCreateInfoHUAWEI),
    #[cfg(feature = "VK_AMD_pipeline_compiler_control")]
    ///Contains a type [`PipelineCompilerControlCreateInfoAMD`] for extending
    /// [`ComputePipelineCreateInfo`]
    PipelineCompilerControlCreateInfoAMD(PipelineCompilerControlCreateInfoAMD),
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for ComputePipelineCreateInfoExtension {
    type LowLevel = *const crate::native::vulkan1_0::BaseInStructure;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        match self {
            #[cfg(feature = "VULKAN_1_3")]
            Self::PipelineCreationFeedbackCreateInfo(ext) => (bump.alloc(ext.into_low_level(context, bump))
                as *mut crate::native::vulkan1_3::PipelineCreationFeedbackCreateInfo)
                .cast(),
            #[cfg(feature = "VK_HUAWEI_subpass_shading")]
            Self::SubpassShadingPipelineCreateInfoHUAWEI(ext) => (bump.alloc(ext.into_low_level(context, bump))
                as *mut crate::native::extensions::huawei_subpass_shading::SubpassShadingPipelineCreateInfoHUAWEI)
                .cast(),
            #[cfg(feature = "VK_AMD_pipeline_compiler_control")]
            Self::PipelineCompilerControlCreateInfoAMD(ext) => (bump.alloc(ext.into_low_level(context, bump))
                as *mut crate::native::extensions::amd_pipeline_compiler_control::PipelineCompilerControlCreateInfoAMD)
                .cast(),
            other => unreachable!("unexpected variant {:?}", other),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for ComputePipelineCreateInfoExtension {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        assert!(!value.is_null());
        match (* value) . s_type { # [cfg (feature = "VULKAN_1_3")] crate :: native :: vulkan1_0 :: StructureType :: PipelineCreationFeedbackCreateInfo => Self :: PipelineCreationFeedbackCreateInfo (PipelineCreationFeedbackCreateInfo :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: vulkan1_3 :: PipelineCreationFeedbackCreateInfo > ()))) , # [cfg (feature = "VK_HUAWEI_subpass_shading")] crate :: native :: vulkan1_0 :: StructureType :: SubpassShadingPipelineCreateInfoHuawei => Self :: SubpassShadingPipelineCreateInfoHUAWEI (SubpassShadingPipelineCreateInfoHUAWEI :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: huawei_subpass_shading :: SubpassShadingPipelineCreateInfoHUAWEI > ()))) , # [cfg (feature = "VK_AMD_pipeline_compiler_control")] crate :: native :: vulkan1_0 :: StructureType :: PipelineCompilerControlCreateInfoAmd => Self :: PipelineCompilerControlCreateInfoAMD (PipelineCompilerControlCreateInfoAMD :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: amd_pipeline_compiler_control :: PipelineCompilerControlCreateInfoAMD > ()))) , other => panic ! ("Structure type {:?} is not a member of {}" , other , stringify ! (ComputePipelineCreateInfo)) }
    }
}
#[cfg(feature = "VULKAN_1_3")]
impl From<PipelineCreationFeedbackCreateInfo> for ComputePipelineCreateInfoExtension {
    fn from(ext: PipelineCreationFeedbackCreateInfo) -> Self {
        Self::PipelineCreationFeedbackCreateInfo(ext)
    }
}
#[cfg(feature = "VULKAN_1_3")]
impl TryInto<PipelineCreationFeedbackCreateInfo> for ComputePipelineCreateInfoExtension {
    type Error = ComputePipelineCreateInfoExtension;
    fn try_into(self) -> Result<PipelineCreationFeedbackCreateInfo, Self::Error> {
        match self {
            Self::PipelineCreationFeedbackCreateInfo(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_HUAWEI_subpass_shading")]
impl From<SubpassShadingPipelineCreateInfoHUAWEI> for ComputePipelineCreateInfoExtension {
    fn from(ext: SubpassShadingPipelineCreateInfoHUAWEI) -> Self {
        Self::SubpassShadingPipelineCreateInfoHUAWEI(ext)
    }
}
#[cfg(feature = "VK_HUAWEI_subpass_shading")]
impl TryInto<SubpassShadingPipelineCreateInfoHUAWEI> for ComputePipelineCreateInfoExtension {
    type Error = ComputePipelineCreateInfoExtension;
    fn try_into(self) -> Result<SubpassShadingPipelineCreateInfoHUAWEI, Self::Error> {
        match self {
            Self::SubpassShadingPipelineCreateInfoHUAWEI(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_AMD_pipeline_compiler_control")]
impl From<PipelineCompilerControlCreateInfoAMD> for ComputePipelineCreateInfoExtension {
    fn from(ext: PipelineCompilerControlCreateInfoAMD) -> Self {
        Self::PipelineCompilerControlCreateInfoAMD(ext)
    }
}
#[cfg(feature = "VK_AMD_pipeline_compiler_control")]
impl TryInto<PipelineCompilerControlCreateInfoAMD> for ComputePipelineCreateInfoExtension {
    type Error = ComputePipelineCreateInfoExtension;
    fn try_into(self) -> Result<PipelineCompilerControlCreateInfoAMD, Self::Error> {
        match self {
            Self::PipelineCompilerControlCreateInfoAMD(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
impl VertexInputBindingDescription {
    ///Get a reference to the `binding` field.
    pub fn binding(&self) -> u32 {
        self.binding
    }
    ///Get a reference to the `stride` field.
    pub fn stride(&self) -> u32 {
        self.stride
    }
    ///Get a reference to the `input_rate` field.
    pub fn input_rate(&self) -> VertexInputRate {
        self.input_rate
    }
    ///Get a mutable reference to the `binding` field.
    pub fn binding_mut(&mut self) -> &mut u32 {
        &mut self.binding
    }
    ///Get a mutable reference to the `stride` field.
    pub fn stride_mut(&mut self) -> &mut u32 {
        &mut self.stride
    }
    ///Get a mutable reference to the `input_rate` field.
    pub fn input_rate_mut(&mut self) -> &mut VertexInputRate {
        &mut self.input_rate
    }
    ///Sets the `binding` field.
    pub fn set_binding(&mut self, binding: u32) -> &mut Self {
        self.binding = binding;
        self
    }
    ///Sets the `stride` field.
    pub fn set_stride(&mut self, stride: u32) -> &mut Self {
        self.stride = stride;
        self
    }
    ///Sets the `input_rate` field.
    pub fn set_input_rate(&mut self, input_rate: VertexInputRate) -> &mut Self {
        self.input_rate = input_rate;
        self
    }
    ///Sets the `binding` field in a builder way.
    pub fn with_binding(mut self, binding: u32) -> Self {
        self.binding = binding;
        self
    }
    ///Sets the `stride` field in a builder way.
    pub fn with_stride(mut self, stride: u32) -> Self {
        self.stride = stride;
        self
    }
    ///Sets the `input_rate` field in a builder way.
    pub fn with_input_rate(mut self, input_rate: VertexInputRate) -> Self {
        self.input_rate = input_rate;
        self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for VertexInputBindingDescription {
    type LowLevel = crate::native::vulkan1_0::VertexInputBindingDescription;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        crate::native::vulkan1_0::VertexInputBindingDescription {
            binding: self.binding.into_low_level(context, bump),
            stride: self.stride.into_low_level(context, bump),
            input_rate: self.input_rate.into_low_level(context, bump),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for VertexInputBindingDescription {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        Self {
            binding: crate::conv::FromLowLevel::from_low_level(context, value.binding),
            stride: crate::conv::FromLowLevel::from_low_level(context, value.stride),
            input_rate: crate::conv::FromLowLevel::from_low_level(context, value.input_rate),
        }
    }
}
impl VertexInputAttributeDescription {
    ///Get a reference to the `location` field.
    pub fn location(&self) -> u32 {
        self.location
    }
    ///Get a reference to the `binding` field.
    pub fn binding(&self) -> u32 {
        self.binding
    }
    ///Get a reference to the `format` field.
    pub fn format(&self) -> Format {
        self.format
    }
    ///Get a reference to the `offset` field.
    pub fn offset(&self) -> u32 {
        self.offset
    }
    ///Get a mutable reference to the `location` field.
    pub fn location_mut(&mut self) -> &mut u32 {
        &mut self.location
    }
    ///Get a mutable reference to the `binding` field.
    pub fn binding_mut(&mut self) -> &mut u32 {
        &mut self.binding
    }
    ///Get a mutable reference to the `format` field.
    pub fn format_mut(&mut self) -> &mut Format {
        &mut self.format
    }
    ///Get a mutable reference to the `offset` field.
    pub fn offset_mut(&mut self) -> &mut u32 {
        &mut self.offset
    }
    ///Sets the `location` field.
    pub fn set_location(&mut self, location: u32) -> &mut Self {
        self.location = location;
        self
    }
    ///Sets the `binding` field.
    pub fn set_binding(&mut self, binding: u32) -> &mut Self {
        self.binding = binding;
        self
    }
    ///Sets the `format` field.
    pub fn set_format(&mut self, format: Format) -> &mut Self {
        self.format = format;
        self
    }
    ///Sets the `offset` field.
    pub fn set_offset(&mut self, offset: u32) -> &mut Self {
        self.offset = offset;
        self
    }
    ///Sets the `location` field in a builder way.
    pub fn with_location(mut self, location: u32) -> Self {
        self.location = location;
        self
    }
    ///Sets the `binding` field in a builder way.
    pub fn with_binding(mut self, binding: u32) -> Self {
        self.binding = binding;
        self
    }
    ///Sets the `format` field in a builder way.
    pub fn with_format(mut self, format: Format) -> Self {
        self.format = format;
        self
    }
    ///Sets the `offset` field in a builder way.
    pub fn with_offset(mut self, offset: u32) -> Self {
        self.offset = offset;
        self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for VertexInputAttributeDescription {
    type LowLevel = crate::native::vulkan1_0::VertexInputAttributeDescription;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        crate::native::vulkan1_0::VertexInputAttributeDescription {
            location: self.location.into_low_level(context, bump),
            binding: self.binding.into_low_level(context, bump),
            format: self.format.into_low_level(context, bump),
            offset: self.offset.into_low_level(context, bump),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for VertexInputAttributeDescription {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        Self {
            location: crate::conv::FromLowLevel::from_low_level(context, value.location),
            binding: crate::conv::FromLowLevel::from_low_level(context, value.binding),
            format: crate::conv::FromLowLevel::from_low_level(context, value.format),
            offset: crate::conv::FromLowLevel::from_low_level(context, value.offset),
        }
    }
}
#[doc(alias = "VkPipelineVertexInputStateCreateInfo")]
#[derive(Clone, PartialEq, Debug, Default)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct PipelineVertexInputStateCreateInfo {
    #[doc(alias = "pNext")]
    pub extensions: SmallVec<[PipelineVertexInputStateCreateInfoExtension; 1]>,
    pub flags: PipelineVertexInputStateCreateFlags,
    #[doc(alias = "pVertexBindingDescriptions")]
    pub vertex_binding_descriptions: SmallVec<[VertexInputBindingDescription; 8]>,
    #[doc(alias = "pVertexAttributeDescriptions")]
    pub vertex_attribute_descriptions: SmallVec<[VertexInputAttributeDescription; 8]>,
}
impl PipelineVertexInputStateCreateInfo {
    ///Adds an extension to the struct
    pub fn with_extension(mut self, ext: impl Into<PipelineVertexInputStateCreateInfoExtension>) -> Self {
        self.extensions.push(ext.into());
        self
    }
    ///Get a reference to the `extensions` field.
    pub fn extensions(&self) -> &SmallVec<[PipelineVertexInputStateCreateInfoExtension; 1]> {
        &self.extensions
    }
    ///Get a reference to the `flags` field.
    pub fn flags(&self) -> PipelineVertexInputStateCreateFlags {
        self.flags
    }
    ///Get a reference to the `vertex_binding_descriptions` field.
    pub fn vertex_binding_descriptions(&self) -> &SmallVec<[VertexInputBindingDescription; 8]> {
        &self.vertex_binding_descriptions
    }
    ///Get a reference to the `vertex_attribute_descriptions` field.
    pub fn vertex_attribute_descriptions(&self) -> &SmallVec<[VertexInputAttributeDescription; 8]> {
        &self.vertex_attribute_descriptions
    }
    ///Get a mutable reference to the `extensions` field.
    pub fn extensions_mut(&mut self) -> &mut SmallVec<[PipelineVertexInputStateCreateInfoExtension; 1]> {
        &mut self.extensions
    }
    ///Get a mutable reference to the `flags` field.
    pub fn flags_mut(&mut self) -> &mut PipelineVertexInputStateCreateFlags {
        &mut self.flags
    }
    ///Get a mutable reference to the `vertex_binding_descriptions` field.
    pub fn vertex_binding_descriptions_mut(&mut self) -> &mut SmallVec<[VertexInputBindingDescription; 8]> {
        &mut self.vertex_binding_descriptions
    }
    ///Get a mutable reference to the `vertex_attribute_descriptions` field.
    pub fn vertex_attribute_descriptions_mut(&mut self) -> &mut SmallVec<[VertexInputAttributeDescription; 8]> {
        &mut self.vertex_attribute_descriptions
    }
    ///Sets the `extensions` field.
    pub fn set_extensions(
        &mut self,
        extensions: SmallVec<[PipelineVertexInputStateCreateInfoExtension; 1]>,
    ) -> &mut Self {
        self.extensions = extensions;
        self
    }
    ///Sets the `flags` field.
    pub fn set_flags(&mut self, flags: PipelineVertexInputStateCreateFlags) -> &mut Self {
        self.flags = flags;
        self
    }
    ///Sets the `vertex_binding_descriptions` field.
    pub fn set_vertex_binding_descriptions(
        &mut self,
        vertex_binding_descriptions: SmallVec<[VertexInputBindingDescription; 8]>,
    ) -> &mut Self {
        self.vertex_binding_descriptions = vertex_binding_descriptions;
        self
    }
    ///Sets the `vertex_attribute_descriptions` field.
    pub fn set_vertex_attribute_descriptions(
        &mut self,
        vertex_attribute_descriptions: SmallVec<[VertexInputAttributeDescription; 8]>,
    ) -> &mut Self {
        self.vertex_attribute_descriptions = vertex_attribute_descriptions;
        self
    }
    ///Sets the `extensions` field in a builder way.
    pub fn with_extensions(mut self, extensions: SmallVec<[PipelineVertexInputStateCreateInfoExtension; 1]>) -> Self {
        self.extensions = extensions;
        self
    }
    ///Sets the `flags` field in a builder way.
    pub fn with_flags(mut self, flags: PipelineVertexInputStateCreateFlags) -> Self {
        self.flags = flags;
        self
    }
    ///Sets the `vertex_binding_descriptions` field in a builder way.
    pub fn with_vertex_binding_descriptions(
        mut self,
        vertex_binding_descriptions: SmallVec<[VertexInputBindingDescription; 8]>,
    ) -> Self {
        self.vertex_binding_descriptions = vertex_binding_descriptions;
        self
    }
    ///Sets the `vertex_attribute_descriptions` field in a builder way.
    pub fn with_vertex_attribute_descriptions(
        mut self,
        vertex_attribute_descriptions: SmallVec<[VertexInputAttributeDescription; 8]>,
    ) -> Self {
        self.vertex_attribute_descriptions = vertex_attribute_descriptions;
        self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for PipelineVertexInputStateCreateInfo {
    type LowLevel = crate::native::vulkan1_0::PipelineVertexInputStateCreateInfo;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        let mut next = std::ptr::null();
        let mut extensions = self.extensions.iter();
        while let Some(ext) = extensions.next() {
            let ext = ext.into_low_level(context, bump);
            (*ext).next = next;
            next = ext;
        }
        let len_vertex_binding_descriptions = self.vertex_binding_descriptions.len() as u32;
        let vertex_binding_descriptions = bump
            .alloc_slice_fill_iter(
                self.vertex_binding_descriptions
                    .iter()
                    .map(|x| x.into_low_level(context, bump)),
            )
            .as_ptr()
            .cast();
        let len_vertex_attribute_descriptions = self.vertex_attribute_descriptions.len() as u32;
        let vertex_attribute_descriptions = bump
            .alloc_slice_fill_iter(
                self.vertex_attribute_descriptions
                    .iter()
                    .map(|x| x.into_low_level(context, bump)),
            )
            .as_ptr()
            .cast();
        crate::native::vulkan1_0::PipelineVertexInputStateCreateInfo {
            s_type: StructureType::PipelineVertexInputStateCreateInfo,
            p_next: next,
            flags: self.flags.into_low_level(context, bump),
            vertex_binding_description_count: len_vertex_binding_descriptions,
            vertex_binding_descriptions: vertex_binding_descriptions,
            vertex_attribute_description_count: len_vertex_attribute_descriptions,
            vertex_attribute_descriptions: vertex_attribute_descriptions,
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for PipelineVertexInputStateCreateInfo {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        let mut next = value.p_next;
        let mut extensions = SmallVec::new();
        while !next.is_null() {
            extensions.push(crate::conv::FromLowLevel::from_low_level(context, next));
            next = std::ptr::read(next).next;
        }
        let vertex_binding_descriptions_len = value.vertex_binding_description_count;
        let mut vertex_binding_descriptions = SmallVec::with_capacity(vertex_binding_descriptions_len as usize);
        for i in 0..vertex_binding_descriptions_len {
            vertex_binding_descriptions.push(crate::conv::FromLowLevel::from_low_level(
                context,
                value.vertex_binding_descriptions.add(i as usize).read(),
            ));
        }
        let vertex_attribute_descriptions_len = value.vertex_attribute_description_count;
        let mut vertex_attribute_descriptions = SmallVec::with_capacity(vertex_attribute_descriptions_len as usize);
        for i in 0..vertex_attribute_descriptions_len {
            vertex_attribute_descriptions.push(crate::conv::FromLowLevel::from_low_level(
                context,
                value.vertex_attribute_descriptions.add(i as usize).read(),
            ));
        }
        Self {
            extensions: extensions,
            flags: crate::conv::FromLowLevel::from_low_level(context, value.flags),
            vertex_binding_descriptions: vertex_binding_descriptions,
            vertex_attribute_descriptions: vertex_attribute_descriptions,
        }
    }
}
#[derive(Clone, PartialEq, Debug)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
///Extensions for [`PipelineVertexInputStateCreateInfo`]
pub enum PipelineVertexInputStateCreateInfoExtension {
    #[cfg(feature = "VK_EXT_vertex_attribute_divisor")]
    ///Contains a type [`PipelineVertexInputDivisorStateCreateInfoEXT`] for extending
    /// [`PipelineVertexInputStateCreateInfo`]
    PipelineVertexInputDivisorStateCreateInfoEXT(PipelineVertexInputDivisorStateCreateInfoEXT),
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for PipelineVertexInputStateCreateInfoExtension {
    type LowLevel = *const crate::native::vulkan1_0::BaseInStructure;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        match self { # [cfg (feature = "VK_EXT_vertex_attribute_divisor")] Self :: PipelineVertexInputDivisorStateCreateInfoEXT (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: ext_vertex_attribute_divisor :: PipelineVertexInputDivisorStateCreateInfoEXT) . cast () , other => unreachable ! ("unexpected variant {:?}" , other) }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for PipelineVertexInputStateCreateInfoExtension {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        assert!(!value.is_null());
        match (* value) . s_type { # [cfg (feature = "VK_EXT_vertex_attribute_divisor")] crate :: native :: vulkan1_0 :: StructureType :: PipelineVertexInputDivisorStateCreateInfoExt => Self :: PipelineVertexInputDivisorStateCreateInfoEXT (PipelineVertexInputDivisorStateCreateInfoEXT :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: ext_vertex_attribute_divisor :: PipelineVertexInputDivisorStateCreateInfoEXT > ()))) , other => panic ! ("Structure type {:?} is not a member of {}" , other , stringify ! (PipelineVertexInputStateCreateInfo)) }
    }
}
#[cfg(feature = "VK_EXT_vertex_attribute_divisor")]
impl From<PipelineVertexInputDivisorStateCreateInfoEXT> for PipelineVertexInputStateCreateInfoExtension {
    fn from(ext: PipelineVertexInputDivisorStateCreateInfoEXT) -> Self {
        Self::PipelineVertexInputDivisorStateCreateInfoEXT(ext)
    }
}
#[cfg(feature = "VK_EXT_vertex_attribute_divisor")]
impl TryInto<PipelineVertexInputDivisorStateCreateInfoEXT> for PipelineVertexInputStateCreateInfoExtension {
    type Error = PipelineVertexInputStateCreateInfoExtension;
    fn try_into(self) -> Result<PipelineVertexInputDivisorStateCreateInfoEXT, Self::Error> {
        match self {
            Self::PipelineVertexInputDivisorStateCreateInfoEXT(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[doc(alias = "VkPipelineInputAssemblyStateCreateInfo")]
#[derive(Clone, PartialEq, Debug, Default)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct PipelineInputAssemblyStateCreateInfo {
    pub flags: PipelineInputAssemblyStateCreateFlags,
    pub topology: PrimitiveTopology,
    #[doc(alias = "primitiveRestartEnable")]
    pub primitive_restart_enable: bool,
}
impl PipelineInputAssemblyStateCreateInfo {
    ///Get a reference to the `flags` field.
    pub fn flags(&self) -> PipelineInputAssemblyStateCreateFlags {
        self.flags
    }
    ///Get a reference to the `topology` field.
    pub fn topology(&self) -> PrimitiveTopology {
        self.topology
    }
    ///Get a reference to the `primitive_restart_enable` field.
    pub fn primitive_restart_enable(&self) -> &bool {
        &self.primitive_restart_enable
    }
    ///Get a mutable reference to the `flags` field.
    pub fn flags_mut(&mut self) -> &mut PipelineInputAssemblyStateCreateFlags {
        &mut self.flags
    }
    ///Get a mutable reference to the `topology` field.
    pub fn topology_mut(&mut self) -> &mut PrimitiveTopology {
        &mut self.topology
    }
    ///Get a mutable reference to the `primitive_restart_enable` field.
    pub fn primitive_restart_enable_mut(&mut self) -> &mut bool {
        &mut self.primitive_restart_enable
    }
    ///Sets the `flags` field.
    pub fn set_flags(&mut self, flags: PipelineInputAssemblyStateCreateFlags) -> &mut Self {
        self.flags = flags;
        self
    }
    ///Sets the `topology` field.
    pub fn set_topology(&mut self, topology: PrimitiveTopology) -> &mut Self {
        self.topology = topology;
        self
    }
    ///Sets the `primitive_restart_enable` field.
    pub fn set_primitive_restart_enable(&mut self, primitive_restart_enable: bool) -> &mut Self {
        self.primitive_restart_enable = primitive_restart_enable;
        self
    }
    ///Sets the `flags` field in a builder way.
    pub fn with_flags(mut self, flags: PipelineInputAssemblyStateCreateFlags) -> Self {
        self.flags = flags;
        self
    }
    ///Sets the `topology` field in a builder way.
    pub fn with_topology(mut self, topology: PrimitiveTopology) -> Self {
        self.topology = topology;
        self
    }
    ///Sets the `primitive_restart_enable` field in a builder way.
    pub fn with_primitive_restart_enable(mut self, primitive_restart_enable: bool) -> Self {
        self.primitive_restart_enable = primitive_restart_enable;
        self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for PipelineInputAssemblyStateCreateInfo {
    type LowLevel = crate::native::vulkan1_0::PipelineInputAssemblyStateCreateInfo;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        crate::native::vulkan1_0::PipelineInputAssemblyStateCreateInfo {
            s_type: StructureType::PipelineInputAssemblyStateCreateInfo,
            p_next: std::ptr::null(),
            flags: self.flags.into_low_level(context, bump),
            topology: self.topology.into_low_level(context, bump),
            primitive_restart_enable: self.primitive_restart_enable.into_low_level(context, bump),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for PipelineInputAssemblyStateCreateInfo {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        Self {
            flags: crate::conv::FromLowLevel::from_low_level(context, value.flags),
            topology: crate::conv::FromLowLevel::from_low_level(context, value.topology),
            primitive_restart_enable: crate::conv::FromLowLevel::from_low_level(
                context,
                value.primitive_restart_enable,
            ),
        }
    }
}
#[doc(alias = "VkPipelineTessellationStateCreateInfo")]
#[derive(Clone, PartialEq, Debug, Default)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct PipelineTessellationStateCreateInfo {
    #[doc(alias = "pNext")]
    pub extensions: SmallVec<[PipelineTessellationStateCreateInfoExtension; 1]>,
    pub flags: PipelineTessellationStateCreateFlags,
    #[doc(alias = "patchControlPoints")]
    pub patch_control_points: u32,
}
impl PipelineTessellationStateCreateInfo {
    ///Adds an extension to the struct
    pub fn with_extension(mut self, ext: impl Into<PipelineTessellationStateCreateInfoExtension>) -> Self {
        self.extensions.push(ext.into());
        self
    }
    ///Get a reference to the `extensions` field.
    pub fn extensions(&self) -> &SmallVec<[PipelineTessellationStateCreateInfoExtension; 1]> {
        &self.extensions
    }
    ///Get a reference to the `flags` field.
    pub fn flags(&self) -> PipelineTessellationStateCreateFlags {
        self.flags
    }
    ///Get a reference to the `patch_control_points` field.
    pub fn patch_control_points(&self) -> u32 {
        self.patch_control_points
    }
    ///Get a mutable reference to the `extensions` field.
    pub fn extensions_mut(&mut self) -> &mut SmallVec<[PipelineTessellationStateCreateInfoExtension; 1]> {
        &mut self.extensions
    }
    ///Get a mutable reference to the `flags` field.
    pub fn flags_mut(&mut self) -> &mut PipelineTessellationStateCreateFlags {
        &mut self.flags
    }
    ///Get a mutable reference to the `patch_control_points` field.
    pub fn patch_control_points_mut(&mut self) -> &mut u32 {
        &mut self.patch_control_points
    }
    ///Sets the `extensions` field.
    pub fn set_extensions(
        &mut self,
        extensions: SmallVec<[PipelineTessellationStateCreateInfoExtension; 1]>,
    ) -> &mut Self {
        self.extensions = extensions;
        self
    }
    ///Sets the `flags` field.
    pub fn set_flags(&mut self, flags: PipelineTessellationStateCreateFlags) -> &mut Self {
        self.flags = flags;
        self
    }
    ///Sets the `patch_control_points` field.
    pub fn set_patch_control_points(&mut self, patch_control_points: u32) -> &mut Self {
        self.patch_control_points = patch_control_points;
        self
    }
    ///Sets the `extensions` field in a builder way.
    pub fn with_extensions(mut self, extensions: SmallVec<[PipelineTessellationStateCreateInfoExtension; 1]>) -> Self {
        self.extensions = extensions;
        self
    }
    ///Sets the `flags` field in a builder way.
    pub fn with_flags(mut self, flags: PipelineTessellationStateCreateFlags) -> Self {
        self.flags = flags;
        self
    }
    ///Sets the `patch_control_points` field in a builder way.
    pub fn with_patch_control_points(mut self, patch_control_points: u32) -> Self {
        self.patch_control_points = patch_control_points;
        self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for PipelineTessellationStateCreateInfo {
    type LowLevel = crate::native::vulkan1_0::PipelineTessellationStateCreateInfo;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        let mut next = std::ptr::null();
        let mut extensions = self.extensions.iter();
        while let Some(ext) = extensions.next() {
            let ext = ext.into_low_level(context, bump);
            (*ext).next = next;
            next = ext;
        }
        crate::native::vulkan1_0::PipelineTessellationStateCreateInfo {
            s_type: StructureType::PipelineTessellationStateCreateInfo,
            p_next: next,
            flags: self.flags.into_low_level(context, bump),
            patch_control_points: self.patch_control_points.into_low_level(context, bump),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for PipelineTessellationStateCreateInfo {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        let mut next = value.p_next;
        let mut extensions = SmallVec::new();
        while !next.is_null() {
            extensions.push(crate::conv::FromLowLevel::from_low_level(context, next));
            next = std::ptr::read(next).next;
        }
        Self {
            extensions: extensions,
            flags: crate::conv::FromLowLevel::from_low_level(context, value.flags),
            patch_control_points: crate::conv::FromLowLevel::from_low_level(context, value.patch_control_points),
        }
    }
}
#[derive(Clone, PartialEq, Debug, Copy)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
///Extensions for [`PipelineTessellationStateCreateInfo`]
pub enum PipelineTessellationStateCreateInfoExtension {
    ///Contains a type [`PipelineTessellationDomainOriginStateCreateInfo`] for extending
    /// [`PipelineTessellationStateCreateInfo`]
    PipelineTessellationDomainOriginStateCreateInfo(PipelineTessellationDomainOriginStateCreateInfo),
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for PipelineTessellationStateCreateInfoExtension {
    type LowLevel = *const crate::native::vulkan1_0::BaseInStructure;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        match self {
            Self::PipelineTessellationDomainOriginStateCreateInfo(ext) => {
                (bump.alloc(ext.into_low_level(context, bump))
                    as *mut crate::native::vulkan1_1::PipelineTessellationDomainOriginStateCreateInfo)
                    .cast()
            },
            other => unreachable!("unexpected variant {:?}", other),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for PipelineTessellationStateCreateInfoExtension {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        assert!(!value.is_null());
        match (*value).s_type {
            crate::native::vulkan1_0::StructureType::PipelineTessellationDomainOriginStateCreateInfo => {
                Self::PipelineTessellationDomainOriginStateCreateInfo(
                    PipelineTessellationDomainOriginStateCreateInfo::from_low_level(
                        context,
                        std::ptr::read(
                            value.cast::<crate::native::vulkan1_1::PipelineTessellationDomainOriginStateCreateInfo>(),
                        ),
                    ),
                )
            },
            other => panic!(
                "Structure type {:?} is not a member of {}",
                other,
                stringify!(PipelineTessellationStateCreateInfo)
            ),
        }
    }
}
impl From<PipelineTessellationDomainOriginStateCreateInfo> for PipelineTessellationStateCreateInfoExtension {
    fn from(ext: PipelineTessellationDomainOriginStateCreateInfo) -> Self {
        Self::PipelineTessellationDomainOriginStateCreateInfo(ext)
    }
}
impl TryInto<PipelineTessellationDomainOriginStateCreateInfo> for PipelineTessellationStateCreateInfoExtension {
    type Error = PipelineTessellationStateCreateInfoExtension;
    fn try_into(self) -> Result<PipelineTessellationDomainOriginStateCreateInfo, Self::Error> {
        match self {
            Self::PipelineTessellationDomainOriginStateCreateInfo(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[doc(alias = "VkPipelineViewportStateCreateInfo")]
#[derive(Clone, PartialEq, Debug, Default)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct PipelineViewportStateCreateInfo {
    #[doc(alias = "pNext")]
    pub extensions: SmallVec<[PipelineViewportStateCreateInfoExtension; 1]>,
    pub flags: PipelineViewportStateCreateFlags,
    #[doc(alias = "pViewports")]
    pub viewports: SmallVec<[Viewport; 8]>,
    #[doc(alias = "pScissors")]
    pub scissors: SmallVec<[Rect2D; 8]>,
}
impl PipelineViewportStateCreateInfo {
    ///Adds an extension to the struct
    pub fn with_extension(mut self, ext: impl Into<PipelineViewportStateCreateInfoExtension>) -> Self {
        self.extensions.push(ext.into());
        self
    }
    ///Get a reference to the `extensions` field.
    pub fn extensions(&self) -> &SmallVec<[PipelineViewportStateCreateInfoExtension; 1]> {
        &self.extensions
    }
    ///Get a reference to the `flags` field.
    pub fn flags(&self) -> PipelineViewportStateCreateFlags {
        self.flags
    }
    ///Get a reference to the `viewports` field.
    pub fn viewports(&self) -> &SmallVec<[Viewport; 8]> {
        &self.viewports
    }
    ///Get a reference to the `scissors` field.
    pub fn scissors(&self) -> &SmallVec<[Rect2D; 8]> {
        &self.scissors
    }
    ///Get a mutable reference to the `extensions` field.
    pub fn extensions_mut(&mut self) -> &mut SmallVec<[PipelineViewportStateCreateInfoExtension; 1]> {
        &mut self.extensions
    }
    ///Get a mutable reference to the `flags` field.
    pub fn flags_mut(&mut self) -> &mut PipelineViewportStateCreateFlags {
        &mut self.flags
    }
    ///Get a mutable reference to the `viewports` field.
    pub fn viewports_mut(&mut self) -> &mut SmallVec<[Viewport; 8]> {
        &mut self.viewports
    }
    ///Get a mutable reference to the `scissors` field.
    pub fn scissors_mut(&mut self) -> &mut SmallVec<[Rect2D; 8]> {
        &mut self.scissors
    }
    ///Sets the `extensions` field.
    pub fn set_extensions(&mut self, extensions: SmallVec<[PipelineViewportStateCreateInfoExtension; 1]>) -> &mut Self {
        self.extensions = extensions;
        self
    }
    ///Sets the `flags` field.
    pub fn set_flags(&mut self, flags: PipelineViewportStateCreateFlags) -> &mut Self {
        self.flags = flags;
        self
    }
    ///Sets the `viewports` field.
    pub fn set_viewports(&mut self, viewports: SmallVec<[Viewport; 8]>) -> &mut Self {
        self.viewports = viewports;
        self
    }
    ///Sets the `scissors` field.
    pub fn set_scissors(&mut self, scissors: SmallVec<[Rect2D; 8]>) -> &mut Self {
        self.scissors = scissors;
        self
    }
    ///Sets the `extensions` field in a builder way.
    pub fn with_extensions(mut self, extensions: SmallVec<[PipelineViewportStateCreateInfoExtension; 1]>) -> Self {
        self.extensions = extensions;
        self
    }
    ///Sets the `flags` field in a builder way.
    pub fn with_flags(mut self, flags: PipelineViewportStateCreateFlags) -> Self {
        self.flags = flags;
        self
    }
    ///Sets the `viewports` field in a builder way.
    pub fn with_viewports(mut self, viewports: SmallVec<[Viewport; 8]>) -> Self {
        self.viewports = viewports;
        self
    }
    ///Sets the `scissors` field in a builder way.
    pub fn with_scissors(mut self, scissors: SmallVec<[Rect2D; 8]>) -> Self {
        self.scissors = scissors;
        self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for PipelineViewportStateCreateInfo {
    type LowLevel = crate::native::vulkan1_0::PipelineViewportStateCreateInfo;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        let mut next = std::ptr::null();
        let mut extensions = self.extensions.iter();
        while let Some(ext) = extensions.next() {
            let ext = ext.into_low_level(context, bump);
            (*ext).next = next;
            next = ext;
        }
        let len_viewports = self.viewports.len() as u32;
        let viewports = bump
            .alloc_slice_fill_iter(self.viewports.iter().map(|x| x.into_low_level(context, bump)))
            .as_ptr()
            .cast();
        let len_scissors = self.scissors.len() as u32;
        let scissors = bump
            .alloc_slice_fill_iter(self.scissors.iter().map(|x| x.into_low_level(context, bump)))
            .as_ptr()
            .cast();
        crate::native::vulkan1_0::PipelineViewportStateCreateInfo {
            s_type: StructureType::PipelineViewportStateCreateInfo,
            p_next: next,
            flags: self.flags.into_low_level(context, bump),
            viewport_count: len_viewports,
            viewports: viewports,
            scissor_count: len_scissors,
            scissors: scissors,
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for PipelineViewportStateCreateInfo {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        let mut next = value.p_next;
        let mut extensions = SmallVec::new();
        while !next.is_null() {
            extensions.push(crate::conv::FromLowLevel::from_low_level(context, next));
            next = std::ptr::read(next).next;
        }
        let viewports_len = value.viewport_count;
        let mut viewports = SmallVec::with_capacity(viewports_len as usize);
        for i in 0..viewports_len {
            viewports.push(crate::conv::FromLowLevel::from_low_level(
                context,
                value.viewports.add(i as usize).read(),
            ));
        }
        let scissors_len = value.scissor_count;
        let mut scissors = SmallVec::with_capacity(scissors_len as usize);
        for i in 0..scissors_len {
            scissors.push(crate::conv::FromLowLevel::from_low_level(
                context,
                value.scissors.add(i as usize).read(),
            ));
        }
        Self {
            extensions: extensions,
            flags: crate::conv::FromLowLevel::from_low_level(context, value.flags),
            viewports: viewports,
            scissors: scissors,
        }
    }
}
#[derive(Clone, PartialEq, Debug)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
///Extensions for [`PipelineViewportStateCreateInfo`]
pub enum PipelineViewportStateCreateInfoExtension {
    #[cfg(feature = "VK_NV_clip_space_w_scaling")]
    ///Contains a type [`PipelineViewportWScalingStateCreateInfoNV`] for extending
    /// [`PipelineViewportStateCreateInfo`]
    PipelineViewportWScalingStateCreateInfoNV(PipelineViewportWScalingStateCreateInfoNV),
    #[cfg(feature = "VK_NV_viewport_swizzle")]
    ///Contains a type [`PipelineViewportSwizzleStateCreateInfoNV`] for extending
    /// [`PipelineViewportStateCreateInfo`]
    PipelineViewportSwizzleStateCreateInfoNV(PipelineViewportSwizzleStateCreateInfoNV),
    #[cfg(feature = "VK_NV_scissor_exclusive")]
    ///Contains a type [`PipelineViewportExclusiveScissorStateCreateInfoNV`] for extending
    /// [`PipelineViewportStateCreateInfo`]
    PipelineViewportExclusiveScissorStateCreateInfoNV(PipelineViewportExclusiveScissorStateCreateInfoNV),
    #[cfg(feature = "VK_NV_shading_rate_image")]
    ///Contains a type [`PipelineViewportShadingRateImageStateCreateInfoNV`] for extending
    /// [`PipelineViewportStateCreateInfo`]
    PipelineViewportShadingRateImageStateCreateInfoNV(PipelineViewportShadingRateImageStateCreateInfoNV),
    #[cfg(feature = "VK_NV_shading_rate_image")]
    ///Contains a type [`PipelineViewportCoarseSampleOrderStateCreateInfoNV`] for extending
    /// [`PipelineViewportStateCreateInfo`]
    PipelineViewportCoarseSampleOrderStateCreateInfoNV(PipelineViewportCoarseSampleOrderStateCreateInfoNV),
    #[cfg(feature = "VK_EXT_depth_clip_control")]
    ///Contains a type [`PipelineViewportDepthClipControlCreateInfoEXT`] for extending
    /// [`PipelineViewportStateCreateInfo`]
    PipelineViewportDepthClipControlCreateInfoEXT(PipelineViewportDepthClipControlCreateInfoEXT),
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for PipelineViewportStateCreateInfoExtension {
    type LowLevel = *const crate::native::vulkan1_0::BaseInStructure;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        match self { # [cfg (feature = "VK_NV_clip_space_w_scaling")] Self :: PipelineViewportWScalingStateCreateInfoNV (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: nv_clip_space_w_scaling :: PipelineViewportWScalingStateCreateInfoNV) . cast () , # [cfg (feature = "VK_NV_viewport_swizzle")] Self :: PipelineViewportSwizzleStateCreateInfoNV (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: nv_viewport_swizzle :: PipelineViewportSwizzleStateCreateInfoNV) . cast () , # [cfg (feature = "VK_NV_scissor_exclusive")] Self :: PipelineViewportExclusiveScissorStateCreateInfoNV (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: nv_scissor_exclusive :: PipelineViewportExclusiveScissorStateCreateInfoNV) . cast () , # [cfg (feature = "VK_NV_shading_rate_image")] Self :: PipelineViewportShadingRateImageStateCreateInfoNV (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: nv_shading_rate_image :: PipelineViewportShadingRateImageStateCreateInfoNV) . cast () , # [cfg (feature = "VK_NV_shading_rate_image")] Self :: PipelineViewportCoarseSampleOrderStateCreateInfoNV (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: nv_shading_rate_image :: PipelineViewportCoarseSampleOrderStateCreateInfoNV) . cast () , # [cfg (feature = "VK_EXT_depth_clip_control")] Self :: PipelineViewportDepthClipControlCreateInfoEXT (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: ext_depth_clip_control :: PipelineViewportDepthClipControlCreateInfoEXT) . cast () , other => unreachable ! ("unexpected variant {:?}" , other) }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for PipelineViewportStateCreateInfoExtension {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        assert!(!value.is_null());
        match (* value) . s_type { # [cfg (feature = "VK_NV_clip_space_w_scaling")] crate :: native :: vulkan1_0 :: StructureType :: PipelineViewportWScalingStateCreateInfoNv => Self :: PipelineViewportWScalingStateCreateInfoNV (PipelineViewportWScalingStateCreateInfoNV :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: nv_clip_space_w_scaling :: PipelineViewportWScalingStateCreateInfoNV > ()))) , # [cfg (feature = "VK_NV_viewport_swizzle")] crate :: native :: vulkan1_0 :: StructureType :: PipelineViewportSwizzleStateCreateInfoNv => Self :: PipelineViewportSwizzleStateCreateInfoNV (PipelineViewportSwizzleStateCreateInfoNV :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: nv_viewport_swizzle :: PipelineViewportSwizzleStateCreateInfoNV > ()))) , # [cfg (feature = "VK_NV_scissor_exclusive")] crate :: native :: vulkan1_0 :: StructureType :: PipelineViewportExclusiveScissorStateCreateInfoNv => Self :: PipelineViewportExclusiveScissorStateCreateInfoNV (PipelineViewportExclusiveScissorStateCreateInfoNV :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: nv_scissor_exclusive :: PipelineViewportExclusiveScissorStateCreateInfoNV > ()))) , # [cfg (feature = "VK_NV_shading_rate_image")] crate :: native :: vulkan1_0 :: StructureType :: PipelineViewportShadingRateImageStateCreateInfoNv => Self :: PipelineViewportShadingRateImageStateCreateInfoNV (PipelineViewportShadingRateImageStateCreateInfoNV :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: nv_shading_rate_image :: PipelineViewportShadingRateImageStateCreateInfoNV > ()))) , # [cfg (feature = "VK_NV_shading_rate_image")] crate :: native :: vulkan1_0 :: StructureType :: PipelineViewportCoarseSampleOrderStateCreateInfoNv => Self :: PipelineViewportCoarseSampleOrderStateCreateInfoNV (PipelineViewportCoarseSampleOrderStateCreateInfoNV :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: nv_shading_rate_image :: PipelineViewportCoarseSampleOrderStateCreateInfoNV > ()))) , # [cfg (feature = "VK_EXT_depth_clip_control")] crate :: native :: vulkan1_0 :: StructureType :: PipelineViewportDepthClipControlCreateInfoExt => Self :: PipelineViewportDepthClipControlCreateInfoEXT (PipelineViewportDepthClipControlCreateInfoEXT :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: ext_depth_clip_control :: PipelineViewportDepthClipControlCreateInfoEXT > ()))) , other => panic ! ("Structure type {:?} is not a member of {}" , other , stringify ! (PipelineViewportStateCreateInfo)) }
    }
}
#[cfg(feature = "VK_NV_clip_space_w_scaling")]
impl From<PipelineViewportWScalingStateCreateInfoNV> for PipelineViewportStateCreateInfoExtension {
    fn from(ext: PipelineViewportWScalingStateCreateInfoNV) -> Self {
        Self::PipelineViewportWScalingStateCreateInfoNV(ext)
    }
}
#[cfg(feature = "VK_NV_clip_space_w_scaling")]
impl TryInto<PipelineViewportWScalingStateCreateInfoNV> for PipelineViewportStateCreateInfoExtension {
    type Error = PipelineViewportStateCreateInfoExtension;
    fn try_into(self) -> Result<PipelineViewportWScalingStateCreateInfoNV, Self::Error> {
        match self {
            Self::PipelineViewportWScalingStateCreateInfoNV(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_NV_viewport_swizzle")]
impl From<PipelineViewportSwizzleStateCreateInfoNV> for PipelineViewportStateCreateInfoExtension {
    fn from(ext: PipelineViewportSwizzleStateCreateInfoNV) -> Self {
        Self::PipelineViewportSwizzleStateCreateInfoNV(ext)
    }
}
#[cfg(feature = "VK_NV_viewport_swizzle")]
impl TryInto<PipelineViewportSwizzleStateCreateInfoNV> for PipelineViewportStateCreateInfoExtension {
    type Error = PipelineViewportStateCreateInfoExtension;
    fn try_into(self) -> Result<PipelineViewportSwizzleStateCreateInfoNV, Self::Error> {
        match self {
            Self::PipelineViewportSwizzleStateCreateInfoNV(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_NV_scissor_exclusive")]
impl From<PipelineViewportExclusiveScissorStateCreateInfoNV> for PipelineViewportStateCreateInfoExtension {
    fn from(ext: PipelineViewportExclusiveScissorStateCreateInfoNV) -> Self {
        Self::PipelineViewportExclusiveScissorStateCreateInfoNV(ext)
    }
}
#[cfg(feature = "VK_NV_scissor_exclusive")]
impl TryInto<PipelineViewportExclusiveScissorStateCreateInfoNV> for PipelineViewportStateCreateInfoExtension {
    type Error = PipelineViewportStateCreateInfoExtension;
    fn try_into(self) -> Result<PipelineViewportExclusiveScissorStateCreateInfoNV, Self::Error> {
        match self {
            Self::PipelineViewportExclusiveScissorStateCreateInfoNV(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_NV_shading_rate_image")]
impl From<PipelineViewportShadingRateImageStateCreateInfoNV> for PipelineViewportStateCreateInfoExtension {
    fn from(ext: PipelineViewportShadingRateImageStateCreateInfoNV) -> Self {
        Self::PipelineViewportShadingRateImageStateCreateInfoNV(ext)
    }
}
#[cfg(feature = "VK_NV_shading_rate_image")]
impl TryInto<PipelineViewportShadingRateImageStateCreateInfoNV> for PipelineViewportStateCreateInfoExtension {
    type Error = PipelineViewportStateCreateInfoExtension;
    fn try_into(self) -> Result<PipelineViewportShadingRateImageStateCreateInfoNV, Self::Error> {
        match self {
            Self::PipelineViewportShadingRateImageStateCreateInfoNV(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_NV_shading_rate_image")]
impl From<PipelineViewportCoarseSampleOrderStateCreateInfoNV> for PipelineViewportStateCreateInfoExtension {
    fn from(ext: PipelineViewportCoarseSampleOrderStateCreateInfoNV) -> Self {
        Self::PipelineViewportCoarseSampleOrderStateCreateInfoNV(ext)
    }
}
#[cfg(feature = "VK_NV_shading_rate_image")]
impl TryInto<PipelineViewportCoarseSampleOrderStateCreateInfoNV> for PipelineViewportStateCreateInfoExtension {
    type Error = PipelineViewportStateCreateInfoExtension;
    fn try_into(self) -> Result<PipelineViewportCoarseSampleOrderStateCreateInfoNV, Self::Error> {
        match self {
            Self::PipelineViewportCoarseSampleOrderStateCreateInfoNV(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_EXT_depth_clip_control")]
impl From<PipelineViewportDepthClipControlCreateInfoEXT> for PipelineViewportStateCreateInfoExtension {
    fn from(ext: PipelineViewportDepthClipControlCreateInfoEXT) -> Self {
        Self::PipelineViewportDepthClipControlCreateInfoEXT(ext)
    }
}
#[cfg(feature = "VK_EXT_depth_clip_control")]
impl TryInto<PipelineViewportDepthClipControlCreateInfoEXT> for PipelineViewportStateCreateInfoExtension {
    type Error = PipelineViewportStateCreateInfoExtension;
    fn try_into(self) -> Result<PipelineViewportDepthClipControlCreateInfoEXT, Self::Error> {
        match self {
            Self::PipelineViewportDepthClipControlCreateInfoEXT(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[doc(alias = "VkPipelineRasterizationStateCreateInfo")]
#[derive(Clone, PartialEq, Debug, Default)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct PipelineRasterizationStateCreateInfo {
    #[doc(alias = "pNext")]
    pub extensions: SmallVec<[PipelineRasterizationStateCreateInfoExtension; 1]>,
    pub flags: PipelineRasterizationStateCreateFlags,
    #[doc(alias = "depthClampEnable")]
    pub depth_clamp_enable: bool,
    #[doc(alias = "rasterizerDiscardEnable")]
    pub rasterizer_discard_enable: bool,
    #[doc(alias = "polygonMode")]
    pub polygon_mode: PolygonMode,
    #[doc(alias = "cullMode")]
    pub cull_mode: CullModeFlags,
    #[doc(alias = "frontFace")]
    pub front_face: FrontFace,
    #[doc(alias = "depthBiasEnable")]
    pub depth_bias_enable: bool,
    #[doc(alias = "depthBiasConstantFactor")]
    pub depth_bias_constant_factor: f32,
    #[doc(alias = "depthBiasClamp")]
    pub depth_bias_clamp: f32,
    #[doc(alias = "depthBiasSlopeFactor")]
    pub depth_bias_slope_factor: f32,
    #[doc(alias = "lineWidth")]
    pub line_width: f32,
}
impl PipelineRasterizationStateCreateInfo {
    ///Adds an extension to the struct
    pub fn with_extension(mut self, ext: impl Into<PipelineRasterizationStateCreateInfoExtension>) -> Self {
        self.extensions.push(ext.into());
        self
    }
    ///Get a reference to the `extensions` field.
    pub fn extensions(&self) -> &SmallVec<[PipelineRasterizationStateCreateInfoExtension; 1]> {
        &self.extensions
    }
    ///Get a reference to the `flags` field.
    pub fn flags(&self) -> PipelineRasterizationStateCreateFlags {
        self.flags
    }
    ///Get a reference to the `depth_clamp_enable` field.
    pub fn depth_clamp_enable(&self) -> &bool {
        &self.depth_clamp_enable
    }
    ///Get a reference to the `rasterizer_discard_enable` field.
    pub fn rasterizer_discard_enable(&self) -> &bool {
        &self.rasterizer_discard_enable
    }
    ///Get a reference to the `polygon_mode` field.
    pub fn polygon_mode(&self) -> PolygonMode {
        self.polygon_mode
    }
    ///Get a reference to the `cull_mode` field.
    pub fn cull_mode(&self) -> CullModeFlags {
        self.cull_mode
    }
    ///Get a reference to the `front_face` field.
    pub fn front_face(&self) -> FrontFace {
        self.front_face
    }
    ///Get a reference to the `depth_bias_enable` field.
    pub fn depth_bias_enable(&self) -> &bool {
        &self.depth_bias_enable
    }
    ///Get a reference to the `depth_bias_constant_factor` field.
    pub fn depth_bias_constant_factor(&self) -> f32 {
        self.depth_bias_constant_factor
    }
    ///Get a reference to the `depth_bias_clamp` field.
    pub fn depth_bias_clamp(&self) -> f32 {
        self.depth_bias_clamp
    }
    ///Get a reference to the `depth_bias_slope_factor` field.
    pub fn depth_bias_slope_factor(&self) -> f32 {
        self.depth_bias_slope_factor
    }
    ///Get a reference to the `line_width` field.
    pub fn line_width(&self) -> f32 {
        self.line_width
    }
    ///Get a mutable reference to the `extensions` field.
    pub fn extensions_mut(&mut self) -> &mut SmallVec<[PipelineRasterizationStateCreateInfoExtension; 1]> {
        &mut self.extensions
    }
    ///Get a mutable reference to the `flags` field.
    pub fn flags_mut(&mut self) -> &mut PipelineRasterizationStateCreateFlags {
        &mut self.flags
    }
    ///Get a mutable reference to the `depth_clamp_enable` field.
    pub fn depth_clamp_enable_mut(&mut self) -> &mut bool {
        &mut self.depth_clamp_enable
    }
    ///Get a mutable reference to the `rasterizer_discard_enable` field.
    pub fn rasterizer_discard_enable_mut(&mut self) -> &mut bool {
        &mut self.rasterizer_discard_enable
    }
    ///Get a mutable reference to the `polygon_mode` field.
    pub fn polygon_mode_mut(&mut self) -> &mut PolygonMode {
        &mut self.polygon_mode
    }
    ///Get a mutable reference to the `cull_mode` field.
    pub fn cull_mode_mut(&mut self) -> &mut CullModeFlags {
        &mut self.cull_mode
    }
    ///Get a mutable reference to the `front_face` field.
    pub fn front_face_mut(&mut self) -> &mut FrontFace {
        &mut self.front_face
    }
    ///Get a mutable reference to the `depth_bias_enable` field.
    pub fn depth_bias_enable_mut(&mut self) -> &mut bool {
        &mut self.depth_bias_enable
    }
    ///Get a mutable reference to the `depth_bias_constant_factor` field.
    pub fn depth_bias_constant_factor_mut(&mut self) -> &mut f32 {
        &mut self.depth_bias_constant_factor
    }
    ///Get a mutable reference to the `depth_bias_clamp` field.
    pub fn depth_bias_clamp_mut(&mut self) -> &mut f32 {
        &mut self.depth_bias_clamp
    }
    ///Get a mutable reference to the `depth_bias_slope_factor` field.
    pub fn depth_bias_slope_factor_mut(&mut self) -> &mut f32 {
        &mut self.depth_bias_slope_factor
    }
    ///Get a mutable reference to the `line_width` field.
    pub fn line_width_mut(&mut self) -> &mut f32 {
        &mut self.line_width
    }
    ///Sets the `extensions` field.
    pub fn set_extensions(
        &mut self,
        extensions: SmallVec<[PipelineRasterizationStateCreateInfoExtension; 1]>,
    ) -> &mut Self {
        self.extensions = extensions;
        self
    }
    ///Sets the `flags` field.
    pub fn set_flags(&mut self, flags: PipelineRasterizationStateCreateFlags) -> &mut Self {
        self.flags = flags;
        self
    }
    ///Sets the `depth_clamp_enable` field.
    pub fn set_depth_clamp_enable(&mut self, depth_clamp_enable: bool) -> &mut Self {
        self.depth_clamp_enable = depth_clamp_enable;
        self
    }
    ///Sets the `rasterizer_discard_enable` field.
    pub fn set_rasterizer_discard_enable(&mut self, rasterizer_discard_enable: bool) -> &mut Self {
        self.rasterizer_discard_enable = rasterizer_discard_enable;
        self
    }
    ///Sets the `polygon_mode` field.
    pub fn set_polygon_mode(&mut self, polygon_mode: PolygonMode) -> &mut Self {
        self.polygon_mode = polygon_mode;
        self
    }
    ///Sets the `cull_mode` field.
    pub fn set_cull_mode(&mut self, cull_mode: CullModeFlags) -> &mut Self {
        self.cull_mode = cull_mode;
        self
    }
    ///Sets the `front_face` field.
    pub fn set_front_face(&mut self, front_face: FrontFace) -> &mut Self {
        self.front_face = front_face;
        self
    }
    ///Sets the `depth_bias_enable` field.
    pub fn set_depth_bias_enable(&mut self, depth_bias_enable: bool) -> &mut Self {
        self.depth_bias_enable = depth_bias_enable;
        self
    }
    ///Sets the `depth_bias_constant_factor` field.
    pub fn set_depth_bias_constant_factor(&mut self, depth_bias_constant_factor: f32) -> &mut Self {
        self.depth_bias_constant_factor = depth_bias_constant_factor;
        self
    }
    ///Sets the `depth_bias_clamp` field.
    pub fn set_depth_bias_clamp(&mut self, depth_bias_clamp: f32) -> &mut Self {
        self.depth_bias_clamp = depth_bias_clamp;
        self
    }
    ///Sets the `depth_bias_slope_factor` field.
    pub fn set_depth_bias_slope_factor(&mut self, depth_bias_slope_factor: f32) -> &mut Self {
        self.depth_bias_slope_factor = depth_bias_slope_factor;
        self
    }
    ///Sets the `line_width` field.
    pub fn set_line_width(&mut self, line_width: f32) -> &mut Self {
        self.line_width = line_width;
        self
    }
    ///Sets the `extensions` field in a builder way.
    pub fn with_extensions(mut self, extensions: SmallVec<[PipelineRasterizationStateCreateInfoExtension; 1]>) -> Self {
        self.extensions = extensions;
        self
    }
    ///Sets the `flags` field in a builder way.
    pub fn with_flags(mut self, flags: PipelineRasterizationStateCreateFlags) -> Self {
        self.flags = flags;
        self
    }
    ///Sets the `depth_clamp_enable` field in a builder way.
    pub fn with_depth_clamp_enable(mut self, depth_clamp_enable: bool) -> Self {
        self.depth_clamp_enable = depth_clamp_enable;
        self
    }
    ///Sets the `rasterizer_discard_enable` field in a builder way.
    pub fn with_rasterizer_discard_enable(mut self, rasterizer_discard_enable: bool) -> Self {
        self.rasterizer_discard_enable = rasterizer_discard_enable;
        self
    }
    ///Sets the `polygon_mode` field in a builder way.
    pub fn with_polygon_mode(mut self, polygon_mode: PolygonMode) -> Self {
        self.polygon_mode = polygon_mode;
        self
    }
    ///Sets the `cull_mode` field in a builder way.
    pub fn with_cull_mode(mut self, cull_mode: CullModeFlags) -> Self {
        self.cull_mode = cull_mode;
        self
    }
    ///Sets the `front_face` field in a builder way.
    pub fn with_front_face(mut self, front_face: FrontFace) -> Self {
        self.front_face = front_face;
        self
    }
    ///Sets the `depth_bias_enable` field in a builder way.
    pub fn with_depth_bias_enable(mut self, depth_bias_enable: bool) -> Self {
        self.depth_bias_enable = depth_bias_enable;
        self
    }
    ///Sets the `depth_bias_constant_factor` field in a builder way.
    pub fn with_depth_bias_constant_factor(mut self, depth_bias_constant_factor: f32) -> Self {
        self.depth_bias_constant_factor = depth_bias_constant_factor;
        self
    }
    ///Sets the `depth_bias_clamp` field in a builder way.
    pub fn with_depth_bias_clamp(mut self, depth_bias_clamp: f32) -> Self {
        self.depth_bias_clamp = depth_bias_clamp;
        self
    }
    ///Sets the `depth_bias_slope_factor` field in a builder way.
    pub fn with_depth_bias_slope_factor(mut self, depth_bias_slope_factor: f32) -> Self {
        self.depth_bias_slope_factor = depth_bias_slope_factor;
        self
    }
    ///Sets the `line_width` field in a builder way.
    pub fn with_line_width(mut self, line_width: f32) -> Self {
        self.line_width = line_width;
        self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for PipelineRasterizationStateCreateInfo {
    type LowLevel = crate::native::vulkan1_0::PipelineRasterizationStateCreateInfo;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        let mut next = std::ptr::null();
        let mut extensions = self.extensions.iter();
        while let Some(ext) = extensions.next() {
            let ext = ext.into_low_level(context, bump);
            (*ext).next = next;
            next = ext;
        }
        crate::native::vulkan1_0::PipelineRasterizationStateCreateInfo {
            s_type: StructureType::PipelineRasterizationStateCreateInfo,
            p_next: next,
            flags: self.flags.into_low_level(context, bump),
            depth_clamp_enable: self.depth_clamp_enable.into_low_level(context, bump),
            rasterizer_discard_enable: self.rasterizer_discard_enable.into_low_level(context, bump),
            polygon_mode: self.polygon_mode.into_low_level(context, bump),
            cull_mode: self.cull_mode.into_low_level(context, bump),
            front_face: self.front_face.into_low_level(context, bump),
            depth_bias_enable: self.depth_bias_enable.into_low_level(context, bump),
            depth_bias_constant_factor: self.depth_bias_constant_factor.into_low_level(context, bump),
            depth_bias_clamp: self.depth_bias_clamp.into_low_level(context, bump),
            depth_bias_slope_factor: self.depth_bias_slope_factor.into_low_level(context, bump),
            line_width: self.line_width.into_low_level(context, bump),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for PipelineRasterizationStateCreateInfo {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        let mut next = value.p_next;
        let mut extensions = SmallVec::new();
        while !next.is_null() {
            extensions.push(crate::conv::FromLowLevel::from_low_level(context, next));
            next = std::ptr::read(next).next;
        }
        Self {
            extensions: extensions,
            flags: crate::conv::FromLowLevel::from_low_level(context, value.flags),
            depth_clamp_enable: crate::conv::FromLowLevel::from_low_level(context, value.depth_clamp_enable),
            rasterizer_discard_enable: crate::conv::FromLowLevel::from_low_level(
                context,
                value.rasterizer_discard_enable,
            ),
            polygon_mode: crate::conv::FromLowLevel::from_low_level(context, value.polygon_mode),
            cull_mode: crate::conv::FromLowLevel::from_low_level(context, value.cull_mode),
            front_face: crate::conv::FromLowLevel::from_low_level(context, value.front_face),
            depth_bias_enable: crate::conv::FromLowLevel::from_low_level(context, value.depth_bias_enable),
            depth_bias_constant_factor: crate::conv::FromLowLevel::from_low_level(
                context,
                value.depth_bias_constant_factor,
            ),
            depth_bias_clamp: crate::conv::FromLowLevel::from_low_level(context, value.depth_bias_clamp),
            depth_bias_slope_factor: crate::conv::FromLowLevel::from_low_level(context, value.depth_bias_slope_factor),
            line_width: crate::conv::FromLowLevel::from_low_level(context, value.line_width),
        }
    }
}
#[derive(Clone, PartialEq, Debug)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
///Extensions for [`PipelineRasterizationStateCreateInfo`]
pub enum PipelineRasterizationStateCreateInfoExtension {
    #[cfg(feature = "VK_AMD_rasterization_order")]
    ///Contains a type [`PipelineRasterizationStateRasterizationOrderAMD`] for extending
    /// [`PipelineRasterizationStateCreateInfo`]
    PipelineRasterizationStateRasterizationOrderAMD(PipelineRasterizationStateRasterizationOrderAMD),
    #[cfg(feature = "VK_EXT_conservative_rasterization")]
    ///Contains a type [`PipelineRasterizationConservativeStateCreateInfoEXT`] for extending
    /// [`PipelineRasterizationStateCreateInfo`]
    PipelineRasterizationConservativeStateCreateInfoEXT(PipelineRasterizationConservativeStateCreateInfoEXT),
    #[cfg(feature = "VK_EXT_transform_feedback")]
    ///Contains a type [`PipelineRasterizationStateStreamCreateInfoEXT`] for extending
    /// [`PipelineRasterizationStateCreateInfo`]
    PipelineRasterizationStateStreamCreateInfoEXT(PipelineRasterizationStateStreamCreateInfoEXT),
    #[cfg(feature = "VK_EXT_depth_clip_enable")]
    ///Contains a type [`PipelineRasterizationDepthClipStateCreateInfoEXT`] for extending
    /// [`PipelineRasterizationStateCreateInfo`]
    PipelineRasterizationDepthClipStateCreateInfoEXT(PipelineRasterizationDepthClipStateCreateInfoEXT),
    #[cfg(feature = "VK_EXT_line_rasterization")]
    ///Contains a type [`PipelineRasterizationLineStateCreateInfoEXT`] for extending
    /// [`PipelineRasterizationStateCreateInfo`]
    PipelineRasterizationLineStateCreateInfoEXT(PipelineRasterizationLineStateCreateInfoEXT),
    #[cfg(feature = "VK_EXT_provoking_vertex")]
    ///Contains a type [`PipelineRasterizationProvokingVertexStateCreateInfoEXT`] for extending
    /// [`PipelineRasterizationStateCreateInfo`]
    PipelineRasterizationProvokingVertexStateCreateInfoEXT(PipelineRasterizationProvokingVertexStateCreateInfoEXT),
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for PipelineRasterizationStateCreateInfoExtension {
    type LowLevel = *const crate::native::vulkan1_0::BaseInStructure;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        match self { # [cfg (feature = "VK_AMD_rasterization_order")] Self :: PipelineRasterizationStateRasterizationOrderAMD (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: amd_rasterization_order :: PipelineRasterizationStateRasterizationOrderAMD) . cast () , # [cfg (feature = "VK_EXT_conservative_rasterization")] Self :: PipelineRasterizationConservativeStateCreateInfoEXT (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: ext_conservative_rasterization :: PipelineRasterizationConservativeStateCreateInfoEXT) . cast () , # [cfg (feature = "VK_EXT_transform_feedback")] Self :: PipelineRasterizationStateStreamCreateInfoEXT (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: ext_transform_feedback :: PipelineRasterizationStateStreamCreateInfoEXT) . cast () , # [cfg (feature = "VK_EXT_depth_clip_enable")] Self :: PipelineRasterizationDepthClipStateCreateInfoEXT (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: ext_depth_clip_enable :: PipelineRasterizationDepthClipStateCreateInfoEXT) . cast () , # [cfg (feature = "VK_EXT_line_rasterization")] Self :: PipelineRasterizationLineStateCreateInfoEXT (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: ext_line_rasterization :: PipelineRasterizationLineStateCreateInfoEXT) . cast () , # [cfg (feature = "VK_EXT_provoking_vertex")] Self :: PipelineRasterizationProvokingVertexStateCreateInfoEXT (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: ext_provoking_vertex :: PipelineRasterizationProvokingVertexStateCreateInfoEXT) . cast () , other => unreachable ! ("unexpected variant {:?}" , other) }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for PipelineRasterizationStateCreateInfoExtension {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        assert!(!value.is_null());
        match (* value) . s_type { # [cfg (feature = "VK_AMD_rasterization_order")] crate :: native :: vulkan1_0 :: StructureType :: PipelineRasterizationStateRasterizationOrderAmd => Self :: PipelineRasterizationStateRasterizationOrderAMD (PipelineRasterizationStateRasterizationOrderAMD :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: amd_rasterization_order :: PipelineRasterizationStateRasterizationOrderAMD > ()))) , # [cfg (feature = "VK_EXT_conservative_rasterization")] crate :: native :: vulkan1_0 :: StructureType :: PipelineRasterizationConservativeStateCreateInfoExt => Self :: PipelineRasterizationConservativeStateCreateInfoEXT (PipelineRasterizationConservativeStateCreateInfoEXT :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: ext_conservative_rasterization :: PipelineRasterizationConservativeStateCreateInfoEXT > ()))) , # [cfg (feature = "VK_EXT_transform_feedback")] crate :: native :: vulkan1_0 :: StructureType :: PipelineRasterizationStateStreamCreateInfoExt => Self :: PipelineRasterizationStateStreamCreateInfoEXT (PipelineRasterizationStateStreamCreateInfoEXT :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: ext_transform_feedback :: PipelineRasterizationStateStreamCreateInfoEXT > ()))) , # [cfg (feature = "VK_EXT_depth_clip_enable")] crate :: native :: vulkan1_0 :: StructureType :: PipelineRasterizationDepthClipStateCreateInfoExt => Self :: PipelineRasterizationDepthClipStateCreateInfoEXT (PipelineRasterizationDepthClipStateCreateInfoEXT :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: ext_depth_clip_enable :: PipelineRasterizationDepthClipStateCreateInfoEXT > ()))) , # [cfg (feature = "VK_EXT_line_rasterization")] crate :: native :: vulkan1_0 :: StructureType :: PipelineRasterizationLineStateCreateInfoExt => Self :: PipelineRasterizationLineStateCreateInfoEXT (PipelineRasterizationLineStateCreateInfoEXT :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: ext_line_rasterization :: PipelineRasterizationLineStateCreateInfoEXT > ()))) , # [cfg (feature = "VK_EXT_provoking_vertex")] crate :: native :: vulkan1_0 :: StructureType :: PipelineRasterizationProvokingVertexStateCreateInfoExt => Self :: PipelineRasterizationProvokingVertexStateCreateInfoEXT (PipelineRasterizationProvokingVertexStateCreateInfoEXT :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: ext_provoking_vertex :: PipelineRasterizationProvokingVertexStateCreateInfoEXT > ()))) , other => panic ! ("Structure type {:?} is not a member of {}" , other , stringify ! (PipelineRasterizationStateCreateInfo)) }
    }
}
#[cfg(feature = "VK_AMD_rasterization_order")]
impl From<PipelineRasterizationStateRasterizationOrderAMD> for PipelineRasterizationStateCreateInfoExtension {
    fn from(ext: PipelineRasterizationStateRasterizationOrderAMD) -> Self {
        Self::PipelineRasterizationStateRasterizationOrderAMD(ext)
    }
}
#[cfg(feature = "VK_AMD_rasterization_order")]
impl TryInto<PipelineRasterizationStateRasterizationOrderAMD> for PipelineRasterizationStateCreateInfoExtension {
    type Error = PipelineRasterizationStateCreateInfoExtension;
    fn try_into(self) -> Result<PipelineRasterizationStateRasterizationOrderAMD, Self::Error> {
        match self {
            Self::PipelineRasterizationStateRasterizationOrderAMD(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_EXT_conservative_rasterization")]
impl From<PipelineRasterizationConservativeStateCreateInfoEXT> for PipelineRasterizationStateCreateInfoExtension {
    fn from(ext: PipelineRasterizationConservativeStateCreateInfoEXT) -> Self {
        Self::PipelineRasterizationConservativeStateCreateInfoEXT(ext)
    }
}
#[cfg(feature = "VK_EXT_conservative_rasterization")]
impl TryInto<PipelineRasterizationConservativeStateCreateInfoEXT> for PipelineRasterizationStateCreateInfoExtension {
    type Error = PipelineRasterizationStateCreateInfoExtension;
    fn try_into(self) -> Result<PipelineRasterizationConservativeStateCreateInfoEXT, Self::Error> {
        match self {
            Self::PipelineRasterizationConservativeStateCreateInfoEXT(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_EXT_transform_feedback")]
impl From<PipelineRasterizationStateStreamCreateInfoEXT> for PipelineRasterizationStateCreateInfoExtension {
    fn from(ext: PipelineRasterizationStateStreamCreateInfoEXT) -> Self {
        Self::PipelineRasterizationStateStreamCreateInfoEXT(ext)
    }
}
#[cfg(feature = "VK_EXT_transform_feedback")]
impl TryInto<PipelineRasterizationStateStreamCreateInfoEXT> for PipelineRasterizationStateCreateInfoExtension {
    type Error = PipelineRasterizationStateCreateInfoExtension;
    fn try_into(self) -> Result<PipelineRasterizationStateStreamCreateInfoEXT, Self::Error> {
        match self {
            Self::PipelineRasterizationStateStreamCreateInfoEXT(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_EXT_depth_clip_enable")]
impl From<PipelineRasterizationDepthClipStateCreateInfoEXT> for PipelineRasterizationStateCreateInfoExtension {
    fn from(ext: PipelineRasterizationDepthClipStateCreateInfoEXT) -> Self {
        Self::PipelineRasterizationDepthClipStateCreateInfoEXT(ext)
    }
}
#[cfg(feature = "VK_EXT_depth_clip_enable")]
impl TryInto<PipelineRasterizationDepthClipStateCreateInfoEXT> for PipelineRasterizationStateCreateInfoExtension {
    type Error = PipelineRasterizationStateCreateInfoExtension;
    fn try_into(self) -> Result<PipelineRasterizationDepthClipStateCreateInfoEXT, Self::Error> {
        match self {
            Self::PipelineRasterizationDepthClipStateCreateInfoEXT(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_EXT_line_rasterization")]
impl From<PipelineRasterizationLineStateCreateInfoEXT> for PipelineRasterizationStateCreateInfoExtension {
    fn from(ext: PipelineRasterizationLineStateCreateInfoEXT) -> Self {
        Self::PipelineRasterizationLineStateCreateInfoEXT(ext)
    }
}
#[cfg(feature = "VK_EXT_line_rasterization")]
impl TryInto<PipelineRasterizationLineStateCreateInfoEXT> for PipelineRasterizationStateCreateInfoExtension {
    type Error = PipelineRasterizationStateCreateInfoExtension;
    fn try_into(self) -> Result<PipelineRasterizationLineStateCreateInfoEXT, Self::Error> {
        match self {
            Self::PipelineRasterizationLineStateCreateInfoEXT(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_EXT_provoking_vertex")]
impl From<PipelineRasterizationProvokingVertexStateCreateInfoEXT> for PipelineRasterizationStateCreateInfoExtension {
    fn from(ext: PipelineRasterizationProvokingVertexStateCreateInfoEXT) -> Self {
        Self::PipelineRasterizationProvokingVertexStateCreateInfoEXT(ext)
    }
}
#[cfg(feature = "VK_EXT_provoking_vertex")]
impl TryInto<PipelineRasterizationProvokingVertexStateCreateInfoEXT> for PipelineRasterizationStateCreateInfoExtension {
    type Error = PipelineRasterizationStateCreateInfoExtension;
    fn try_into(self) -> Result<PipelineRasterizationProvokingVertexStateCreateInfoEXT, Self::Error> {
        match self {
            Self::PipelineRasterizationProvokingVertexStateCreateInfoEXT(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[doc(alias = "VkPipelineMultisampleStateCreateInfo")]
#[derive(Clone, PartialEq, Debug, Default)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct PipelineMultisampleStateCreateInfo {
    #[doc(alias = "pNext")]
    pub extensions: SmallVec<[PipelineMultisampleStateCreateInfoExtension; 1]>,
    pub flags: PipelineMultisampleStateCreateFlags,
    #[doc(alias = "rasterizationSamples")]
    pub rasterization_samples: SampleCountFlagBits,
    #[doc(alias = "sampleShadingEnable")]
    pub sample_shading_enable: bool,
    #[doc(alias = "minSampleShading")]
    pub min_sample_shading: f32,
    #[doc(alias = "pSampleMask")]
    pub sample_mask: SmallVec<[SampleMask; 8]>,
    #[doc(alias = "alphaToCoverageEnable")]
    pub alpha_to_coverage_enable: bool,
    #[doc(alias = "alphaToOneEnable")]
    pub alpha_to_one_enable: bool,
}
impl PipelineMultisampleStateCreateInfo {
    ///Adds an extension to the struct
    pub fn with_extension(mut self, ext: impl Into<PipelineMultisampleStateCreateInfoExtension>) -> Self {
        self.extensions.push(ext.into());
        self
    }
    ///Get a reference to the `extensions` field.
    pub fn extensions(&self) -> &SmallVec<[PipelineMultisampleStateCreateInfoExtension; 1]> {
        &self.extensions
    }
    ///Get a reference to the `flags` field.
    pub fn flags(&self) -> PipelineMultisampleStateCreateFlags {
        self.flags
    }
    ///Get a reference to the `rasterization_samples` field.
    pub fn rasterization_samples(&self) -> SampleCountFlagBits {
        self.rasterization_samples
    }
    ///Get a reference to the `sample_shading_enable` field.
    pub fn sample_shading_enable(&self) -> &bool {
        &self.sample_shading_enable
    }
    ///Get a reference to the `min_sample_shading` field.
    pub fn min_sample_shading(&self) -> f32 {
        self.min_sample_shading
    }
    ///Get a reference to the `sample_mask` field.
    pub fn sample_mask(&self) -> &SmallVec<[SampleMask; 8]> {
        &self.sample_mask
    }
    ///Get a reference to the `alpha_to_coverage_enable` field.
    pub fn alpha_to_coverage_enable(&self) -> &bool {
        &self.alpha_to_coverage_enable
    }
    ///Get a reference to the `alpha_to_one_enable` field.
    pub fn alpha_to_one_enable(&self) -> &bool {
        &self.alpha_to_one_enable
    }
    ///Get a mutable reference to the `extensions` field.
    pub fn extensions_mut(&mut self) -> &mut SmallVec<[PipelineMultisampleStateCreateInfoExtension; 1]> {
        &mut self.extensions
    }
    ///Get a mutable reference to the `flags` field.
    pub fn flags_mut(&mut self) -> &mut PipelineMultisampleStateCreateFlags {
        &mut self.flags
    }
    ///Get a mutable reference to the `rasterization_samples` field.
    pub fn rasterization_samples_mut(&mut self) -> &mut SampleCountFlagBits {
        &mut self.rasterization_samples
    }
    ///Get a mutable reference to the `sample_shading_enable` field.
    pub fn sample_shading_enable_mut(&mut self) -> &mut bool {
        &mut self.sample_shading_enable
    }
    ///Get a mutable reference to the `min_sample_shading` field.
    pub fn min_sample_shading_mut(&mut self) -> &mut f32 {
        &mut self.min_sample_shading
    }
    ///Get a mutable reference to the `sample_mask` field.
    pub fn sample_mask_mut(&mut self) -> &mut SmallVec<[SampleMask; 8]> {
        &mut self.sample_mask
    }
    ///Get a mutable reference to the `alpha_to_coverage_enable` field.
    pub fn alpha_to_coverage_enable_mut(&mut self) -> &mut bool {
        &mut self.alpha_to_coverage_enable
    }
    ///Get a mutable reference to the `alpha_to_one_enable` field.
    pub fn alpha_to_one_enable_mut(&mut self) -> &mut bool {
        &mut self.alpha_to_one_enable
    }
    ///Sets the `extensions` field.
    pub fn set_extensions(
        &mut self,
        extensions: SmallVec<[PipelineMultisampleStateCreateInfoExtension; 1]>,
    ) -> &mut Self {
        self.extensions = extensions;
        self
    }
    ///Sets the `flags` field.
    pub fn set_flags(&mut self, flags: PipelineMultisampleStateCreateFlags) -> &mut Self {
        self.flags = flags;
        self
    }
    ///Sets the `rasterization_samples` field.
    pub fn set_rasterization_samples(&mut self, rasterization_samples: SampleCountFlagBits) -> &mut Self {
        self.rasterization_samples = rasterization_samples;
        self
    }
    ///Sets the `sample_shading_enable` field.
    pub fn set_sample_shading_enable(&mut self, sample_shading_enable: bool) -> &mut Self {
        self.sample_shading_enable = sample_shading_enable;
        self
    }
    ///Sets the `min_sample_shading` field.
    pub fn set_min_sample_shading(&mut self, min_sample_shading: f32) -> &mut Self {
        self.min_sample_shading = min_sample_shading;
        self
    }
    ///Sets the `sample_mask` field.
    pub fn set_sample_mask(&mut self, sample_mask: SmallVec<[SampleMask; 8]>) -> &mut Self {
        self.sample_mask = sample_mask;
        self
    }
    ///Sets the `alpha_to_coverage_enable` field.
    pub fn set_alpha_to_coverage_enable(&mut self, alpha_to_coverage_enable: bool) -> &mut Self {
        self.alpha_to_coverage_enable = alpha_to_coverage_enable;
        self
    }
    ///Sets the `alpha_to_one_enable` field.
    pub fn set_alpha_to_one_enable(&mut self, alpha_to_one_enable: bool) -> &mut Self {
        self.alpha_to_one_enable = alpha_to_one_enable;
        self
    }
    ///Sets the `extensions` field in a builder way.
    pub fn with_extensions(mut self, extensions: SmallVec<[PipelineMultisampleStateCreateInfoExtension; 1]>) -> Self {
        self.extensions = extensions;
        self
    }
    ///Sets the `flags` field in a builder way.
    pub fn with_flags(mut self, flags: PipelineMultisampleStateCreateFlags) -> Self {
        self.flags = flags;
        self
    }
    ///Sets the `rasterization_samples` field in a builder way.
    pub fn with_rasterization_samples(mut self, rasterization_samples: SampleCountFlagBits) -> Self {
        self.rasterization_samples = rasterization_samples;
        self
    }
    ///Sets the `sample_shading_enable` field in a builder way.
    pub fn with_sample_shading_enable(mut self, sample_shading_enable: bool) -> Self {
        self.sample_shading_enable = sample_shading_enable;
        self
    }
    ///Sets the `min_sample_shading` field in a builder way.
    pub fn with_min_sample_shading(mut self, min_sample_shading: f32) -> Self {
        self.min_sample_shading = min_sample_shading;
        self
    }
    ///Sets the `sample_mask` field in a builder way.
    pub fn with_sample_mask(mut self, sample_mask: SmallVec<[SampleMask; 8]>) -> Self {
        self.sample_mask = sample_mask;
        self
    }
    ///Sets the `alpha_to_coverage_enable` field in a builder way.
    pub fn with_alpha_to_coverage_enable(mut self, alpha_to_coverage_enable: bool) -> Self {
        self.alpha_to_coverage_enable = alpha_to_coverage_enable;
        self
    }
    ///Sets the `alpha_to_one_enable` field in a builder way.
    pub fn with_alpha_to_one_enable(mut self, alpha_to_one_enable: bool) -> Self {
        self.alpha_to_one_enable = alpha_to_one_enable;
        self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for PipelineMultisampleStateCreateInfo {
    type LowLevel = crate::native::vulkan1_0::PipelineMultisampleStateCreateInfo;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        let mut next = std::ptr::null();
        let mut extensions = self.extensions.iter();
        while let Some(ext) = extensions.next() {
            let ext = ext.into_low_level(context, bump);
            (*ext).next = next;
            next = ext;
        }
        let sample_mask = bump
            .alloc_slice_fill_iter(self.sample_mask.iter().map(|x| x.into_low_level(context, bump)))
            .as_ptr()
            .cast();
        crate::native::vulkan1_0::PipelineMultisampleStateCreateInfo {
            s_type: StructureType::PipelineMultisampleStateCreateInfo,
            p_next: next,
            flags: self.flags.into_low_level(context, bump),
            rasterization_samples: self.rasterization_samples.into_low_level(context, bump),
            sample_shading_enable: self.sample_shading_enable.into_low_level(context, bump),
            min_sample_shading: self.min_sample_shading.into_low_level(context, bump),
            sample_mask: sample_mask,
            alpha_to_coverage_enable: self.alpha_to_coverage_enable.into_low_level(context, bump),
            alpha_to_one_enable: self.alpha_to_one_enable.into_low_level(context, bump),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for PipelineMultisampleStateCreateInfo {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        let mut next = value.p_next;
        let mut extensions = SmallVec::new();
        while !next.is_null() {
            extensions.push(crate::conv::FromLowLevel::from_low_level(context, next));
            next = std::ptr::read(next).next;
        }
        let sample_mask_len = ((value.rasterization_samples.bits()) + (31)) / (32);
        let mut sample_mask = SmallVec::with_capacity(sample_mask_len as usize);
        for i in 0..sample_mask_len {
            sample_mask.push(crate::conv::FromLowLevel::from_low_level(
                context,
                value.sample_mask.add(i as usize).read(),
            ));
        }
        Self {
            extensions: extensions,
            flags: crate::conv::FromLowLevel::from_low_level(context, value.flags),
            rasterization_samples: crate::conv::FromLowLevel::from_low_level(context, value.rasterization_samples),
            sample_shading_enable: crate::conv::FromLowLevel::from_low_level(context, value.sample_shading_enable),
            min_sample_shading: crate::conv::FromLowLevel::from_low_level(context, value.min_sample_shading),
            sample_mask: sample_mask,
            alpha_to_coverage_enable: crate::conv::FromLowLevel::from_low_level(
                context,
                value.alpha_to_coverage_enable,
            ),
            alpha_to_one_enable: crate::conv::FromLowLevel::from_low_level(context, value.alpha_to_one_enable),
        }
    }
}
#[derive(Clone, PartialEq, Debug)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
///Extensions for [`PipelineMultisampleStateCreateInfo`]
pub enum PipelineMultisampleStateCreateInfoExtension {
    #[cfg(feature = "VK_NV_fragment_coverage_to_color")]
    ///Contains a type [`PipelineCoverageToColorStateCreateInfoNV`] for extending
    /// [`PipelineMultisampleStateCreateInfo`]
    PipelineCoverageToColorStateCreateInfoNV(PipelineCoverageToColorStateCreateInfoNV),
    #[cfg(feature = "VK_EXT_sample_locations")]
    ///Contains a type [`PipelineSampleLocationsStateCreateInfoEXT`] for extending
    /// [`PipelineMultisampleStateCreateInfo`]
    PipelineSampleLocationsStateCreateInfoEXT(PipelineSampleLocationsStateCreateInfoEXT),
    #[cfg(feature = "VK_NV_framebuffer_mixed_samples")]
    ///Contains a type [`PipelineCoverageModulationStateCreateInfoNV`] for extending
    /// [`PipelineMultisampleStateCreateInfo`]
    PipelineCoverageModulationStateCreateInfoNV(PipelineCoverageModulationStateCreateInfoNV),
    #[cfg(feature = "VK_NV_coverage_reduction_mode")]
    ///Contains a type [`PipelineCoverageReductionStateCreateInfoNV`] for extending
    /// [`PipelineMultisampleStateCreateInfo`]
    PipelineCoverageReductionStateCreateInfoNV(PipelineCoverageReductionStateCreateInfoNV),
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for PipelineMultisampleStateCreateInfoExtension {
    type LowLevel = *const crate::native::vulkan1_0::BaseInStructure;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        match self { # [cfg (feature = "VK_NV_fragment_coverage_to_color")] Self :: PipelineCoverageToColorStateCreateInfoNV (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: nv_fragment_coverage_to_color :: PipelineCoverageToColorStateCreateInfoNV) . cast () , # [cfg (feature = "VK_EXT_sample_locations")] Self :: PipelineSampleLocationsStateCreateInfoEXT (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: ext_sample_locations :: PipelineSampleLocationsStateCreateInfoEXT) . cast () , # [cfg (feature = "VK_NV_framebuffer_mixed_samples")] Self :: PipelineCoverageModulationStateCreateInfoNV (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: nv_framebuffer_mixed_samples :: PipelineCoverageModulationStateCreateInfoNV) . cast () , # [cfg (feature = "VK_NV_coverage_reduction_mode")] Self :: PipelineCoverageReductionStateCreateInfoNV (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: nv_coverage_reduction_mode :: PipelineCoverageReductionStateCreateInfoNV) . cast () , other => unreachable ! ("unexpected variant {:?}" , other) }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for PipelineMultisampleStateCreateInfoExtension {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        assert!(!value.is_null());
        match (* value) . s_type { # [cfg (feature = "VK_NV_fragment_coverage_to_color")] crate :: native :: vulkan1_0 :: StructureType :: PipelineCoverageToColorStateCreateInfoNv => Self :: PipelineCoverageToColorStateCreateInfoNV (PipelineCoverageToColorStateCreateInfoNV :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: nv_fragment_coverage_to_color :: PipelineCoverageToColorStateCreateInfoNV > ()))) , # [cfg (feature = "VK_EXT_sample_locations")] crate :: native :: vulkan1_0 :: StructureType :: PipelineSampleLocationsStateCreateInfoExt => Self :: PipelineSampleLocationsStateCreateInfoEXT (PipelineSampleLocationsStateCreateInfoEXT :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: ext_sample_locations :: PipelineSampleLocationsStateCreateInfoEXT > ()))) , # [cfg (feature = "VK_NV_framebuffer_mixed_samples")] crate :: native :: vulkan1_0 :: StructureType :: PipelineCoverageModulationStateCreateInfoNv => Self :: PipelineCoverageModulationStateCreateInfoNV (PipelineCoverageModulationStateCreateInfoNV :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: nv_framebuffer_mixed_samples :: PipelineCoverageModulationStateCreateInfoNV > ()))) , # [cfg (feature = "VK_NV_coverage_reduction_mode")] crate :: native :: vulkan1_0 :: StructureType :: PipelineCoverageReductionStateCreateInfoNv => Self :: PipelineCoverageReductionStateCreateInfoNV (PipelineCoverageReductionStateCreateInfoNV :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: nv_coverage_reduction_mode :: PipelineCoverageReductionStateCreateInfoNV > ()))) , other => panic ! ("Structure type {:?} is not a member of {}" , other , stringify ! (PipelineMultisampleStateCreateInfo)) }
    }
}
#[cfg(feature = "VK_NV_fragment_coverage_to_color")]
impl From<PipelineCoverageToColorStateCreateInfoNV> for PipelineMultisampleStateCreateInfoExtension {
    fn from(ext: PipelineCoverageToColorStateCreateInfoNV) -> Self {
        Self::PipelineCoverageToColorStateCreateInfoNV(ext)
    }
}
#[cfg(feature = "VK_NV_fragment_coverage_to_color")]
impl TryInto<PipelineCoverageToColorStateCreateInfoNV> for PipelineMultisampleStateCreateInfoExtension {
    type Error = PipelineMultisampleStateCreateInfoExtension;
    fn try_into(self) -> Result<PipelineCoverageToColorStateCreateInfoNV, Self::Error> {
        match self {
            Self::PipelineCoverageToColorStateCreateInfoNV(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_EXT_sample_locations")]
impl From<PipelineSampleLocationsStateCreateInfoEXT> for PipelineMultisampleStateCreateInfoExtension {
    fn from(ext: PipelineSampleLocationsStateCreateInfoEXT) -> Self {
        Self::PipelineSampleLocationsStateCreateInfoEXT(ext)
    }
}
#[cfg(feature = "VK_EXT_sample_locations")]
impl TryInto<PipelineSampleLocationsStateCreateInfoEXT> for PipelineMultisampleStateCreateInfoExtension {
    type Error = PipelineMultisampleStateCreateInfoExtension;
    fn try_into(self) -> Result<PipelineSampleLocationsStateCreateInfoEXT, Self::Error> {
        match self {
            Self::PipelineSampleLocationsStateCreateInfoEXT(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_NV_framebuffer_mixed_samples")]
impl From<PipelineCoverageModulationStateCreateInfoNV> for PipelineMultisampleStateCreateInfoExtension {
    fn from(ext: PipelineCoverageModulationStateCreateInfoNV) -> Self {
        Self::PipelineCoverageModulationStateCreateInfoNV(ext)
    }
}
#[cfg(feature = "VK_NV_framebuffer_mixed_samples")]
impl TryInto<PipelineCoverageModulationStateCreateInfoNV> for PipelineMultisampleStateCreateInfoExtension {
    type Error = PipelineMultisampleStateCreateInfoExtension;
    fn try_into(self) -> Result<PipelineCoverageModulationStateCreateInfoNV, Self::Error> {
        match self {
            Self::PipelineCoverageModulationStateCreateInfoNV(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_NV_coverage_reduction_mode")]
impl From<PipelineCoverageReductionStateCreateInfoNV> for PipelineMultisampleStateCreateInfoExtension {
    fn from(ext: PipelineCoverageReductionStateCreateInfoNV) -> Self {
        Self::PipelineCoverageReductionStateCreateInfoNV(ext)
    }
}
#[cfg(feature = "VK_NV_coverage_reduction_mode")]
impl TryInto<PipelineCoverageReductionStateCreateInfoNV> for PipelineMultisampleStateCreateInfoExtension {
    type Error = PipelineMultisampleStateCreateInfoExtension;
    fn try_into(self) -> Result<PipelineCoverageReductionStateCreateInfoNV, Self::Error> {
        match self {
            Self::PipelineCoverageReductionStateCreateInfoNV(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[doc(alias = "VkPipelineColorBlendAttachmentState")]
#[derive(Clone, PartialEq, Debug, Default)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct PipelineColorBlendAttachmentState {
    #[doc(alias = "blendEnable")]
    pub blend_enable: bool,
    #[doc(alias = "srcColorBlendFactor")]
    pub src_color_blend_factor: BlendFactor,
    #[doc(alias = "dstColorBlendFactor")]
    pub dst_color_blend_factor: BlendFactor,
    #[doc(alias = "colorBlendOp")]
    pub color_blend_op: BlendOp,
    #[doc(alias = "srcAlphaBlendFactor")]
    pub src_alpha_blend_factor: BlendFactor,
    #[doc(alias = "dstAlphaBlendFactor")]
    pub dst_alpha_blend_factor: BlendFactor,
    #[doc(alias = "alphaBlendOp")]
    pub alpha_blend_op: BlendOp,
    #[doc(alias = "colorWriteMask")]
    pub color_write_mask: ColorComponentFlags,
}
impl PipelineColorBlendAttachmentState {
    ///Get a reference to the `blend_enable` field.
    pub fn blend_enable(&self) -> &bool {
        &self.blend_enable
    }
    ///Get a reference to the `src_color_blend_factor` field.
    pub fn src_color_blend_factor(&self) -> BlendFactor {
        self.src_color_blend_factor
    }
    ///Get a reference to the `dst_color_blend_factor` field.
    pub fn dst_color_blend_factor(&self) -> BlendFactor {
        self.dst_color_blend_factor
    }
    ///Get a reference to the `color_blend_op` field.
    pub fn color_blend_op(&self) -> BlendOp {
        self.color_blend_op
    }
    ///Get a reference to the `src_alpha_blend_factor` field.
    pub fn src_alpha_blend_factor(&self) -> BlendFactor {
        self.src_alpha_blend_factor
    }
    ///Get a reference to the `dst_alpha_blend_factor` field.
    pub fn dst_alpha_blend_factor(&self) -> BlendFactor {
        self.dst_alpha_blend_factor
    }
    ///Get a reference to the `alpha_blend_op` field.
    pub fn alpha_blend_op(&self) -> BlendOp {
        self.alpha_blend_op
    }
    ///Get a reference to the `color_write_mask` field.
    pub fn color_write_mask(&self) -> ColorComponentFlags {
        self.color_write_mask
    }
    ///Get a mutable reference to the `blend_enable` field.
    pub fn blend_enable_mut(&mut self) -> &mut bool {
        &mut self.blend_enable
    }
    ///Get a mutable reference to the `src_color_blend_factor` field.
    pub fn src_color_blend_factor_mut(&mut self) -> &mut BlendFactor {
        &mut self.src_color_blend_factor
    }
    ///Get a mutable reference to the `dst_color_blend_factor` field.
    pub fn dst_color_blend_factor_mut(&mut self) -> &mut BlendFactor {
        &mut self.dst_color_blend_factor
    }
    ///Get a mutable reference to the `color_blend_op` field.
    pub fn color_blend_op_mut(&mut self) -> &mut BlendOp {
        &mut self.color_blend_op
    }
    ///Get a mutable reference to the `src_alpha_blend_factor` field.
    pub fn src_alpha_blend_factor_mut(&mut self) -> &mut BlendFactor {
        &mut self.src_alpha_blend_factor
    }
    ///Get a mutable reference to the `dst_alpha_blend_factor` field.
    pub fn dst_alpha_blend_factor_mut(&mut self) -> &mut BlendFactor {
        &mut self.dst_alpha_blend_factor
    }
    ///Get a mutable reference to the `alpha_blend_op` field.
    pub fn alpha_blend_op_mut(&mut self) -> &mut BlendOp {
        &mut self.alpha_blend_op
    }
    ///Get a mutable reference to the `color_write_mask` field.
    pub fn color_write_mask_mut(&mut self) -> &mut ColorComponentFlags {
        &mut self.color_write_mask
    }
    ///Sets the `blend_enable` field.
    pub fn set_blend_enable(&mut self, blend_enable: bool) -> &mut Self {
        self.blend_enable = blend_enable;
        self
    }
    ///Sets the `src_color_blend_factor` field.
    pub fn set_src_color_blend_factor(&mut self, src_color_blend_factor: BlendFactor) -> &mut Self {
        self.src_color_blend_factor = src_color_blend_factor;
        self
    }
    ///Sets the `dst_color_blend_factor` field.
    pub fn set_dst_color_blend_factor(&mut self, dst_color_blend_factor: BlendFactor) -> &mut Self {
        self.dst_color_blend_factor = dst_color_blend_factor;
        self
    }
    ///Sets the `color_blend_op` field.
    pub fn set_color_blend_op(&mut self, color_blend_op: BlendOp) -> &mut Self {
        self.color_blend_op = color_blend_op;
        self
    }
    ///Sets the `src_alpha_blend_factor` field.
    pub fn set_src_alpha_blend_factor(&mut self, src_alpha_blend_factor: BlendFactor) -> &mut Self {
        self.src_alpha_blend_factor = src_alpha_blend_factor;
        self
    }
    ///Sets the `dst_alpha_blend_factor` field.
    pub fn set_dst_alpha_blend_factor(&mut self, dst_alpha_blend_factor: BlendFactor) -> &mut Self {
        self.dst_alpha_blend_factor = dst_alpha_blend_factor;
        self
    }
    ///Sets the `alpha_blend_op` field.
    pub fn set_alpha_blend_op(&mut self, alpha_blend_op: BlendOp) -> &mut Self {
        self.alpha_blend_op = alpha_blend_op;
        self
    }
    ///Sets the `color_write_mask` field.
    pub fn set_color_write_mask(&mut self, color_write_mask: ColorComponentFlags) -> &mut Self {
        self.color_write_mask = color_write_mask;
        self
    }
    ///Sets the `blend_enable` field in a builder way.
    pub fn with_blend_enable(mut self, blend_enable: bool) -> Self {
        self.blend_enable = blend_enable;
        self
    }
    ///Sets the `src_color_blend_factor` field in a builder way.
    pub fn with_src_color_blend_factor(mut self, src_color_blend_factor: BlendFactor) -> Self {
        self.src_color_blend_factor = src_color_blend_factor;
        self
    }
    ///Sets the `dst_color_blend_factor` field in a builder way.
    pub fn with_dst_color_blend_factor(mut self, dst_color_blend_factor: BlendFactor) -> Self {
        self.dst_color_blend_factor = dst_color_blend_factor;
        self
    }
    ///Sets the `color_blend_op` field in a builder way.
    pub fn with_color_blend_op(mut self, color_blend_op: BlendOp) -> Self {
        self.color_blend_op = color_blend_op;
        self
    }
    ///Sets the `src_alpha_blend_factor` field in a builder way.
    pub fn with_src_alpha_blend_factor(mut self, src_alpha_blend_factor: BlendFactor) -> Self {
        self.src_alpha_blend_factor = src_alpha_blend_factor;
        self
    }
    ///Sets the `dst_alpha_blend_factor` field in a builder way.
    pub fn with_dst_alpha_blend_factor(mut self, dst_alpha_blend_factor: BlendFactor) -> Self {
        self.dst_alpha_blend_factor = dst_alpha_blend_factor;
        self
    }
    ///Sets the `alpha_blend_op` field in a builder way.
    pub fn with_alpha_blend_op(mut self, alpha_blend_op: BlendOp) -> Self {
        self.alpha_blend_op = alpha_blend_op;
        self
    }
    ///Sets the `color_write_mask` field in a builder way.
    pub fn with_color_write_mask(mut self, color_write_mask: ColorComponentFlags) -> Self {
        self.color_write_mask = color_write_mask;
        self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for PipelineColorBlendAttachmentState {
    type LowLevel = crate::native::vulkan1_0::PipelineColorBlendAttachmentState;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        crate::native::vulkan1_0::PipelineColorBlendAttachmentState {
            blend_enable: self.blend_enable.into_low_level(context, bump),
            src_color_blend_factor: self.src_color_blend_factor.into_low_level(context, bump),
            dst_color_blend_factor: self.dst_color_blend_factor.into_low_level(context, bump),
            color_blend_op: self.color_blend_op.into_low_level(context, bump),
            src_alpha_blend_factor: self.src_alpha_blend_factor.into_low_level(context, bump),
            dst_alpha_blend_factor: self.dst_alpha_blend_factor.into_low_level(context, bump),
            alpha_blend_op: self.alpha_blend_op.into_low_level(context, bump),
            color_write_mask: self.color_write_mask.into_low_level(context, bump),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for PipelineColorBlendAttachmentState {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        Self {
            blend_enable: crate::conv::FromLowLevel::from_low_level(context, value.blend_enable),
            src_color_blend_factor: crate::conv::FromLowLevel::from_low_level(context, value.src_color_blend_factor),
            dst_color_blend_factor: crate::conv::FromLowLevel::from_low_level(context, value.dst_color_blend_factor),
            color_blend_op: crate::conv::FromLowLevel::from_low_level(context, value.color_blend_op),
            src_alpha_blend_factor: crate::conv::FromLowLevel::from_low_level(context, value.src_alpha_blend_factor),
            dst_alpha_blend_factor: crate::conv::FromLowLevel::from_low_level(context, value.dst_alpha_blend_factor),
            alpha_blend_op: crate::conv::FromLowLevel::from_low_level(context, value.alpha_blend_op),
            color_write_mask: crate::conv::FromLowLevel::from_low_level(context, value.color_write_mask),
        }
    }
}
#[doc(alias = "VkPipelineColorBlendStateCreateInfo")]
#[derive(Clone, PartialEq, Debug, Default)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct PipelineColorBlendStateCreateInfo {
    #[doc(alias = "pNext")]
    pub extensions: SmallVec<[PipelineColorBlendStateCreateInfoExtension; 1]>,
    pub flags: PipelineColorBlendStateCreateFlags,
    #[doc(alias = "logicOpEnable")]
    pub logic_op_enable: bool,
    #[doc(alias = "logicOp")]
    pub logic_op: LogicOp,
    #[doc(alias = "pAttachments")]
    pub attachments: SmallVec<[PipelineColorBlendAttachmentState; 8]>,
    #[doc(alias = "blendConstants")]
    pub blend_constants: [f32; 4 as usize],
}
impl PipelineColorBlendStateCreateInfo {
    ///Adds an extension to the struct
    pub fn with_extension(mut self, ext: impl Into<PipelineColorBlendStateCreateInfoExtension>) -> Self {
        self.extensions.push(ext.into());
        self
    }
    ///Get a reference to the `extensions` field.
    pub fn extensions(&self) -> &SmallVec<[PipelineColorBlendStateCreateInfoExtension; 1]> {
        &self.extensions
    }
    ///Get a reference to the `flags` field.
    pub fn flags(&self) -> PipelineColorBlendStateCreateFlags {
        self.flags
    }
    ///Get a reference to the `logic_op_enable` field.
    pub fn logic_op_enable(&self) -> &bool {
        &self.logic_op_enable
    }
    ///Get a reference to the `logic_op` field.
    pub fn logic_op(&self) -> LogicOp {
        self.logic_op
    }
    ///Get a reference to the `attachments` field.
    pub fn attachments(&self) -> &SmallVec<[PipelineColorBlendAttachmentState; 8]> {
        &self.attachments
    }
    ///Get a reference to the `blend_constants` field.
    pub fn blend_constants(&self) -> [f32; 4 as usize] {
        self.blend_constants
    }
    ///Get a mutable reference to the `extensions` field.
    pub fn extensions_mut(&mut self) -> &mut SmallVec<[PipelineColorBlendStateCreateInfoExtension; 1]> {
        &mut self.extensions
    }
    ///Get a mutable reference to the `flags` field.
    pub fn flags_mut(&mut self) -> &mut PipelineColorBlendStateCreateFlags {
        &mut self.flags
    }
    ///Get a mutable reference to the `logic_op_enable` field.
    pub fn logic_op_enable_mut(&mut self) -> &mut bool {
        &mut self.logic_op_enable
    }
    ///Get a mutable reference to the `logic_op` field.
    pub fn logic_op_mut(&mut self) -> &mut LogicOp {
        &mut self.logic_op
    }
    ///Get a mutable reference to the `attachments` field.
    pub fn attachments_mut(&mut self) -> &mut SmallVec<[PipelineColorBlendAttachmentState; 8]> {
        &mut self.attachments
    }
    ///Get a mutable reference to the `blend_constants` field.
    pub fn blend_constants_mut(&mut self) -> &mut [f32; 4 as usize] {
        &mut self.blend_constants
    }
    ///Sets the `extensions` field.
    pub fn set_extensions(
        &mut self,
        extensions: SmallVec<[PipelineColorBlendStateCreateInfoExtension; 1]>,
    ) -> &mut Self {
        self.extensions = extensions;
        self
    }
    ///Sets the `flags` field.
    pub fn set_flags(&mut self, flags: PipelineColorBlendStateCreateFlags) -> &mut Self {
        self.flags = flags;
        self
    }
    ///Sets the `logic_op_enable` field.
    pub fn set_logic_op_enable(&mut self, logic_op_enable: bool) -> &mut Self {
        self.logic_op_enable = logic_op_enable;
        self
    }
    ///Sets the `logic_op` field.
    pub fn set_logic_op(&mut self, logic_op: LogicOp) -> &mut Self {
        self.logic_op = logic_op;
        self
    }
    ///Sets the `attachments` field.
    pub fn set_attachments(&mut self, attachments: SmallVec<[PipelineColorBlendAttachmentState; 8]>) -> &mut Self {
        self.attachments = attachments;
        self
    }
    ///Sets the `blend_constants` field.
    pub fn set_blend_constants(&mut self, blend_constants: [f32; 4 as usize]) -> &mut Self {
        self.blend_constants = blend_constants;
        self
    }
    ///Sets the `extensions` field in a builder way.
    pub fn with_extensions(mut self, extensions: SmallVec<[PipelineColorBlendStateCreateInfoExtension; 1]>) -> Self {
        self.extensions = extensions;
        self
    }
    ///Sets the `flags` field in a builder way.
    pub fn with_flags(mut self, flags: PipelineColorBlendStateCreateFlags) -> Self {
        self.flags = flags;
        self
    }
    ///Sets the `logic_op_enable` field in a builder way.
    pub fn with_logic_op_enable(mut self, logic_op_enable: bool) -> Self {
        self.logic_op_enable = logic_op_enable;
        self
    }
    ///Sets the `logic_op` field in a builder way.
    pub fn with_logic_op(mut self, logic_op: LogicOp) -> Self {
        self.logic_op = logic_op;
        self
    }
    ///Sets the `attachments` field in a builder way.
    pub fn with_attachments(mut self, attachments: SmallVec<[PipelineColorBlendAttachmentState; 8]>) -> Self {
        self.attachments = attachments;
        self
    }
    ///Sets the `blend_constants` field in a builder way.
    pub fn with_blend_constants(mut self, blend_constants: [f32; 4 as usize]) -> Self {
        self.blend_constants = blend_constants;
        self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for PipelineColorBlendStateCreateInfo {
    type LowLevel = crate::native::vulkan1_0::PipelineColorBlendStateCreateInfo;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        let mut next = std::ptr::null();
        let mut extensions = self.extensions.iter();
        while let Some(ext) = extensions.next() {
            let ext = ext.into_low_level(context, bump);
            (*ext).next = next;
            next = ext;
        }
        let len_attachments = self.attachments.len() as u32;
        let attachments = bump
            .alloc_slice_fill_iter(self.attachments.iter().map(|x| x.into_low_level(context, bump)))
            .as_ptr()
            .cast();
        crate::native::vulkan1_0::PipelineColorBlendStateCreateInfo {
            s_type: StructureType::PipelineColorBlendStateCreateInfo,
            p_next: next,
            flags: self.flags.into_low_level(context, bump),
            logic_op_enable: self.logic_op_enable.into_low_level(context, bump),
            logic_op: self.logic_op.into_low_level(context, bump),
            attachment_count: len_attachments,
            attachments: attachments,
            blend_constants: self.blend_constants.into_low_level(context, bump),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for PipelineColorBlendStateCreateInfo {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        let mut next = value.p_next;
        let mut extensions = SmallVec::new();
        while !next.is_null() {
            extensions.push(crate::conv::FromLowLevel::from_low_level(context, next));
            next = std::ptr::read(next).next;
        }
        let attachments_len = value.attachment_count;
        let mut attachments = SmallVec::with_capacity(attachments_len as usize);
        for i in 0..attachments_len {
            attachments.push(crate::conv::FromLowLevel::from_low_level(
                context,
                value.attachments.add(i as usize).read(),
            ));
        }
        Self {
            extensions: extensions,
            flags: crate::conv::FromLowLevel::from_low_level(context, value.flags),
            logic_op_enable: crate::conv::FromLowLevel::from_low_level(context, value.logic_op_enable),
            logic_op: crate::conv::FromLowLevel::from_low_level(context, value.logic_op),
            attachments: attachments,
            blend_constants: crate::conv::FromLowLevel::from_low_level(context, value.blend_constants),
        }
    }
}
#[derive(Clone, PartialEq, Debug)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
///Extensions for [`PipelineColorBlendStateCreateInfo`]
pub enum PipelineColorBlendStateCreateInfoExtension {
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    ///Contains a type [`PipelineColorBlendAdvancedStateCreateInfoEXT`] for extending
    /// [`PipelineColorBlendStateCreateInfo`]
    PipelineColorBlendAdvancedStateCreateInfoEXT(PipelineColorBlendAdvancedStateCreateInfoEXT),
    #[cfg(feature = "VK_EXT_color_write_enable")]
    ///Contains a type [`PipelineColorWriteCreateInfoEXT`] for extending
    /// [`PipelineColorBlendStateCreateInfo`]
    PipelineColorWriteCreateInfoEXT(PipelineColorWriteCreateInfoEXT),
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for PipelineColorBlendStateCreateInfoExtension {
    type LowLevel = *const crate::native::vulkan1_0::BaseInStructure;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        match self { # [cfg (feature = "VK_EXT_blend_operation_advanced")] Self :: PipelineColorBlendAdvancedStateCreateInfoEXT (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: ext_blend_operation_advanced :: PipelineColorBlendAdvancedStateCreateInfoEXT) . cast () , # [cfg (feature = "VK_EXT_color_write_enable")] Self :: PipelineColorWriteCreateInfoEXT (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: ext_color_write_enable :: PipelineColorWriteCreateInfoEXT) . cast () , other => unreachable ! ("unexpected variant {:?}" , other) }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for PipelineColorBlendStateCreateInfoExtension {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        assert!(!value.is_null());
        match (* value) . s_type { # [cfg (feature = "VK_EXT_blend_operation_advanced")] crate :: native :: vulkan1_0 :: StructureType :: PipelineColorBlendAdvancedStateCreateInfoExt => Self :: PipelineColorBlendAdvancedStateCreateInfoEXT (PipelineColorBlendAdvancedStateCreateInfoEXT :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: ext_blend_operation_advanced :: PipelineColorBlendAdvancedStateCreateInfoEXT > ()))) , # [cfg (feature = "VK_EXT_color_write_enable")] crate :: native :: vulkan1_0 :: StructureType :: PipelineColorWriteCreateInfoExt => Self :: PipelineColorWriteCreateInfoEXT (PipelineColorWriteCreateInfoEXT :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: ext_color_write_enable :: PipelineColorWriteCreateInfoEXT > ()))) , other => panic ! ("Structure type {:?} is not a member of {}" , other , stringify ! (PipelineColorBlendStateCreateInfo)) }
    }
}
#[cfg(feature = "VK_EXT_blend_operation_advanced")]
impl From<PipelineColorBlendAdvancedStateCreateInfoEXT> for PipelineColorBlendStateCreateInfoExtension {
    fn from(ext: PipelineColorBlendAdvancedStateCreateInfoEXT) -> Self {
        Self::PipelineColorBlendAdvancedStateCreateInfoEXT(ext)
    }
}
#[cfg(feature = "VK_EXT_blend_operation_advanced")]
impl TryInto<PipelineColorBlendAdvancedStateCreateInfoEXT> for PipelineColorBlendStateCreateInfoExtension {
    type Error = PipelineColorBlendStateCreateInfoExtension;
    fn try_into(self) -> Result<PipelineColorBlendAdvancedStateCreateInfoEXT, Self::Error> {
        match self {
            Self::PipelineColorBlendAdvancedStateCreateInfoEXT(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_EXT_color_write_enable")]
impl From<PipelineColorWriteCreateInfoEXT> for PipelineColorBlendStateCreateInfoExtension {
    fn from(ext: PipelineColorWriteCreateInfoEXT) -> Self {
        Self::PipelineColorWriteCreateInfoEXT(ext)
    }
}
#[cfg(feature = "VK_EXT_color_write_enable")]
impl TryInto<PipelineColorWriteCreateInfoEXT> for PipelineColorBlendStateCreateInfoExtension {
    type Error = PipelineColorBlendStateCreateInfoExtension;
    fn try_into(self) -> Result<PipelineColorWriteCreateInfoEXT, Self::Error> {
        match self {
            Self::PipelineColorWriteCreateInfoEXT(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[doc(alias = "VkPipelineDynamicStateCreateInfo")]
#[derive(Clone, PartialEq, Debug, Default)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct PipelineDynamicStateCreateInfo {
    pub flags: PipelineDynamicStateCreateFlags,
    #[doc(alias = "pDynamicStates")]
    pub dynamic_states: SmallVec<[DynamicState; 8]>,
}
impl PipelineDynamicStateCreateInfo {
    ///Get a reference to the `flags` field.
    pub fn flags(&self) -> PipelineDynamicStateCreateFlags {
        self.flags
    }
    ///Get a reference to the `dynamic_states` field.
    pub fn dynamic_states(&self) -> &SmallVec<[DynamicState; 8]> {
        &self.dynamic_states
    }
    ///Get a mutable reference to the `flags` field.
    pub fn flags_mut(&mut self) -> &mut PipelineDynamicStateCreateFlags {
        &mut self.flags
    }
    ///Get a mutable reference to the `dynamic_states` field.
    pub fn dynamic_states_mut(&mut self) -> &mut SmallVec<[DynamicState; 8]> {
        &mut self.dynamic_states
    }
    ///Sets the `flags` field.
    pub fn set_flags(&mut self, flags: PipelineDynamicStateCreateFlags) -> &mut Self {
        self.flags = flags;
        self
    }
    ///Sets the `dynamic_states` field.
    pub fn set_dynamic_states(&mut self, dynamic_states: SmallVec<[DynamicState; 8]>) -> &mut Self {
        self.dynamic_states = dynamic_states;
        self
    }
    ///Sets the `flags` field in a builder way.
    pub fn with_flags(mut self, flags: PipelineDynamicStateCreateFlags) -> Self {
        self.flags = flags;
        self
    }
    ///Sets the `dynamic_states` field in a builder way.
    pub fn with_dynamic_states(mut self, dynamic_states: SmallVec<[DynamicState; 8]>) -> Self {
        self.dynamic_states = dynamic_states;
        self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for PipelineDynamicStateCreateInfo {
    type LowLevel = crate::native::vulkan1_0::PipelineDynamicStateCreateInfo;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        let len_dynamic_states = self.dynamic_states.len() as u32;
        let dynamic_states = bump
            .alloc_slice_fill_iter(self.dynamic_states.iter().map(|x| x.into_low_level(context, bump)))
            .as_ptr()
            .cast();
        crate::native::vulkan1_0::PipelineDynamicStateCreateInfo {
            s_type: StructureType::PipelineDynamicStateCreateInfo,
            p_next: std::ptr::null(),
            flags: self.flags.into_low_level(context, bump),
            dynamic_state_count: len_dynamic_states,
            dynamic_states: dynamic_states,
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for PipelineDynamicStateCreateInfo {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        let dynamic_states_len = value.dynamic_state_count;
        let mut dynamic_states = SmallVec::with_capacity(dynamic_states_len as usize);
        for i in 0..dynamic_states_len {
            dynamic_states.push(crate::conv::FromLowLevel::from_low_level(
                context,
                value.dynamic_states.add(i as usize).read(),
            ));
        }
        Self {
            flags: crate::conv::FromLowLevel::from_low_level(context, value.flags),
            dynamic_states: dynamic_states,
        }
    }
}
impl StencilOpState {
    ///Get a reference to the `fail_op` field.
    pub fn fail_op(&self) -> StencilOp {
        self.fail_op
    }
    ///Get a reference to the `pass_op` field.
    pub fn pass_op(&self) -> StencilOp {
        self.pass_op
    }
    ///Get a reference to the `depth_fail_op` field.
    pub fn depth_fail_op(&self) -> StencilOp {
        self.depth_fail_op
    }
    ///Get a reference to the `compare_op` field.
    pub fn compare_op(&self) -> CompareOp {
        self.compare_op
    }
    ///Get a reference to the `compare_mask` field.
    pub fn compare_mask(&self) -> u32 {
        self.compare_mask
    }
    ///Get a reference to the `write_mask` field.
    pub fn write_mask(&self) -> u32 {
        self.write_mask
    }
    ///Get a reference to the `reference` field.
    pub fn reference(&self) -> u32 {
        self.reference
    }
    ///Get a mutable reference to the `fail_op` field.
    pub fn fail_op_mut(&mut self) -> &mut StencilOp {
        &mut self.fail_op
    }
    ///Get a mutable reference to the `pass_op` field.
    pub fn pass_op_mut(&mut self) -> &mut StencilOp {
        &mut self.pass_op
    }
    ///Get a mutable reference to the `depth_fail_op` field.
    pub fn depth_fail_op_mut(&mut self) -> &mut StencilOp {
        &mut self.depth_fail_op
    }
    ///Get a mutable reference to the `compare_op` field.
    pub fn compare_op_mut(&mut self) -> &mut CompareOp {
        &mut self.compare_op
    }
    ///Get a mutable reference to the `compare_mask` field.
    pub fn compare_mask_mut(&mut self) -> &mut u32 {
        &mut self.compare_mask
    }
    ///Get a mutable reference to the `write_mask` field.
    pub fn write_mask_mut(&mut self) -> &mut u32 {
        &mut self.write_mask
    }
    ///Get a mutable reference to the `reference` field.
    pub fn reference_mut(&mut self) -> &mut u32 {
        &mut self.reference
    }
    ///Sets the `fail_op` field.
    pub fn set_fail_op(&mut self, fail_op: StencilOp) -> &mut Self {
        self.fail_op = fail_op;
        self
    }
    ///Sets the `pass_op` field.
    pub fn set_pass_op(&mut self, pass_op: StencilOp) -> &mut Self {
        self.pass_op = pass_op;
        self
    }
    ///Sets the `depth_fail_op` field.
    pub fn set_depth_fail_op(&mut self, depth_fail_op: StencilOp) -> &mut Self {
        self.depth_fail_op = depth_fail_op;
        self
    }
    ///Sets the `compare_op` field.
    pub fn set_compare_op(&mut self, compare_op: CompareOp) -> &mut Self {
        self.compare_op = compare_op;
        self
    }
    ///Sets the `compare_mask` field.
    pub fn set_compare_mask(&mut self, compare_mask: u32) -> &mut Self {
        self.compare_mask = compare_mask;
        self
    }
    ///Sets the `write_mask` field.
    pub fn set_write_mask(&mut self, write_mask: u32) -> &mut Self {
        self.write_mask = write_mask;
        self
    }
    ///Sets the `reference` field.
    pub fn set_reference(&mut self, reference: u32) -> &mut Self {
        self.reference = reference;
        self
    }
    ///Sets the `fail_op` field in a builder way.
    pub fn with_fail_op(mut self, fail_op: StencilOp) -> Self {
        self.fail_op = fail_op;
        self
    }
    ///Sets the `pass_op` field in a builder way.
    pub fn with_pass_op(mut self, pass_op: StencilOp) -> Self {
        self.pass_op = pass_op;
        self
    }
    ///Sets the `depth_fail_op` field in a builder way.
    pub fn with_depth_fail_op(mut self, depth_fail_op: StencilOp) -> Self {
        self.depth_fail_op = depth_fail_op;
        self
    }
    ///Sets the `compare_op` field in a builder way.
    pub fn with_compare_op(mut self, compare_op: CompareOp) -> Self {
        self.compare_op = compare_op;
        self
    }
    ///Sets the `compare_mask` field in a builder way.
    pub fn with_compare_mask(mut self, compare_mask: u32) -> Self {
        self.compare_mask = compare_mask;
        self
    }
    ///Sets the `write_mask` field in a builder way.
    pub fn with_write_mask(mut self, write_mask: u32) -> Self {
        self.write_mask = write_mask;
        self
    }
    ///Sets the `reference` field in a builder way.
    pub fn with_reference(mut self, reference: u32) -> Self {
        self.reference = reference;
        self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for StencilOpState {
    type LowLevel = crate::native::vulkan1_0::StencilOpState;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        crate::native::vulkan1_0::StencilOpState {
            fail_op: self.fail_op.into_low_level(context, bump),
            pass_op: self.pass_op.into_low_level(context, bump),
            depth_fail_op: self.depth_fail_op.into_low_level(context, bump),
            compare_op: self.compare_op.into_low_level(context, bump),
            compare_mask: self.compare_mask.into_low_level(context, bump),
            write_mask: self.write_mask.into_low_level(context, bump),
            reference: self.reference.into_low_level(context, bump),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for StencilOpState {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        Self {
            fail_op: crate::conv::FromLowLevel::from_low_level(context, value.fail_op),
            pass_op: crate::conv::FromLowLevel::from_low_level(context, value.pass_op),
            depth_fail_op: crate::conv::FromLowLevel::from_low_level(context, value.depth_fail_op),
            compare_op: crate::conv::FromLowLevel::from_low_level(context, value.compare_op),
            compare_mask: crate::conv::FromLowLevel::from_low_level(context, value.compare_mask),
            write_mask: crate::conv::FromLowLevel::from_low_level(context, value.write_mask),
            reference: crate::conv::FromLowLevel::from_low_level(context, value.reference),
        }
    }
}
#[doc(alias = "VkPipelineDepthStencilStateCreateInfo")]
#[derive(Clone, PartialEq, Debug, Default)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct PipelineDepthStencilStateCreateInfo {
    pub flags: PipelineDepthStencilStateCreateFlags,
    #[doc(alias = "depthTestEnable")]
    pub depth_test_enable: bool,
    #[doc(alias = "depthWriteEnable")]
    pub depth_write_enable: bool,
    #[doc(alias = "depthCompareOp")]
    pub depth_compare_op: CompareOp,
    #[doc(alias = "depthBoundsTestEnable")]
    pub depth_bounds_test_enable: bool,
    #[doc(alias = "stencilTestEnable")]
    pub stencil_test_enable: bool,
    pub front: StencilOpState,
    pub back: StencilOpState,
    #[doc(alias = "minDepthBounds")]
    pub min_depth_bounds: f32,
    #[doc(alias = "maxDepthBounds")]
    pub max_depth_bounds: f32,
}
impl PipelineDepthStencilStateCreateInfo {
    ///Get a reference to the `flags` field.
    pub fn flags(&self) -> PipelineDepthStencilStateCreateFlags {
        self.flags
    }
    ///Get a reference to the `depth_test_enable` field.
    pub fn depth_test_enable(&self) -> &bool {
        &self.depth_test_enable
    }
    ///Get a reference to the `depth_write_enable` field.
    pub fn depth_write_enable(&self) -> &bool {
        &self.depth_write_enable
    }
    ///Get a reference to the `depth_compare_op` field.
    pub fn depth_compare_op(&self) -> CompareOp {
        self.depth_compare_op
    }
    ///Get a reference to the `depth_bounds_test_enable` field.
    pub fn depth_bounds_test_enable(&self) -> &bool {
        &self.depth_bounds_test_enable
    }
    ///Get a reference to the `stencil_test_enable` field.
    pub fn stencil_test_enable(&self) -> &bool {
        &self.stencil_test_enable
    }
    ///Get a reference to the `front` field.
    pub fn front(&self) -> StencilOpState {
        self.front
    }
    ///Get a reference to the `back` field.
    pub fn back(&self) -> StencilOpState {
        self.back
    }
    ///Get a reference to the `min_depth_bounds` field.
    pub fn min_depth_bounds(&self) -> f32 {
        self.min_depth_bounds
    }
    ///Get a reference to the `max_depth_bounds` field.
    pub fn max_depth_bounds(&self) -> f32 {
        self.max_depth_bounds
    }
    ///Get a mutable reference to the `flags` field.
    pub fn flags_mut(&mut self) -> &mut PipelineDepthStencilStateCreateFlags {
        &mut self.flags
    }
    ///Get a mutable reference to the `depth_test_enable` field.
    pub fn depth_test_enable_mut(&mut self) -> &mut bool {
        &mut self.depth_test_enable
    }
    ///Get a mutable reference to the `depth_write_enable` field.
    pub fn depth_write_enable_mut(&mut self) -> &mut bool {
        &mut self.depth_write_enable
    }
    ///Get a mutable reference to the `depth_compare_op` field.
    pub fn depth_compare_op_mut(&mut self) -> &mut CompareOp {
        &mut self.depth_compare_op
    }
    ///Get a mutable reference to the `depth_bounds_test_enable` field.
    pub fn depth_bounds_test_enable_mut(&mut self) -> &mut bool {
        &mut self.depth_bounds_test_enable
    }
    ///Get a mutable reference to the `stencil_test_enable` field.
    pub fn stencil_test_enable_mut(&mut self) -> &mut bool {
        &mut self.stencil_test_enable
    }
    ///Get a mutable reference to the `front` field.
    pub fn front_mut(&mut self) -> &mut StencilOpState {
        &mut self.front
    }
    ///Get a mutable reference to the `back` field.
    pub fn back_mut(&mut self) -> &mut StencilOpState {
        &mut self.back
    }
    ///Get a mutable reference to the `min_depth_bounds` field.
    pub fn min_depth_bounds_mut(&mut self) -> &mut f32 {
        &mut self.min_depth_bounds
    }
    ///Get a mutable reference to the `max_depth_bounds` field.
    pub fn max_depth_bounds_mut(&mut self) -> &mut f32 {
        &mut self.max_depth_bounds
    }
    ///Sets the `flags` field.
    pub fn set_flags(&mut self, flags: PipelineDepthStencilStateCreateFlags) -> &mut Self {
        self.flags = flags;
        self
    }
    ///Sets the `depth_test_enable` field.
    pub fn set_depth_test_enable(&mut self, depth_test_enable: bool) -> &mut Self {
        self.depth_test_enable = depth_test_enable;
        self
    }
    ///Sets the `depth_write_enable` field.
    pub fn set_depth_write_enable(&mut self, depth_write_enable: bool) -> &mut Self {
        self.depth_write_enable = depth_write_enable;
        self
    }
    ///Sets the `depth_compare_op` field.
    pub fn set_depth_compare_op(&mut self, depth_compare_op: CompareOp) -> &mut Self {
        self.depth_compare_op = depth_compare_op;
        self
    }
    ///Sets the `depth_bounds_test_enable` field.
    pub fn set_depth_bounds_test_enable(&mut self, depth_bounds_test_enable: bool) -> &mut Self {
        self.depth_bounds_test_enable = depth_bounds_test_enable;
        self
    }
    ///Sets the `stencil_test_enable` field.
    pub fn set_stencil_test_enable(&mut self, stencil_test_enable: bool) -> &mut Self {
        self.stencil_test_enable = stencil_test_enable;
        self
    }
    ///Sets the `front` field.
    pub fn set_front(&mut self, front: StencilOpState) -> &mut Self {
        self.front = front;
        self
    }
    ///Sets the `back` field.
    pub fn set_back(&mut self, back: StencilOpState) -> &mut Self {
        self.back = back;
        self
    }
    ///Sets the `min_depth_bounds` field.
    pub fn set_min_depth_bounds(&mut self, min_depth_bounds: f32) -> &mut Self {
        self.min_depth_bounds = min_depth_bounds;
        self
    }
    ///Sets the `max_depth_bounds` field.
    pub fn set_max_depth_bounds(&mut self, max_depth_bounds: f32) -> &mut Self {
        self.max_depth_bounds = max_depth_bounds;
        self
    }
    ///Sets the `flags` field in a builder way.
    pub fn with_flags(mut self, flags: PipelineDepthStencilStateCreateFlags) -> Self {
        self.flags = flags;
        self
    }
    ///Sets the `depth_test_enable` field in a builder way.
    pub fn with_depth_test_enable(mut self, depth_test_enable: bool) -> Self {
        self.depth_test_enable = depth_test_enable;
        self
    }
    ///Sets the `depth_write_enable` field in a builder way.
    pub fn with_depth_write_enable(mut self, depth_write_enable: bool) -> Self {
        self.depth_write_enable = depth_write_enable;
        self
    }
    ///Sets the `depth_compare_op` field in a builder way.
    pub fn with_depth_compare_op(mut self, depth_compare_op: CompareOp) -> Self {
        self.depth_compare_op = depth_compare_op;
        self
    }
    ///Sets the `depth_bounds_test_enable` field in a builder way.
    pub fn with_depth_bounds_test_enable(mut self, depth_bounds_test_enable: bool) -> Self {
        self.depth_bounds_test_enable = depth_bounds_test_enable;
        self
    }
    ///Sets the `stencil_test_enable` field in a builder way.
    pub fn with_stencil_test_enable(mut self, stencil_test_enable: bool) -> Self {
        self.stencil_test_enable = stencil_test_enable;
        self
    }
    ///Sets the `front` field in a builder way.
    pub fn with_front(mut self, front: StencilOpState) -> Self {
        self.front = front;
        self
    }
    ///Sets the `back` field in a builder way.
    pub fn with_back(mut self, back: StencilOpState) -> Self {
        self.back = back;
        self
    }
    ///Sets the `min_depth_bounds` field in a builder way.
    pub fn with_min_depth_bounds(mut self, min_depth_bounds: f32) -> Self {
        self.min_depth_bounds = min_depth_bounds;
        self
    }
    ///Sets the `max_depth_bounds` field in a builder way.
    pub fn with_max_depth_bounds(mut self, max_depth_bounds: f32) -> Self {
        self.max_depth_bounds = max_depth_bounds;
        self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for PipelineDepthStencilStateCreateInfo {
    type LowLevel = crate::native::vulkan1_0::PipelineDepthStencilStateCreateInfo;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        crate::native::vulkan1_0::PipelineDepthStencilStateCreateInfo {
            s_type: StructureType::PipelineDepthStencilStateCreateInfo,
            p_next: std::ptr::null(),
            flags: self.flags.into_low_level(context, bump),
            depth_test_enable: self.depth_test_enable.into_low_level(context, bump),
            depth_write_enable: self.depth_write_enable.into_low_level(context, bump),
            depth_compare_op: self.depth_compare_op.into_low_level(context, bump),
            depth_bounds_test_enable: self.depth_bounds_test_enable.into_low_level(context, bump),
            stencil_test_enable: self.stencil_test_enable.into_low_level(context, bump),
            front: self.front.into_low_level(context, bump),
            back: self.back.into_low_level(context, bump),
            min_depth_bounds: self.min_depth_bounds.into_low_level(context, bump),
            max_depth_bounds: self.max_depth_bounds.into_low_level(context, bump),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for PipelineDepthStencilStateCreateInfo {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        Self {
            flags: crate::conv::FromLowLevel::from_low_level(context, value.flags),
            depth_test_enable: crate::conv::FromLowLevel::from_low_level(context, value.depth_test_enable),
            depth_write_enable: crate::conv::FromLowLevel::from_low_level(context, value.depth_write_enable),
            depth_compare_op: crate::conv::FromLowLevel::from_low_level(context, value.depth_compare_op),
            depth_bounds_test_enable: crate::conv::FromLowLevel::from_low_level(
                context,
                value.depth_bounds_test_enable,
            ),
            stencil_test_enable: crate::conv::FromLowLevel::from_low_level(context, value.stencil_test_enable),
            front: crate::conv::FromLowLevel::from_low_level(context, value.front),
            back: crate::conv::FromLowLevel::from_low_level(context, value.back),
            min_depth_bounds: crate::conv::FromLowLevel::from_low_level(context, value.min_depth_bounds),
            max_depth_bounds: crate::conv::FromLowLevel::from_low_level(context, value.max_depth_bounds),
        }
    }
}
#[doc(alias = "VkGraphicsPipelineCreateInfo")]
#[derive(Clone, PartialEq, Debug)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct GraphicsPipelineCreateInfo {
    #[doc(alias = "pNext")]
    pub extensions: SmallVec<[GraphicsPipelineCreateInfoExtension; 1]>,
    pub flags: PipelineCreateFlags,
    #[doc(alias = "pStages")]
    pub stages: SmallVec<[PipelineShaderStageCreateInfo; 8]>,
    #[doc(alias = "pVertexInputState")]
    pub vertex_input_state: Option<PipelineVertexInputStateCreateInfo>,
    #[doc(alias = "pInputAssemblyState")]
    pub input_assembly_state: Option<PipelineInputAssemblyStateCreateInfo>,
    #[doc(alias = "pTessellationState")]
    pub tessellation_state: Option<PipelineTessellationStateCreateInfo>,
    #[doc(alias = "pViewportState")]
    pub viewport_state: Option<PipelineViewportStateCreateInfo>,
    #[doc(alias = "pRasterizationState")]
    pub rasterization_state: PipelineRasterizationStateCreateInfo,
    #[doc(alias = "pMultisampleState")]
    pub multisample_state: Option<PipelineMultisampleStateCreateInfo>,
    #[doc(alias = "pDepthStencilState")]
    pub depth_stencil_state: Option<PipelineDepthStencilStateCreateInfo>,
    #[doc(alias = "pColorBlendState")]
    pub color_blend_state: Option<PipelineColorBlendStateCreateInfo>,
    #[doc(alias = "pDynamicState")]
    pub dynamic_state: Option<PipelineDynamicStateCreateInfo>,
    pub layout: PipelineLayout,
    #[doc(alias = "renderPass")]
    pub render_pass: Option<RenderPass>,
    pub subpass: u32,
    #[doc(alias = "basePipelineHandle")]
    pub base_pipeline_handle: Option<Pipeline>,
    #[doc(alias = "basePipelineIndex")]
    pub base_pipeline_index: i32,
}
impl GraphicsPipelineCreateInfo {
    ///Adds an extension to the struct
    pub fn with_extension(mut self, ext: impl Into<GraphicsPipelineCreateInfoExtension>) -> Self {
        self.extensions.push(ext.into());
        self
    }
    ///Get a reference to the `extensions` field.
    pub fn extensions(&self) -> &SmallVec<[GraphicsPipelineCreateInfoExtension; 1]> {
        &self.extensions
    }
    ///Get a reference to the `flags` field.
    pub fn flags(&self) -> PipelineCreateFlags {
        self.flags
    }
    ///Get a reference to the `stages` field.
    pub fn stages(&self) -> &SmallVec<[PipelineShaderStageCreateInfo; 8]> {
        &self.stages
    }
    ///Get a reference to the `vertex_input_state` field.
    pub fn vertex_input_state(&self) -> &Option<PipelineVertexInputStateCreateInfo> {
        &self.vertex_input_state
    }
    ///Get a reference to the `input_assembly_state` field.
    pub fn input_assembly_state(&self) -> &Option<PipelineInputAssemblyStateCreateInfo> {
        &self.input_assembly_state
    }
    ///Get a reference to the `tessellation_state` field.
    pub fn tessellation_state(&self) -> &Option<PipelineTessellationStateCreateInfo> {
        &self.tessellation_state
    }
    ///Get a reference to the `viewport_state` field.
    pub fn viewport_state(&self) -> &Option<PipelineViewportStateCreateInfo> {
        &self.viewport_state
    }
    ///Get a reference to the `rasterization_state` field.
    pub fn rasterization_state(&self) -> &PipelineRasterizationStateCreateInfo {
        &self.rasterization_state
    }
    ///Get a reference to the `multisample_state` field.
    pub fn multisample_state(&self) -> &Option<PipelineMultisampleStateCreateInfo> {
        &self.multisample_state
    }
    ///Get a reference to the `depth_stencil_state` field.
    pub fn depth_stencil_state(&self) -> &Option<PipelineDepthStencilStateCreateInfo> {
        &self.depth_stencil_state
    }
    ///Get a reference to the `color_blend_state` field.
    pub fn color_blend_state(&self) -> &Option<PipelineColorBlendStateCreateInfo> {
        &self.color_blend_state
    }
    ///Get a reference to the `dynamic_state` field.
    pub fn dynamic_state(&self) -> &Option<PipelineDynamicStateCreateInfo> {
        &self.dynamic_state
    }
    ///Get a reference to the `layout` field.
    pub fn layout(&self) -> &PipelineLayout {
        &self.layout
    }
    ///Get a reference to the `render_pass` field.
    pub fn render_pass(&self) -> &Option<RenderPass> {
        &self.render_pass
    }
    ///Get a reference to the `subpass` field.
    pub fn subpass(&self) -> u32 {
        self.subpass
    }
    ///Get a reference to the `base_pipeline_handle` field.
    pub fn base_pipeline_handle(&self) -> &Option<Pipeline> {
        &self.base_pipeline_handle
    }
    ///Get a reference to the `base_pipeline_index` field.
    pub fn base_pipeline_index(&self) -> i32 {
        self.base_pipeline_index
    }
    ///Get a mutable reference to the `extensions` field.
    pub fn extensions_mut(&mut self) -> &mut SmallVec<[GraphicsPipelineCreateInfoExtension; 1]> {
        &mut self.extensions
    }
    ///Get a mutable reference to the `flags` field.
    pub fn flags_mut(&mut self) -> &mut PipelineCreateFlags {
        &mut self.flags
    }
    ///Get a mutable reference to the `stages` field.
    pub fn stages_mut(&mut self) -> &mut SmallVec<[PipelineShaderStageCreateInfo; 8]> {
        &mut self.stages
    }
    ///Get a mutable reference to the `vertex_input_state` field.
    pub fn vertex_input_state_mut(&mut self) -> &mut Option<PipelineVertexInputStateCreateInfo> {
        &mut self.vertex_input_state
    }
    ///Get a mutable reference to the `input_assembly_state` field.
    pub fn input_assembly_state_mut(&mut self) -> &mut Option<PipelineInputAssemblyStateCreateInfo> {
        &mut self.input_assembly_state
    }
    ///Get a mutable reference to the `tessellation_state` field.
    pub fn tessellation_state_mut(&mut self) -> &mut Option<PipelineTessellationStateCreateInfo> {
        &mut self.tessellation_state
    }
    ///Get a mutable reference to the `viewport_state` field.
    pub fn viewport_state_mut(&mut self) -> &mut Option<PipelineViewportStateCreateInfo> {
        &mut self.viewport_state
    }
    ///Get a mutable reference to the `rasterization_state` field.
    pub fn rasterization_state_mut(&mut self) -> &mut PipelineRasterizationStateCreateInfo {
        &mut self.rasterization_state
    }
    ///Get a mutable reference to the `multisample_state` field.
    pub fn multisample_state_mut(&mut self) -> &mut Option<PipelineMultisampleStateCreateInfo> {
        &mut self.multisample_state
    }
    ///Get a mutable reference to the `depth_stencil_state` field.
    pub fn depth_stencil_state_mut(&mut self) -> &mut Option<PipelineDepthStencilStateCreateInfo> {
        &mut self.depth_stencil_state
    }
    ///Get a mutable reference to the `color_blend_state` field.
    pub fn color_blend_state_mut(&mut self) -> &mut Option<PipelineColorBlendStateCreateInfo> {
        &mut self.color_blend_state
    }
    ///Get a mutable reference to the `dynamic_state` field.
    pub fn dynamic_state_mut(&mut self) -> &mut Option<PipelineDynamicStateCreateInfo> {
        &mut self.dynamic_state
    }
    ///Get a mutable reference to the `layout` field.
    pub fn layout_mut(&mut self) -> &mut PipelineLayout {
        &mut self.layout
    }
    ///Get a mutable reference to the `render_pass` field.
    pub fn render_pass_mut(&mut self) -> &mut Option<RenderPass> {
        &mut self.render_pass
    }
    ///Get a mutable reference to the `subpass` field.
    pub fn subpass_mut(&mut self) -> &mut u32 {
        &mut self.subpass
    }
    ///Get a mutable reference to the `base_pipeline_handle` field.
    pub fn base_pipeline_handle_mut(&mut self) -> &mut Option<Pipeline> {
        &mut self.base_pipeline_handle
    }
    ///Get a mutable reference to the `base_pipeline_index` field.
    pub fn base_pipeline_index_mut(&mut self) -> &mut i32 {
        &mut self.base_pipeline_index
    }
    ///Sets the `extensions` field.
    pub fn set_extensions(&mut self, extensions: SmallVec<[GraphicsPipelineCreateInfoExtension; 1]>) -> &mut Self {
        self.extensions = extensions;
        self
    }
    ///Sets the `flags` field.
    pub fn set_flags(&mut self, flags: PipelineCreateFlags) -> &mut Self {
        self.flags = flags;
        self
    }
    ///Sets the `stages` field.
    pub fn set_stages(&mut self, stages: SmallVec<[PipelineShaderStageCreateInfo; 8]>) -> &mut Self {
        self.stages = stages;
        self
    }
    ///Sets the `vertex_input_state` field.
    pub fn set_vertex_input_state(
        &mut self,
        vertex_input_state: Option<PipelineVertexInputStateCreateInfo>,
    ) -> &mut Self {
        self.vertex_input_state = vertex_input_state;
        self
    }
    ///Sets the `input_assembly_state` field.
    pub fn set_input_assembly_state(
        &mut self,
        input_assembly_state: Option<PipelineInputAssemblyStateCreateInfo>,
    ) -> &mut Self {
        self.input_assembly_state = input_assembly_state;
        self
    }
    ///Sets the `tessellation_state` field.
    pub fn set_tessellation_state(
        &mut self,
        tessellation_state: Option<PipelineTessellationStateCreateInfo>,
    ) -> &mut Self {
        self.tessellation_state = tessellation_state;
        self
    }
    ///Sets the `viewport_state` field.
    pub fn set_viewport_state(&mut self, viewport_state: Option<PipelineViewportStateCreateInfo>) -> &mut Self {
        self.viewport_state = viewport_state;
        self
    }
    ///Sets the `rasterization_state` field.
    pub fn set_rasterization_state(&mut self, rasterization_state: PipelineRasterizationStateCreateInfo) -> &mut Self {
        self.rasterization_state = rasterization_state;
        self
    }
    ///Sets the `multisample_state` field.
    pub fn set_multisample_state(
        &mut self,
        multisample_state: Option<PipelineMultisampleStateCreateInfo>,
    ) -> &mut Self {
        self.multisample_state = multisample_state;
        self
    }
    ///Sets the `depth_stencil_state` field.
    pub fn set_depth_stencil_state(
        &mut self,
        depth_stencil_state: Option<PipelineDepthStencilStateCreateInfo>,
    ) -> &mut Self {
        self.depth_stencil_state = depth_stencil_state;
        self
    }
    ///Sets the `color_blend_state` field.
    pub fn set_color_blend_state(&mut self, color_blend_state: Option<PipelineColorBlendStateCreateInfo>) -> &mut Self {
        self.color_blend_state = color_blend_state;
        self
    }
    ///Sets the `dynamic_state` field.
    pub fn set_dynamic_state(&mut self, dynamic_state: Option<PipelineDynamicStateCreateInfo>) -> &mut Self {
        self.dynamic_state = dynamic_state;
        self
    }
    ///Sets the `layout` field.
    pub fn set_layout(&mut self, layout: PipelineLayout) -> &mut Self {
        self.layout = layout;
        self
    }
    ///Sets the `render_pass` field.
    pub fn set_render_pass(&mut self, render_pass: Option<RenderPass>) -> &mut Self {
        self.render_pass = render_pass;
        self
    }
    ///Sets the `subpass` field.
    pub fn set_subpass(&mut self, subpass: u32) -> &mut Self {
        self.subpass = subpass;
        self
    }
    ///Sets the `base_pipeline_handle` field.
    pub fn set_base_pipeline_handle(&mut self, base_pipeline_handle: Option<Pipeline>) -> &mut Self {
        self.base_pipeline_handle = base_pipeline_handle;
        self
    }
    ///Sets the `base_pipeline_index` field.
    pub fn set_base_pipeline_index(&mut self, base_pipeline_index: i32) -> &mut Self {
        self.base_pipeline_index = base_pipeline_index;
        self
    }
    ///Sets the `extensions` field in a builder way.
    pub fn with_extensions(mut self, extensions: SmallVec<[GraphicsPipelineCreateInfoExtension; 1]>) -> Self {
        self.extensions = extensions;
        self
    }
    ///Sets the `flags` field in a builder way.
    pub fn with_flags(mut self, flags: PipelineCreateFlags) -> Self {
        self.flags = flags;
        self
    }
    ///Sets the `stages` field in a builder way.
    pub fn with_stages(mut self, stages: SmallVec<[PipelineShaderStageCreateInfo; 8]>) -> Self {
        self.stages = stages;
        self
    }
    ///Sets the `vertex_input_state` field in a builder way.
    pub fn with_vertex_input_state(mut self, vertex_input_state: Option<PipelineVertexInputStateCreateInfo>) -> Self {
        self.vertex_input_state = vertex_input_state;
        self
    }
    ///Sets the `input_assembly_state` field in a builder way.
    pub fn with_input_assembly_state(
        mut self,
        input_assembly_state: Option<PipelineInputAssemblyStateCreateInfo>,
    ) -> Self {
        self.input_assembly_state = input_assembly_state;
        self
    }
    ///Sets the `tessellation_state` field in a builder way.
    pub fn with_tessellation_state(mut self, tessellation_state: Option<PipelineTessellationStateCreateInfo>) -> Self {
        self.tessellation_state = tessellation_state;
        self
    }
    ///Sets the `viewport_state` field in a builder way.
    pub fn with_viewport_state(mut self, viewport_state: Option<PipelineViewportStateCreateInfo>) -> Self {
        self.viewport_state = viewport_state;
        self
    }
    ///Sets the `rasterization_state` field in a builder way.
    pub fn with_rasterization_state(mut self, rasterization_state: PipelineRasterizationStateCreateInfo) -> Self {
        self.rasterization_state = rasterization_state;
        self
    }
    ///Sets the `multisample_state` field in a builder way.
    pub fn with_multisample_state(mut self, multisample_state: Option<PipelineMultisampleStateCreateInfo>) -> Self {
        self.multisample_state = multisample_state;
        self
    }
    ///Sets the `depth_stencil_state` field in a builder way.
    pub fn with_depth_stencil_state(
        mut self,
        depth_stencil_state: Option<PipelineDepthStencilStateCreateInfo>,
    ) -> Self {
        self.depth_stencil_state = depth_stencil_state;
        self
    }
    ///Sets the `color_blend_state` field in a builder way.
    pub fn with_color_blend_state(mut self, color_blend_state: Option<PipelineColorBlendStateCreateInfo>) -> Self {
        self.color_blend_state = color_blend_state;
        self
    }
    ///Sets the `dynamic_state` field in a builder way.
    pub fn with_dynamic_state(mut self, dynamic_state: Option<PipelineDynamicStateCreateInfo>) -> Self {
        self.dynamic_state = dynamic_state;
        self
    }
    ///Sets the `layout` field in a builder way.
    pub fn with_layout(mut self, layout: PipelineLayout) -> Self {
        self.layout = layout;
        self
    }
    ///Sets the `render_pass` field in a builder way.
    pub fn with_render_pass(mut self, render_pass: Option<RenderPass>) -> Self {
        self.render_pass = render_pass;
        self
    }
    ///Sets the `subpass` field in a builder way.
    pub fn with_subpass(mut self, subpass: u32) -> Self {
        self.subpass = subpass;
        self
    }
    ///Sets the `base_pipeline_handle` field in a builder way.
    pub fn with_base_pipeline_handle(mut self, base_pipeline_handle: Option<Pipeline>) -> Self {
        self.base_pipeline_handle = base_pipeline_handle;
        self
    }
    ///Sets the `base_pipeline_index` field in a builder way.
    pub fn with_base_pipeline_index(mut self, base_pipeline_index: i32) -> Self {
        self.base_pipeline_index = base_pipeline_index;
        self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for GraphicsPipelineCreateInfo {
    type LowLevel = crate::native::vulkan1_0::GraphicsPipelineCreateInfo;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        let mut next = std::ptr::null();
        let mut extensions = self.extensions.iter();
        while let Some(ext) = extensions.next() {
            let ext = ext.into_low_level(context, bump);
            (*ext).next = next;
            next = ext;
        }
        let len_stages = self.stages.len() as u32;
        let stages = bump
            .alloc_slice_fill_iter(self.stages.iter().map(|x| x.into_low_level(context, bump)))
            .as_ptr()
            .cast();
        crate::native::vulkan1_0::GraphicsPipelineCreateInfo {
            s_type: StructureType::GraphicsPipelineCreateInfo,
            p_next: next,
            flags: self.flags.into_low_level(context, bump),
            stage_count: len_stages,
            stages: stages,
            vertex_input_state: self
                .vertex_input_state
                .as_ref()
                .map(|v| bump.alloc(v.into_low_level(context, bump)) as *const _)
                .unwrap_or_else(std::ptr::null),
            input_assembly_state: self
                .input_assembly_state
                .as_ref()
                .map(|v| bump.alloc(v.into_low_level(context, bump)) as *const _)
                .unwrap_or_else(std::ptr::null),
            tessellation_state: self
                .tessellation_state
                .as_ref()
                .map(|v| bump.alloc(v.into_low_level(context, bump)) as *const _)
                .unwrap_or_else(std::ptr::null),
            viewport_state: self
                .viewport_state
                .as_ref()
                .map(|v| bump.alloc(v.into_low_level(context, bump)) as *const _)
                .unwrap_or_else(std::ptr::null),
            rasterization_state: bump.alloc(self.rasterization_state.into_low_level(context, bump)) as *const _,
            multisample_state: self
                .multisample_state
                .as_ref()
                .map(|v| bump.alloc(v.into_low_level(context, bump)) as *const _)
                .unwrap_or_else(std::ptr::null),
            depth_stencil_state: self
                .depth_stencil_state
                .as_ref()
                .map(|v| bump.alloc(v.into_low_level(context, bump)) as *const _)
                .unwrap_or_else(std::ptr::null),
            color_blend_state: self
                .color_blend_state
                .as_ref()
                .map(|v| bump.alloc(v.into_low_level(context, bump)) as *const _)
                .unwrap_or_else(std::ptr::null),
            dynamic_state: self
                .dynamic_state
                .as_ref()
                .map(|v| bump.alloc(v.into_low_level(context, bump)) as *const _)
                .unwrap_or_else(std::ptr::null),
            layout: self.layout.into_low_level(context, bump),
            render_pass: self
                .render_pass
                .as_ref()
                .map(|v| v.into_low_level(context, bump))
                .unwrap_or_else(Default::default),
            subpass: self.subpass.into_low_level(context, bump),
            base_pipeline_handle: self
                .base_pipeline_handle
                .as_ref()
                .map(|v| v.into_low_level(context, bump))
                .unwrap_or_else(Default::default),
            base_pipeline_index: self.base_pipeline_index.into_low_level(context, bump),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for GraphicsPipelineCreateInfo {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        let mut next = value.p_next;
        let mut extensions = SmallVec::new();
        while !next.is_null() {
            extensions.push(crate::conv::FromLowLevel::from_low_level(context, next));
            next = std::ptr::read(next).next;
        }
        let stages_len = value.stage_count;
        let mut stages = SmallVec::with_capacity(stages_len as usize);
        for i in 0..stages_len {
            stages.push(crate::conv::FromLowLevel::from_low_level(
                context,
                value.stages.add(i as usize).read(),
            ));
        }
        Self {
            extensions: extensions,
            flags: crate::conv::FromLowLevel::from_low_level(context, value.flags),
            stages: stages,
            vertex_input_state: crate::conv::FromLowLevel::from_low_level(context, *value.vertex_input_state),
            input_assembly_state: crate::conv::FromLowLevel::from_low_level(context, *value.input_assembly_state),
            tessellation_state: crate::conv::FromLowLevel::from_low_level(context, *value.tessellation_state),
            viewport_state: crate::conv::FromLowLevel::from_low_level(context, *value.viewport_state),
            rasterization_state: crate::conv::FromLowLevel::from_low_level(context, *value.rasterization_state),
            multisample_state: crate::conv::FromLowLevel::from_low_level(context, *value.multisample_state),
            depth_stencil_state: crate::conv::FromLowLevel::from_low_level(context, *value.depth_stencil_state),
            color_blend_state: crate::conv::FromLowLevel::from_low_level(context, *value.color_blend_state),
            dynamic_state: crate::conv::FromLowLevel::from_low_level(context, *value.dynamic_state),
            layout: crate::conv::FromLowLevel::from_low_level(context, value.layout),
            render_pass: if value.render_pass == crate::native::vulkan1_0::RenderPass::null() {
                None
            } else {
                Some(crate::conv::FromLowLevel::from_low_level(context, value.render_pass))
            },
            subpass: crate::conv::FromLowLevel::from_low_level(context, value.subpass),
            base_pipeline_handle: if value.base_pipeline_handle == crate::native::vulkan1_0::Pipeline::null() {
                None
            } else {
                Some(crate::conv::FromLowLevel::from_low_level(
                    context,
                    value.base_pipeline_handle,
                ))
            },
            base_pipeline_index: crate::conv::FromLowLevel::from_low_level(context, value.base_pipeline_index),
        }
    }
}
#[derive(Clone, PartialEq, Debug)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
///Extensions for [`GraphicsPipelineCreateInfo`]
pub enum GraphicsPipelineCreateInfoExtension {
    #[cfg(feature = "VK_NV_device_generated_commands")]
    ///Contains a type [`GraphicsPipelineShaderGroupsCreateInfoNV`] for extending
    /// [`GraphicsPipelineCreateInfo`]
    GraphicsPipelineShaderGroupsCreateInfoNV(GraphicsPipelineShaderGroupsCreateInfoNV),
    #[cfg(feature = "VK_EXT_discard_rectangles")]
    ///Contains a type [`PipelineDiscardRectangleStateCreateInfoEXT`] for extending
    /// [`GraphicsPipelineCreateInfo`]
    PipelineDiscardRectangleStateCreateInfoEXT(PipelineDiscardRectangleStateCreateInfoEXT),
    #[cfg(feature = "VK_NV_representative_fragment_test")]
    ///Contains a type [`PipelineRepresentativeFragmentTestStateCreateInfoNV`] for extending
    /// [`GraphicsPipelineCreateInfo`]
    PipelineRepresentativeFragmentTestStateCreateInfoNV(PipelineRepresentativeFragmentTestStateCreateInfoNV),
    #[cfg(feature = "VULKAN_1_3")]
    ///Contains a type [`PipelineCreationFeedbackCreateInfo`] for extending
    /// [`GraphicsPipelineCreateInfo`]
    PipelineCreationFeedbackCreateInfo(PipelineCreationFeedbackCreateInfo),
    #[cfg(feature = "VK_AMD_pipeline_compiler_control")]
    ///Contains a type [`PipelineCompilerControlCreateInfoAMD`] for extending
    /// [`GraphicsPipelineCreateInfo`]
    PipelineCompilerControlCreateInfoAMD(PipelineCompilerControlCreateInfoAMD),
    #[cfg(feature = "VK_KHR_fragment_shading_rate")]
    ///Contains a type [`PipelineFragmentShadingRateStateCreateInfoKHR`] for extending
    /// [`GraphicsPipelineCreateInfo`]
    PipelineFragmentShadingRateStateCreateInfoKHR(PipelineFragmentShadingRateStateCreateInfoKHR),
    #[cfg(feature = "VK_NV_fragment_shading_rate_enums")]
    ///Contains a type [`PipelineFragmentShadingRateEnumStateCreateInfoNV`] for extending
    /// [`GraphicsPipelineCreateInfo`]
    PipelineFragmentShadingRateEnumStateCreateInfoNV(PipelineFragmentShadingRateEnumStateCreateInfoNV),
    #[cfg(feature = "VULKAN_1_3")]
    ///Contains a type [`PipelineRenderingCreateInfo`] for extending [`GraphicsPipelineCreateInfo`]
    PipelineRenderingCreateInfo(PipelineRenderingCreateInfo),
    #[cfg(feature = "VK_KHR_dynamic_rendering")]
    ///Contains a type [`AttachmentSampleCountInfoAMD`] for extending
    /// [`GraphicsPipelineCreateInfo`]
    AttachmentSampleCountInfoAMD(AttachmentSampleCountInfoAMD),
    #[cfg(feature = "VK_KHR_dynamic_rendering")]
    ///Contains a type [`MultiviewPerViewAttributesInfoNVX`] for extending
    /// [`GraphicsPipelineCreateInfo`]
    MultiviewPerViewAttributesInfoNVX(MultiviewPerViewAttributesInfoNVX),
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for GraphicsPipelineCreateInfoExtension {
    type LowLevel = *const crate::native::vulkan1_0::BaseInStructure;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        match self { # [cfg (feature = "VK_NV_device_generated_commands")] Self :: GraphicsPipelineShaderGroupsCreateInfoNV (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: nv_device_generated_commands :: GraphicsPipelineShaderGroupsCreateInfoNV) . cast () , # [cfg (feature = "VK_EXT_discard_rectangles")] Self :: PipelineDiscardRectangleStateCreateInfoEXT (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: ext_discard_rectangles :: PipelineDiscardRectangleStateCreateInfoEXT) . cast () , # [cfg (feature = "VK_NV_representative_fragment_test")] Self :: PipelineRepresentativeFragmentTestStateCreateInfoNV (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: nv_representative_fragment_test :: PipelineRepresentativeFragmentTestStateCreateInfoNV) . cast () , # [cfg (feature = "VULKAN_1_3")] Self :: PipelineCreationFeedbackCreateInfo (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: vulkan1_3 :: PipelineCreationFeedbackCreateInfo) . cast () , # [cfg (feature = "VK_AMD_pipeline_compiler_control")] Self :: PipelineCompilerControlCreateInfoAMD (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: amd_pipeline_compiler_control :: PipelineCompilerControlCreateInfoAMD) . cast () , # [cfg (feature = "VK_KHR_fragment_shading_rate")] Self :: PipelineFragmentShadingRateStateCreateInfoKHR (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: khr_fragment_shading_rate :: PipelineFragmentShadingRateStateCreateInfoKHR) . cast () , # [cfg (feature = "VK_NV_fragment_shading_rate_enums")] Self :: PipelineFragmentShadingRateEnumStateCreateInfoNV (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: nv_fragment_shading_rate_enums :: PipelineFragmentShadingRateEnumStateCreateInfoNV) . cast () , # [cfg (feature = "VULKAN_1_3")] Self :: PipelineRenderingCreateInfo (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: vulkan1_3 :: PipelineRenderingCreateInfo) . cast () , # [cfg (feature = "VK_KHR_dynamic_rendering")] Self :: AttachmentSampleCountInfoAMD (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: khr_dynamic_rendering :: AttachmentSampleCountInfoAMD) . cast () , # [cfg (feature = "VK_KHR_dynamic_rendering")] Self :: MultiviewPerViewAttributesInfoNVX (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: khr_dynamic_rendering :: MultiviewPerViewAttributesInfoNVX) . cast () , other => unreachable ! ("unexpected variant {:?}" , other) }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for GraphicsPipelineCreateInfoExtension {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        assert!(!value.is_null());
        match (* value) . s_type { # [cfg (feature = "VK_NV_device_generated_commands")] crate :: native :: vulkan1_0 :: StructureType :: GraphicsPipelineShaderGroupsCreateInfoNv => Self :: GraphicsPipelineShaderGroupsCreateInfoNV (GraphicsPipelineShaderGroupsCreateInfoNV :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: nv_device_generated_commands :: GraphicsPipelineShaderGroupsCreateInfoNV > ()))) , # [cfg (feature = "VK_EXT_discard_rectangles")] crate :: native :: vulkan1_0 :: StructureType :: PipelineDiscardRectangleStateCreateInfoExt => Self :: PipelineDiscardRectangleStateCreateInfoEXT (PipelineDiscardRectangleStateCreateInfoEXT :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: ext_discard_rectangles :: PipelineDiscardRectangleStateCreateInfoEXT > ()))) , # [cfg (feature = "VK_NV_representative_fragment_test")] crate :: native :: vulkan1_0 :: StructureType :: PipelineRepresentativeFragmentTestStateCreateInfoNv => Self :: PipelineRepresentativeFragmentTestStateCreateInfoNV (PipelineRepresentativeFragmentTestStateCreateInfoNV :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: nv_representative_fragment_test :: PipelineRepresentativeFragmentTestStateCreateInfoNV > ()))) , # [cfg (feature = "VULKAN_1_3")] crate :: native :: vulkan1_0 :: StructureType :: PipelineCreationFeedbackCreateInfo => Self :: PipelineCreationFeedbackCreateInfo (PipelineCreationFeedbackCreateInfo :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: vulkan1_3 :: PipelineCreationFeedbackCreateInfo > ()))) , # [cfg (feature = "VK_AMD_pipeline_compiler_control")] crate :: native :: vulkan1_0 :: StructureType :: PipelineCompilerControlCreateInfoAmd => Self :: PipelineCompilerControlCreateInfoAMD (PipelineCompilerControlCreateInfoAMD :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: amd_pipeline_compiler_control :: PipelineCompilerControlCreateInfoAMD > ()))) , # [cfg (feature = "VK_KHR_fragment_shading_rate")] crate :: native :: vulkan1_0 :: StructureType :: PipelineFragmentShadingRateStateCreateInfoKhr => Self :: PipelineFragmentShadingRateStateCreateInfoKHR (PipelineFragmentShadingRateStateCreateInfoKHR :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: khr_fragment_shading_rate :: PipelineFragmentShadingRateStateCreateInfoKHR > ()))) , # [cfg (feature = "VK_NV_fragment_shading_rate_enums")] crate :: native :: vulkan1_0 :: StructureType :: PipelineFragmentShadingRateEnumStateCreateInfoNv => Self :: PipelineFragmentShadingRateEnumStateCreateInfoNV (PipelineFragmentShadingRateEnumStateCreateInfoNV :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: nv_fragment_shading_rate_enums :: PipelineFragmentShadingRateEnumStateCreateInfoNV > ()))) , # [cfg (feature = "VULKAN_1_3")] crate :: native :: vulkan1_0 :: StructureType :: PipelineRenderingCreateInfo => Self :: PipelineRenderingCreateInfo (PipelineRenderingCreateInfo :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: vulkan1_3 :: PipelineRenderingCreateInfo > ()))) , # [cfg (feature = "VK_KHR_dynamic_rendering")] crate :: native :: vulkan1_0 :: StructureType :: AttachmentSampleCountInfoAmd => Self :: AttachmentSampleCountInfoAMD (AttachmentSampleCountInfoAMD :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: khr_dynamic_rendering :: AttachmentSampleCountInfoAMD > ()))) , # [cfg (feature = "VK_KHR_dynamic_rendering")] crate :: native :: vulkan1_0 :: StructureType :: MultiviewPerViewAttributesInfoNvx => Self :: MultiviewPerViewAttributesInfoNVX (MultiviewPerViewAttributesInfoNVX :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: khr_dynamic_rendering :: MultiviewPerViewAttributesInfoNVX > ()))) , other => panic ! ("Structure type {:?} is not a member of {}" , other , stringify ! (GraphicsPipelineCreateInfo)) }
    }
}
#[cfg(feature = "VK_NV_device_generated_commands")]
impl From<GraphicsPipelineShaderGroupsCreateInfoNV> for GraphicsPipelineCreateInfoExtension {
    fn from(ext: GraphicsPipelineShaderGroupsCreateInfoNV) -> Self {
        Self::GraphicsPipelineShaderGroupsCreateInfoNV(ext)
    }
}
#[cfg(feature = "VK_NV_device_generated_commands")]
impl TryInto<GraphicsPipelineShaderGroupsCreateInfoNV> for GraphicsPipelineCreateInfoExtension {
    type Error = GraphicsPipelineCreateInfoExtension;
    fn try_into(self) -> Result<GraphicsPipelineShaderGroupsCreateInfoNV, Self::Error> {
        match self {
            Self::GraphicsPipelineShaderGroupsCreateInfoNV(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_EXT_discard_rectangles")]
impl From<PipelineDiscardRectangleStateCreateInfoEXT> for GraphicsPipelineCreateInfoExtension {
    fn from(ext: PipelineDiscardRectangleStateCreateInfoEXT) -> Self {
        Self::PipelineDiscardRectangleStateCreateInfoEXT(ext)
    }
}
#[cfg(feature = "VK_EXT_discard_rectangles")]
impl TryInto<PipelineDiscardRectangleStateCreateInfoEXT> for GraphicsPipelineCreateInfoExtension {
    type Error = GraphicsPipelineCreateInfoExtension;
    fn try_into(self) -> Result<PipelineDiscardRectangleStateCreateInfoEXT, Self::Error> {
        match self {
            Self::PipelineDiscardRectangleStateCreateInfoEXT(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_NV_representative_fragment_test")]
impl From<PipelineRepresentativeFragmentTestStateCreateInfoNV> for GraphicsPipelineCreateInfoExtension {
    fn from(ext: PipelineRepresentativeFragmentTestStateCreateInfoNV) -> Self {
        Self::PipelineRepresentativeFragmentTestStateCreateInfoNV(ext)
    }
}
#[cfg(feature = "VK_NV_representative_fragment_test")]
impl TryInto<PipelineRepresentativeFragmentTestStateCreateInfoNV> for GraphicsPipelineCreateInfoExtension {
    type Error = GraphicsPipelineCreateInfoExtension;
    fn try_into(self) -> Result<PipelineRepresentativeFragmentTestStateCreateInfoNV, Self::Error> {
        match self {
            Self::PipelineRepresentativeFragmentTestStateCreateInfoNV(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VULKAN_1_3")]
impl From<PipelineCreationFeedbackCreateInfo> for GraphicsPipelineCreateInfoExtension {
    fn from(ext: PipelineCreationFeedbackCreateInfo) -> Self {
        Self::PipelineCreationFeedbackCreateInfo(ext)
    }
}
#[cfg(feature = "VULKAN_1_3")]
impl TryInto<PipelineCreationFeedbackCreateInfo> for GraphicsPipelineCreateInfoExtension {
    type Error = GraphicsPipelineCreateInfoExtension;
    fn try_into(self) -> Result<PipelineCreationFeedbackCreateInfo, Self::Error> {
        match self {
            Self::PipelineCreationFeedbackCreateInfo(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_AMD_pipeline_compiler_control")]
impl From<PipelineCompilerControlCreateInfoAMD> for GraphicsPipelineCreateInfoExtension {
    fn from(ext: PipelineCompilerControlCreateInfoAMD) -> Self {
        Self::PipelineCompilerControlCreateInfoAMD(ext)
    }
}
#[cfg(feature = "VK_AMD_pipeline_compiler_control")]
impl TryInto<PipelineCompilerControlCreateInfoAMD> for GraphicsPipelineCreateInfoExtension {
    type Error = GraphicsPipelineCreateInfoExtension;
    fn try_into(self) -> Result<PipelineCompilerControlCreateInfoAMD, Self::Error> {
        match self {
            Self::PipelineCompilerControlCreateInfoAMD(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_KHR_fragment_shading_rate")]
impl From<PipelineFragmentShadingRateStateCreateInfoKHR> for GraphicsPipelineCreateInfoExtension {
    fn from(ext: PipelineFragmentShadingRateStateCreateInfoKHR) -> Self {
        Self::PipelineFragmentShadingRateStateCreateInfoKHR(ext)
    }
}
#[cfg(feature = "VK_KHR_fragment_shading_rate")]
impl TryInto<PipelineFragmentShadingRateStateCreateInfoKHR> for GraphicsPipelineCreateInfoExtension {
    type Error = GraphicsPipelineCreateInfoExtension;
    fn try_into(self) -> Result<PipelineFragmentShadingRateStateCreateInfoKHR, Self::Error> {
        match self {
            Self::PipelineFragmentShadingRateStateCreateInfoKHR(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_NV_fragment_shading_rate_enums")]
impl From<PipelineFragmentShadingRateEnumStateCreateInfoNV> for GraphicsPipelineCreateInfoExtension {
    fn from(ext: PipelineFragmentShadingRateEnumStateCreateInfoNV) -> Self {
        Self::PipelineFragmentShadingRateEnumStateCreateInfoNV(ext)
    }
}
#[cfg(feature = "VK_NV_fragment_shading_rate_enums")]
impl TryInto<PipelineFragmentShadingRateEnumStateCreateInfoNV> for GraphicsPipelineCreateInfoExtension {
    type Error = GraphicsPipelineCreateInfoExtension;
    fn try_into(self) -> Result<PipelineFragmentShadingRateEnumStateCreateInfoNV, Self::Error> {
        match self {
            Self::PipelineFragmentShadingRateEnumStateCreateInfoNV(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VULKAN_1_3")]
impl From<PipelineRenderingCreateInfo> for GraphicsPipelineCreateInfoExtension {
    fn from(ext: PipelineRenderingCreateInfo) -> Self {
        Self::PipelineRenderingCreateInfo(ext)
    }
}
#[cfg(feature = "VULKAN_1_3")]
impl TryInto<PipelineRenderingCreateInfo> for GraphicsPipelineCreateInfoExtension {
    type Error = GraphicsPipelineCreateInfoExtension;
    fn try_into(self) -> Result<PipelineRenderingCreateInfo, Self::Error> {
        match self {
            Self::PipelineRenderingCreateInfo(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_KHR_dynamic_rendering")]
impl From<AttachmentSampleCountInfoAMD> for GraphicsPipelineCreateInfoExtension {
    fn from(ext: AttachmentSampleCountInfoAMD) -> Self {
        Self::AttachmentSampleCountInfoAMD(ext)
    }
}
#[cfg(feature = "VK_KHR_dynamic_rendering")]
impl TryInto<AttachmentSampleCountInfoAMD> for GraphicsPipelineCreateInfoExtension {
    type Error = GraphicsPipelineCreateInfoExtension;
    fn try_into(self) -> Result<AttachmentSampleCountInfoAMD, Self::Error> {
        match self {
            Self::AttachmentSampleCountInfoAMD(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_KHR_dynamic_rendering")]
impl From<MultiviewPerViewAttributesInfoNVX> for GraphicsPipelineCreateInfoExtension {
    fn from(ext: MultiviewPerViewAttributesInfoNVX) -> Self {
        Self::MultiviewPerViewAttributesInfoNVX(ext)
    }
}
#[cfg(feature = "VK_KHR_dynamic_rendering")]
impl TryInto<MultiviewPerViewAttributesInfoNVX> for GraphicsPipelineCreateInfoExtension {
    type Error = GraphicsPipelineCreateInfoExtension;
    fn try_into(self) -> Result<MultiviewPerViewAttributesInfoNVX, Self::Error> {
        match self {
            Self::MultiviewPerViewAttributesInfoNVX(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[doc(alias = "VkPipelineCacheCreateInfo")]
#[derive(Clone, PartialEq, Debug, Default)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct PipelineCacheCreateInfo {
    pub flags: PipelineCacheCreateFlags,
    #[doc(alias = "pInitialData")]
    pub initial_data: Vec<u8>,
}
impl PipelineCacheCreateInfo {
    ///Get a reference to the `flags` field.
    pub fn flags(&self) -> PipelineCacheCreateFlags {
        self.flags
    }
    ///Get a reference to the `initial_data` field.
    pub fn initial_data(&self) -> &Vec<u8> {
        &self.initial_data
    }
    ///Get a mutable reference to the `flags` field.
    pub fn flags_mut(&mut self) -> &mut PipelineCacheCreateFlags {
        &mut self.flags
    }
    ///Get a mutable reference to the `initial_data` field.
    pub fn initial_data_mut(&mut self) -> &mut Vec<u8> {
        &mut self.initial_data
    }
    ///Sets the `flags` field.
    pub fn set_flags(&mut self, flags: PipelineCacheCreateFlags) -> &mut Self {
        self.flags = flags;
        self
    }
    ///Sets the `initial_data` field.
    pub fn set_initial_data(&mut self, initial_data: Vec<u8>) -> &mut Self {
        self.initial_data = initial_data;
        self
    }
    ///Sets the `flags` field in a builder way.
    pub fn with_flags(mut self, flags: PipelineCacheCreateFlags) -> Self {
        self.flags = flags;
        self
    }
    ///Sets the `initial_data` field in a builder way.
    pub fn with_initial_data(mut self, initial_data: Vec<u8>) -> Self {
        self.initial_data = initial_data;
        self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for PipelineCacheCreateInfo {
    type LowLevel = crate::native::vulkan1_0::PipelineCacheCreateInfo;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        let len_initial_data = self.initial_data.len() as usize;
        crate::native::vulkan1_0::PipelineCacheCreateInfo {
            s_type: StructureType::PipelineCacheCreateInfo,
            p_next: std::ptr::null(),
            flags: self.flags.into_low_level(context, bump),
            initial_data_size: len_initial_data,
            initial_data: self.initial_data.as_ptr().cast(),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for PipelineCacheCreateInfo {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        let initial_data_len = value.initial_data_size;
        let mut initial_data = Vec::with_capacity(initial_data_len as usize);
        let initial_data_ptr = value.initial_data as *const u8;
        for i in 0..initial_data_len {
            initial_data.push(crate::conv::FromLowLevel::from_low_level(
                context,
                initial_data_ptr.add(i as usize).read(),
            ));
        }
        Self {
            flags: crate::conv::FromLowLevel::from_low_level(context, value.flags),
            initial_data: initial_data,
        }
    }
}
impl PipelineCacheHeaderVersionOne {
    ///Get a reference to the `header_size` field.
    pub fn header_size(&self) -> u32 {
        self.header_size
    }
    ///Get a reference to the `header_version` field.
    pub fn header_version(&self) -> PipelineCacheHeaderVersion {
        self.header_version
    }
    ///Get a reference to the `vendor_id` field.
    pub fn vendor_id(&self) -> u32 {
        self.vendor_id
    }
    ///Get a reference to the `device_id` field.
    pub fn device_id(&self) -> u32 {
        self.device_id
    }
    ///Get a reference to the `pipeline_cache_uuid` field.
    pub fn pipeline_cache_uuid(&self) -> uuid::Uuid {
        self.pipeline_cache_uuid
    }
    ///Get a mutable reference to the `header_size` field.
    pub fn header_size_mut(&mut self) -> &mut u32 {
        &mut self.header_size
    }
    ///Get a mutable reference to the `header_version` field.
    pub fn header_version_mut(&mut self) -> &mut PipelineCacheHeaderVersion {
        &mut self.header_version
    }
    ///Get a mutable reference to the `vendor_id` field.
    pub fn vendor_id_mut(&mut self) -> &mut u32 {
        &mut self.vendor_id
    }
    ///Get a mutable reference to the `device_id` field.
    pub fn device_id_mut(&mut self) -> &mut u32 {
        &mut self.device_id
    }
    ///Get a mutable reference to the `pipeline_cache_uuid` field.
    pub fn pipeline_cache_uuid_mut(&mut self) -> &mut uuid::Uuid {
        &mut self.pipeline_cache_uuid
    }
    ///Sets the `header_size` field.
    pub fn set_header_size(&mut self, header_size: u32) -> &mut Self {
        self.header_size = header_size;
        self
    }
    ///Sets the `header_version` field.
    pub fn set_header_version(&mut self, header_version: PipelineCacheHeaderVersion) -> &mut Self {
        self.header_version = header_version;
        self
    }
    ///Sets the `vendor_id` field.
    pub fn set_vendor_id(&mut self, vendor_id: u32) -> &mut Self {
        self.vendor_id = vendor_id;
        self
    }
    ///Sets the `device_id` field.
    pub fn set_device_id(&mut self, device_id: u32) -> &mut Self {
        self.device_id = device_id;
        self
    }
    ///Sets the `pipeline_cache_uuid` field.
    pub fn set_pipeline_cache_uuid(&mut self, pipeline_cache_uuid: uuid::Uuid) -> &mut Self {
        self.pipeline_cache_uuid = pipeline_cache_uuid;
        self
    }
    ///Sets the `header_size` field in a builder way.
    pub fn with_header_size(mut self, header_size: u32) -> Self {
        self.header_size = header_size;
        self
    }
    ///Sets the `header_version` field in a builder way.
    pub fn with_header_version(mut self, header_version: PipelineCacheHeaderVersion) -> Self {
        self.header_version = header_version;
        self
    }
    ///Sets the `vendor_id` field in a builder way.
    pub fn with_vendor_id(mut self, vendor_id: u32) -> Self {
        self.vendor_id = vendor_id;
        self
    }
    ///Sets the `device_id` field in a builder way.
    pub fn with_device_id(mut self, device_id: u32) -> Self {
        self.device_id = device_id;
        self
    }
    ///Sets the `pipeline_cache_uuid` field in a builder way.
    pub fn with_pipeline_cache_uuid(mut self, pipeline_cache_uuid: uuid::Uuid) -> Self {
        self.pipeline_cache_uuid = pipeline_cache_uuid;
        self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for PipelineCacheHeaderVersionOne {
    type LowLevel = crate::native::vulkan1_0::PipelineCacheHeaderVersionOne;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        crate::native::vulkan1_0::PipelineCacheHeaderVersionOne {
            header_size: self.header_size.into_low_level(context, bump),
            header_version: self.header_version.into_low_level(context, bump),
            vendor_id: self.vendor_id.into_low_level(context, bump),
            device_id: self.device_id.into_low_level(context, bump),
            pipeline_cache_uuid: self.pipeline_cache_uuid.into_low_level(context, bump),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for PipelineCacheHeaderVersionOne {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        Self {
            header_size: crate::conv::FromLowLevel::from_low_level(context, value.header_size),
            header_version: crate::conv::FromLowLevel::from_low_level(context, value.header_version),
            vendor_id: crate::conv::FromLowLevel::from_low_level(context, value.vendor_id),
            device_id: crate::conv::FromLowLevel::from_low_level(context, value.device_id),
            pipeline_cache_uuid: crate::conv::FromLowLevel::from_low_level(context, value.pipeline_cache_uuid),
        }
    }
}
impl PushConstantRange {
    ///Get a reference to the `stage_flags` field.
    pub fn stage_flags(&self) -> ShaderStageFlags {
        self.stage_flags
    }
    ///Get a reference to the `offset` field.
    pub fn offset(&self) -> u32 {
        self.offset
    }
    ///Get a reference to the `size` field.
    pub fn size(&self) -> u32 {
        self.size
    }
    ///Get a mutable reference to the `stage_flags` field.
    pub fn stage_flags_mut(&mut self) -> &mut ShaderStageFlags {
        &mut self.stage_flags
    }
    ///Get a mutable reference to the `offset` field.
    pub fn offset_mut(&mut self) -> &mut u32 {
        &mut self.offset
    }
    ///Get a mutable reference to the `size` field.
    pub fn size_mut(&mut self) -> &mut u32 {
        &mut self.size
    }
    ///Sets the `stage_flags` field.
    pub fn set_stage_flags(&mut self, stage_flags: ShaderStageFlags) -> &mut Self {
        self.stage_flags = stage_flags;
        self
    }
    ///Sets the `offset` field.
    pub fn set_offset(&mut self, offset: u32) -> &mut Self {
        self.offset = offset;
        self
    }
    ///Sets the `size` field.
    pub fn set_size(&mut self, size: u32) -> &mut Self {
        self.size = size;
        self
    }
    ///Sets the `stage_flags` field in a builder way.
    pub fn with_stage_flags(mut self, stage_flags: ShaderStageFlags) -> Self {
        self.stage_flags = stage_flags;
        self
    }
    ///Sets the `offset` field in a builder way.
    pub fn with_offset(mut self, offset: u32) -> Self {
        self.offset = offset;
        self
    }
    ///Sets the `size` field in a builder way.
    pub fn with_size(mut self, size: u32) -> Self {
        self.size = size;
        self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for PushConstantRange {
    type LowLevel = crate::native::vulkan1_0::PushConstantRange;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        crate::native::vulkan1_0::PushConstantRange {
            stage_flags: self.stage_flags.into_low_level(context, bump),
            offset: self.offset.into_low_level(context, bump),
            size: self.size.into_low_level(context, bump),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for PushConstantRange {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        Self {
            stage_flags: crate::conv::FromLowLevel::from_low_level(context, value.stage_flags),
            offset: crate::conv::FromLowLevel::from_low_level(context, value.offset),
            size: crate::conv::FromLowLevel::from_low_level(context, value.size),
        }
    }
}
#[doc(alias = "VkPipelineLayoutCreateInfo")]
#[derive(Clone, PartialEq, Debug, Default)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct PipelineLayoutCreateInfo {
    pub flags: PipelineLayoutCreateFlags,
    #[doc(alias = "pSetLayouts")]
    pub set_layouts: SmallVec<[DescriptorSetLayout; 8]>,
    #[doc(alias = "pPushConstantRanges")]
    pub push_constant_ranges: SmallVec<[PushConstantRange; 8]>,
}
impl PipelineLayoutCreateInfo {
    ///Get a reference to the `flags` field.
    pub fn flags(&self) -> PipelineLayoutCreateFlags {
        self.flags
    }
    ///Get a reference to the `set_layouts` field.
    pub fn set_layouts(&self) -> &SmallVec<[DescriptorSetLayout; 8]> {
        &self.set_layouts
    }
    ///Get a reference to the `push_constant_ranges` field.
    pub fn push_constant_ranges(&self) -> &SmallVec<[PushConstantRange; 8]> {
        &self.push_constant_ranges
    }
    ///Get a mutable reference to the `flags` field.
    pub fn flags_mut(&mut self) -> &mut PipelineLayoutCreateFlags {
        &mut self.flags
    }
    ///Get a mutable reference to the `set_layouts` field.
    pub fn set_layouts_mut(&mut self) -> &mut SmallVec<[DescriptorSetLayout; 8]> {
        &mut self.set_layouts
    }
    ///Get a mutable reference to the `push_constant_ranges` field.
    pub fn push_constant_ranges_mut(&mut self) -> &mut SmallVec<[PushConstantRange; 8]> {
        &mut self.push_constant_ranges
    }
    ///Sets the `flags` field.
    pub fn set_flags(&mut self, flags: PipelineLayoutCreateFlags) -> &mut Self {
        self.flags = flags;
        self
    }
    ///Sets the `set_layouts` field.
    pub fn set_set_layouts(&mut self, set_layouts: SmallVec<[DescriptorSetLayout; 8]>) -> &mut Self {
        self.set_layouts = set_layouts;
        self
    }
    ///Sets the `push_constant_ranges` field.
    pub fn set_push_constant_ranges(&mut self, push_constant_ranges: SmallVec<[PushConstantRange; 8]>) -> &mut Self {
        self.push_constant_ranges = push_constant_ranges;
        self
    }
    ///Sets the `flags` field in a builder way.
    pub fn with_flags(mut self, flags: PipelineLayoutCreateFlags) -> Self {
        self.flags = flags;
        self
    }
    ///Sets the `set_layouts` field in a builder way.
    pub fn with_set_layouts(mut self, set_layouts: SmallVec<[DescriptorSetLayout; 8]>) -> Self {
        self.set_layouts = set_layouts;
        self
    }
    ///Sets the `push_constant_ranges` field in a builder way.
    pub fn with_push_constant_ranges(mut self, push_constant_ranges: SmallVec<[PushConstantRange; 8]>) -> Self {
        self.push_constant_ranges = push_constant_ranges;
        self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for PipelineLayoutCreateInfo {
    type LowLevel = crate::native::vulkan1_0::PipelineLayoutCreateInfo;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        let len_set_layouts = self.set_layouts.len() as u32;
        let set_layouts = bump
            .alloc_slice_fill_iter(self.set_layouts.iter().map(|x| x.into_low_level(context, bump)))
            .as_ptr()
            .cast();
        let len_push_constant_ranges = self.push_constant_ranges.len() as u32;
        let push_constant_ranges = bump
            .alloc_slice_fill_iter(
                self.push_constant_ranges
                    .iter()
                    .map(|x| x.into_low_level(context, bump)),
            )
            .as_ptr()
            .cast();
        crate::native::vulkan1_0::PipelineLayoutCreateInfo {
            s_type: StructureType::PipelineLayoutCreateInfo,
            p_next: std::ptr::null(),
            flags: self.flags.into_low_level(context, bump),
            set_layout_count: len_set_layouts,
            set_layouts: set_layouts,
            push_constant_range_count: len_push_constant_ranges,
            push_constant_ranges: push_constant_ranges,
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for PipelineLayoutCreateInfo {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        let set_layouts_len = value.set_layout_count;
        let mut set_layouts = SmallVec::with_capacity(set_layouts_len as usize);
        for i in 0..set_layouts_len {
            set_layouts.push(crate::conv::FromLowLevel::from_low_level(
                context,
                value.set_layouts.add(i as usize).read(),
            ));
        }
        let push_constant_ranges_len = value.push_constant_range_count;
        let mut push_constant_ranges = SmallVec::with_capacity(push_constant_ranges_len as usize);
        for i in 0..push_constant_ranges_len {
            push_constant_ranges.push(crate::conv::FromLowLevel::from_low_level(
                context,
                value.push_constant_ranges.add(i as usize).read(),
            ));
        }
        Self {
            flags: crate::conv::FromLowLevel::from_low_level(context, value.flags),
            set_layouts: set_layouts,
            push_constant_ranges: push_constant_ranges,
        }
    }
}
#[doc(alias = "VkSamplerCreateInfo")]
#[derive(Clone, PartialEq, Debug, Default)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct SamplerCreateInfo {
    #[doc(alias = "pNext")]
    pub extensions: SmallVec<[SamplerCreateInfoExtension; 1]>,
    pub flags: SamplerCreateFlags,
    #[doc(alias = "magFilter")]
    pub mag_filter: Filter,
    #[doc(alias = "minFilter")]
    pub min_filter: Filter,
    #[doc(alias = "mipmapMode")]
    pub mipmap_mode: SamplerMipmapMode,
    #[doc(alias = "addressModeU")]
    pub address_mode_u: SamplerAddressMode,
    #[doc(alias = "addressModeV")]
    pub address_mode_v: SamplerAddressMode,
    #[doc(alias = "addressModeW")]
    pub address_mode_w: SamplerAddressMode,
    #[doc(alias = "mipLodBias")]
    pub mip_lod_bias: f32,
    #[doc(alias = "anisotropyEnable")]
    pub anisotropy_enable: bool,
    #[doc(alias = "maxAnisotropy")]
    pub max_anisotropy: f32,
    #[doc(alias = "compareEnable")]
    pub compare_enable: bool,
    #[doc(alias = "compareOp")]
    pub compare_op: CompareOp,
    #[doc(alias = "minLod")]
    pub min_lod: f32,
    #[doc(alias = "maxLod")]
    pub max_lod: f32,
    #[doc(alias = "borderColor")]
    pub border_color: BorderColor,
    #[doc(alias = "unnormalizedCoordinates")]
    pub unnormalized_coordinates: bool,
}
impl SamplerCreateInfo {
    ///Adds an extension to the struct
    pub fn with_extension(mut self, ext: impl Into<SamplerCreateInfoExtension>) -> Self {
        self.extensions.push(ext.into());
        self
    }
    ///Get a reference to the `extensions` field.
    pub fn extensions(&self) -> &SmallVec<[SamplerCreateInfoExtension; 1]> {
        &self.extensions
    }
    ///Get a reference to the `flags` field.
    pub fn flags(&self) -> SamplerCreateFlags {
        self.flags
    }
    ///Get a reference to the `mag_filter` field.
    pub fn mag_filter(&self) -> Filter {
        self.mag_filter
    }
    ///Get a reference to the `min_filter` field.
    pub fn min_filter(&self) -> Filter {
        self.min_filter
    }
    ///Get a reference to the `mipmap_mode` field.
    pub fn mipmap_mode(&self) -> SamplerMipmapMode {
        self.mipmap_mode
    }
    ///Get a reference to the `address_mode_u` field.
    pub fn address_mode_u(&self) -> SamplerAddressMode {
        self.address_mode_u
    }
    ///Get a reference to the `address_mode_v` field.
    pub fn address_mode_v(&self) -> SamplerAddressMode {
        self.address_mode_v
    }
    ///Get a reference to the `address_mode_w` field.
    pub fn address_mode_w(&self) -> SamplerAddressMode {
        self.address_mode_w
    }
    ///Get a reference to the `mip_lod_bias` field.
    pub fn mip_lod_bias(&self) -> f32 {
        self.mip_lod_bias
    }
    ///Get a reference to the `anisotropy_enable` field.
    pub fn anisotropy_enable(&self) -> &bool {
        &self.anisotropy_enable
    }
    ///Get a reference to the `max_anisotropy` field.
    pub fn max_anisotropy(&self) -> f32 {
        self.max_anisotropy
    }
    ///Get a reference to the `compare_enable` field.
    pub fn compare_enable(&self) -> &bool {
        &self.compare_enable
    }
    ///Get a reference to the `compare_op` field.
    pub fn compare_op(&self) -> CompareOp {
        self.compare_op
    }
    ///Get a reference to the `min_lod` field.
    pub fn min_lod(&self) -> f32 {
        self.min_lod
    }
    ///Get a reference to the `max_lod` field.
    pub fn max_lod(&self) -> f32 {
        self.max_lod
    }
    ///Get a reference to the `border_color` field.
    pub fn border_color(&self) -> BorderColor {
        self.border_color
    }
    ///Get a reference to the `unnormalized_coordinates` field.
    pub fn unnormalized_coordinates(&self) -> &bool {
        &self.unnormalized_coordinates
    }
    ///Get a mutable reference to the `extensions` field.
    pub fn extensions_mut(&mut self) -> &mut SmallVec<[SamplerCreateInfoExtension; 1]> {
        &mut self.extensions
    }
    ///Get a mutable reference to the `flags` field.
    pub fn flags_mut(&mut self) -> &mut SamplerCreateFlags {
        &mut self.flags
    }
    ///Get a mutable reference to the `mag_filter` field.
    pub fn mag_filter_mut(&mut self) -> &mut Filter {
        &mut self.mag_filter
    }
    ///Get a mutable reference to the `min_filter` field.
    pub fn min_filter_mut(&mut self) -> &mut Filter {
        &mut self.min_filter
    }
    ///Get a mutable reference to the `mipmap_mode` field.
    pub fn mipmap_mode_mut(&mut self) -> &mut SamplerMipmapMode {
        &mut self.mipmap_mode
    }
    ///Get a mutable reference to the `address_mode_u` field.
    pub fn address_mode_u_mut(&mut self) -> &mut SamplerAddressMode {
        &mut self.address_mode_u
    }
    ///Get a mutable reference to the `address_mode_v` field.
    pub fn address_mode_v_mut(&mut self) -> &mut SamplerAddressMode {
        &mut self.address_mode_v
    }
    ///Get a mutable reference to the `address_mode_w` field.
    pub fn address_mode_w_mut(&mut self) -> &mut SamplerAddressMode {
        &mut self.address_mode_w
    }
    ///Get a mutable reference to the `mip_lod_bias` field.
    pub fn mip_lod_bias_mut(&mut self) -> &mut f32 {
        &mut self.mip_lod_bias
    }
    ///Get a mutable reference to the `anisotropy_enable` field.
    pub fn anisotropy_enable_mut(&mut self) -> &mut bool {
        &mut self.anisotropy_enable
    }
    ///Get a mutable reference to the `max_anisotropy` field.
    pub fn max_anisotropy_mut(&mut self) -> &mut f32 {
        &mut self.max_anisotropy
    }
    ///Get a mutable reference to the `compare_enable` field.
    pub fn compare_enable_mut(&mut self) -> &mut bool {
        &mut self.compare_enable
    }
    ///Get a mutable reference to the `compare_op` field.
    pub fn compare_op_mut(&mut self) -> &mut CompareOp {
        &mut self.compare_op
    }
    ///Get a mutable reference to the `min_lod` field.
    pub fn min_lod_mut(&mut self) -> &mut f32 {
        &mut self.min_lod
    }
    ///Get a mutable reference to the `max_lod` field.
    pub fn max_lod_mut(&mut self) -> &mut f32 {
        &mut self.max_lod
    }
    ///Get a mutable reference to the `border_color` field.
    pub fn border_color_mut(&mut self) -> &mut BorderColor {
        &mut self.border_color
    }
    ///Get a mutable reference to the `unnormalized_coordinates` field.
    pub fn unnormalized_coordinates_mut(&mut self) -> &mut bool {
        &mut self.unnormalized_coordinates
    }
    ///Sets the `extensions` field.
    pub fn set_extensions(&mut self, extensions: SmallVec<[SamplerCreateInfoExtension; 1]>) -> &mut Self {
        self.extensions = extensions;
        self
    }
    ///Sets the `flags` field.
    pub fn set_flags(&mut self, flags: SamplerCreateFlags) -> &mut Self {
        self.flags = flags;
        self
    }
    ///Sets the `mag_filter` field.
    pub fn set_mag_filter(&mut self, mag_filter: Filter) -> &mut Self {
        self.mag_filter = mag_filter;
        self
    }
    ///Sets the `min_filter` field.
    pub fn set_min_filter(&mut self, min_filter: Filter) -> &mut Self {
        self.min_filter = min_filter;
        self
    }
    ///Sets the `mipmap_mode` field.
    pub fn set_mipmap_mode(&mut self, mipmap_mode: SamplerMipmapMode) -> &mut Self {
        self.mipmap_mode = mipmap_mode;
        self
    }
    ///Sets the `address_mode_u` field.
    pub fn set_address_mode_u(&mut self, address_mode_u: SamplerAddressMode) -> &mut Self {
        self.address_mode_u = address_mode_u;
        self
    }
    ///Sets the `address_mode_v` field.
    pub fn set_address_mode_v(&mut self, address_mode_v: SamplerAddressMode) -> &mut Self {
        self.address_mode_v = address_mode_v;
        self
    }
    ///Sets the `address_mode_w` field.
    pub fn set_address_mode_w(&mut self, address_mode_w: SamplerAddressMode) -> &mut Self {
        self.address_mode_w = address_mode_w;
        self
    }
    ///Sets the `mip_lod_bias` field.
    pub fn set_mip_lod_bias(&mut self, mip_lod_bias: f32) -> &mut Self {
        self.mip_lod_bias = mip_lod_bias;
        self
    }
    ///Sets the `anisotropy_enable` field.
    pub fn set_anisotropy_enable(&mut self, anisotropy_enable: bool) -> &mut Self {
        self.anisotropy_enable = anisotropy_enable;
        self
    }
    ///Sets the `max_anisotropy` field.
    pub fn set_max_anisotropy(&mut self, max_anisotropy: f32) -> &mut Self {
        self.max_anisotropy = max_anisotropy;
        self
    }
    ///Sets the `compare_enable` field.
    pub fn set_compare_enable(&mut self, compare_enable: bool) -> &mut Self {
        self.compare_enable = compare_enable;
        self
    }
    ///Sets the `compare_op` field.
    pub fn set_compare_op(&mut self, compare_op: CompareOp) -> &mut Self {
        self.compare_op = compare_op;
        self
    }
    ///Sets the `min_lod` field.
    pub fn set_min_lod(&mut self, min_lod: f32) -> &mut Self {
        self.min_lod = min_lod;
        self
    }
    ///Sets the `max_lod` field.
    pub fn set_max_lod(&mut self, max_lod: f32) -> &mut Self {
        self.max_lod = max_lod;
        self
    }
    ///Sets the `border_color` field.
    pub fn set_border_color(&mut self, border_color: BorderColor) -> &mut Self {
        self.border_color = border_color;
        self
    }
    ///Sets the `unnormalized_coordinates` field.
    pub fn set_unnormalized_coordinates(&mut self, unnormalized_coordinates: bool) -> &mut Self {
        self.unnormalized_coordinates = unnormalized_coordinates;
        self
    }
    ///Sets the `extensions` field in a builder way.
    pub fn with_extensions(mut self, extensions: SmallVec<[SamplerCreateInfoExtension; 1]>) -> Self {
        self.extensions = extensions;
        self
    }
    ///Sets the `flags` field in a builder way.
    pub fn with_flags(mut self, flags: SamplerCreateFlags) -> Self {
        self.flags = flags;
        self
    }
    ///Sets the `mag_filter` field in a builder way.
    pub fn with_mag_filter(mut self, mag_filter: Filter) -> Self {
        self.mag_filter = mag_filter;
        self
    }
    ///Sets the `min_filter` field in a builder way.
    pub fn with_min_filter(mut self, min_filter: Filter) -> Self {
        self.min_filter = min_filter;
        self
    }
    ///Sets the `mipmap_mode` field in a builder way.
    pub fn with_mipmap_mode(mut self, mipmap_mode: SamplerMipmapMode) -> Self {
        self.mipmap_mode = mipmap_mode;
        self
    }
    ///Sets the `address_mode_u` field in a builder way.
    pub fn with_address_mode_u(mut self, address_mode_u: SamplerAddressMode) -> Self {
        self.address_mode_u = address_mode_u;
        self
    }
    ///Sets the `address_mode_v` field in a builder way.
    pub fn with_address_mode_v(mut self, address_mode_v: SamplerAddressMode) -> Self {
        self.address_mode_v = address_mode_v;
        self
    }
    ///Sets the `address_mode_w` field in a builder way.
    pub fn with_address_mode_w(mut self, address_mode_w: SamplerAddressMode) -> Self {
        self.address_mode_w = address_mode_w;
        self
    }
    ///Sets the `mip_lod_bias` field in a builder way.
    pub fn with_mip_lod_bias(mut self, mip_lod_bias: f32) -> Self {
        self.mip_lod_bias = mip_lod_bias;
        self
    }
    ///Sets the `anisotropy_enable` field in a builder way.
    pub fn with_anisotropy_enable(mut self, anisotropy_enable: bool) -> Self {
        self.anisotropy_enable = anisotropy_enable;
        self
    }
    ///Sets the `max_anisotropy` field in a builder way.
    pub fn with_max_anisotropy(mut self, max_anisotropy: f32) -> Self {
        self.max_anisotropy = max_anisotropy;
        self
    }
    ///Sets the `compare_enable` field in a builder way.
    pub fn with_compare_enable(mut self, compare_enable: bool) -> Self {
        self.compare_enable = compare_enable;
        self
    }
    ///Sets the `compare_op` field in a builder way.
    pub fn with_compare_op(mut self, compare_op: CompareOp) -> Self {
        self.compare_op = compare_op;
        self
    }
    ///Sets the `min_lod` field in a builder way.
    pub fn with_min_lod(mut self, min_lod: f32) -> Self {
        self.min_lod = min_lod;
        self
    }
    ///Sets the `max_lod` field in a builder way.
    pub fn with_max_lod(mut self, max_lod: f32) -> Self {
        self.max_lod = max_lod;
        self
    }
    ///Sets the `border_color` field in a builder way.
    pub fn with_border_color(mut self, border_color: BorderColor) -> Self {
        self.border_color = border_color;
        self
    }
    ///Sets the `unnormalized_coordinates` field in a builder way.
    pub fn with_unnormalized_coordinates(mut self, unnormalized_coordinates: bool) -> Self {
        self.unnormalized_coordinates = unnormalized_coordinates;
        self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for SamplerCreateInfo {
    type LowLevel = crate::native::vulkan1_0::SamplerCreateInfo;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        let mut next = std::ptr::null();
        let mut extensions = self.extensions.iter();
        while let Some(ext) = extensions.next() {
            let ext = ext.into_low_level(context, bump);
            (*ext).next = next;
            next = ext;
        }
        crate::native::vulkan1_0::SamplerCreateInfo {
            s_type: StructureType::SamplerCreateInfo,
            p_next: next,
            flags: self.flags.into_low_level(context, bump),
            mag_filter: self.mag_filter.into_low_level(context, bump),
            min_filter: self.min_filter.into_low_level(context, bump),
            mipmap_mode: self.mipmap_mode.into_low_level(context, bump),
            address_mode_u: self.address_mode_u.into_low_level(context, bump),
            address_mode_v: self.address_mode_v.into_low_level(context, bump),
            address_mode_w: self.address_mode_w.into_low_level(context, bump),
            mip_lod_bias: self.mip_lod_bias.into_low_level(context, bump),
            anisotropy_enable: self.anisotropy_enable.into_low_level(context, bump),
            max_anisotropy: self.max_anisotropy.into_low_level(context, bump),
            compare_enable: self.compare_enable.into_low_level(context, bump),
            compare_op: self.compare_op.into_low_level(context, bump),
            min_lod: self.min_lod.into_low_level(context, bump),
            max_lod: self.max_lod.into_low_level(context, bump),
            border_color: self.border_color.into_low_level(context, bump),
            unnormalized_coordinates: self.unnormalized_coordinates.into_low_level(context, bump),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for SamplerCreateInfo {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        let mut next = value.p_next;
        let mut extensions = SmallVec::new();
        while !next.is_null() {
            extensions.push(crate::conv::FromLowLevel::from_low_level(context, next));
            next = std::ptr::read(next).next;
        }
        Self {
            extensions: extensions,
            flags: crate::conv::FromLowLevel::from_low_level(context, value.flags),
            mag_filter: crate::conv::FromLowLevel::from_low_level(context, value.mag_filter),
            min_filter: crate::conv::FromLowLevel::from_low_level(context, value.min_filter),
            mipmap_mode: crate::conv::FromLowLevel::from_low_level(context, value.mipmap_mode),
            address_mode_u: crate::conv::FromLowLevel::from_low_level(context, value.address_mode_u),
            address_mode_v: crate::conv::FromLowLevel::from_low_level(context, value.address_mode_v),
            address_mode_w: crate::conv::FromLowLevel::from_low_level(context, value.address_mode_w),
            mip_lod_bias: crate::conv::FromLowLevel::from_low_level(context, value.mip_lod_bias),
            anisotropy_enable: crate::conv::FromLowLevel::from_low_level(context, value.anisotropy_enable),
            max_anisotropy: crate::conv::FromLowLevel::from_low_level(context, value.max_anisotropy),
            compare_enable: crate::conv::FromLowLevel::from_low_level(context, value.compare_enable),
            compare_op: crate::conv::FromLowLevel::from_low_level(context, value.compare_op),
            min_lod: crate::conv::FromLowLevel::from_low_level(context, value.min_lod),
            max_lod: crate::conv::FromLowLevel::from_low_level(context, value.max_lod),
            border_color: crate::conv::FromLowLevel::from_low_level(context, value.border_color),
            unnormalized_coordinates: crate::conv::FromLowLevel::from_low_level(
                context,
                value.unnormalized_coordinates,
            ),
        }
    }
}
#[derive(Clone, PartialEq, Debug)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
///Extensions for [`SamplerCreateInfo`]
pub enum SamplerCreateInfoExtension {
    ///Contains a type [`SamplerYcbcrConversionInfo`] for extending [`SamplerCreateInfo`]
    SamplerYcbcrConversionInfo(SamplerYcbcrConversionInfo),
    #[cfg(feature = "VULKAN_1_2")]
    ///Contains a type [`SamplerReductionModeCreateInfo`] for extending [`SamplerCreateInfo`]
    SamplerReductionModeCreateInfo(SamplerReductionModeCreateInfo),
    #[cfg(feature = "VK_EXT_custom_border_color")]
    ///Contains a type [`SamplerCustomBorderColorCreateInfoEXT`] for extending
    /// [`SamplerCreateInfo`]
    SamplerCustomBorderColorCreateInfoEXT(SamplerCustomBorderColorCreateInfoEXT),
    #[cfg(feature = "VK_EXT_border_color_swizzle")]
    ///Contains a type [`SamplerBorderColorComponentMappingCreateInfoEXT`] for extending
    /// [`SamplerCreateInfo`]
    SamplerBorderColorComponentMappingCreateInfoEXT(SamplerBorderColorComponentMappingCreateInfoEXT),
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for SamplerCreateInfoExtension {
    type LowLevel = *const crate::native::vulkan1_0::BaseInStructure;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        match self { Self :: SamplerYcbcrConversionInfo (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: vulkan1_1 :: SamplerYcbcrConversionInfo) . cast () , # [cfg (feature = "VULKAN_1_2")] Self :: SamplerReductionModeCreateInfo (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: vulkan1_2 :: SamplerReductionModeCreateInfo) . cast () , # [cfg (feature = "VK_EXT_custom_border_color")] Self :: SamplerCustomBorderColorCreateInfoEXT (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: ext_custom_border_color :: SamplerCustomBorderColorCreateInfoEXT) . cast () , # [cfg (feature = "VK_EXT_border_color_swizzle")] Self :: SamplerBorderColorComponentMappingCreateInfoEXT (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: ext_border_color_swizzle :: SamplerBorderColorComponentMappingCreateInfoEXT) . cast () , other => unreachable ! ("unexpected variant {:?}" , other) }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for SamplerCreateInfoExtension {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        assert!(!value.is_null());
        match (* value) . s_type { crate :: native :: vulkan1_0 :: StructureType :: SamplerYcbcrConversionInfo => Self :: SamplerYcbcrConversionInfo (SamplerYcbcrConversionInfo :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: vulkan1_1 :: SamplerYcbcrConversionInfo > ()))) , # [cfg (feature = "VULKAN_1_2")] crate :: native :: vulkan1_0 :: StructureType :: SamplerReductionModeCreateInfo => Self :: SamplerReductionModeCreateInfo (SamplerReductionModeCreateInfo :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: vulkan1_2 :: SamplerReductionModeCreateInfo > ()))) , # [cfg (feature = "VK_EXT_custom_border_color")] crate :: native :: vulkan1_0 :: StructureType :: SamplerCustomBorderColorCreateInfoExt => Self :: SamplerCustomBorderColorCreateInfoEXT (SamplerCustomBorderColorCreateInfoEXT :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: ext_custom_border_color :: SamplerCustomBorderColorCreateInfoEXT > ()))) , # [cfg (feature = "VK_EXT_border_color_swizzle")] crate :: native :: vulkan1_0 :: StructureType :: SamplerBorderColorComponentMappingCreateInfoExt => Self :: SamplerBorderColorComponentMappingCreateInfoEXT (SamplerBorderColorComponentMappingCreateInfoEXT :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: ext_border_color_swizzle :: SamplerBorderColorComponentMappingCreateInfoEXT > ()))) , other => panic ! ("Structure type {:?} is not a member of {}" , other , stringify ! (SamplerCreateInfo)) }
    }
}
impl From<SamplerYcbcrConversionInfo> for SamplerCreateInfoExtension {
    fn from(ext: SamplerYcbcrConversionInfo) -> Self {
        Self::SamplerYcbcrConversionInfo(ext)
    }
}
impl TryInto<SamplerYcbcrConversionInfo> for SamplerCreateInfoExtension {
    type Error = SamplerCreateInfoExtension;
    fn try_into(self) -> Result<SamplerYcbcrConversionInfo, Self::Error> {
        match self {
            Self::SamplerYcbcrConversionInfo(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VULKAN_1_2")]
impl From<SamplerReductionModeCreateInfo> for SamplerCreateInfoExtension {
    fn from(ext: SamplerReductionModeCreateInfo) -> Self {
        Self::SamplerReductionModeCreateInfo(ext)
    }
}
#[cfg(feature = "VULKAN_1_2")]
impl TryInto<SamplerReductionModeCreateInfo> for SamplerCreateInfoExtension {
    type Error = SamplerCreateInfoExtension;
    fn try_into(self) -> Result<SamplerReductionModeCreateInfo, Self::Error> {
        match self {
            Self::SamplerReductionModeCreateInfo(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_EXT_custom_border_color")]
impl From<SamplerCustomBorderColorCreateInfoEXT> for SamplerCreateInfoExtension {
    fn from(ext: SamplerCustomBorderColorCreateInfoEXT) -> Self {
        Self::SamplerCustomBorderColorCreateInfoEXT(ext)
    }
}
#[cfg(feature = "VK_EXT_custom_border_color")]
impl TryInto<SamplerCustomBorderColorCreateInfoEXT> for SamplerCreateInfoExtension {
    type Error = SamplerCreateInfoExtension;
    fn try_into(self) -> Result<SamplerCustomBorderColorCreateInfoEXT, Self::Error> {
        match self {
            Self::SamplerCustomBorderColorCreateInfoEXT(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_EXT_border_color_swizzle")]
impl From<SamplerBorderColorComponentMappingCreateInfoEXT> for SamplerCreateInfoExtension {
    fn from(ext: SamplerBorderColorComponentMappingCreateInfoEXT) -> Self {
        Self::SamplerBorderColorComponentMappingCreateInfoEXT(ext)
    }
}
#[cfg(feature = "VK_EXT_border_color_swizzle")]
impl TryInto<SamplerBorderColorComponentMappingCreateInfoEXT> for SamplerCreateInfoExtension {
    type Error = SamplerCreateInfoExtension;
    fn try_into(self) -> Result<SamplerBorderColorComponentMappingCreateInfoEXT, Self::Error> {
        match self {
            Self::SamplerBorderColorComponentMappingCreateInfoEXT(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[doc(alias = "VkCommandPoolCreateInfo")]
#[derive(Clone, PartialEq, Debug, Copy, Default)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct CommandPoolCreateInfo {
    pub flags: CommandPoolCreateFlags,
    #[doc(alias = "queueFamilyIndex")]
    pub queue_family_index: u32,
}
impl CommandPoolCreateInfo {
    ///Get a reference to the `flags` field.
    pub fn flags(&self) -> CommandPoolCreateFlags {
        self.flags
    }
    ///Get a reference to the `queue_family_index` field.
    pub fn queue_family_index(&self) -> u32 {
        self.queue_family_index
    }
    ///Get a mutable reference to the `flags` field.
    pub fn flags_mut(&mut self) -> &mut CommandPoolCreateFlags {
        &mut self.flags
    }
    ///Get a mutable reference to the `queue_family_index` field.
    pub fn queue_family_index_mut(&mut self) -> &mut u32 {
        &mut self.queue_family_index
    }
    ///Sets the `flags` field.
    pub fn set_flags(&mut self, flags: CommandPoolCreateFlags) -> &mut Self {
        self.flags = flags;
        self
    }
    ///Sets the `queue_family_index` field.
    pub fn set_queue_family_index(&mut self, queue_family_index: u32) -> &mut Self {
        self.queue_family_index = queue_family_index;
        self
    }
    ///Sets the `flags` field in a builder way.
    pub fn with_flags(mut self, flags: CommandPoolCreateFlags) -> Self {
        self.flags = flags;
        self
    }
    ///Sets the `queue_family_index` field in a builder way.
    pub fn with_queue_family_index(mut self, queue_family_index: u32) -> Self {
        self.queue_family_index = queue_family_index;
        self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for CommandPoolCreateInfo {
    type LowLevel = crate::native::vulkan1_0::CommandPoolCreateInfo;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        crate::native::vulkan1_0::CommandPoolCreateInfo {
            s_type: StructureType::CommandPoolCreateInfo,
            p_next: std::ptr::null(),
            flags: self.flags.into_low_level(context, bump),
            queue_family_index: self.queue_family_index.into_low_level(context, bump),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for CommandPoolCreateInfo {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        Self {
            flags: crate::conv::FromLowLevel::from_low_level(context, value.flags),
            queue_family_index: crate::conv::FromLowLevel::from_low_level(context, value.queue_family_index),
        }
    }
}
#[doc(alias = "VkCommandBufferAllocateInfo")]
#[derive(Clone, PartialEq, Debug)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct CommandBufferAllocateInfo {
    #[doc(alias = "commandPool")]
    pub command_pool: CommandPool,
    pub level: CommandBufferLevel,
    #[doc(alias = "commandBufferCount")]
    pub command_buffer_count: u32,
}
impl CommandBufferAllocateInfo {
    ///Get a reference to the `command_pool` field.
    pub fn command_pool(&self) -> &CommandPool {
        &self.command_pool
    }
    ///Get a reference to the `level` field.
    pub fn level(&self) -> CommandBufferLevel {
        self.level
    }
    ///Get a reference to the `command_buffer_count` field.
    pub fn command_buffer_count(&self) -> u32 {
        self.command_buffer_count
    }
    ///Get a mutable reference to the `command_pool` field.
    pub fn command_pool_mut(&mut self) -> &mut CommandPool {
        &mut self.command_pool
    }
    ///Get a mutable reference to the `level` field.
    pub fn level_mut(&mut self) -> &mut CommandBufferLevel {
        &mut self.level
    }
    ///Get a mutable reference to the `command_buffer_count` field.
    pub fn command_buffer_count_mut(&mut self) -> &mut u32 {
        &mut self.command_buffer_count
    }
    ///Sets the `command_pool` field.
    pub fn set_command_pool(&mut self, command_pool: CommandPool) -> &mut Self {
        self.command_pool = command_pool;
        self
    }
    ///Sets the `level` field.
    pub fn set_level(&mut self, level: CommandBufferLevel) -> &mut Self {
        self.level = level;
        self
    }
    ///Sets the `command_buffer_count` field.
    pub fn set_command_buffer_count(&mut self, command_buffer_count: u32) -> &mut Self {
        self.command_buffer_count = command_buffer_count;
        self
    }
    ///Sets the `command_pool` field in a builder way.
    pub fn with_command_pool(mut self, command_pool: CommandPool) -> Self {
        self.command_pool = command_pool;
        self
    }
    ///Sets the `level` field in a builder way.
    pub fn with_level(mut self, level: CommandBufferLevel) -> Self {
        self.level = level;
        self
    }
    ///Sets the `command_buffer_count` field in a builder way.
    pub fn with_command_buffer_count(mut self, command_buffer_count: u32) -> Self {
        self.command_buffer_count = command_buffer_count;
        self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for CommandBufferAllocateInfo {
    type LowLevel = crate::native::vulkan1_0::CommandBufferAllocateInfo;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        crate::native::vulkan1_0::CommandBufferAllocateInfo {
            s_type: StructureType::CommandBufferAllocateInfo,
            p_next: std::ptr::null(),
            command_pool: self.command_pool.into_low_level(context, bump),
            level: self.level.into_low_level(context, bump),
            command_buffer_count: self.command_buffer_count.into_low_level(context, bump),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for CommandBufferAllocateInfo {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        Self {
            command_pool: crate::conv::FromLowLevel::from_low_level(context, value.command_pool),
            level: crate::conv::FromLowLevel::from_low_level(context, value.level),
            command_buffer_count: crate::conv::FromLowLevel::from_low_level(context, value.command_buffer_count),
        }
    }
}
#[doc(alias = "VkCommandBufferInheritanceInfo")]
#[derive(Clone, PartialEq, Debug, Default)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct CommandBufferInheritanceInfo {
    #[doc(alias = "pNext")]
    pub extensions: SmallVec<[CommandBufferInheritanceInfoExtension; 1]>,
    #[doc(alias = "renderPass")]
    pub render_pass: Option<RenderPass>,
    pub subpass: u32,
    pub framebuffer: Option<Framebuffer>,
    #[doc(alias = "occlusionQueryEnable")]
    pub occlusion_query_enable: bool,
    #[doc(alias = "queryFlags")]
    pub query_flags: QueryControlFlags,
    #[doc(alias = "pipelineStatistics")]
    pub pipeline_statistics: QueryPipelineStatisticFlags,
}
impl CommandBufferInheritanceInfo {
    ///Adds an extension to the struct
    pub fn with_extension(mut self, ext: impl Into<CommandBufferInheritanceInfoExtension>) -> Self {
        self.extensions.push(ext.into());
        self
    }
    ///Get a reference to the `extensions` field.
    pub fn extensions(&self) -> &SmallVec<[CommandBufferInheritanceInfoExtension; 1]> {
        &self.extensions
    }
    ///Get a reference to the `render_pass` field.
    pub fn render_pass(&self) -> &Option<RenderPass> {
        &self.render_pass
    }
    ///Get a reference to the `subpass` field.
    pub fn subpass(&self) -> u32 {
        self.subpass
    }
    ///Get a reference to the `framebuffer` field.
    pub fn framebuffer(&self) -> &Option<Framebuffer> {
        &self.framebuffer
    }
    ///Get a reference to the `occlusion_query_enable` field.
    pub fn occlusion_query_enable(&self) -> &bool {
        &self.occlusion_query_enable
    }
    ///Get a reference to the `query_flags` field.
    pub fn query_flags(&self) -> QueryControlFlags {
        self.query_flags
    }
    ///Get a reference to the `pipeline_statistics` field.
    pub fn pipeline_statistics(&self) -> QueryPipelineStatisticFlags {
        self.pipeline_statistics
    }
    ///Get a mutable reference to the `extensions` field.
    pub fn extensions_mut(&mut self) -> &mut SmallVec<[CommandBufferInheritanceInfoExtension; 1]> {
        &mut self.extensions
    }
    ///Get a mutable reference to the `render_pass` field.
    pub fn render_pass_mut(&mut self) -> &mut Option<RenderPass> {
        &mut self.render_pass
    }
    ///Get a mutable reference to the `subpass` field.
    pub fn subpass_mut(&mut self) -> &mut u32 {
        &mut self.subpass
    }
    ///Get a mutable reference to the `framebuffer` field.
    pub fn framebuffer_mut(&mut self) -> &mut Option<Framebuffer> {
        &mut self.framebuffer
    }
    ///Get a mutable reference to the `occlusion_query_enable` field.
    pub fn occlusion_query_enable_mut(&mut self) -> &mut bool {
        &mut self.occlusion_query_enable
    }
    ///Get a mutable reference to the `query_flags` field.
    pub fn query_flags_mut(&mut self) -> &mut QueryControlFlags {
        &mut self.query_flags
    }
    ///Get a mutable reference to the `pipeline_statistics` field.
    pub fn pipeline_statistics_mut(&mut self) -> &mut QueryPipelineStatisticFlags {
        &mut self.pipeline_statistics
    }
    ///Sets the `extensions` field.
    pub fn set_extensions(&mut self, extensions: SmallVec<[CommandBufferInheritanceInfoExtension; 1]>) -> &mut Self {
        self.extensions = extensions;
        self
    }
    ///Sets the `render_pass` field.
    pub fn set_render_pass(&mut self, render_pass: Option<RenderPass>) -> &mut Self {
        self.render_pass = render_pass;
        self
    }
    ///Sets the `subpass` field.
    pub fn set_subpass(&mut self, subpass: u32) -> &mut Self {
        self.subpass = subpass;
        self
    }
    ///Sets the `framebuffer` field.
    pub fn set_framebuffer(&mut self, framebuffer: Option<Framebuffer>) -> &mut Self {
        self.framebuffer = framebuffer;
        self
    }
    ///Sets the `occlusion_query_enable` field.
    pub fn set_occlusion_query_enable(&mut self, occlusion_query_enable: bool) -> &mut Self {
        self.occlusion_query_enable = occlusion_query_enable;
        self
    }
    ///Sets the `query_flags` field.
    pub fn set_query_flags(&mut self, query_flags: QueryControlFlags) -> &mut Self {
        self.query_flags = query_flags;
        self
    }
    ///Sets the `pipeline_statistics` field.
    pub fn set_pipeline_statistics(&mut self, pipeline_statistics: QueryPipelineStatisticFlags) -> &mut Self {
        self.pipeline_statistics = pipeline_statistics;
        self
    }
    ///Sets the `extensions` field in a builder way.
    pub fn with_extensions(mut self, extensions: SmallVec<[CommandBufferInheritanceInfoExtension; 1]>) -> Self {
        self.extensions = extensions;
        self
    }
    ///Sets the `render_pass` field in a builder way.
    pub fn with_render_pass(mut self, render_pass: Option<RenderPass>) -> Self {
        self.render_pass = render_pass;
        self
    }
    ///Sets the `subpass` field in a builder way.
    pub fn with_subpass(mut self, subpass: u32) -> Self {
        self.subpass = subpass;
        self
    }
    ///Sets the `framebuffer` field in a builder way.
    pub fn with_framebuffer(mut self, framebuffer: Option<Framebuffer>) -> Self {
        self.framebuffer = framebuffer;
        self
    }
    ///Sets the `occlusion_query_enable` field in a builder way.
    pub fn with_occlusion_query_enable(mut self, occlusion_query_enable: bool) -> Self {
        self.occlusion_query_enable = occlusion_query_enable;
        self
    }
    ///Sets the `query_flags` field in a builder way.
    pub fn with_query_flags(mut self, query_flags: QueryControlFlags) -> Self {
        self.query_flags = query_flags;
        self
    }
    ///Sets the `pipeline_statistics` field in a builder way.
    pub fn with_pipeline_statistics(mut self, pipeline_statistics: QueryPipelineStatisticFlags) -> Self {
        self.pipeline_statistics = pipeline_statistics;
        self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for CommandBufferInheritanceInfo {
    type LowLevel = crate::native::vulkan1_0::CommandBufferInheritanceInfo;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        let mut next = std::ptr::null();
        let mut extensions = self.extensions.iter();
        while let Some(ext) = extensions.next() {
            let ext = ext.into_low_level(context, bump);
            (*ext).next = next;
            next = ext;
        }
        crate::native::vulkan1_0::CommandBufferInheritanceInfo {
            s_type: StructureType::CommandBufferInheritanceInfo,
            p_next: next,
            render_pass: self
                .render_pass
                .as_ref()
                .map(|v| v.into_low_level(context, bump))
                .unwrap_or_else(Default::default),
            subpass: self.subpass.into_low_level(context, bump),
            framebuffer: self
                .framebuffer
                .as_ref()
                .map(|v| v.into_low_level(context, bump))
                .unwrap_or_else(Default::default),
            occlusion_query_enable: self.occlusion_query_enable.into_low_level(context, bump),
            query_flags: self.query_flags.into_low_level(context, bump),
            pipeline_statistics: self.pipeline_statistics.into_low_level(context, bump),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for CommandBufferInheritanceInfo {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        let mut next = value.p_next;
        let mut extensions = SmallVec::new();
        while !next.is_null() {
            extensions.push(crate::conv::FromLowLevel::from_low_level(context, next));
            next = std::ptr::read(next).next;
        }
        Self {
            extensions: extensions,
            render_pass: if value.render_pass == crate::native::vulkan1_0::RenderPass::null() {
                None
            } else {
                Some(crate::conv::FromLowLevel::from_low_level(context, value.render_pass))
            },
            subpass: crate::conv::FromLowLevel::from_low_level(context, value.subpass),
            framebuffer: if value.framebuffer == crate::native::vulkan1_0::Framebuffer::null() {
                None
            } else {
                Some(crate::conv::FromLowLevel::from_low_level(context, value.framebuffer))
            },
            occlusion_query_enable: crate::conv::FromLowLevel::from_low_level(context, value.occlusion_query_enable),
            query_flags: crate::conv::FromLowLevel::from_low_level(context, value.query_flags),
            pipeline_statistics: crate::conv::FromLowLevel::from_low_level(context, value.pipeline_statistics),
        }
    }
}
#[derive(Clone, PartialEq, Debug)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
///Extensions for [`CommandBufferInheritanceInfo`]
pub enum CommandBufferInheritanceInfoExtension {
    #[cfg(feature = "VK_EXT_conditional_rendering")]
    ///Contains a type [`CommandBufferInheritanceConditionalRenderingInfoEXT`] for extending
    /// [`CommandBufferInheritanceInfo`]
    CommandBufferInheritanceConditionalRenderingInfoEXT(CommandBufferInheritanceConditionalRenderingInfoEXT),
    #[cfg(feature = "VK_NV_inherited_viewport_scissor")]
    ///Contains a type [`CommandBufferInheritanceViewportScissorInfoNV`] for extending
    /// [`CommandBufferInheritanceInfo`]
    CommandBufferInheritanceViewportScissorInfoNV(CommandBufferInheritanceViewportScissorInfoNV),
    #[cfg(feature = "VULKAN_1_3")]
    ///Contains a type [`CommandBufferInheritanceRenderingInfo`] for extending
    /// [`CommandBufferInheritanceInfo`]
    CommandBufferInheritanceRenderingInfo(CommandBufferInheritanceRenderingInfo),
    #[cfg(feature = "VK_KHR_dynamic_rendering")]
    ///Contains a type [`AttachmentSampleCountInfoAMD`] for extending
    /// [`CommandBufferInheritanceInfo`]
    AttachmentSampleCountInfoAMD(AttachmentSampleCountInfoAMD),
    #[cfg(feature = "VK_KHR_dynamic_rendering")]
    ///Contains a type [`MultiviewPerViewAttributesInfoNVX`] for extending
    /// [`CommandBufferInheritanceInfo`]
    MultiviewPerViewAttributesInfoNVX(MultiviewPerViewAttributesInfoNVX),
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for CommandBufferInheritanceInfoExtension {
    type LowLevel = *const crate::native::vulkan1_0::BaseInStructure;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        match self { # [cfg (feature = "VK_EXT_conditional_rendering")] Self :: CommandBufferInheritanceConditionalRenderingInfoEXT (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: ext_conditional_rendering :: CommandBufferInheritanceConditionalRenderingInfoEXT) . cast () , # [cfg (feature = "VK_NV_inherited_viewport_scissor")] Self :: CommandBufferInheritanceViewportScissorInfoNV (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: nv_inherited_viewport_scissor :: CommandBufferInheritanceViewportScissorInfoNV) . cast () , # [cfg (feature = "VULKAN_1_3")] Self :: CommandBufferInheritanceRenderingInfo (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: vulkan1_3 :: CommandBufferInheritanceRenderingInfo) . cast () , # [cfg (feature = "VK_KHR_dynamic_rendering")] Self :: AttachmentSampleCountInfoAMD (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: khr_dynamic_rendering :: AttachmentSampleCountInfoAMD) . cast () , # [cfg (feature = "VK_KHR_dynamic_rendering")] Self :: MultiviewPerViewAttributesInfoNVX (ext) => (bump . alloc (ext . into_low_level (context , bump)) as * mut crate :: native :: extensions :: khr_dynamic_rendering :: MultiviewPerViewAttributesInfoNVX) . cast () , other => unreachable ! ("unexpected variant {:?}" , other) }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for CommandBufferInheritanceInfoExtension {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        assert!(!value.is_null());
        match (* value) . s_type { # [cfg (feature = "VK_EXT_conditional_rendering")] crate :: native :: vulkan1_0 :: StructureType :: CommandBufferInheritanceConditionalRenderingInfoExt => Self :: CommandBufferInheritanceConditionalRenderingInfoEXT (CommandBufferInheritanceConditionalRenderingInfoEXT :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: ext_conditional_rendering :: CommandBufferInheritanceConditionalRenderingInfoEXT > ()))) , # [cfg (feature = "VK_NV_inherited_viewport_scissor")] crate :: native :: vulkan1_0 :: StructureType :: CommandBufferInheritanceViewportScissorInfoNv => Self :: CommandBufferInheritanceViewportScissorInfoNV (CommandBufferInheritanceViewportScissorInfoNV :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: nv_inherited_viewport_scissor :: CommandBufferInheritanceViewportScissorInfoNV > ()))) , # [cfg (feature = "VULKAN_1_3")] crate :: native :: vulkan1_0 :: StructureType :: CommandBufferInheritanceRenderingInfo => Self :: CommandBufferInheritanceRenderingInfo (CommandBufferInheritanceRenderingInfo :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: vulkan1_3 :: CommandBufferInheritanceRenderingInfo > ()))) , # [cfg (feature = "VK_KHR_dynamic_rendering")] crate :: native :: vulkan1_0 :: StructureType :: AttachmentSampleCountInfoAmd => Self :: AttachmentSampleCountInfoAMD (AttachmentSampleCountInfoAMD :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: khr_dynamic_rendering :: AttachmentSampleCountInfoAMD > ()))) , # [cfg (feature = "VK_KHR_dynamic_rendering")] crate :: native :: vulkan1_0 :: StructureType :: MultiviewPerViewAttributesInfoNvx => Self :: MultiviewPerViewAttributesInfoNVX (MultiviewPerViewAttributesInfoNVX :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: khr_dynamic_rendering :: MultiviewPerViewAttributesInfoNVX > ()))) , other => panic ! ("Structure type {:?} is not a member of {}" , other , stringify ! (CommandBufferInheritanceInfo)) }
    }
}
#[cfg(feature = "VK_EXT_conditional_rendering")]
impl From<CommandBufferInheritanceConditionalRenderingInfoEXT> for CommandBufferInheritanceInfoExtension {
    fn from(ext: CommandBufferInheritanceConditionalRenderingInfoEXT) -> Self {
        Self::CommandBufferInheritanceConditionalRenderingInfoEXT(ext)
    }
}
#[cfg(feature = "VK_EXT_conditional_rendering")]
impl TryInto<CommandBufferInheritanceConditionalRenderingInfoEXT> for CommandBufferInheritanceInfoExtension {
    type Error = CommandBufferInheritanceInfoExtension;
    fn try_into(self) -> Result<CommandBufferInheritanceConditionalRenderingInfoEXT, Self::Error> {
        match self {
            Self::CommandBufferInheritanceConditionalRenderingInfoEXT(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_NV_inherited_viewport_scissor")]
impl From<CommandBufferInheritanceViewportScissorInfoNV> for CommandBufferInheritanceInfoExtension {
    fn from(ext: CommandBufferInheritanceViewportScissorInfoNV) -> Self {
        Self::CommandBufferInheritanceViewportScissorInfoNV(ext)
    }
}
#[cfg(feature = "VK_NV_inherited_viewport_scissor")]
impl TryInto<CommandBufferInheritanceViewportScissorInfoNV> for CommandBufferInheritanceInfoExtension {
    type Error = CommandBufferInheritanceInfoExtension;
    fn try_into(self) -> Result<CommandBufferInheritanceViewportScissorInfoNV, Self::Error> {
        match self {
            Self::CommandBufferInheritanceViewportScissorInfoNV(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VULKAN_1_3")]
impl From<CommandBufferInheritanceRenderingInfo> for CommandBufferInheritanceInfoExtension {
    fn from(ext: CommandBufferInheritanceRenderingInfo) -> Self {
        Self::CommandBufferInheritanceRenderingInfo(ext)
    }
}
#[cfg(feature = "VULKAN_1_3")]
impl TryInto<CommandBufferInheritanceRenderingInfo> for CommandBufferInheritanceInfoExtension {
    type Error = CommandBufferInheritanceInfoExtension;
    fn try_into(self) -> Result<CommandBufferInheritanceRenderingInfo, Self::Error> {
        match self {
            Self::CommandBufferInheritanceRenderingInfo(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_KHR_dynamic_rendering")]
impl From<AttachmentSampleCountInfoAMD> for CommandBufferInheritanceInfoExtension {
    fn from(ext: AttachmentSampleCountInfoAMD) -> Self {
        Self::AttachmentSampleCountInfoAMD(ext)
    }
}
#[cfg(feature = "VK_KHR_dynamic_rendering")]
impl TryInto<AttachmentSampleCountInfoAMD> for CommandBufferInheritanceInfoExtension {
    type Error = CommandBufferInheritanceInfoExtension;
    fn try_into(self) -> Result<AttachmentSampleCountInfoAMD, Self::Error> {
        match self {
            Self::AttachmentSampleCountInfoAMD(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_KHR_dynamic_rendering")]
impl From<MultiviewPerViewAttributesInfoNVX> for CommandBufferInheritanceInfoExtension {
    fn from(ext: MultiviewPerViewAttributesInfoNVX) -> Self {
        Self::MultiviewPerViewAttributesInfoNVX(ext)
    }
}
#[cfg(feature = "VK_KHR_dynamic_rendering")]
impl TryInto<MultiviewPerViewAttributesInfoNVX> for CommandBufferInheritanceInfoExtension {
    type Error = CommandBufferInheritanceInfoExtension;
    fn try_into(self) -> Result<MultiviewPerViewAttributesInfoNVX, Self::Error> {
        match self {
            Self::MultiviewPerViewAttributesInfoNVX(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[doc(alias = "VkCommandBufferBeginInfo")]
#[derive(Clone, PartialEq, Debug, Default)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct CommandBufferBeginInfo {
    #[doc(alias = "pNext")]
    pub extensions: SmallVec<[CommandBufferBeginInfoExtension; 1]>,
    pub flags: CommandBufferUsageFlags,
    #[doc(alias = "pInheritanceInfo")]
    pub inheritance_info: Option<CommandBufferInheritanceInfo>,
}
impl CommandBufferBeginInfo {
    ///Adds an extension to the struct
    pub fn with_extension(mut self, ext: impl Into<CommandBufferBeginInfoExtension>) -> Self {
        self.extensions.push(ext.into());
        self
    }
    ///Get a reference to the `extensions` field.
    pub fn extensions(&self) -> &SmallVec<[CommandBufferBeginInfoExtension; 1]> {
        &self.extensions
    }
    ///Get a reference to the `flags` field.
    pub fn flags(&self) -> CommandBufferUsageFlags {
        self.flags
    }
    ///Get a reference to the `inheritance_info` field.
    pub fn inheritance_info(&self) -> &Option<CommandBufferInheritanceInfo> {
        &self.inheritance_info
    }
    ///Get a mutable reference to the `extensions` field.
    pub fn extensions_mut(&mut self) -> &mut SmallVec<[CommandBufferBeginInfoExtension; 1]> {
        &mut self.extensions
    }
    ///Get a mutable reference to the `flags` field.
    pub fn flags_mut(&mut self) -> &mut CommandBufferUsageFlags {
        &mut self.flags
    }
    ///Get a mutable reference to the `inheritance_info` field.
    pub fn inheritance_info_mut(&mut self) -> &mut Option<CommandBufferInheritanceInfo> {
        &mut self.inheritance_info
    }
    ///Sets the `extensions` field.
    pub fn set_extensions(&mut self, extensions: SmallVec<[CommandBufferBeginInfoExtension; 1]>) -> &mut Self {
        self.extensions = extensions;
        self
    }
    ///Sets the `flags` field.
    pub fn set_flags(&mut self, flags: CommandBufferUsageFlags) -> &mut Self {
        self.flags = flags;
        self
    }
    ///Sets the `inheritance_info` field.
    pub fn set_inheritance_info(&mut self, inheritance_info: Option<CommandBufferInheritanceInfo>) -> &mut Self {
        self.inheritance_info = inheritance_info;
        self
    }
    ///Sets the `extensions` field in a builder way.
    pub fn with_extensions(mut self, extensions: SmallVec<[CommandBufferBeginInfoExtension; 1]>) -> Self {
        self.extensions = extensions;
        self
    }
    ///Sets the `flags` field in a builder way.
    pub fn with_flags(mut self, flags: CommandBufferUsageFlags) -> Self {
        self.flags = flags;
        self
    }
    ///Sets the `inheritance_info` field in a builder way.
    pub fn with_inheritance_info(mut self, inheritance_info: Option<CommandBufferInheritanceInfo>) -> Self {
        self.inheritance_info = inheritance_info;
        self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for CommandBufferBeginInfo {
    type LowLevel = crate::native::vulkan1_0::CommandBufferBeginInfo;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        let mut next = std::ptr::null();
        let mut extensions = self.extensions.iter();
        while let Some(ext) = extensions.next() {
            let ext = ext.into_low_level(context, bump);
            (*ext).next = next;
            next = ext;
        }
        crate::native::vulkan1_0::CommandBufferBeginInfo {
            s_type: StructureType::CommandBufferBeginInfo,
            p_next: next,
            flags: self.flags.into_low_level(context, bump),
            inheritance_info: self
                .inheritance_info
                .as_ref()
                .map(|v| bump.alloc(v.into_low_level(context, bump)) as *const _)
                .unwrap_or_else(std::ptr::null),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for CommandBufferBeginInfo {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        let mut next = value.p_next;
        let mut extensions = SmallVec::new();
        while !next.is_null() {
            extensions.push(crate::conv::FromLowLevel::from_low_level(context, next));
            next = std::ptr::read(next).next;
        }
        Self {
            extensions: extensions,
            flags: crate::conv::FromLowLevel::from_low_level(context, value.flags),
            inheritance_info: crate::conv::FromLowLevel::from_low_level(context, *value.inheritance_info),
        }
    }
}
#[derive(Clone, PartialEq, Debug, Copy)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
///Extensions for [`CommandBufferBeginInfo`]
pub enum CommandBufferBeginInfoExtension {
    ///Contains a type [`DeviceGroupCommandBufferBeginInfo`] for extending
    /// [`CommandBufferBeginInfo`]
    DeviceGroupCommandBufferBeginInfo(DeviceGroupCommandBufferBeginInfo),
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for CommandBufferBeginInfoExtension {
    type LowLevel = *const crate::native::vulkan1_0::BaseInStructure;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        match self {
            Self::DeviceGroupCommandBufferBeginInfo(ext) => (bump.alloc(ext.into_low_level(context, bump))
                as *mut crate::native::vulkan1_1::DeviceGroupCommandBufferBeginInfo)
                .cast(),
            other => unreachable!("unexpected variant {:?}", other),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for CommandBufferBeginInfoExtension {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        assert!(!value.is_null());
        match (*value).s_type {
            crate::native::vulkan1_0::StructureType::DeviceGroupCommandBufferBeginInfo => {
                Self::DeviceGroupCommandBufferBeginInfo(DeviceGroupCommandBufferBeginInfo::from_low_level(
                    context,
                    std::ptr::read(value.cast::<crate::native::vulkan1_1::DeviceGroupCommandBufferBeginInfo>()),
                ))
            },
            other => panic!(
                "Structure type {:?} is not a member of {}",
                other,
                stringify!(CommandBufferBeginInfo)
            ),
        }
    }
}
impl From<DeviceGroupCommandBufferBeginInfo> for CommandBufferBeginInfoExtension {
    fn from(ext: DeviceGroupCommandBufferBeginInfo) -> Self {
        Self::DeviceGroupCommandBufferBeginInfo(ext)
    }
}
impl TryInto<DeviceGroupCommandBufferBeginInfo> for CommandBufferBeginInfoExtension {
    type Error = CommandBufferBeginInfoExtension;
    fn try_into(self) -> Result<DeviceGroupCommandBufferBeginInfo, Self::Error> {
        match self {
            Self::DeviceGroupCommandBufferBeginInfo(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[doc(alias = "VkRenderPassBeginInfo")]
#[derive(Clone, PartialEq, Debug)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct RenderPassBeginInfo {
    #[doc(alias = "pNext")]
    pub extensions: SmallVec<[RenderPassBeginInfoExtension; 1]>,
    #[doc(alias = "renderPass")]
    pub render_pass: RenderPass,
    pub framebuffer: Framebuffer,
    #[doc(alias = "renderArea")]
    pub render_area: Rect2D,
    #[doc(alias = "pClearValues")]
    pub clear_values: SmallVec<[ClearValue; 8]>,
}
impl RenderPassBeginInfo {
    ///Adds an extension to the struct
    pub fn with_extension(mut self, ext: impl Into<RenderPassBeginInfoExtension>) -> Self {
        self.extensions.push(ext.into());
        self
    }
    ///Get a reference to the `extensions` field.
    pub fn extensions(&self) -> &SmallVec<[RenderPassBeginInfoExtension; 1]> {
        &self.extensions
    }
    ///Get a reference to the `render_pass` field.
    pub fn render_pass(&self) -> &RenderPass {
        &self.render_pass
    }
    ///Get a reference to the `framebuffer` field.
    pub fn framebuffer(&self) -> &Framebuffer {
        &self.framebuffer
    }
    ///Get a reference to the `render_area` field.
    pub fn render_area(&self) -> Rect2D {
        self.render_area
    }
    ///Get a reference to the `clear_values` field.
    pub fn clear_values(&self) -> &SmallVec<[ClearValue; 8]> {
        &self.clear_values
    }
    ///Get a mutable reference to the `extensions` field.
    pub fn extensions_mut(&mut self) -> &mut SmallVec<[RenderPassBeginInfoExtension; 1]> {
        &mut self.extensions
    }
    ///Get a mutable reference to the `render_pass` field.
    pub fn render_pass_mut(&mut self) -> &mut RenderPass {
        &mut self.render_pass
    }
    ///Get a mutable reference to the `framebuffer` field.
    pub fn framebuffer_mut(&mut self) -> &mut Framebuffer {
        &mut self.framebuffer
    }
    ///Get a mutable reference to the `render_area` field.
    pub fn render_area_mut(&mut self) -> &mut Rect2D {
        &mut self.render_area
    }
    ///Get a mutable reference to the `clear_values` field.
    pub fn clear_values_mut(&mut self) -> &mut SmallVec<[ClearValue; 8]> {
        &mut self.clear_values
    }
    ///Sets the `extensions` field.
    pub fn set_extensions(&mut self, extensions: SmallVec<[RenderPassBeginInfoExtension; 1]>) -> &mut Self {
        self.extensions = extensions;
        self
    }
    ///Sets the `render_pass` field.
    pub fn set_render_pass(&mut self, render_pass: RenderPass) -> &mut Self {
        self.render_pass = render_pass;
        self
    }
    ///Sets the `framebuffer` field.
    pub fn set_framebuffer(&mut self, framebuffer: Framebuffer) -> &mut Self {
        self.framebuffer = framebuffer;
        self
    }
    ///Sets the `render_area` field.
    pub fn set_render_area(&mut self, render_area: Rect2D) -> &mut Self {
        self.render_area = render_area;
        self
    }
    ///Sets the `clear_values` field.
    pub fn set_clear_values(&mut self, clear_values: SmallVec<[ClearValue; 8]>) -> &mut Self {
        self.clear_values = clear_values;
        self
    }
    ///Sets the `extensions` field in a builder way.
    pub fn with_extensions(mut self, extensions: SmallVec<[RenderPassBeginInfoExtension; 1]>) -> Self {
        self.extensions = extensions;
        self
    }
    ///Sets the `render_pass` field in a builder way.
    pub fn with_render_pass(mut self, render_pass: RenderPass) -> Self {
        self.render_pass = render_pass;
        self
    }
    ///Sets the `framebuffer` field in a builder way.
    pub fn with_framebuffer(mut self, framebuffer: Framebuffer) -> Self {
        self.framebuffer = framebuffer;
        self
    }
    ///Sets the `render_area` field in a builder way.
    pub fn with_render_area(mut self, render_area: Rect2D) -> Self {
        self.render_area = render_area;
        self
    }
    ///Sets the `clear_values` field in a builder way.
    pub fn with_clear_values(mut self, clear_values: SmallVec<[ClearValue; 8]>) -> Self {
        self.clear_values = clear_values;
        self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for RenderPassBeginInfo {
    type LowLevel = crate::native::vulkan1_0::RenderPassBeginInfo;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        let mut next = std::ptr::null();
        let mut extensions = self.extensions.iter();
        while let Some(ext) = extensions.next() {
            let ext = ext.into_low_level(context, bump);
            (*ext).next = next;
            next = ext;
        }
        let len_clear_values = self.clear_values.len() as u32;
        let clear_values = bump
            .alloc_slice_fill_iter(self.clear_values.iter().map(|x| x.into_low_level(context, bump)))
            .as_ptr()
            .cast();
        crate::native::vulkan1_0::RenderPassBeginInfo {
            s_type: StructureType::RenderPassBeginInfo,
            p_next: next,
            render_pass: self.render_pass.into_low_level(context, bump),
            framebuffer: self.framebuffer.into_low_level(context, bump),
            render_area: self.render_area.into_low_level(context, bump),
            clear_value_count: len_clear_values,
            clear_values: clear_values,
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for RenderPassBeginInfo {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        let mut next = value.p_next;
        let mut extensions = SmallVec::new();
        while !next.is_null() {
            extensions.push(crate::conv::FromLowLevel::from_low_level(context, next));
            next = std::ptr::read(next).next;
        }
        let clear_values_len = value.clear_value_count;
        let mut clear_values = SmallVec::with_capacity(clear_values_len as usize);
        for i in 0..clear_values_len {
            clear_values.push(crate::conv::FromLowLevel::from_low_level(
                context,
                value.clear_values.add(i as usize).read(),
            ));
        }
        Self {
            extensions: extensions,
            render_pass: crate::conv::FromLowLevel::from_low_level(context, value.render_pass),
            framebuffer: crate::conv::FromLowLevel::from_low_level(context, value.framebuffer),
            render_area: crate::conv::FromLowLevel::from_low_level(context, value.render_area),
            clear_values: clear_values,
        }
    }
}
#[derive(Clone, PartialEq, Debug)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
///Extensions for [`RenderPassBeginInfo`]
pub enum RenderPassBeginInfoExtension {
    ///Contains a type [`DeviceGroupRenderPassBeginInfo`] for extending [`RenderPassBeginInfo`]
    DeviceGroupRenderPassBeginInfo(DeviceGroupRenderPassBeginInfo),
    #[cfg(feature = "VK_EXT_sample_locations")]
    ///Contains a type [`RenderPassSampleLocationsBeginInfoEXT`] for extending
    /// [`RenderPassBeginInfo`]
    RenderPassSampleLocationsBeginInfoEXT(RenderPassSampleLocationsBeginInfoEXT),
    #[cfg(feature = "VULKAN_1_2")]
    ///Contains a type [`RenderPassAttachmentBeginInfo`] for extending [`RenderPassBeginInfo`]
    RenderPassAttachmentBeginInfo(RenderPassAttachmentBeginInfo),
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for RenderPassBeginInfoExtension {
    type LowLevel = *const crate::native::vulkan1_0::BaseInStructure;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        match self {
            Self::DeviceGroupRenderPassBeginInfo(ext) => (bump.alloc(ext.into_low_level(context, bump))
                as *mut crate::native::vulkan1_1::DeviceGroupRenderPassBeginInfo)
                .cast(),
            #[cfg(feature = "VK_EXT_sample_locations")]
            Self::RenderPassSampleLocationsBeginInfoEXT(ext) => (bump.alloc(ext.into_low_level(context, bump))
                as *mut crate::native::extensions::ext_sample_locations::RenderPassSampleLocationsBeginInfoEXT)
                .cast(),
            #[cfg(feature = "VULKAN_1_2")]
            Self::RenderPassAttachmentBeginInfo(ext) => (bump.alloc(ext.into_low_level(context, bump))
                as *mut crate::native::vulkan1_2::RenderPassAttachmentBeginInfo)
                .cast(),
            other => unreachable!("unexpected variant {:?}", other),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for RenderPassBeginInfoExtension {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        assert!(!value.is_null());
        match (* value) . s_type { crate :: native :: vulkan1_0 :: StructureType :: DeviceGroupRenderPassBeginInfo => Self :: DeviceGroupRenderPassBeginInfo (DeviceGroupRenderPassBeginInfo :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: vulkan1_1 :: DeviceGroupRenderPassBeginInfo > ()))) , # [cfg (feature = "VK_EXT_sample_locations")] crate :: native :: vulkan1_0 :: StructureType :: RenderPassSampleLocationsBeginInfoExt => Self :: RenderPassSampleLocationsBeginInfoEXT (RenderPassSampleLocationsBeginInfoEXT :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: ext_sample_locations :: RenderPassSampleLocationsBeginInfoEXT > ()))) , # [cfg (feature = "VULKAN_1_2")] crate :: native :: vulkan1_0 :: StructureType :: RenderPassAttachmentBeginInfo => Self :: RenderPassAttachmentBeginInfo (RenderPassAttachmentBeginInfo :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: vulkan1_2 :: RenderPassAttachmentBeginInfo > ()))) , other => panic ! ("Structure type {:?} is not a member of {}" , other , stringify ! (RenderPassBeginInfo)) }
    }
}
impl From<DeviceGroupRenderPassBeginInfo> for RenderPassBeginInfoExtension {
    fn from(ext: DeviceGroupRenderPassBeginInfo) -> Self {
        Self::DeviceGroupRenderPassBeginInfo(ext)
    }
}
impl TryInto<DeviceGroupRenderPassBeginInfo> for RenderPassBeginInfoExtension {
    type Error = RenderPassBeginInfoExtension;
    fn try_into(self) -> Result<DeviceGroupRenderPassBeginInfo, Self::Error> {
        match self {
            Self::DeviceGroupRenderPassBeginInfo(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_EXT_sample_locations")]
impl From<RenderPassSampleLocationsBeginInfoEXT> for RenderPassBeginInfoExtension {
    fn from(ext: RenderPassSampleLocationsBeginInfoEXT) -> Self {
        Self::RenderPassSampleLocationsBeginInfoEXT(ext)
    }
}
#[cfg(feature = "VK_EXT_sample_locations")]
impl TryInto<RenderPassSampleLocationsBeginInfoEXT> for RenderPassBeginInfoExtension {
    type Error = RenderPassBeginInfoExtension;
    fn try_into(self) -> Result<RenderPassSampleLocationsBeginInfoEXT, Self::Error> {
        match self {
            Self::RenderPassSampleLocationsBeginInfoEXT(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VULKAN_1_2")]
impl From<RenderPassAttachmentBeginInfo> for RenderPassBeginInfoExtension {
    fn from(ext: RenderPassAttachmentBeginInfo) -> Self {
        Self::RenderPassAttachmentBeginInfo(ext)
    }
}
#[cfg(feature = "VULKAN_1_2")]
impl TryInto<RenderPassAttachmentBeginInfo> for RenderPassBeginInfoExtension {
    type Error = RenderPassBeginInfoExtension;
    fn try_into(self) -> Result<RenderPassAttachmentBeginInfo, Self::Error> {
        match self {
            Self::RenderPassAttachmentBeginInfo(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
impl ClearDepthStencilValue {
    ///Get a reference to the `depth` field.
    pub fn depth(&self) -> f32 {
        self.depth
    }
    ///Get a reference to the `stencil` field.
    pub fn stencil(&self) -> u32 {
        self.stencil
    }
    ///Get a mutable reference to the `depth` field.
    pub fn depth_mut(&mut self) -> &mut f32 {
        &mut self.depth
    }
    ///Get a mutable reference to the `stencil` field.
    pub fn stencil_mut(&mut self) -> &mut u32 {
        &mut self.stencil
    }
    ///Sets the `depth` field.
    pub fn set_depth(&mut self, depth: f32) -> &mut Self {
        self.depth = depth;
        self
    }
    ///Sets the `stencil` field.
    pub fn set_stencil(&mut self, stencil: u32) -> &mut Self {
        self.stencil = stencil;
        self
    }
    ///Sets the `depth` field in a builder way.
    pub fn with_depth(mut self, depth: f32) -> Self {
        self.depth = depth;
        self
    }
    ///Sets the `stencil` field in a builder way.
    pub fn with_stencil(mut self, stencil: u32) -> Self {
        self.stencil = stencil;
        self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for ClearDepthStencilValue {
    type LowLevel = crate::native::vulkan1_0::ClearDepthStencilValue;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        crate::native::vulkan1_0::ClearDepthStencilValue {
            depth: self.depth.into_low_level(context, bump),
            stencil: self.stencil.into_low_level(context, bump),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for ClearDepthStencilValue {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        Self {
            depth: crate::conv::FromLowLevel::from_low_level(context, value.depth),
            stencil: crate::conv::FromLowLevel::from_low_level(context, value.stencil),
        }
    }
}
#[doc(alias = "VkClearAttachment")]
#[derive(Clone, PartialEq, Debug, Copy)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct ClearAttachment {
    #[doc(alias = "aspectMask")]
    pub aspect_mask: ImageAspectFlags,
    #[doc(alias = "colorAttachment")]
    pub color_attachment: u32,
    #[doc(alias = "clearValue")]
    pub clear_value: ClearValue,
}
impl ClearAttachment {
    ///Get a reference to the `aspect_mask` field.
    pub fn aspect_mask(&self) -> ImageAspectFlags {
        self.aspect_mask
    }
    ///Get a reference to the `color_attachment` field.
    pub fn color_attachment(&self) -> u32 {
        self.color_attachment
    }
    ///Get a reference to the `clear_value` field.
    pub fn clear_value(&self) -> ClearValue {
        self.clear_value
    }
    ///Get a mutable reference to the `aspect_mask` field.
    pub fn aspect_mask_mut(&mut self) -> &mut ImageAspectFlags {
        &mut self.aspect_mask
    }
    ///Get a mutable reference to the `color_attachment` field.
    pub fn color_attachment_mut(&mut self) -> &mut u32 {
        &mut self.color_attachment
    }
    ///Get a mutable reference to the `clear_value` field.
    pub fn clear_value_mut(&mut self) -> &mut ClearValue {
        &mut self.clear_value
    }
    ///Sets the `aspect_mask` field.
    pub fn set_aspect_mask(&mut self, aspect_mask: ImageAspectFlags) -> &mut Self {
        self.aspect_mask = aspect_mask;
        self
    }
    ///Sets the `color_attachment` field.
    pub fn set_color_attachment(&mut self, color_attachment: u32) -> &mut Self {
        self.color_attachment = color_attachment;
        self
    }
    ///Sets the `clear_value` field.
    pub fn set_clear_value(&mut self, clear_value: ClearValue) -> &mut Self {
        self.clear_value = clear_value;
        self
    }
    ///Sets the `aspect_mask` field in a builder way.
    pub fn with_aspect_mask(mut self, aspect_mask: ImageAspectFlags) -> Self {
        self.aspect_mask = aspect_mask;
        self
    }
    ///Sets the `color_attachment` field in a builder way.
    pub fn with_color_attachment(mut self, color_attachment: u32) -> Self {
        self.color_attachment = color_attachment;
        self
    }
    ///Sets the `clear_value` field in a builder way.
    pub fn with_clear_value(mut self, clear_value: ClearValue) -> Self {
        self.clear_value = clear_value;
        self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for ClearAttachment {
    type LowLevel = crate::native::vulkan1_0::ClearAttachment;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        crate::native::vulkan1_0::ClearAttachment {
            aspect_mask: self.aspect_mask.into_low_level(context, bump),
            color_attachment: self.color_attachment.into_low_level(context, bump),
            clear_value: self.clear_value.into_low_level(context, bump),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for ClearAttachment {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        Self {
            aspect_mask: crate::conv::FromLowLevel::from_low_level(context, value.aspect_mask),
            color_attachment: crate::conv::FromLowLevel::from_low_level(context, value.color_attachment),
            clear_value: crate::conv::FromLowLevel::from_low_level(context, value.clear_value),
        }
    }
}
impl AttachmentDescription {
    ///Get a reference to the `flags` field.
    pub fn flags(&self) -> AttachmentDescriptionFlags {
        self.flags
    }
    ///Get a reference to the `format` field.
    pub fn format(&self) -> Format {
        self.format
    }
    ///Get a reference to the `samples` field.
    pub fn samples(&self) -> SampleCountFlagBits {
        self.samples
    }
    ///Get a reference to the `load_op` field.
    pub fn load_op(&self) -> AttachmentLoadOp {
        self.load_op
    }
    ///Get a reference to the `store_op` field.
    pub fn store_op(&self) -> AttachmentStoreOp {
        self.store_op
    }
    ///Get a reference to the `stencil_load_op` field.
    pub fn stencil_load_op(&self) -> AttachmentLoadOp {
        self.stencil_load_op
    }
    ///Get a reference to the `stencil_store_op` field.
    pub fn stencil_store_op(&self) -> AttachmentStoreOp {
        self.stencil_store_op
    }
    ///Get a reference to the `initial_layout` field.
    pub fn initial_layout(&self) -> ImageLayout {
        self.initial_layout
    }
    ///Get a reference to the `final_layout` field.
    pub fn final_layout(&self) -> ImageLayout {
        self.final_layout
    }
    ///Get a mutable reference to the `flags` field.
    pub fn flags_mut(&mut self) -> &mut AttachmentDescriptionFlags {
        &mut self.flags
    }
    ///Get a mutable reference to the `format` field.
    pub fn format_mut(&mut self) -> &mut Format {
        &mut self.format
    }
    ///Get a mutable reference to the `samples` field.
    pub fn samples_mut(&mut self) -> &mut SampleCountFlagBits {
        &mut self.samples
    }
    ///Get a mutable reference to the `load_op` field.
    pub fn load_op_mut(&mut self) -> &mut AttachmentLoadOp {
        &mut self.load_op
    }
    ///Get a mutable reference to the `store_op` field.
    pub fn store_op_mut(&mut self) -> &mut AttachmentStoreOp {
        &mut self.store_op
    }
    ///Get a mutable reference to the `stencil_load_op` field.
    pub fn stencil_load_op_mut(&mut self) -> &mut AttachmentLoadOp {
        &mut self.stencil_load_op
    }
    ///Get a mutable reference to the `stencil_store_op` field.
    pub fn stencil_store_op_mut(&mut self) -> &mut AttachmentStoreOp {
        &mut self.stencil_store_op
    }
    ///Get a mutable reference to the `initial_layout` field.
    pub fn initial_layout_mut(&mut self) -> &mut ImageLayout {
        &mut self.initial_layout
    }
    ///Get a mutable reference to the `final_layout` field.
    pub fn final_layout_mut(&mut self) -> &mut ImageLayout {
        &mut self.final_layout
    }
    ///Sets the `flags` field.
    pub fn set_flags(&mut self, flags: AttachmentDescriptionFlags) -> &mut Self {
        self.flags = flags;
        self
    }
    ///Sets the `format` field.
    pub fn set_format(&mut self, format: Format) -> &mut Self {
        self.format = format;
        self
    }
    ///Sets the `samples` field.
    pub fn set_samples(&mut self, samples: SampleCountFlagBits) -> &mut Self {
        self.samples = samples;
        self
    }
    ///Sets the `load_op` field.
    pub fn set_load_op(&mut self, load_op: AttachmentLoadOp) -> &mut Self {
        self.load_op = load_op;
        self
    }
    ///Sets the `store_op` field.
    pub fn set_store_op(&mut self, store_op: AttachmentStoreOp) -> &mut Self {
        self.store_op = store_op;
        self
    }
    ///Sets the `stencil_load_op` field.
    pub fn set_stencil_load_op(&mut self, stencil_load_op: AttachmentLoadOp) -> &mut Self {
        self.stencil_load_op = stencil_load_op;
        self
    }
    ///Sets the `stencil_store_op` field.
    pub fn set_stencil_store_op(&mut self, stencil_store_op: AttachmentStoreOp) -> &mut Self {
        self.stencil_store_op = stencil_store_op;
        self
    }
    ///Sets the `initial_layout` field.
    pub fn set_initial_layout(&mut self, initial_layout: ImageLayout) -> &mut Self {
        self.initial_layout = initial_layout;
        self
    }
    ///Sets the `final_layout` field.
    pub fn set_final_layout(&mut self, final_layout: ImageLayout) -> &mut Self {
        self.final_layout = final_layout;
        self
    }
    ///Sets the `flags` field in a builder way.
    pub fn with_flags(mut self, flags: AttachmentDescriptionFlags) -> Self {
        self.flags = flags;
        self
    }
    ///Sets the `format` field in a builder way.
    pub fn with_format(mut self, format: Format) -> Self {
        self.format = format;
        self
    }
    ///Sets the `samples` field in a builder way.
    pub fn with_samples(mut self, samples: SampleCountFlagBits) -> Self {
        self.samples = samples;
        self
    }
    ///Sets the `load_op` field in a builder way.
    pub fn with_load_op(mut self, load_op: AttachmentLoadOp) -> Self {
        self.load_op = load_op;
        self
    }
    ///Sets the `store_op` field in a builder way.
    pub fn with_store_op(mut self, store_op: AttachmentStoreOp) -> Self {
        self.store_op = store_op;
        self
    }
    ///Sets the `stencil_load_op` field in a builder way.
    pub fn with_stencil_load_op(mut self, stencil_load_op: AttachmentLoadOp) -> Self {
        self.stencil_load_op = stencil_load_op;
        self
    }
    ///Sets the `stencil_store_op` field in a builder way.
    pub fn with_stencil_store_op(mut self, stencil_store_op: AttachmentStoreOp) -> Self {
        self.stencil_store_op = stencil_store_op;
        self
    }
    ///Sets the `initial_layout` field in a builder way.
    pub fn with_initial_layout(mut self, initial_layout: ImageLayout) -> Self {
        self.initial_layout = initial_layout;
        self
    }
    ///Sets the `final_layout` field in a builder way.
    pub fn with_final_layout(mut self, final_layout: ImageLayout) -> Self {
        self.final_layout = final_layout;
        self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for AttachmentDescription {
    type LowLevel = crate::native::vulkan1_0::AttachmentDescription;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        crate::native::vulkan1_0::AttachmentDescription {
            flags: self.flags.into_low_level(context, bump),
            format: self.format.into_low_level(context, bump),
            samples: self.samples.into_low_level(context, bump),
            load_op: self.load_op.into_low_level(context, bump),
            store_op: self.store_op.into_low_level(context, bump),
            stencil_load_op: self.stencil_load_op.into_low_level(context, bump),
            stencil_store_op: self.stencil_store_op.into_low_level(context, bump),
            initial_layout: self.initial_layout.into_low_level(context, bump),
            final_layout: self.final_layout.into_low_level(context, bump),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for AttachmentDescription {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        Self {
            flags: crate::conv::FromLowLevel::from_low_level(context, value.flags),
            format: crate::conv::FromLowLevel::from_low_level(context, value.format),
            samples: crate::conv::FromLowLevel::from_low_level(context, value.samples),
            load_op: crate::conv::FromLowLevel::from_low_level(context, value.load_op),
            store_op: crate::conv::FromLowLevel::from_low_level(context, value.store_op),
            stencil_load_op: crate::conv::FromLowLevel::from_low_level(context, value.stencil_load_op),
            stencil_store_op: crate::conv::FromLowLevel::from_low_level(context, value.stencil_store_op),
            initial_layout: crate::conv::FromLowLevel::from_low_level(context, value.initial_layout),
            final_layout: crate::conv::FromLowLevel::from_low_level(context, value.final_layout),
        }
    }
}
impl AttachmentReference {
    ///Get a reference to the `attachment` field.
    pub fn attachment(&self) -> u32 {
        self.attachment
    }
    ///Get a reference to the `layout` field.
    pub fn layout(&self) -> ImageLayout {
        self.layout
    }
    ///Get a mutable reference to the `attachment` field.
    pub fn attachment_mut(&mut self) -> &mut u32 {
        &mut self.attachment
    }
    ///Get a mutable reference to the `layout` field.
    pub fn layout_mut(&mut self) -> &mut ImageLayout {
        &mut self.layout
    }
    ///Sets the `attachment` field.
    pub fn set_attachment(&mut self, attachment: u32) -> &mut Self {
        self.attachment = attachment;
        self
    }
    ///Sets the `layout` field.
    pub fn set_layout(&mut self, layout: ImageLayout) -> &mut Self {
        self.layout = layout;
        self
    }
    ///Sets the `attachment` field in a builder way.
    pub fn with_attachment(mut self, attachment: u32) -> Self {
        self.attachment = attachment;
        self
    }
    ///Sets the `layout` field in a builder way.
    pub fn with_layout(mut self, layout: ImageLayout) -> Self {
        self.layout = layout;
        self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for AttachmentReference {
    type LowLevel = crate::native::vulkan1_0::AttachmentReference;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        crate::native::vulkan1_0::AttachmentReference {
            attachment: self.attachment.into_low_level(context, bump),
            layout: self.layout.into_low_level(context, bump),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for AttachmentReference {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        Self {
            attachment: crate::conv::FromLowLevel::from_low_level(context, value.attachment),
            layout: crate::conv::FromLowLevel::from_low_level(context, value.layout),
        }
    }
}
#[doc(alias = "VkSubpassDescription")]
#[derive(Clone, PartialEq, Debug, Default)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct SubpassDescription {
    pub flags: SubpassDescriptionFlags,
    #[doc(alias = "pipelineBindPoint")]
    pub pipeline_bind_point: PipelineBindPoint,
    #[doc(alias = "pInputAttachments")]
    pub input_attachments: SmallVec<[AttachmentReference; 8]>,
    #[doc(alias = "pColorAttachments")]
    pub color_attachments: SmallVec<[AttachmentReference; 8]>,
    #[doc(alias = "pResolveAttachments")]
    pub resolve_attachments: SmallVec<[AttachmentReference; 8]>,
    #[doc(alias = "pDepthStencilAttachment")]
    pub depth_stencil_attachment: Option<AttachmentReference>,
    #[doc(alias = "pPreserveAttachments")]
    pub preserve_attachments: SmallVec<[u32; 8]>,
}
impl SubpassDescription {
    ///Get a reference to the `flags` field.
    pub fn flags(&self) -> SubpassDescriptionFlags {
        self.flags
    }
    ///Get a reference to the `pipeline_bind_point` field.
    pub fn pipeline_bind_point(&self) -> PipelineBindPoint {
        self.pipeline_bind_point
    }
    ///Get a reference to the `input_attachments` field.
    pub fn input_attachments(&self) -> &SmallVec<[AttachmentReference; 8]> {
        &self.input_attachments
    }
    ///Get a reference to the `color_attachments` field.
    pub fn color_attachments(&self) -> &SmallVec<[AttachmentReference; 8]> {
        &self.color_attachments
    }
    ///Get a reference to the `resolve_attachments` field.
    pub fn resolve_attachments(&self) -> &SmallVec<[AttachmentReference; 8]> {
        &self.resolve_attachments
    }
    ///Get a reference to the `depth_stencil_attachment` field.
    pub fn depth_stencil_attachment(&self) -> Option<AttachmentReference> {
        self.depth_stencil_attachment
    }
    ///Get a reference to the `preserve_attachments` field.
    pub fn preserve_attachments(&self) -> &SmallVec<[u32; 8]> {
        &self.preserve_attachments
    }
    ///Get a mutable reference to the `flags` field.
    pub fn flags_mut(&mut self) -> &mut SubpassDescriptionFlags {
        &mut self.flags
    }
    ///Get a mutable reference to the `pipeline_bind_point` field.
    pub fn pipeline_bind_point_mut(&mut self) -> &mut PipelineBindPoint {
        &mut self.pipeline_bind_point
    }
    ///Get a mutable reference to the `input_attachments` field.
    pub fn input_attachments_mut(&mut self) -> &mut SmallVec<[AttachmentReference; 8]> {
        &mut self.input_attachments
    }
    ///Get a mutable reference to the `color_attachments` field.
    pub fn color_attachments_mut(&mut self) -> &mut SmallVec<[AttachmentReference; 8]> {
        &mut self.color_attachments
    }
    ///Get a mutable reference to the `resolve_attachments` field.
    pub fn resolve_attachments_mut(&mut self) -> &mut SmallVec<[AttachmentReference; 8]> {
        &mut self.resolve_attachments
    }
    ///Get a mutable reference to the `depth_stencil_attachment` field.
    pub fn depth_stencil_attachment_mut(&mut self) -> &mut Option<AttachmentReference> {
        &mut self.depth_stencil_attachment
    }
    ///Get a mutable reference to the `preserve_attachments` field.
    pub fn preserve_attachments_mut(&mut self) -> &mut SmallVec<[u32; 8]> {
        &mut self.preserve_attachments
    }
    ///Sets the `flags` field.
    pub fn set_flags(&mut self, flags: SubpassDescriptionFlags) -> &mut Self {
        self.flags = flags;
        self
    }
    ///Sets the `pipeline_bind_point` field.
    pub fn set_pipeline_bind_point(&mut self, pipeline_bind_point: PipelineBindPoint) -> &mut Self {
        self.pipeline_bind_point = pipeline_bind_point;
        self
    }
    ///Sets the `input_attachments` field.
    pub fn set_input_attachments(&mut self, input_attachments: SmallVec<[AttachmentReference; 8]>) -> &mut Self {
        self.input_attachments = input_attachments;
        self
    }
    ///Sets the `color_attachments` field.
    pub fn set_color_attachments(&mut self, color_attachments: SmallVec<[AttachmentReference; 8]>) -> &mut Self {
        self.color_attachments = color_attachments;
        self
    }
    ///Sets the `resolve_attachments` field.
    pub fn set_resolve_attachments(&mut self, resolve_attachments: SmallVec<[AttachmentReference; 8]>) -> &mut Self {
        self.resolve_attachments = resolve_attachments;
        self
    }
    ///Sets the `depth_stencil_attachment` field.
    pub fn set_depth_stencil_attachment(&mut self, depth_stencil_attachment: Option<AttachmentReference>) -> &mut Self {
        self.depth_stencil_attachment = depth_stencil_attachment;
        self
    }
    ///Sets the `preserve_attachments` field.
    pub fn set_preserve_attachments(&mut self, preserve_attachments: SmallVec<[u32; 8]>) -> &mut Self {
        self.preserve_attachments = preserve_attachments;
        self
    }
    ///Sets the `flags` field in a builder way.
    pub fn with_flags(mut self, flags: SubpassDescriptionFlags) -> Self {
        self.flags = flags;
        self
    }
    ///Sets the `pipeline_bind_point` field in a builder way.
    pub fn with_pipeline_bind_point(mut self, pipeline_bind_point: PipelineBindPoint) -> Self {
        self.pipeline_bind_point = pipeline_bind_point;
        self
    }
    ///Sets the `input_attachments` field in a builder way.
    pub fn with_input_attachments(mut self, input_attachments: SmallVec<[AttachmentReference; 8]>) -> Self {
        self.input_attachments = input_attachments;
        self
    }
    ///Sets the `color_attachments` field in a builder way.
    pub fn with_color_attachments(mut self, color_attachments: SmallVec<[AttachmentReference; 8]>) -> Self {
        self.color_attachments = color_attachments;
        self
    }
    ///Sets the `resolve_attachments` field in a builder way.
    pub fn with_resolve_attachments(mut self, resolve_attachments: SmallVec<[AttachmentReference; 8]>) -> Self {
        self.resolve_attachments = resolve_attachments;
        self
    }
    ///Sets the `depth_stencil_attachment` field in a builder way.
    pub fn with_depth_stencil_attachment(mut self, depth_stencil_attachment: Option<AttachmentReference>) -> Self {
        self.depth_stencil_attachment = depth_stencil_attachment;
        self
    }
    ///Sets the `preserve_attachments` field in a builder way.
    pub fn with_preserve_attachments(mut self, preserve_attachments: SmallVec<[u32; 8]>) -> Self {
        self.preserve_attachments = preserve_attachments;
        self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for SubpassDescription {
    type LowLevel = crate::native::vulkan1_0::SubpassDescription;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        let len_input_attachments = self.input_attachments.len() as u32;
        let input_attachments = bump
            .alloc_slice_fill_iter(self.input_attachments.iter().map(|x| x.into_low_level(context, bump)))
            .as_ptr()
            .cast();
        let len_color_attachments = self.color_attachments.len() as u32;
        let color_attachments = bump
            .alloc_slice_fill_iter(self.color_attachments.iter().map(|x| x.into_low_level(context, bump)))
            .as_ptr()
            .cast();
        let resolve_attachments = bump
            .alloc_slice_fill_iter(self.resolve_attachments.iter().map(|x| x.into_low_level(context, bump)))
            .as_ptr()
            .cast();
        let len_preserve_attachments = self.preserve_attachments.len() as u32;
        let preserve_attachments = bump
            .alloc_slice_fill_iter(
                self.preserve_attachments
                    .iter()
                    .map(|x| x.into_low_level(context, bump)),
            )
            .as_ptr()
            .cast();
        crate::native::vulkan1_0::SubpassDescription {
            flags: self.flags.into_low_level(context, bump),
            pipeline_bind_point: self.pipeline_bind_point.into_low_level(context, bump),
            input_attachment_count: len_input_attachments,
            input_attachments: input_attachments,
            color_attachment_count: len_color_attachments,
            color_attachments: color_attachments,
            resolve_attachments: resolve_attachments,
            depth_stencil_attachment: self
                .depth_stencil_attachment
                .as_ref()
                .map(|v| bump.alloc(v.into_low_level(context, bump)) as *const _)
                .unwrap_or_else(std::ptr::null),
            preserve_attachment_count: len_preserve_attachments,
            preserve_attachments: preserve_attachments,
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for SubpassDescription {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        let input_attachments_len = value.input_attachment_count;
        let mut input_attachments = SmallVec::with_capacity(input_attachments_len as usize);
        for i in 0..input_attachments_len {
            input_attachments.push(crate::conv::FromLowLevel::from_low_level(
                context,
                value.input_attachments.add(i as usize).read(),
            ));
        }
        let color_attachments_len = value.color_attachment_count;
        let mut color_attachments = SmallVec::with_capacity(color_attachments_len as usize);
        for i in 0..color_attachments_len {
            color_attachments.push(crate::conv::FromLowLevel::from_low_level(
                context,
                value.color_attachments.add(i as usize).read(),
            ));
        }
        let resolve_attachments_len = value.color_attachment_count;
        let mut resolve_attachments = SmallVec::with_capacity(resolve_attachments_len as usize);
        for i in 0..resolve_attachments_len {
            resolve_attachments.push(crate::conv::FromLowLevel::from_low_level(
                context,
                value.resolve_attachments.add(i as usize).read(),
            ));
        }
        let preserve_attachments_len = value.preserve_attachment_count;
        let mut preserve_attachments = SmallVec::with_capacity(preserve_attachments_len as usize);
        for i in 0..preserve_attachments_len {
            preserve_attachments.push(crate::conv::FromLowLevel::from_low_level(
                context,
                value.preserve_attachments.add(i as usize).read(),
            ));
        }
        Self {
            flags: crate::conv::FromLowLevel::from_low_level(context, value.flags),
            pipeline_bind_point: crate::conv::FromLowLevel::from_low_level(context, value.pipeline_bind_point),
            input_attachments: input_attachments,
            color_attachments: color_attachments,
            resolve_attachments: resolve_attachments,
            depth_stencil_attachment: crate::conv::FromLowLevel::from_low_level(
                context,
                *value.depth_stencil_attachment,
            ),
            preserve_attachments: preserve_attachments,
        }
    }
}
impl SubpassDependency {
    ///Get a reference to the `src_subpass` field.
    pub fn src_subpass(&self) -> u32 {
        self.src_subpass
    }
    ///Get a reference to the `dst_subpass` field.
    pub fn dst_subpass(&self) -> u32 {
        self.dst_subpass
    }
    ///Get a reference to the `src_stage_mask` field.
    pub fn src_stage_mask(&self) -> PipelineStageFlags {
        self.src_stage_mask
    }
    ///Get a reference to the `dst_stage_mask` field.
    pub fn dst_stage_mask(&self) -> PipelineStageFlags {
        self.dst_stage_mask
    }
    ///Get a reference to the `src_access_mask` field.
    pub fn src_access_mask(&self) -> AccessFlags {
        self.src_access_mask
    }
    ///Get a reference to the `dst_access_mask` field.
    pub fn dst_access_mask(&self) -> AccessFlags {
        self.dst_access_mask
    }
    ///Get a reference to the `dependency_flags` field.
    pub fn dependency_flags(&self) -> DependencyFlags {
        self.dependency_flags
    }
    ///Get a mutable reference to the `src_subpass` field.
    pub fn src_subpass_mut(&mut self) -> &mut u32 {
        &mut self.src_subpass
    }
    ///Get a mutable reference to the `dst_subpass` field.
    pub fn dst_subpass_mut(&mut self) -> &mut u32 {
        &mut self.dst_subpass
    }
    ///Get a mutable reference to the `src_stage_mask` field.
    pub fn src_stage_mask_mut(&mut self) -> &mut PipelineStageFlags {
        &mut self.src_stage_mask
    }
    ///Get a mutable reference to the `dst_stage_mask` field.
    pub fn dst_stage_mask_mut(&mut self) -> &mut PipelineStageFlags {
        &mut self.dst_stage_mask
    }
    ///Get a mutable reference to the `src_access_mask` field.
    pub fn src_access_mask_mut(&mut self) -> &mut AccessFlags {
        &mut self.src_access_mask
    }
    ///Get a mutable reference to the `dst_access_mask` field.
    pub fn dst_access_mask_mut(&mut self) -> &mut AccessFlags {
        &mut self.dst_access_mask
    }
    ///Get a mutable reference to the `dependency_flags` field.
    pub fn dependency_flags_mut(&mut self) -> &mut DependencyFlags {
        &mut self.dependency_flags
    }
    ///Sets the `src_subpass` field.
    pub fn set_src_subpass(&mut self, src_subpass: u32) -> &mut Self {
        self.src_subpass = src_subpass;
        self
    }
    ///Sets the `dst_subpass` field.
    pub fn set_dst_subpass(&mut self, dst_subpass: u32) -> &mut Self {
        self.dst_subpass = dst_subpass;
        self
    }
    ///Sets the `src_stage_mask` field.
    pub fn set_src_stage_mask(&mut self, src_stage_mask: PipelineStageFlags) -> &mut Self {
        self.src_stage_mask = src_stage_mask;
        self
    }
    ///Sets the `dst_stage_mask` field.
    pub fn set_dst_stage_mask(&mut self, dst_stage_mask: PipelineStageFlags) -> &mut Self {
        self.dst_stage_mask = dst_stage_mask;
        self
    }
    ///Sets the `src_access_mask` field.
    pub fn set_src_access_mask(&mut self, src_access_mask: AccessFlags) -> &mut Self {
        self.src_access_mask = src_access_mask;
        self
    }
    ///Sets the `dst_access_mask` field.
    pub fn set_dst_access_mask(&mut self, dst_access_mask: AccessFlags) -> &mut Self {
        self.dst_access_mask = dst_access_mask;
        self
    }
    ///Sets the `dependency_flags` field.
    pub fn set_dependency_flags(&mut self, dependency_flags: DependencyFlags) -> &mut Self {
        self.dependency_flags = dependency_flags;
        self
    }
    ///Sets the `src_subpass` field in a builder way.
    pub fn with_src_subpass(mut self, src_subpass: u32) -> Self {
        self.src_subpass = src_subpass;
        self
    }
    ///Sets the `dst_subpass` field in a builder way.
    pub fn with_dst_subpass(mut self, dst_subpass: u32) -> Self {
        self.dst_subpass = dst_subpass;
        self
    }
    ///Sets the `src_stage_mask` field in a builder way.
    pub fn with_src_stage_mask(mut self, src_stage_mask: PipelineStageFlags) -> Self {
        self.src_stage_mask = src_stage_mask;
        self
    }
    ///Sets the `dst_stage_mask` field in a builder way.
    pub fn with_dst_stage_mask(mut self, dst_stage_mask: PipelineStageFlags) -> Self {
        self.dst_stage_mask = dst_stage_mask;
        self
    }
    ///Sets the `src_access_mask` field in a builder way.
    pub fn with_src_access_mask(mut self, src_access_mask: AccessFlags) -> Self {
        self.src_access_mask = src_access_mask;
        self
    }
    ///Sets the `dst_access_mask` field in a builder way.
    pub fn with_dst_access_mask(mut self, dst_access_mask: AccessFlags) -> Self {
        self.dst_access_mask = dst_access_mask;
        self
    }
    ///Sets the `dependency_flags` field in a builder way.
    pub fn with_dependency_flags(mut self, dependency_flags: DependencyFlags) -> Self {
        self.dependency_flags = dependency_flags;
        self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for SubpassDependency {
    type LowLevel = crate::native::vulkan1_0::SubpassDependency;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        crate::native::vulkan1_0::SubpassDependency {
            src_subpass: self.src_subpass.into_low_level(context, bump),
            dst_subpass: self.dst_subpass.into_low_level(context, bump),
            src_stage_mask: self.src_stage_mask.into_low_level(context, bump),
            dst_stage_mask: self.dst_stage_mask.into_low_level(context, bump),
            src_access_mask: self.src_access_mask.into_low_level(context, bump),
            dst_access_mask: self.dst_access_mask.into_low_level(context, bump),
            dependency_flags: self.dependency_flags.into_low_level(context, bump),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for SubpassDependency {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        Self {
            src_subpass: crate::conv::FromLowLevel::from_low_level(context, value.src_subpass),
            dst_subpass: crate::conv::FromLowLevel::from_low_level(context, value.dst_subpass),
            src_stage_mask: crate::conv::FromLowLevel::from_low_level(context, value.src_stage_mask),
            dst_stage_mask: crate::conv::FromLowLevel::from_low_level(context, value.dst_stage_mask),
            src_access_mask: crate::conv::FromLowLevel::from_low_level(context, value.src_access_mask),
            dst_access_mask: crate::conv::FromLowLevel::from_low_level(context, value.dst_access_mask),
            dependency_flags: crate::conv::FromLowLevel::from_low_level(context, value.dependency_flags),
        }
    }
}
#[doc(alias = "VkRenderPassCreateInfo")]
#[derive(Clone, PartialEq, Debug, Default)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct RenderPassCreateInfo {
    #[doc(alias = "pNext")]
    pub extensions: SmallVec<[RenderPassCreateInfoExtension; 1]>,
    pub flags: RenderPassCreateFlags,
    #[doc(alias = "pAttachments")]
    pub attachments: SmallVec<[AttachmentDescription; 8]>,
    #[doc(alias = "pSubpasses")]
    pub subpasses: SmallVec<[SubpassDescription; 8]>,
    #[doc(alias = "pDependencies")]
    pub dependencies: SmallVec<[SubpassDependency; 8]>,
}
impl RenderPassCreateInfo {
    ///Adds an extension to the struct
    pub fn with_extension(mut self, ext: impl Into<RenderPassCreateInfoExtension>) -> Self {
        self.extensions.push(ext.into());
        self
    }
    ///Get a reference to the `extensions` field.
    pub fn extensions(&self) -> &SmallVec<[RenderPassCreateInfoExtension; 1]> {
        &self.extensions
    }
    ///Get a reference to the `flags` field.
    pub fn flags(&self) -> RenderPassCreateFlags {
        self.flags
    }
    ///Get a reference to the `attachments` field.
    pub fn attachments(&self) -> &SmallVec<[AttachmentDescription; 8]> {
        &self.attachments
    }
    ///Get a reference to the `subpasses` field.
    pub fn subpasses(&self) -> &SmallVec<[SubpassDescription; 8]> {
        &self.subpasses
    }
    ///Get a reference to the `dependencies` field.
    pub fn dependencies(&self) -> &SmallVec<[SubpassDependency; 8]> {
        &self.dependencies
    }
    ///Get a mutable reference to the `extensions` field.
    pub fn extensions_mut(&mut self) -> &mut SmallVec<[RenderPassCreateInfoExtension; 1]> {
        &mut self.extensions
    }
    ///Get a mutable reference to the `flags` field.
    pub fn flags_mut(&mut self) -> &mut RenderPassCreateFlags {
        &mut self.flags
    }
    ///Get a mutable reference to the `attachments` field.
    pub fn attachments_mut(&mut self) -> &mut SmallVec<[AttachmentDescription; 8]> {
        &mut self.attachments
    }
    ///Get a mutable reference to the `subpasses` field.
    pub fn subpasses_mut(&mut self) -> &mut SmallVec<[SubpassDescription; 8]> {
        &mut self.subpasses
    }
    ///Get a mutable reference to the `dependencies` field.
    pub fn dependencies_mut(&mut self) -> &mut SmallVec<[SubpassDependency; 8]> {
        &mut self.dependencies
    }
    ///Sets the `extensions` field.
    pub fn set_extensions(&mut self, extensions: SmallVec<[RenderPassCreateInfoExtension; 1]>) -> &mut Self {
        self.extensions = extensions;
        self
    }
    ///Sets the `flags` field.
    pub fn set_flags(&mut self, flags: RenderPassCreateFlags) -> &mut Self {
        self.flags = flags;
        self
    }
    ///Sets the `attachments` field.
    pub fn set_attachments(&mut self, attachments: SmallVec<[AttachmentDescription; 8]>) -> &mut Self {
        self.attachments = attachments;
        self
    }
    ///Sets the `subpasses` field.
    pub fn set_subpasses(&mut self, subpasses: SmallVec<[SubpassDescription; 8]>) -> &mut Self {
        self.subpasses = subpasses;
        self
    }
    ///Sets the `dependencies` field.
    pub fn set_dependencies(&mut self, dependencies: SmallVec<[SubpassDependency; 8]>) -> &mut Self {
        self.dependencies = dependencies;
        self
    }
    ///Sets the `extensions` field in a builder way.
    pub fn with_extensions(mut self, extensions: SmallVec<[RenderPassCreateInfoExtension; 1]>) -> Self {
        self.extensions = extensions;
        self
    }
    ///Sets the `flags` field in a builder way.
    pub fn with_flags(mut self, flags: RenderPassCreateFlags) -> Self {
        self.flags = flags;
        self
    }
    ///Sets the `attachments` field in a builder way.
    pub fn with_attachments(mut self, attachments: SmallVec<[AttachmentDescription; 8]>) -> Self {
        self.attachments = attachments;
        self
    }
    ///Sets the `subpasses` field in a builder way.
    pub fn with_subpasses(mut self, subpasses: SmallVec<[SubpassDescription; 8]>) -> Self {
        self.subpasses = subpasses;
        self
    }
    ///Sets the `dependencies` field in a builder way.
    pub fn with_dependencies(mut self, dependencies: SmallVec<[SubpassDependency; 8]>) -> Self {
        self.dependencies = dependencies;
        self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for RenderPassCreateInfo {
    type LowLevel = crate::native::vulkan1_0::RenderPassCreateInfo;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        let mut next = std::ptr::null();
        let mut extensions = self.extensions.iter();
        while let Some(ext) = extensions.next() {
            let ext = ext.into_low_level(context, bump);
            (*ext).next = next;
            next = ext;
        }
        let len_attachments = self.attachments.len() as u32;
        let attachments = bump
            .alloc_slice_fill_iter(self.attachments.iter().map(|x| x.into_low_level(context, bump)))
            .as_ptr()
            .cast();
        let len_subpasses = self.subpasses.len() as u32;
        let subpasses = bump
            .alloc_slice_fill_iter(self.subpasses.iter().map(|x| x.into_low_level(context, bump)))
            .as_ptr()
            .cast();
        let len_dependencies = self.dependencies.len() as u32;
        let dependencies = bump
            .alloc_slice_fill_iter(self.dependencies.iter().map(|x| x.into_low_level(context, bump)))
            .as_ptr()
            .cast();
        crate::native::vulkan1_0::RenderPassCreateInfo {
            s_type: StructureType::RenderPassCreateInfo,
            p_next: next,
            flags: self.flags.into_low_level(context, bump),
            attachment_count: len_attachments,
            attachments: attachments,
            subpass_count: len_subpasses,
            subpasses: subpasses,
            dependency_count: len_dependencies,
            dependencies: dependencies,
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for RenderPassCreateInfo {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        let mut next = value.p_next;
        let mut extensions = SmallVec::new();
        while !next.is_null() {
            extensions.push(crate::conv::FromLowLevel::from_low_level(context, next));
            next = std::ptr::read(next).next;
        }
        let attachments_len = value.attachment_count;
        let mut attachments = SmallVec::with_capacity(attachments_len as usize);
        for i in 0..attachments_len {
            attachments.push(crate::conv::FromLowLevel::from_low_level(
                context,
                value.attachments.add(i as usize).read(),
            ));
        }
        let subpasses_len = value.subpass_count;
        let mut subpasses = SmallVec::with_capacity(subpasses_len as usize);
        for i in 0..subpasses_len {
            subpasses.push(crate::conv::FromLowLevel::from_low_level(
                context,
                value.subpasses.add(i as usize).read(),
            ));
        }
        let dependencies_len = value.dependency_count;
        let mut dependencies = SmallVec::with_capacity(dependencies_len as usize);
        for i in 0..dependencies_len {
            dependencies.push(crate::conv::FromLowLevel::from_low_level(
                context,
                value.dependencies.add(i as usize).read(),
            ));
        }
        Self {
            extensions: extensions,
            flags: crate::conv::FromLowLevel::from_low_level(context, value.flags),
            attachments: attachments,
            subpasses: subpasses,
            dependencies: dependencies,
        }
    }
}
#[derive(Clone, PartialEq, Debug)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
///Extensions for [`RenderPassCreateInfo`]
pub enum RenderPassCreateInfoExtension {
    ///Contains a type [`RenderPassMultiviewCreateInfo`] for extending [`RenderPassCreateInfo`]
    RenderPassMultiviewCreateInfo(RenderPassMultiviewCreateInfo),
    ///Contains a type [`RenderPassInputAttachmentAspectCreateInfo`] for extending
    /// [`RenderPassCreateInfo`]
    RenderPassInputAttachmentAspectCreateInfo(RenderPassInputAttachmentAspectCreateInfo),
    #[cfg(feature = "VK_EXT_fragment_density_map")]
    ///Contains a type [`RenderPassFragmentDensityMapCreateInfoEXT`] for extending
    /// [`RenderPassCreateInfo`]
    RenderPassFragmentDensityMapCreateInfoEXT(RenderPassFragmentDensityMapCreateInfoEXT),
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for RenderPassCreateInfoExtension {
    type LowLevel = *const crate::native::vulkan1_0::BaseInStructure;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        match self {
            Self::RenderPassMultiviewCreateInfo(ext) => (bump.alloc(ext.into_low_level(context, bump))
                as *mut crate::native::vulkan1_1::RenderPassMultiviewCreateInfo)
                .cast(),
            Self::RenderPassInputAttachmentAspectCreateInfo(ext) => (bump.alloc(ext.into_low_level(context, bump))
                as *mut crate::native::vulkan1_1::RenderPassInputAttachmentAspectCreateInfo)
                .cast(),
            #[cfg(feature = "VK_EXT_fragment_density_map")]
            Self::RenderPassFragmentDensityMapCreateInfoEXT(ext) => (bump.alloc(ext.into_low_level(context, bump))
                as *mut crate::native::extensions::ext_fragment_density_map::RenderPassFragmentDensityMapCreateInfoEXT)
                .cast(),
            other => unreachable!("unexpected variant {:?}", other),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for RenderPassCreateInfoExtension {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        assert!(!value.is_null());
        match (* value) . s_type { crate :: native :: vulkan1_0 :: StructureType :: RenderPassMultiviewCreateInfo => Self :: RenderPassMultiviewCreateInfo (RenderPassMultiviewCreateInfo :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: vulkan1_1 :: RenderPassMultiviewCreateInfo > ()))) , crate :: native :: vulkan1_0 :: StructureType :: RenderPassInputAttachmentAspectCreateInfo => Self :: RenderPassInputAttachmentAspectCreateInfo (RenderPassInputAttachmentAspectCreateInfo :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: vulkan1_1 :: RenderPassInputAttachmentAspectCreateInfo > ()))) , # [cfg (feature = "VK_EXT_fragment_density_map")] crate :: native :: vulkan1_0 :: StructureType :: RenderPassFragmentDensityMapCreateInfoExt => Self :: RenderPassFragmentDensityMapCreateInfoEXT (RenderPassFragmentDensityMapCreateInfoEXT :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: ext_fragment_density_map :: RenderPassFragmentDensityMapCreateInfoEXT > ()))) , other => panic ! ("Structure type {:?} is not a member of {}" , other , stringify ! (RenderPassCreateInfo)) }
    }
}
impl From<RenderPassMultiviewCreateInfo> for RenderPassCreateInfoExtension {
    fn from(ext: RenderPassMultiviewCreateInfo) -> Self {
        Self::RenderPassMultiviewCreateInfo(ext)
    }
}
impl TryInto<RenderPassMultiviewCreateInfo> for RenderPassCreateInfoExtension {
    type Error = RenderPassCreateInfoExtension;
    fn try_into(self) -> Result<RenderPassMultiviewCreateInfo, Self::Error> {
        match self {
            Self::RenderPassMultiviewCreateInfo(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
impl From<RenderPassInputAttachmentAspectCreateInfo> for RenderPassCreateInfoExtension {
    fn from(ext: RenderPassInputAttachmentAspectCreateInfo) -> Self {
        Self::RenderPassInputAttachmentAspectCreateInfo(ext)
    }
}
impl TryInto<RenderPassInputAttachmentAspectCreateInfo> for RenderPassCreateInfoExtension {
    type Error = RenderPassCreateInfoExtension;
    fn try_into(self) -> Result<RenderPassInputAttachmentAspectCreateInfo, Self::Error> {
        match self {
            Self::RenderPassInputAttachmentAspectCreateInfo(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_EXT_fragment_density_map")]
impl From<RenderPassFragmentDensityMapCreateInfoEXT> for RenderPassCreateInfoExtension {
    fn from(ext: RenderPassFragmentDensityMapCreateInfoEXT) -> Self {
        Self::RenderPassFragmentDensityMapCreateInfoEXT(ext)
    }
}
#[cfg(feature = "VK_EXT_fragment_density_map")]
impl TryInto<RenderPassFragmentDensityMapCreateInfoEXT> for RenderPassCreateInfoExtension {
    type Error = RenderPassCreateInfoExtension;
    fn try_into(self) -> Result<RenderPassFragmentDensityMapCreateInfoEXT, Self::Error> {
        match self {
            Self::RenderPassFragmentDensityMapCreateInfoEXT(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[doc(alias = "VkEventCreateInfo")]
#[derive(Clone, PartialEq, Debug, Copy, Default)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct EventCreateInfo {
    pub flags: EventCreateFlags,
}
impl EventCreateInfo {
    ///Get a reference to the `flags` field.
    pub fn flags(&self) -> EventCreateFlags {
        self.flags
    }
    ///Get a mutable reference to the `flags` field.
    pub fn flags_mut(&mut self) -> &mut EventCreateFlags {
        &mut self.flags
    }
    ///Sets the `flags` field.
    pub fn set_flags(&mut self, flags: EventCreateFlags) -> &mut Self {
        self.flags = flags;
        self
    }
    ///Sets the `flags` field in a builder way.
    pub fn with_flags(mut self, flags: EventCreateFlags) -> Self {
        self.flags = flags;
        self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for EventCreateInfo {
    type LowLevel = crate::native::vulkan1_0::EventCreateInfo;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        crate::native::vulkan1_0::EventCreateInfo {
            s_type: StructureType::EventCreateInfo,
            p_next: std::ptr::null(),
            flags: self.flags.into_low_level(context, bump),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for EventCreateInfo {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        Self {
            flags: crate::conv::FromLowLevel::from_low_level(context, value.flags),
        }
    }
}
#[doc(alias = "VkFenceCreateInfo")]
#[derive(Clone, PartialEq, Debug, Default)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct FenceCreateInfo {
    #[doc(alias = "pNext")]
    pub extensions: SmallVec<[FenceCreateInfoExtension; 1]>,
    pub flags: FenceCreateFlags,
}
impl FenceCreateInfo {
    ///Adds an extension to the struct
    pub fn with_extension(mut self, ext: impl Into<FenceCreateInfoExtension>) -> Self {
        self.extensions.push(ext.into());
        self
    }
    ///Get a reference to the `extensions` field.
    pub fn extensions(&self) -> &SmallVec<[FenceCreateInfoExtension; 1]> {
        &self.extensions
    }
    ///Get a reference to the `flags` field.
    pub fn flags(&self) -> FenceCreateFlags {
        self.flags
    }
    ///Get a mutable reference to the `extensions` field.
    pub fn extensions_mut(&mut self) -> &mut SmallVec<[FenceCreateInfoExtension; 1]> {
        &mut self.extensions
    }
    ///Get a mutable reference to the `flags` field.
    pub fn flags_mut(&mut self) -> &mut FenceCreateFlags {
        &mut self.flags
    }
    ///Sets the `extensions` field.
    pub fn set_extensions(&mut self, extensions: SmallVec<[FenceCreateInfoExtension; 1]>) -> &mut Self {
        self.extensions = extensions;
        self
    }
    ///Sets the `flags` field.
    pub fn set_flags(&mut self, flags: FenceCreateFlags) -> &mut Self {
        self.flags = flags;
        self
    }
    ///Sets the `extensions` field in a builder way.
    pub fn with_extensions(mut self, extensions: SmallVec<[FenceCreateInfoExtension; 1]>) -> Self {
        self.extensions = extensions;
        self
    }
    ///Sets the `flags` field in a builder way.
    pub fn with_flags(mut self, flags: FenceCreateFlags) -> Self {
        self.flags = flags;
        self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for FenceCreateInfo {
    type LowLevel = crate::native::vulkan1_0::FenceCreateInfo;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        let mut next = std::ptr::null();
        let mut extensions = self.extensions.iter();
        while let Some(ext) = extensions.next() {
            let ext = ext.into_low_level(context, bump);
            (*ext).next = next;
            next = ext;
        }
        crate::native::vulkan1_0::FenceCreateInfo {
            s_type: StructureType::FenceCreateInfo,
            p_next: next,
            flags: self.flags.into_low_level(context, bump),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for FenceCreateInfo {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        let mut next = value.p_next;
        let mut extensions = SmallVec::new();
        while !next.is_null() {
            extensions.push(crate::conv::FromLowLevel::from_low_level(context, next));
            next = std::ptr::read(next).next;
        }
        Self {
            extensions: extensions,
            flags: crate::conv::FromLowLevel::from_low_level(context, value.flags),
        }
    }
}
#[derive(Clone, PartialEq, Debug)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
///Extensions for [`FenceCreateInfo`]
pub enum FenceCreateInfoExtension {
    ///Contains a type [`ExportFenceCreateInfo`] for extending [`FenceCreateInfo`]
    ExportFenceCreateInfo(ExportFenceCreateInfo),
    #[cfg(feature = "VK_KHR_external_fence_win32")]
    ///Contains a type [`ExportFenceWin32HandleInfoKHR`] for extending [`FenceCreateInfo`]
    ExportFenceWin32HandleInfoKHR(ExportFenceWin32HandleInfoKHR),
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for FenceCreateInfoExtension {
    type LowLevel = *const crate::native::vulkan1_0::BaseInStructure;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        match self {
            Self::ExportFenceCreateInfo(ext) => (bump.alloc(ext.into_low_level(context, bump))
                as *mut crate::native::vulkan1_1::ExportFenceCreateInfo)
                .cast(),
            #[cfg(feature = "VK_KHR_external_fence_win32")]
            Self::ExportFenceWin32HandleInfoKHR(ext) => (bump.alloc(ext.into_low_level(context, bump))
                as *mut crate::native::extensions::khr_external_fence_win32::ExportFenceWin32HandleInfoKHR)
                .cast(),
            other => unreachable!("unexpected variant {:?}", other),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for FenceCreateInfoExtension {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        assert!(!value.is_null());
        match (*value).s_type {
            crate::native::vulkan1_0::StructureType::ExportFenceCreateInfo => {
                Self::ExportFenceCreateInfo(ExportFenceCreateInfo::from_low_level(
                    context,
                    std::ptr::read(value.cast::<crate::native::vulkan1_1::ExportFenceCreateInfo>()),
                ))
            },
            #[cfg(feature = "VK_KHR_external_fence_win32")]
            crate::native::vulkan1_0::StructureType::ExportFenceWin32HandleInfoKhr => {
                Self::ExportFenceWin32HandleInfoKHR(ExportFenceWin32HandleInfoKHR::from_low_level(
                    context,
                    std::ptr::read(
                        value
                            .cast::<crate::native::extensions::khr_external_fence_win32::ExportFenceWin32HandleInfoKHR>(
                            ),
                    ),
                ))
            },
            other => panic!(
                "Structure type {:?} is not a member of {}",
                other,
                stringify!(FenceCreateInfo)
            ),
        }
    }
}
impl From<ExportFenceCreateInfo> for FenceCreateInfoExtension {
    fn from(ext: ExportFenceCreateInfo) -> Self {
        Self::ExportFenceCreateInfo(ext)
    }
}
impl TryInto<ExportFenceCreateInfo> for FenceCreateInfoExtension {
    type Error = FenceCreateInfoExtension;
    fn try_into(self) -> Result<ExportFenceCreateInfo, Self::Error> {
        match self {
            Self::ExportFenceCreateInfo(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_KHR_external_fence_win32")]
impl From<ExportFenceWin32HandleInfoKHR> for FenceCreateInfoExtension {
    fn from(ext: ExportFenceWin32HandleInfoKHR) -> Self {
        Self::ExportFenceWin32HandleInfoKHR(ext)
    }
}
#[cfg(feature = "VK_KHR_external_fence_win32")]
impl TryInto<ExportFenceWin32HandleInfoKHR> for FenceCreateInfoExtension {
    type Error = FenceCreateInfoExtension;
    fn try_into(self) -> Result<ExportFenceWin32HandleInfoKHR, Self::Error> {
        match self {
            Self::ExportFenceWin32HandleInfoKHR(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[doc(alias = "VkPhysicalDeviceFeatures")]
#[derive(Clone, PartialEq, Debug, Default)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct PhysicalDeviceFeatures {
    #[doc(alias = "robustBufferAccess")]
    pub robust_buffer_access: bool,
    #[doc(alias = "fullDrawIndexUint32")]
    pub full_draw_index_uint32: bool,
    #[doc(alias = "imageCubeArray")]
    pub image_cube_array: bool,
    #[doc(alias = "independentBlend")]
    pub independent_blend: bool,
    #[doc(alias = "geometryShader")]
    pub geometry_shader: bool,
    #[doc(alias = "tessellationShader")]
    pub tessellation_shader: bool,
    #[doc(alias = "sampleRateShading")]
    pub sample_rate_shading: bool,
    #[doc(alias = "dualSrcBlend")]
    pub dual_src_blend: bool,
    #[doc(alias = "logicOp")]
    pub logic_op: bool,
    #[doc(alias = "multiDrawIndirect")]
    pub multi_draw_indirect: bool,
    #[doc(alias = "drawIndirectFirstInstance")]
    pub draw_indirect_first_instance: bool,
    #[doc(alias = "depthClamp")]
    pub depth_clamp: bool,
    #[doc(alias = "depthBiasClamp")]
    pub depth_bias_clamp: bool,
    #[doc(alias = "fillModeNonSolid")]
    pub fill_mode_non_solid: bool,
    #[doc(alias = "depthBounds")]
    pub depth_bounds: bool,
    #[doc(alias = "wideLines")]
    pub wide_lines: bool,
    #[doc(alias = "largePoints")]
    pub large_points: bool,
    #[doc(alias = "alphaToOne")]
    pub alpha_to_one: bool,
    #[doc(alias = "multiViewport")]
    pub multi_viewport: bool,
    #[doc(alias = "samplerAnisotropy")]
    pub sampler_anisotropy: bool,
    #[doc(alias = "textureCompressionETC2")]
    pub texture_compression_etc2: bool,
    #[doc(alias = "textureCompressionASTC_LDR")]
    pub texture_compression_astc_ldr: bool,
    #[doc(alias = "textureCompressionBC")]
    pub texture_compression_bc: bool,
    #[doc(alias = "occlusionQueryPrecise")]
    pub occlusion_query_precise: bool,
    #[doc(alias = "pipelineStatisticsQuery")]
    pub pipeline_statistics_query: bool,
    #[doc(alias = "vertexPipelineStoresAndAtomics")]
    pub vertex_pipeline_stores_and_atomics: bool,
    #[doc(alias = "fragmentStoresAndAtomics")]
    pub fragment_stores_and_atomics: bool,
    #[doc(alias = "shaderTessellationAndGeometryPointSize")]
    pub shader_tessellation_and_geometry_point_size: bool,
    #[doc(alias = "shaderImageGatherExtended")]
    pub shader_image_gather_extended: bool,
    #[doc(alias = "shaderStorageImageExtendedFormats")]
    pub shader_storage_image_extended_formats: bool,
    #[doc(alias = "shaderStorageImageMultisample")]
    pub shader_storage_image_multisample: bool,
    #[doc(alias = "shaderStorageImageReadWithoutFormat")]
    pub shader_storage_image_read_without_format: bool,
    #[doc(alias = "shaderStorageImageWriteWithoutFormat")]
    pub shader_storage_image_write_without_format: bool,
    #[doc(alias = "shaderUniformBufferArrayDynamicIndexing")]
    pub shader_uniform_buffer_array_dynamic_indexing: bool,
    #[doc(alias = "shaderSampledImageArrayDynamicIndexing")]
    pub shader_sampled_image_array_dynamic_indexing: bool,
    #[doc(alias = "shaderStorageBufferArrayDynamicIndexing")]
    pub shader_storage_buffer_array_dynamic_indexing: bool,
    #[doc(alias = "shaderStorageImageArrayDynamicIndexing")]
    pub shader_storage_image_array_dynamic_indexing: bool,
    #[doc(alias = "shaderClipDistance")]
    pub shader_clip_distance: bool,
    #[doc(alias = "shaderCullDistance")]
    pub shader_cull_distance: bool,
    #[doc(alias = "shaderFloat64")]
    pub shader_float64: bool,
    #[doc(alias = "shaderInt64")]
    pub shader_int64: bool,
    #[doc(alias = "shaderInt16")]
    pub shader_int16: bool,
    #[doc(alias = "shaderResourceResidency")]
    pub shader_resource_residency: bool,
    #[doc(alias = "shaderResourceMinLod")]
    pub shader_resource_min_lod: bool,
    #[doc(alias = "sparseBinding")]
    pub sparse_binding: bool,
    #[doc(alias = "sparseResidencyBuffer")]
    pub sparse_residency_buffer: bool,
    #[doc(alias = "sparseResidencyImage2D")]
    pub sparse_residency_image2_d: bool,
    #[doc(alias = "sparseResidencyImage3D")]
    pub sparse_residency_image3_d: bool,
    #[doc(alias = "sparseResidency2Samples")]
    pub sparse_residency2_samples: bool,
    #[doc(alias = "sparseResidency4Samples")]
    pub sparse_residency4_samples: bool,
    #[doc(alias = "sparseResidency8Samples")]
    pub sparse_residency8_samples: bool,
    #[doc(alias = "sparseResidency16Samples")]
    pub sparse_residency16_samples: bool,
    #[doc(alias = "sparseResidencyAliased")]
    pub sparse_residency_aliased: bool,
    #[doc(alias = "variableMultisampleRate")]
    pub variable_multisample_rate: bool,
    #[doc(alias = "inheritedQueries")]
    pub inherited_queries: bool,
}
impl PhysicalDeviceFeatures {
    ///Get a reference to the `robust_buffer_access` field.
    pub fn robust_buffer_access(&self) -> &bool {
        &self.robust_buffer_access
    }
    ///Get a reference to the `full_draw_index_uint32` field.
    pub fn full_draw_index_uint32(&self) -> &bool {
        &self.full_draw_index_uint32
    }
    ///Get a reference to the `image_cube_array` field.
    pub fn image_cube_array(&self) -> &bool {
        &self.image_cube_array
    }
    ///Get a reference to the `independent_blend` field.
    pub fn independent_blend(&self) -> &bool {
        &self.independent_blend
    }
    ///Get a reference to the `geometry_shader` field.
    pub fn geometry_shader(&self) -> &bool {
        &self.geometry_shader
    }
    ///Get a reference to the `tessellation_shader` field.
    pub fn tessellation_shader(&self) -> &bool {
        &self.tessellation_shader
    }
    ///Get a reference to the `sample_rate_shading` field.
    pub fn sample_rate_shading(&self) -> &bool {
        &self.sample_rate_shading
    }
    ///Get a reference to the `dual_src_blend` field.
    pub fn dual_src_blend(&self) -> &bool {
        &self.dual_src_blend
    }
    ///Get a reference to the `logic_op` field.
    pub fn logic_op(&self) -> &bool {
        &self.logic_op
    }
    ///Get a reference to the `multi_draw_indirect` field.
    pub fn multi_draw_indirect(&self) -> &bool {
        &self.multi_draw_indirect
    }
    ///Get a reference to the `draw_indirect_first_instance` field.
    pub fn draw_indirect_first_instance(&self) -> &bool {
        &self.draw_indirect_first_instance
    }
    ///Get a reference to the `depth_clamp` field.
    pub fn depth_clamp(&self) -> &bool {
        &self.depth_clamp
    }
    ///Get a reference to the `depth_bias_clamp` field.
    pub fn depth_bias_clamp(&self) -> &bool {
        &self.depth_bias_clamp
    }
    ///Get a reference to the `fill_mode_non_solid` field.
    pub fn fill_mode_non_solid(&self) -> &bool {
        &self.fill_mode_non_solid
    }
    ///Get a reference to the `depth_bounds` field.
    pub fn depth_bounds(&self) -> &bool {
        &self.depth_bounds
    }
    ///Get a reference to the `wide_lines` field.
    pub fn wide_lines(&self) -> &bool {
        &self.wide_lines
    }
    ///Get a reference to the `large_points` field.
    pub fn large_points(&self) -> &bool {
        &self.large_points
    }
    ///Get a reference to the `alpha_to_one` field.
    pub fn alpha_to_one(&self) -> &bool {
        &self.alpha_to_one
    }
    ///Get a reference to the `multi_viewport` field.
    pub fn multi_viewport(&self) -> &bool {
        &self.multi_viewport
    }
    ///Get a reference to the `sampler_anisotropy` field.
    pub fn sampler_anisotropy(&self) -> &bool {
        &self.sampler_anisotropy
    }
    ///Get a reference to the `texture_compression_etc2` field.
    pub fn texture_compression_etc2(&self) -> &bool {
        &self.texture_compression_etc2
    }
    ///Get a reference to the `texture_compression_astc_ldr` field.
    pub fn texture_compression_astc_ldr(&self) -> &bool {
        &self.texture_compression_astc_ldr
    }
    ///Get a reference to the `texture_compression_bc` field.
    pub fn texture_compression_bc(&self) -> &bool {
        &self.texture_compression_bc
    }
    ///Get a reference to the `occlusion_query_precise` field.
    pub fn occlusion_query_precise(&self) -> &bool {
        &self.occlusion_query_precise
    }
    ///Get a reference to the `pipeline_statistics_query` field.
    pub fn pipeline_statistics_query(&self) -> &bool {
        &self.pipeline_statistics_query
    }
    ///Get a reference to the `vertex_pipeline_stores_and_atomics` field.
    pub fn vertex_pipeline_stores_and_atomics(&self) -> &bool {
        &self.vertex_pipeline_stores_and_atomics
    }
    ///Get a reference to the `fragment_stores_and_atomics` field.
    pub fn fragment_stores_and_atomics(&self) -> &bool {
        &self.fragment_stores_and_atomics
    }
    ///Get a reference to the `shader_tessellation_and_geometry_point_size` field.
    pub fn shader_tessellation_and_geometry_point_size(&self) -> &bool {
        &self.shader_tessellation_and_geometry_point_size
    }
    ///Get a reference to the `shader_image_gather_extended` field.
    pub fn shader_image_gather_extended(&self) -> &bool {
        &self.shader_image_gather_extended
    }
    ///Get a reference to the `shader_storage_image_extended_formats` field.
    pub fn shader_storage_image_extended_formats(&self) -> &bool {
        &self.shader_storage_image_extended_formats
    }
    ///Get a reference to the `shader_storage_image_multisample` field.
    pub fn shader_storage_image_multisample(&self) -> &bool {
        &self.shader_storage_image_multisample
    }
    ///Get a reference to the `shader_storage_image_read_without_format` field.
    pub fn shader_storage_image_read_without_format(&self) -> &bool {
        &self.shader_storage_image_read_without_format
    }
    ///Get a reference to the `shader_storage_image_write_without_format` field.
    pub fn shader_storage_image_write_without_format(&self) -> &bool {
        &self.shader_storage_image_write_without_format
    }
    ///Get a reference to the `shader_uniform_buffer_array_dynamic_indexing` field.
    pub fn shader_uniform_buffer_array_dynamic_indexing(&self) -> &bool {
        &self.shader_uniform_buffer_array_dynamic_indexing
    }
    ///Get a reference to the `shader_sampled_image_array_dynamic_indexing` field.
    pub fn shader_sampled_image_array_dynamic_indexing(&self) -> &bool {
        &self.shader_sampled_image_array_dynamic_indexing
    }
    ///Get a reference to the `shader_storage_buffer_array_dynamic_indexing` field.
    pub fn shader_storage_buffer_array_dynamic_indexing(&self) -> &bool {
        &self.shader_storage_buffer_array_dynamic_indexing
    }
    ///Get a reference to the `shader_storage_image_array_dynamic_indexing` field.
    pub fn shader_storage_image_array_dynamic_indexing(&self) -> &bool {
        &self.shader_storage_image_array_dynamic_indexing
    }
    ///Get a reference to the `shader_clip_distance` field.
    pub fn shader_clip_distance(&self) -> &bool {
        &self.shader_clip_distance
    }
    ///Get a reference to the `shader_cull_distance` field.
    pub fn shader_cull_distance(&self) -> &bool {
        &self.shader_cull_distance
    }
    ///Get a reference to the `shader_float64` field.
    pub fn shader_float64(&self) -> &bool {
        &self.shader_float64
    }
    ///Get a reference to the `shader_int64` field.
    pub fn shader_int64(&self) -> &bool {
        &self.shader_int64
    }
    ///Get a reference to the `shader_int16` field.
    pub fn shader_int16(&self) -> &bool {
        &self.shader_int16
    }
    ///Get a reference to the `shader_resource_residency` field.
    pub fn shader_resource_residency(&self) -> &bool {
        &self.shader_resource_residency
    }
    ///Get a reference to the `shader_resource_min_lod` field.
    pub fn shader_resource_min_lod(&self) -> &bool {
        &self.shader_resource_min_lod
    }
    ///Get a reference to the `sparse_binding` field.
    pub fn sparse_binding(&self) -> &bool {
        &self.sparse_binding
    }
    ///Get a reference to the `sparse_residency_buffer` field.
    pub fn sparse_residency_buffer(&self) -> &bool {
        &self.sparse_residency_buffer
    }
    ///Get a reference to the `sparse_residency_image2_d` field.
    pub fn sparse_residency_image2_d(&self) -> &bool {
        &self.sparse_residency_image2_d
    }
    ///Get a reference to the `sparse_residency_image3_d` field.
    pub fn sparse_residency_image3_d(&self) -> &bool {
        &self.sparse_residency_image3_d
    }
    ///Get a reference to the `sparse_residency2_samples` field.
    pub fn sparse_residency2_samples(&self) -> &bool {
        &self.sparse_residency2_samples
    }
    ///Get a reference to the `sparse_residency4_samples` field.
    pub fn sparse_residency4_samples(&self) -> &bool {
        &self.sparse_residency4_samples
    }
    ///Get a reference to the `sparse_residency8_samples` field.
    pub fn sparse_residency8_samples(&self) -> &bool {
        &self.sparse_residency8_samples
    }
    ///Get a reference to the `sparse_residency16_samples` field.
    pub fn sparse_residency16_samples(&self) -> &bool {
        &self.sparse_residency16_samples
    }
    ///Get a reference to the `sparse_residency_aliased` field.
    pub fn sparse_residency_aliased(&self) -> &bool {
        &self.sparse_residency_aliased
    }
    ///Get a reference to the `variable_multisample_rate` field.
    pub fn variable_multisample_rate(&self) -> &bool {
        &self.variable_multisample_rate
    }
    ///Get a reference to the `inherited_queries` field.
    pub fn inherited_queries(&self) -> &bool {
        &self.inherited_queries
    }
    ///Get a mutable reference to the `robust_buffer_access` field.
    pub fn robust_buffer_access_mut(&mut self) -> &mut bool {
        &mut self.robust_buffer_access
    }
    ///Get a mutable reference to the `full_draw_index_uint32` field.
    pub fn full_draw_index_uint32_mut(&mut self) -> &mut bool {
        &mut self.full_draw_index_uint32
    }
    ///Get a mutable reference to the `image_cube_array` field.
    pub fn image_cube_array_mut(&mut self) -> &mut bool {
        &mut self.image_cube_array
    }
    ///Get a mutable reference to the `independent_blend` field.
    pub fn independent_blend_mut(&mut self) -> &mut bool {
        &mut self.independent_blend
    }
    ///Get a mutable reference to the `geometry_shader` field.
    pub fn geometry_shader_mut(&mut self) -> &mut bool {
        &mut self.geometry_shader
    }
    ///Get a mutable reference to the `tessellation_shader` field.
    pub fn tessellation_shader_mut(&mut self) -> &mut bool {
        &mut self.tessellation_shader
    }
    ///Get a mutable reference to the `sample_rate_shading` field.
    pub fn sample_rate_shading_mut(&mut self) -> &mut bool {
        &mut self.sample_rate_shading
    }
    ///Get a mutable reference to the `dual_src_blend` field.
    pub fn dual_src_blend_mut(&mut self) -> &mut bool {
        &mut self.dual_src_blend
    }
    ///Get a mutable reference to the `logic_op` field.
    pub fn logic_op_mut(&mut self) -> &mut bool {
        &mut self.logic_op
    }
    ///Get a mutable reference to the `multi_draw_indirect` field.
    pub fn multi_draw_indirect_mut(&mut self) -> &mut bool {
        &mut self.multi_draw_indirect
    }
    ///Get a mutable reference to the `draw_indirect_first_instance` field.
    pub fn draw_indirect_first_instance_mut(&mut self) -> &mut bool {
        &mut self.draw_indirect_first_instance
    }
    ///Get a mutable reference to the `depth_clamp` field.
    pub fn depth_clamp_mut(&mut self) -> &mut bool {
        &mut self.depth_clamp
    }
    ///Get a mutable reference to the `depth_bias_clamp` field.
    pub fn depth_bias_clamp_mut(&mut self) -> &mut bool {
        &mut self.depth_bias_clamp
    }
    ///Get a mutable reference to the `fill_mode_non_solid` field.
    pub fn fill_mode_non_solid_mut(&mut self) -> &mut bool {
        &mut self.fill_mode_non_solid
    }
    ///Get a mutable reference to the `depth_bounds` field.
    pub fn depth_bounds_mut(&mut self) -> &mut bool {
        &mut self.depth_bounds
    }
    ///Get a mutable reference to the `wide_lines` field.
    pub fn wide_lines_mut(&mut self) -> &mut bool {
        &mut self.wide_lines
    }
    ///Get a mutable reference to the `large_points` field.
    pub fn large_points_mut(&mut self) -> &mut bool {
        &mut self.large_points
    }
    ///Get a mutable reference to the `alpha_to_one` field.
    pub fn alpha_to_one_mut(&mut self) -> &mut bool {
        &mut self.alpha_to_one
    }
    ///Get a mutable reference to the `multi_viewport` field.
    pub fn multi_viewport_mut(&mut self) -> &mut bool {
        &mut self.multi_viewport
    }
    ///Get a mutable reference to the `sampler_anisotropy` field.
    pub fn sampler_anisotropy_mut(&mut self) -> &mut bool {
        &mut self.sampler_anisotropy
    }
    ///Get a mutable reference to the `texture_compression_etc2` field.
    pub fn texture_compression_etc2_mut(&mut self) -> &mut bool {
        &mut self.texture_compression_etc2
    }
    ///Get a mutable reference to the `texture_compression_astc_ldr` field.
    pub fn texture_compression_astc_ldr_mut(&mut self) -> &mut bool {
        &mut self.texture_compression_astc_ldr
    }
    ///Get a mutable reference to the `texture_compression_bc` field.
    pub fn texture_compression_bc_mut(&mut self) -> &mut bool {
        &mut self.texture_compression_bc
    }
    ///Get a mutable reference to the `occlusion_query_precise` field.
    pub fn occlusion_query_precise_mut(&mut self) -> &mut bool {
        &mut self.occlusion_query_precise
    }
    ///Get a mutable reference to the `pipeline_statistics_query` field.
    pub fn pipeline_statistics_query_mut(&mut self) -> &mut bool {
        &mut self.pipeline_statistics_query
    }
    ///Get a mutable reference to the `vertex_pipeline_stores_and_atomics` field.
    pub fn vertex_pipeline_stores_and_atomics_mut(&mut self) -> &mut bool {
        &mut self.vertex_pipeline_stores_and_atomics
    }
    ///Get a mutable reference to the `fragment_stores_and_atomics` field.
    pub fn fragment_stores_and_atomics_mut(&mut self) -> &mut bool {
        &mut self.fragment_stores_and_atomics
    }
    ///Get a mutable reference to the `shader_tessellation_and_geometry_point_size` field.
    pub fn shader_tessellation_and_geometry_point_size_mut(&mut self) -> &mut bool {
        &mut self.shader_tessellation_and_geometry_point_size
    }
    ///Get a mutable reference to the `shader_image_gather_extended` field.
    pub fn shader_image_gather_extended_mut(&mut self) -> &mut bool {
        &mut self.shader_image_gather_extended
    }
    ///Get a mutable reference to the `shader_storage_image_extended_formats` field.
    pub fn shader_storage_image_extended_formats_mut(&mut self) -> &mut bool {
        &mut self.shader_storage_image_extended_formats
    }
    ///Get a mutable reference to the `shader_storage_image_multisample` field.
    pub fn shader_storage_image_multisample_mut(&mut self) -> &mut bool {
        &mut self.shader_storage_image_multisample
    }
    ///Get a mutable reference to the `shader_storage_image_read_without_format` field.
    pub fn shader_storage_image_read_without_format_mut(&mut self) -> &mut bool {
        &mut self.shader_storage_image_read_without_format
    }
    ///Get a mutable reference to the `shader_storage_image_write_without_format` field.
    pub fn shader_storage_image_write_without_format_mut(&mut self) -> &mut bool {
        &mut self.shader_storage_image_write_without_format
    }
    ///Get a mutable reference to the `shader_uniform_buffer_array_dynamic_indexing` field.
    pub fn shader_uniform_buffer_array_dynamic_indexing_mut(&mut self) -> &mut bool {
        &mut self.shader_uniform_buffer_array_dynamic_indexing
    }
    ///Get a mutable reference to the `shader_sampled_image_array_dynamic_indexing` field.
    pub fn shader_sampled_image_array_dynamic_indexing_mut(&mut self) -> &mut bool {
        &mut self.shader_sampled_image_array_dynamic_indexing
    }
    ///Get a mutable reference to the `shader_storage_buffer_array_dynamic_indexing` field.
    pub fn shader_storage_buffer_array_dynamic_indexing_mut(&mut self) -> &mut bool {
        &mut self.shader_storage_buffer_array_dynamic_indexing
    }
    ///Get a mutable reference to the `shader_storage_image_array_dynamic_indexing` field.
    pub fn shader_storage_image_array_dynamic_indexing_mut(&mut self) -> &mut bool {
        &mut self.shader_storage_image_array_dynamic_indexing
    }
    ///Get a mutable reference to the `shader_clip_distance` field.
    pub fn shader_clip_distance_mut(&mut self) -> &mut bool {
        &mut self.shader_clip_distance
    }
    ///Get a mutable reference to the `shader_cull_distance` field.
    pub fn shader_cull_distance_mut(&mut self) -> &mut bool {
        &mut self.shader_cull_distance
    }
    ///Get a mutable reference to the `shader_float64` field.
    pub fn shader_float64_mut(&mut self) -> &mut bool {
        &mut self.shader_float64
    }
    ///Get a mutable reference to the `shader_int64` field.
    pub fn shader_int64_mut(&mut self) -> &mut bool {
        &mut self.shader_int64
    }
    ///Get a mutable reference to the `shader_int16` field.
    pub fn shader_int16_mut(&mut self) -> &mut bool {
        &mut self.shader_int16
    }
    ///Get a mutable reference to the `shader_resource_residency` field.
    pub fn shader_resource_residency_mut(&mut self) -> &mut bool {
        &mut self.shader_resource_residency
    }
    ///Get a mutable reference to the `shader_resource_min_lod` field.
    pub fn shader_resource_min_lod_mut(&mut self) -> &mut bool {
        &mut self.shader_resource_min_lod
    }
    ///Get a mutable reference to the `sparse_binding` field.
    pub fn sparse_binding_mut(&mut self) -> &mut bool {
        &mut self.sparse_binding
    }
    ///Get a mutable reference to the `sparse_residency_buffer` field.
    pub fn sparse_residency_buffer_mut(&mut self) -> &mut bool {
        &mut self.sparse_residency_buffer
    }
    ///Get a mutable reference to the `sparse_residency_image2_d` field.
    pub fn sparse_residency_image2_d_mut(&mut self) -> &mut bool {
        &mut self.sparse_residency_image2_d
    }
    ///Get a mutable reference to the `sparse_residency_image3_d` field.
    pub fn sparse_residency_image3_d_mut(&mut self) -> &mut bool {
        &mut self.sparse_residency_image3_d
    }
    ///Get a mutable reference to the `sparse_residency2_samples` field.
    pub fn sparse_residency2_samples_mut(&mut self) -> &mut bool {
        &mut self.sparse_residency2_samples
    }
    ///Get a mutable reference to the `sparse_residency4_samples` field.
    pub fn sparse_residency4_samples_mut(&mut self) -> &mut bool {
        &mut self.sparse_residency4_samples
    }
    ///Get a mutable reference to the `sparse_residency8_samples` field.
    pub fn sparse_residency8_samples_mut(&mut self) -> &mut bool {
        &mut self.sparse_residency8_samples
    }
    ///Get a mutable reference to the `sparse_residency16_samples` field.
    pub fn sparse_residency16_samples_mut(&mut self) -> &mut bool {
        &mut self.sparse_residency16_samples
    }
    ///Get a mutable reference to the `sparse_residency_aliased` field.
    pub fn sparse_residency_aliased_mut(&mut self) -> &mut bool {
        &mut self.sparse_residency_aliased
    }
    ///Get a mutable reference to the `variable_multisample_rate` field.
    pub fn variable_multisample_rate_mut(&mut self) -> &mut bool {
        &mut self.variable_multisample_rate
    }
    ///Get a mutable reference to the `inherited_queries` field.
    pub fn inherited_queries_mut(&mut self) -> &mut bool {
        &mut self.inherited_queries
    }
    ///Sets the `robust_buffer_access` field.
    pub fn set_robust_buffer_access(&mut self, robust_buffer_access: bool) -> &mut Self {
        self.robust_buffer_access = robust_buffer_access;
        self
    }
    ///Sets the `full_draw_index_uint32` field.
    pub fn set_full_draw_index_uint32(&mut self, full_draw_index_uint32: bool) -> &mut Self {
        self.full_draw_index_uint32 = full_draw_index_uint32;
        self
    }
    ///Sets the `image_cube_array` field.
    pub fn set_image_cube_array(&mut self, image_cube_array: bool) -> &mut Self {
        self.image_cube_array = image_cube_array;
        self
    }
    ///Sets the `independent_blend` field.
    pub fn set_independent_blend(&mut self, independent_blend: bool) -> &mut Self {
        self.independent_blend = independent_blend;
        self
    }
    ///Sets the `geometry_shader` field.
    pub fn set_geometry_shader(&mut self, geometry_shader: bool) -> &mut Self {
        self.geometry_shader = geometry_shader;
        self
    }
    ///Sets the `tessellation_shader` field.
    pub fn set_tessellation_shader(&mut self, tessellation_shader: bool) -> &mut Self {
        self.tessellation_shader = tessellation_shader;
        self
    }
    ///Sets the `sample_rate_shading` field.
    pub fn set_sample_rate_shading(&mut self, sample_rate_shading: bool) -> &mut Self {
        self.sample_rate_shading = sample_rate_shading;
        self
    }
    ///Sets the `dual_src_blend` field.
    pub fn set_dual_src_blend(&mut self, dual_src_blend: bool) -> &mut Self {
        self.dual_src_blend = dual_src_blend;
        self
    }
    ///Sets the `logic_op` field.
    pub fn set_logic_op(&mut self, logic_op: bool) -> &mut Self {
        self.logic_op = logic_op;
        self
    }
    ///Sets the `multi_draw_indirect` field.
    pub fn set_multi_draw_indirect(&mut self, multi_draw_indirect: bool) -> &mut Self {
        self.multi_draw_indirect = multi_draw_indirect;
        self
    }
    ///Sets the `draw_indirect_first_instance` field.
    pub fn set_draw_indirect_first_instance(&mut self, draw_indirect_first_instance: bool) -> &mut Self {
        self.draw_indirect_first_instance = draw_indirect_first_instance;
        self
    }
    ///Sets the `depth_clamp` field.
    pub fn set_depth_clamp(&mut self, depth_clamp: bool) -> &mut Self {
        self.depth_clamp = depth_clamp;
        self
    }
    ///Sets the `depth_bias_clamp` field.
    pub fn set_depth_bias_clamp(&mut self, depth_bias_clamp: bool) -> &mut Self {
        self.depth_bias_clamp = depth_bias_clamp;
        self
    }
    ///Sets the `fill_mode_non_solid` field.
    pub fn set_fill_mode_non_solid(&mut self, fill_mode_non_solid: bool) -> &mut Self {
        self.fill_mode_non_solid = fill_mode_non_solid;
        self
    }
    ///Sets the `depth_bounds` field.
    pub fn set_depth_bounds(&mut self, depth_bounds: bool) -> &mut Self {
        self.depth_bounds = depth_bounds;
        self
    }
    ///Sets the `wide_lines` field.
    pub fn set_wide_lines(&mut self, wide_lines: bool) -> &mut Self {
        self.wide_lines = wide_lines;
        self
    }
    ///Sets the `large_points` field.
    pub fn set_large_points(&mut self, large_points: bool) -> &mut Self {
        self.large_points = large_points;
        self
    }
    ///Sets the `alpha_to_one` field.
    pub fn set_alpha_to_one(&mut self, alpha_to_one: bool) -> &mut Self {
        self.alpha_to_one = alpha_to_one;
        self
    }
    ///Sets the `multi_viewport` field.
    pub fn set_multi_viewport(&mut self, multi_viewport: bool) -> &mut Self {
        self.multi_viewport = multi_viewport;
        self
    }
    ///Sets the `sampler_anisotropy` field.
    pub fn set_sampler_anisotropy(&mut self, sampler_anisotropy: bool) -> &mut Self {
        self.sampler_anisotropy = sampler_anisotropy;
        self
    }
    ///Sets the `texture_compression_etc2` field.
    pub fn set_texture_compression_etc2(&mut self, texture_compression_etc2: bool) -> &mut Self {
        self.texture_compression_etc2 = texture_compression_etc2;
        self
    }
    ///Sets the `texture_compression_astc_ldr` field.
    pub fn set_texture_compression_astc_ldr(&mut self, texture_compression_astc_ldr: bool) -> &mut Self {
        self.texture_compression_astc_ldr = texture_compression_astc_ldr;
        self
    }
    ///Sets the `texture_compression_bc` field.
    pub fn set_texture_compression_bc(&mut self, texture_compression_bc: bool) -> &mut Self {
        self.texture_compression_bc = texture_compression_bc;
        self
    }
    ///Sets the `occlusion_query_precise` field.
    pub fn set_occlusion_query_precise(&mut self, occlusion_query_precise: bool) -> &mut Self {
        self.occlusion_query_precise = occlusion_query_precise;
        self
    }
    ///Sets the `pipeline_statistics_query` field.
    pub fn set_pipeline_statistics_query(&mut self, pipeline_statistics_query: bool) -> &mut Self {
        self.pipeline_statistics_query = pipeline_statistics_query;
        self
    }
    ///Sets the `vertex_pipeline_stores_and_atomics` field.
    pub fn set_vertex_pipeline_stores_and_atomics(&mut self, vertex_pipeline_stores_and_atomics: bool) -> &mut Self {
        self.vertex_pipeline_stores_and_atomics = vertex_pipeline_stores_and_atomics;
        self
    }
    ///Sets the `fragment_stores_and_atomics` field.
    pub fn set_fragment_stores_and_atomics(&mut self, fragment_stores_and_atomics: bool) -> &mut Self {
        self.fragment_stores_and_atomics = fragment_stores_and_atomics;
        self
    }
    ///Sets the `shader_tessellation_and_geometry_point_size` field.
    pub fn set_shader_tessellation_and_geometry_point_size(
        &mut self,
        shader_tessellation_and_geometry_point_size: bool,
    ) -> &mut Self {
        self.shader_tessellation_and_geometry_point_size = shader_tessellation_and_geometry_point_size;
        self
    }
    ///Sets the `shader_image_gather_extended` field.
    pub fn set_shader_image_gather_extended(&mut self, shader_image_gather_extended: bool) -> &mut Self {
        self.shader_image_gather_extended = shader_image_gather_extended;
        self
    }
    ///Sets the `shader_storage_image_extended_formats` field.
    pub fn set_shader_storage_image_extended_formats(
        &mut self,
        shader_storage_image_extended_formats: bool,
    ) -> &mut Self {
        self.shader_storage_image_extended_formats = shader_storage_image_extended_formats;
        self
    }
    ///Sets the `shader_storage_image_multisample` field.
    pub fn set_shader_storage_image_multisample(&mut self, shader_storage_image_multisample: bool) -> &mut Self {
        self.shader_storage_image_multisample = shader_storage_image_multisample;
        self
    }
    ///Sets the `shader_storage_image_read_without_format` field.
    pub fn set_shader_storage_image_read_without_format(
        &mut self,
        shader_storage_image_read_without_format: bool,
    ) -> &mut Self {
        self.shader_storage_image_read_without_format = shader_storage_image_read_without_format;
        self
    }
    ///Sets the `shader_storage_image_write_without_format` field.
    pub fn set_shader_storage_image_write_without_format(
        &mut self,
        shader_storage_image_write_without_format: bool,
    ) -> &mut Self {
        self.shader_storage_image_write_without_format = shader_storage_image_write_without_format;
        self
    }
    ///Sets the `shader_uniform_buffer_array_dynamic_indexing` field.
    pub fn set_shader_uniform_buffer_array_dynamic_indexing(
        &mut self,
        shader_uniform_buffer_array_dynamic_indexing: bool,
    ) -> &mut Self {
        self.shader_uniform_buffer_array_dynamic_indexing = shader_uniform_buffer_array_dynamic_indexing;
        self
    }
    ///Sets the `shader_sampled_image_array_dynamic_indexing` field.
    pub fn set_shader_sampled_image_array_dynamic_indexing(
        &mut self,
        shader_sampled_image_array_dynamic_indexing: bool,
    ) -> &mut Self {
        self.shader_sampled_image_array_dynamic_indexing = shader_sampled_image_array_dynamic_indexing;
        self
    }
    ///Sets the `shader_storage_buffer_array_dynamic_indexing` field.
    pub fn set_shader_storage_buffer_array_dynamic_indexing(
        &mut self,
        shader_storage_buffer_array_dynamic_indexing: bool,
    ) -> &mut Self {
        self.shader_storage_buffer_array_dynamic_indexing = shader_storage_buffer_array_dynamic_indexing;
        self
    }
    ///Sets the `shader_storage_image_array_dynamic_indexing` field.
    pub fn set_shader_storage_image_array_dynamic_indexing(
        &mut self,
        shader_storage_image_array_dynamic_indexing: bool,
    ) -> &mut Self {
        self.shader_storage_image_array_dynamic_indexing = shader_storage_image_array_dynamic_indexing;
        self
    }
    ///Sets the `shader_clip_distance` field.
    pub fn set_shader_clip_distance(&mut self, shader_clip_distance: bool) -> &mut Self {
        self.shader_clip_distance = shader_clip_distance;
        self
    }
    ///Sets the `shader_cull_distance` field.
    pub fn set_shader_cull_distance(&mut self, shader_cull_distance: bool) -> &mut Self {
        self.shader_cull_distance = shader_cull_distance;
        self
    }
    ///Sets the `shader_float64` field.
    pub fn set_shader_float64(&mut self, shader_float64: bool) -> &mut Self {
        self.shader_float64 = shader_float64;
        self
    }
    ///Sets the `shader_int64` field.
    pub fn set_shader_int64(&mut self, shader_int64: bool) -> &mut Self {
        self.shader_int64 = shader_int64;
        self
    }
    ///Sets the `shader_int16` field.
    pub fn set_shader_int16(&mut self, shader_int16: bool) -> &mut Self {
        self.shader_int16 = shader_int16;
        self
    }
    ///Sets the `shader_resource_residency` field.
    pub fn set_shader_resource_residency(&mut self, shader_resource_residency: bool) -> &mut Self {
        self.shader_resource_residency = shader_resource_residency;
        self
    }
    ///Sets the `shader_resource_min_lod` field.
    pub fn set_shader_resource_min_lod(&mut self, shader_resource_min_lod: bool) -> &mut Self {
        self.shader_resource_min_lod = shader_resource_min_lod;
        self
    }
    ///Sets the `sparse_binding` field.
    pub fn set_sparse_binding(&mut self, sparse_binding: bool) -> &mut Self {
        self.sparse_binding = sparse_binding;
        self
    }
    ///Sets the `sparse_residency_buffer` field.
    pub fn set_sparse_residency_buffer(&mut self, sparse_residency_buffer: bool) -> &mut Self {
        self.sparse_residency_buffer = sparse_residency_buffer;
        self
    }
    ///Sets the `sparse_residency_image2_d` field.
    pub fn set_sparse_residency_image2_d(&mut self, sparse_residency_image2_d: bool) -> &mut Self {
        self.sparse_residency_image2_d = sparse_residency_image2_d;
        self
    }
    ///Sets the `sparse_residency_image3_d` field.
    pub fn set_sparse_residency_image3_d(&mut self, sparse_residency_image3_d: bool) -> &mut Self {
        self.sparse_residency_image3_d = sparse_residency_image3_d;
        self
    }
    ///Sets the `sparse_residency2_samples` field.
    pub fn set_sparse_residency2_samples(&mut self, sparse_residency2_samples: bool) -> &mut Self {
        self.sparse_residency2_samples = sparse_residency2_samples;
        self
    }
    ///Sets the `sparse_residency4_samples` field.
    pub fn set_sparse_residency4_samples(&mut self, sparse_residency4_samples: bool) -> &mut Self {
        self.sparse_residency4_samples = sparse_residency4_samples;
        self
    }
    ///Sets the `sparse_residency8_samples` field.
    pub fn set_sparse_residency8_samples(&mut self, sparse_residency8_samples: bool) -> &mut Self {
        self.sparse_residency8_samples = sparse_residency8_samples;
        self
    }
    ///Sets the `sparse_residency16_samples` field.
    pub fn set_sparse_residency16_samples(&mut self, sparse_residency16_samples: bool) -> &mut Self {
        self.sparse_residency16_samples = sparse_residency16_samples;
        self
    }
    ///Sets the `sparse_residency_aliased` field.
    pub fn set_sparse_residency_aliased(&mut self, sparse_residency_aliased: bool) -> &mut Self {
        self.sparse_residency_aliased = sparse_residency_aliased;
        self
    }
    ///Sets the `variable_multisample_rate` field.
    pub fn set_variable_multisample_rate(&mut self, variable_multisample_rate: bool) -> &mut Self {
        self.variable_multisample_rate = variable_multisample_rate;
        self
    }
    ///Sets the `inherited_queries` field.
    pub fn set_inherited_queries(&mut self, inherited_queries: bool) -> &mut Self {
        self.inherited_queries = inherited_queries;
        self
    }
    ///Sets the `robust_buffer_access` field in a builder way.
    pub fn with_robust_buffer_access(mut self, robust_buffer_access: bool) -> Self {
        self.robust_buffer_access = robust_buffer_access;
        self
    }
    ///Sets the `full_draw_index_uint32` field in a builder way.
    pub fn with_full_draw_index_uint32(mut self, full_draw_index_uint32: bool) -> Self {
        self.full_draw_index_uint32 = full_draw_index_uint32;
        self
    }
    ///Sets the `image_cube_array` field in a builder way.
    pub fn with_image_cube_array(mut self, image_cube_array: bool) -> Self {
        self.image_cube_array = image_cube_array;
        self
    }
    ///Sets the `independent_blend` field in a builder way.
    pub fn with_independent_blend(mut self, independent_blend: bool) -> Self {
        self.independent_blend = independent_blend;
        self
    }
    ///Sets the `geometry_shader` field in a builder way.
    pub fn with_geometry_shader(mut self, geometry_shader: bool) -> Self {
        self.geometry_shader = geometry_shader;
        self
    }
    ///Sets the `tessellation_shader` field in a builder way.
    pub fn with_tessellation_shader(mut self, tessellation_shader: bool) -> Self {
        self.tessellation_shader = tessellation_shader;
        self
    }
    ///Sets the `sample_rate_shading` field in a builder way.
    pub fn with_sample_rate_shading(mut self, sample_rate_shading: bool) -> Self {
        self.sample_rate_shading = sample_rate_shading;
        self
    }
    ///Sets the `dual_src_blend` field in a builder way.
    pub fn with_dual_src_blend(mut self, dual_src_blend: bool) -> Self {
        self.dual_src_blend = dual_src_blend;
        self
    }
    ///Sets the `logic_op` field in a builder way.
    pub fn with_logic_op(mut self, logic_op: bool) -> Self {
        self.logic_op = logic_op;
        self
    }
    ///Sets the `multi_draw_indirect` field in a builder way.
    pub fn with_multi_draw_indirect(mut self, multi_draw_indirect: bool) -> Self {
        self.multi_draw_indirect = multi_draw_indirect;
        self
    }
    ///Sets the `draw_indirect_first_instance` field in a builder way.
    pub fn with_draw_indirect_first_instance(mut self, draw_indirect_first_instance: bool) -> Self {
        self.draw_indirect_first_instance = draw_indirect_first_instance;
        self
    }
    ///Sets the `depth_clamp` field in a builder way.
    pub fn with_depth_clamp(mut self, depth_clamp: bool) -> Self {
        self.depth_clamp = depth_clamp;
        self
    }
    ///Sets the `depth_bias_clamp` field in a builder way.
    pub fn with_depth_bias_clamp(mut self, depth_bias_clamp: bool) -> Self {
        self.depth_bias_clamp = depth_bias_clamp;
        self
    }
    ///Sets the `fill_mode_non_solid` field in a builder way.
    pub fn with_fill_mode_non_solid(mut self, fill_mode_non_solid: bool) -> Self {
        self.fill_mode_non_solid = fill_mode_non_solid;
        self
    }
    ///Sets the `depth_bounds` field in a builder way.
    pub fn with_depth_bounds(mut self, depth_bounds: bool) -> Self {
        self.depth_bounds = depth_bounds;
        self
    }
    ///Sets the `wide_lines` field in a builder way.
    pub fn with_wide_lines(mut self, wide_lines: bool) -> Self {
        self.wide_lines = wide_lines;
        self
    }
    ///Sets the `large_points` field in a builder way.
    pub fn with_large_points(mut self, large_points: bool) -> Self {
        self.large_points = large_points;
        self
    }
    ///Sets the `alpha_to_one` field in a builder way.
    pub fn with_alpha_to_one(mut self, alpha_to_one: bool) -> Self {
        self.alpha_to_one = alpha_to_one;
        self
    }
    ///Sets the `multi_viewport` field in a builder way.
    pub fn with_multi_viewport(mut self, multi_viewport: bool) -> Self {
        self.multi_viewport = multi_viewport;
        self
    }
    ///Sets the `sampler_anisotropy` field in a builder way.
    pub fn with_sampler_anisotropy(mut self, sampler_anisotropy: bool) -> Self {
        self.sampler_anisotropy = sampler_anisotropy;
        self
    }
    ///Sets the `texture_compression_etc2` field in a builder way.
    pub fn with_texture_compression_etc2(mut self, texture_compression_etc2: bool) -> Self {
        self.texture_compression_etc2 = texture_compression_etc2;
        self
    }
    ///Sets the `texture_compression_astc_ldr` field in a builder way.
    pub fn with_texture_compression_astc_ldr(mut self, texture_compression_astc_ldr: bool) -> Self {
        self.texture_compression_astc_ldr = texture_compression_astc_ldr;
        self
    }
    ///Sets the `texture_compression_bc` field in a builder way.
    pub fn with_texture_compression_bc(mut self, texture_compression_bc: bool) -> Self {
        self.texture_compression_bc = texture_compression_bc;
        self
    }
    ///Sets the `occlusion_query_precise` field in a builder way.
    pub fn with_occlusion_query_precise(mut self, occlusion_query_precise: bool) -> Self {
        self.occlusion_query_precise = occlusion_query_precise;
        self
    }
    ///Sets the `pipeline_statistics_query` field in a builder way.
    pub fn with_pipeline_statistics_query(mut self, pipeline_statistics_query: bool) -> Self {
        self.pipeline_statistics_query = pipeline_statistics_query;
        self
    }
    ///Sets the `vertex_pipeline_stores_and_atomics` field in a builder way.
    pub fn with_vertex_pipeline_stores_and_atomics(mut self, vertex_pipeline_stores_and_atomics: bool) -> Self {
        self.vertex_pipeline_stores_and_atomics = vertex_pipeline_stores_and_atomics;
        self
    }
    ///Sets the `fragment_stores_and_atomics` field in a builder way.
    pub fn with_fragment_stores_and_atomics(mut self, fragment_stores_and_atomics: bool) -> Self {
        self.fragment_stores_and_atomics = fragment_stores_and_atomics;
        self
    }
    ///Sets the `shader_tessellation_and_geometry_point_size` field in a builder way.
    pub fn with_shader_tessellation_and_geometry_point_size(
        mut self,
        shader_tessellation_and_geometry_point_size: bool,
    ) -> Self {
        self.shader_tessellation_and_geometry_point_size = shader_tessellation_and_geometry_point_size;
        self
    }
    ///Sets the `shader_image_gather_extended` field in a builder way.
    pub fn with_shader_image_gather_extended(mut self, shader_image_gather_extended: bool) -> Self {
        self.shader_image_gather_extended = shader_image_gather_extended;
        self
    }
    ///Sets the `shader_storage_image_extended_formats` field in a builder way.
    pub fn with_shader_storage_image_extended_formats(mut self, shader_storage_image_extended_formats: bool) -> Self {
        self.shader_storage_image_extended_formats = shader_storage_image_extended_formats;
        self
    }
    ///Sets the `shader_storage_image_multisample` field in a builder way.
    pub fn with_shader_storage_image_multisample(mut self, shader_storage_image_multisample: bool) -> Self {
        self.shader_storage_image_multisample = shader_storage_image_multisample;
        self
    }
    ///Sets the `shader_storage_image_read_without_format` field in a builder way.
    pub fn with_shader_storage_image_read_without_format(
        mut self,
        shader_storage_image_read_without_format: bool,
    ) -> Self {
        self.shader_storage_image_read_without_format = shader_storage_image_read_without_format;
        self
    }
    ///Sets the `shader_storage_image_write_without_format` field in a builder way.
    pub fn with_shader_storage_image_write_without_format(
        mut self,
        shader_storage_image_write_without_format: bool,
    ) -> Self {
        self.shader_storage_image_write_without_format = shader_storage_image_write_without_format;
        self
    }
    ///Sets the `shader_uniform_buffer_array_dynamic_indexing` field in a builder way.
    pub fn with_shader_uniform_buffer_array_dynamic_indexing(
        mut self,
        shader_uniform_buffer_array_dynamic_indexing: bool,
    ) -> Self {
        self.shader_uniform_buffer_array_dynamic_indexing = shader_uniform_buffer_array_dynamic_indexing;
        self
    }
    ///Sets the `shader_sampled_image_array_dynamic_indexing` field in a builder way.
    pub fn with_shader_sampled_image_array_dynamic_indexing(
        mut self,
        shader_sampled_image_array_dynamic_indexing: bool,
    ) -> Self {
        self.shader_sampled_image_array_dynamic_indexing = shader_sampled_image_array_dynamic_indexing;
        self
    }
    ///Sets the `shader_storage_buffer_array_dynamic_indexing` field in a builder way.
    pub fn with_shader_storage_buffer_array_dynamic_indexing(
        mut self,
        shader_storage_buffer_array_dynamic_indexing: bool,
    ) -> Self {
        self.shader_storage_buffer_array_dynamic_indexing = shader_storage_buffer_array_dynamic_indexing;
        self
    }
    ///Sets the `shader_storage_image_array_dynamic_indexing` field in a builder way.
    pub fn with_shader_storage_image_array_dynamic_indexing(
        mut self,
        shader_storage_image_array_dynamic_indexing: bool,
    ) -> Self {
        self.shader_storage_image_array_dynamic_indexing = shader_storage_image_array_dynamic_indexing;
        self
    }
    ///Sets the `shader_clip_distance` field in a builder way.
    pub fn with_shader_clip_distance(mut self, shader_clip_distance: bool) -> Self {
        self.shader_clip_distance = shader_clip_distance;
        self
    }
    ///Sets the `shader_cull_distance` field in a builder way.
    pub fn with_shader_cull_distance(mut self, shader_cull_distance: bool) -> Self {
        self.shader_cull_distance = shader_cull_distance;
        self
    }
    ///Sets the `shader_float64` field in a builder way.
    pub fn with_shader_float64(mut self, shader_float64: bool) -> Self {
        self.shader_float64 = shader_float64;
        self
    }
    ///Sets the `shader_int64` field in a builder way.
    pub fn with_shader_int64(mut self, shader_int64: bool) -> Self {
        self.shader_int64 = shader_int64;
        self
    }
    ///Sets the `shader_int16` field in a builder way.
    pub fn with_shader_int16(mut self, shader_int16: bool) -> Self {
        self.shader_int16 = shader_int16;
        self
    }
    ///Sets the `shader_resource_residency` field in a builder way.
    pub fn with_shader_resource_residency(mut self, shader_resource_residency: bool) -> Self {
        self.shader_resource_residency = shader_resource_residency;
        self
    }
    ///Sets the `shader_resource_min_lod` field in a builder way.
    pub fn with_shader_resource_min_lod(mut self, shader_resource_min_lod: bool) -> Self {
        self.shader_resource_min_lod = shader_resource_min_lod;
        self
    }
    ///Sets the `sparse_binding` field in a builder way.
    pub fn with_sparse_binding(mut self, sparse_binding: bool) -> Self {
        self.sparse_binding = sparse_binding;
        self
    }
    ///Sets the `sparse_residency_buffer` field in a builder way.
    pub fn with_sparse_residency_buffer(mut self, sparse_residency_buffer: bool) -> Self {
        self.sparse_residency_buffer = sparse_residency_buffer;
        self
    }
    ///Sets the `sparse_residency_image2_d` field in a builder way.
    pub fn with_sparse_residency_image2_d(mut self, sparse_residency_image2_d: bool) -> Self {
        self.sparse_residency_image2_d = sparse_residency_image2_d;
        self
    }
    ///Sets the `sparse_residency_image3_d` field in a builder way.
    pub fn with_sparse_residency_image3_d(mut self, sparse_residency_image3_d: bool) -> Self {
        self.sparse_residency_image3_d = sparse_residency_image3_d;
        self
    }
    ///Sets the `sparse_residency2_samples` field in a builder way.
    pub fn with_sparse_residency2_samples(mut self, sparse_residency2_samples: bool) -> Self {
        self.sparse_residency2_samples = sparse_residency2_samples;
        self
    }
    ///Sets the `sparse_residency4_samples` field in a builder way.
    pub fn with_sparse_residency4_samples(mut self, sparse_residency4_samples: bool) -> Self {
        self.sparse_residency4_samples = sparse_residency4_samples;
        self
    }
    ///Sets the `sparse_residency8_samples` field in a builder way.
    pub fn with_sparse_residency8_samples(mut self, sparse_residency8_samples: bool) -> Self {
        self.sparse_residency8_samples = sparse_residency8_samples;
        self
    }
    ///Sets the `sparse_residency16_samples` field in a builder way.
    pub fn with_sparse_residency16_samples(mut self, sparse_residency16_samples: bool) -> Self {
        self.sparse_residency16_samples = sparse_residency16_samples;
        self
    }
    ///Sets the `sparse_residency_aliased` field in a builder way.
    pub fn with_sparse_residency_aliased(mut self, sparse_residency_aliased: bool) -> Self {
        self.sparse_residency_aliased = sparse_residency_aliased;
        self
    }
    ///Sets the `variable_multisample_rate` field in a builder way.
    pub fn with_variable_multisample_rate(mut self, variable_multisample_rate: bool) -> Self {
        self.variable_multisample_rate = variable_multisample_rate;
        self
    }
    ///Sets the `inherited_queries` field in a builder way.
    pub fn with_inherited_queries(mut self, inherited_queries: bool) -> Self {
        self.inherited_queries = inherited_queries;
        self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for PhysicalDeviceFeatures {
    type LowLevel = crate::native::vulkan1_0::PhysicalDeviceFeatures;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        crate::native::vulkan1_0::PhysicalDeviceFeatures {
            robust_buffer_access: self.robust_buffer_access.into_low_level(context, bump),
            full_draw_index_uint32: self.full_draw_index_uint32.into_low_level(context, bump),
            image_cube_array: self.image_cube_array.into_low_level(context, bump),
            independent_blend: self.independent_blend.into_low_level(context, bump),
            geometry_shader: self.geometry_shader.into_low_level(context, bump),
            tessellation_shader: self.tessellation_shader.into_low_level(context, bump),
            sample_rate_shading: self.sample_rate_shading.into_low_level(context, bump),
            dual_src_blend: self.dual_src_blend.into_low_level(context, bump),
            logic_op: self.logic_op.into_low_level(context, bump),
            multi_draw_indirect: self.multi_draw_indirect.into_low_level(context, bump),
            draw_indirect_first_instance: self.draw_indirect_first_instance.into_low_level(context, bump),
            depth_clamp: self.depth_clamp.into_low_level(context, bump),
            depth_bias_clamp: self.depth_bias_clamp.into_low_level(context, bump),
            fill_mode_non_solid: self.fill_mode_non_solid.into_low_level(context, bump),
            depth_bounds: self.depth_bounds.into_low_level(context, bump),
            wide_lines: self.wide_lines.into_low_level(context, bump),
            large_points: self.large_points.into_low_level(context, bump),
            alpha_to_one: self.alpha_to_one.into_low_level(context, bump),
            multi_viewport: self.multi_viewport.into_low_level(context, bump),
            sampler_anisotropy: self.sampler_anisotropy.into_low_level(context, bump),
            texture_compression_etc2: self.texture_compression_etc2.into_low_level(context, bump),
            texture_compression_astc_ldr: self.texture_compression_astc_ldr.into_low_level(context, bump),
            texture_compression_bc: self.texture_compression_bc.into_low_level(context, bump),
            occlusion_query_precise: self.occlusion_query_precise.into_low_level(context, bump),
            pipeline_statistics_query: self.pipeline_statistics_query.into_low_level(context, bump),
            vertex_pipeline_stores_and_atomics: self.vertex_pipeline_stores_and_atomics.into_low_level(context, bump),
            fragment_stores_and_atomics: self.fragment_stores_and_atomics.into_low_level(context, bump),
            shader_tessellation_and_geometry_point_size: self
                .shader_tessellation_and_geometry_point_size
                .into_low_level(context, bump),
            shader_image_gather_extended: self.shader_image_gather_extended.into_low_level(context, bump),
            shader_storage_image_extended_formats: self
                .shader_storage_image_extended_formats
                .into_low_level(context, bump),
            shader_storage_image_multisample: self.shader_storage_image_multisample.into_low_level(context, bump),
            shader_storage_image_read_without_format: self
                .shader_storage_image_read_without_format
                .into_low_level(context, bump),
            shader_storage_image_write_without_format: self
                .shader_storage_image_write_without_format
                .into_low_level(context, bump),
            shader_uniform_buffer_array_dynamic_indexing: self
                .shader_uniform_buffer_array_dynamic_indexing
                .into_low_level(context, bump),
            shader_sampled_image_array_dynamic_indexing: self
                .shader_sampled_image_array_dynamic_indexing
                .into_low_level(context, bump),
            shader_storage_buffer_array_dynamic_indexing: self
                .shader_storage_buffer_array_dynamic_indexing
                .into_low_level(context, bump),
            shader_storage_image_array_dynamic_indexing: self
                .shader_storage_image_array_dynamic_indexing
                .into_low_level(context, bump),
            shader_clip_distance: self.shader_clip_distance.into_low_level(context, bump),
            shader_cull_distance: self.shader_cull_distance.into_low_level(context, bump),
            shader_float64: self.shader_float64.into_low_level(context, bump),
            shader_int64: self.shader_int64.into_low_level(context, bump),
            shader_int16: self.shader_int16.into_low_level(context, bump),
            shader_resource_residency: self.shader_resource_residency.into_low_level(context, bump),
            shader_resource_min_lod: self.shader_resource_min_lod.into_low_level(context, bump),
            sparse_binding: self.sparse_binding.into_low_level(context, bump),
            sparse_residency_buffer: self.sparse_residency_buffer.into_low_level(context, bump),
            sparse_residency_image2_d: self.sparse_residency_image2_d.into_low_level(context, bump),
            sparse_residency_image3_d: self.sparse_residency_image3_d.into_low_level(context, bump),
            sparse_residency2_samples: self.sparse_residency2_samples.into_low_level(context, bump),
            sparse_residency4_samples: self.sparse_residency4_samples.into_low_level(context, bump),
            sparse_residency8_samples: self.sparse_residency8_samples.into_low_level(context, bump),
            sparse_residency16_samples: self.sparse_residency16_samples.into_low_level(context, bump),
            sparse_residency_aliased: self.sparse_residency_aliased.into_low_level(context, bump),
            variable_multisample_rate: self.variable_multisample_rate.into_low_level(context, bump),
            inherited_queries: self.inherited_queries.into_low_level(context, bump),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for PhysicalDeviceFeatures {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        Self {
            robust_buffer_access: crate::conv::FromLowLevel::from_low_level(context, value.robust_buffer_access),
            full_draw_index_uint32: crate::conv::FromLowLevel::from_low_level(context, value.full_draw_index_uint32),
            image_cube_array: crate::conv::FromLowLevel::from_low_level(context, value.image_cube_array),
            independent_blend: crate::conv::FromLowLevel::from_low_level(context, value.independent_blend),
            geometry_shader: crate::conv::FromLowLevel::from_low_level(context, value.geometry_shader),
            tessellation_shader: crate::conv::FromLowLevel::from_low_level(context, value.tessellation_shader),
            sample_rate_shading: crate::conv::FromLowLevel::from_low_level(context, value.sample_rate_shading),
            dual_src_blend: crate::conv::FromLowLevel::from_low_level(context, value.dual_src_blend),
            logic_op: crate::conv::FromLowLevel::from_low_level(context, value.logic_op),
            multi_draw_indirect: crate::conv::FromLowLevel::from_low_level(context, value.multi_draw_indirect),
            draw_indirect_first_instance: crate::conv::FromLowLevel::from_low_level(
                context,
                value.draw_indirect_first_instance,
            ),
            depth_clamp: crate::conv::FromLowLevel::from_low_level(context, value.depth_clamp),
            depth_bias_clamp: crate::conv::FromLowLevel::from_low_level(context, value.depth_bias_clamp),
            fill_mode_non_solid: crate::conv::FromLowLevel::from_low_level(context, value.fill_mode_non_solid),
            depth_bounds: crate::conv::FromLowLevel::from_low_level(context, value.depth_bounds),
            wide_lines: crate::conv::FromLowLevel::from_low_level(context, value.wide_lines),
            large_points: crate::conv::FromLowLevel::from_low_level(context, value.large_points),
            alpha_to_one: crate::conv::FromLowLevel::from_low_level(context, value.alpha_to_one),
            multi_viewport: crate::conv::FromLowLevel::from_low_level(context, value.multi_viewport),
            sampler_anisotropy: crate::conv::FromLowLevel::from_low_level(context, value.sampler_anisotropy),
            texture_compression_etc2: crate::conv::FromLowLevel::from_low_level(
                context,
                value.texture_compression_etc2,
            ),
            texture_compression_astc_ldr: crate::conv::FromLowLevel::from_low_level(
                context,
                value.texture_compression_astc_ldr,
            ),
            texture_compression_bc: crate::conv::FromLowLevel::from_low_level(context, value.texture_compression_bc),
            occlusion_query_precise: crate::conv::FromLowLevel::from_low_level(context, value.occlusion_query_precise),
            pipeline_statistics_query: crate::conv::FromLowLevel::from_low_level(
                context,
                value.pipeline_statistics_query,
            ),
            vertex_pipeline_stores_and_atomics: crate::conv::FromLowLevel::from_low_level(
                context,
                value.vertex_pipeline_stores_and_atomics,
            ),
            fragment_stores_and_atomics: crate::conv::FromLowLevel::from_low_level(
                context,
                value.fragment_stores_and_atomics,
            ),
            shader_tessellation_and_geometry_point_size: crate::conv::FromLowLevel::from_low_level(
                context,
                value.shader_tessellation_and_geometry_point_size,
            ),
            shader_image_gather_extended: crate::conv::FromLowLevel::from_low_level(
                context,
                value.shader_image_gather_extended,
            ),
            shader_storage_image_extended_formats: crate::conv::FromLowLevel::from_low_level(
                context,
                value.shader_storage_image_extended_formats,
            ),
            shader_storage_image_multisample: crate::conv::FromLowLevel::from_low_level(
                context,
                value.shader_storage_image_multisample,
            ),
            shader_storage_image_read_without_format: crate::conv::FromLowLevel::from_low_level(
                context,
                value.shader_storage_image_read_without_format,
            ),
            shader_storage_image_write_without_format: crate::conv::FromLowLevel::from_low_level(
                context,
                value.shader_storage_image_write_without_format,
            ),
            shader_uniform_buffer_array_dynamic_indexing: crate::conv::FromLowLevel::from_low_level(
                context,
                value.shader_uniform_buffer_array_dynamic_indexing,
            ),
            shader_sampled_image_array_dynamic_indexing: crate::conv::FromLowLevel::from_low_level(
                context,
                value.shader_sampled_image_array_dynamic_indexing,
            ),
            shader_storage_buffer_array_dynamic_indexing: crate::conv::FromLowLevel::from_low_level(
                context,
                value.shader_storage_buffer_array_dynamic_indexing,
            ),
            shader_storage_image_array_dynamic_indexing: crate::conv::FromLowLevel::from_low_level(
                context,
                value.shader_storage_image_array_dynamic_indexing,
            ),
            shader_clip_distance: crate::conv::FromLowLevel::from_low_level(context, value.shader_clip_distance),
            shader_cull_distance: crate::conv::FromLowLevel::from_low_level(context, value.shader_cull_distance),
            shader_float64: crate::conv::FromLowLevel::from_low_level(context, value.shader_float64),
            shader_int64: crate::conv::FromLowLevel::from_low_level(context, value.shader_int64),
            shader_int16: crate::conv::FromLowLevel::from_low_level(context, value.shader_int16),
            shader_resource_residency: crate::conv::FromLowLevel::from_low_level(
                context,
                value.shader_resource_residency,
            ),
            shader_resource_min_lod: crate::conv::FromLowLevel::from_low_level(context, value.shader_resource_min_lod),
            sparse_binding: crate::conv::FromLowLevel::from_low_level(context, value.sparse_binding),
            sparse_residency_buffer: crate::conv::FromLowLevel::from_low_level(context, value.sparse_residency_buffer),
            sparse_residency_image2_d: crate::conv::FromLowLevel::from_low_level(
                context,
                value.sparse_residency_image2_d,
            ),
            sparse_residency_image3_d: crate::conv::FromLowLevel::from_low_level(
                context,
                value.sparse_residency_image3_d,
            ),
            sparse_residency2_samples: crate::conv::FromLowLevel::from_low_level(
                context,
                value.sparse_residency2_samples,
            ),
            sparse_residency4_samples: crate::conv::FromLowLevel::from_low_level(
                context,
                value.sparse_residency4_samples,
            ),
            sparse_residency8_samples: crate::conv::FromLowLevel::from_low_level(
                context,
                value.sparse_residency8_samples,
            ),
            sparse_residency16_samples: crate::conv::FromLowLevel::from_low_level(
                context,
                value.sparse_residency16_samples,
            ),
            sparse_residency_aliased: crate::conv::FromLowLevel::from_low_level(
                context,
                value.sparse_residency_aliased,
            ),
            variable_multisample_rate: crate::conv::FromLowLevel::from_low_level(
                context,
                value.variable_multisample_rate,
            ),
            inherited_queries: crate::conv::FromLowLevel::from_low_level(context, value.inherited_queries),
        }
    }
}
#[doc(alias = "VkPhysicalDeviceSparseProperties")]
#[derive(Clone, PartialEq, Debug, Default)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct PhysicalDeviceSparseProperties {
    #[doc(alias = "residencyStandard2DBlockShape")]
    pub residency_standard2_d_block_shape: bool,
    #[doc(alias = "residencyStandard2DMultisampleBlockShape")]
    pub residency_standard2_d_multisample_block_shape: bool,
    #[doc(alias = "residencyStandard3DBlockShape")]
    pub residency_standard3_d_block_shape: bool,
    #[doc(alias = "residencyAlignedMipSize")]
    pub residency_aligned_mip_size: bool,
    #[doc(alias = "residencyNonResidentStrict")]
    pub residency_non_resident_strict: bool,
}
impl PhysicalDeviceSparseProperties {
    ///Get a reference to the `residency_standard2_d_block_shape` field.
    pub fn residency_standard2_d_block_shape(&self) -> &bool {
        &self.residency_standard2_d_block_shape
    }
    ///Get a reference to the `residency_standard2_d_multisample_block_shape` field.
    pub fn residency_standard2_d_multisample_block_shape(&self) -> &bool {
        &self.residency_standard2_d_multisample_block_shape
    }
    ///Get a reference to the `residency_standard3_d_block_shape` field.
    pub fn residency_standard3_d_block_shape(&self) -> &bool {
        &self.residency_standard3_d_block_shape
    }
    ///Get a reference to the `residency_aligned_mip_size` field.
    pub fn residency_aligned_mip_size(&self) -> &bool {
        &self.residency_aligned_mip_size
    }
    ///Get a reference to the `residency_non_resident_strict` field.
    pub fn residency_non_resident_strict(&self) -> &bool {
        &self.residency_non_resident_strict
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for PhysicalDeviceSparseProperties {
    type LowLevel = crate::native::vulkan1_0::PhysicalDeviceSparseProperties;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        crate::native::vulkan1_0::PhysicalDeviceSparseProperties {
            residency_standard2_d_block_shape: self.residency_standard2_d_block_shape.into_low_level(context, bump),
            residency_standard2_d_multisample_block_shape: self
                .residency_standard2_d_multisample_block_shape
                .into_low_level(context, bump),
            residency_standard3_d_block_shape: self.residency_standard3_d_block_shape.into_low_level(context, bump),
            residency_aligned_mip_size: self.residency_aligned_mip_size.into_low_level(context, bump),
            residency_non_resident_strict: self.residency_non_resident_strict.into_low_level(context, bump),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for PhysicalDeviceSparseProperties {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        Self {
            residency_standard2_d_block_shape: crate::conv::FromLowLevel::from_low_level(
                context,
                value.residency_standard2_d_block_shape,
            ),
            residency_standard2_d_multisample_block_shape: crate::conv::FromLowLevel::from_low_level(
                context,
                value.residency_standard2_d_multisample_block_shape,
            ),
            residency_standard3_d_block_shape: crate::conv::FromLowLevel::from_low_level(
                context,
                value.residency_standard3_d_block_shape,
            ),
            residency_aligned_mip_size: crate::conv::FromLowLevel::from_low_level(
                context,
                value.residency_aligned_mip_size,
            ),
            residency_non_resident_strict: crate::conv::FromLowLevel::from_low_level(
                context,
                value.residency_non_resident_strict,
            ),
        }
    }
}
#[doc(alias = "VkPhysicalDeviceLimits")]
#[derive(Clone, PartialEq, Debug, Default)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct PhysicalDeviceLimits {
    #[doc(alias = "maxImageDimension1D")]
    pub max_image_dimension1_d: u32,
    #[doc(alias = "maxImageDimension2D")]
    pub max_image_dimension2_d: u32,
    #[doc(alias = "maxImageDimension3D")]
    pub max_image_dimension3_d: u32,
    #[doc(alias = "maxImageDimensionCube")]
    pub max_image_dimension_cube: u32,
    #[doc(alias = "maxImageArrayLayers")]
    pub max_image_array_layers: u32,
    #[doc(alias = "maxTexelBufferElements")]
    pub max_texel_buffer_elements: u32,
    #[doc(alias = "maxUniformBufferRange")]
    pub max_uniform_buffer_range: u32,
    #[doc(alias = "maxStorageBufferRange")]
    pub max_storage_buffer_range: u32,
    #[doc(alias = "maxPushConstantsSize")]
    pub max_push_constants_size: u32,
    #[doc(alias = "maxMemoryAllocationCount")]
    pub max_memory_allocation_count: u32,
    #[doc(alias = "maxSamplerAllocationCount")]
    pub max_sampler_allocation_count: u32,
    #[doc(alias = "bufferImageGranularity")]
    pub buffer_image_granularity: DeviceSize,
    #[doc(alias = "sparseAddressSpaceSize")]
    pub sparse_address_space_size: DeviceSize,
    #[doc(alias = "maxBoundDescriptorSets")]
    pub max_bound_descriptor_sets: u32,
    #[doc(alias = "maxPerStageDescriptorSamplers")]
    pub max_per_stage_descriptor_samplers: u32,
    #[doc(alias = "maxPerStageDescriptorUniformBuffers")]
    pub max_per_stage_descriptor_uniform_buffers: u32,
    #[doc(alias = "maxPerStageDescriptorStorageBuffers")]
    pub max_per_stage_descriptor_storage_buffers: u32,
    #[doc(alias = "maxPerStageDescriptorSampledImages")]
    pub max_per_stage_descriptor_sampled_images: u32,
    #[doc(alias = "maxPerStageDescriptorStorageImages")]
    pub max_per_stage_descriptor_storage_images: u32,
    #[doc(alias = "maxPerStageDescriptorInputAttachments")]
    pub max_per_stage_descriptor_input_attachments: u32,
    #[doc(alias = "maxPerStageResources")]
    pub max_per_stage_resources: u32,
    #[doc(alias = "maxDescriptorSetSamplers")]
    pub max_descriptor_set_samplers: u32,
    #[doc(alias = "maxDescriptorSetUniformBuffers")]
    pub max_descriptor_set_uniform_buffers: u32,
    #[doc(alias = "maxDescriptorSetUniformBuffersDynamic")]
    pub max_descriptor_set_uniform_buffers_dynamic: u32,
    #[doc(alias = "maxDescriptorSetStorageBuffers")]
    pub max_descriptor_set_storage_buffers: u32,
    #[doc(alias = "maxDescriptorSetStorageBuffersDynamic")]
    pub max_descriptor_set_storage_buffers_dynamic: u32,
    #[doc(alias = "maxDescriptorSetSampledImages")]
    pub max_descriptor_set_sampled_images: u32,
    #[doc(alias = "maxDescriptorSetStorageImages")]
    pub max_descriptor_set_storage_images: u32,
    #[doc(alias = "maxDescriptorSetInputAttachments")]
    pub max_descriptor_set_input_attachments: u32,
    #[doc(alias = "maxVertexInputAttributes")]
    pub max_vertex_input_attributes: u32,
    #[doc(alias = "maxVertexInputBindings")]
    pub max_vertex_input_bindings: u32,
    #[doc(alias = "maxVertexInputAttributeOffset")]
    pub max_vertex_input_attribute_offset: u32,
    #[doc(alias = "maxVertexInputBindingStride")]
    pub max_vertex_input_binding_stride: u32,
    #[doc(alias = "maxVertexOutputComponents")]
    pub max_vertex_output_components: u32,
    #[doc(alias = "maxTessellationGenerationLevel")]
    pub max_tessellation_generation_level: u32,
    #[doc(alias = "maxTessellationPatchSize")]
    pub max_tessellation_patch_size: u32,
    #[doc(alias = "maxTessellationControlPerVertexInputComponents")]
    pub max_tessellation_control_per_vertex_input_components: u32,
    #[doc(alias = "maxTessellationControlPerVertexOutputComponents")]
    pub max_tessellation_control_per_vertex_output_components: u32,
    #[doc(alias = "maxTessellationControlPerPatchOutputComponents")]
    pub max_tessellation_control_per_patch_output_components: u32,
    #[doc(alias = "maxTessellationControlTotalOutputComponents")]
    pub max_tessellation_control_total_output_components: u32,
    #[doc(alias = "maxTessellationEvaluationInputComponents")]
    pub max_tessellation_evaluation_input_components: u32,
    #[doc(alias = "maxTessellationEvaluationOutputComponents")]
    pub max_tessellation_evaluation_output_components: u32,
    #[doc(alias = "maxGeometryShaderInvocations")]
    pub max_geometry_shader_invocations: u32,
    #[doc(alias = "maxGeometryInputComponents")]
    pub max_geometry_input_components: u32,
    #[doc(alias = "maxGeometryOutputComponents")]
    pub max_geometry_output_components: u32,
    #[doc(alias = "maxGeometryOutputVertices")]
    pub max_geometry_output_vertices: u32,
    #[doc(alias = "maxGeometryTotalOutputComponents")]
    pub max_geometry_total_output_components: u32,
    #[doc(alias = "maxFragmentInputComponents")]
    pub max_fragment_input_components: u32,
    #[doc(alias = "maxFragmentOutputAttachments")]
    pub max_fragment_output_attachments: u32,
    #[doc(alias = "maxFragmentDualSrcAttachments")]
    pub max_fragment_dual_src_attachments: u32,
    #[doc(alias = "maxFragmentCombinedOutputResources")]
    pub max_fragment_combined_output_resources: u32,
    #[doc(alias = "maxComputeSharedMemorySize")]
    pub max_compute_shared_memory_size: u32,
    #[doc(alias = "maxComputeWorkGroupCount")]
    pub max_compute_work_group_count: [u32; 3 as usize],
    #[doc(alias = "maxComputeWorkGroupInvocations")]
    pub max_compute_work_group_invocations: u32,
    #[doc(alias = "maxComputeWorkGroupSize")]
    pub max_compute_work_group_size: [u32; 3 as usize],
    #[doc(alias = "subPixelPrecisionBits")]
    pub sub_pixel_precision_bits: u32,
    #[doc(alias = "subTexelPrecisionBits")]
    pub sub_texel_precision_bits: u32,
    #[doc(alias = "mipmapPrecisionBits")]
    pub mipmap_precision_bits: u32,
    #[doc(alias = "maxDrawIndexedIndexValue")]
    pub max_draw_indexed_index_value: u32,
    #[doc(alias = "maxDrawIndirectCount")]
    pub max_draw_indirect_count: u32,
    #[doc(alias = "maxSamplerLodBias")]
    pub max_sampler_lod_bias: f32,
    #[doc(alias = "maxSamplerAnisotropy")]
    pub max_sampler_anisotropy: f32,
    #[doc(alias = "maxViewports")]
    pub max_viewports: u32,
    #[doc(alias = "maxViewportDimensions")]
    pub max_viewport_dimensions: [u32; 2 as usize],
    #[doc(alias = "viewportBoundsRange")]
    pub viewport_bounds_range: [f32; 2 as usize],
    #[doc(alias = "viewportSubPixelBits")]
    pub viewport_sub_pixel_bits: u32,
    #[doc(alias = "minMemoryMapAlignment")]
    pub min_memory_map_alignment: usize,
    #[doc(alias = "minTexelBufferOffsetAlignment")]
    pub min_texel_buffer_offset_alignment: DeviceSize,
    #[doc(alias = "minUniformBufferOffsetAlignment")]
    pub min_uniform_buffer_offset_alignment: DeviceSize,
    #[doc(alias = "minStorageBufferOffsetAlignment")]
    pub min_storage_buffer_offset_alignment: DeviceSize,
    #[doc(alias = "minTexelOffset")]
    pub min_texel_offset: i32,
    #[doc(alias = "maxTexelOffset")]
    pub max_texel_offset: u32,
    #[doc(alias = "minTexelGatherOffset")]
    pub min_texel_gather_offset: i32,
    #[doc(alias = "maxTexelGatherOffset")]
    pub max_texel_gather_offset: u32,
    #[doc(alias = "minInterpolationOffset")]
    pub min_interpolation_offset: f32,
    #[doc(alias = "maxInterpolationOffset")]
    pub max_interpolation_offset: f32,
    #[doc(alias = "subPixelInterpolationOffsetBits")]
    pub sub_pixel_interpolation_offset_bits: u32,
    #[doc(alias = "maxFramebufferWidth")]
    pub max_framebuffer_width: u32,
    #[doc(alias = "maxFramebufferHeight")]
    pub max_framebuffer_height: u32,
    #[doc(alias = "maxFramebufferLayers")]
    pub max_framebuffer_layers: u32,
    #[doc(alias = "framebufferColorSampleCounts")]
    pub framebuffer_color_sample_counts: SampleCountFlags,
    #[doc(alias = "framebufferDepthSampleCounts")]
    pub framebuffer_depth_sample_counts: SampleCountFlags,
    #[doc(alias = "framebufferStencilSampleCounts")]
    pub framebuffer_stencil_sample_counts: SampleCountFlags,
    #[doc(alias = "framebufferNoAttachmentsSampleCounts")]
    pub framebuffer_no_attachments_sample_counts: SampleCountFlags,
    #[doc(alias = "maxColorAttachments")]
    pub max_color_attachments: u32,
    #[doc(alias = "sampledImageColorSampleCounts")]
    pub sampled_image_color_sample_counts: SampleCountFlags,
    #[doc(alias = "sampledImageIntegerSampleCounts")]
    pub sampled_image_integer_sample_counts: SampleCountFlags,
    #[doc(alias = "sampledImageDepthSampleCounts")]
    pub sampled_image_depth_sample_counts: SampleCountFlags,
    #[doc(alias = "sampledImageStencilSampleCounts")]
    pub sampled_image_stencil_sample_counts: SampleCountFlags,
    #[doc(alias = "storageImageSampleCounts")]
    pub storage_image_sample_counts: SampleCountFlags,
    #[doc(alias = "maxSampleMaskWords")]
    pub max_sample_mask_words: u32,
    #[doc(alias = "timestampComputeAndGraphics")]
    pub timestamp_compute_and_graphics: bool,
    #[doc(alias = "timestampPeriod")]
    pub timestamp_period: f32,
    #[doc(alias = "maxClipDistances")]
    pub max_clip_distances: u32,
    #[doc(alias = "maxCullDistances")]
    pub max_cull_distances: u32,
    #[doc(alias = "maxCombinedClipAndCullDistances")]
    pub max_combined_clip_and_cull_distances: u32,
    #[doc(alias = "discreteQueuePriorities")]
    pub discrete_queue_priorities: u32,
    #[doc(alias = "pointSizeRange")]
    pub point_size_range: [f32; 2 as usize],
    #[doc(alias = "lineWidthRange")]
    pub line_width_range: [f32; 2 as usize],
    #[doc(alias = "pointSizeGranularity")]
    pub point_size_granularity: f32,
    #[doc(alias = "lineWidthGranularity")]
    pub line_width_granularity: f32,
    #[doc(alias = "strictLines")]
    pub strict_lines: bool,
    #[doc(alias = "standardSampleLocations")]
    pub standard_sample_locations: bool,
    #[doc(alias = "optimalBufferCopyOffsetAlignment")]
    pub optimal_buffer_copy_offset_alignment: DeviceSize,
    #[doc(alias = "optimalBufferCopyRowPitchAlignment")]
    pub optimal_buffer_copy_row_pitch_alignment: DeviceSize,
    #[doc(alias = "nonCoherentAtomSize")]
    pub non_coherent_atom_size: DeviceSize,
}
impl PhysicalDeviceLimits {
    ///Get a reference to the `max_image_dimension1_d` field.
    pub fn max_image_dimension1_d(&self) -> u32 {
        self.max_image_dimension1_d
    }
    ///Get a reference to the `max_image_dimension2_d` field.
    pub fn max_image_dimension2_d(&self) -> u32 {
        self.max_image_dimension2_d
    }
    ///Get a reference to the `max_image_dimension3_d` field.
    pub fn max_image_dimension3_d(&self) -> u32 {
        self.max_image_dimension3_d
    }
    ///Get a reference to the `max_image_dimension_cube` field.
    pub fn max_image_dimension_cube(&self) -> u32 {
        self.max_image_dimension_cube
    }
    ///Get a reference to the `max_image_array_layers` field.
    pub fn max_image_array_layers(&self) -> u32 {
        self.max_image_array_layers
    }
    ///Get a reference to the `max_texel_buffer_elements` field.
    pub fn max_texel_buffer_elements(&self) -> u32 {
        self.max_texel_buffer_elements
    }
    ///Get a reference to the `max_uniform_buffer_range` field.
    pub fn max_uniform_buffer_range(&self) -> u32 {
        self.max_uniform_buffer_range
    }
    ///Get a reference to the `max_storage_buffer_range` field.
    pub fn max_storage_buffer_range(&self) -> u32 {
        self.max_storage_buffer_range
    }
    ///Get a reference to the `max_push_constants_size` field.
    pub fn max_push_constants_size(&self) -> u32 {
        self.max_push_constants_size
    }
    ///Get a reference to the `max_memory_allocation_count` field.
    pub fn max_memory_allocation_count(&self) -> u32 {
        self.max_memory_allocation_count
    }
    ///Get a reference to the `max_sampler_allocation_count` field.
    pub fn max_sampler_allocation_count(&self) -> u32 {
        self.max_sampler_allocation_count
    }
    ///Get a reference to the `buffer_image_granularity` field.
    pub fn buffer_image_granularity(&self) -> &DeviceSize {
        &self.buffer_image_granularity
    }
    ///Get a reference to the `sparse_address_space_size` field.
    pub fn sparse_address_space_size(&self) -> &DeviceSize {
        &self.sparse_address_space_size
    }
    ///Get a reference to the `max_bound_descriptor_sets` field.
    pub fn max_bound_descriptor_sets(&self) -> u32 {
        self.max_bound_descriptor_sets
    }
    ///Get a reference to the `max_per_stage_descriptor_samplers` field.
    pub fn max_per_stage_descriptor_samplers(&self) -> u32 {
        self.max_per_stage_descriptor_samplers
    }
    ///Get a reference to the `max_per_stage_descriptor_uniform_buffers` field.
    pub fn max_per_stage_descriptor_uniform_buffers(&self) -> u32 {
        self.max_per_stage_descriptor_uniform_buffers
    }
    ///Get a reference to the `max_per_stage_descriptor_storage_buffers` field.
    pub fn max_per_stage_descriptor_storage_buffers(&self) -> u32 {
        self.max_per_stage_descriptor_storage_buffers
    }
    ///Get a reference to the `max_per_stage_descriptor_sampled_images` field.
    pub fn max_per_stage_descriptor_sampled_images(&self) -> u32 {
        self.max_per_stage_descriptor_sampled_images
    }
    ///Get a reference to the `max_per_stage_descriptor_storage_images` field.
    pub fn max_per_stage_descriptor_storage_images(&self) -> u32 {
        self.max_per_stage_descriptor_storage_images
    }
    ///Get a reference to the `max_per_stage_descriptor_input_attachments` field.
    pub fn max_per_stage_descriptor_input_attachments(&self) -> u32 {
        self.max_per_stage_descriptor_input_attachments
    }
    ///Get a reference to the `max_per_stage_resources` field.
    pub fn max_per_stage_resources(&self) -> u32 {
        self.max_per_stage_resources
    }
    ///Get a reference to the `max_descriptor_set_samplers` field.
    pub fn max_descriptor_set_samplers(&self) -> u32 {
        self.max_descriptor_set_samplers
    }
    ///Get a reference to the `max_descriptor_set_uniform_buffers` field.
    pub fn max_descriptor_set_uniform_buffers(&self) -> u32 {
        self.max_descriptor_set_uniform_buffers
    }
    ///Get a reference to the `max_descriptor_set_uniform_buffers_dynamic` field.
    pub fn max_descriptor_set_uniform_buffers_dynamic(&self) -> u32 {
        self.max_descriptor_set_uniform_buffers_dynamic
    }
    ///Get a reference to the `max_descriptor_set_storage_buffers` field.
    pub fn max_descriptor_set_storage_buffers(&self) -> u32 {
        self.max_descriptor_set_storage_buffers
    }
    ///Get a reference to the `max_descriptor_set_storage_buffers_dynamic` field.
    pub fn max_descriptor_set_storage_buffers_dynamic(&self) -> u32 {
        self.max_descriptor_set_storage_buffers_dynamic
    }
    ///Get a reference to the `max_descriptor_set_sampled_images` field.
    pub fn max_descriptor_set_sampled_images(&self) -> u32 {
        self.max_descriptor_set_sampled_images
    }
    ///Get a reference to the `max_descriptor_set_storage_images` field.
    pub fn max_descriptor_set_storage_images(&self) -> u32 {
        self.max_descriptor_set_storage_images
    }
    ///Get a reference to the `max_descriptor_set_input_attachments` field.
    pub fn max_descriptor_set_input_attachments(&self) -> u32 {
        self.max_descriptor_set_input_attachments
    }
    ///Get a reference to the `max_vertex_input_attributes` field.
    pub fn max_vertex_input_attributes(&self) -> u32 {
        self.max_vertex_input_attributes
    }
    ///Get a reference to the `max_vertex_input_bindings` field.
    pub fn max_vertex_input_bindings(&self) -> u32 {
        self.max_vertex_input_bindings
    }
    ///Get a reference to the `max_vertex_input_attribute_offset` field.
    pub fn max_vertex_input_attribute_offset(&self) -> u32 {
        self.max_vertex_input_attribute_offset
    }
    ///Get a reference to the `max_vertex_input_binding_stride` field.
    pub fn max_vertex_input_binding_stride(&self) -> u32 {
        self.max_vertex_input_binding_stride
    }
    ///Get a reference to the `max_vertex_output_components` field.
    pub fn max_vertex_output_components(&self) -> u32 {
        self.max_vertex_output_components
    }
    ///Get a reference to the `max_tessellation_generation_level` field.
    pub fn max_tessellation_generation_level(&self) -> u32 {
        self.max_tessellation_generation_level
    }
    ///Get a reference to the `max_tessellation_patch_size` field.
    pub fn max_tessellation_patch_size(&self) -> u32 {
        self.max_tessellation_patch_size
    }
    ///Get a reference to the `max_tessellation_control_per_vertex_input_components` field.
    pub fn max_tessellation_control_per_vertex_input_components(&self) -> u32 {
        self.max_tessellation_control_per_vertex_input_components
    }
    ///Get a reference to the `max_tessellation_control_per_vertex_output_components` field.
    pub fn max_tessellation_control_per_vertex_output_components(&self) -> u32 {
        self.max_tessellation_control_per_vertex_output_components
    }
    ///Get a reference to the `max_tessellation_control_per_patch_output_components` field.
    pub fn max_tessellation_control_per_patch_output_components(&self) -> u32 {
        self.max_tessellation_control_per_patch_output_components
    }
    ///Get a reference to the `max_tessellation_control_total_output_components` field.
    pub fn max_tessellation_control_total_output_components(&self) -> u32 {
        self.max_tessellation_control_total_output_components
    }
    ///Get a reference to the `max_tessellation_evaluation_input_components` field.
    pub fn max_tessellation_evaluation_input_components(&self) -> u32 {
        self.max_tessellation_evaluation_input_components
    }
    ///Get a reference to the `max_tessellation_evaluation_output_components` field.
    pub fn max_tessellation_evaluation_output_components(&self) -> u32 {
        self.max_tessellation_evaluation_output_components
    }
    ///Get a reference to the `max_geometry_shader_invocations` field.
    pub fn max_geometry_shader_invocations(&self) -> u32 {
        self.max_geometry_shader_invocations
    }
    ///Get a reference to the `max_geometry_input_components` field.
    pub fn max_geometry_input_components(&self) -> u32 {
        self.max_geometry_input_components
    }
    ///Get a reference to the `max_geometry_output_components` field.
    pub fn max_geometry_output_components(&self) -> u32 {
        self.max_geometry_output_components
    }
    ///Get a reference to the `max_geometry_output_vertices` field.
    pub fn max_geometry_output_vertices(&self) -> u32 {
        self.max_geometry_output_vertices
    }
    ///Get a reference to the `max_geometry_total_output_components` field.
    pub fn max_geometry_total_output_components(&self) -> u32 {
        self.max_geometry_total_output_components
    }
    ///Get a reference to the `max_fragment_input_components` field.
    pub fn max_fragment_input_components(&self) -> u32 {
        self.max_fragment_input_components
    }
    ///Get a reference to the `max_fragment_output_attachments` field.
    pub fn max_fragment_output_attachments(&self) -> u32 {
        self.max_fragment_output_attachments
    }
    ///Get a reference to the `max_fragment_dual_src_attachments` field.
    pub fn max_fragment_dual_src_attachments(&self) -> u32 {
        self.max_fragment_dual_src_attachments
    }
    ///Get a reference to the `max_fragment_combined_output_resources` field.
    pub fn max_fragment_combined_output_resources(&self) -> u32 {
        self.max_fragment_combined_output_resources
    }
    ///Get a reference to the `max_compute_shared_memory_size` field.
    pub fn max_compute_shared_memory_size(&self) -> u32 {
        self.max_compute_shared_memory_size
    }
    ///Get a reference to the `max_compute_work_group_count` field.
    pub fn max_compute_work_group_count(&self) -> [u32; 3 as usize] {
        self.max_compute_work_group_count
    }
    ///Get a reference to the `max_compute_work_group_invocations` field.
    pub fn max_compute_work_group_invocations(&self) -> u32 {
        self.max_compute_work_group_invocations
    }
    ///Get a reference to the `max_compute_work_group_size` field.
    pub fn max_compute_work_group_size(&self) -> [u32; 3 as usize] {
        self.max_compute_work_group_size
    }
    ///Get a reference to the `sub_pixel_precision_bits` field.
    pub fn sub_pixel_precision_bits(&self) -> u32 {
        self.sub_pixel_precision_bits
    }
    ///Get a reference to the `sub_texel_precision_bits` field.
    pub fn sub_texel_precision_bits(&self) -> u32 {
        self.sub_texel_precision_bits
    }
    ///Get a reference to the `mipmap_precision_bits` field.
    pub fn mipmap_precision_bits(&self) -> u32 {
        self.mipmap_precision_bits
    }
    ///Get a reference to the `max_draw_indexed_index_value` field.
    pub fn max_draw_indexed_index_value(&self) -> u32 {
        self.max_draw_indexed_index_value
    }
    ///Get a reference to the `max_draw_indirect_count` field.
    pub fn max_draw_indirect_count(&self) -> u32 {
        self.max_draw_indirect_count
    }
    ///Get a reference to the `max_sampler_lod_bias` field.
    pub fn max_sampler_lod_bias(&self) -> f32 {
        self.max_sampler_lod_bias
    }
    ///Get a reference to the `max_sampler_anisotropy` field.
    pub fn max_sampler_anisotropy(&self) -> f32 {
        self.max_sampler_anisotropy
    }
    ///Get a reference to the `max_viewports` field.
    pub fn max_viewports(&self) -> u32 {
        self.max_viewports
    }
    ///Get a reference to the `max_viewport_dimensions` field.
    pub fn max_viewport_dimensions(&self) -> [u32; 2 as usize] {
        self.max_viewport_dimensions
    }
    ///Get a reference to the `viewport_bounds_range` field.
    pub fn viewport_bounds_range(&self) -> [f32; 2 as usize] {
        self.viewport_bounds_range
    }
    ///Get a reference to the `viewport_sub_pixel_bits` field.
    pub fn viewport_sub_pixel_bits(&self) -> u32 {
        self.viewport_sub_pixel_bits
    }
    ///Get a reference to the `min_memory_map_alignment` field.
    pub fn min_memory_map_alignment(&self) -> usize {
        self.min_memory_map_alignment
    }
    ///Get a reference to the `min_texel_buffer_offset_alignment` field.
    pub fn min_texel_buffer_offset_alignment(&self) -> &DeviceSize {
        &self.min_texel_buffer_offset_alignment
    }
    ///Get a reference to the `min_uniform_buffer_offset_alignment` field.
    pub fn min_uniform_buffer_offset_alignment(&self) -> &DeviceSize {
        &self.min_uniform_buffer_offset_alignment
    }
    ///Get a reference to the `min_storage_buffer_offset_alignment` field.
    pub fn min_storage_buffer_offset_alignment(&self) -> &DeviceSize {
        &self.min_storage_buffer_offset_alignment
    }
    ///Get a reference to the `min_texel_offset` field.
    pub fn min_texel_offset(&self) -> i32 {
        self.min_texel_offset
    }
    ///Get a reference to the `max_texel_offset` field.
    pub fn max_texel_offset(&self) -> u32 {
        self.max_texel_offset
    }
    ///Get a reference to the `min_texel_gather_offset` field.
    pub fn min_texel_gather_offset(&self) -> i32 {
        self.min_texel_gather_offset
    }
    ///Get a reference to the `max_texel_gather_offset` field.
    pub fn max_texel_gather_offset(&self) -> u32 {
        self.max_texel_gather_offset
    }
    ///Get a reference to the `min_interpolation_offset` field.
    pub fn min_interpolation_offset(&self) -> f32 {
        self.min_interpolation_offset
    }
    ///Get a reference to the `max_interpolation_offset` field.
    pub fn max_interpolation_offset(&self) -> f32 {
        self.max_interpolation_offset
    }
    ///Get a reference to the `sub_pixel_interpolation_offset_bits` field.
    pub fn sub_pixel_interpolation_offset_bits(&self) -> u32 {
        self.sub_pixel_interpolation_offset_bits
    }
    ///Get a reference to the `max_framebuffer_width` field.
    pub fn max_framebuffer_width(&self) -> u32 {
        self.max_framebuffer_width
    }
    ///Get a reference to the `max_framebuffer_height` field.
    pub fn max_framebuffer_height(&self) -> u32 {
        self.max_framebuffer_height
    }
    ///Get a reference to the `max_framebuffer_layers` field.
    pub fn max_framebuffer_layers(&self) -> u32 {
        self.max_framebuffer_layers
    }
    ///Get a reference to the `framebuffer_color_sample_counts` field.
    pub fn framebuffer_color_sample_counts(&self) -> SampleCountFlags {
        self.framebuffer_color_sample_counts
    }
    ///Get a reference to the `framebuffer_depth_sample_counts` field.
    pub fn framebuffer_depth_sample_counts(&self) -> SampleCountFlags {
        self.framebuffer_depth_sample_counts
    }
    ///Get a reference to the `framebuffer_stencil_sample_counts` field.
    pub fn framebuffer_stencil_sample_counts(&self) -> SampleCountFlags {
        self.framebuffer_stencil_sample_counts
    }
    ///Get a reference to the `framebuffer_no_attachments_sample_counts` field.
    pub fn framebuffer_no_attachments_sample_counts(&self) -> SampleCountFlags {
        self.framebuffer_no_attachments_sample_counts
    }
    ///Get a reference to the `max_color_attachments` field.
    pub fn max_color_attachments(&self) -> u32 {
        self.max_color_attachments
    }
    ///Get a reference to the `sampled_image_color_sample_counts` field.
    pub fn sampled_image_color_sample_counts(&self) -> SampleCountFlags {
        self.sampled_image_color_sample_counts
    }
    ///Get a reference to the `sampled_image_integer_sample_counts` field.
    pub fn sampled_image_integer_sample_counts(&self) -> SampleCountFlags {
        self.sampled_image_integer_sample_counts
    }
    ///Get a reference to the `sampled_image_depth_sample_counts` field.
    pub fn sampled_image_depth_sample_counts(&self) -> SampleCountFlags {
        self.sampled_image_depth_sample_counts
    }
    ///Get a reference to the `sampled_image_stencil_sample_counts` field.
    pub fn sampled_image_stencil_sample_counts(&self) -> SampleCountFlags {
        self.sampled_image_stencil_sample_counts
    }
    ///Get a reference to the `storage_image_sample_counts` field.
    pub fn storage_image_sample_counts(&self) -> SampleCountFlags {
        self.storage_image_sample_counts
    }
    ///Get a reference to the `max_sample_mask_words` field.
    pub fn max_sample_mask_words(&self) -> u32 {
        self.max_sample_mask_words
    }
    ///Get a reference to the `timestamp_compute_and_graphics` field.
    pub fn timestamp_compute_and_graphics(&self) -> &bool {
        &self.timestamp_compute_and_graphics
    }
    ///Get a reference to the `timestamp_period` field.
    pub fn timestamp_period(&self) -> f32 {
        self.timestamp_period
    }
    ///Get a reference to the `max_clip_distances` field.
    pub fn max_clip_distances(&self) -> u32 {
        self.max_clip_distances
    }
    ///Get a reference to the `max_cull_distances` field.
    pub fn max_cull_distances(&self) -> u32 {
        self.max_cull_distances
    }
    ///Get a reference to the `max_combined_clip_and_cull_distances` field.
    pub fn max_combined_clip_and_cull_distances(&self) -> u32 {
        self.max_combined_clip_and_cull_distances
    }
    ///Get a reference to the `discrete_queue_priorities` field.
    pub fn discrete_queue_priorities(&self) -> u32 {
        self.discrete_queue_priorities
    }
    ///Get a reference to the `point_size_range` field.
    pub fn point_size_range(&self) -> [f32; 2 as usize] {
        self.point_size_range
    }
    ///Get a reference to the `line_width_range` field.
    pub fn line_width_range(&self) -> [f32; 2 as usize] {
        self.line_width_range
    }
    ///Get a reference to the `point_size_granularity` field.
    pub fn point_size_granularity(&self) -> f32 {
        self.point_size_granularity
    }
    ///Get a reference to the `line_width_granularity` field.
    pub fn line_width_granularity(&self) -> f32 {
        self.line_width_granularity
    }
    ///Get a reference to the `strict_lines` field.
    pub fn strict_lines(&self) -> &bool {
        &self.strict_lines
    }
    ///Get a reference to the `standard_sample_locations` field.
    pub fn standard_sample_locations(&self) -> &bool {
        &self.standard_sample_locations
    }
    ///Get a reference to the `optimal_buffer_copy_offset_alignment` field.
    pub fn optimal_buffer_copy_offset_alignment(&self) -> &DeviceSize {
        &self.optimal_buffer_copy_offset_alignment
    }
    ///Get a reference to the `optimal_buffer_copy_row_pitch_alignment` field.
    pub fn optimal_buffer_copy_row_pitch_alignment(&self) -> &DeviceSize {
        &self.optimal_buffer_copy_row_pitch_alignment
    }
    ///Get a reference to the `non_coherent_atom_size` field.
    pub fn non_coherent_atom_size(&self) -> &DeviceSize {
        &self.non_coherent_atom_size
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for PhysicalDeviceLimits {
    type LowLevel = crate::native::vulkan1_0::PhysicalDeviceLimits;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        crate::native::vulkan1_0::PhysicalDeviceLimits {
            max_image_dimension1_d: self.max_image_dimension1_d.into_low_level(context, bump),
            max_image_dimension2_d: self.max_image_dimension2_d.into_low_level(context, bump),
            max_image_dimension3_d: self.max_image_dimension3_d.into_low_level(context, bump),
            max_image_dimension_cube: self.max_image_dimension_cube.into_low_level(context, bump),
            max_image_array_layers: self.max_image_array_layers.into_low_level(context, bump),
            max_texel_buffer_elements: self.max_texel_buffer_elements.into_low_level(context, bump),
            max_uniform_buffer_range: self.max_uniform_buffer_range.into_low_level(context, bump),
            max_storage_buffer_range: self.max_storage_buffer_range.into_low_level(context, bump),
            max_push_constants_size: self.max_push_constants_size.into_low_level(context, bump),
            max_memory_allocation_count: self.max_memory_allocation_count.into_low_level(context, bump),
            max_sampler_allocation_count: self.max_sampler_allocation_count.into_low_level(context, bump),
            buffer_image_granularity: self.buffer_image_granularity.into_low_level(context, bump),
            sparse_address_space_size: self.sparse_address_space_size.into_low_level(context, bump),
            max_bound_descriptor_sets: self.max_bound_descriptor_sets.into_low_level(context, bump),
            max_per_stage_descriptor_samplers: self.max_per_stage_descriptor_samplers.into_low_level(context, bump),
            max_per_stage_descriptor_uniform_buffers: self
                .max_per_stage_descriptor_uniform_buffers
                .into_low_level(context, bump),
            max_per_stage_descriptor_storage_buffers: self
                .max_per_stage_descriptor_storage_buffers
                .into_low_level(context, bump),
            max_per_stage_descriptor_sampled_images: self
                .max_per_stage_descriptor_sampled_images
                .into_low_level(context, bump),
            max_per_stage_descriptor_storage_images: self
                .max_per_stage_descriptor_storage_images
                .into_low_level(context, bump),
            max_per_stage_descriptor_input_attachments: self
                .max_per_stage_descriptor_input_attachments
                .into_low_level(context, bump),
            max_per_stage_resources: self.max_per_stage_resources.into_low_level(context, bump),
            max_descriptor_set_samplers: self.max_descriptor_set_samplers.into_low_level(context, bump),
            max_descriptor_set_uniform_buffers: self.max_descriptor_set_uniform_buffers.into_low_level(context, bump),
            max_descriptor_set_uniform_buffers_dynamic: self
                .max_descriptor_set_uniform_buffers_dynamic
                .into_low_level(context, bump),
            max_descriptor_set_storage_buffers: self.max_descriptor_set_storage_buffers.into_low_level(context, bump),
            max_descriptor_set_storage_buffers_dynamic: self
                .max_descriptor_set_storage_buffers_dynamic
                .into_low_level(context, bump),
            max_descriptor_set_sampled_images: self.max_descriptor_set_sampled_images.into_low_level(context, bump),
            max_descriptor_set_storage_images: self.max_descriptor_set_storage_images.into_low_level(context, bump),
            max_descriptor_set_input_attachments: self
                .max_descriptor_set_input_attachments
                .into_low_level(context, bump),
            max_vertex_input_attributes: self.max_vertex_input_attributes.into_low_level(context, bump),
            max_vertex_input_bindings: self.max_vertex_input_bindings.into_low_level(context, bump),
            max_vertex_input_attribute_offset: self.max_vertex_input_attribute_offset.into_low_level(context, bump),
            max_vertex_input_binding_stride: self.max_vertex_input_binding_stride.into_low_level(context, bump),
            max_vertex_output_components: self.max_vertex_output_components.into_low_level(context, bump),
            max_tessellation_generation_level: self.max_tessellation_generation_level.into_low_level(context, bump),
            max_tessellation_patch_size: self.max_tessellation_patch_size.into_low_level(context, bump),
            max_tessellation_control_per_vertex_input_components: self
                .max_tessellation_control_per_vertex_input_components
                .into_low_level(context, bump),
            max_tessellation_control_per_vertex_output_components: self
                .max_tessellation_control_per_vertex_output_components
                .into_low_level(context, bump),
            max_tessellation_control_per_patch_output_components: self
                .max_tessellation_control_per_patch_output_components
                .into_low_level(context, bump),
            max_tessellation_control_total_output_components: self
                .max_tessellation_control_total_output_components
                .into_low_level(context, bump),
            max_tessellation_evaluation_input_components: self
                .max_tessellation_evaluation_input_components
                .into_low_level(context, bump),
            max_tessellation_evaluation_output_components: self
                .max_tessellation_evaluation_output_components
                .into_low_level(context, bump),
            max_geometry_shader_invocations: self.max_geometry_shader_invocations.into_low_level(context, bump),
            max_geometry_input_components: self.max_geometry_input_components.into_low_level(context, bump),
            max_geometry_output_components: self.max_geometry_output_components.into_low_level(context, bump),
            max_geometry_output_vertices: self.max_geometry_output_vertices.into_low_level(context, bump),
            max_geometry_total_output_components: self
                .max_geometry_total_output_components
                .into_low_level(context, bump),
            max_fragment_input_components: self.max_fragment_input_components.into_low_level(context, bump),
            max_fragment_output_attachments: self.max_fragment_output_attachments.into_low_level(context, bump),
            max_fragment_dual_src_attachments: self.max_fragment_dual_src_attachments.into_low_level(context, bump),
            max_fragment_combined_output_resources: self
                .max_fragment_combined_output_resources
                .into_low_level(context, bump),
            max_compute_shared_memory_size: self.max_compute_shared_memory_size.into_low_level(context, bump),
            max_compute_work_group_count: self.max_compute_work_group_count.into_low_level(context, bump),
            max_compute_work_group_invocations: self.max_compute_work_group_invocations.into_low_level(context, bump),
            max_compute_work_group_size: self.max_compute_work_group_size.into_low_level(context, bump),
            sub_pixel_precision_bits: self.sub_pixel_precision_bits.into_low_level(context, bump),
            sub_texel_precision_bits: self.sub_texel_precision_bits.into_low_level(context, bump),
            mipmap_precision_bits: self.mipmap_precision_bits.into_low_level(context, bump),
            max_draw_indexed_index_value: self.max_draw_indexed_index_value.into_low_level(context, bump),
            max_draw_indirect_count: self.max_draw_indirect_count.into_low_level(context, bump),
            max_sampler_lod_bias: self.max_sampler_lod_bias.into_low_level(context, bump),
            max_sampler_anisotropy: self.max_sampler_anisotropy.into_low_level(context, bump),
            max_viewports: self.max_viewports.into_low_level(context, bump),
            max_viewport_dimensions: self.max_viewport_dimensions.into_low_level(context, bump),
            viewport_bounds_range: self.viewport_bounds_range.into_low_level(context, bump),
            viewport_sub_pixel_bits: self.viewport_sub_pixel_bits.into_low_level(context, bump),
            min_memory_map_alignment: self.min_memory_map_alignment.into_low_level(context, bump),
            min_texel_buffer_offset_alignment: self.min_texel_buffer_offset_alignment.into_low_level(context, bump),
            min_uniform_buffer_offset_alignment: self.min_uniform_buffer_offset_alignment.into_low_level(context, bump),
            min_storage_buffer_offset_alignment: self.min_storage_buffer_offset_alignment.into_low_level(context, bump),
            min_texel_offset: self.min_texel_offset.into_low_level(context, bump),
            max_texel_offset: self.max_texel_offset.into_low_level(context, bump),
            min_texel_gather_offset: self.min_texel_gather_offset.into_low_level(context, bump),
            max_texel_gather_offset: self.max_texel_gather_offset.into_low_level(context, bump),
            min_interpolation_offset: self.min_interpolation_offset.into_low_level(context, bump),
            max_interpolation_offset: self.max_interpolation_offset.into_low_level(context, bump),
            sub_pixel_interpolation_offset_bits: self.sub_pixel_interpolation_offset_bits.into_low_level(context, bump),
            max_framebuffer_width: self.max_framebuffer_width.into_low_level(context, bump),
            max_framebuffer_height: self.max_framebuffer_height.into_low_level(context, bump),
            max_framebuffer_layers: self.max_framebuffer_layers.into_low_level(context, bump),
            framebuffer_color_sample_counts: self.framebuffer_color_sample_counts.into_low_level(context, bump),
            framebuffer_depth_sample_counts: self.framebuffer_depth_sample_counts.into_low_level(context, bump),
            framebuffer_stencil_sample_counts: self.framebuffer_stencil_sample_counts.into_low_level(context, bump),
            framebuffer_no_attachments_sample_counts: self
                .framebuffer_no_attachments_sample_counts
                .into_low_level(context, bump),
            max_color_attachments: self.max_color_attachments.into_low_level(context, bump),
            sampled_image_color_sample_counts: self.sampled_image_color_sample_counts.into_low_level(context, bump),
            sampled_image_integer_sample_counts: self.sampled_image_integer_sample_counts.into_low_level(context, bump),
            sampled_image_depth_sample_counts: self.sampled_image_depth_sample_counts.into_low_level(context, bump),
            sampled_image_stencil_sample_counts: self.sampled_image_stencil_sample_counts.into_low_level(context, bump),
            storage_image_sample_counts: self.storage_image_sample_counts.into_low_level(context, bump),
            max_sample_mask_words: self.max_sample_mask_words.into_low_level(context, bump),
            timestamp_compute_and_graphics: self.timestamp_compute_and_graphics.into_low_level(context, bump),
            timestamp_period: self.timestamp_period.into_low_level(context, bump),
            max_clip_distances: self.max_clip_distances.into_low_level(context, bump),
            max_cull_distances: self.max_cull_distances.into_low_level(context, bump),
            max_combined_clip_and_cull_distances: self
                .max_combined_clip_and_cull_distances
                .into_low_level(context, bump),
            discrete_queue_priorities: self.discrete_queue_priorities.into_low_level(context, bump),
            point_size_range: self.point_size_range.into_low_level(context, bump),
            line_width_range: self.line_width_range.into_low_level(context, bump),
            point_size_granularity: self.point_size_granularity.into_low_level(context, bump),
            line_width_granularity: self.line_width_granularity.into_low_level(context, bump),
            strict_lines: self.strict_lines.into_low_level(context, bump),
            standard_sample_locations: self.standard_sample_locations.into_low_level(context, bump),
            optimal_buffer_copy_offset_alignment: self
                .optimal_buffer_copy_offset_alignment
                .into_low_level(context, bump),
            optimal_buffer_copy_row_pitch_alignment: self
                .optimal_buffer_copy_row_pitch_alignment
                .into_low_level(context, bump),
            non_coherent_atom_size: self.non_coherent_atom_size.into_low_level(context, bump),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for PhysicalDeviceLimits {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        Self {
            max_image_dimension1_d: crate::conv::FromLowLevel::from_low_level(context, value.max_image_dimension1_d),
            max_image_dimension2_d: crate::conv::FromLowLevel::from_low_level(context, value.max_image_dimension2_d),
            max_image_dimension3_d: crate::conv::FromLowLevel::from_low_level(context, value.max_image_dimension3_d),
            max_image_dimension_cube: crate::conv::FromLowLevel::from_low_level(
                context,
                value.max_image_dimension_cube,
            ),
            max_image_array_layers: crate::conv::FromLowLevel::from_low_level(context, value.max_image_array_layers),
            max_texel_buffer_elements: crate::conv::FromLowLevel::from_low_level(
                context,
                value.max_texel_buffer_elements,
            ),
            max_uniform_buffer_range: crate::conv::FromLowLevel::from_low_level(
                context,
                value.max_uniform_buffer_range,
            ),
            max_storage_buffer_range: crate::conv::FromLowLevel::from_low_level(
                context,
                value.max_storage_buffer_range,
            ),
            max_push_constants_size: crate::conv::FromLowLevel::from_low_level(context, value.max_push_constants_size),
            max_memory_allocation_count: crate::conv::FromLowLevel::from_low_level(
                context,
                value.max_memory_allocation_count,
            ),
            max_sampler_allocation_count: crate::conv::FromLowLevel::from_low_level(
                context,
                value.max_sampler_allocation_count,
            ),
            buffer_image_granularity: crate::conv::FromLowLevel::from_low_level(
                context,
                value.buffer_image_granularity,
            ),
            sparse_address_space_size: crate::conv::FromLowLevel::from_low_level(
                context,
                value.sparse_address_space_size,
            ),
            max_bound_descriptor_sets: crate::conv::FromLowLevel::from_low_level(
                context,
                value.max_bound_descriptor_sets,
            ),
            max_per_stage_descriptor_samplers: crate::conv::FromLowLevel::from_low_level(
                context,
                value.max_per_stage_descriptor_samplers,
            ),
            max_per_stage_descriptor_uniform_buffers: crate::conv::FromLowLevel::from_low_level(
                context,
                value.max_per_stage_descriptor_uniform_buffers,
            ),
            max_per_stage_descriptor_storage_buffers: crate::conv::FromLowLevel::from_low_level(
                context,
                value.max_per_stage_descriptor_storage_buffers,
            ),
            max_per_stage_descriptor_sampled_images: crate::conv::FromLowLevel::from_low_level(
                context,
                value.max_per_stage_descriptor_sampled_images,
            ),
            max_per_stage_descriptor_storage_images: crate::conv::FromLowLevel::from_low_level(
                context,
                value.max_per_stage_descriptor_storage_images,
            ),
            max_per_stage_descriptor_input_attachments: crate::conv::FromLowLevel::from_low_level(
                context,
                value.max_per_stage_descriptor_input_attachments,
            ),
            max_per_stage_resources: crate::conv::FromLowLevel::from_low_level(context, value.max_per_stage_resources),
            max_descriptor_set_samplers: crate::conv::FromLowLevel::from_low_level(
                context,
                value.max_descriptor_set_samplers,
            ),
            max_descriptor_set_uniform_buffers: crate::conv::FromLowLevel::from_low_level(
                context,
                value.max_descriptor_set_uniform_buffers,
            ),
            max_descriptor_set_uniform_buffers_dynamic: crate::conv::FromLowLevel::from_low_level(
                context,
                value.max_descriptor_set_uniform_buffers_dynamic,
            ),
            max_descriptor_set_storage_buffers: crate::conv::FromLowLevel::from_low_level(
                context,
                value.max_descriptor_set_storage_buffers,
            ),
            max_descriptor_set_storage_buffers_dynamic: crate::conv::FromLowLevel::from_low_level(
                context,
                value.max_descriptor_set_storage_buffers_dynamic,
            ),
            max_descriptor_set_sampled_images: crate::conv::FromLowLevel::from_low_level(
                context,
                value.max_descriptor_set_sampled_images,
            ),
            max_descriptor_set_storage_images: crate::conv::FromLowLevel::from_low_level(
                context,
                value.max_descriptor_set_storage_images,
            ),
            max_descriptor_set_input_attachments: crate::conv::FromLowLevel::from_low_level(
                context,
                value.max_descriptor_set_input_attachments,
            ),
            max_vertex_input_attributes: crate::conv::FromLowLevel::from_low_level(
                context,
                value.max_vertex_input_attributes,
            ),
            max_vertex_input_bindings: crate::conv::FromLowLevel::from_low_level(
                context,
                value.max_vertex_input_bindings,
            ),
            max_vertex_input_attribute_offset: crate::conv::FromLowLevel::from_low_level(
                context,
                value.max_vertex_input_attribute_offset,
            ),
            max_vertex_input_binding_stride: crate::conv::FromLowLevel::from_low_level(
                context,
                value.max_vertex_input_binding_stride,
            ),
            max_vertex_output_components: crate::conv::FromLowLevel::from_low_level(
                context,
                value.max_vertex_output_components,
            ),
            max_tessellation_generation_level: crate::conv::FromLowLevel::from_low_level(
                context,
                value.max_tessellation_generation_level,
            ),
            max_tessellation_patch_size: crate::conv::FromLowLevel::from_low_level(
                context,
                value.max_tessellation_patch_size,
            ),
            max_tessellation_control_per_vertex_input_components: crate::conv::FromLowLevel::from_low_level(
                context,
                value.max_tessellation_control_per_vertex_input_components,
            ),
            max_tessellation_control_per_vertex_output_components: crate::conv::FromLowLevel::from_low_level(
                context,
                value.max_tessellation_control_per_vertex_output_components,
            ),
            max_tessellation_control_per_patch_output_components: crate::conv::FromLowLevel::from_low_level(
                context,
                value.max_tessellation_control_per_patch_output_components,
            ),
            max_tessellation_control_total_output_components: crate::conv::FromLowLevel::from_low_level(
                context,
                value.max_tessellation_control_total_output_components,
            ),
            max_tessellation_evaluation_input_components: crate::conv::FromLowLevel::from_low_level(
                context,
                value.max_tessellation_evaluation_input_components,
            ),
            max_tessellation_evaluation_output_components: crate::conv::FromLowLevel::from_low_level(
                context,
                value.max_tessellation_evaluation_output_components,
            ),
            max_geometry_shader_invocations: crate::conv::FromLowLevel::from_low_level(
                context,
                value.max_geometry_shader_invocations,
            ),
            max_geometry_input_components: crate::conv::FromLowLevel::from_low_level(
                context,
                value.max_geometry_input_components,
            ),
            max_geometry_output_components: crate::conv::FromLowLevel::from_low_level(
                context,
                value.max_geometry_output_components,
            ),
            max_geometry_output_vertices: crate::conv::FromLowLevel::from_low_level(
                context,
                value.max_geometry_output_vertices,
            ),
            max_geometry_total_output_components: crate::conv::FromLowLevel::from_low_level(
                context,
                value.max_geometry_total_output_components,
            ),
            max_fragment_input_components: crate::conv::FromLowLevel::from_low_level(
                context,
                value.max_fragment_input_components,
            ),
            max_fragment_output_attachments: crate::conv::FromLowLevel::from_low_level(
                context,
                value.max_fragment_output_attachments,
            ),
            max_fragment_dual_src_attachments: crate::conv::FromLowLevel::from_low_level(
                context,
                value.max_fragment_dual_src_attachments,
            ),
            max_fragment_combined_output_resources: crate::conv::FromLowLevel::from_low_level(
                context,
                value.max_fragment_combined_output_resources,
            ),
            max_compute_shared_memory_size: crate::conv::FromLowLevel::from_low_level(
                context,
                value.max_compute_shared_memory_size,
            ),
            max_compute_work_group_count: crate::conv::FromLowLevel::from_low_level(
                context,
                value.max_compute_work_group_count,
            ),
            max_compute_work_group_invocations: crate::conv::FromLowLevel::from_low_level(
                context,
                value.max_compute_work_group_invocations,
            ),
            max_compute_work_group_size: crate::conv::FromLowLevel::from_low_level(
                context,
                value.max_compute_work_group_size,
            ),
            sub_pixel_precision_bits: crate::conv::FromLowLevel::from_low_level(
                context,
                value.sub_pixel_precision_bits,
            ),
            sub_texel_precision_bits: crate::conv::FromLowLevel::from_low_level(
                context,
                value.sub_texel_precision_bits,
            ),
            mipmap_precision_bits: crate::conv::FromLowLevel::from_low_level(context, value.mipmap_precision_bits),
            max_draw_indexed_index_value: crate::conv::FromLowLevel::from_low_level(
                context,
                value.max_draw_indexed_index_value,
            ),
            max_draw_indirect_count: crate::conv::FromLowLevel::from_low_level(context, value.max_draw_indirect_count),
            max_sampler_lod_bias: crate::conv::FromLowLevel::from_low_level(context, value.max_sampler_lod_bias),
            max_sampler_anisotropy: crate::conv::FromLowLevel::from_low_level(context, value.max_sampler_anisotropy),
            max_viewports: crate::conv::FromLowLevel::from_low_level(context, value.max_viewports),
            max_viewport_dimensions: crate::conv::FromLowLevel::from_low_level(context, value.max_viewport_dimensions),
            viewport_bounds_range: crate::conv::FromLowLevel::from_low_level(context, value.viewport_bounds_range),
            viewport_sub_pixel_bits: crate::conv::FromLowLevel::from_low_level(context, value.viewport_sub_pixel_bits),
            min_memory_map_alignment: crate::conv::FromLowLevel::from_low_level(
                context,
                value.min_memory_map_alignment,
            ),
            min_texel_buffer_offset_alignment: crate::conv::FromLowLevel::from_low_level(
                context,
                value.min_texel_buffer_offset_alignment,
            ),
            min_uniform_buffer_offset_alignment: crate::conv::FromLowLevel::from_low_level(
                context,
                value.min_uniform_buffer_offset_alignment,
            ),
            min_storage_buffer_offset_alignment: crate::conv::FromLowLevel::from_low_level(
                context,
                value.min_storage_buffer_offset_alignment,
            ),
            min_texel_offset: crate::conv::FromLowLevel::from_low_level(context, value.min_texel_offset),
            max_texel_offset: crate::conv::FromLowLevel::from_low_level(context, value.max_texel_offset),
            min_texel_gather_offset: crate::conv::FromLowLevel::from_low_level(context, value.min_texel_gather_offset),
            max_texel_gather_offset: crate::conv::FromLowLevel::from_low_level(context, value.max_texel_gather_offset),
            min_interpolation_offset: crate::conv::FromLowLevel::from_low_level(
                context,
                value.min_interpolation_offset,
            ),
            max_interpolation_offset: crate::conv::FromLowLevel::from_low_level(
                context,
                value.max_interpolation_offset,
            ),
            sub_pixel_interpolation_offset_bits: crate::conv::FromLowLevel::from_low_level(
                context,
                value.sub_pixel_interpolation_offset_bits,
            ),
            max_framebuffer_width: crate::conv::FromLowLevel::from_low_level(context, value.max_framebuffer_width),
            max_framebuffer_height: crate::conv::FromLowLevel::from_low_level(context, value.max_framebuffer_height),
            max_framebuffer_layers: crate::conv::FromLowLevel::from_low_level(context, value.max_framebuffer_layers),
            framebuffer_color_sample_counts: crate::conv::FromLowLevel::from_low_level(
                context,
                value.framebuffer_color_sample_counts,
            ),
            framebuffer_depth_sample_counts: crate::conv::FromLowLevel::from_low_level(
                context,
                value.framebuffer_depth_sample_counts,
            ),
            framebuffer_stencil_sample_counts: crate::conv::FromLowLevel::from_low_level(
                context,
                value.framebuffer_stencil_sample_counts,
            ),
            framebuffer_no_attachments_sample_counts: crate::conv::FromLowLevel::from_low_level(
                context,
                value.framebuffer_no_attachments_sample_counts,
            ),
            max_color_attachments: crate::conv::FromLowLevel::from_low_level(context, value.max_color_attachments),
            sampled_image_color_sample_counts: crate::conv::FromLowLevel::from_low_level(
                context,
                value.sampled_image_color_sample_counts,
            ),
            sampled_image_integer_sample_counts: crate::conv::FromLowLevel::from_low_level(
                context,
                value.sampled_image_integer_sample_counts,
            ),
            sampled_image_depth_sample_counts: crate::conv::FromLowLevel::from_low_level(
                context,
                value.sampled_image_depth_sample_counts,
            ),
            sampled_image_stencil_sample_counts: crate::conv::FromLowLevel::from_low_level(
                context,
                value.sampled_image_stencil_sample_counts,
            ),
            storage_image_sample_counts: crate::conv::FromLowLevel::from_low_level(
                context,
                value.storage_image_sample_counts,
            ),
            max_sample_mask_words: crate::conv::FromLowLevel::from_low_level(context, value.max_sample_mask_words),
            timestamp_compute_and_graphics: crate::conv::FromLowLevel::from_low_level(
                context,
                value.timestamp_compute_and_graphics,
            ),
            timestamp_period: crate::conv::FromLowLevel::from_low_level(context, value.timestamp_period),
            max_clip_distances: crate::conv::FromLowLevel::from_low_level(context, value.max_clip_distances),
            max_cull_distances: crate::conv::FromLowLevel::from_low_level(context, value.max_cull_distances),
            max_combined_clip_and_cull_distances: crate::conv::FromLowLevel::from_low_level(
                context,
                value.max_combined_clip_and_cull_distances,
            ),
            discrete_queue_priorities: crate::conv::FromLowLevel::from_low_level(
                context,
                value.discrete_queue_priorities,
            ),
            point_size_range: crate::conv::FromLowLevel::from_low_level(context, value.point_size_range),
            line_width_range: crate::conv::FromLowLevel::from_low_level(context, value.line_width_range),
            point_size_granularity: crate::conv::FromLowLevel::from_low_level(context, value.point_size_granularity),
            line_width_granularity: crate::conv::FromLowLevel::from_low_level(context, value.line_width_granularity),
            strict_lines: crate::conv::FromLowLevel::from_low_level(context, value.strict_lines),
            standard_sample_locations: crate::conv::FromLowLevel::from_low_level(
                context,
                value.standard_sample_locations,
            ),
            optimal_buffer_copy_offset_alignment: crate::conv::FromLowLevel::from_low_level(
                context,
                value.optimal_buffer_copy_offset_alignment,
            ),
            optimal_buffer_copy_row_pitch_alignment: crate::conv::FromLowLevel::from_low_level(
                context,
                value.optimal_buffer_copy_row_pitch_alignment,
            ),
            non_coherent_atom_size: crate::conv::FromLowLevel::from_low_level(context, value.non_coherent_atom_size),
        }
    }
}
#[doc(alias = "VkSemaphoreCreateInfo")]
#[derive(Clone, PartialEq, Debug, Default)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct SemaphoreCreateInfo {
    #[doc(alias = "pNext")]
    pub extensions: SmallVec<[SemaphoreCreateInfoExtension; 1]>,
    pub flags: SemaphoreCreateFlags,
}
impl SemaphoreCreateInfo {
    ///Adds an extension to the struct
    pub fn with_extension(mut self, ext: impl Into<SemaphoreCreateInfoExtension>) -> Self {
        self.extensions.push(ext.into());
        self
    }
    ///Get a reference to the `extensions` field.
    pub fn extensions(&self) -> &SmallVec<[SemaphoreCreateInfoExtension; 1]> {
        &self.extensions
    }
    ///Get a reference to the `flags` field.
    pub fn flags(&self) -> SemaphoreCreateFlags {
        self.flags
    }
    ///Get a mutable reference to the `extensions` field.
    pub fn extensions_mut(&mut self) -> &mut SmallVec<[SemaphoreCreateInfoExtension; 1]> {
        &mut self.extensions
    }
    ///Get a mutable reference to the `flags` field.
    pub fn flags_mut(&mut self) -> &mut SemaphoreCreateFlags {
        &mut self.flags
    }
    ///Sets the `extensions` field.
    pub fn set_extensions(&mut self, extensions: SmallVec<[SemaphoreCreateInfoExtension; 1]>) -> &mut Self {
        self.extensions = extensions;
        self
    }
    ///Sets the `flags` field.
    pub fn set_flags(&mut self, flags: SemaphoreCreateFlags) -> &mut Self {
        self.flags = flags;
        self
    }
    ///Sets the `extensions` field in a builder way.
    pub fn with_extensions(mut self, extensions: SmallVec<[SemaphoreCreateInfoExtension; 1]>) -> Self {
        self.extensions = extensions;
        self
    }
    ///Sets the `flags` field in a builder way.
    pub fn with_flags(mut self, flags: SemaphoreCreateFlags) -> Self {
        self.flags = flags;
        self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for SemaphoreCreateInfo {
    type LowLevel = crate::native::vulkan1_0::SemaphoreCreateInfo;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        let mut next = std::ptr::null();
        let mut extensions = self.extensions.iter();
        while let Some(ext) = extensions.next() {
            let ext = ext.into_low_level(context, bump);
            (*ext).next = next;
            next = ext;
        }
        crate::native::vulkan1_0::SemaphoreCreateInfo {
            s_type: StructureType::SemaphoreCreateInfo,
            p_next: next,
            flags: self.flags.into_low_level(context, bump),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for SemaphoreCreateInfo {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        let mut next = value.p_next;
        let mut extensions = SmallVec::new();
        while !next.is_null() {
            extensions.push(crate::conv::FromLowLevel::from_low_level(context, next));
            next = std::ptr::read(next).next;
        }
        Self {
            extensions: extensions,
            flags: crate::conv::FromLowLevel::from_low_level(context, value.flags),
        }
    }
}
#[derive(Clone, PartialEq, Debug)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
///Extensions for [`SemaphoreCreateInfo`]
pub enum SemaphoreCreateInfoExtension {
    ///Contains a type [`ExportSemaphoreCreateInfo`] for extending [`SemaphoreCreateInfo`]
    ExportSemaphoreCreateInfo(ExportSemaphoreCreateInfo),
    #[cfg(feature = "VK_KHR_external_semaphore_win32")]
    ///Contains a type [`ExportSemaphoreWin32HandleInfoKHR`] for extending [`SemaphoreCreateInfo`]
    ExportSemaphoreWin32HandleInfoKHR(ExportSemaphoreWin32HandleInfoKHR),
    #[cfg(feature = "VULKAN_1_2")]
    ///Contains a type [`SemaphoreTypeCreateInfo`] for extending [`SemaphoreCreateInfo`]
    SemaphoreTypeCreateInfo(SemaphoreTypeCreateInfo),
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for SemaphoreCreateInfoExtension {
    type LowLevel = *const crate::native::vulkan1_0::BaseInStructure;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        match self {
            Self::ExportSemaphoreCreateInfo(ext) => (bump.alloc(ext.into_low_level(context, bump))
                as *mut crate::native::vulkan1_1::ExportSemaphoreCreateInfo)
                .cast(),
            #[cfg(feature = "VK_KHR_external_semaphore_win32")]
            Self::ExportSemaphoreWin32HandleInfoKHR(ext) => (bump.alloc(ext.into_low_level(context, bump))
                as *mut crate::native::extensions::khr_external_semaphore_win32::ExportSemaphoreWin32HandleInfoKHR)
                .cast(),
            #[cfg(feature = "VULKAN_1_2")]
            Self::SemaphoreTypeCreateInfo(ext) => (bump.alloc(ext.into_low_level(context, bump))
                as *mut crate::native::vulkan1_2::SemaphoreTypeCreateInfo)
                .cast(),
            other => unreachable!("unexpected variant {:?}", other),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for SemaphoreCreateInfoExtension {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        assert!(!value.is_null());
        match (* value) . s_type { crate :: native :: vulkan1_0 :: StructureType :: ExportSemaphoreCreateInfo => Self :: ExportSemaphoreCreateInfo (ExportSemaphoreCreateInfo :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: vulkan1_1 :: ExportSemaphoreCreateInfo > ()))) , # [cfg (feature = "VK_KHR_external_semaphore_win32")] crate :: native :: vulkan1_0 :: StructureType :: ExportSemaphoreWin32HandleInfoKhr => Self :: ExportSemaphoreWin32HandleInfoKHR (ExportSemaphoreWin32HandleInfoKHR :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: khr_external_semaphore_win32 :: ExportSemaphoreWin32HandleInfoKHR > ()))) , # [cfg (feature = "VULKAN_1_2")] crate :: native :: vulkan1_0 :: StructureType :: SemaphoreTypeCreateInfo => Self :: SemaphoreTypeCreateInfo (SemaphoreTypeCreateInfo :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: vulkan1_2 :: SemaphoreTypeCreateInfo > ()))) , other => panic ! ("Structure type {:?} is not a member of {}" , other , stringify ! (SemaphoreCreateInfo)) }
    }
}
impl From<ExportSemaphoreCreateInfo> for SemaphoreCreateInfoExtension {
    fn from(ext: ExportSemaphoreCreateInfo) -> Self {
        Self::ExportSemaphoreCreateInfo(ext)
    }
}
impl TryInto<ExportSemaphoreCreateInfo> for SemaphoreCreateInfoExtension {
    type Error = SemaphoreCreateInfoExtension;
    fn try_into(self) -> Result<ExportSemaphoreCreateInfo, Self::Error> {
        match self {
            Self::ExportSemaphoreCreateInfo(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_KHR_external_semaphore_win32")]
impl From<ExportSemaphoreWin32HandleInfoKHR> for SemaphoreCreateInfoExtension {
    fn from(ext: ExportSemaphoreWin32HandleInfoKHR) -> Self {
        Self::ExportSemaphoreWin32HandleInfoKHR(ext)
    }
}
#[cfg(feature = "VK_KHR_external_semaphore_win32")]
impl TryInto<ExportSemaphoreWin32HandleInfoKHR> for SemaphoreCreateInfoExtension {
    type Error = SemaphoreCreateInfoExtension;
    fn try_into(self) -> Result<ExportSemaphoreWin32HandleInfoKHR, Self::Error> {
        match self {
            Self::ExportSemaphoreWin32HandleInfoKHR(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VULKAN_1_2")]
impl From<SemaphoreTypeCreateInfo> for SemaphoreCreateInfoExtension {
    fn from(ext: SemaphoreTypeCreateInfo) -> Self {
        Self::SemaphoreTypeCreateInfo(ext)
    }
}
#[cfg(feature = "VULKAN_1_2")]
impl TryInto<SemaphoreTypeCreateInfo> for SemaphoreCreateInfoExtension {
    type Error = SemaphoreCreateInfoExtension;
    fn try_into(self) -> Result<SemaphoreTypeCreateInfo, Self::Error> {
        match self {
            Self::SemaphoreTypeCreateInfo(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[doc(alias = "VkQueryPoolCreateInfo")]
#[derive(Clone, PartialEq, Debug, Default)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct QueryPoolCreateInfo {
    #[doc(alias = "pNext")]
    pub extensions: SmallVec<[QueryPoolCreateInfoExtension; 1]>,
    pub flags: QueryPoolCreateFlags,
    #[doc(alias = "queryType")]
    pub query_type: QueryType,
    #[doc(alias = "queryCount")]
    pub query_count: u32,
    #[doc(alias = "pipelineStatistics")]
    pub pipeline_statistics: QueryPipelineStatisticFlags,
}
impl QueryPoolCreateInfo {
    ///Adds an extension to the struct
    pub fn with_extension(mut self, ext: impl Into<QueryPoolCreateInfoExtension>) -> Self {
        self.extensions.push(ext.into());
        self
    }
    ///Get a reference to the `extensions` field.
    pub fn extensions(&self) -> &SmallVec<[QueryPoolCreateInfoExtension; 1]> {
        &self.extensions
    }
    ///Get a reference to the `flags` field.
    pub fn flags(&self) -> QueryPoolCreateFlags {
        self.flags
    }
    ///Get a reference to the `query_type` field.
    pub fn query_type(&self) -> QueryType {
        self.query_type
    }
    ///Get a reference to the `query_count` field.
    pub fn query_count(&self) -> u32 {
        self.query_count
    }
    ///Get a reference to the `pipeline_statistics` field.
    pub fn pipeline_statistics(&self) -> QueryPipelineStatisticFlags {
        self.pipeline_statistics
    }
    ///Get a mutable reference to the `extensions` field.
    pub fn extensions_mut(&mut self) -> &mut SmallVec<[QueryPoolCreateInfoExtension; 1]> {
        &mut self.extensions
    }
    ///Get a mutable reference to the `flags` field.
    pub fn flags_mut(&mut self) -> &mut QueryPoolCreateFlags {
        &mut self.flags
    }
    ///Get a mutable reference to the `query_type` field.
    pub fn query_type_mut(&mut self) -> &mut QueryType {
        &mut self.query_type
    }
    ///Get a mutable reference to the `query_count` field.
    pub fn query_count_mut(&mut self) -> &mut u32 {
        &mut self.query_count
    }
    ///Get a mutable reference to the `pipeline_statistics` field.
    pub fn pipeline_statistics_mut(&mut self) -> &mut QueryPipelineStatisticFlags {
        &mut self.pipeline_statistics
    }
    ///Sets the `extensions` field.
    pub fn set_extensions(&mut self, extensions: SmallVec<[QueryPoolCreateInfoExtension; 1]>) -> &mut Self {
        self.extensions = extensions;
        self
    }
    ///Sets the `flags` field.
    pub fn set_flags(&mut self, flags: QueryPoolCreateFlags) -> &mut Self {
        self.flags = flags;
        self
    }
    ///Sets the `query_type` field.
    pub fn set_query_type(&mut self, query_type: QueryType) -> &mut Self {
        self.query_type = query_type;
        self
    }
    ///Sets the `query_count` field.
    pub fn set_query_count(&mut self, query_count: u32) -> &mut Self {
        self.query_count = query_count;
        self
    }
    ///Sets the `pipeline_statistics` field.
    pub fn set_pipeline_statistics(&mut self, pipeline_statistics: QueryPipelineStatisticFlags) -> &mut Self {
        self.pipeline_statistics = pipeline_statistics;
        self
    }
    ///Sets the `extensions` field in a builder way.
    pub fn with_extensions(mut self, extensions: SmallVec<[QueryPoolCreateInfoExtension; 1]>) -> Self {
        self.extensions = extensions;
        self
    }
    ///Sets the `flags` field in a builder way.
    pub fn with_flags(mut self, flags: QueryPoolCreateFlags) -> Self {
        self.flags = flags;
        self
    }
    ///Sets the `query_type` field in a builder way.
    pub fn with_query_type(mut self, query_type: QueryType) -> Self {
        self.query_type = query_type;
        self
    }
    ///Sets the `query_count` field in a builder way.
    pub fn with_query_count(mut self, query_count: u32) -> Self {
        self.query_count = query_count;
        self
    }
    ///Sets the `pipeline_statistics` field in a builder way.
    pub fn with_pipeline_statistics(mut self, pipeline_statistics: QueryPipelineStatisticFlags) -> Self {
        self.pipeline_statistics = pipeline_statistics;
        self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for QueryPoolCreateInfo {
    type LowLevel = crate::native::vulkan1_0::QueryPoolCreateInfo;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        let mut next = std::ptr::null();
        let mut extensions = self.extensions.iter();
        while let Some(ext) = extensions.next() {
            let ext = ext.into_low_level(context, bump);
            (*ext).next = next;
            next = ext;
        }
        crate::native::vulkan1_0::QueryPoolCreateInfo {
            s_type: StructureType::QueryPoolCreateInfo,
            p_next: next,
            flags: self.flags.into_low_level(context, bump),
            query_type: self.query_type.into_low_level(context, bump),
            query_count: self.query_count.into_low_level(context, bump),
            pipeline_statistics: self.pipeline_statistics.into_low_level(context, bump),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for QueryPoolCreateInfo {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        let mut next = value.p_next;
        let mut extensions = SmallVec::new();
        while !next.is_null() {
            extensions.push(crate::conv::FromLowLevel::from_low_level(context, next));
            next = std::ptr::read(next).next;
        }
        Self {
            extensions: extensions,
            flags: crate::conv::FromLowLevel::from_low_level(context, value.flags),
            query_type: crate::conv::FromLowLevel::from_low_level(context, value.query_type),
            query_count: crate::conv::FromLowLevel::from_low_level(context, value.query_count),
            pipeline_statistics: crate::conv::FromLowLevel::from_low_level(context, value.pipeline_statistics),
        }
    }
}
#[derive(Clone, PartialEq, Debug)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
///Extensions for [`QueryPoolCreateInfo`]
pub enum QueryPoolCreateInfoExtension {
    #[cfg(feature = "VK_KHR_performance_query")]
    ///Contains a type [`QueryPoolPerformanceCreateInfoKHR`] for extending [`QueryPoolCreateInfo`]
    QueryPoolPerformanceCreateInfoKHR(QueryPoolPerformanceCreateInfoKHR),
    #[cfg(feature = "VK_INTEL_performance_query")]
    ///Contains a type [`QueryPoolPerformanceQueryCreateInfoINTEL`] for extending
    /// [`QueryPoolCreateInfo`]
    QueryPoolPerformanceQueryCreateInfoINTEL(QueryPoolPerformanceQueryCreateInfoINTEL),
    #[cfg(feature = "VK_KHR_video_queue")]
    ///Contains a type [`VideoProfileKHR`] for extending [`QueryPoolCreateInfo`]
    VideoProfileKHR(VideoProfileKHR),
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for QueryPoolCreateInfoExtension {
    type LowLevel = *const crate::native::vulkan1_0::BaseInStructure;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        match self {
            #[cfg(feature = "VK_KHR_performance_query")]
            Self::QueryPoolPerformanceCreateInfoKHR(ext) => (bump.alloc(ext.into_low_level(context, bump))
                as *mut crate::native::extensions::khr_performance_query::QueryPoolPerformanceCreateInfoKHR)
                .cast(),
            #[cfg(feature = "VK_INTEL_performance_query")]
            Self::QueryPoolPerformanceQueryCreateInfoINTEL(ext) => (bump.alloc(ext.into_low_level(context, bump))
                as *mut crate::native::extensions::intel_performance_query::QueryPoolPerformanceQueryCreateInfoINTEL)
                .cast(),
            #[cfg(feature = "VK_KHR_video_queue")]
            Self::VideoProfileKHR(ext) => (bump.alloc(ext.into_low_level(context, bump))
                as *mut crate::native::extensions::khr_video_queue::VideoProfileKHR)
                .cast(),
            other => unreachable!("unexpected variant {:?}", other),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for QueryPoolCreateInfoExtension {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        assert!(!value.is_null());
        match (* value) . s_type { # [cfg (feature = "VK_KHR_performance_query")] crate :: native :: vulkan1_0 :: StructureType :: QueryPoolPerformanceCreateInfoKhr => Self :: QueryPoolPerformanceCreateInfoKHR (QueryPoolPerformanceCreateInfoKHR :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: khr_performance_query :: QueryPoolPerformanceCreateInfoKHR > ()))) , # [cfg (feature = "VK_INTEL_performance_query")] crate :: native :: vulkan1_0 :: StructureType :: QueryPoolPerformanceQueryCreateInfoIntel => Self :: QueryPoolPerformanceQueryCreateInfoINTEL (QueryPoolPerformanceQueryCreateInfoINTEL :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: intel_performance_query :: QueryPoolPerformanceQueryCreateInfoINTEL > ()))) , # [cfg (feature = "VK_KHR_video_queue")] crate :: native :: vulkan1_0 :: StructureType :: VideoProfileKhr => Self :: VideoProfileKHR (VideoProfileKHR :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: khr_video_queue :: VideoProfileKHR > ()))) , other => panic ! ("Structure type {:?} is not a member of {}" , other , stringify ! (QueryPoolCreateInfo)) }
    }
}
#[cfg(feature = "VK_KHR_performance_query")]
impl From<QueryPoolPerformanceCreateInfoKHR> for QueryPoolCreateInfoExtension {
    fn from(ext: QueryPoolPerformanceCreateInfoKHR) -> Self {
        Self::QueryPoolPerformanceCreateInfoKHR(ext)
    }
}
#[cfg(feature = "VK_KHR_performance_query")]
impl TryInto<QueryPoolPerformanceCreateInfoKHR> for QueryPoolCreateInfoExtension {
    type Error = QueryPoolCreateInfoExtension;
    fn try_into(self) -> Result<QueryPoolPerformanceCreateInfoKHR, Self::Error> {
        match self {
            Self::QueryPoolPerformanceCreateInfoKHR(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_INTEL_performance_query")]
impl From<QueryPoolPerformanceQueryCreateInfoINTEL> for QueryPoolCreateInfoExtension {
    fn from(ext: QueryPoolPerformanceQueryCreateInfoINTEL) -> Self {
        Self::QueryPoolPerformanceQueryCreateInfoINTEL(ext)
    }
}
#[cfg(feature = "VK_INTEL_performance_query")]
impl TryInto<QueryPoolPerformanceQueryCreateInfoINTEL> for QueryPoolCreateInfoExtension {
    type Error = QueryPoolCreateInfoExtension;
    fn try_into(self) -> Result<QueryPoolPerformanceQueryCreateInfoINTEL, Self::Error> {
        match self {
            Self::QueryPoolPerformanceQueryCreateInfoINTEL(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_KHR_video_queue")]
impl From<VideoProfileKHR> for QueryPoolCreateInfoExtension {
    fn from(ext: VideoProfileKHR) -> Self {
        Self::VideoProfileKHR(ext)
    }
}
#[cfg(feature = "VK_KHR_video_queue")]
impl TryInto<VideoProfileKHR> for QueryPoolCreateInfoExtension {
    type Error = QueryPoolCreateInfoExtension;
    fn try_into(self) -> Result<VideoProfileKHR, Self::Error> {
        match self {
            Self::VideoProfileKHR(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[doc(alias = "VkFramebufferCreateInfo")]
#[derive(Clone, PartialEq, Debug)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct FramebufferCreateInfo {
    #[doc(alias = "pNext")]
    pub extensions: SmallVec<[FramebufferCreateInfoExtension; 1]>,
    pub flags: FramebufferCreateFlags,
    #[doc(alias = "renderPass")]
    pub render_pass: RenderPass,
    #[doc(alias = "pAttachments")]
    pub attachments: SmallVec<[ImageView; 8]>,
    pub width: u32,
    pub height: u32,
    pub layers: u32,
}
impl FramebufferCreateInfo {
    ///Adds an extension to the struct
    pub fn with_extension(mut self, ext: impl Into<FramebufferCreateInfoExtension>) -> Self {
        self.extensions.push(ext.into());
        self
    }
    ///Get a reference to the `extensions` field.
    pub fn extensions(&self) -> &SmallVec<[FramebufferCreateInfoExtension; 1]> {
        &self.extensions
    }
    ///Get a reference to the `flags` field.
    pub fn flags(&self) -> FramebufferCreateFlags {
        self.flags
    }
    ///Get a reference to the `render_pass` field.
    pub fn render_pass(&self) -> &RenderPass {
        &self.render_pass
    }
    ///Get a reference to the `attachments` field.
    pub fn attachments(&self) -> &SmallVec<[ImageView; 8]> {
        &self.attachments
    }
    ///Get a reference to the `width` field.
    pub fn width(&self) -> u32 {
        self.width
    }
    ///Get a reference to the `height` field.
    pub fn height(&self) -> u32 {
        self.height
    }
    ///Get a reference to the `layers` field.
    pub fn layers(&self) -> u32 {
        self.layers
    }
    ///Get a mutable reference to the `extensions` field.
    pub fn extensions_mut(&mut self) -> &mut SmallVec<[FramebufferCreateInfoExtension; 1]> {
        &mut self.extensions
    }
    ///Get a mutable reference to the `flags` field.
    pub fn flags_mut(&mut self) -> &mut FramebufferCreateFlags {
        &mut self.flags
    }
    ///Get a mutable reference to the `render_pass` field.
    pub fn render_pass_mut(&mut self) -> &mut RenderPass {
        &mut self.render_pass
    }
    ///Get a mutable reference to the `attachments` field.
    pub fn attachments_mut(&mut self) -> &mut SmallVec<[ImageView; 8]> {
        &mut self.attachments
    }
    ///Get a mutable reference to the `width` field.
    pub fn width_mut(&mut self) -> &mut u32 {
        &mut self.width
    }
    ///Get a mutable reference to the `height` field.
    pub fn height_mut(&mut self) -> &mut u32 {
        &mut self.height
    }
    ///Get a mutable reference to the `layers` field.
    pub fn layers_mut(&mut self) -> &mut u32 {
        &mut self.layers
    }
    ///Sets the `extensions` field.
    pub fn set_extensions(&mut self, extensions: SmallVec<[FramebufferCreateInfoExtension; 1]>) -> &mut Self {
        self.extensions = extensions;
        self
    }
    ///Sets the `flags` field.
    pub fn set_flags(&mut self, flags: FramebufferCreateFlags) -> &mut Self {
        self.flags = flags;
        self
    }
    ///Sets the `render_pass` field.
    pub fn set_render_pass(&mut self, render_pass: RenderPass) -> &mut Self {
        self.render_pass = render_pass;
        self
    }
    ///Sets the `attachments` field.
    pub fn set_attachments(&mut self, attachments: SmallVec<[ImageView; 8]>) -> &mut Self {
        self.attachments = attachments;
        self
    }
    ///Sets the `width` field.
    pub fn set_width(&mut self, width: u32) -> &mut Self {
        self.width = width;
        self
    }
    ///Sets the `height` field.
    pub fn set_height(&mut self, height: u32) -> &mut Self {
        self.height = height;
        self
    }
    ///Sets the `layers` field.
    pub fn set_layers(&mut self, layers: u32) -> &mut Self {
        self.layers = layers;
        self
    }
    ///Sets the `extensions` field in a builder way.
    pub fn with_extensions(mut self, extensions: SmallVec<[FramebufferCreateInfoExtension; 1]>) -> Self {
        self.extensions = extensions;
        self
    }
    ///Sets the `flags` field in a builder way.
    pub fn with_flags(mut self, flags: FramebufferCreateFlags) -> Self {
        self.flags = flags;
        self
    }
    ///Sets the `render_pass` field in a builder way.
    pub fn with_render_pass(mut self, render_pass: RenderPass) -> Self {
        self.render_pass = render_pass;
        self
    }
    ///Sets the `attachments` field in a builder way.
    pub fn with_attachments(mut self, attachments: SmallVec<[ImageView; 8]>) -> Self {
        self.attachments = attachments;
        self
    }
    ///Sets the `width` field in a builder way.
    pub fn with_width(mut self, width: u32) -> Self {
        self.width = width;
        self
    }
    ///Sets the `height` field in a builder way.
    pub fn with_height(mut self, height: u32) -> Self {
        self.height = height;
        self
    }
    ///Sets the `layers` field in a builder way.
    pub fn with_layers(mut self, layers: u32) -> Self {
        self.layers = layers;
        self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for FramebufferCreateInfo {
    type LowLevel = crate::native::vulkan1_0::FramebufferCreateInfo;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        let mut next = std::ptr::null();
        let mut extensions = self.extensions.iter();
        while let Some(ext) = extensions.next() {
            let ext = ext.into_low_level(context, bump);
            (*ext).next = next;
            next = ext;
        }
        let len_attachments = self.attachments.len() as u32;
        let attachments = bump
            .alloc_slice_fill_iter(self.attachments.iter().map(|x| x.into_low_level(context, bump)))
            .as_ptr()
            .cast();
        crate::native::vulkan1_0::FramebufferCreateInfo {
            s_type: StructureType::FramebufferCreateInfo,
            p_next: next,
            flags: self.flags.into_low_level(context, bump),
            render_pass: self.render_pass.into_low_level(context, bump),
            attachment_count: len_attachments,
            attachments: attachments,
            width: self.width.into_low_level(context, bump),
            height: self.height.into_low_level(context, bump),
            layers: self.layers.into_low_level(context, bump),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for FramebufferCreateInfo {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        let mut next = value.p_next;
        let mut extensions = SmallVec::new();
        while !next.is_null() {
            extensions.push(crate::conv::FromLowLevel::from_low_level(context, next));
            next = std::ptr::read(next).next;
        }
        let attachments_len = value.attachment_count;
        let mut attachments = SmallVec::with_capacity(attachments_len as usize);
        for i in 0..attachments_len {
            attachments.push(crate::conv::FromLowLevel::from_low_level(
                context,
                value.attachments.add(i as usize).read(),
            ));
        }
        Self {
            extensions: extensions,
            flags: crate::conv::FromLowLevel::from_low_level(context, value.flags),
            render_pass: crate::conv::FromLowLevel::from_low_level(context, value.render_pass),
            attachments: attachments,
            width: crate::conv::FromLowLevel::from_low_level(context, value.width),
            height: crate::conv::FromLowLevel::from_low_level(context, value.height),
            layers: crate::conv::FromLowLevel::from_low_level(context, value.layers),
        }
    }
}
#[derive(Clone, PartialEq, Debug)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
///Extensions for [`FramebufferCreateInfo`]
pub enum FramebufferCreateInfoExtension {
    #[cfg(feature = "VULKAN_1_2")]
    ///Contains a type [`FramebufferAttachmentsCreateInfo`] for extending [`FramebufferCreateInfo`]
    FramebufferAttachmentsCreateInfo(FramebufferAttachmentsCreateInfo),
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for FramebufferCreateInfoExtension {
    type LowLevel = *const crate::native::vulkan1_0::BaseInStructure;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        match self {
            #[cfg(feature = "VULKAN_1_2")]
            Self::FramebufferAttachmentsCreateInfo(ext) => (bump.alloc(ext.into_low_level(context, bump))
                as *mut crate::native::vulkan1_2::FramebufferAttachmentsCreateInfo)
                .cast(),
            other => unreachable!("unexpected variant {:?}", other),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for FramebufferCreateInfoExtension {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        assert!(!value.is_null());
        match (*value).s_type {
            #[cfg(feature = "VULKAN_1_2")]
            crate::native::vulkan1_0::StructureType::FramebufferAttachmentsCreateInfo => {
                Self::FramebufferAttachmentsCreateInfo(FramebufferAttachmentsCreateInfo::from_low_level(
                    context,
                    std::ptr::read(value.cast::<crate::native::vulkan1_2::FramebufferAttachmentsCreateInfo>()),
                ))
            },
            other => panic!(
                "Structure type {:?} is not a member of {}",
                other,
                stringify!(FramebufferCreateInfo)
            ),
        }
    }
}
#[cfg(feature = "VULKAN_1_2")]
impl From<FramebufferAttachmentsCreateInfo> for FramebufferCreateInfoExtension {
    fn from(ext: FramebufferAttachmentsCreateInfo) -> Self {
        Self::FramebufferAttachmentsCreateInfo(ext)
    }
}
#[cfg(feature = "VULKAN_1_2")]
impl TryInto<FramebufferAttachmentsCreateInfo> for FramebufferCreateInfoExtension {
    type Error = FramebufferCreateInfoExtension;
    fn try_into(self) -> Result<FramebufferAttachmentsCreateInfo, Self::Error> {
        match self {
            Self::FramebufferAttachmentsCreateInfo(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
impl DrawIndirectCommand {
    ///Get a reference to the `vertex_count` field.
    pub fn vertex_count(&self) -> u32 {
        self.vertex_count
    }
    ///Get a reference to the `instance_count` field.
    pub fn instance_count(&self) -> u32 {
        self.instance_count
    }
    ///Get a reference to the `first_vertex` field.
    pub fn first_vertex(&self) -> u32 {
        self.first_vertex
    }
    ///Get a reference to the `first_instance` field.
    pub fn first_instance(&self) -> u32 {
        self.first_instance
    }
    ///Get a mutable reference to the `vertex_count` field.
    pub fn vertex_count_mut(&mut self) -> &mut u32 {
        &mut self.vertex_count
    }
    ///Get a mutable reference to the `instance_count` field.
    pub fn instance_count_mut(&mut self) -> &mut u32 {
        &mut self.instance_count
    }
    ///Get a mutable reference to the `first_vertex` field.
    pub fn first_vertex_mut(&mut self) -> &mut u32 {
        &mut self.first_vertex
    }
    ///Get a mutable reference to the `first_instance` field.
    pub fn first_instance_mut(&mut self) -> &mut u32 {
        &mut self.first_instance
    }
    ///Sets the `vertex_count` field.
    pub fn set_vertex_count(&mut self, vertex_count: u32) -> &mut Self {
        self.vertex_count = vertex_count;
        self
    }
    ///Sets the `instance_count` field.
    pub fn set_instance_count(&mut self, instance_count: u32) -> &mut Self {
        self.instance_count = instance_count;
        self
    }
    ///Sets the `first_vertex` field.
    pub fn set_first_vertex(&mut self, first_vertex: u32) -> &mut Self {
        self.first_vertex = first_vertex;
        self
    }
    ///Sets the `first_instance` field.
    pub fn set_first_instance(&mut self, first_instance: u32) -> &mut Self {
        self.first_instance = first_instance;
        self
    }
    ///Sets the `vertex_count` field in a builder way.
    pub fn with_vertex_count(mut self, vertex_count: u32) -> Self {
        self.vertex_count = vertex_count;
        self
    }
    ///Sets the `instance_count` field in a builder way.
    pub fn with_instance_count(mut self, instance_count: u32) -> Self {
        self.instance_count = instance_count;
        self
    }
    ///Sets the `first_vertex` field in a builder way.
    pub fn with_first_vertex(mut self, first_vertex: u32) -> Self {
        self.first_vertex = first_vertex;
        self
    }
    ///Sets the `first_instance` field in a builder way.
    pub fn with_first_instance(mut self, first_instance: u32) -> Self {
        self.first_instance = first_instance;
        self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for DrawIndirectCommand {
    type LowLevel = crate::native::vulkan1_0::DrawIndirectCommand;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        crate::native::vulkan1_0::DrawIndirectCommand {
            vertex_count: self.vertex_count.into_low_level(context, bump),
            instance_count: self.instance_count.into_low_level(context, bump),
            first_vertex: self.first_vertex.into_low_level(context, bump),
            first_instance: self.first_instance.into_low_level(context, bump),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for DrawIndirectCommand {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        Self {
            vertex_count: crate::conv::FromLowLevel::from_low_level(context, value.vertex_count),
            instance_count: crate::conv::FromLowLevel::from_low_level(context, value.instance_count),
            first_vertex: crate::conv::FromLowLevel::from_low_level(context, value.first_vertex),
            first_instance: crate::conv::FromLowLevel::from_low_level(context, value.first_instance),
        }
    }
}
impl DrawIndexedIndirectCommand {
    ///Get a reference to the `index_count` field.
    pub fn index_count(&self) -> u32 {
        self.index_count
    }
    ///Get a reference to the `instance_count` field.
    pub fn instance_count(&self) -> u32 {
        self.instance_count
    }
    ///Get a reference to the `first_index` field.
    pub fn first_index(&self) -> u32 {
        self.first_index
    }
    ///Get a reference to the `vertex_offset` field.
    pub fn vertex_offset(&self) -> i32 {
        self.vertex_offset
    }
    ///Get a reference to the `first_instance` field.
    pub fn first_instance(&self) -> u32 {
        self.first_instance
    }
    ///Get a mutable reference to the `index_count` field.
    pub fn index_count_mut(&mut self) -> &mut u32 {
        &mut self.index_count
    }
    ///Get a mutable reference to the `instance_count` field.
    pub fn instance_count_mut(&mut self) -> &mut u32 {
        &mut self.instance_count
    }
    ///Get a mutable reference to the `first_index` field.
    pub fn first_index_mut(&mut self) -> &mut u32 {
        &mut self.first_index
    }
    ///Get a mutable reference to the `vertex_offset` field.
    pub fn vertex_offset_mut(&mut self) -> &mut i32 {
        &mut self.vertex_offset
    }
    ///Get a mutable reference to the `first_instance` field.
    pub fn first_instance_mut(&mut self) -> &mut u32 {
        &mut self.first_instance
    }
    ///Sets the `index_count` field.
    pub fn set_index_count(&mut self, index_count: u32) -> &mut Self {
        self.index_count = index_count;
        self
    }
    ///Sets the `instance_count` field.
    pub fn set_instance_count(&mut self, instance_count: u32) -> &mut Self {
        self.instance_count = instance_count;
        self
    }
    ///Sets the `first_index` field.
    pub fn set_first_index(&mut self, first_index: u32) -> &mut Self {
        self.first_index = first_index;
        self
    }
    ///Sets the `vertex_offset` field.
    pub fn set_vertex_offset(&mut self, vertex_offset: i32) -> &mut Self {
        self.vertex_offset = vertex_offset;
        self
    }
    ///Sets the `first_instance` field.
    pub fn set_first_instance(&mut self, first_instance: u32) -> &mut Self {
        self.first_instance = first_instance;
        self
    }
    ///Sets the `index_count` field in a builder way.
    pub fn with_index_count(mut self, index_count: u32) -> Self {
        self.index_count = index_count;
        self
    }
    ///Sets the `instance_count` field in a builder way.
    pub fn with_instance_count(mut self, instance_count: u32) -> Self {
        self.instance_count = instance_count;
        self
    }
    ///Sets the `first_index` field in a builder way.
    pub fn with_first_index(mut self, first_index: u32) -> Self {
        self.first_index = first_index;
        self
    }
    ///Sets the `vertex_offset` field in a builder way.
    pub fn with_vertex_offset(mut self, vertex_offset: i32) -> Self {
        self.vertex_offset = vertex_offset;
        self
    }
    ///Sets the `first_instance` field in a builder way.
    pub fn with_first_instance(mut self, first_instance: u32) -> Self {
        self.first_instance = first_instance;
        self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for DrawIndexedIndirectCommand {
    type LowLevel = crate::native::vulkan1_0::DrawIndexedIndirectCommand;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        crate::native::vulkan1_0::DrawIndexedIndirectCommand {
            index_count: self.index_count.into_low_level(context, bump),
            instance_count: self.instance_count.into_low_level(context, bump),
            first_index: self.first_index.into_low_level(context, bump),
            vertex_offset: self.vertex_offset.into_low_level(context, bump),
            first_instance: self.first_instance.into_low_level(context, bump),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for DrawIndexedIndirectCommand {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        Self {
            index_count: crate::conv::FromLowLevel::from_low_level(context, value.index_count),
            instance_count: crate::conv::FromLowLevel::from_low_level(context, value.instance_count),
            first_index: crate::conv::FromLowLevel::from_low_level(context, value.first_index),
            vertex_offset: crate::conv::FromLowLevel::from_low_level(context, value.vertex_offset),
            first_instance: crate::conv::FromLowLevel::from_low_level(context, value.first_instance),
        }
    }
}
impl DispatchIndirectCommand {
    ///Get a reference to the `x` field.
    pub fn x(&self) -> u32 {
        self.x
    }
    ///Get a reference to the `y` field.
    pub fn y(&self) -> u32 {
        self.y
    }
    ///Get a reference to the `z` field.
    pub fn z(&self) -> u32 {
        self.z
    }
    ///Get a mutable reference to the `x` field.
    pub fn x_mut(&mut self) -> &mut u32 {
        &mut self.x
    }
    ///Get a mutable reference to the `y` field.
    pub fn y_mut(&mut self) -> &mut u32 {
        &mut self.y
    }
    ///Get a mutable reference to the `z` field.
    pub fn z_mut(&mut self) -> &mut u32 {
        &mut self.z
    }
    ///Sets the `x` field.
    pub fn set_x(&mut self, x: u32) -> &mut Self {
        self.x = x;
        self
    }
    ///Sets the `y` field.
    pub fn set_y(&mut self, y: u32) -> &mut Self {
        self.y = y;
        self
    }
    ///Sets the `z` field.
    pub fn set_z(&mut self, z: u32) -> &mut Self {
        self.z = z;
        self
    }
    ///Sets the `x` field in a builder way.
    pub fn with_x(mut self, x: u32) -> Self {
        self.x = x;
        self
    }
    ///Sets the `y` field in a builder way.
    pub fn with_y(mut self, y: u32) -> Self {
        self.y = y;
        self
    }
    ///Sets the `z` field in a builder way.
    pub fn with_z(mut self, z: u32) -> Self {
        self.z = z;
        self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for DispatchIndirectCommand {
    type LowLevel = crate::native::vulkan1_0::DispatchIndirectCommand;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        crate::native::vulkan1_0::DispatchIndirectCommand {
            x: self.x.into_low_level(context, bump),
            y: self.y.into_low_level(context, bump),
            z: self.z.into_low_level(context, bump),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for DispatchIndirectCommand {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        Self {
            x: crate::conv::FromLowLevel::from_low_level(context, value.x),
            y: crate::conv::FromLowLevel::from_low_level(context, value.y),
            z: crate::conv::FromLowLevel::from_low_level(context, value.z),
        }
    }
}
#[doc(alias = "VkSubmitInfo")]
#[derive(Clone, PartialEq, Debug, Default)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct SubmitInfo {
    #[doc(alias = "pNext")]
    pub extensions: SmallVec<[SubmitInfoExtension; 1]>,
    #[doc(alias = "pWaitSemaphores")]
    pub wait_semaphores: SmallVec<[Semaphore; 8]>,
    #[doc(alias = "pWaitDstStageMask")]
    pub wait_dst_stage_mask: SmallVec<[PipelineStageFlags; 8]>,
    #[doc(alias = "pCommandBuffers")]
    pub command_buffers: SmallVec<[CommandBuffer; 8]>,
    #[doc(alias = "pSignalSemaphores")]
    pub signal_semaphores: SmallVec<[Semaphore; 8]>,
}
impl SubmitInfo {
    ///Adds an extension to the struct
    pub fn with_extension(mut self, ext: impl Into<SubmitInfoExtension>) -> Self {
        self.extensions.push(ext.into());
        self
    }
    ///Get a reference to the `extensions` field.
    pub fn extensions(&self) -> &SmallVec<[SubmitInfoExtension; 1]> {
        &self.extensions
    }
    ///Get a reference to the `wait_semaphores` field.
    pub fn wait_semaphores(&self) -> &SmallVec<[Semaphore; 8]> {
        &self.wait_semaphores
    }
    ///Get a reference to the `wait_dst_stage_mask` field.
    pub fn wait_dst_stage_mask(&self) -> &SmallVec<[PipelineStageFlags; 8]> {
        &self.wait_dst_stage_mask
    }
    ///Get a reference to the `command_buffers` field.
    pub fn command_buffers(&self) -> &SmallVec<[CommandBuffer; 8]> {
        &self.command_buffers
    }
    ///Get a reference to the `signal_semaphores` field.
    pub fn signal_semaphores(&self) -> &SmallVec<[Semaphore; 8]> {
        &self.signal_semaphores
    }
    ///Get a mutable reference to the `extensions` field.
    pub fn extensions_mut(&mut self) -> &mut SmallVec<[SubmitInfoExtension; 1]> {
        &mut self.extensions
    }
    ///Get a mutable reference to the `wait_semaphores` field.
    pub fn wait_semaphores_mut(&mut self) -> &mut SmallVec<[Semaphore; 8]> {
        &mut self.wait_semaphores
    }
    ///Get a mutable reference to the `wait_dst_stage_mask` field.
    pub fn wait_dst_stage_mask_mut(&mut self) -> &mut SmallVec<[PipelineStageFlags; 8]> {
        &mut self.wait_dst_stage_mask
    }
    ///Get a mutable reference to the `command_buffers` field.
    pub fn command_buffers_mut(&mut self) -> &mut SmallVec<[CommandBuffer; 8]> {
        &mut self.command_buffers
    }
    ///Get a mutable reference to the `signal_semaphores` field.
    pub fn signal_semaphores_mut(&mut self) -> &mut SmallVec<[Semaphore; 8]> {
        &mut self.signal_semaphores
    }
    ///Sets the `extensions` field.
    pub fn set_extensions(&mut self, extensions: SmallVec<[SubmitInfoExtension; 1]>) -> &mut Self {
        self.extensions = extensions;
        self
    }
    ///Sets the `wait_semaphores` field.
    pub fn set_wait_semaphores(&mut self, wait_semaphores: SmallVec<[Semaphore; 8]>) -> &mut Self {
        self.wait_semaphores = wait_semaphores;
        self
    }
    ///Sets the `wait_dst_stage_mask` field.
    pub fn set_wait_dst_stage_mask(&mut self, wait_dst_stage_mask: SmallVec<[PipelineStageFlags; 8]>) -> &mut Self {
        self.wait_dst_stage_mask = wait_dst_stage_mask;
        self
    }
    ///Sets the `command_buffers` field.
    pub fn set_command_buffers(&mut self, command_buffers: SmallVec<[CommandBuffer; 8]>) -> &mut Self {
        self.command_buffers = command_buffers;
        self
    }
    ///Sets the `signal_semaphores` field.
    pub fn set_signal_semaphores(&mut self, signal_semaphores: SmallVec<[Semaphore; 8]>) -> &mut Self {
        self.signal_semaphores = signal_semaphores;
        self
    }
    ///Sets the `extensions` field in a builder way.
    pub fn with_extensions(mut self, extensions: SmallVec<[SubmitInfoExtension; 1]>) -> Self {
        self.extensions = extensions;
        self
    }
    ///Sets the `wait_semaphores` field in a builder way.
    pub fn with_wait_semaphores(mut self, wait_semaphores: SmallVec<[Semaphore; 8]>) -> Self {
        self.wait_semaphores = wait_semaphores;
        self
    }
    ///Sets the `wait_dst_stage_mask` field in a builder way.
    pub fn with_wait_dst_stage_mask(mut self, wait_dst_stage_mask: SmallVec<[PipelineStageFlags; 8]>) -> Self {
        self.wait_dst_stage_mask = wait_dst_stage_mask;
        self
    }
    ///Sets the `command_buffers` field in a builder way.
    pub fn with_command_buffers(mut self, command_buffers: SmallVec<[CommandBuffer; 8]>) -> Self {
        self.command_buffers = command_buffers;
        self
    }
    ///Sets the `signal_semaphores` field in a builder way.
    pub fn with_signal_semaphores(mut self, signal_semaphores: SmallVec<[Semaphore; 8]>) -> Self {
        self.signal_semaphores = signal_semaphores;
        self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for SubmitInfo {
    type LowLevel = crate::native::vulkan1_0::SubmitInfo;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        let mut next = std::ptr::null();
        let mut extensions = self.extensions.iter();
        while let Some(ext) = extensions.next() {
            let ext = ext.into_low_level(context, bump);
            (*ext).next = next;
            next = ext;
        }
        let len_wait_semaphores = self.wait_semaphores.len() as u32;
        let wait_semaphores = bump
            .alloc_slice_fill_iter(self.wait_semaphores.iter().map(|x| x.into_low_level(context, bump)))
            .as_ptr()
            .cast();
        let wait_dst_stage_mask = bump
            .alloc_slice_fill_iter(self.wait_dst_stage_mask.iter().map(|x| x.into_low_level(context, bump)))
            .as_ptr()
            .cast();
        let len_command_buffers = self.command_buffers.len() as u32;
        let command_buffers = bump
            .alloc_slice_fill_iter(self.command_buffers.iter().map(|x| x.into_low_level(context, bump)))
            .as_ptr()
            .cast();
        let len_signal_semaphores = self.signal_semaphores.len() as u32;
        let signal_semaphores = bump
            .alloc_slice_fill_iter(self.signal_semaphores.iter().map(|x| x.into_low_level(context, bump)))
            .as_ptr()
            .cast();
        crate::native::vulkan1_0::SubmitInfo {
            s_type: StructureType::SubmitInfo,
            p_next: next,
            wait_semaphore_count: len_wait_semaphores,
            wait_semaphores: wait_semaphores,
            wait_dst_stage_mask: wait_dst_stage_mask,
            command_buffer_count: len_command_buffers,
            command_buffers: command_buffers,
            signal_semaphore_count: len_signal_semaphores,
            signal_semaphores: signal_semaphores,
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for SubmitInfo {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        let mut next = value.p_next;
        let mut extensions = SmallVec::new();
        while !next.is_null() {
            extensions.push(crate::conv::FromLowLevel::from_low_level(context, next));
            next = std::ptr::read(next).next;
        }
        let wait_semaphores_len = value.wait_semaphore_count;
        let mut wait_semaphores = SmallVec::with_capacity(wait_semaphores_len as usize);
        for i in 0..wait_semaphores_len {
            wait_semaphores.push(crate::conv::FromLowLevel::from_low_level(
                context,
                value.wait_semaphores.add(i as usize).read(),
            ));
        }
        let wait_dst_stage_mask_len = value.wait_semaphore_count;
        let mut wait_dst_stage_mask = SmallVec::with_capacity(wait_dst_stage_mask_len as usize);
        for i in 0..wait_dst_stage_mask_len {
            wait_dst_stage_mask.push(crate::conv::FromLowLevel::from_low_level(
                context,
                value.wait_dst_stage_mask.add(i as usize).read(),
            ));
        }
        let command_buffers_len = value.command_buffer_count;
        let mut command_buffers = SmallVec::with_capacity(command_buffers_len as usize);
        for i in 0..command_buffers_len {
            command_buffers.push(crate::conv::FromLowLevel::from_low_level(
                context,
                value.command_buffers.add(i as usize).read(),
            ));
        }
        let signal_semaphores_len = value.signal_semaphore_count;
        let mut signal_semaphores = SmallVec::with_capacity(signal_semaphores_len as usize);
        for i in 0..signal_semaphores_len {
            signal_semaphores.push(crate::conv::FromLowLevel::from_low_level(
                context,
                value.signal_semaphores.add(i as usize).read(),
            ));
        }
        Self {
            extensions: extensions,
            wait_semaphores: wait_semaphores,
            wait_dst_stage_mask: wait_dst_stage_mask,
            command_buffers: command_buffers,
            signal_semaphores: signal_semaphores,
        }
    }
}
#[derive(Clone, PartialEq, Debug)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
///Extensions for [`SubmitInfo`]
pub enum SubmitInfoExtension {
    #[cfg(feature = "VK_NV_win32_keyed_mutex")]
    ///Contains a type [`Win32KeyedMutexAcquireReleaseInfoNV`] for extending [`SubmitInfo`]
    Win32KeyedMutexAcquireReleaseInfoNV(Win32KeyedMutexAcquireReleaseInfoNV),
    #[cfg(feature = "VK_KHR_win32_keyed_mutex")]
    ///Contains a type [`Win32KeyedMutexAcquireReleaseInfoKHR`] for extending [`SubmitInfo`]
    Win32KeyedMutexAcquireReleaseInfoKHR(Win32KeyedMutexAcquireReleaseInfoKHR),
    #[cfg(feature = "VK_KHR_external_semaphore_win32")]
    ///Contains a type [`D3d12FenceSubmitInfoKHR`] for extending [`SubmitInfo`]
    D3d12FenceSubmitInfoKHR(D3d12FenceSubmitInfoKHR),
    ///Contains a type [`DeviceGroupSubmitInfo`] for extending [`SubmitInfo`]
    DeviceGroupSubmitInfo(DeviceGroupSubmitInfo),
    ///Contains a type [`ProtectedSubmitInfo`] for extending [`SubmitInfo`]
    ProtectedSubmitInfo(ProtectedSubmitInfo),
    #[cfg(feature = "VULKAN_1_2")]
    ///Contains a type [`TimelineSemaphoreSubmitInfo`] for extending [`SubmitInfo`]
    TimelineSemaphoreSubmitInfo(TimelineSemaphoreSubmitInfo),
    #[cfg(feature = "VK_KHR_performance_query")]
    ///Contains a type [`PerformanceQuerySubmitInfoKHR`] for extending [`SubmitInfo`]
    PerformanceQuerySubmitInfoKHR(PerformanceQuerySubmitInfoKHR),
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for SubmitInfoExtension {
    type LowLevel = *const crate::native::vulkan1_0::BaseInStructure;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        match self {
            #[cfg(feature = "VK_NV_win32_keyed_mutex")]
            Self::Win32KeyedMutexAcquireReleaseInfoNV(ext) => (bump.alloc(ext.into_low_level(context, bump))
                as *mut crate::native::extensions::nv_win32_keyed_mutex::Win32KeyedMutexAcquireReleaseInfoNV)
                .cast(),
            #[cfg(feature = "VK_KHR_win32_keyed_mutex")]
            Self::Win32KeyedMutexAcquireReleaseInfoKHR(ext) => (bump.alloc(ext.into_low_level(context, bump))
                as *mut crate::native::extensions::khr_win32_keyed_mutex::Win32KeyedMutexAcquireReleaseInfoKHR)
                .cast(),
            #[cfg(feature = "VK_KHR_external_semaphore_win32")]
            Self::D3d12FenceSubmitInfoKHR(ext) => (bump.alloc(ext.into_low_level(context, bump))
                as *mut crate::native::extensions::khr_external_semaphore_win32::D3d12FenceSubmitInfoKHR)
                .cast(),
            Self::DeviceGroupSubmitInfo(ext) => (bump.alloc(ext.into_low_level(context, bump))
                as *mut crate::native::vulkan1_1::DeviceGroupSubmitInfo)
                .cast(),
            Self::ProtectedSubmitInfo(ext) => (bump.alloc(ext.into_low_level(context, bump))
                as *mut crate::native::vulkan1_1::ProtectedSubmitInfo)
                .cast(),
            #[cfg(feature = "VULKAN_1_2")]
            Self::TimelineSemaphoreSubmitInfo(ext) => (bump.alloc(ext.into_low_level(context, bump))
                as *mut crate::native::vulkan1_2::TimelineSemaphoreSubmitInfo)
                .cast(),
            #[cfg(feature = "VK_KHR_performance_query")]
            Self::PerformanceQuerySubmitInfoKHR(ext) => (bump.alloc(ext.into_low_level(context, bump))
                as *mut crate::native::extensions::khr_performance_query::PerformanceQuerySubmitInfoKHR)
                .cast(),
            other => unreachable!("unexpected variant {:?}", other),
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for SubmitInfoExtension {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        assert!(!value.is_null());
        match (* value) . s_type { # [cfg (feature = "VK_NV_win32_keyed_mutex")] crate :: native :: vulkan1_0 :: StructureType :: Win32KeyedMutexAcquireReleaseInfoNv => Self :: Win32KeyedMutexAcquireReleaseInfoNV (Win32KeyedMutexAcquireReleaseInfoNV :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: nv_win32_keyed_mutex :: Win32KeyedMutexAcquireReleaseInfoNV > ()))) , # [cfg (feature = "VK_KHR_win32_keyed_mutex")] crate :: native :: vulkan1_0 :: StructureType :: Win32KeyedMutexAcquireReleaseInfoKhr => Self :: Win32KeyedMutexAcquireReleaseInfoKHR (Win32KeyedMutexAcquireReleaseInfoKHR :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: khr_win32_keyed_mutex :: Win32KeyedMutexAcquireReleaseInfoKHR > ()))) , # [cfg (feature = "VK_KHR_external_semaphore_win32")] crate :: native :: vulkan1_0 :: StructureType :: D3d12FenceSubmitInfoKhr => Self :: D3d12FenceSubmitInfoKHR (D3d12FenceSubmitInfoKHR :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: khr_external_semaphore_win32 :: D3d12FenceSubmitInfoKHR > ()))) , crate :: native :: vulkan1_0 :: StructureType :: DeviceGroupSubmitInfo => Self :: DeviceGroupSubmitInfo (DeviceGroupSubmitInfo :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: vulkan1_1 :: DeviceGroupSubmitInfo > ()))) , crate :: native :: vulkan1_0 :: StructureType :: ProtectedSubmitInfo => Self :: ProtectedSubmitInfo (ProtectedSubmitInfo :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: vulkan1_1 :: ProtectedSubmitInfo > ()))) , # [cfg (feature = "VULKAN_1_2")] crate :: native :: vulkan1_0 :: StructureType :: TimelineSemaphoreSubmitInfo => Self :: TimelineSemaphoreSubmitInfo (TimelineSemaphoreSubmitInfo :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: vulkan1_2 :: TimelineSemaphoreSubmitInfo > ()))) , # [cfg (feature = "VK_KHR_performance_query")] crate :: native :: vulkan1_0 :: StructureType :: PerformanceQuerySubmitInfoKhr => Self :: PerformanceQuerySubmitInfoKHR (PerformanceQuerySubmitInfoKHR :: from_low_level (context , std :: ptr :: read (value . cast :: < crate :: native :: extensions :: khr_performance_query :: PerformanceQuerySubmitInfoKHR > ()))) , other => panic ! ("Structure type {:?} is not a member of {}" , other , stringify ! (SubmitInfo)) }
    }
}
#[cfg(feature = "VK_NV_win32_keyed_mutex")]
impl From<Win32KeyedMutexAcquireReleaseInfoNV> for SubmitInfoExtension {
    fn from(ext: Win32KeyedMutexAcquireReleaseInfoNV) -> Self {
        Self::Win32KeyedMutexAcquireReleaseInfoNV(ext)
    }
}
#[cfg(feature = "VK_NV_win32_keyed_mutex")]
impl TryInto<Win32KeyedMutexAcquireReleaseInfoNV> for SubmitInfoExtension {
    type Error = SubmitInfoExtension;
    fn try_into(self) -> Result<Win32KeyedMutexAcquireReleaseInfoNV, Self::Error> {
        match self {
            Self::Win32KeyedMutexAcquireReleaseInfoNV(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_KHR_win32_keyed_mutex")]
impl From<Win32KeyedMutexAcquireReleaseInfoKHR> for SubmitInfoExtension {
    fn from(ext: Win32KeyedMutexAcquireReleaseInfoKHR) -> Self {
        Self::Win32KeyedMutexAcquireReleaseInfoKHR(ext)
    }
}
#[cfg(feature = "VK_KHR_win32_keyed_mutex")]
impl TryInto<Win32KeyedMutexAcquireReleaseInfoKHR> for SubmitInfoExtension {
    type Error = SubmitInfoExtension;
    fn try_into(self) -> Result<Win32KeyedMutexAcquireReleaseInfoKHR, Self::Error> {
        match self {
            Self::Win32KeyedMutexAcquireReleaseInfoKHR(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_KHR_external_semaphore_win32")]
impl From<D3d12FenceSubmitInfoKHR> for SubmitInfoExtension {
    fn from(ext: D3d12FenceSubmitInfoKHR) -> Self {
        Self::D3d12FenceSubmitInfoKHR(ext)
    }
}
#[cfg(feature = "VK_KHR_external_semaphore_win32")]
impl TryInto<D3d12FenceSubmitInfoKHR> for SubmitInfoExtension {
    type Error = SubmitInfoExtension;
    fn try_into(self) -> Result<D3d12FenceSubmitInfoKHR, Self::Error> {
        match self {
            Self::D3d12FenceSubmitInfoKHR(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
impl From<DeviceGroupSubmitInfo> for SubmitInfoExtension {
    fn from(ext: DeviceGroupSubmitInfo) -> Self {
        Self::DeviceGroupSubmitInfo(ext)
    }
}
impl TryInto<DeviceGroupSubmitInfo> for SubmitInfoExtension {
    type Error = SubmitInfoExtension;
    fn try_into(self) -> Result<DeviceGroupSubmitInfo, Self::Error> {
        match self {
            Self::DeviceGroupSubmitInfo(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
impl From<ProtectedSubmitInfo> for SubmitInfoExtension {
    fn from(ext: ProtectedSubmitInfo) -> Self {
        Self::ProtectedSubmitInfo(ext)
    }
}
impl TryInto<ProtectedSubmitInfo> for SubmitInfoExtension {
    type Error = SubmitInfoExtension;
    fn try_into(self) -> Result<ProtectedSubmitInfo, Self::Error> {
        match self {
            Self::ProtectedSubmitInfo(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VULKAN_1_2")]
impl From<TimelineSemaphoreSubmitInfo> for SubmitInfoExtension {
    fn from(ext: TimelineSemaphoreSubmitInfo) -> Self {
        Self::TimelineSemaphoreSubmitInfo(ext)
    }
}
#[cfg(feature = "VULKAN_1_2")]
impl TryInto<TimelineSemaphoreSubmitInfo> for SubmitInfoExtension {
    type Error = SubmitInfoExtension;
    fn try_into(self) -> Result<TimelineSemaphoreSubmitInfo, Self::Error> {
        match self {
            Self::TimelineSemaphoreSubmitInfo(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[cfg(feature = "VK_KHR_performance_query")]
impl From<PerformanceQuerySubmitInfoKHR> for SubmitInfoExtension {
    fn from(ext: PerformanceQuerySubmitInfoKHR) -> Self {
        Self::PerformanceQuerySubmitInfoKHR(ext)
    }
}
#[cfg(feature = "VK_KHR_performance_query")]
impl TryInto<PerformanceQuerySubmitInfoKHR> for SubmitInfoExtension {
    type Error = SubmitInfoExtension;
    fn try_into(self) -> Result<PerformanceQuerySubmitInfoKHR, Self::Error> {
        match self {
            Self::PerformanceQuerySubmitInfoKHR(ext) => Ok(ext),
            other => Err(other),
        }
    }
}
#[doc(alias = "VkClearColorValue")]
#[derive(Clone, PartialEq, Debug, Copy)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub enum ClearColorValue {
    Float32([f32; 4 as usize]),
    Int32([i32; 4 as usize]),
    Uint32([u32; 4 as usize]),
}
impl From<[f32; 4 as usize]> for ClearColorValue {
    fn from(v: [f32; 4 as usize]) -> Self {
        Self::Float32(v)
    }
}
impl From<[i32; 4 as usize]> for ClearColorValue {
    fn from(v: [i32; 4 as usize]) -> Self {
        Self::Int32(v)
    }
}
impl From<[u32; 4 as usize]> for ClearColorValue {
    fn from(v: [u32; 4 as usize]) -> Self {
        Self::Uint32(v)
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for ClearColorValue {
    type LowLevel = crate::native::vulkan1_0::ClearColorValue;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        match self {
            Self::Float32(v) => crate::native::vulkan1_0::ClearColorValue {
                float32: (v.into_low_level(context, bump)),
            },
            Self::Int32(v) => crate::native::vulkan1_0::ClearColorValue {
                int32: (v.into_low_level(context, bump)),
            },
            Self::Uint32(v) => crate::native::vulkan1_0::ClearColorValue {
                uint32: (v.into_low_level(context, bump)),
            },
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for ClearColorValue {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        _value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        unreachable!("cannot convert native union to high level if it does not have a selection");
    }
}
#[doc(alias = "VkClearValue")]
#[derive(Clone, PartialEq, Debug, Copy)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub enum ClearValue {
    Color(ClearColorValue),
    DepthStencil(ClearDepthStencilValue),
}
impl From<ClearColorValue> for ClearValue {
    fn from(v: ClearColorValue) -> Self {
        Self::Color(v)
    }
}
impl From<ClearDepthStencilValue> for ClearValue {
    fn from(v: ClearDepthStencilValue) -> Self {
        Self::DepthStencil(v)
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for ClearValue {
    type LowLevel = crate::native::vulkan1_0::ClearValue;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        match self {
            Self::Color(v) => crate::native::vulkan1_0::ClearValue {
                color: (v.into_low_level(context, bump)),
            },
            Self::DepthStencil(v) => crate::native::vulkan1_0::ClearValue {
                depth_stencil: (v.into_low_level(context, bump)),
            },
        }
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for ClearValue {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        _value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        unreachable!("cannot convert native union to high level if it does not have a selection");
    }
}
#[doc(alias = "VkInstance")]
#[derive(Debug)]
pub struct Instance {
    context: Arc<Context>,
    id: ObjectId,
}
impl Clone for Instance {
    fn clone(&self) -> Self {
        self.context.clone_instance(self.id);
        Self {
            context: Arc::clone(&self.context),
            id: self.id,
        }
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for Instance {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.id.serialize(serializer)
    }
}
impl<'de> Deserialize<'de> for Instance {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let id = ObjectId::deserialize(deserializer)?;
        crate::context::CONTEXT.with(|context| {
            let borrow = context.borrow();
            let context = borrow.as_ref().expect("Context not set.");
            Ok(Self {
                context: Arc::clone(context),
                id,
            })
        })
    }
}
impl Drop for Instance {
    fn drop(&mut self) {
        if !std::thread::panicking() {
            self.context.drop_instance(&self.id);
        }
    }
}
impl PartialEq for Instance {
    fn eq(&self, other: &Self) -> bool {
        self.id == other.id
    }
}
impl Instance {
    ///Creates a new instance of this handle from its core components.
    pub(crate) const unsafe fn new(context: Arc<Context>, id: ObjectId) -> Self {
        Self { context, id }
    }
    ///Gets the object id
    pub fn id(&self) -> &ObjectId {
        &self.id
    }
    ///Gets a reference to the context
    pub fn context(&self) -> &Context {
        &self.context
    }
    ///Gets a reference to the context wrapped in an [`Arc`]
    pub fn arc_context(&self) -> &Arc<Context> {
        &self.context
    }
    #[doc(alias = "vkEnumeratePhysicalDevices")]
    pub fn enumerate_physical_devices(
        &self,
        p_physical_device_count: Option<usize>,
    ) -> Result<SmallVec<[PhysicalDevice; 1]>, Error> {
        self.context.enumerate_physical_devices(self, p_physical_device_count)
    }
    #[doc(alias = "vkGetInstanceProcAddr")]
    pub fn get_instance_proc_addr<PName: AsRef<str>>(&self, p_name: PName) -> () {
        self.context.get_instance_proc_addr(self, p_name)
    }
    #[cfg(feature = "VK_EXT_debug_report")]
    #[doc(alias = "vkDebugReportMessageEXT")]
    pub fn debug_report_message_ext<PLayerPrefix: AsRef<str>, PMessage: AsRef<str>>(
        &self,
        flags: DebugReportFlagsEXT,
        object_type: DebugReportObjectTypeEXT,
        object: u64,
        location: usize,
        message_code: i32,
        p_layer_prefix: PLayerPrefix,
        p_message: PMessage,
    ) -> () {
        self.context.debug_report_message_ext(
            self,
            flags,
            object_type,
            object,
            location,
            message_code,
            p_layer_prefix,
            p_message,
        )
    }
    #[doc(alias = "vkEnumeratePhysicalDeviceGroups")]
    pub fn enumerate_physical_device_groups(
        &self,
        p_physical_device_group_count: Option<usize>,
    ) -> Result<SmallVec<[PhysicalDeviceGroupProperties; 1]>, Error> {
        self.context
            .enumerate_physical_device_groups(self, p_physical_device_group_count)
    }
    #[cfg(feature = "VK_EXT_debug_utils")]
    #[doc(alias = "vkSubmitDebugUtilsMessageEXT")]
    pub fn submit_debug_utils_message_ext(
        &self,
        message_severity: DebugUtilsMessageSeverityFlagBitsEXT,
        message_types: DebugUtilsMessageTypeFlagsEXT,
        p_callback_data: &DebugUtilsMessengerCallbackDataEXT,
    ) -> () {
        self.context
            .submit_debug_utils_message_ext(self, message_severity, message_types, p_callback_data)
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for Instance {
    type LowLevel = crate::native::vulkan1_0::Instance;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *context.instance().get(&self.id).expect("unknwon handle").handle()
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for Instance {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        let object_id = ObjectId::random();
        context.instance().insert(object_id, Container::new(value));
        Self {
            context: context.clone(),
            id: object_id,
        }
    }
}
#[doc(alias = "VkPhysicalDevice")]
#[derive(Debug)]
pub struct PhysicalDevice {
    context: Arc<Context>,
    id: ObjectId,
}
impl Clone for PhysicalDevice {
    fn clone(&self) -> Self {
        self.context.clone_physical_device(self.id);
        Self {
            context: Arc::clone(&self.context),
            id: self.id,
        }
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for PhysicalDevice {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.id.serialize(serializer)
    }
}
impl<'de> Deserialize<'de> for PhysicalDevice {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let id = ObjectId::deserialize(deserializer)?;
        crate::context::CONTEXT.with(|context| {
            let borrow = context.borrow();
            let context = borrow.as_ref().expect("Context not set.");
            Ok(Self {
                context: Arc::clone(context),
                id,
            })
        })
    }
}
impl Drop for PhysicalDevice {
    fn drop(&mut self) {
        if !std::thread::panicking() {
            self.context.drop_physical_device(&self.id);
        }
    }
}
impl PartialEq for PhysicalDevice {
    fn eq(&self, other: &Self) -> bool {
        self.id == other.id
    }
}
impl PhysicalDevice {
    ///Creates a new instance of this handle from its core components.
    pub(crate) const unsafe fn new(context: Arc<Context>, id: ObjectId) -> Self {
        Self { context, id }
    }
    ///Gets the object id
    pub fn id(&self) -> &ObjectId {
        &self.id
    }
    ///Gets a reference to the context
    pub fn context(&self) -> &Context {
        &self.context
    }
    ///Gets a reference to the context wrapped in an [`Arc`]
    pub fn arc_context(&self) -> &Arc<Context> {
        &self.context
    }
    #[doc(alias = "vkGetPhysicalDeviceProperties")]
    pub fn get_physical_device_properties(&self) -> PhysicalDeviceProperties {
        self.context.get_physical_device_properties(self)
    }
    #[doc(alias = "vkGetPhysicalDeviceQueueFamilyProperties")]
    pub fn get_physical_device_queue_family_properties(
        &self,
        p_queue_family_property_count: Option<usize>,
    ) -> SmallVec<[QueueFamilyProperties; 1]> {
        self.context
            .get_physical_device_queue_family_properties(self, p_queue_family_property_count)
    }
    #[doc(alias = "vkGetPhysicalDeviceMemoryProperties")]
    pub fn get_physical_device_memory_properties(&self) -> PhysicalDeviceMemoryProperties {
        self.context.get_physical_device_memory_properties(self)
    }
    #[doc(alias = "vkGetPhysicalDeviceFeatures")]
    pub fn get_physical_device_features(&self) -> PhysicalDeviceFeatures {
        self.context.get_physical_device_features(self)
    }
    #[doc(alias = "vkGetPhysicalDeviceFormatProperties")]
    pub fn get_physical_device_format_properties(&self, format: Format) -> FormatProperties {
        self.context.get_physical_device_format_properties(self, format)
    }
    #[doc(alias = "vkGetPhysicalDeviceImageFormatProperties")]
    pub fn get_physical_device_image_format_properties(
        &self,
        format: Format,
        type_: ImageType,
        tiling: ImageTiling,
        usage: ImageUsageFlags,
        flags: ImageCreateFlags,
    ) -> Result<ImageFormatProperties, Error> {
        self.context
            .get_physical_device_image_format_properties(self, format, type_, tiling, usage, flags)
    }
    #[doc(alias = "vkEnumerateDeviceLayerProperties")]
    pub fn enumerate_device_layer_properties(
        &self,
        p_property_count: Option<usize>,
    ) -> Result<SmallVec<[LayerProperties; 1]>, Error> {
        self.context.enumerate_device_layer_properties(self, p_property_count)
    }
    #[doc(alias = "vkEnumerateDeviceExtensionProperties")]
    pub fn enumerate_device_extension_properties<PLayerName: AsRef<str>>(
        &self,
        p_layer_name: PLayerName,
        p_property_count: Option<usize>,
    ) -> Result<SmallVec<[ExtensionProperties; 1]>, Error> {
        self.context
            .enumerate_device_extension_properties(self, p_layer_name, p_property_count)
    }
    #[doc(alias = "vkGetPhysicalDeviceSparseImageFormatProperties")]
    pub fn get_physical_device_sparse_image_format_properties(
        &self,
        format: Format,
        type_: ImageType,
        samples: SampleCountFlagBits,
        usage: ImageUsageFlags,
        tiling: ImageTiling,
        p_property_count: Option<usize>,
    ) -> SmallVec<[SparseImageFormatProperties; 1]> {
        self.context.get_physical_device_sparse_image_format_properties(
            self,
            format,
            type_,
            samples,
            usage,
            tiling,
            p_property_count,
        )
    }
    #[cfg(feature = "VK_KHR_display")]
    #[doc(alias = "vkGetPhysicalDeviceDisplayPropertiesKHR")]
    pub fn get_physical_device_display_properties_khr(
        &self,
        p_property_count: Option<usize>,
    ) -> Result<SmallVec<[DisplayPropertiesKHR; 1]>, Error> {
        self.context
            .get_physical_device_display_properties_khr(self, p_property_count)
    }
    #[cfg(feature = "VK_KHR_display")]
    #[doc(alias = "vkGetPhysicalDeviceDisplayPlanePropertiesKHR")]
    pub fn get_physical_device_display_plane_properties_khr(
        &self,
        p_property_count: Option<usize>,
    ) -> Result<SmallVec<[DisplayPlanePropertiesKHR; 1]>, Error> {
        self.context
            .get_physical_device_display_plane_properties_khr(self, p_property_count)
    }
    #[cfg(feature = "VK_KHR_display")]
    #[doc(alias = "vkGetDisplayPlaneSupportedDisplaysKHR")]
    pub fn get_display_plane_supported_displays_khr(
        &self,
        plane_index: u32,
        p_display_count: Option<usize>,
    ) -> Result<SmallVec<[DisplayKHR; 1]>, Error> {
        self.context
            .get_display_plane_supported_displays_khr(self, plane_index, p_display_count)
    }
    #[cfg(feature = "VK_KHR_display")]
    #[doc(alias = "vkGetDisplayModePropertiesKHR")]
    pub fn get_display_mode_properties_khr(
        &self,
        display: DisplayKHR,
        p_property_count: Option<usize>,
    ) -> Result<SmallVec<[DisplayModePropertiesKHR; 1]>, Error> {
        self.context
            .get_display_mode_properties_khr(self, display, p_property_count)
    }
    #[cfg(feature = "VK_KHR_display")]
    #[doc(alias = "vkGetDisplayPlaneCapabilitiesKHR")]
    pub fn get_display_plane_capabilities_khr(
        &self,
        mode: DisplayModeKHR,
        plane_index: u32,
    ) -> Result<DisplayPlaneCapabilitiesKHR, Error> {
        self.context.get_display_plane_capabilities_khr(self, mode, plane_index)
    }
    #[cfg(feature = "VK_KHR_surface")]
    #[doc(alias = "vkGetPhysicalDeviceSurfaceSupportKHR")]
    pub fn get_physical_device_surface_support_khr(
        &self,
        queue_family_index: u32,
        surface: SurfaceKHR,
    ) -> Result<Bool32, Error> {
        self.context
            .get_physical_device_surface_support_khr(self, queue_family_index, surface)
    }
    #[cfg(feature = "VK_KHR_surface")]
    #[doc(alias = "vkGetPhysicalDeviceSurfaceCapabilitiesKHR")]
    pub fn get_physical_device_surface_capabilities_khr(
        &self,
        surface: SurfaceKHR,
    ) -> Result<SurfaceCapabilitiesKHR, Error> {
        self.context.get_physical_device_surface_capabilities_khr(self, surface)
    }
    #[cfg(feature = "VK_KHR_surface")]
    #[doc(alias = "vkGetPhysicalDeviceSurfaceFormatsKHR")]
    pub fn get_physical_device_surface_formats_khr(
        &self,
        surface: SurfaceKHR,
        p_surface_format_count: Option<usize>,
    ) -> Result<SmallVec<[SurfaceFormatKHR; 1]>, Error> {
        self.context
            .get_physical_device_surface_formats_khr(self, surface, p_surface_format_count)
    }
    #[cfg(feature = "VK_KHR_surface")]
    #[doc(alias = "vkGetPhysicalDeviceSurfacePresentModesKHR")]
    pub fn get_physical_device_surface_present_modes_khr(
        &self,
        surface: SurfaceKHR,
        p_present_mode_count: Option<usize>,
    ) -> Result<SmallVec<[PresentModeKHR; 1]>, Error> {
        self.context
            .get_physical_device_surface_present_modes_khr(self, surface, p_present_mode_count)
    }
    #[cfg(feature = "VK_KHR_win32_surface")]
    #[doc(alias = "vkGetPhysicalDeviceWin32PresentationSupportKHR")]
    pub fn get_physical_device_win32_presentation_support_khr(&self, queue_family_index: u32) -> () {
        self.context
            .get_physical_device_win32_presentation_support_khr(self, queue_family_index)
    }
    #[cfg(feature = "VK_NV_external_memory_capabilities")]
    #[doc(alias = "vkGetPhysicalDeviceExternalImageFormatPropertiesNV")]
    pub fn get_physical_device_external_image_format_properties_nv(
        &self,
        format: Format,
        type_: ImageType,
        tiling: ImageTiling,
        usage: ImageUsageFlags,
        flags: ImageCreateFlags,
        external_handle_type: ExternalMemoryHandleTypeFlagsNV,
    ) -> Result<ExternalImageFormatPropertiesNV, Error> {
        self.context.get_physical_device_external_image_format_properties_nv(
            self,
            format,
            type_,
            tiling,
            usage,
            flags,
            external_handle_type,
        )
    }
    #[doc(alias = "vkGetPhysicalDeviceFeatures2")]
    pub fn get_physical_device_features2(&self) -> PhysicalDeviceFeatures2 {
        self.context.get_physical_device_features2(self)
    }
    #[doc(alias = "vkGetPhysicalDeviceProperties2")]
    pub fn get_physical_device_properties2(&self) -> PhysicalDeviceProperties2 {
        self.context.get_physical_device_properties2(self)
    }
    #[doc(alias = "vkGetPhysicalDeviceFormatProperties2")]
    pub fn get_physical_device_format_properties2(&self, format: Format) -> FormatProperties2 {
        self.context.get_physical_device_format_properties2(self, format)
    }
    #[doc(alias = "vkGetPhysicalDeviceImageFormatProperties2")]
    pub fn get_physical_device_image_format_properties2(
        &self,
        p_image_format_info: &PhysicalDeviceImageFormatInfo2,
    ) -> Result<ImageFormatProperties2, Error> {
        self.context
            .get_physical_device_image_format_properties2(self, p_image_format_info)
    }
    #[doc(alias = "vkGetPhysicalDeviceQueueFamilyProperties2")]
    pub fn get_physical_device_queue_family_properties2(
        &self,
        p_queue_family_property_count: Option<usize>,
    ) -> SmallVec<[QueueFamilyProperties2; 1]> {
        self.context
            .get_physical_device_queue_family_properties2(self, p_queue_family_property_count)
    }
    #[doc(alias = "vkGetPhysicalDeviceMemoryProperties2")]
    pub fn get_physical_device_memory_properties2(&self) -> PhysicalDeviceMemoryProperties2 {
        self.context.get_physical_device_memory_properties2(self)
    }
    #[doc(alias = "vkGetPhysicalDeviceSparseImageFormatProperties2")]
    pub fn get_physical_device_sparse_image_format_properties2(
        &self,
        p_format_info: &PhysicalDeviceSparseImageFormatInfo2,
        p_property_count: Option<usize>,
    ) -> SmallVec<[SparseImageFormatProperties2; 1]> {
        self.context
            .get_physical_device_sparse_image_format_properties2(self, p_format_info, p_property_count)
    }
    #[doc(alias = "vkGetPhysicalDeviceExternalBufferProperties")]
    pub fn get_physical_device_external_buffer_properties(
        &self,
        p_external_buffer_info: &PhysicalDeviceExternalBufferInfo,
    ) -> ExternalBufferProperties {
        self.context
            .get_physical_device_external_buffer_properties(self, p_external_buffer_info)
    }
    #[doc(alias = "vkGetPhysicalDeviceExternalSemaphoreProperties")]
    pub fn get_physical_device_external_semaphore_properties(
        &self,
        p_external_semaphore_info: &PhysicalDeviceExternalSemaphoreInfo,
    ) -> ExternalSemaphoreProperties {
        self.context
            .get_physical_device_external_semaphore_properties(self, p_external_semaphore_info)
    }
    #[doc(alias = "vkGetPhysicalDeviceExternalFenceProperties")]
    pub fn get_physical_device_external_fence_properties(
        &self,
        p_external_fence_info: &PhysicalDeviceExternalFenceInfo,
    ) -> ExternalFenceProperties {
        self.context
            .get_physical_device_external_fence_properties(self, p_external_fence_info)
    }
    #[cfg(feature = "VK_EXT_direct_mode_display")]
    #[doc(alias = "vkReleaseDisplayEXT")]
    pub fn release_display_ext(&self, display: DisplayKHR) -> Result<(), Error> {
        self.context.release_display_ext(self, display)
    }
    #[cfg(feature = "VK_NV_acquire_winrt_display")]
    #[doc(alias = "vkAcquireWinrtDisplayNV")]
    pub fn acquire_winrt_display_nv(&self, display: DisplayKHR) -> Result<(), Error> {
        self.context.acquire_winrt_display_nv(self, display)
    }
    #[cfg(feature = "VK_NV_acquire_winrt_display")]
    #[doc(alias = "vkGetWinrtDisplayNV")]
    pub fn get_winrt_display_nv(&self, device_relative_id: u32) -> Result<DisplayKHR, Error> {
        self.context.get_winrt_display_nv(self, device_relative_id)
    }
    #[cfg(feature = "VK_EXT_display_surface_counter")]
    #[doc(alias = "vkGetPhysicalDeviceSurfaceCapabilities2EXT")]
    pub fn get_physical_device_surface_capabilities2_ext(
        &self,
        surface: SurfaceKHR,
    ) -> Result<SurfaceCapabilities2EXT, Error> {
        self.context
            .get_physical_device_surface_capabilities2_ext(self, surface)
    }
    #[cfg(feature = "VK_KHR_device_group")]
    #[doc(alias = "vkGetPhysicalDevicePresentRectanglesKHR")]
    pub fn get_physical_device_present_rectangles_khr(
        &self,
        surface: SurfaceKHR,
        p_rect_count: Option<usize>,
    ) -> Result<SmallVec<[Rect2D; 1]>, Error> {
        self.context
            .get_physical_device_present_rectangles_khr(self, surface, p_rect_count)
    }
    #[cfg(feature = "VK_EXT_sample_locations")]
    #[doc(alias = "vkGetPhysicalDeviceMultisamplePropertiesEXT")]
    pub fn get_physical_device_multisample_properties_ext(
        &self,
        samples: SampleCountFlagBits,
    ) -> MultisamplePropertiesEXT {
        self.context
            .get_physical_device_multisample_properties_ext(self, samples)
    }
    #[cfg(feature = "VK_KHR_get_surface_capabilities2")]
    #[doc(alias = "vkGetPhysicalDeviceSurfaceCapabilities2KHR")]
    pub fn get_physical_device_surface_capabilities2_khr(
        &self,
        p_surface_info: &PhysicalDeviceSurfaceInfo2KHR,
    ) -> Result<SurfaceCapabilities2KHR, Error> {
        self.context
            .get_physical_device_surface_capabilities2_khr(self, p_surface_info)
    }
    #[cfg(feature = "VK_KHR_get_surface_capabilities2")]
    #[doc(alias = "vkGetPhysicalDeviceSurfaceFormats2KHR")]
    pub fn get_physical_device_surface_formats2_khr(
        &self,
        p_surface_info: &PhysicalDeviceSurfaceInfo2KHR,
        p_surface_format_count: Option<usize>,
    ) -> Result<SmallVec<[SurfaceFormat2KHR; 1]>, Error> {
        self.context
            .get_physical_device_surface_formats2_khr(self, p_surface_info, p_surface_format_count)
    }
    #[cfg(feature = "VK_KHR_get_display_properties2")]
    #[doc(alias = "vkGetPhysicalDeviceDisplayProperties2KHR")]
    pub fn get_physical_device_display_properties2_khr(
        &self,
        p_property_count: Option<usize>,
    ) -> Result<SmallVec<[DisplayProperties2KHR; 1]>, Error> {
        self.context
            .get_physical_device_display_properties2_khr(self, p_property_count)
    }
    #[cfg(feature = "VK_KHR_get_display_properties2")]
    #[doc(alias = "vkGetPhysicalDeviceDisplayPlaneProperties2KHR")]
    pub fn get_physical_device_display_plane_properties2_khr(
        &self,
        p_property_count: Option<usize>,
    ) -> Result<SmallVec<[DisplayPlaneProperties2KHR; 1]>, Error> {
        self.context
            .get_physical_device_display_plane_properties2_khr(self, p_property_count)
    }
    #[cfg(feature = "VK_KHR_get_display_properties2")]
    #[doc(alias = "vkGetDisplayModeProperties2KHR")]
    pub fn get_display_mode_properties2_khr(
        &self,
        display: DisplayKHR,
        p_property_count: Option<usize>,
    ) -> Result<SmallVec<[DisplayModeProperties2KHR; 1]>, Error> {
        self.context
            .get_display_mode_properties2_khr(self, display, p_property_count)
    }
    #[cfg(feature = "VK_KHR_get_display_properties2")]
    #[doc(alias = "vkGetDisplayPlaneCapabilities2KHR")]
    pub fn get_display_plane_capabilities2_khr(
        &self,
        p_display_plane_info: &DisplayPlaneInfo2KHR,
    ) -> Result<DisplayPlaneCapabilities2KHR, Error> {
        self.context
            .get_display_plane_capabilities2_khr(self, p_display_plane_info)
    }
    #[cfg(feature = "VK_EXT_calibrated_timestamps")]
    #[doc(alias = "vkGetPhysicalDeviceCalibrateableTimeDomainsEXT")]
    pub fn get_physical_device_calibrateable_time_domains_ext(
        &self,
        p_time_domain_count: Option<usize>,
    ) -> Result<SmallVec<[TimeDomainEXT; 1]>, Error> {
        self.context
            .get_physical_device_calibrateable_time_domains_ext(self, p_time_domain_count)
    }
    #[cfg(feature = "VK_NV_cooperative_matrix")]
    #[doc(alias = "vkGetPhysicalDeviceCooperativeMatrixPropertiesNV")]
    pub fn get_physical_device_cooperative_matrix_properties_nv(
        &self,
        p_property_count: Option<usize>,
    ) -> Result<SmallVec<[CooperativeMatrixPropertiesNV; 1]>, Error> {
        self.context
            .get_physical_device_cooperative_matrix_properties_nv(self, p_property_count)
    }
    #[cfg(feature = "VK_EXT_full_screen_exclusive")]
    #[doc(alias = "vkGetPhysicalDeviceSurfacePresentModes2EXT")]
    pub fn get_physical_device_surface_present_modes2_ext(
        &self,
        p_surface_info: &PhysicalDeviceSurfaceInfo2KHR,
        p_present_mode_count: Option<usize>,
    ) -> Result<SmallVec<[PresentModeKHR; 1]>, Error> {
        self.context
            .get_physical_device_surface_present_modes2_ext(self, p_surface_info, p_present_mode_count)
    }
    #[cfg(feature = "VK_KHR_performance_query")]
    #[doc(alias = "vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR")]
    pub fn enumerate_physical_device_queue_family_performance_query_counters_khr(
        &self,
        queue_family_index: u32,
        p_counter_count: Option<usize>,
    ) -> Result<
        (
            SmallVec<[PerformanceCounterKHR; 1]>,
            SmallVec<[PerformanceCounterDescriptionKHR; 1]>,
        ),
        Error,
    > {
        self.context
            .enumerate_physical_device_queue_family_performance_query_counters_khr(
                self,
                queue_family_index,
                p_counter_count,
            )
    }
    #[cfg(feature = "VK_KHR_performance_query")]
    #[doc(alias = "vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR")]
    pub fn get_physical_device_queue_family_performance_query_passes_khr(
        &self,
        p_performance_query_create_info: &QueryPoolPerformanceCreateInfoKHR,
    ) -> u32 {
        self.context
            .get_physical_device_queue_family_performance_query_passes_khr(self, p_performance_query_create_info)
    }
    #[cfg(feature = "VK_NV_coverage_reduction_mode")]
    #[doc(alias = "vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV")]
    pub fn get_physical_device_supported_framebuffer_mixed_samples_combinations_nv(
        &self,
        p_combination_count: Option<usize>,
    ) -> Result<SmallVec<[FramebufferMixedSamplesCombinationNV; 1]>, Error> {
        self.context
            .get_physical_device_supported_framebuffer_mixed_samples_combinations_nv(self, p_combination_count)
    }
    #[cfg(feature = "VULKAN_1_3")]
    #[doc(alias = "vkGetPhysicalDeviceToolProperties")]
    pub fn get_physical_device_tool_properties(
        &self,
        p_tool_count: Option<usize>,
    ) -> Result<SmallVec<[PhysicalDeviceToolProperties; 1]>, Error> {
        self.context.get_physical_device_tool_properties(self, p_tool_count)
    }
    #[cfg(feature = "VK_KHR_fragment_shading_rate")]
    #[doc(alias = "vkGetPhysicalDeviceFragmentShadingRatesKHR")]
    pub fn get_physical_device_fragment_shading_rates_khr(
        &self,
        p_fragment_shading_rate_count: Option<usize>,
    ) -> Result<SmallVec<[PhysicalDeviceFragmentShadingRateKHR; 1]>, Error> {
        self.context
            .get_physical_device_fragment_shading_rates_khr(self, p_fragment_shading_rate_count)
    }
    #[cfg(feature = "VK_KHR_video_queue")]
    #[doc(alias = "vkGetPhysicalDeviceVideoCapabilitiesKHR")]
    pub fn get_physical_device_video_capabilities_khr(
        &self,
        p_video_profile: &VideoProfileKHR,
    ) -> Result<VideoCapabilitiesKHR, Error> {
        self.context
            .get_physical_device_video_capabilities_khr(self, p_video_profile)
    }
    #[cfg(feature = "VK_KHR_video_queue")]
    #[doc(alias = "vkGetPhysicalDeviceVideoFormatPropertiesKHR")]
    pub fn get_physical_device_video_format_properties_khr(
        &self,
        p_video_format_info: &PhysicalDeviceVideoFormatInfoKHR,
        p_video_format_property_count: Option<usize>,
    ) -> Result<SmallVec<[VideoFormatPropertiesKHR; 1]>, Error> {
        self.context.get_physical_device_video_format_properties_khr(
            self,
            p_video_format_info,
            p_video_format_property_count,
        )
    }
    #[cfg(feature = "VK_EXT_acquire_drm_display")]
    #[doc(alias = "vkAcquireDrmDisplayEXT")]
    pub fn acquire_drm_display_ext(&self, drm_fd: i32, display: DisplayKHR) -> Result<(), Error> {
        self.context.acquire_drm_display_ext(self, drm_fd, display)
    }
    #[cfg(feature = "VK_EXT_acquire_drm_display")]
    #[doc(alias = "vkGetDrmDisplayEXT")]
    pub fn get_drm_display_ext(&self, drm_fd: i32, connector_id: u32) -> Result<DisplayKHR, Error> {
        self.context.get_drm_display_ext(self, drm_fd, connector_id)
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for PhysicalDevice {
    type LowLevel = crate::native::vulkan1_0::PhysicalDevice;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *context
            .physical_device()
            .get(&self.id)
            .expect("unknwon handle")
            .handle()
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for PhysicalDevice {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        let object_id = ObjectId::random();
        context.physical_device().insert(object_id, Container::new(value));
        Self {
            context: context.clone(),
            id: object_id,
        }
    }
}
#[doc(alias = "VkDevice")]
#[derive(Debug)]
pub struct Device {
    context: Arc<Context>,
    id: ObjectId,
}
impl Clone for Device {
    fn clone(&self) -> Self {
        self.context.clone_device(self.id);
        Self {
            context: Arc::clone(&self.context),
            id: self.id,
        }
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for Device {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.id.serialize(serializer)
    }
}
impl<'de> Deserialize<'de> for Device {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let id = ObjectId::deserialize(deserializer)?;
        crate::context::CONTEXT.with(|context| {
            let borrow = context.borrow();
            let context = borrow.as_ref().expect("Context not set.");
            Ok(Self {
                context: Arc::clone(context),
                id,
            })
        })
    }
}
impl Drop for Device {
    fn drop(&mut self) {
        if !std::thread::panicking() {
            self.context.drop_device(&self.id);
        }
    }
}
impl PartialEq for Device {
    fn eq(&self, other: &Self) -> bool {
        self.id == other.id
    }
}
impl Device {
    ///Creates a new instance of this handle from its core components.
    pub(crate) const unsafe fn new(context: Arc<Context>, id: ObjectId) -> Self {
        Self { context, id }
    }
    ///Gets the object id
    pub fn id(&self) -> &ObjectId {
        &self.id
    }
    ///Gets a reference to the context
    pub fn context(&self) -> &Context {
        &self.context
    }
    ///Gets a reference to the context wrapped in an [`Arc`]
    pub fn arc_context(&self) -> &Arc<Context> {
        &self.context
    }
    #[doc(alias = "vkGetDeviceProcAddr")]
    pub fn get_device_proc_addr<PName: AsRef<str>>(&self, p_name: PName) -> () {
        self.context.get_device_proc_addr(self, p_name)
    }
    #[doc(alias = "vkGetDeviceQueue")]
    pub fn get_device_queue(&self, queue_family_index: u32, queue_index: u32) -> Queue {
        self.context.get_device_queue(self, queue_family_index, queue_index)
    }
    #[doc(alias = "vkDeviceWaitIdle")]
    pub fn device_wait_idle(&self) -> Result<(), Error> {
        self.context.device_wait_idle(self)
    }
    #[doc(alias = "vkUnmapMemory")]
    pub fn unmap_memory(&self, memory: DeviceMemory) -> () {
        self.context.unmap_memory(self, memory)
    }
    #[doc(alias = "vkFlushMappedMemoryRanges")]
    pub fn flush_mapped_memory_ranges(&self, p_memory_ranges: &[MappedMemoryRange]) -> Result<(), Error> {
        self.context.flush_mapped_memory_ranges(self, p_memory_ranges)
    }
    #[doc(alias = "vkInvalidateMappedMemoryRanges")]
    pub fn invalidate_mapped_memory_ranges(&self, p_memory_ranges: &[MappedMemoryRange]) -> Result<(), Error> {
        self.context.invalidate_mapped_memory_ranges(self, p_memory_ranges)
    }
    #[doc(alias = "vkGetDeviceMemoryCommitment")]
    pub fn get_device_memory_commitment(&self, memory: DeviceMemory) -> DeviceSize {
        self.context.get_device_memory_commitment(self, memory)
    }
    #[doc(alias = "vkGetBufferMemoryRequirements")]
    pub fn get_buffer_memory_requirements(&self, buffer: Buffer) -> MemoryRequirements {
        self.context.get_buffer_memory_requirements(self, buffer)
    }
    #[doc(alias = "vkBindBufferMemory")]
    pub fn bind_buffer_memory(
        &self,
        buffer: Buffer,
        memory: DeviceMemory,
        memory_offset: DeviceSize,
    ) -> Result<(), Error> {
        self.context.bind_buffer_memory(self, buffer, memory, memory_offset)
    }
    #[doc(alias = "vkGetImageMemoryRequirements")]
    pub fn get_image_memory_requirements(&self, image: Image) -> MemoryRequirements {
        self.context.get_image_memory_requirements(self, image)
    }
    #[doc(alias = "vkBindImageMemory")]
    pub fn bind_image_memory(
        &self,
        image: Image,
        memory: DeviceMemory,
        memory_offset: DeviceSize,
    ) -> Result<(), Error> {
        self.context.bind_image_memory(self, image, memory, memory_offset)
    }
    #[doc(alias = "vkGetImageSparseMemoryRequirements")]
    pub fn get_image_sparse_memory_requirements(
        &self,
        image: Image,
        p_sparse_memory_requirement_count: Option<usize>,
    ) -> SmallVec<[SparseImageMemoryRequirements; 1]> {
        self.context
            .get_image_sparse_memory_requirements(self, image, p_sparse_memory_requirement_count)
    }
    #[doc(alias = "vkResetFences")]
    pub fn reset_fences(&self, p_fences: &[Fence]) -> Result<(), Error> {
        self.context.reset_fences(self, p_fences)
    }
    #[doc(alias = "vkGetFenceStatus")]
    pub fn get_fence_status(&self, fence: Fence) -> Result<(), Error> {
        self.context.get_fence_status(self, fence)
    }
    #[doc(alias = "vkWaitForFences")]
    pub fn wait_for_fences(&self, p_fences: &[Fence], wait_all: Bool32, timeout: u64) -> Result<(), Error> {
        self.context.wait_for_fences(self, p_fences, wait_all, timeout)
    }
    #[doc(alias = "vkGetEventStatus")]
    pub fn get_event_status(&self, event: Event) -> Result<(), Error> {
        self.context.get_event_status(self, event)
    }
    #[doc(alias = "vkSetEvent")]
    pub fn set_event(&self, event: Event) -> Result<(), Error> {
        self.context.set_event(self, event)
    }
    #[doc(alias = "vkResetEvent")]
    pub fn reset_event(&self, event: Event) -> Result<(), Error> {
        self.context.reset_event(self, event)
    }
    #[cfg(feature = "VULKAN_1_2")]
    #[doc(alias = "vkResetQueryPool")]
    pub fn reset_query_pool(&self, query_pool: QueryPool, first_query: u32, query_count: u32) -> () {
        self.context
            .reset_query_pool(self, query_pool, first_query, query_count)
    }
    #[doc(alias = "vkGetImageSubresourceLayout")]
    pub fn get_image_subresource_layout(&self, image: Image, p_subresource: &ImageSubresource) -> SubresourceLayout {
        self.context.get_image_subresource_layout(self, image, p_subresource)
    }
    #[doc(alias = "vkMergePipelineCaches")]
    pub fn merge_pipeline_caches(&self, dst_cache: PipelineCache, p_src_caches: &[PipelineCache]) -> Result<(), Error> {
        self.context.merge_pipeline_caches(self, dst_cache, p_src_caches)
    }
    #[cfg(feature = "VK_HUAWEI_subpass_shading")]
    #[doc(alias = "vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI")]
    pub fn get_device_subpass_shading_max_workgroup_size_huawei(
        &self,
        renderpass: RenderPass,
    ) -> Result<Extent2D, Error> {
        self.context
            .get_device_subpass_shading_max_workgroup_size_huawei(self, renderpass)
    }
    #[doc(alias = "vkResetDescriptorPool")]
    pub fn reset_descriptor_pool(
        &self,
        descriptor_pool: DescriptorPool,
        flags: DescriptorPoolResetFlags,
    ) -> Result<(), Error> {
        self.context.reset_descriptor_pool(self, descriptor_pool, flags)
    }
    #[doc(alias = "vkAllocateDescriptorSets")]
    pub fn allocate_descriptor_sets(
        &self,
        p_allocate_info: &DescriptorSetAllocateInfo,
    ) -> Result<SmallVec<[DescriptorSet; 1]>, Error> {
        self.context.allocate_descriptor_sets(self, p_allocate_info)
    }
    #[doc(alias = "vkFreeDescriptorSets")]
    pub fn free_descriptor_sets(
        &self,
        descriptor_pool: DescriptorPool,
        p_descriptor_sets: &[DescriptorSet],
    ) -> Result<(), Error> {
        self.context
            .free_descriptor_sets(self, descriptor_pool, p_descriptor_sets)
    }
    #[doc(alias = "vkUpdateDescriptorSets")]
    pub fn update_descriptor_sets(
        &self,
        p_descriptor_writes: &[WriteDescriptorSet],
        p_descriptor_copies: &[CopyDescriptorSet],
    ) -> () {
        self.context
            .update_descriptor_sets(self, p_descriptor_writes, p_descriptor_copies)
    }
    #[doc(alias = "vkGetRenderAreaGranularity")]
    pub fn get_render_area_granularity(&self, render_pass: RenderPass) -> Extent2D {
        self.context.get_render_area_granularity(self, render_pass)
    }
    #[doc(alias = "vkResetCommandPool")]
    pub fn reset_command_pool(&self, command_pool: CommandPool, flags: CommandPoolResetFlags) -> Result<(), Error> {
        self.context.reset_command_pool(self, command_pool, flags)
    }
    #[doc(alias = "vkAllocateCommandBuffers")]
    pub fn allocate_command_buffers(
        &self,
        p_allocate_info: &CommandBufferAllocateInfo,
    ) -> Result<SmallVec<[CommandBuffer; 1]>, Error> {
        self.context.allocate_command_buffers(self, p_allocate_info)
    }
    #[doc(alias = "vkFreeCommandBuffers")]
    pub fn free_command_buffers(&self, command_pool: CommandPool, p_command_buffers: &[CommandBuffer]) -> () {
        self.context.free_command_buffers(self, command_pool, p_command_buffers)
    }
    #[cfg(feature = "VK_KHR_swapchain")]
    #[doc(alias = "vkGetSwapchainImagesKHR")]
    pub fn get_swapchain_images_khr(
        &self,
        swapchain: SwapchainKHR,
        p_swapchain_image_count: Option<usize>,
    ) -> Result<SmallVec<[Image; 1]>, Error> {
        self.context
            .get_swapchain_images_khr(self, swapchain, p_swapchain_image_count)
    }
    #[cfg(feature = "VK_KHR_swapchain")]
    #[doc(alias = "vkAcquireNextImageKHR")]
    pub fn acquire_next_image_khr(
        &self,
        swapchain: SwapchainKHR,
        timeout: u64,
        semaphore: Semaphore,
        fence: Fence,
    ) -> Result<u32, Error> {
        self.context
            .acquire_next_image_khr(self, swapchain, timeout, semaphore, fence)
    }
    #[cfg(feature = "VK_EXT_debug_marker")]
    #[doc(alias = "vkDebugMarkerSetObjectNameEXT")]
    pub fn debug_marker_set_object_name_ext(&self, p_name_info: &DebugMarkerObjectNameInfoEXT) -> Result<(), Error> {
        self.context.debug_marker_set_object_name_ext(self, p_name_info)
    }
    #[cfg(feature = "VK_EXT_debug_marker")]
    #[doc(alias = "vkDebugMarkerSetObjectTagEXT")]
    pub fn debug_marker_set_object_tag_ext(&self, p_tag_info: &DebugMarkerObjectTagInfoEXT) -> Result<(), Error> {
        self.context.debug_marker_set_object_tag_ext(self, p_tag_info)
    }
    #[cfg(feature = "VK_NV_device_generated_commands")]
    #[doc(alias = "vkGetGeneratedCommandsMemoryRequirementsNV")]
    pub fn get_generated_commands_memory_requirements_nv(
        &self,
        p_info: &GeneratedCommandsMemoryRequirementsInfoNV,
    ) -> MemoryRequirements2 {
        self.context.get_generated_commands_memory_requirements_nv(self, p_info)
    }
    #[doc(alias = "vkTrimCommandPool")]
    pub fn trim_command_pool(&self, command_pool: CommandPool, flags: CommandPoolTrimFlags) -> () {
        self.context.trim_command_pool(self, command_pool, flags)
    }
    #[cfg(feature = "VK_KHR_external_memory_fd")]
    #[doc(alias = "vkGetMemoryFdKHR")]
    pub fn get_memory_fd_khr(&self, p_get_fd_info: &MemoryGetFdInfoKHR) -> Result<i32, Error> {
        self.context.get_memory_fd_khr(self, p_get_fd_info)
    }
    #[cfg(feature = "VK_KHR_external_memory_fd")]
    #[doc(alias = "vkGetMemoryFdPropertiesKHR")]
    pub fn get_memory_fd_properties_khr(
        &self,
        handle_type: ExternalMemoryHandleTypeFlagBits,
        fd: i32,
    ) -> Result<MemoryFdPropertiesKHR, Error> {
        self.context.get_memory_fd_properties_khr(self, handle_type, fd)
    }
    #[cfg(feature = "VK_KHR_external_semaphore_fd")]
    #[doc(alias = "vkGetSemaphoreFdKHR")]
    pub fn get_semaphore_fd_khr(&self, p_get_fd_info: &SemaphoreGetFdInfoKHR) -> Result<i32, Error> {
        self.context.get_semaphore_fd_khr(self, p_get_fd_info)
    }
    #[cfg(feature = "VK_KHR_external_semaphore_fd")]
    #[doc(alias = "vkImportSemaphoreFdKHR")]
    pub fn import_semaphore_fd_khr(&self, p_import_semaphore_fd_info: &ImportSemaphoreFdInfoKHR) -> Result<(), Error> {
        self.context.import_semaphore_fd_khr(self, p_import_semaphore_fd_info)
    }
    #[cfg(feature = "VK_KHR_external_fence_fd")]
    #[doc(alias = "vkGetFenceFdKHR")]
    pub fn get_fence_fd_khr(&self, p_get_fd_info: &FenceGetFdInfoKHR) -> Result<i32, Error> {
        self.context.get_fence_fd_khr(self, p_get_fd_info)
    }
    #[cfg(feature = "VK_KHR_external_fence_fd")]
    #[doc(alias = "vkImportFenceFdKHR")]
    pub fn import_fence_fd_khr(&self, p_import_fence_fd_info: &ImportFenceFdInfoKHR) -> Result<(), Error> {
        self.context.import_fence_fd_khr(self, p_import_fence_fd_info)
    }
    #[cfg(feature = "VK_EXT_display_control")]
    #[doc(alias = "vkDisplayPowerControlEXT")]
    pub fn display_power_control_ext(
        &self,
        display: DisplayKHR,
        p_display_power_info: &DisplayPowerInfoEXT,
    ) -> Result<(), Error> {
        self.context
            .display_power_control_ext(self, display, p_display_power_info)
    }
    #[cfg(feature = "VK_EXT_display_control")]
    #[doc(alias = "vkGetSwapchainCounterEXT")]
    pub fn get_swapchain_counter_ext(
        &self,
        swapchain: SwapchainKHR,
        counter: SurfaceCounterFlagBitsEXT,
    ) -> Result<u64, Error> {
        self.context.get_swapchain_counter_ext(self, swapchain, counter)
    }
    #[doc(alias = "vkGetDeviceGroupPeerMemoryFeatures")]
    pub fn get_device_group_peer_memory_features(
        &self,
        heap_index: u32,
        local_device_index: u32,
        remote_device_index: u32,
    ) -> PeerMemoryFeatureFlags {
        self.context
            .get_device_group_peer_memory_features(self, heap_index, local_device_index, remote_device_index)
    }
    #[doc(alias = "vkBindBufferMemory2")]
    pub fn bind_buffer_memory2(&self, p_bind_infos: &[BindBufferMemoryInfo]) -> Result<(), Error> {
        self.context.bind_buffer_memory2(self, p_bind_infos)
    }
    #[doc(alias = "vkBindImageMemory2")]
    pub fn bind_image_memory2(&self, p_bind_infos: &[BindImageMemoryInfo]) -> Result<(), Error> {
        self.context.bind_image_memory2(self, p_bind_infos)
    }
    #[cfg(feature = "VK_KHR_device_group")]
    #[doc(alias = "vkGetDeviceGroupPresentCapabilitiesKHR")]
    pub fn get_device_group_present_capabilities_khr(&self) -> Result<DeviceGroupPresentCapabilitiesKHR, Error> {
        self.context.get_device_group_present_capabilities_khr(self)
    }
    #[cfg(feature = "VK_KHR_device_group")]
    #[doc(alias = "vkGetDeviceGroupSurfacePresentModesKHR")]
    pub fn get_device_group_surface_present_modes_khr(
        &self,
        surface: SurfaceKHR,
        p_modes: &mut DeviceGroupPresentModeFlagsKHR,
    ) -> Result<(), Error> {
        self.context
            .get_device_group_surface_present_modes_khr(self, surface, p_modes)
    }
    #[cfg(feature = "VK_KHR_device_group")]
    #[doc(alias = "vkAcquireNextImage2KHR")]
    pub fn acquire_next_image2_khr(&self, p_acquire_info: &AcquireNextImageInfoKHR) -> Result<u32, Error> {
        self.context.acquire_next_image2_khr(self, p_acquire_info)
    }
    #[cfg(feature = "VK_EXT_hdr_metadata")]
    #[doc(alias = "vkSetHdrMetadataEXT")]
    pub fn set_hdr_metadata_ext(&self, p_swapchains: &[SwapchainKHR], p_metadata: &[HdrMetadataEXT]) -> () {
        self.context.set_hdr_metadata_ext(self, p_swapchains, p_metadata)
    }
    #[cfg(feature = "VK_KHR_shared_presentable_image")]
    #[doc(alias = "vkGetSwapchainStatusKHR")]
    pub fn get_swapchain_status_khr(&self, swapchain: SwapchainKHR) -> Result<(), Error> {
        self.context.get_swapchain_status_khr(self, swapchain)
    }
    #[cfg(feature = "VK_GOOGLE_display_timing")]
    #[doc(alias = "vkGetRefreshCycleDurationGOOGLE")]
    pub fn get_refresh_cycle_duration_google(
        &self,
        swapchain: SwapchainKHR,
    ) -> Result<RefreshCycleDurationGOOGLE, Error> {
        self.context.get_refresh_cycle_duration_google(self, swapchain)
    }
    #[cfg(feature = "VK_GOOGLE_display_timing")]
    #[doc(alias = "vkGetPastPresentationTimingGOOGLE")]
    pub fn get_past_presentation_timing_google(
        &self,
        swapchain: SwapchainKHR,
        p_presentation_timing_count: Option<usize>,
    ) -> Result<SmallVec<[PastPresentationTimingGOOGLE; 1]>, Error> {
        self.context
            .get_past_presentation_timing_google(self, swapchain, p_presentation_timing_count)
    }
    #[doc(alias = "vkGetBufferMemoryRequirements2")]
    pub fn get_buffer_memory_requirements2(&self, p_info: &BufferMemoryRequirementsInfo2) -> MemoryRequirements2 {
        self.context.get_buffer_memory_requirements2(self, p_info)
    }
    #[doc(alias = "vkGetImageMemoryRequirements2")]
    pub fn get_image_memory_requirements2(&self, p_info: &ImageMemoryRequirementsInfo2) -> MemoryRequirements2 {
        self.context.get_image_memory_requirements2(self, p_info)
    }
    #[doc(alias = "vkGetImageSparseMemoryRequirements2")]
    pub fn get_image_sparse_memory_requirements2(
        &self,
        p_info: &ImageSparseMemoryRequirementsInfo2,
        p_sparse_memory_requirement_count: Option<usize>,
    ) -> SmallVec<[SparseImageMemoryRequirements2; 1]> {
        self.context
            .get_image_sparse_memory_requirements2(self, p_info, p_sparse_memory_requirement_count)
    }
    #[cfg(feature = "VULKAN_1_3")]
    #[doc(alias = "vkGetDeviceBufferMemoryRequirements")]
    pub fn get_device_buffer_memory_requirements(
        &self,
        p_info: &DeviceBufferMemoryRequirements,
    ) -> MemoryRequirements2 {
        self.context.get_device_buffer_memory_requirements(self, p_info)
    }
    #[cfg(feature = "VULKAN_1_3")]
    #[doc(alias = "vkGetDeviceImageMemoryRequirements")]
    pub fn get_device_image_memory_requirements(&self, p_info: &DeviceImageMemoryRequirements) -> MemoryRequirements2 {
        self.context.get_device_image_memory_requirements(self, p_info)
    }
    #[cfg(feature = "VULKAN_1_3")]
    #[doc(alias = "vkGetDeviceImageSparseMemoryRequirements")]
    pub fn get_device_image_sparse_memory_requirements(
        &self,
        p_info: &DeviceImageMemoryRequirements,
        p_sparse_memory_requirement_count: Option<usize>,
    ) -> SmallVec<[SparseImageMemoryRequirements2; 1]> {
        self.context
            .get_device_image_sparse_memory_requirements(self, p_info, p_sparse_memory_requirement_count)
    }
    #[doc(alias = "vkGetDeviceQueue2")]
    pub fn get_device_queue2(&self, p_queue_info: &DeviceQueueInfo2) -> Queue {
        self.context.get_device_queue2(self, p_queue_info)
    }
    #[cfg(feature = "VK_EXT_validation_cache")]
    #[doc(alias = "vkMergeValidationCachesEXT")]
    pub fn merge_validation_caches_ext(
        &self,
        dst_cache: ValidationCacheEXT,
        p_src_caches: &[ValidationCacheEXT],
    ) -> Result<(), Error> {
        self.context.merge_validation_caches_ext(self, dst_cache, p_src_caches)
    }
    #[doc(alias = "vkGetDescriptorSetLayoutSupport")]
    pub fn get_descriptor_set_layout_support(
        &self,
        p_create_info: &DescriptorSetLayoutCreateInfo,
    ) -> DescriptorSetLayoutSupport {
        self.context.get_descriptor_set_layout_support(self, p_create_info)
    }
    #[cfg(feature = "VK_AMD_display_native_hdr")]
    #[doc(alias = "vkSetLocalDimmingAMD")]
    pub fn set_local_dimming_amd(&self, swap_chain: SwapchainKHR, local_dimming_enable: Bool32) -> () {
        self.context
            .set_local_dimming_amd(self, swap_chain, local_dimming_enable)
    }
    #[cfg(feature = "VK_EXT_calibrated_timestamps")]
    #[doc(alias = "vkGetCalibratedTimestampsEXT")]
    pub fn get_calibrated_timestamps_ext(
        &self,
        p_timestamp_infos: &[CalibratedTimestampInfoEXT],
    ) -> Result<(Vec<u64>, u64), Error> {
        self.context.get_calibrated_timestamps_ext(self, p_timestamp_infos)
    }
    #[cfg(feature = "VK_EXT_debug_utils")]
    #[doc(alias = "vkSetDebugUtilsObjectNameEXT")]
    pub fn set_debug_utils_object_name_ext(&self, p_name_info: &DebugUtilsObjectNameInfoEXT) -> Result<(), Error> {
        self.context.set_debug_utils_object_name_ext(self, p_name_info)
    }
    #[cfg(feature = "VK_EXT_debug_utils")]
    #[doc(alias = "vkSetDebugUtilsObjectTagEXT")]
    pub fn set_debug_utils_object_tag_ext(&self, p_tag_info: &DebugUtilsObjectTagInfoEXT) -> Result<(), Error> {
        self.context.set_debug_utils_object_tag_ext(self, p_tag_info)
    }
    #[cfg(feature = "VULKAN_1_2")]
    #[doc(alias = "vkGetSemaphoreCounterValue")]
    pub fn get_semaphore_counter_value(&self, semaphore: Semaphore) -> Result<u64, Error> {
        self.context.get_semaphore_counter_value(self, semaphore)
    }
    #[cfg(feature = "VULKAN_1_2")]
    #[doc(alias = "vkWaitSemaphores")]
    pub fn wait_semaphores(&self, p_wait_info: &SemaphoreWaitInfo, timeout: u64) -> Result<(), Error> {
        self.context.wait_semaphores(self, p_wait_info, timeout)
    }
    #[cfg(feature = "VULKAN_1_2")]
    #[doc(alias = "vkSignalSemaphore")]
    pub fn signal_semaphore(&self, p_signal_info: &SemaphoreSignalInfo) -> Result<(), Error> {
        self.context.signal_semaphore(self, p_signal_info)
    }
    #[cfg(feature = "VK_NV_ray_tracing")]
    #[doc(alias = "vkCompileDeferredNV")]
    pub fn compile_deferred_nv(&self, pipeline: Pipeline, shader: u32) -> Result<(), Error> {
        self.context.compile_deferred_nv(self, pipeline, shader)
    }
    #[cfg(feature = "VK_NV_ray_tracing")]
    #[doc(alias = "vkGetAccelerationStructureMemoryRequirementsNV")]
    pub fn get_acceleration_structure_memory_requirements_nv(
        &self,
        p_info: &AccelerationStructureMemoryRequirementsInfoNV,
    ) -> MemoryRequirements2 {
        self.context
            .get_acceleration_structure_memory_requirements_nv(self, p_info)
    }
    #[cfg(feature = "VK_NV_ray_tracing")]
    #[doc(alias = "vkBindAccelerationStructureMemoryNV")]
    pub fn bind_acceleration_structure_memory_nv(
        &self,
        p_bind_infos: &[BindAccelerationStructureMemoryInfoNV],
    ) -> Result<(), Error> {
        self.context.bind_acceleration_structure_memory_nv(self, p_bind_infos)
    }
    #[cfg(feature = "VK_KHR_acceleration_structure")]
    #[doc(alias = "vkCopyAccelerationStructureKHR")]
    pub fn copy_acceleration_structure_khr(
        &self,
        deferred_operation: DeferredOperationKHR,
        p_info: &CopyAccelerationStructureInfoKHR,
    ) -> Result<(), Error> {
        self.context
            .copy_acceleration_structure_khr(self, deferred_operation, p_info)
    }
    #[cfg(feature = "VK_KHR_acceleration_structure")]
    #[doc(alias = "vkCopyAccelerationStructureToMemoryKHR")]
    pub fn copy_acceleration_structure_to_memory_khr(
        &self,
        deferred_operation: DeferredOperationKHR,
        p_info: &CopyAccelerationStructureToMemoryInfoKHR,
    ) -> Result<(), Error> {
        self.context
            .copy_acceleration_structure_to_memory_khr(self, deferred_operation, p_info)
    }
    #[cfg(feature = "VK_KHR_acceleration_structure")]
    #[doc(alias = "vkCopyMemoryToAccelerationStructureKHR")]
    pub fn copy_memory_to_acceleration_structure_khr(
        &self,
        deferred_operation: DeferredOperationKHR,
        p_info: &CopyMemoryToAccelerationStructureInfoKHR,
    ) -> Result<(), Error> {
        self.context
            .copy_memory_to_acceleration_structure_khr(self, deferred_operation, p_info)
    }
    #[cfg(feature = "VK_KHR_acceleration_structure")]
    #[doc(alias = "vkGetDeviceAccelerationStructureCompatibilityKHR")]
    pub fn get_device_acceleration_structure_compatibility_khr(
        &self,
        p_version_info: &AccelerationStructureVersionInfoKHR,
    ) -> AccelerationStructureCompatibilityKHR {
        self.context
            .get_device_acceleration_structure_compatibility_khr(self, p_version_info)
    }
    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
    #[doc(alias = "vkGetRayTracingShaderGroupStackSizeKHR")]
    pub fn get_ray_tracing_shader_group_stack_size_khr(
        &self,
        pipeline: Pipeline,
        group: u32,
        group_shader: ShaderGroupShaderKHR,
    ) -> () {
        self.context
            .get_ray_tracing_shader_group_stack_size_khr(self, pipeline, group, group_shader)
    }
    #[cfg(feature = "VK_NVX_image_view_handle")]
    #[doc(alias = "vkGetImageViewHandleNVX")]
    pub fn get_image_view_handle_nvx(&self, p_info: &ImageViewHandleInfoNVX) -> () {
        self.context.get_image_view_handle_nvx(self, p_info)
    }
    #[cfg(feature = "VK_NVX_image_view_handle")]
    #[doc(alias = "vkGetImageViewAddressNVX")]
    pub fn get_image_view_address_nvx(&self, image_view: ImageView) -> Result<ImageViewAddressPropertiesNVX, Error> {
        self.context.get_image_view_address_nvx(self, image_view)
    }
    #[cfg(feature = "VK_EXT_full_screen_exclusive")]
    #[doc(alias = "vkGetDeviceGroupSurfacePresentModes2EXT")]
    pub fn get_device_group_surface_present_modes2_ext(
        &self,
        p_surface_info: &PhysicalDeviceSurfaceInfo2KHR,
        p_modes: &mut DeviceGroupPresentModeFlagsKHR,
    ) -> Result<(), Error> {
        self.context
            .get_device_group_surface_present_modes2_ext(self, p_surface_info, p_modes)
    }
    #[cfg(feature = "VK_EXT_full_screen_exclusive")]
    #[doc(alias = "vkAcquireFullScreenExclusiveModeEXT")]
    pub fn acquire_full_screen_exclusive_mode_ext(&self, swapchain: SwapchainKHR) -> Result<(), Error> {
        self.context.acquire_full_screen_exclusive_mode_ext(self, swapchain)
    }
    #[cfg(feature = "VK_EXT_full_screen_exclusive")]
    #[doc(alias = "vkReleaseFullScreenExclusiveModeEXT")]
    pub fn release_full_screen_exclusive_mode_ext(&self, swapchain: SwapchainKHR) -> Result<(), Error> {
        self.context.release_full_screen_exclusive_mode_ext(self, swapchain)
    }
    #[cfg(feature = "VK_KHR_performance_query")]
    #[doc(alias = "vkAcquireProfilingLockKHR")]
    pub fn acquire_profiling_lock_khr(&self, p_info: &AcquireProfilingLockInfoKHR) -> Result<(), Error> {
        self.context.acquire_profiling_lock_khr(self, p_info)
    }
    #[cfg(feature = "VK_KHR_performance_query")]
    #[doc(alias = "vkReleaseProfilingLockKHR")]
    pub fn release_profiling_lock_khr(&self) -> () {
        self.context.release_profiling_lock_khr(self)
    }
    #[cfg(feature = "VK_EXT_image_drm_format_modifier")]
    #[doc(alias = "vkGetImageDrmFormatModifierPropertiesEXT")]
    pub fn get_image_drm_format_modifier_properties_ext(
        &self,
        image: Image,
    ) -> Result<ImageDrmFormatModifierPropertiesEXT, Error> {
        self.context.get_image_drm_format_modifier_properties_ext(self, image)
    }
    #[cfg(feature = "VULKAN_1_2")]
    #[doc(alias = "vkGetBufferOpaqueCaptureAddress")]
    pub fn get_buffer_opaque_capture_address(&self, p_info: &BufferDeviceAddressInfo) -> () {
        self.context.get_buffer_opaque_capture_address(self, p_info)
    }
    #[cfg(feature = "VULKAN_1_2")]
    #[doc(alias = "vkGetBufferDeviceAddress")]
    pub fn get_buffer_device_address(&self, p_info: &BufferDeviceAddressInfo) -> () {
        self.context.get_buffer_device_address(self, p_info)
    }
    #[cfg(feature = "VK_INTEL_performance_query")]
    #[doc(alias = "vkInitializePerformanceApiINTEL")]
    pub fn initialize_performance_api_intel(
        &self,
        p_initialize_info: &InitializePerformanceApiInfoINTEL,
    ) -> Result<(), Error> {
        self.context.initialize_performance_api_intel(self, p_initialize_info)
    }
    #[cfg(feature = "VK_INTEL_performance_query")]
    #[doc(alias = "vkUninitializePerformanceApiINTEL")]
    pub fn uninitialize_performance_api_intel(&self) -> () {
        self.context.uninitialize_performance_api_intel(self)
    }
    #[cfg(feature = "VK_INTEL_performance_query")]
    #[doc(alias = "vkAcquirePerformanceConfigurationINTEL")]
    pub fn acquire_performance_configuration_intel(
        &self,
        p_acquire_info: &PerformanceConfigurationAcquireInfoINTEL,
    ) -> Result<PerformanceConfigurationINTEL, Error> {
        self.context
            .acquire_performance_configuration_intel(self, p_acquire_info)
    }
    #[cfg(feature = "VK_INTEL_performance_query")]
    #[doc(alias = "vkReleasePerformanceConfigurationINTEL")]
    pub fn release_performance_configuration_intel(
        &self,
        configuration: PerformanceConfigurationINTEL,
    ) -> Result<(), Error> {
        self.context
            .release_performance_configuration_intel(self, configuration)
    }
    #[cfg(feature = "VK_INTEL_performance_query")]
    #[doc(alias = "vkGetPerformanceParameterINTEL")]
    pub fn get_performance_parameter_intel(
        &self,
        parameter: PerformanceParameterTypeINTEL,
    ) -> Result<PerformanceValueINTEL, Error> {
        self.context.get_performance_parameter_intel(self, parameter)
    }
    #[cfg(feature = "VULKAN_1_2")]
    #[doc(alias = "vkGetDeviceMemoryOpaqueCaptureAddress")]
    pub fn get_device_memory_opaque_capture_address(&self, p_info: &DeviceMemoryOpaqueCaptureAddressInfo) -> () {
        self.context.get_device_memory_opaque_capture_address(self, p_info)
    }
    #[cfg(feature = "VK_KHR_pipeline_executable_properties")]
    #[doc(alias = "vkGetPipelineExecutablePropertiesKHR")]
    pub fn get_pipeline_executable_properties_khr(
        &self,
        p_pipeline_info: &PipelineInfoKHR,
        p_executable_count: Option<usize>,
    ) -> Result<SmallVec<[PipelineExecutablePropertiesKHR; 1]>, Error> {
        self.context
            .get_pipeline_executable_properties_khr(self, p_pipeline_info, p_executable_count)
    }
    #[cfg(feature = "VK_KHR_pipeline_executable_properties")]
    #[doc(alias = "vkGetPipelineExecutableStatisticsKHR")]
    pub fn get_pipeline_executable_statistics_khr(
        &self,
        p_executable_info: &PipelineExecutableInfoKHR,
        p_statistic_count: Option<usize>,
    ) -> Result<SmallVec<[PipelineExecutableStatisticKHR; 1]>, Error> {
        self.context
            .get_pipeline_executable_statistics_khr(self, p_executable_info, p_statistic_count)
    }
    #[cfg(feature = "VK_KHR_pipeline_executable_properties")]
    #[doc(alias = "vkGetPipelineExecutableInternalRepresentationsKHR")]
    pub fn get_pipeline_executable_internal_representations_khr(
        &self,
        p_executable_info: &PipelineExecutableInfoKHR,
        p_internal_representation_count: Option<usize>,
    ) -> Result<SmallVec<[PipelineExecutableInternalRepresentationKHR; 1]>, Error> {
        self.context.get_pipeline_executable_internal_representations_khr(
            self,
            p_executable_info,
            p_internal_representation_count,
        )
    }
    #[cfg(feature = "VK_KHR_acceleration_structure")]
    #[doc(alias = "vkBuildAccelerationStructuresKHR")]
    pub fn build_acceleration_structures_khr(
        &self,
        deferred_operation: DeferredOperationKHR,
        p_infos: &[AccelerationStructureBuildGeometryInfoKHR],
        pp_build_range_infos: &AccelerationStructureBuildRangeInfoKHR,
    ) -> Result<(), Error> {
        self.context
            .build_acceleration_structures_khr(self, deferred_operation, p_infos, pp_build_range_infos)
    }
    #[cfg(feature = "VK_KHR_acceleration_structure")]
    #[doc(alias = "vkGetAccelerationStructureDeviceAddressKHR")]
    pub fn get_acceleration_structure_device_address_khr(
        &self,
        p_info: &AccelerationStructureDeviceAddressInfoKHR,
    ) -> () {
        self.context.get_acceleration_structure_device_address_khr(self, p_info)
    }
    #[cfg(feature = "VK_KHR_deferred_host_operations")]
    #[doc(alias = "vkGetDeferredOperationMaxConcurrencyKHR")]
    pub fn get_deferred_operation_max_concurrency_khr(&self, operation: DeferredOperationKHR) -> () {
        self.context.get_deferred_operation_max_concurrency_khr(self, operation)
    }
    #[cfg(feature = "VK_KHR_deferred_host_operations")]
    #[doc(alias = "vkGetDeferredOperationResultKHR")]
    pub fn get_deferred_operation_result_khr(&self, operation: DeferredOperationKHR) -> Result<(), Error> {
        self.context.get_deferred_operation_result_khr(self, operation)
    }
    #[cfg(feature = "VK_KHR_deferred_host_operations")]
    #[doc(alias = "vkDeferredOperationJoinKHR")]
    pub fn deferred_operation_join_khr(&self, operation: DeferredOperationKHR) -> Result<(), Error> {
        self.context.deferred_operation_join_khr(self, operation)
    }
    #[cfg(feature = "VULKAN_1_3")]
    #[doc(alias = "vkSetPrivateData")]
    pub fn set_private_data(
        &self,
        object_type: ObjectType,
        object_handle: u64,
        private_data_slot: PrivateDataSlot,
        data: u64,
    ) -> Result<(), Error> {
        self.context
            .set_private_data(self, object_type, object_handle, private_data_slot, data)
    }
    #[cfg(feature = "VULKAN_1_3")]
    #[doc(alias = "vkGetPrivateData")]
    pub fn get_private_data(
        &self,
        object_type: ObjectType,
        object_handle: u64,
        private_data_slot: PrivateDataSlot,
    ) -> u64 {
        self.context
            .get_private_data(self, object_type, object_handle, private_data_slot)
    }
    #[cfg(feature = "VK_KHR_acceleration_structure")]
    #[doc(alias = "vkGetAccelerationStructureBuildSizesKHR")]
    pub fn get_acceleration_structure_build_sizes_khr(
        &self,
        build_type: AccelerationStructureBuildTypeKHR,
        p_build_info: &AccelerationStructureBuildGeometryInfoKHR,
        p_max_primitive_counts: &[u32],
    ) -> AccelerationStructureBuildSizesInfoKHR {
        self.context
            .get_acceleration_structure_build_sizes_khr(self, build_type, p_build_info, p_max_primitive_counts)
    }
    #[cfg(feature = "VK_KHR_video_queue")]
    #[doc(alias = "vkUpdateVideoSessionParametersKHR")]
    pub fn update_video_session_parameters_khr(
        &self,
        video_session_parameters: VideoSessionParametersKHR,
        p_update_info: &VideoSessionParametersUpdateInfoKHR,
    ) -> Result<(), Error> {
        self.context
            .update_video_session_parameters_khr(self, video_session_parameters, p_update_info)
    }
    #[cfg(feature = "VK_KHR_video_queue")]
    #[doc(alias = "vkGetVideoSessionMemoryRequirementsKHR")]
    pub fn get_video_session_memory_requirements_khr(
        &self,
        video_session: VideoSessionKHR,
        p_video_session_memory_requirements_count: Option<usize>,
    ) -> Result<SmallVec<[VideoGetMemoryPropertiesKHR; 1]>, Error> {
        self.context.get_video_session_memory_requirements_khr(
            self,
            video_session,
            p_video_session_memory_requirements_count,
        )
    }
    #[cfg(feature = "VK_KHR_video_queue")]
    #[doc(alias = "vkBindVideoSessionMemoryKHR")]
    pub fn bind_video_session_memory_khr(
        &self,
        video_session: VideoSessionKHR,
        p_video_session_bind_memories: &[VideoBindMemoryKHR],
    ) -> Result<(), Error> {
        self.context
            .bind_video_session_memory_khr(self, video_session, p_video_session_bind_memories)
    }
    #[cfg(feature = "VK_EXT_pageable_device_local_memory")]
    #[doc(alias = "vkSetDeviceMemoryPriorityEXT")]
    pub fn set_device_memory_priority_ext(&self, memory: DeviceMemory, priority: f32) -> () {
        self.context.set_device_memory_priority_ext(self, memory, priority)
    }
    #[cfg(feature = "VK_KHR_present_wait")]
    #[doc(alias = "vkWaitForPresentKHR")]
    pub fn wait_for_present_khr(&self, swapchain: SwapchainKHR, present_id: u64, timeout: u64) -> Result<(), Error> {
        self.context.wait_for_present_khr(self, swapchain, present_id, timeout)
    }
    #[cfg(feature = "VK_FUCHSIA_buffer_collection")]
    #[doc(alias = "vkSetBufferCollectionBufferConstraintsFUCHSIA")]
    pub fn set_buffer_collection_buffer_constraints_fuchsia(
        &self,
        collection: BufferCollectionFUCHSIA,
        p_buffer_constraints_info: &BufferConstraintsInfoFUCHSIA,
    ) -> Result<(), Error> {
        self.context
            .set_buffer_collection_buffer_constraints_fuchsia(self, collection, p_buffer_constraints_info)
    }
    #[cfg(feature = "VK_FUCHSIA_buffer_collection")]
    #[doc(alias = "vkSetBufferCollectionImageConstraintsFUCHSIA")]
    pub fn set_buffer_collection_image_constraints_fuchsia(
        &self,
        collection: BufferCollectionFUCHSIA,
        p_image_constraints_info: &ImageConstraintsInfoFUCHSIA,
    ) -> Result<(), Error> {
        self.context
            .set_buffer_collection_image_constraints_fuchsia(self, collection, p_image_constraints_info)
    }
    #[cfg(feature = "VK_FUCHSIA_buffer_collection")]
    #[doc(alias = "vkGetBufferCollectionPropertiesFUCHSIA")]
    pub fn get_buffer_collection_properties_fuchsia(
        &self,
        collection: BufferCollectionFUCHSIA,
    ) -> Result<BufferCollectionPropertiesFUCHSIA, Error> {
        self.context.get_buffer_collection_properties_fuchsia(self, collection)
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for Device {
    type LowLevel = crate::native::vulkan1_0::Device;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *context.device().get(&self.id).expect("unknwon handle").handle()
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for Device {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        let object_id = ObjectId::random();
        context.device().insert(object_id, Container::new(value));
        Self {
            context: context.clone(),
            id: object_id,
        }
    }
}
#[doc(alias = "VkQueue")]
#[derive(Debug)]
pub struct Queue {
    context: Arc<Context>,
    id: ObjectId,
}
impl Clone for Queue {
    fn clone(&self) -> Self {
        self.context.clone_queue(self.id);
        Self {
            context: Arc::clone(&self.context),
            id: self.id,
        }
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for Queue {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.id.serialize(serializer)
    }
}
impl<'de> Deserialize<'de> for Queue {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let id = ObjectId::deserialize(deserializer)?;
        crate::context::CONTEXT.with(|context| {
            let borrow = context.borrow();
            let context = borrow.as_ref().expect("Context not set.");
            Ok(Self {
                context: Arc::clone(context),
                id,
            })
        })
    }
}
impl Drop for Queue {
    fn drop(&mut self) {
        if !std::thread::panicking() {
            self.context.drop_queue(&self.id);
        }
    }
}
impl PartialEq for Queue {
    fn eq(&self, other: &Self) -> bool {
        self.id == other.id
    }
}
impl Queue {
    ///Creates a new instance of this handle from its core components.
    pub(crate) const unsafe fn new(context: Arc<Context>, id: ObjectId) -> Self {
        Self { context, id }
    }
    ///Gets the object id
    pub fn id(&self) -> &ObjectId {
        &self.id
    }
    ///Gets a reference to the context
    pub fn context(&self) -> &Context {
        &self.context
    }
    ///Gets a reference to the context wrapped in an [`Arc`]
    pub fn arc_context(&self) -> &Arc<Context> {
        &self.context
    }
    #[doc(alias = "vkQueueSubmit")]
    pub fn queue_submit(&mut self, p_submits: &[SubmitInfo], fence: Fence) -> Result<(), Error> {
        self.context.queue_submit(self, p_submits, fence)
    }
    #[doc(alias = "vkQueueWaitIdle")]
    pub fn queue_wait_idle(&mut self) -> Result<(), Error> {
        self.context.queue_wait_idle(self)
    }
    #[doc(alias = "vkQueueBindSparse")]
    pub fn queue_bind_sparse(&mut self, p_bind_info: &[BindSparseInfo], fence: Fence) -> Result<(), Error> {
        self.context.queue_bind_sparse(self, p_bind_info, fence)
    }
    #[cfg(feature = "VK_KHR_swapchain")]
    #[doc(alias = "vkQueuePresentKHR")]
    pub fn queue_present_khr(&mut self, p_present_info: &PresentInfoKHR) -> Result<(), Error> {
        self.context.queue_present_khr(self, p_present_info)
    }
    #[cfg(feature = "VK_EXT_debug_utils")]
    #[doc(alias = "vkQueueBeginDebugUtilsLabelEXT")]
    pub fn queue_begin_debug_utils_label_ext(&self, p_label_info: &DebugUtilsLabelEXT) -> () {
        self.context.queue_begin_debug_utils_label_ext(self, p_label_info)
    }
    #[cfg(feature = "VK_EXT_debug_utils")]
    #[doc(alias = "vkQueueEndDebugUtilsLabelEXT")]
    pub fn queue_end_debug_utils_label_ext(&self) -> () {
        self.context.queue_end_debug_utils_label_ext(self)
    }
    #[cfg(feature = "VK_EXT_debug_utils")]
    #[doc(alias = "vkQueueInsertDebugUtilsLabelEXT")]
    pub fn queue_insert_debug_utils_label_ext(&self, p_label_info: &DebugUtilsLabelEXT) -> () {
        self.context.queue_insert_debug_utils_label_ext(self, p_label_info)
    }
    #[cfg(feature = "VK_INTEL_performance_query")]
    #[doc(alias = "vkQueueSetPerformanceConfigurationINTEL")]
    pub fn queue_set_performance_configuration_intel(
        &self,
        configuration: PerformanceConfigurationINTEL,
    ) -> Result<(), Error> {
        self.context
            .queue_set_performance_configuration_intel(self, configuration)
    }
    #[cfg(feature = "VULKAN_1_3")]
    #[doc(alias = "vkQueueSubmit2")]
    pub fn queue_submit2(&mut self, p_submits: &[SubmitInfo2], fence: Fence) -> Result<(), Error> {
        self.context.queue_submit2(self, p_submits, fence)
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for Queue {
    type LowLevel = crate::native::vulkan1_0::Queue;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *context.queue().get(&self.id).expect("unknwon handle").handle()
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for Queue {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        let object_id = ObjectId::random();
        context.queue().insert(object_id, Container::new(value));
        Self {
            context: context.clone(),
            id: object_id,
        }
    }
}
#[doc(alias = "VkCommandBuffer")]
#[derive(Debug)]
pub struct CommandBuffer {
    context: Arc<Context>,
    id: ObjectId,
}
impl Clone for CommandBuffer {
    fn clone(&self) -> Self {
        self.context.clone_command_buffer(self.id);
        Self {
            context: Arc::clone(&self.context),
            id: self.id,
        }
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for CommandBuffer {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.id.serialize(serializer)
    }
}
impl<'de> Deserialize<'de> for CommandBuffer {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let id = ObjectId::deserialize(deserializer)?;
        crate::context::CONTEXT.with(|context| {
            let borrow = context.borrow();
            let context = borrow.as_ref().expect("Context not set.");
            Ok(Self {
                context: Arc::clone(context),
                id,
            })
        })
    }
}
impl Drop for CommandBuffer {
    fn drop(&mut self) {
        if !std::thread::panicking() {
            self.context.drop_command_buffer(&self.id);
        }
    }
}
impl PartialEq for CommandBuffer {
    fn eq(&self, other: &Self) -> bool {
        self.id == other.id
    }
}
impl CommandBuffer {
    ///Creates a new instance of this handle from its core components.
    pub(crate) const unsafe fn new(context: Arc<Context>, id: ObjectId) -> Self {
        Self { context, id }
    }
    ///Gets the object id
    pub fn id(&self) -> &ObjectId {
        &self.id
    }
    ///Gets a reference to the context
    pub fn context(&self) -> &Context {
        &self.context
    }
    ///Gets a reference to the context wrapped in an [`Arc`]
    pub fn arc_context(&self) -> &Arc<Context> {
        &self.context
    }
    #[doc(alias = "vkBeginCommandBuffer")]
    pub fn begin_command_buffer(&mut self, p_begin_info: &CommandBufferBeginInfo) -> Result<(), Error> {
        self.context.begin_command_buffer(self, p_begin_info)
    }
    #[doc(alias = "vkEndCommandBuffer")]
    pub fn end_command_buffer(&mut self) -> Result<(), Error> {
        self.context.end_command_buffer(self)
    }
    #[doc(alias = "vkResetCommandBuffer")]
    pub fn reset_command_buffer(&mut self, flags: CommandBufferResetFlags) -> Result<(), Error> {
        self.context.reset_command_buffer(self, flags)
    }
    #[doc(alias = "vkCmdBindPipeline")]
    pub fn cmd_bind_pipeline(&mut self, pipeline_bind_point: PipelineBindPoint, pipeline: Pipeline) -> () {
        self.context.cmd_bind_pipeline(self, pipeline_bind_point, pipeline)
    }
    #[doc(alias = "vkCmdSetViewport")]
    pub fn cmd_set_viewport(&mut self, first_viewport: u32, p_viewports: &[Viewport]) -> () {
        self.context.cmd_set_viewport(self, first_viewport, p_viewports)
    }
    #[doc(alias = "vkCmdSetScissor")]
    pub fn cmd_set_scissor(&mut self, first_scissor: u32, p_scissors: &[Rect2D]) -> () {
        self.context.cmd_set_scissor(self, first_scissor, p_scissors)
    }
    #[doc(alias = "vkCmdSetLineWidth")]
    pub fn cmd_set_line_width(&mut self, line_width: f32) -> () {
        self.context.cmd_set_line_width(self, line_width)
    }
    #[doc(alias = "vkCmdSetDepthBias")]
    pub fn cmd_set_depth_bias(
        &mut self,
        depth_bias_constant_factor: f32,
        depth_bias_clamp: f32,
        depth_bias_slope_factor: f32,
    ) -> () {
        self.context.cmd_set_depth_bias(
            self,
            depth_bias_constant_factor,
            depth_bias_clamp,
            depth_bias_slope_factor,
        )
    }
    #[doc(alias = "vkCmdSetBlendConstants")]
    pub fn cmd_set_blend_constants(&mut self, blend_constants: [f32; 4 as usize]) -> () {
        self.context.cmd_set_blend_constants(self, blend_constants)
    }
    #[doc(alias = "vkCmdSetDepthBounds")]
    pub fn cmd_set_depth_bounds(&mut self, min_depth_bounds: f32, max_depth_bounds: f32) -> () {
        self.context
            .cmd_set_depth_bounds(self, min_depth_bounds, max_depth_bounds)
    }
    #[doc(alias = "vkCmdSetStencilCompareMask")]
    pub fn cmd_set_stencil_compare_mask(&mut self, face_mask: StencilFaceFlags, compare_mask: u32) -> () {
        self.context.cmd_set_stencil_compare_mask(self, face_mask, compare_mask)
    }
    #[doc(alias = "vkCmdSetStencilWriteMask")]
    pub fn cmd_set_stencil_write_mask(&mut self, face_mask: StencilFaceFlags, write_mask: u32) -> () {
        self.context.cmd_set_stencil_write_mask(self, face_mask, write_mask)
    }
    #[doc(alias = "vkCmdSetStencilReference")]
    pub fn cmd_set_stencil_reference(&mut self, face_mask: StencilFaceFlags, reference: u32) -> () {
        self.context.cmd_set_stencil_reference(self, face_mask, reference)
    }
    #[doc(alias = "vkCmdBindDescriptorSets")]
    pub fn cmd_bind_descriptor_sets(
        &mut self,
        pipeline_bind_point: PipelineBindPoint,
        layout: PipelineLayout,
        first_set: u32,
        p_descriptor_sets: &[DescriptorSet],
        p_dynamic_offsets: &[u32],
    ) -> () {
        self.context.cmd_bind_descriptor_sets(
            self,
            pipeline_bind_point,
            layout,
            first_set,
            p_descriptor_sets,
            p_dynamic_offsets,
        )
    }
    #[doc(alias = "vkCmdBindIndexBuffer")]
    pub fn cmd_bind_index_buffer(&mut self, buffer: Buffer, offset: DeviceSize, index_type: IndexType) -> () {
        self.context.cmd_bind_index_buffer(self, buffer, offset, index_type)
    }
    #[doc(alias = "vkCmdBindVertexBuffers")]
    pub fn cmd_bind_vertex_buffers(
        &mut self,
        first_binding: u32,
        p_buffers: &[Buffer],
        p_offsets: &[DeviceSize],
    ) -> () {
        self.context
            .cmd_bind_vertex_buffers(self, first_binding, p_buffers, p_offsets)
    }
    #[doc(alias = "vkCmdDraw")]
    pub fn cmd_draw(&mut self, vertex_count: u32, instance_count: u32, first_vertex: u32, first_instance: u32) -> () {
        self.context
            .cmd_draw(self, vertex_count, instance_count, first_vertex, first_instance)
    }
    #[doc(alias = "vkCmdDrawIndexed")]
    pub fn cmd_draw_indexed(
        &mut self,
        index_count: u32,
        instance_count: u32,
        first_index: u32,
        vertex_offset: i32,
        first_instance: u32,
    ) -> () {
        self.context.cmd_draw_indexed(
            self,
            index_count,
            instance_count,
            first_index,
            vertex_offset,
            first_instance,
        )
    }
    #[cfg(feature = "VK_EXT_multi_draw")]
    #[doc(alias = "vkCmdDrawMultiEXT")]
    pub fn cmd_draw_multi_ext(
        &mut self,
        p_vertex_info: &[MultiDrawInfoEXT],
        instance_count: u32,
        first_instance: u32,
        stride: u32,
    ) -> () {
        self.context
            .cmd_draw_multi_ext(self, p_vertex_info, instance_count, first_instance, stride)
    }
    #[cfg(feature = "VK_EXT_multi_draw")]
    #[doc(alias = "vkCmdDrawMultiIndexedEXT")]
    pub fn cmd_draw_multi_indexed_ext(
        &mut self,
        p_index_info: &[MultiDrawIndexedInfoEXT],
        instance_count: u32,
        first_instance: u32,
        stride: u32,
        p_vertex_offset: &i32,
    ) -> () {
        self.context.cmd_draw_multi_indexed_ext(
            self,
            p_index_info,
            instance_count,
            first_instance,
            stride,
            p_vertex_offset,
        )
    }
    #[doc(alias = "vkCmdDrawIndirect")]
    pub fn cmd_draw_indirect(&mut self, buffer: Buffer, offset: DeviceSize, draw_count: u32, stride: u32) -> () {
        self.context.cmd_draw_indirect(self, buffer, offset, draw_count, stride)
    }
    #[doc(alias = "vkCmdDrawIndexedIndirect")]
    pub fn cmd_draw_indexed_indirect(
        &mut self,
        buffer: Buffer,
        offset: DeviceSize,
        draw_count: u32,
        stride: u32,
    ) -> () {
        self.context
            .cmd_draw_indexed_indirect(self, buffer, offset, draw_count, stride)
    }
    #[doc(alias = "vkCmdDispatch")]
    pub fn cmd_dispatch(&mut self, group_count_x: u32, group_count_y: u32, group_count_z: u32) -> () {
        self.context
            .cmd_dispatch(self, group_count_x, group_count_y, group_count_z)
    }
    #[doc(alias = "vkCmdDispatchIndirect")]
    pub fn cmd_dispatch_indirect(&mut self, buffer: Buffer, offset: DeviceSize) -> () {
        self.context.cmd_dispatch_indirect(self, buffer, offset)
    }
    #[cfg(feature = "VK_HUAWEI_subpass_shading")]
    #[doc(alias = "vkCmdSubpassShadingHUAWEI")]
    pub fn cmd_subpass_shading_huawei(&mut self) -> () {
        self.context.cmd_subpass_shading_huawei(self)
    }
    #[doc(alias = "vkCmdCopyBuffer")]
    pub fn cmd_copy_buffer(&mut self, src_buffer: Buffer, dst_buffer: Buffer, p_regions: &[BufferCopy]) -> () {
        self.context.cmd_copy_buffer(self, src_buffer, dst_buffer, p_regions)
    }
    #[doc(alias = "vkCmdCopyImage")]
    pub fn cmd_copy_image(
        &mut self,
        src_image: Image,
        src_image_layout: ImageLayout,
        dst_image: Image,
        dst_image_layout: ImageLayout,
        p_regions: &[ImageCopy],
    ) -> () {
        self.context.cmd_copy_image(
            self,
            src_image,
            src_image_layout,
            dst_image,
            dst_image_layout,
            p_regions,
        )
    }
    #[doc(alias = "vkCmdBlitImage")]
    pub fn cmd_blit_image(
        &mut self,
        src_image: Image,
        src_image_layout: ImageLayout,
        dst_image: Image,
        dst_image_layout: ImageLayout,
        p_regions: &[ImageBlit],
        filter: Filter,
    ) -> () {
        self.context.cmd_blit_image(
            self,
            src_image,
            src_image_layout,
            dst_image,
            dst_image_layout,
            p_regions,
            filter,
        )
    }
    #[doc(alias = "vkCmdCopyBufferToImage")]
    pub fn cmd_copy_buffer_to_image(
        &mut self,
        src_buffer: Buffer,
        dst_image: Image,
        dst_image_layout: ImageLayout,
        p_regions: &[BufferImageCopy],
    ) -> () {
        self.context
            .cmd_copy_buffer_to_image(self, src_buffer, dst_image, dst_image_layout, p_regions)
    }
    #[doc(alias = "vkCmdCopyImageToBuffer")]
    pub fn cmd_copy_image_to_buffer(
        &mut self,
        src_image: Image,
        src_image_layout: ImageLayout,
        dst_buffer: Buffer,
        p_regions: &[BufferImageCopy],
    ) -> () {
        self.context
            .cmd_copy_image_to_buffer(self, src_image, src_image_layout, dst_buffer, p_regions)
    }
    #[doc(alias = "vkCmdFillBuffer")]
    pub fn cmd_fill_buffer(&mut self, dst_buffer: Buffer, dst_offset: DeviceSize, size: DeviceSize, data: u32) -> () {
        self.context.cmd_fill_buffer(self, dst_buffer, dst_offset, size, data)
    }
    #[doc(alias = "vkCmdClearColorImage")]
    pub fn cmd_clear_color_image(
        &mut self,
        image: Image,
        image_layout: ImageLayout,
        p_color: &ClearColorValue,
        p_ranges: &[ImageSubresourceRange],
    ) -> () {
        self.context
            .cmd_clear_color_image(self, image, image_layout, p_color, p_ranges)
    }
    #[doc(alias = "vkCmdClearDepthStencilImage")]
    pub fn cmd_clear_depth_stencil_image(
        &mut self,
        image: Image,
        image_layout: ImageLayout,
        p_depth_stencil: &ClearDepthStencilValue,
        p_ranges: &[ImageSubresourceRange],
    ) -> () {
        self.context
            .cmd_clear_depth_stencil_image(self, image, image_layout, p_depth_stencil, p_ranges)
    }
    #[doc(alias = "vkCmdClearAttachments")]
    pub fn cmd_clear_attachments(&mut self, p_attachments: &[ClearAttachment], p_rects: &[ClearRect]) -> () {
        self.context.cmd_clear_attachments(self, p_attachments, p_rects)
    }
    #[doc(alias = "vkCmdResolveImage")]
    pub fn cmd_resolve_image(
        &mut self,
        src_image: Image,
        src_image_layout: ImageLayout,
        dst_image: Image,
        dst_image_layout: ImageLayout,
        p_regions: &[ImageResolve],
    ) -> () {
        self.context.cmd_resolve_image(
            self,
            src_image,
            src_image_layout,
            dst_image,
            dst_image_layout,
            p_regions,
        )
    }
    #[doc(alias = "vkCmdSetEvent")]
    pub fn cmd_set_event(&mut self, event: Event, stage_mask: PipelineStageFlags) -> () {
        self.context.cmd_set_event(self, event, stage_mask)
    }
    #[doc(alias = "vkCmdResetEvent")]
    pub fn cmd_reset_event(&mut self, event: Event, stage_mask: PipelineStageFlags) -> () {
        self.context.cmd_reset_event(self, event, stage_mask)
    }
    #[doc(alias = "vkCmdWaitEvents")]
    pub fn cmd_wait_events(
        &mut self,
        p_events: &[Event],
        src_stage_mask: PipelineStageFlags,
        dst_stage_mask: PipelineStageFlags,
        p_memory_barriers: &[MemoryBarrier],
        p_buffer_memory_barriers: &[BufferMemoryBarrier],
        p_image_memory_barriers: &[ImageMemoryBarrier],
    ) -> () {
        self.context.cmd_wait_events(
            self,
            p_events,
            src_stage_mask,
            dst_stage_mask,
            p_memory_barriers,
            p_buffer_memory_barriers,
            p_image_memory_barriers,
        )
    }
    #[doc(alias = "vkCmdPipelineBarrier")]
    pub fn cmd_pipeline_barrier(
        &mut self,
        src_stage_mask: PipelineStageFlags,
        dst_stage_mask: PipelineStageFlags,
        dependency_flags: DependencyFlags,
        p_memory_barriers: &[MemoryBarrier],
        p_buffer_memory_barriers: &[BufferMemoryBarrier],
        p_image_memory_barriers: &[ImageMemoryBarrier],
    ) -> () {
        self.context.cmd_pipeline_barrier(
            self,
            src_stage_mask,
            dst_stage_mask,
            dependency_flags,
            p_memory_barriers,
            p_buffer_memory_barriers,
            p_image_memory_barriers,
        )
    }
    #[doc(alias = "vkCmdBeginQuery")]
    pub fn cmd_begin_query(&mut self, query_pool: QueryPool, query: u32, flags: QueryControlFlags) -> () {
        self.context.cmd_begin_query(self, query_pool, query, flags)
    }
    #[doc(alias = "vkCmdEndQuery")]
    pub fn cmd_end_query(&mut self, query_pool: QueryPool, query: u32) -> () {
        self.context.cmd_end_query(self, query_pool, query)
    }
    #[cfg(feature = "VK_EXT_conditional_rendering")]
    #[doc(alias = "vkCmdBeginConditionalRenderingEXT")]
    pub fn cmd_begin_conditional_rendering_ext(
        &mut self,
        p_conditional_rendering_begin: &ConditionalRenderingBeginInfoEXT,
    ) -> () {
        self.context
            .cmd_begin_conditional_rendering_ext(self, p_conditional_rendering_begin)
    }
    #[cfg(feature = "VK_EXT_conditional_rendering")]
    #[doc(alias = "vkCmdEndConditionalRenderingEXT")]
    pub fn cmd_end_conditional_rendering_ext(&mut self) -> () {
        self.context.cmd_end_conditional_rendering_ext(self)
    }
    #[doc(alias = "vkCmdResetQueryPool")]
    pub fn cmd_reset_query_pool(&mut self, query_pool: QueryPool, first_query: u32, query_count: u32) -> () {
        self.context
            .cmd_reset_query_pool(self, query_pool, first_query, query_count)
    }
    #[doc(alias = "vkCmdWriteTimestamp")]
    pub fn cmd_write_timestamp(
        &mut self,
        pipeline_stage: PipelineStageFlagBits,
        query_pool: QueryPool,
        query: u32,
    ) -> () {
        self.context
            .cmd_write_timestamp(self, pipeline_stage, query_pool, query)
    }
    #[doc(alias = "vkCmdCopyQueryPoolResults")]
    pub fn cmd_copy_query_pool_results(
        &mut self,
        query_pool: QueryPool,
        first_query: u32,
        query_count: u32,
        dst_buffer: Buffer,
        dst_offset: DeviceSize,
        stride: DeviceSize,
        flags: QueryResultFlags,
    ) -> () {
        self.context.cmd_copy_query_pool_results(
            self,
            query_pool,
            first_query,
            query_count,
            dst_buffer,
            dst_offset,
            stride,
            flags,
        )
    }
    #[doc(alias = "vkCmdBeginRenderPass")]
    pub fn cmd_begin_render_pass(
        &mut self,
        p_render_pass_begin: &RenderPassBeginInfo,
        contents: SubpassContents,
    ) -> () {
        self.context.cmd_begin_render_pass(self, p_render_pass_begin, contents)
    }
    #[doc(alias = "vkCmdNextSubpass")]
    pub fn cmd_next_subpass(&mut self, contents: SubpassContents) -> () {
        self.context.cmd_next_subpass(self, contents)
    }
    #[doc(alias = "vkCmdEndRenderPass")]
    pub fn cmd_end_render_pass(&mut self) -> () {
        self.context.cmd_end_render_pass(self)
    }
    #[doc(alias = "vkCmdExecuteCommands")]
    pub fn cmd_execute_commands(&mut self, p_command_buffers: &[CommandBuffer]) -> () {
        self.context.cmd_execute_commands(self, p_command_buffers)
    }
    #[cfg(feature = "VK_EXT_debug_marker")]
    #[doc(alias = "vkCmdDebugMarkerBeginEXT")]
    pub fn cmd_debug_marker_begin_ext(&mut self, p_marker_info: &DebugMarkerMarkerInfoEXT) -> () {
        self.context.cmd_debug_marker_begin_ext(self, p_marker_info)
    }
    #[cfg(feature = "VK_EXT_debug_marker")]
    #[doc(alias = "vkCmdDebugMarkerEndEXT")]
    pub fn cmd_debug_marker_end_ext(&mut self) -> () {
        self.context.cmd_debug_marker_end_ext(self)
    }
    #[cfg(feature = "VK_EXT_debug_marker")]
    #[doc(alias = "vkCmdDebugMarkerInsertEXT")]
    pub fn cmd_debug_marker_insert_ext(&mut self, p_marker_info: &DebugMarkerMarkerInfoEXT) -> () {
        self.context.cmd_debug_marker_insert_ext(self, p_marker_info)
    }
    #[cfg(feature = "VK_NV_device_generated_commands")]
    #[doc(alias = "vkCmdExecuteGeneratedCommandsNV")]
    pub fn cmd_execute_generated_commands_nv(
        &mut self,
        is_preprocessed: Bool32,
        p_generated_commands_info: &GeneratedCommandsInfoNV,
    ) -> () {
        self.context
            .cmd_execute_generated_commands_nv(self, is_preprocessed, p_generated_commands_info)
    }
    #[cfg(feature = "VK_NV_device_generated_commands")]
    #[doc(alias = "vkCmdPreprocessGeneratedCommandsNV")]
    pub fn cmd_preprocess_generated_commands_nv(&mut self, p_generated_commands_info: &GeneratedCommandsInfoNV) -> () {
        self.context
            .cmd_preprocess_generated_commands_nv(self, p_generated_commands_info)
    }
    #[cfg(feature = "VK_NV_device_generated_commands")]
    #[doc(alias = "vkCmdBindPipelineShaderGroupNV")]
    pub fn cmd_bind_pipeline_shader_group_nv(
        &mut self,
        pipeline_bind_point: PipelineBindPoint,
        pipeline: Pipeline,
        group_index: u32,
    ) -> () {
        self.context
            .cmd_bind_pipeline_shader_group_nv(self, pipeline_bind_point, pipeline, group_index)
    }
    #[cfg(feature = "VK_KHR_push_descriptor")]
    #[doc(alias = "vkCmdPushDescriptorSetKHR")]
    pub fn cmd_push_descriptor_set_khr(
        &mut self,
        pipeline_bind_point: PipelineBindPoint,
        layout: PipelineLayout,
        set: u32,
        p_descriptor_writes: &[WriteDescriptorSet],
    ) -> () {
        self.context
            .cmd_push_descriptor_set_khr(self, pipeline_bind_point, layout, set, p_descriptor_writes)
    }
    #[doc(alias = "vkCmdSetDeviceMask")]
    pub fn cmd_set_device_mask(&mut self, device_mask: u32) -> () {
        self.context.cmd_set_device_mask(self, device_mask)
    }
    #[doc(alias = "vkCmdDispatchBase")]
    pub fn cmd_dispatch_base(
        &mut self,
        base_group_x: u32,
        base_group_y: u32,
        base_group_z: u32,
        group_count_x: u32,
        group_count_y: u32,
        group_count_z: u32,
    ) -> () {
        self.context.cmd_dispatch_base(
            self,
            base_group_x,
            base_group_y,
            base_group_z,
            group_count_x,
            group_count_y,
            group_count_z,
        )
    }
    #[cfg(feature = "VK_NV_clip_space_w_scaling")]
    #[doc(alias = "vkCmdSetViewportWScalingNV")]
    pub fn cmd_set_viewport_w_scaling_nv(
        &mut self,
        first_viewport: u32,
        p_viewport_w_scalings: &[ViewportWScalingNV],
    ) -> () {
        self.context
            .cmd_set_viewport_w_scaling_nv(self, first_viewport, p_viewport_w_scalings)
    }
    #[cfg(feature = "VK_EXT_discard_rectangles")]
    #[doc(alias = "vkCmdSetDiscardRectangleEXT")]
    pub fn cmd_set_discard_rectangle_ext(
        &mut self,
        first_discard_rectangle: u32,
        p_discard_rectangles: &[Rect2D],
    ) -> () {
        self.context
            .cmd_set_discard_rectangle_ext(self, first_discard_rectangle, p_discard_rectangles)
    }
    #[cfg(feature = "VK_EXT_sample_locations")]
    #[doc(alias = "vkCmdSetSampleLocationsEXT")]
    pub fn cmd_set_sample_locations_ext(&mut self, p_sample_locations_info: &SampleLocationsInfoEXT) -> () {
        self.context.cmd_set_sample_locations_ext(self, p_sample_locations_info)
    }
    #[cfg(feature = "VK_EXT_debug_utils")]
    #[doc(alias = "vkCmdBeginDebugUtilsLabelEXT")]
    pub fn cmd_begin_debug_utils_label_ext(&mut self, p_label_info: &DebugUtilsLabelEXT) -> () {
        self.context.cmd_begin_debug_utils_label_ext(self, p_label_info)
    }
    #[cfg(feature = "VK_EXT_debug_utils")]
    #[doc(alias = "vkCmdEndDebugUtilsLabelEXT")]
    pub fn cmd_end_debug_utils_label_ext(&mut self) -> () {
        self.context.cmd_end_debug_utils_label_ext(self)
    }
    #[cfg(feature = "VK_EXT_debug_utils")]
    #[doc(alias = "vkCmdInsertDebugUtilsLabelEXT")]
    pub fn cmd_insert_debug_utils_label_ext(&mut self, p_label_info: &DebugUtilsLabelEXT) -> () {
        self.context.cmd_insert_debug_utils_label_ext(self, p_label_info)
    }
    #[cfg(feature = "VK_AMD_buffer_marker")]
    #[doc(alias = "vkCmdWriteBufferMarkerAMD")]
    pub fn cmd_write_buffer_marker_amd(
        &mut self,
        pipeline_stage: PipelineStageFlagBits,
        dst_buffer: Buffer,
        dst_offset: DeviceSize,
        marker: u32,
    ) -> () {
        self.context
            .cmd_write_buffer_marker_amd(self, pipeline_stage, dst_buffer, dst_offset, marker)
    }
    #[cfg(feature = "VULKAN_1_2")]
    #[doc(alias = "vkCmdBeginRenderPass2")]
    pub fn cmd_begin_render_pass2(
        &mut self,
        p_render_pass_begin: &RenderPassBeginInfo,
        p_subpass_begin_info: &SubpassBeginInfo,
    ) -> () {
        self.context
            .cmd_begin_render_pass2(self, p_render_pass_begin, p_subpass_begin_info)
    }
    #[cfg(feature = "VULKAN_1_2")]
    #[doc(alias = "vkCmdNextSubpass2")]
    pub fn cmd_next_subpass2(
        &mut self,
        p_subpass_begin_info: &SubpassBeginInfo,
        p_subpass_end_info: &SubpassEndInfo,
    ) -> () {
        self.context
            .cmd_next_subpass2(self, p_subpass_begin_info, p_subpass_end_info)
    }
    #[cfg(feature = "VULKAN_1_2")]
    #[doc(alias = "vkCmdEndRenderPass2")]
    pub fn cmd_end_render_pass2(&mut self, p_subpass_end_info: &SubpassEndInfo) -> () {
        self.context.cmd_end_render_pass2(self, p_subpass_end_info)
    }
    #[cfg(feature = "VULKAN_1_2")]
    #[doc(alias = "vkCmdDrawIndirectCount")]
    pub fn cmd_draw_indirect_count(
        &mut self,
        buffer: Buffer,
        offset: DeviceSize,
        count_buffer: Buffer,
        count_buffer_offset: DeviceSize,
        max_draw_count: u32,
        stride: u32,
    ) -> () {
        self.context.cmd_draw_indirect_count(
            self,
            buffer,
            offset,
            count_buffer,
            count_buffer_offset,
            max_draw_count,
            stride,
        )
    }
    #[cfg(feature = "VULKAN_1_2")]
    #[doc(alias = "vkCmdDrawIndexedIndirectCount")]
    pub fn cmd_draw_indexed_indirect_count(
        &mut self,
        buffer: Buffer,
        offset: DeviceSize,
        count_buffer: Buffer,
        count_buffer_offset: DeviceSize,
        max_draw_count: u32,
        stride: u32,
    ) -> () {
        self.context.cmd_draw_indexed_indirect_count(
            self,
            buffer,
            offset,
            count_buffer,
            count_buffer_offset,
            max_draw_count,
            stride,
        )
    }
    #[cfg(feature = "VK_EXT_transform_feedback")]
    #[doc(alias = "vkCmdBindTransformFeedbackBuffersEXT")]
    pub fn cmd_bind_transform_feedback_buffers_ext(
        &mut self,
        first_binding: u32,
        p_buffers: &[Buffer],
        p_offsets: &[DeviceSize],
        p_sizes: &[DeviceSize],
    ) -> () {
        self.context
            .cmd_bind_transform_feedback_buffers_ext(self, first_binding, p_buffers, p_offsets, p_sizes)
    }
    #[cfg(feature = "VK_EXT_transform_feedback")]
    #[doc(alias = "vkCmdBeginTransformFeedbackEXT")]
    pub fn cmd_begin_transform_feedback_ext(
        &mut self,
        first_counter_buffer: u32,
        p_counter_buffers: &[Buffer],
        p_counter_buffer_offsets: &[DeviceSize],
    ) -> () {
        self.context.cmd_begin_transform_feedback_ext(
            self,
            first_counter_buffer,
            p_counter_buffers,
            p_counter_buffer_offsets,
        )
    }
    #[cfg(feature = "VK_EXT_transform_feedback")]
    #[doc(alias = "vkCmdEndTransformFeedbackEXT")]
    pub fn cmd_end_transform_feedback_ext(
        &mut self,
        first_counter_buffer: u32,
        p_counter_buffers: &[Buffer],
        p_counter_buffer_offsets: &[DeviceSize],
    ) -> () {
        self.context.cmd_end_transform_feedback_ext(
            self,
            first_counter_buffer,
            p_counter_buffers,
            p_counter_buffer_offsets,
        )
    }
    #[cfg(feature = "VK_EXT_transform_feedback")]
    #[doc(alias = "vkCmdBeginQueryIndexedEXT")]
    pub fn cmd_begin_query_indexed_ext(
        &mut self,
        query_pool: QueryPool,
        query: u32,
        flags: QueryControlFlags,
        index: u32,
    ) -> () {
        self.context
            .cmd_begin_query_indexed_ext(self, query_pool, query, flags, index)
    }
    #[cfg(feature = "VK_EXT_transform_feedback")]
    #[doc(alias = "vkCmdEndQueryIndexedEXT")]
    pub fn cmd_end_query_indexed_ext(&mut self, query_pool: QueryPool, query: u32, index: u32) -> () {
        self.context.cmd_end_query_indexed_ext(self, query_pool, query, index)
    }
    #[cfg(feature = "VK_EXT_transform_feedback")]
    #[doc(alias = "vkCmdDrawIndirectByteCountEXT")]
    pub fn cmd_draw_indirect_byte_count_ext(
        &mut self,
        instance_count: u32,
        first_instance: u32,
        counter_buffer: Buffer,
        counter_buffer_offset: DeviceSize,
        counter_offset: u32,
        vertex_stride: u32,
    ) -> () {
        self.context.cmd_draw_indirect_byte_count_ext(
            self,
            instance_count,
            first_instance,
            counter_buffer,
            counter_buffer_offset,
            counter_offset,
            vertex_stride,
        )
    }
    #[cfg(feature = "VK_NV_scissor_exclusive")]
    #[doc(alias = "vkCmdSetExclusiveScissorNV")]
    pub fn cmd_set_exclusive_scissor_nv(
        &mut self,
        first_exclusive_scissor: u32,
        p_exclusive_scissors: &[Rect2D],
    ) -> () {
        self.context
            .cmd_set_exclusive_scissor_nv(self, first_exclusive_scissor, p_exclusive_scissors)
    }
    #[cfg(feature = "VK_NV_shading_rate_image")]
    #[doc(alias = "vkCmdBindShadingRateImageNV")]
    pub fn cmd_bind_shading_rate_image_nv(&mut self, image_view: ImageView, image_layout: ImageLayout) -> () {
        self.context
            .cmd_bind_shading_rate_image_nv(self, image_view, image_layout)
    }
    #[cfg(feature = "VK_NV_shading_rate_image")]
    #[doc(alias = "vkCmdSetViewportShadingRatePaletteNV")]
    pub fn cmd_set_viewport_shading_rate_palette_nv(
        &mut self,
        first_viewport: u32,
        p_shading_rate_palettes: &[ShadingRatePaletteNV],
    ) -> () {
        self.context
            .cmd_set_viewport_shading_rate_palette_nv(self, first_viewport, p_shading_rate_palettes)
    }
    #[cfg(feature = "VK_NV_shading_rate_image")]
    #[doc(alias = "vkCmdSetCoarseSampleOrderNV")]
    pub fn cmd_set_coarse_sample_order_nv(
        &mut self,
        sample_order_type: CoarseSampleOrderTypeNV,
        p_custom_sample_orders: &[CoarseSampleOrderCustomNV],
    ) -> () {
        self.context
            .cmd_set_coarse_sample_order_nv(self, sample_order_type, p_custom_sample_orders)
    }
    #[cfg(feature = "VK_NV_mesh_shader")]
    #[doc(alias = "vkCmdDrawMeshTasksNV")]
    pub fn cmd_draw_mesh_tasks_nv(&mut self, task_count: u32, first_task: u32) -> () {
        self.context.cmd_draw_mesh_tasks_nv(self, task_count, first_task)
    }
    #[cfg(feature = "VK_NV_mesh_shader")]
    #[doc(alias = "vkCmdDrawMeshTasksIndirectNV")]
    pub fn cmd_draw_mesh_tasks_indirect_nv(
        &mut self,
        buffer: Buffer,
        offset: DeviceSize,
        draw_count: u32,
        stride: u32,
    ) -> () {
        self.context
            .cmd_draw_mesh_tasks_indirect_nv(self, buffer, offset, draw_count, stride)
    }
    #[cfg(feature = "VK_NV_mesh_shader")]
    #[doc(alias = "vkCmdDrawMeshTasksIndirectCountNV")]
    pub fn cmd_draw_mesh_tasks_indirect_count_nv(
        &mut self,
        buffer: Buffer,
        offset: DeviceSize,
        count_buffer: Buffer,
        count_buffer_offset: DeviceSize,
        max_draw_count: u32,
        stride: u32,
    ) -> () {
        self.context.cmd_draw_mesh_tasks_indirect_count_nv(
            self,
            buffer,
            offset,
            count_buffer,
            count_buffer_offset,
            max_draw_count,
            stride,
        )
    }
    #[cfg(feature = "VK_HUAWEI_invocation_mask")]
    #[doc(alias = "vkCmdBindInvocationMaskHUAWEI")]
    pub fn cmd_bind_invocation_mask_huawei(&mut self, image_view: ImageView, image_layout: ImageLayout) -> () {
        self.context
            .cmd_bind_invocation_mask_huawei(self, image_view, image_layout)
    }
    #[cfg(feature = "VK_NV_ray_tracing")]
    #[doc(alias = "vkCmdCopyAccelerationStructureNV")]
    pub fn cmd_copy_acceleration_structure_nv(
        &mut self,
        dst: AccelerationStructureNV,
        src: AccelerationStructureNV,
        mode: CopyAccelerationStructureModeKHR,
    ) -> () {
        self.context.cmd_copy_acceleration_structure_nv(self, dst, src, mode)
    }
    #[cfg(feature = "VK_KHR_acceleration_structure")]
    #[doc(alias = "vkCmdCopyAccelerationStructureKHR")]
    pub fn cmd_copy_acceleration_structure_khr(&mut self, p_info: &CopyAccelerationStructureInfoKHR) -> () {
        self.context.cmd_copy_acceleration_structure_khr(self, p_info)
    }
    #[cfg(feature = "VK_KHR_acceleration_structure")]
    #[doc(alias = "vkCmdCopyAccelerationStructureToMemoryKHR")]
    pub fn cmd_copy_acceleration_structure_to_memory_khr(
        &mut self,
        p_info: &CopyAccelerationStructureToMemoryInfoKHR,
    ) -> () {
        self.context.cmd_copy_acceleration_structure_to_memory_khr(self, p_info)
    }
    #[cfg(feature = "VK_KHR_acceleration_structure")]
    #[doc(alias = "vkCmdCopyMemoryToAccelerationStructureKHR")]
    pub fn cmd_copy_memory_to_acceleration_structure_khr(
        &mut self,
        p_info: &CopyMemoryToAccelerationStructureInfoKHR,
    ) -> () {
        self.context.cmd_copy_memory_to_acceleration_structure_khr(self, p_info)
    }
    #[cfg(feature = "VK_KHR_acceleration_structure")]
    #[doc(alias = "vkCmdWriteAccelerationStructuresPropertiesKHR")]
    pub fn cmd_write_acceleration_structures_properties_khr(
        &mut self,
        p_acceleration_structures: &[AccelerationStructureKHR],
        query_type: QueryType,
        query_pool: QueryPool,
        first_query: u32,
    ) -> () {
        self.context.cmd_write_acceleration_structures_properties_khr(
            self,
            p_acceleration_structures,
            query_type,
            query_pool,
            first_query,
        )
    }
    #[cfg(feature = "VK_NV_ray_tracing")]
    #[doc(alias = "vkCmdWriteAccelerationStructuresPropertiesNV")]
    pub fn cmd_write_acceleration_structures_properties_nv(
        &mut self,
        p_acceleration_structures: &[AccelerationStructureNV],
        query_type: QueryType,
        query_pool: QueryPool,
        first_query: u32,
    ) -> () {
        self.context.cmd_write_acceleration_structures_properties_nv(
            self,
            p_acceleration_structures,
            query_type,
            query_pool,
            first_query,
        )
    }
    #[cfg(feature = "VK_NV_ray_tracing")]
    #[doc(alias = "vkCmdBuildAccelerationStructureNV")]
    pub fn cmd_build_acceleration_structure_nv(
        &mut self,
        p_info: &AccelerationStructureInfoNV,
        instance_data: Buffer,
        instance_offset: DeviceSize,
        update: Bool32,
        dst: AccelerationStructureNV,
        src: AccelerationStructureNV,
        scratch: Buffer,
        scratch_offset: DeviceSize,
    ) -> () {
        self.context.cmd_build_acceleration_structure_nv(
            self,
            p_info,
            instance_data,
            instance_offset,
            update,
            dst,
            src,
            scratch,
            scratch_offset,
        )
    }
    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
    #[doc(alias = "vkCmdTraceRaysKHR")]
    pub fn cmd_trace_rays_khr(
        &mut self,
        p_raygen_shader_binding_table: &StridedDeviceAddressRegionKHR,
        p_miss_shader_binding_table: &StridedDeviceAddressRegionKHR,
        p_hit_shader_binding_table: &StridedDeviceAddressRegionKHR,
        p_callable_shader_binding_table: &StridedDeviceAddressRegionKHR,
        width: u32,
        height: u32,
        depth: u32,
    ) -> () {
        self.context.cmd_trace_rays_khr(
            self,
            p_raygen_shader_binding_table,
            p_miss_shader_binding_table,
            p_hit_shader_binding_table,
            p_callable_shader_binding_table,
            width,
            height,
            depth,
        )
    }
    #[cfg(feature = "VK_NV_ray_tracing")]
    #[doc(alias = "vkCmdTraceRaysNV")]
    pub fn cmd_trace_rays_nv(
        &mut self,
        raygen_shader_binding_table_buffer: Buffer,
        raygen_shader_binding_offset: DeviceSize,
        miss_shader_binding_table_buffer: Buffer,
        miss_shader_binding_offset: DeviceSize,
        miss_shader_binding_stride: DeviceSize,
        hit_shader_binding_table_buffer: Buffer,
        hit_shader_binding_offset: DeviceSize,
        hit_shader_binding_stride: DeviceSize,
        callable_shader_binding_table_buffer: Buffer,
        callable_shader_binding_offset: DeviceSize,
        callable_shader_binding_stride: DeviceSize,
        width: u32,
        height: u32,
        depth: u32,
    ) -> () {
        self.context.cmd_trace_rays_nv(
            self,
            raygen_shader_binding_table_buffer,
            raygen_shader_binding_offset,
            miss_shader_binding_table_buffer,
            miss_shader_binding_offset,
            miss_shader_binding_stride,
            hit_shader_binding_table_buffer,
            hit_shader_binding_offset,
            hit_shader_binding_stride,
            callable_shader_binding_table_buffer,
            callable_shader_binding_offset,
            callable_shader_binding_stride,
            width,
            height,
            depth,
        )
    }
    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
    #[doc(alias = "vkCmdTraceRaysIndirectKHR")]
    pub fn cmd_trace_rays_indirect_khr(
        &mut self,
        p_raygen_shader_binding_table: &StridedDeviceAddressRegionKHR,
        p_miss_shader_binding_table: &StridedDeviceAddressRegionKHR,
        p_hit_shader_binding_table: &StridedDeviceAddressRegionKHR,
        p_callable_shader_binding_table: &StridedDeviceAddressRegionKHR,
        indirect_device_address: DeviceAddress,
    ) -> () {
        self.context.cmd_trace_rays_indirect_khr(
            self,
            p_raygen_shader_binding_table,
            p_miss_shader_binding_table,
            p_hit_shader_binding_table,
            p_callable_shader_binding_table,
            indirect_device_address,
        )
    }
    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
    #[doc(alias = "vkCmdSetRayTracingPipelineStackSizeKHR")]
    pub fn cmd_set_ray_tracing_pipeline_stack_size_khr(&mut self, pipeline_stack_size: u32) -> () {
        self.context
            .cmd_set_ray_tracing_pipeline_stack_size_khr(self, pipeline_stack_size)
    }
    #[cfg(feature = "VK_INTEL_performance_query")]
    #[doc(alias = "vkCmdSetPerformanceMarkerINTEL")]
    pub fn cmd_set_performance_marker_intel(
        &mut self,
        p_marker_info: &PerformanceMarkerInfoINTEL,
    ) -> Result<(), Error> {
        self.context.cmd_set_performance_marker_intel(self, p_marker_info)
    }
    #[cfg(feature = "VK_INTEL_performance_query")]
    #[doc(alias = "vkCmdSetPerformanceStreamMarkerINTEL")]
    pub fn cmd_set_performance_stream_marker_intel(
        &mut self,
        p_marker_info: &PerformanceStreamMarkerInfoINTEL,
    ) -> Result<(), Error> {
        self.context
            .cmd_set_performance_stream_marker_intel(self, p_marker_info)
    }
    #[cfg(feature = "VK_INTEL_performance_query")]
    #[doc(alias = "vkCmdSetPerformanceOverrideINTEL")]
    pub fn cmd_set_performance_override_intel(
        &mut self,
        p_override_info: &PerformanceOverrideInfoINTEL,
    ) -> Result<(), Error> {
        self.context.cmd_set_performance_override_intel(self, p_override_info)
    }
    #[cfg(feature = "VK_EXT_line_rasterization")]
    #[doc(alias = "vkCmdSetLineStippleEXT")]
    pub fn cmd_set_line_stipple_ext(&mut self, line_stipple_factor: u32, line_stipple_pattern: u16) -> () {
        self.context
            .cmd_set_line_stipple_ext(self, line_stipple_factor, line_stipple_pattern)
    }
    #[cfg(feature = "VK_KHR_acceleration_structure")]
    #[doc(alias = "vkCmdBuildAccelerationStructuresKHR")]
    pub fn cmd_build_acceleration_structures_khr(
        &mut self,
        p_infos: &[AccelerationStructureBuildGeometryInfoKHR],
        pp_build_range_infos: &AccelerationStructureBuildRangeInfoKHR,
    ) -> () {
        self.context
            .cmd_build_acceleration_structures_khr(self, p_infos, pp_build_range_infos)
    }
    #[cfg(feature = "VK_KHR_acceleration_structure")]
    #[doc(alias = "vkCmdBuildAccelerationStructuresIndirectKHR")]
    pub fn cmd_build_acceleration_structures_indirect_khr(
        &mut self,
        p_infos: &[AccelerationStructureBuildGeometryInfoKHR],
        p_indirect_device_addresses: &[DeviceAddress],
        p_indirect_strides: &[u32],
        pp_max_primitive_counts: &u32,
    ) -> () {
        self.context.cmd_build_acceleration_structures_indirect_khr(
            self,
            p_infos,
            p_indirect_device_addresses,
            p_indirect_strides,
            pp_max_primitive_counts,
        )
    }
    #[cfg(feature = "VULKAN_1_3")]
    #[doc(alias = "vkCmdSetCullMode")]
    pub fn cmd_set_cull_mode(&mut self, cull_mode: CullModeFlags) -> () {
        self.context.cmd_set_cull_mode(self, cull_mode)
    }
    #[cfg(feature = "VULKAN_1_3")]
    #[doc(alias = "vkCmdSetFrontFace")]
    pub fn cmd_set_front_face(&mut self, front_face: FrontFace) -> () {
        self.context.cmd_set_front_face(self, front_face)
    }
    #[cfg(feature = "VULKAN_1_3")]
    #[doc(alias = "vkCmdSetPrimitiveTopology")]
    pub fn cmd_set_primitive_topology(&mut self, primitive_topology: PrimitiveTopology) -> () {
        self.context.cmd_set_primitive_topology(self, primitive_topology)
    }
    #[cfg(feature = "VULKAN_1_3")]
    #[doc(alias = "vkCmdSetViewportWithCount")]
    pub fn cmd_set_viewport_with_count(&mut self, p_viewports: &[Viewport]) -> () {
        self.context.cmd_set_viewport_with_count(self, p_viewports)
    }
    #[cfg(feature = "VULKAN_1_3")]
    #[doc(alias = "vkCmdSetScissorWithCount")]
    pub fn cmd_set_scissor_with_count(&mut self, p_scissors: &[Rect2D]) -> () {
        self.context.cmd_set_scissor_with_count(self, p_scissors)
    }
    #[cfg(feature = "VULKAN_1_3")]
    #[doc(alias = "vkCmdBindVertexBuffers2")]
    pub fn cmd_bind_vertex_buffers2(
        &mut self,
        first_binding: u32,
        p_buffers: &[Buffer],
        p_offsets: &[DeviceSize],
        p_sizes: &[DeviceSize],
        p_strides: &[DeviceSize],
    ) -> () {
        self.context
            .cmd_bind_vertex_buffers2(self, first_binding, p_buffers, p_offsets, p_sizes, p_strides)
    }
    #[cfg(feature = "VULKAN_1_3")]
    #[doc(alias = "vkCmdSetDepthTestEnable")]
    pub fn cmd_set_depth_test_enable(&mut self, depth_test_enable: Bool32) -> () {
        self.context.cmd_set_depth_test_enable(self, depth_test_enable)
    }
    #[cfg(feature = "VULKAN_1_3")]
    #[doc(alias = "vkCmdSetDepthWriteEnable")]
    pub fn cmd_set_depth_write_enable(&mut self, depth_write_enable: Bool32) -> () {
        self.context.cmd_set_depth_write_enable(self, depth_write_enable)
    }
    #[cfg(feature = "VULKAN_1_3")]
    #[doc(alias = "vkCmdSetDepthCompareOp")]
    pub fn cmd_set_depth_compare_op(&mut self, depth_compare_op: CompareOp) -> () {
        self.context.cmd_set_depth_compare_op(self, depth_compare_op)
    }
    #[cfg(feature = "VULKAN_1_3")]
    #[doc(alias = "vkCmdSetDepthBoundsTestEnable")]
    pub fn cmd_set_depth_bounds_test_enable(&mut self, depth_bounds_test_enable: Bool32) -> () {
        self.context
            .cmd_set_depth_bounds_test_enable(self, depth_bounds_test_enable)
    }
    #[cfg(feature = "VULKAN_1_3")]
    #[doc(alias = "vkCmdSetStencilTestEnable")]
    pub fn cmd_set_stencil_test_enable(&mut self, stencil_test_enable: Bool32) -> () {
        self.context.cmd_set_stencil_test_enable(self, stencil_test_enable)
    }
    #[cfg(feature = "VULKAN_1_3")]
    #[doc(alias = "vkCmdSetStencilOp")]
    pub fn cmd_set_stencil_op(
        &mut self,
        face_mask: StencilFaceFlags,
        fail_op: StencilOp,
        pass_op: StencilOp,
        depth_fail_op: StencilOp,
        compare_op: CompareOp,
    ) -> () {
        self.context
            .cmd_set_stencil_op(self, face_mask, fail_op, pass_op, depth_fail_op, compare_op)
    }
    #[cfg(feature = "VK_EXT_extended_dynamic_state2")]
    #[doc(alias = "vkCmdSetPatchControlPointsEXT")]
    pub fn cmd_set_patch_control_points_ext(&mut self, patch_control_points: u32) -> () {
        self.context
            .cmd_set_patch_control_points_ext(self, patch_control_points)
    }
    #[cfg(feature = "VULKAN_1_3")]
    #[doc(alias = "vkCmdSetRasterizerDiscardEnable")]
    pub fn cmd_set_rasterizer_discard_enable(&mut self, rasterizer_discard_enable: Bool32) -> () {
        self.context
            .cmd_set_rasterizer_discard_enable(self, rasterizer_discard_enable)
    }
    #[cfg(feature = "VULKAN_1_3")]
    #[doc(alias = "vkCmdSetDepthBiasEnable")]
    pub fn cmd_set_depth_bias_enable(&mut self, depth_bias_enable: Bool32) -> () {
        self.context.cmd_set_depth_bias_enable(self, depth_bias_enable)
    }
    #[cfg(feature = "VK_EXT_extended_dynamic_state2")]
    #[doc(alias = "vkCmdSetLogicOpEXT")]
    pub fn cmd_set_logic_op_ext(&mut self, logic_op: LogicOp) -> () {
        self.context.cmd_set_logic_op_ext(self, logic_op)
    }
    #[cfg(feature = "VULKAN_1_3")]
    #[doc(alias = "vkCmdSetPrimitiveRestartEnable")]
    pub fn cmd_set_primitive_restart_enable(&mut self, primitive_restart_enable: Bool32) -> () {
        self.context
            .cmd_set_primitive_restart_enable(self, primitive_restart_enable)
    }
    #[cfg(feature = "VULKAN_1_3")]
    #[doc(alias = "vkCmdCopyBuffer2")]
    pub fn cmd_copy_buffer2(&mut self, p_copy_buffer_info: &CopyBufferInfo2) -> () {
        self.context.cmd_copy_buffer2(self, p_copy_buffer_info)
    }
    #[cfg(feature = "VULKAN_1_3")]
    #[doc(alias = "vkCmdCopyImage2")]
    pub fn cmd_copy_image2(&mut self, p_copy_image_info: &CopyImageInfo2) -> () {
        self.context.cmd_copy_image2(self, p_copy_image_info)
    }
    #[cfg(feature = "VULKAN_1_3")]
    #[doc(alias = "vkCmdBlitImage2")]
    pub fn cmd_blit_image2(&mut self, p_blit_image_info: &BlitImageInfo2) -> () {
        self.context.cmd_blit_image2(self, p_blit_image_info)
    }
    #[cfg(feature = "VULKAN_1_3")]
    #[doc(alias = "vkCmdCopyBufferToImage2")]
    pub fn cmd_copy_buffer_to_image2(&mut self, p_copy_buffer_to_image_info: &CopyBufferToImageInfo2) -> () {
        self.context
            .cmd_copy_buffer_to_image2(self, p_copy_buffer_to_image_info)
    }
    #[cfg(feature = "VULKAN_1_3")]
    #[doc(alias = "vkCmdCopyImageToBuffer2")]
    pub fn cmd_copy_image_to_buffer2(&mut self, p_copy_image_to_buffer_info: &CopyImageToBufferInfo2) -> () {
        self.context
            .cmd_copy_image_to_buffer2(self, p_copy_image_to_buffer_info)
    }
    #[cfg(feature = "VULKAN_1_3")]
    #[doc(alias = "vkCmdResolveImage2")]
    pub fn cmd_resolve_image2(&mut self, p_resolve_image_info: &ResolveImageInfo2) -> () {
        self.context.cmd_resolve_image2(self, p_resolve_image_info)
    }
    #[cfg(feature = "VK_KHR_fragment_shading_rate")]
    #[doc(alias = "vkCmdSetFragmentShadingRateKHR")]
    pub fn cmd_set_fragment_shading_rate_khr(
        &mut self,
        p_fragment_size: &Extent2D,
        combiner_ops: [FragmentShadingRateCombinerOpKHR; 2 as usize],
    ) -> () {
        self.context
            .cmd_set_fragment_shading_rate_khr(self, p_fragment_size, combiner_ops)
    }
    #[cfg(feature = "VK_NV_fragment_shading_rate_enums")]
    #[doc(alias = "vkCmdSetFragmentShadingRateEnumNV")]
    pub fn cmd_set_fragment_shading_rate_enum_nv(
        &mut self,
        shading_rate: FragmentShadingRateNV,
        combiner_ops: [FragmentShadingRateCombinerOpKHR; 2 as usize],
    ) -> () {
        self.context
            .cmd_set_fragment_shading_rate_enum_nv(self, shading_rate, combiner_ops)
    }
    #[cfg(feature = "VK_EXT_vertex_input_dynamic_state")]
    #[doc(alias = "vkCmdSetVertexInputEXT")]
    pub fn cmd_set_vertex_input_ext(
        &mut self,
        p_vertex_binding_descriptions: &[VertexInputBindingDescription2EXT],
        p_vertex_attribute_descriptions: &[VertexInputAttributeDescription2EXT],
    ) -> () {
        self.context
            .cmd_set_vertex_input_ext(self, p_vertex_binding_descriptions, p_vertex_attribute_descriptions)
    }
    #[cfg(feature = "VK_EXT_color_write_enable")]
    #[doc(alias = "vkCmdSetColorWriteEnableEXT")]
    pub fn cmd_set_color_write_enable_ext(&mut self, p_color_write_enables: &[Bool32]) -> () {
        self.context.cmd_set_color_write_enable_ext(self, p_color_write_enables)
    }
    #[cfg(feature = "VULKAN_1_3")]
    #[doc(alias = "vkCmdSetEvent2")]
    pub fn cmd_set_event2(&mut self, event: Event, p_dependency_info: &DependencyInfo) -> () {
        self.context.cmd_set_event2(self, event, p_dependency_info)
    }
    #[cfg(feature = "VULKAN_1_3")]
    #[doc(alias = "vkCmdResetEvent2")]
    pub fn cmd_reset_event2(&mut self, event: Event, stage_mask: PipelineStageFlags2) -> () {
        self.context.cmd_reset_event2(self, event, stage_mask)
    }
    #[cfg(feature = "VULKAN_1_3")]
    #[doc(alias = "vkCmdWaitEvents2")]
    pub fn cmd_wait_events2(&mut self, p_events: &[Event], p_dependency_infos: &[DependencyInfo]) -> () {
        self.context.cmd_wait_events2(self, p_events, p_dependency_infos)
    }
    #[cfg(feature = "VULKAN_1_3")]
    #[doc(alias = "vkCmdPipelineBarrier2")]
    pub fn cmd_pipeline_barrier2(&mut self, p_dependency_info: &DependencyInfo) -> () {
        self.context.cmd_pipeline_barrier2(self, p_dependency_info)
    }
    #[cfg(feature = "VULKAN_1_3")]
    #[doc(alias = "vkCmdWriteTimestamp2")]
    pub fn cmd_write_timestamp2(&mut self, stage: PipelineStageFlags2, query_pool: QueryPool, query: u32) -> () {
        self.context.cmd_write_timestamp2(self, stage, query_pool, query)
    }
    #[cfg(feature = "VK_KHR_synchronization2")]
    #[doc(alias = "vkCmdWriteBufferMarker2AMD")]
    pub fn cmd_write_buffer_marker2_amd(
        &mut self,
        stage: PipelineStageFlags2,
        dst_buffer: Buffer,
        dst_offset: DeviceSize,
        marker: u32,
    ) -> () {
        self.context
            .cmd_write_buffer_marker2_amd(self, stage, dst_buffer, dst_offset, marker)
    }
    #[cfg(feature = "VK_KHR_video_decode_queue")]
    #[doc(alias = "vkCmdDecodeVideoKHR")]
    pub fn cmd_decode_video_khr(&self, p_frame_info: &VideoDecodeInfoKHR) -> () {
        self.context.cmd_decode_video_khr(self, p_frame_info)
    }
    #[cfg(feature = "VK_KHR_video_queue")]
    #[doc(alias = "vkCmdBeginVideoCodingKHR")]
    pub fn cmd_begin_video_coding_khr(&self, p_begin_info: &VideoBeginCodingInfoKHR) -> () {
        self.context.cmd_begin_video_coding_khr(self, p_begin_info)
    }
    #[cfg(feature = "VK_KHR_video_queue")]
    #[doc(alias = "vkCmdControlVideoCodingKHR")]
    pub fn cmd_control_video_coding_khr(&self, p_coding_control_info: &VideoCodingControlInfoKHR) -> () {
        self.context.cmd_control_video_coding_khr(self, p_coding_control_info)
    }
    #[cfg(feature = "VK_KHR_video_queue")]
    #[doc(alias = "vkCmdEndVideoCodingKHR")]
    pub fn cmd_end_video_coding_khr(&self, p_end_coding_info: &VideoEndCodingInfoKHR) -> () {
        self.context.cmd_end_video_coding_khr(self, p_end_coding_info)
    }
    #[cfg(feature = "VK_KHR_video_encode_queue")]
    #[doc(alias = "vkCmdEncodeVideoKHR")]
    pub fn cmd_encode_video_khr(&self, p_encode_info: &VideoEncodeInfoKHR) -> () {
        self.context.cmd_encode_video_khr(self, p_encode_info)
    }
    #[cfg(feature = "VULKAN_1_3")]
    #[doc(alias = "vkCmdBeginRendering")]
    pub fn cmd_begin_rendering(&mut self, p_rendering_info: &RenderingInfo) -> () {
        self.context.cmd_begin_rendering(self, p_rendering_info)
    }
    #[cfg(feature = "VULKAN_1_3")]
    #[doc(alias = "vkCmdEndRendering")]
    pub fn cmd_end_rendering(&mut self) -> () {
        self.context.cmd_end_rendering(self)
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for CommandBuffer {
    type LowLevel = crate::native::vulkan1_0::CommandBuffer;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *context.command_buffer().get(&self.id).expect("unknwon handle").handle()
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for CommandBuffer {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        let object_id = ObjectId::random();
        context.command_buffer().insert(object_id, Container::new(value));
        Self {
            context: context.clone(),
            id: object_id,
        }
    }
}
#[doc(alias = "VkDeviceMemory")]
#[derive(Debug)]
pub struct DeviceMemory {
    context: Arc<Context>,
    id: ObjectId,
}
impl Clone for DeviceMemory {
    fn clone(&self) -> Self {
        self.context.clone_device_memory(self.id);
        Self {
            context: Arc::clone(&self.context),
            id: self.id,
        }
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for DeviceMemory {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.id.serialize(serializer)
    }
}
impl<'de> Deserialize<'de> for DeviceMemory {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let id = ObjectId::deserialize(deserializer)?;
        crate::context::CONTEXT.with(|context| {
            let borrow = context.borrow();
            let context = borrow.as_ref().expect("Context not set.");
            Ok(Self {
                context: Arc::clone(context),
                id,
            })
        })
    }
}
impl Drop for DeviceMemory {
    fn drop(&mut self) {
        if !std::thread::panicking() {
            self.context.drop_device_memory(&self.id);
        }
    }
}
impl PartialEq for DeviceMemory {
    fn eq(&self, other: &Self) -> bool {
        self.id == other.id
    }
}
impl DeviceMemory {
    ///Creates a new instance of this handle from its core components.
    pub(crate) const unsafe fn new(context: Arc<Context>, id: ObjectId) -> Self {
        Self { context, id }
    }
    ///Gets the object id
    pub fn id(&self) -> &ObjectId {
        &self.id
    }
    ///Gets a reference to the context
    pub fn context(&self) -> &Context {
        &self.context
    }
    ///Gets a reference to the context wrapped in an [`Arc`]
    pub fn arc_context(&self) -> &Arc<Context> {
        &self.context
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for DeviceMemory {
    type LowLevel = crate::native::vulkan1_0::DeviceMemory;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *context.device_memory().get(&self.id).expect("unknwon handle").handle()
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for DeviceMemory {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        let object_id = ObjectId::random();
        context.device_memory().insert(object_id, Container::new(value));
        Self {
            context: context.clone(),
            id: object_id,
        }
    }
}
#[doc(alias = "VkCommandPool")]
#[derive(Debug)]
pub struct CommandPool {
    context: Arc<Context>,
    id: ObjectId,
}
impl Clone for CommandPool {
    fn clone(&self) -> Self {
        self.context.clone_command_pool(self.id);
        Self {
            context: Arc::clone(&self.context),
            id: self.id,
        }
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for CommandPool {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.id.serialize(serializer)
    }
}
impl<'de> Deserialize<'de> for CommandPool {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let id = ObjectId::deserialize(deserializer)?;
        crate::context::CONTEXT.with(|context| {
            let borrow = context.borrow();
            let context = borrow.as_ref().expect("Context not set.");
            Ok(Self {
                context: Arc::clone(context),
                id,
            })
        })
    }
}
impl Drop for CommandPool {
    fn drop(&mut self) {
        if !std::thread::panicking() {
            self.context.drop_command_pool(&self.id);
        }
    }
}
impl PartialEq for CommandPool {
    fn eq(&self, other: &Self) -> bool {
        self.id == other.id
    }
}
impl CommandPool {
    ///Creates a new instance of this handle from its core components.
    pub(crate) const unsafe fn new(context: Arc<Context>, id: ObjectId) -> Self {
        Self { context, id }
    }
    ///Gets the object id
    pub fn id(&self) -> &ObjectId {
        &self.id
    }
    ///Gets a reference to the context
    pub fn context(&self) -> &Context {
        &self.context
    }
    ///Gets a reference to the context wrapped in an [`Arc`]
    pub fn arc_context(&self) -> &Arc<Context> {
        &self.context
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for CommandPool {
    type LowLevel = crate::native::vulkan1_0::CommandPool;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *context.command_pool().get(&self.id).expect("unknwon handle").handle()
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for CommandPool {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        let object_id = ObjectId::random();
        context.command_pool().insert(object_id, Container::new(value));
        Self {
            context: context.clone(),
            id: object_id,
        }
    }
}
#[doc(alias = "VkBuffer")]
#[derive(Debug)]
pub struct Buffer {
    context: Arc<Context>,
    id: ObjectId,
}
impl Clone for Buffer {
    fn clone(&self) -> Self {
        self.context.clone_buffer(self.id);
        Self {
            context: Arc::clone(&self.context),
            id: self.id,
        }
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for Buffer {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.id.serialize(serializer)
    }
}
impl<'de> Deserialize<'de> for Buffer {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let id = ObjectId::deserialize(deserializer)?;
        crate::context::CONTEXT.with(|context| {
            let borrow = context.borrow();
            let context = borrow.as_ref().expect("Context not set.");
            Ok(Self {
                context: Arc::clone(context),
                id,
            })
        })
    }
}
impl Drop for Buffer {
    fn drop(&mut self) {
        if !std::thread::panicking() {
            self.context.drop_buffer(&self.id);
        }
    }
}
impl PartialEq for Buffer {
    fn eq(&self, other: &Self) -> bool {
        self.id == other.id
    }
}
impl Buffer {
    ///Creates a new instance of this handle from its core components.
    pub(crate) const unsafe fn new(context: Arc<Context>, id: ObjectId) -> Self {
        Self { context, id }
    }
    ///Gets the object id
    pub fn id(&self) -> &ObjectId {
        &self.id
    }
    ///Gets a reference to the context
    pub fn context(&self) -> &Context {
        &self.context
    }
    ///Gets a reference to the context wrapped in an [`Arc`]
    pub fn arc_context(&self) -> &Arc<Context> {
        &self.context
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for Buffer {
    type LowLevel = crate::native::vulkan1_0::Buffer;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *context.buffer().get(&self.id).expect("unknwon handle").handle()
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for Buffer {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        let object_id = ObjectId::random();
        context.buffer().insert(object_id, Container::new(value));
        Self {
            context: context.clone(),
            id: object_id,
        }
    }
}
#[doc(alias = "VkBufferView")]
#[derive(Debug)]
pub struct BufferView {
    context: Arc<Context>,
    id: ObjectId,
}
impl Clone for BufferView {
    fn clone(&self) -> Self {
        self.context.clone_buffer_view(self.id);
        Self {
            context: Arc::clone(&self.context),
            id: self.id,
        }
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for BufferView {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.id.serialize(serializer)
    }
}
impl<'de> Deserialize<'de> for BufferView {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let id = ObjectId::deserialize(deserializer)?;
        crate::context::CONTEXT.with(|context| {
            let borrow = context.borrow();
            let context = borrow.as_ref().expect("Context not set.");
            Ok(Self {
                context: Arc::clone(context),
                id,
            })
        })
    }
}
impl Drop for BufferView {
    fn drop(&mut self) {
        if !std::thread::panicking() {
            self.context.drop_buffer_view(&self.id);
        }
    }
}
impl PartialEq for BufferView {
    fn eq(&self, other: &Self) -> bool {
        self.id == other.id
    }
}
impl BufferView {
    ///Creates a new instance of this handle from its core components.
    pub(crate) const unsafe fn new(context: Arc<Context>, id: ObjectId) -> Self {
        Self { context, id }
    }
    ///Gets the object id
    pub fn id(&self) -> &ObjectId {
        &self.id
    }
    ///Gets a reference to the context
    pub fn context(&self) -> &Context {
        &self.context
    }
    ///Gets a reference to the context wrapped in an [`Arc`]
    pub fn arc_context(&self) -> &Arc<Context> {
        &self.context
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for BufferView {
    type LowLevel = crate::native::vulkan1_0::BufferView;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *context.buffer_view().get(&self.id).expect("unknwon handle").handle()
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for BufferView {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        let object_id = ObjectId::random();
        context.buffer_view().insert(object_id, Container::new(value));
        Self {
            context: context.clone(),
            id: object_id,
        }
    }
}
#[doc(alias = "VkImage")]
#[derive(Debug)]
pub struct Image {
    context: Arc<Context>,
    id: ObjectId,
}
impl Clone for Image {
    fn clone(&self) -> Self {
        self.context.clone_image(self.id);
        Self {
            context: Arc::clone(&self.context),
            id: self.id,
        }
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for Image {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.id.serialize(serializer)
    }
}
impl<'de> Deserialize<'de> for Image {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let id = ObjectId::deserialize(deserializer)?;
        crate::context::CONTEXT.with(|context| {
            let borrow = context.borrow();
            let context = borrow.as_ref().expect("Context not set.");
            Ok(Self {
                context: Arc::clone(context),
                id,
            })
        })
    }
}
impl Drop for Image {
    fn drop(&mut self) {
        if !std::thread::panicking() {
            self.context.drop_image(&self.id);
        }
    }
}
impl PartialEq for Image {
    fn eq(&self, other: &Self) -> bool {
        self.id == other.id
    }
}
impl Image {
    ///Creates a new instance of this handle from its core components.
    pub(crate) const unsafe fn new(context: Arc<Context>, id: ObjectId) -> Self {
        Self { context, id }
    }
    ///Gets the object id
    pub fn id(&self) -> &ObjectId {
        &self.id
    }
    ///Gets a reference to the context
    pub fn context(&self) -> &Context {
        &self.context
    }
    ///Gets a reference to the context wrapped in an [`Arc`]
    pub fn arc_context(&self) -> &Arc<Context> {
        &self.context
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for Image {
    type LowLevel = crate::native::vulkan1_0::Image;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *context.image().get(&self.id).expect("unknwon handle").handle()
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for Image {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        let object_id = ObjectId::random();
        context.image().insert(object_id, Container::new(value));
        Self {
            context: context.clone(),
            id: object_id,
        }
    }
}
#[doc(alias = "VkImageView")]
#[derive(Debug)]
pub struct ImageView {
    context: Arc<Context>,
    id: ObjectId,
}
impl Clone for ImageView {
    fn clone(&self) -> Self {
        self.context.clone_image_view(self.id);
        Self {
            context: Arc::clone(&self.context),
            id: self.id,
        }
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for ImageView {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.id.serialize(serializer)
    }
}
impl<'de> Deserialize<'de> for ImageView {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let id = ObjectId::deserialize(deserializer)?;
        crate::context::CONTEXT.with(|context| {
            let borrow = context.borrow();
            let context = borrow.as_ref().expect("Context not set.");
            Ok(Self {
                context: Arc::clone(context),
                id,
            })
        })
    }
}
impl Drop for ImageView {
    fn drop(&mut self) {
        if !std::thread::panicking() {
            self.context.drop_image_view(&self.id);
        }
    }
}
impl PartialEq for ImageView {
    fn eq(&self, other: &Self) -> bool {
        self.id == other.id
    }
}
impl ImageView {
    ///Creates a new instance of this handle from its core components.
    pub(crate) const unsafe fn new(context: Arc<Context>, id: ObjectId) -> Self {
        Self { context, id }
    }
    ///Gets the object id
    pub fn id(&self) -> &ObjectId {
        &self.id
    }
    ///Gets a reference to the context
    pub fn context(&self) -> &Context {
        &self.context
    }
    ///Gets a reference to the context wrapped in an [`Arc`]
    pub fn arc_context(&self) -> &Arc<Context> {
        &self.context
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for ImageView {
    type LowLevel = crate::native::vulkan1_0::ImageView;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *context.image_view().get(&self.id).expect("unknwon handle").handle()
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for ImageView {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        let object_id = ObjectId::random();
        context.image_view().insert(object_id, Container::new(value));
        Self {
            context: context.clone(),
            id: object_id,
        }
    }
}
#[doc(alias = "VkShaderModule")]
#[derive(Debug)]
pub struct ShaderModule {
    context: Arc<Context>,
    id: ObjectId,
}
impl Clone for ShaderModule {
    fn clone(&self) -> Self {
        self.context.clone_shader_module(self.id);
        Self {
            context: Arc::clone(&self.context),
            id: self.id,
        }
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for ShaderModule {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.id.serialize(serializer)
    }
}
impl<'de> Deserialize<'de> for ShaderModule {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let id = ObjectId::deserialize(deserializer)?;
        crate::context::CONTEXT.with(|context| {
            let borrow = context.borrow();
            let context = borrow.as_ref().expect("Context not set.");
            Ok(Self {
                context: Arc::clone(context),
                id,
            })
        })
    }
}
impl Drop for ShaderModule {
    fn drop(&mut self) {
        if !std::thread::panicking() {
            self.context.drop_shader_module(&self.id);
        }
    }
}
impl PartialEq for ShaderModule {
    fn eq(&self, other: &Self) -> bool {
        self.id == other.id
    }
}
impl ShaderModule {
    ///Creates a new instance of this handle from its core components.
    pub(crate) const unsafe fn new(context: Arc<Context>, id: ObjectId) -> Self {
        Self { context, id }
    }
    ///Gets the object id
    pub fn id(&self) -> &ObjectId {
        &self.id
    }
    ///Gets a reference to the context
    pub fn context(&self) -> &Context {
        &self.context
    }
    ///Gets a reference to the context wrapped in an [`Arc`]
    pub fn arc_context(&self) -> &Arc<Context> {
        &self.context
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for ShaderModule {
    type LowLevel = crate::native::vulkan1_0::ShaderModule;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *context.shader_module().get(&self.id).expect("unknwon handle").handle()
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for ShaderModule {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        let object_id = ObjectId::random();
        context.shader_module().insert(object_id, Container::new(value));
        Self {
            context: context.clone(),
            id: object_id,
        }
    }
}
#[doc(alias = "VkPipeline")]
#[derive(Debug)]
pub struct Pipeline {
    context: Arc<Context>,
    id: ObjectId,
}
impl Clone for Pipeline {
    fn clone(&self) -> Self {
        self.context.clone_pipeline(self.id);
        Self {
            context: Arc::clone(&self.context),
            id: self.id,
        }
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for Pipeline {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.id.serialize(serializer)
    }
}
impl<'de> Deserialize<'de> for Pipeline {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let id = ObjectId::deserialize(deserializer)?;
        crate::context::CONTEXT.with(|context| {
            let borrow = context.borrow();
            let context = borrow.as_ref().expect("Context not set.");
            Ok(Self {
                context: Arc::clone(context),
                id,
            })
        })
    }
}
impl Drop for Pipeline {
    fn drop(&mut self) {
        if !std::thread::panicking() {
            self.context.drop_pipeline(&self.id);
        }
    }
}
impl PartialEq for Pipeline {
    fn eq(&self, other: &Self) -> bool {
        self.id == other.id
    }
}
impl Pipeline {
    ///Creates a new instance of this handle from its core components.
    pub(crate) const unsafe fn new(context: Arc<Context>, id: ObjectId) -> Self {
        Self { context, id }
    }
    ///Gets the object id
    pub fn id(&self) -> &ObjectId {
        &self.id
    }
    ///Gets a reference to the context
    pub fn context(&self) -> &Context {
        &self.context
    }
    ///Gets a reference to the context wrapped in an [`Arc`]
    pub fn arc_context(&self) -> &Arc<Context> {
        &self.context
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for Pipeline {
    type LowLevel = crate::native::vulkan1_0::Pipeline;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *context.pipeline().get(&self.id).expect("unknwon handle").handle()
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for Pipeline {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        let object_id = ObjectId::random();
        context.pipeline().insert(object_id, Container::new(value));
        Self {
            context: context.clone(),
            id: object_id,
        }
    }
}
#[doc(alias = "VkPipelineLayout")]
#[derive(Debug)]
pub struct PipelineLayout {
    context: Arc<Context>,
    id: ObjectId,
}
impl Clone for PipelineLayout {
    fn clone(&self) -> Self {
        self.context.clone_pipeline_layout(self.id);
        Self {
            context: Arc::clone(&self.context),
            id: self.id,
        }
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for PipelineLayout {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.id.serialize(serializer)
    }
}
impl<'de> Deserialize<'de> for PipelineLayout {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let id = ObjectId::deserialize(deserializer)?;
        crate::context::CONTEXT.with(|context| {
            let borrow = context.borrow();
            let context = borrow.as_ref().expect("Context not set.");
            Ok(Self {
                context: Arc::clone(context),
                id,
            })
        })
    }
}
impl Drop for PipelineLayout {
    fn drop(&mut self) {
        if !std::thread::panicking() {
            self.context.drop_pipeline_layout(&self.id);
        }
    }
}
impl PartialEq for PipelineLayout {
    fn eq(&self, other: &Self) -> bool {
        self.id == other.id
    }
}
impl PipelineLayout {
    ///Creates a new instance of this handle from its core components.
    pub(crate) const unsafe fn new(context: Arc<Context>, id: ObjectId) -> Self {
        Self { context, id }
    }
    ///Gets the object id
    pub fn id(&self) -> &ObjectId {
        &self.id
    }
    ///Gets a reference to the context
    pub fn context(&self) -> &Context {
        &self.context
    }
    ///Gets a reference to the context wrapped in an [`Arc`]
    pub fn arc_context(&self) -> &Arc<Context> {
        &self.context
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for PipelineLayout {
    type LowLevel = crate::native::vulkan1_0::PipelineLayout;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *context
            .pipeline_layout()
            .get(&self.id)
            .expect("unknwon handle")
            .handle()
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for PipelineLayout {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        let object_id = ObjectId::random();
        context.pipeline_layout().insert(object_id, Container::new(value));
        Self {
            context: context.clone(),
            id: object_id,
        }
    }
}
#[doc(alias = "VkSampler")]
#[derive(Debug)]
pub struct Sampler {
    context: Arc<Context>,
    id: ObjectId,
}
impl Clone for Sampler {
    fn clone(&self) -> Self {
        self.context.clone_sampler(self.id);
        Self {
            context: Arc::clone(&self.context),
            id: self.id,
        }
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for Sampler {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.id.serialize(serializer)
    }
}
impl<'de> Deserialize<'de> for Sampler {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let id = ObjectId::deserialize(deserializer)?;
        crate::context::CONTEXT.with(|context| {
            let borrow = context.borrow();
            let context = borrow.as_ref().expect("Context not set.");
            Ok(Self {
                context: Arc::clone(context),
                id,
            })
        })
    }
}
impl Drop for Sampler {
    fn drop(&mut self) {
        if !std::thread::panicking() {
            self.context.drop_sampler(&self.id);
        }
    }
}
impl PartialEq for Sampler {
    fn eq(&self, other: &Self) -> bool {
        self.id == other.id
    }
}
impl Sampler {
    ///Creates a new instance of this handle from its core components.
    pub(crate) const unsafe fn new(context: Arc<Context>, id: ObjectId) -> Self {
        Self { context, id }
    }
    ///Gets the object id
    pub fn id(&self) -> &ObjectId {
        &self.id
    }
    ///Gets a reference to the context
    pub fn context(&self) -> &Context {
        &self.context
    }
    ///Gets a reference to the context wrapped in an [`Arc`]
    pub fn arc_context(&self) -> &Arc<Context> {
        &self.context
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for Sampler {
    type LowLevel = crate::native::vulkan1_0::Sampler;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *context.sampler().get(&self.id).expect("unknwon handle").handle()
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for Sampler {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        let object_id = ObjectId::random();
        context.sampler().insert(object_id, Container::new(value));
        Self {
            context: context.clone(),
            id: object_id,
        }
    }
}
#[doc(alias = "VkDescriptorSet")]
#[derive(Debug)]
pub struct DescriptorSet {
    context: Arc<Context>,
    id: ObjectId,
}
impl Clone for DescriptorSet {
    fn clone(&self) -> Self {
        self.context.clone_descriptor_set(self.id);
        Self {
            context: Arc::clone(&self.context),
            id: self.id,
        }
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for DescriptorSet {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.id.serialize(serializer)
    }
}
impl<'de> Deserialize<'de> for DescriptorSet {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let id = ObjectId::deserialize(deserializer)?;
        crate::context::CONTEXT.with(|context| {
            let borrow = context.borrow();
            let context = borrow.as_ref().expect("Context not set.");
            Ok(Self {
                context: Arc::clone(context),
                id,
            })
        })
    }
}
impl Drop for DescriptorSet {
    fn drop(&mut self) {
        if !std::thread::panicking() {
            self.context.drop_descriptor_set(&self.id);
        }
    }
}
impl PartialEq for DescriptorSet {
    fn eq(&self, other: &Self) -> bool {
        self.id == other.id
    }
}
impl DescriptorSet {
    ///Creates a new instance of this handle from its core components.
    pub(crate) const unsafe fn new(context: Arc<Context>, id: ObjectId) -> Self {
        Self { context, id }
    }
    ///Gets the object id
    pub fn id(&self) -> &ObjectId {
        &self.id
    }
    ///Gets a reference to the context
    pub fn context(&self) -> &Context {
        &self.context
    }
    ///Gets a reference to the context wrapped in an [`Arc`]
    pub fn arc_context(&self) -> &Arc<Context> {
        &self.context
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for DescriptorSet {
    type LowLevel = crate::native::vulkan1_0::DescriptorSet;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *context.descriptor_set().get(&self.id).expect("unknwon handle").handle()
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for DescriptorSet {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        let object_id = ObjectId::random();
        context.descriptor_set().insert(object_id, Container::new(value));
        Self {
            context: context.clone(),
            id: object_id,
        }
    }
}
#[doc(alias = "VkDescriptorSetLayout")]
#[derive(Debug)]
pub struct DescriptorSetLayout {
    context: Arc<Context>,
    id: ObjectId,
}
impl Clone for DescriptorSetLayout {
    fn clone(&self) -> Self {
        self.context.clone_descriptor_set_layout(self.id);
        Self {
            context: Arc::clone(&self.context),
            id: self.id,
        }
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for DescriptorSetLayout {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.id.serialize(serializer)
    }
}
impl<'de> Deserialize<'de> for DescriptorSetLayout {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let id = ObjectId::deserialize(deserializer)?;
        crate::context::CONTEXT.with(|context| {
            let borrow = context.borrow();
            let context = borrow.as_ref().expect("Context not set.");
            Ok(Self {
                context: Arc::clone(context),
                id,
            })
        })
    }
}
impl Drop for DescriptorSetLayout {
    fn drop(&mut self) {
        if !std::thread::panicking() {
            self.context.drop_descriptor_set_layout(&self.id);
        }
    }
}
impl PartialEq for DescriptorSetLayout {
    fn eq(&self, other: &Self) -> bool {
        self.id == other.id
    }
}
impl DescriptorSetLayout {
    ///Creates a new instance of this handle from its core components.
    pub(crate) const unsafe fn new(context: Arc<Context>, id: ObjectId) -> Self {
        Self { context, id }
    }
    ///Gets the object id
    pub fn id(&self) -> &ObjectId {
        &self.id
    }
    ///Gets a reference to the context
    pub fn context(&self) -> &Context {
        &self.context
    }
    ///Gets a reference to the context wrapped in an [`Arc`]
    pub fn arc_context(&self) -> &Arc<Context> {
        &self.context
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for DescriptorSetLayout {
    type LowLevel = crate::native::vulkan1_0::DescriptorSetLayout;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *context
            .descriptor_set_layout()
            .get(&self.id)
            .expect("unknwon handle")
            .handle()
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for DescriptorSetLayout {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        let object_id = ObjectId::random();
        context.descriptor_set_layout().insert(object_id, Container::new(value));
        Self {
            context: context.clone(),
            id: object_id,
        }
    }
}
#[doc(alias = "VkDescriptorPool")]
#[derive(Debug)]
pub struct DescriptorPool {
    context: Arc<Context>,
    id: ObjectId,
}
impl Clone for DescriptorPool {
    fn clone(&self) -> Self {
        self.context.clone_descriptor_pool(self.id);
        Self {
            context: Arc::clone(&self.context),
            id: self.id,
        }
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for DescriptorPool {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.id.serialize(serializer)
    }
}
impl<'de> Deserialize<'de> for DescriptorPool {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let id = ObjectId::deserialize(deserializer)?;
        crate::context::CONTEXT.with(|context| {
            let borrow = context.borrow();
            let context = borrow.as_ref().expect("Context not set.");
            Ok(Self {
                context: Arc::clone(context),
                id,
            })
        })
    }
}
impl Drop for DescriptorPool {
    fn drop(&mut self) {
        if !std::thread::panicking() {
            self.context.drop_descriptor_pool(&self.id);
        }
    }
}
impl PartialEq for DescriptorPool {
    fn eq(&self, other: &Self) -> bool {
        self.id == other.id
    }
}
impl DescriptorPool {
    ///Creates a new instance of this handle from its core components.
    pub(crate) const unsafe fn new(context: Arc<Context>, id: ObjectId) -> Self {
        Self { context, id }
    }
    ///Gets the object id
    pub fn id(&self) -> &ObjectId {
        &self.id
    }
    ///Gets a reference to the context
    pub fn context(&self) -> &Context {
        &self.context
    }
    ///Gets a reference to the context wrapped in an [`Arc`]
    pub fn arc_context(&self) -> &Arc<Context> {
        &self.context
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for DescriptorPool {
    type LowLevel = crate::native::vulkan1_0::DescriptorPool;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *context
            .descriptor_pool()
            .get(&self.id)
            .expect("unknwon handle")
            .handle()
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for DescriptorPool {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        let object_id = ObjectId::random();
        context.descriptor_pool().insert(object_id, Container::new(value));
        Self {
            context: context.clone(),
            id: object_id,
        }
    }
}
#[doc(alias = "VkFence")]
#[derive(Debug)]
pub struct Fence {
    context: Arc<Context>,
    id: ObjectId,
}
impl Clone for Fence {
    fn clone(&self) -> Self {
        self.context.clone_fence(self.id);
        Self {
            context: Arc::clone(&self.context),
            id: self.id,
        }
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for Fence {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.id.serialize(serializer)
    }
}
impl<'de> Deserialize<'de> for Fence {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let id = ObjectId::deserialize(deserializer)?;
        crate::context::CONTEXT.with(|context| {
            let borrow = context.borrow();
            let context = borrow.as_ref().expect("Context not set.");
            Ok(Self {
                context: Arc::clone(context),
                id,
            })
        })
    }
}
impl Drop for Fence {
    fn drop(&mut self) {
        if !std::thread::panicking() {
            self.context.drop_fence(&self.id);
        }
    }
}
impl PartialEq for Fence {
    fn eq(&self, other: &Self) -> bool {
        self.id == other.id
    }
}
impl Fence {
    ///Creates a new instance of this handle from its core components.
    pub(crate) const unsafe fn new(context: Arc<Context>, id: ObjectId) -> Self {
        Self { context, id }
    }
    ///Gets the object id
    pub fn id(&self) -> &ObjectId {
        &self.id
    }
    ///Gets a reference to the context
    pub fn context(&self) -> &Context {
        &self.context
    }
    ///Gets a reference to the context wrapped in an [`Arc`]
    pub fn arc_context(&self) -> &Arc<Context> {
        &self.context
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for Fence {
    type LowLevel = crate::native::vulkan1_0::Fence;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *context.fence().get(&self.id).expect("unknwon handle").handle()
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for Fence {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        let object_id = ObjectId::random();
        context.fence().insert(object_id, Container::new(value));
        Self {
            context: context.clone(),
            id: object_id,
        }
    }
}
#[doc(alias = "VkSemaphore")]
#[derive(Debug)]
pub struct Semaphore {
    context: Arc<Context>,
    id: ObjectId,
}
impl Clone for Semaphore {
    fn clone(&self) -> Self {
        self.context.clone_semaphore(self.id);
        Self {
            context: Arc::clone(&self.context),
            id: self.id,
        }
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for Semaphore {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.id.serialize(serializer)
    }
}
impl<'de> Deserialize<'de> for Semaphore {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let id = ObjectId::deserialize(deserializer)?;
        crate::context::CONTEXT.with(|context| {
            let borrow = context.borrow();
            let context = borrow.as_ref().expect("Context not set.");
            Ok(Self {
                context: Arc::clone(context),
                id,
            })
        })
    }
}
impl Drop for Semaphore {
    fn drop(&mut self) {
        if !std::thread::panicking() {
            self.context.drop_semaphore(&self.id);
        }
    }
}
impl PartialEq for Semaphore {
    fn eq(&self, other: &Self) -> bool {
        self.id == other.id
    }
}
impl Semaphore {
    ///Creates a new instance of this handle from its core components.
    pub(crate) const unsafe fn new(context: Arc<Context>, id: ObjectId) -> Self {
        Self { context, id }
    }
    ///Gets the object id
    pub fn id(&self) -> &ObjectId {
        &self.id
    }
    ///Gets a reference to the context
    pub fn context(&self) -> &Context {
        &self.context
    }
    ///Gets a reference to the context wrapped in an [`Arc`]
    pub fn arc_context(&self) -> &Arc<Context> {
        &self.context
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for Semaphore {
    type LowLevel = crate::native::vulkan1_0::Semaphore;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *context.semaphore().get(&self.id).expect("unknwon handle").handle()
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for Semaphore {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        let object_id = ObjectId::random();
        context.semaphore().insert(object_id, Container::new(value));
        Self {
            context: context.clone(),
            id: object_id,
        }
    }
}
#[doc(alias = "VkEvent")]
#[derive(Debug)]
pub struct Event {
    context: Arc<Context>,
    id: ObjectId,
}
impl Clone for Event {
    fn clone(&self) -> Self {
        self.context.clone_event(self.id);
        Self {
            context: Arc::clone(&self.context),
            id: self.id,
        }
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for Event {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.id.serialize(serializer)
    }
}
impl<'de> Deserialize<'de> for Event {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let id = ObjectId::deserialize(deserializer)?;
        crate::context::CONTEXT.with(|context| {
            let borrow = context.borrow();
            let context = borrow.as_ref().expect("Context not set.");
            Ok(Self {
                context: Arc::clone(context),
                id,
            })
        })
    }
}
impl Drop for Event {
    fn drop(&mut self) {
        if !std::thread::panicking() {
            self.context.drop_event(&self.id);
        }
    }
}
impl PartialEq for Event {
    fn eq(&self, other: &Self) -> bool {
        self.id == other.id
    }
}
impl Event {
    ///Creates a new instance of this handle from its core components.
    pub(crate) const unsafe fn new(context: Arc<Context>, id: ObjectId) -> Self {
        Self { context, id }
    }
    ///Gets the object id
    pub fn id(&self) -> &ObjectId {
        &self.id
    }
    ///Gets a reference to the context
    pub fn context(&self) -> &Context {
        &self.context
    }
    ///Gets a reference to the context wrapped in an [`Arc`]
    pub fn arc_context(&self) -> &Arc<Context> {
        &self.context
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for Event {
    type LowLevel = crate::native::vulkan1_0::Event;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *context.event().get(&self.id).expect("unknwon handle").handle()
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for Event {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        let object_id = ObjectId::random();
        context.event().insert(object_id, Container::new(value));
        Self {
            context: context.clone(),
            id: object_id,
        }
    }
}
#[doc(alias = "VkQueryPool")]
#[derive(Debug)]
pub struct QueryPool {
    context: Arc<Context>,
    id: ObjectId,
}
impl Clone for QueryPool {
    fn clone(&self) -> Self {
        self.context.clone_query_pool(self.id);
        Self {
            context: Arc::clone(&self.context),
            id: self.id,
        }
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for QueryPool {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.id.serialize(serializer)
    }
}
impl<'de> Deserialize<'de> for QueryPool {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let id = ObjectId::deserialize(deserializer)?;
        crate::context::CONTEXT.with(|context| {
            let borrow = context.borrow();
            let context = borrow.as_ref().expect("Context not set.");
            Ok(Self {
                context: Arc::clone(context),
                id,
            })
        })
    }
}
impl Drop for QueryPool {
    fn drop(&mut self) {
        if !std::thread::panicking() {
            self.context.drop_query_pool(&self.id);
        }
    }
}
impl PartialEq for QueryPool {
    fn eq(&self, other: &Self) -> bool {
        self.id == other.id
    }
}
impl QueryPool {
    ///Creates a new instance of this handle from its core components.
    pub(crate) const unsafe fn new(context: Arc<Context>, id: ObjectId) -> Self {
        Self { context, id }
    }
    ///Gets the object id
    pub fn id(&self) -> &ObjectId {
        &self.id
    }
    ///Gets a reference to the context
    pub fn context(&self) -> &Context {
        &self.context
    }
    ///Gets a reference to the context wrapped in an [`Arc`]
    pub fn arc_context(&self) -> &Arc<Context> {
        &self.context
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for QueryPool {
    type LowLevel = crate::native::vulkan1_0::QueryPool;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *context.query_pool().get(&self.id).expect("unknwon handle").handle()
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for QueryPool {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        let object_id = ObjectId::random();
        context.query_pool().insert(object_id, Container::new(value));
        Self {
            context: context.clone(),
            id: object_id,
        }
    }
}
#[doc(alias = "VkFramebuffer")]
#[derive(Debug)]
pub struct Framebuffer {
    context: Arc<Context>,
    id: ObjectId,
}
impl Clone for Framebuffer {
    fn clone(&self) -> Self {
        self.context.clone_framebuffer(self.id);
        Self {
            context: Arc::clone(&self.context),
            id: self.id,
        }
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for Framebuffer {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.id.serialize(serializer)
    }
}
impl<'de> Deserialize<'de> for Framebuffer {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let id = ObjectId::deserialize(deserializer)?;
        crate::context::CONTEXT.with(|context| {
            let borrow = context.borrow();
            let context = borrow.as_ref().expect("Context not set.");
            Ok(Self {
                context: Arc::clone(context),
                id,
            })
        })
    }
}
impl Drop for Framebuffer {
    fn drop(&mut self) {
        if !std::thread::panicking() {
            self.context.drop_framebuffer(&self.id);
        }
    }
}
impl PartialEq for Framebuffer {
    fn eq(&self, other: &Self) -> bool {
        self.id == other.id
    }
}
impl Framebuffer {
    ///Creates a new instance of this handle from its core components.
    pub(crate) const unsafe fn new(context: Arc<Context>, id: ObjectId) -> Self {
        Self { context, id }
    }
    ///Gets the object id
    pub fn id(&self) -> &ObjectId {
        &self.id
    }
    ///Gets a reference to the context
    pub fn context(&self) -> &Context {
        &self.context
    }
    ///Gets a reference to the context wrapped in an [`Arc`]
    pub fn arc_context(&self) -> &Arc<Context> {
        &self.context
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for Framebuffer {
    type LowLevel = crate::native::vulkan1_0::Framebuffer;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *context.framebuffer().get(&self.id).expect("unknwon handle").handle()
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for Framebuffer {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        let object_id = ObjectId::random();
        context.framebuffer().insert(object_id, Container::new(value));
        Self {
            context: context.clone(),
            id: object_id,
        }
    }
}
#[doc(alias = "VkRenderPass")]
#[derive(Debug)]
pub struct RenderPass {
    context: Arc<Context>,
    id: ObjectId,
}
impl Clone for RenderPass {
    fn clone(&self) -> Self {
        self.context.clone_render_pass(self.id);
        Self {
            context: Arc::clone(&self.context),
            id: self.id,
        }
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for RenderPass {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.id.serialize(serializer)
    }
}
impl<'de> Deserialize<'de> for RenderPass {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let id = ObjectId::deserialize(deserializer)?;
        crate::context::CONTEXT.with(|context| {
            let borrow = context.borrow();
            let context = borrow.as_ref().expect("Context not set.");
            Ok(Self {
                context: Arc::clone(context),
                id,
            })
        })
    }
}
impl Drop for RenderPass {
    fn drop(&mut self) {
        if !std::thread::panicking() {
            self.context.drop_render_pass(&self.id);
        }
    }
}
impl PartialEq for RenderPass {
    fn eq(&self, other: &Self) -> bool {
        self.id == other.id
    }
}
impl RenderPass {
    ///Creates a new instance of this handle from its core components.
    pub(crate) const unsafe fn new(context: Arc<Context>, id: ObjectId) -> Self {
        Self { context, id }
    }
    ///Gets the object id
    pub fn id(&self) -> &ObjectId {
        &self.id
    }
    ///Gets a reference to the context
    pub fn context(&self) -> &Context {
        &self.context
    }
    ///Gets a reference to the context wrapped in an [`Arc`]
    pub fn arc_context(&self) -> &Arc<Context> {
        &self.context
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for RenderPass {
    type LowLevel = crate::native::vulkan1_0::RenderPass;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *context.render_pass().get(&self.id).expect("unknwon handle").handle()
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for RenderPass {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        let object_id = ObjectId::random();
        context.render_pass().insert(object_id, Container::new(value));
        Self {
            context: context.clone(),
            id: object_id,
        }
    }
}
#[doc(alias = "VkPipelineCache")]
#[derive(Debug)]
pub struct PipelineCache {
    context: Arc<Context>,
    id: ObjectId,
}
impl Clone for PipelineCache {
    fn clone(&self) -> Self {
        self.context.clone_pipeline_cache(self.id);
        Self {
            context: Arc::clone(&self.context),
            id: self.id,
        }
    }
}
#[cfg(feature = "serde")]
impl serde::Serialize for PipelineCache {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.id.serialize(serializer)
    }
}
impl<'de> Deserialize<'de> for PipelineCache {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let id = ObjectId::deserialize(deserializer)?;
        crate::context::CONTEXT.with(|context| {
            let borrow = context.borrow();
            let context = borrow.as_ref().expect("Context not set.");
            Ok(Self {
                context: Arc::clone(context),
                id,
            })
        })
    }
}
impl Drop for PipelineCache {
    fn drop(&mut self) {
        if !std::thread::panicking() {
            self.context.drop_pipeline_cache(&self.id);
        }
    }
}
impl PartialEq for PipelineCache {
    fn eq(&self, other: &Self) -> bool {
        self.id == other.id
    }
}
impl PipelineCache {
    ///Creates a new instance of this handle from its core components.
    pub(crate) const unsafe fn new(context: Arc<Context>, id: ObjectId) -> Self {
        Self { context, id }
    }
    ///Gets the object id
    pub fn id(&self) -> &ObjectId {
        &self.id
    }
    ///Gets a reference to the context
    pub fn context(&self) -> &Context {
        &self.context
    }
    ///Gets a reference to the context wrapped in an [`Arc`]
    pub fn arc_context(&self) -> &Arc<Context> {
        &self.context
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for PipelineCache {
    type LowLevel = crate::native::vulkan1_0::PipelineCache;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *context.pipeline_cache().get(&self.id).expect("unknwon handle").handle()
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for PipelineCache {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        let object_id = ObjectId::random();
        context.pipeline_cache().insert(object_id, Container::new(value));
        Self {
            context: context.clone(),
            id: object_id,
        }
    }
}
