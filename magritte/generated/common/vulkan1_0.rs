#[cfg(feature = "VK_ARM_rasterization_order_attachment_access")]
use crate::common::extensions::arm_rasterization_order_attachment_access::PipelineColorBlendStateCreateFlagBits;
#[cfg(feature = "VK_ARM_rasterization_order_attachment_access")]
use crate::common::extensions::arm_rasterization_order_attachment_access::PipelineDepthStencilStateCreateFlagBits;
#[cfg(feature = "VK_EXT_pipeline_creation_cache_control")]
use crate::common::extensions::ext_pipeline_creation_cache_control::PipelineCacheCreateFlagBits;
use crate::common::vulkan1_1::DeviceQueueCreateFlagBits;
#[cfg(feature = "serde")]
use serde::{Deserialize, Serialize};
use uuid::Uuid;
#[doc(alias = "VkOffset2D")]
#[derive(Clone, Copy, PartialEq, Debug, Default)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct Offset2D {
    pub x: i32,
    pub y: i32,
}
#[doc(alias = "VkOffset3D")]
#[derive(Clone, Copy, PartialEq, Debug, Default)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct Offset3D {
    pub x: i32,
    pub y: i32,
    pub z: i32,
}
#[doc(alias = "VkExtent2D")]
#[derive(Clone, Copy, PartialEq, Debug, Default)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct Extent2D {
    pub width: u32,
    pub height: u32,
}
#[doc(alias = "VkExtent3D")]
#[derive(Clone, Copy, PartialEq, Debug, Default)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct Extent3D {
    pub width: u32,
    pub height: u32,
    pub depth: u32,
}
#[doc(alias = "VkViewport")]
#[derive(Clone, Copy, PartialEq, Debug, Default)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct Viewport {
    pub x: f32,
    pub y: f32,
    pub width: f32,
    pub height: f32,
    #[doc(alias = "minDepth")]
    pub min_depth: f32,
    #[doc(alias = "maxDepth")]
    pub max_depth: f32,
}
#[doc(alias = "VkRect2D")]
#[derive(Clone, Copy, PartialEq, Debug, Default)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct Rect2D {
    pub offset: Offset2D,
    pub extent: Extent2D,
}
#[doc(alias = "VkClearRect")]
#[derive(Clone, Copy, PartialEq, Debug, Default)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct ClearRect {
    pub rect: Rect2D,
    #[doc(alias = "baseArrayLayer")]
    pub base_array_layer: u32,
    #[doc(alias = "layerCount")]
    pub layer_count: u32,
}
#[doc(alias = "VkComponentMapping")]
#[derive(Clone, Copy, PartialEq, Debug, Default)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct ComponentMapping {
    pub r: ComponentSwizzle,
    pub g: ComponentSwizzle,
    pub b: ComponentSwizzle,
    pub a: ComponentSwizzle,
}
#[doc(alias = "VkQueueFamilyProperties")]
#[derive(Clone, Copy, PartialEq, Debug, Default)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct QueueFamilyProperties {
    #[doc(alias = "queueFlags")]
    pub queue_flags: QueueFlags,
    #[doc(alias = "queueCount")]
    pub queue_count: u32,
    #[doc(alias = "timestampValidBits")]
    pub timestamp_valid_bits: u32,
    #[doc(alias = "minImageTransferGranularity")]
    pub min_image_transfer_granularity: Extent3D,
}
#[doc(alias = "VkPhysicalDeviceMemoryProperties")]
#[derive(Clone, Copy, PartialEq, Debug, Default)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct PhysicalDeviceMemoryProperties {
    #[doc(alias = "memoryTypeCount")]
    pub memory_type_count: u32,
    #[doc(alias = "memoryTypes")]
    pub memory_types: [MemoryType; MAX_MEMORY_TYPES as usize],
    #[doc(alias = "memoryHeapCount")]
    pub memory_heap_count: u32,
    #[doc(alias = "memoryHeaps")]
    pub memory_heaps: [MemoryHeap; MAX_MEMORY_HEAPS as usize],
}
#[doc(alias = "VkMemoryRequirements")]
#[derive(Clone, Copy, PartialEq, Debug, Default)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct MemoryRequirements {
    pub size: DeviceSize,
    pub alignment: DeviceSize,
    #[doc(alias = "memoryTypeBits")]
    pub memory_type_bits: u32,
}
#[doc(alias = "VkSparseImageFormatProperties")]
#[derive(Clone, Copy, PartialEq, Debug, Default)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct SparseImageFormatProperties {
    #[doc(alias = "aspectMask")]
    pub aspect_mask: ImageAspectFlags,
    #[doc(alias = "imageGranularity")]
    pub image_granularity: Extent3D,
    pub flags: SparseImageFormatFlags,
}
#[doc(alias = "VkSparseImageMemoryRequirements")]
#[derive(Clone, Copy, PartialEq, Debug, Default)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct SparseImageMemoryRequirements {
    #[doc(alias = "formatProperties")]
    pub format_properties: SparseImageFormatProperties,
    #[doc(alias = "imageMipTailFirstLod")]
    pub image_mip_tail_first_lod: u32,
    #[doc(alias = "imageMipTailSize")]
    pub image_mip_tail_size: DeviceSize,
    #[doc(alias = "imageMipTailOffset")]
    pub image_mip_tail_offset: DeviceSize,
    #[doc(alias = "imageMipTailStride")]
    pub image_mip_tail_stride: DeviceSize,
}
#[doc(alias = "VkMemoryType")]
#[derive(Clone, Copy, PartialEq, Debug, Default)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct MemoryType {
    #[doc(alias = "propertyFlags")]
    pub property_flags: MemoryPropertyFlags,
    #[doc(alias = "heapIndex")]
    pub heap_index: u32,
}
#[doc(alias = "VkMemoryHeap")]
#[derive(Clone, Copy, PartialEq, Debug, Default)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct MemoryHeap {
    pub size: DeviceSize,
    pub flags: MemoryHeapFlags,
}
#[doc(alias = "VkFormatProperties")]
#[derive(Clone, Copy, PartialEq, Debug, Default)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct FormatProperties {
    #[doc(alias = "linearTilingFeatures")]
    pub linear_tiling_features: FormatFeatureFlags,
    #[doc(alias = "optimalTilingFeatures")]
    pub optimal_tiling_features: FormatFeatureFlags,
    #[doc(alias = "bufferFeatures")]
    pub buffer_features: FormatFeatureFlags,
}
#[doc(alias = "VkImageFormatProperties")]
#[derive(Clone, Copy, PartialEq, Debug, Default)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct ImageFormatProperties {
    #[doc(alias = "maxExtent")]
    pub max_extent: Extent3D,
    #[doc(alias = "maxMipLevels")]
    pub max_mip_levels: u32,
    #[doc(alias = "maxArrayLayers")]
    pub max_array_layers: u32,
    #[doc(alias = "sampleCounts")]
    pub sample_counts: SampleCountFlags,
    #[doc(alias = "maxResourceSize")]
    pub max_resource_size: DeviceSize,
}
#[doc(alias = "VkImageSubresource")]
#[derive(Clone, Copy, PartialEq, Debug, Default)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct ImageSubresource {
    #[doc(alias = "aspectMask")]
    pub aspect_mask: ImageAspectFlags,
    #[doc(alias = "mipLevel")]
    pub mip_level: u32,
    #[doc(alias = "arrayLayer")]
    pub array_layer: u32,
}
#[doc(alias = "VkImageSubresourceLayers")]
#[derive(Clone, Copy, PartialEq, Debug, Default)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct ImageSubresourceLayers {
    #[doc(alias = "aspectMask")]
    pub aspect_mask: ImageAspectFlags,
    #[doc(alias = "mipLevel")]
    pub mip_level: u32,
    #[doc(alias = "baseArrayLayer")]
    pub base_array_layer: u32,
    #[doc(alias = "layerCount")]
    pub layer_count: u32,
}
#[doc(alias = "VkImageSubresourceRange")]
#[derive(Clone, Copy, PartialEq, Debug, Default)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct ImageSubresourceRange {
    #[doc(alias = "aspectMask")]
    pub aspect_mask: ImageAspectFlags,
    #[doc(alias = "baseMipLevel")]
    pub base_mip_level: u32,
    #[doc(alias = "levelCount")]
    pub level_count: u32,
    #[doc(alias = "baseArrayLayer")]
    pub base_array_layer: u32,
    #[doc(alias = "layerCount")]
    pub layer_count: u32,
}
#[doc(alias = "VkSubresourceLayout")]
#[derive(Clone, Copy, PartialEq, Debug, Default)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct SubresourceLayout {
    pub offset: DeviceSize,
    pub size: DeviceSize,
    #[doc(alias = "rowPitch")]
    pub row_pitch: DeviceSize,
    #[doc(alias = "arrayPitch")]
    pub array_pitch: DeviceSize,
    #[doc(alias = "depthPitch")]
    pub depth_pitch: DeviceSize,
}
#[doc(alias = "VkBufferCopy")]
#[derive(Clone, Copy, PartialEq, Debug, Default)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct BufferCopy {
    #[doc(alias = "srcOffset")]
    pub src_offset: DeviceSize,
    #[doc(alias = "dstOffset")]
    pub dst_offset: DeviceSize,
    pub size: DeviceSize,
}
#[doc(alias = "VkImageCopy")]
#[derive(Clone, Copy, PartialEq, Debug, Default)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct ImageCopy {
    #[doc(alias = "srcSubresource")]
    pub src_subresource: ImageSubresourceLayers,
    #[doc(alias = "srcOffset")]
    pub src_offset: Offset3D,
    #[doc(alias = "dstSubresource")]
    pub dst_subresource: ImageSubresourceLayers,
    #[doc(alias = "dstOffset")]
    pub dst_offset: Offset3D,
    pub extent: Extent3D,
}
#[doc(alias = "VkImageBlit")]
#[derive(Clone, Copy, PartialEq, Debug, Default)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct ImageBlit {
    #[doc(alias = "srcSubresource")]
    pub src_subresource: ImageSubresourceLayers,
    #[doc(alias = "srcOffsets")]
    pub src_offsets: [Offset3D; 2 as usize],
    #[doc(alias = "dstSubresource")]
    pub dst_subresource: ImageSubresourceLayers,
    #[doc(alias = "dstOffsets")]
    pub dst_offsets: [Offset3D; 2 as usize],
}
#[doc(alias = "VkBufferImageCopy")]
#[derive(Clone, Copy, PartialEq, Debug, Default)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct BufferImageCopy {
    #[doc(alias = "bufferOffset")]
    pub buffer_offset: DeviceSize,
    #[doc(alias = "bufferRowLength")]
    pub buffer_row_length: u32,
    #[doc(alias = "bufferImageHeight")]
    pub buffer_image_height: u32,
    #[doc(alias = "imageSubresource")]
    pub image_subresource: ImageSubresourceLayers,
    #[doc(alias = "imageOffset")]
    pub image_offset: Offset3D,
    #[doc(alias = "imageExtent")]
    pub image_extent: Extent3D,
}
#[doc(alias = "VkImageResolve")]
#[derive(Clone, Copy, PartialEq, Debug, Default)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct ImageResolve {
    #[doc(alias = "srcSubresource")]
    pub src_subresource: ImageSubresourceLayers,
    #[doc(alias = "srcOffset")]
    pub src_offset: Offset3D,
    #[doc(alias = "dstSubresource")]
    pub dst_subresource: ImageSubresourceLayers,
    #[doc(alias = "dstOffset")]
    pub dst_offset: Offset3D,
    pub extent: Extent3D,
}
#[doc(alias = "VkDescriptorPoolSize")]
#[derive(Clone, Copy, PartialEq, Debug, Default)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct DescriptorPoolSize {
    #[doc(alias = "type")]
    pub type_: DescriptorType,
    #[doc(alias = "descriptorCount")]
    pub descriptor_count: u32,
}
#[doc(alias = "VkSpecializationMapEntry")]
#[derive(Clone, Copy, PartialEq, Debug, Default)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct SpecializationMapEntry {
    #[doc(alias = "constantID")]
    pub constant_id: u32,
    pub offset: u32,
    pub size: usize,
}
#[doc(alias = "VkVertexInputBindingDescription")]
#[derive(Clone, Copy, PartialEq, Debug, Default)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct VertexInputBindingDescription {
    pub binding: u32,
    pub stride: u32,
    #[doc(alias = "inputRate")]
    pub input_rate: VertexInputRate,
}
#[doc(alias = "VkVertexInputAttributeDescription")]
#[derive(Clone, Copy, PartialEq, Debug, Default)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct VertexInputAttributeDescription {
    pub location: u32,
    pub binding: u32,
    pub format: Format,
    pub offset: u32,
}
#[doc(alias = "VkStencilOpState")]
#[derive(Clone, Copy, PartialEq, Debug, Default)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct StencilOpState {
    #[doc(alias = "failOp")]
    pub fail_op: StencilOp,
    #[doc(alias = "passOp")]
    pub pass_op: StencilOp,
    #[doc(alias = "depthFailOp")]
    pub depth_fail_op: StencilOp,
    #[doc(alias = "compareOp")]
    pub compare_op: CompareOp,
    #[doc(alias = "compareMask")]
    pub compare_mask: u32,
    #[doc(alias = "writeMask")]
    pub write_mask: u32,
    pub reference: u32,
}
#[doc(alias = "VkPipelineCacheHeaderVersionOne")]
#[derive(Clone, Copy, PartialEq, Debug, Default)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct PipelineCacheHeaderVersionOne {
    #[doc(alias = "headerSize")]
    pub header_size: u32,
    #[doc(alias = "headerVersion")]
    pub header_version: PipelineCacheHeaderVersion,
    #[doc(alias = "vendorID")]
    pub vendor_id: u32,
    #[doc(alias = "deviceID")]
    pub device_id: u32,
    #[doc(alias = "pipelineCacheUUID")]
    pub pipeline_cache_uuid: Uuid,
}
#[doc(alias = "VkPushConstantRange")]
#[derive(Clone, Copy, PartialEq, Debug, Default)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct PushConstantRange {
    #[doc(alias = "stageFlags")]
    pub stage_flags: ShaderStageFlags,
    pub offset: u32,
    pub size: u32,
}
#[doc(alias = "VkClearDepthStencilValue")]
#[derive(Clone, Copy, PartialEq, Debug, Default)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct ClearDepthStencilValue {
    pub depth: f32,
    pub stencil: u32,
}
#[doc(alias = "VkAttachmentDescription")]
#[derive(Clone, Copy, PartialEq, Debug, Default)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct AttachmentDescription {
    pub flags: AttachmentDescriptionFlags,
    pub format: Format,
    pub samples: SampleCountFlagBits,
    #[doc(alias = "loadOp")]
    pub load_op: AttachmentLoadOp,
    #[doc(alias = "storeOp")]
    pub store_op: AttachmentStoreOp,
    #[doc(alias = "stencilLoadOp")]
    pub stencil_load_op: AttachmentLoadOp,
    #[doc(alias = "stencilStoreOp")]
    pub stencil_store_op: AttachmentStoreOp,
    #[doc(alias = "initialLayout")]
    pub initial_layout: ImageLayout,
    #[doc(alias = "finalLayout")]
    pub final_layout: ImageLayout,
}
#[doc(alias = "VkAttachmentReference")]
#[derive(Clone, Copy, PartialEq, Debug, Default)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct AttachmentReference {
    pub attachment: u32,
    pub layout: ImageLayout,
}
#[doc(alias = "VkSubpassDependency")]
#[derive(Clone, Copy, PartialEq, Debug, Default)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct SubpassDependency {
    #[doc(alias = "srcSubpass")]
    pub src_subpass: u32,
    #[doc(alias = "dstSubpass")]
    pub dst_subpass: u32,
    #[doc(alias = "srcStageMask")]
    pub src_stage_mask: PipelineStageFlags,
    #[doc(alias = "dstStageMask")]
    pub dst_stage_mask: PipelineStageFlags,
    #[doc(alias = "srcAccessMask")]
    pub src_access_mask: AccessFlags,
    #[doc(alias = "dstAccessMask")]
    pub dst_access_mask: AccessFlags,
    #[doc(alias = "dependencyFlags")]
    pub dependency_flags: DependencyFlags,
}
#[doc(alias = "VkDrawIndirectCommand")]
#[derive(Clone, Copy, PartialEq, Debug, Default)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct DrawIndirectCommand {
    #[doc(alias = "vertexCount")]
    pub vertex_count: u32,
    #[doc(alias = "instanceCount")]
    pub instance_count: u32,
    #[doc(alias = "firstVertex")]
    pub first_vertex: u32,
    #[doc(alias = "firstInstance")]
    pub first_instance: u32,
}
#[doc(alias = "VkDrawIndexedIndirectCommand")]
#[derive(Clone, Copy, PartialEq, Debug, Default)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct DrawIndexedIndirectCommand {
    #[doc(alias = "indexCount")]
    pub index_count: u32,
    #[doc(alias = "instanceCount")]
    pub instance_count: u32,
    #[doc(alias = "firstIndex")]
    pub first_index: u32,
    #[doc(alias = "vertexOffset")]
    pub vertex_offset: i32,
    #[doc(alias = "firstInstance")]
    pub first_instance: u32,
}
#[doc(alias = "VkDispatchIndirectCommand")]
#[derive(Clone, Copy, PartialEq, Debug, Default)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct DispatchIndirectCommand {
    pub x: u32,
    pub y: u32,
    pub z: u32,
}
#[doc(alias = "VkSampleMask")]
pub type SampleMask = u32;
#[doc(alias = "VkBool32")]
pub type Bool32 = u32;
#[doc(alias = "VkFlags")]
pub type Flags = u32;
#[doc(alias = "VkDeviceSize")]
pub type DeviceSize = u64;
#[doc(alias = "VkDeviceAddress")]
pub type DeviceAddress = u64;
#[doc(alias = "VkFramebufferCreateFlags")]
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct FramebufferCreateFlags(u32);
impl FramebufferCreateFlags {
    #[doc(alias = "VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT")]
    #[cfg(feature = "VULKAN_1_2")]
    pub const IMAGELESS: Self = Self(1);
    #[doc(alias = "VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT_KHR")]
    #[cfg(feature = "VK_KHR_imageless_framebuffer")]
    pub const IMAGELESS_KHR: Self = Self::IMAGELESS;
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    #[allow(unused_mut)]
    pub const fn all() -> Self {
        let mut all = Self::empty();
        #[cfg(feature = "VULKAN_1_2")]
        {
            all |= Self::IMAGELESS;
        }
        #[cfg(feature = "VK_KHR_imageless_framebuffer")]
        {
            all |= Self::IMAGELESS_KHR;
        }
        all
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl std::ops::BitOr for FramebufferCreateFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl std::ops::BitOrAssign for FramebufferCreateFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl std::ops::BitXor for FramebufferCreateFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl std::ops::BitXorAssign for FramebufferCreateFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl std::ops::BitAnd for FramebufferCreateFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl std::ops::BitAndAssign for FramebufferCreateFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl std::ops::Sub for FramebufferCreateFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl std::ops::SubAssign for FramebufferCreateFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl std::ops::Not for FramebufferCreateFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl Extend<FramebufferCreateFlags> for FramebufferCreateFlags {
    fn extend<T: IntoIterator<Item = FramebufferCreateFlags>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, i);
        }
    }
}
impl FromIterator<FramebufferCreateFlags> for FramebufferCreateFlags {
    fn from_iter<T: IntoIterator<Item = FramebufferCreateFlags>>(iterator: T) -> FramebufferCreateFlags {
        let mut out = Self::empty();
        <Self as Extend<FramebufferCreateFlags>>::extend(&mut out, iterator);
        out
    }
}
impl Default for FramebufferCreateFlags {
    fn default() -> Self {
        Self::empty()
    }
}
impl From<FramebufferCreateFlagBits> for FramebufferCreateFlags {
    fn from(bit: FramebufferCreateFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(bit.bits()) }
    }
}
impl Extend<FramebufferCreateFlagBits> for FramebufferCreateFlags {
    fn extend<T: IntoIterator<Item = FramebufferCreateFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, Self::from(i));
        }
    }
}
impl FromIterator<FramebufferCreateFlagBits> for FramebufferCreateFlags {
    fn from_iter<T: IntoIterator<Item = FramebufferCreateFlagBits>>(iterator: T) -> FramebufferCreateFlags {
        let mut out = Self::empty();
        <Self as Extend<FramebufferCreateFlagBits>>::extend(&mut out, iterator);
        out
    }
}
impl std::fmt::Debug for FramebufferCreateFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(FramebufferCreateFlags);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == FramebufferCreateFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    #[cfg(feature = "VULKAN_1_2")]
                    if self.0.contains(FramebufferCreateFlags::IMAGELESS) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(IMAGELESS))?;
                    }
                    #[cfg(feature = "VK_KHR_imageless_framebuffer")]
                    if self.0.contains(FramebufferCreateFlags::IMAGELESS_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(IMAGELESS_KHR))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(FramebufferCreateFlags))
            .field(&Flags(*self))
            .finish()
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for FramebufferCreateFlags {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for FramebufferCreateFlags {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkQueryPoolCreateFlags")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct QueryPoolCreateFlags(u32);
impl QueryPoolCreateFlags {
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
}
impl Default for QueryPoolCreateFlags {
    #[inline]
    fn default() -> Self {
        Self::empty()
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for QueryPoolCreateFlags {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for QueryPoolCreateFlags {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkRenderPassCreateFlags")]
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct RenderPassCreateFlags(u32);
impl RenderPassCreateFlags {
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    #[allow(unused_mut)]
    pub const fn all() -> Self {
        let mut all = Self::empty();
        all
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl std::ops::BitOr for RenderPassCreateFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl std::ops::BitOrAssign for RenderPassCreateFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl std::ops::BitXor for RenderPassCreateFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl std::ops::BitXorAssign for RenderPassCreateFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl std::ops::BitAnd for RenderPassCreateFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl std::ops::BitAndAssign for RenderPassCreateFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl std::ops::Sub for RenderPassCreateFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl std::ops::SubAssign for RenderPassCreateFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl std::ops::Not for RenderPassCreateFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl Extend<RenderPassCreateFlags> for RenderPassCreateFlags {
    fn extend<T: IntoIterator<Item = RenderPassCreateFlags>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, i);
        }
    }
}
impl FromIterator<RenderPassCreateFlags> for RenderPassCreateFlags {
    fn from_iter<T: IntoIterator<Item = RenderPassCreateFlags>>(iterator: T) -> RenderPassCreateFlags {
        let mut out = Self::empty();
        <Self as Extend<RenderPassCreateFlags>>::extend(&mut out, iterator);
        out
    }
}
impl Default for RenderPassCreateFlags {
    fn default() -> Self {
        Self::empty()
    }
}
impl From<RenderPassCreateFlagBits> for RenderPassCreateFlags {
    fn from(bit: RenderPassCreateFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(bit.bits()) }
    }
}
impl Extend<RenderPassCreateFlagBits> for RenderPassCreateFlags {
    fn extend<T: IntoIterator<Item = RenderPassCreateFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, Self::from(i));
        }
    }
}
impl FromIterator<RenderPassCreateFlagBits> for RenderPassCreateFlags {
    fn from_iter<T: IntoIterator<Item = RenderPassCreateFlagBits>>(iterator: T) -> RenderPassCreateFlags {
        let mut out = Self::empty();
        <Self as Extend<RenderPassCreateFlagBits>>::extend(&mut out, iterator);
        out
    }
}
impl std::fmt::Debug for RenderPassCreateFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(RenderPassCreateFlags);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == RenderPassCreateFlags::empty() {
                    f.write_str("empty")?;
                } else {
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(RenderPassCreateFlags))
            .field(&Flags(*self))
            .finish()
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for RenderPassCreateFlags {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for RenderPassCreateFlags {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkSamplerCreateFlags")]
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct SamplerCreateFlags(u32);
impl SamplerCreateFlags {
    #[doc(alias = "VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT")]
    #[cfg(feature = "VK_EXT_fragment_density_map")]
    pub const SUBSAMPLED_EXT: Self = Self(1);
    #[doc(alias = "VK_SAMPLER_CREATE_SUBSAMPLED_COARSE_RECONSTRUCTION_BIT_EXT")]
    #[cfg(feature = "VK_EXT_fragment_density_map")]
    pub const SUBSAMPLED_COARSE_RECONSTRUCTION_EXT: Self = Self(2);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    #[allow(unused_mut)]
    pub const fn all() -> Self {
        let mut all = Self::empty();
        #[cfg(feature = "VK_EXT_fragment_density_map")]
        {
            all |= Self::SUBSAMPLED_EXT;
        }
        #[cfg(feature = "VK_EXT_fragment_density_map")]
        {
            all |= Self::SUBSAMPLED_COARSE_RECONSTRUCTION_EXT;
        }
        all
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl std::ops::BitOr for SamplerCreateFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl std::ops::BitOrAssign for SamplerCreateFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl std::ops::BitXor for SamplerCreateFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl std::ops::BitXorAssign for SamplerCreateFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl std::ops::BitAnd for SamplerCreateFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl std::ops::BitAndAssign for SamplerCreateFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl std::ops::Sub for SamplerCreateFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl std::ops::SubAssign for SamplerCreateFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl std::ops::Not for SamplerCreateFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl Extend<SamplerCreateFlags> for SamplerCreateFlags {
    fn extend<T: IntoIterator<Item = SamplerCreateFlags>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, i);
        }
    }
}
impl FromIterator<SamplerCreateFlags> for SamplerCreateFlags {
    fn from_iter<T: IntoIterator<Item = SamplerCreateFlags>>(iterator: T) -> SamplerCreateFlags {
        let mut out = Self::empty();
        <Self as Extend<SamplerCreateFlags>>::extend(&mut out, iterator);
        out
    }
}
impl Default for SamplerCreateFlags {
    fn default() -> Self {
        Self::empty()
    }
}
impl From<SamplerCreateFlagBits> for SamplerCreateFlags {
    fn from(bit: SamplerCreateFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(bit.bits()) }
    }
}
impl Extend<SamplerCreateFlagBits> for SamplerCreateFlags {
    fn extend<T: IntoIterator<Item = SamplerCreateFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, Self::from(i));
        }
    }
}
impl FromIterator<SamplerCreateFlagBits> for SamplerCreateFlags {
    fn from_iter<T: IntoIterator<Item = SamplerCreateFlagBits>>(iterator: T) -> SamplerCreateFlags {
        let mut out = Self::empty();
        <Self as Extend<SamplerCreateFlagBits>>::extend(&mut out, iterator);
        out
    }
}
impl std::fmt::Debug for SamplerCreateFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(SamplerCreateFlags);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == SamplerCreateFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    #[cfg(feature = "VK_EXT_fragment_density_map")]
                    if self.0.contains(SamplerCreateFlags::SUBSAMPLED_EXT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(SUBSAMPLED_EXT))?;
                    }
                    #[cfg(feature = "VK_EXT_fragment_density_map")]
                    if self
                        .0
                        .contains(SamplerCreateFlags::SUBSAMPLED_COARSE_RECONSTRUCTION_EXT)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(SUBSAMPLED_COARSE_RECONSTRUCTION_EXT))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(SamplerCreateFlags))
            .field(&Flags(*self))
            .finish()
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for SamplerCreateFlags {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for SamplerCreateFlags {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkPipelineLayoutCreateFlags")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct PipelineLayoutCreateFlags(u32);
impl PipelineLayoutCreateFlags {
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
}
impl Default for PipelineLayoutCreateFlags {
    #[inline]
    fn default() -> Self {
        Self::empty()
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for PipelineLayoutCreateFlags {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for PipelineLayoutCreateFlags {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkPipelineCacheCreateFlags")]
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct PipelineCacheCreateFlags(u32);
impl PipelineCacheCreateFlags {
    #[doc(alias = "VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT")]
    pub const EXTERNALLY_SYNCHRONIZED: Self = Self(1);
    #[doc(alias = "VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT_EXT")]
    pub const EXTERNALLY_SYNCHRONIZED_EXT: Self = Self::EXTERNALLY_SYNCHRONIZED;
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    #[allow(unused_mut)]
    pub const fn all() -> Self {
        let mut all = Self::empty();
        #[cfg(feature = "VULKAN_1_3")]
        {
            all |= Self::EXTERNALLY_SYNCHRONIZED;
        }
        #[cfg(feature = "VK_EXT_pipeline_creation_cache_control")]
        {
            all |= Self::EXTERNALLY_SYNCHRONIZED_EXT;
        }
        all
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl std::ops::BitOr for PipelineCacheCreateFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl std::ops::BitOrAssign for PipelineCacheCreateFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl std::ops::BitXor for PipelineCacheCreateFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl std::ops::BitXorAssign for PipelineCacheCreateFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl std::ops::BitAnd for PipelineCacheCreateFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl std::ops::BitAndAssign for PipelineCacheCreateFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl std::ops::Sub for PipelineCacheCreateFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl std::ops::SubAssign for PipelineCacheCreateFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl std::ops::Not for PipelineCacheCreateFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl Extend<PipelineCacheCreateFlags> for PipelineCacheCreateFlags {
    fn extend<T: IntoIterator<Item = PipelineCacheCreateFlags>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, i);
        }
    }
}
impl FromIterator<PipelineCacheCreateFlags> for PipelineCacheCreateFlags {
    fn from_iter<T: IntoIterator<Item = PipelineCacheCreateFlags>>(iterator: T) -> PipelineCacheCreateFlags {
        let mut out = Self::empty();
        <Self as Extend<PipelineCacheCreateFlags>>::extend(&mut out, iterator);
        out
    }
}
impl Default for PipelineCacheCreateFlags {
    fn default() -> Self {
        Self::empty()
    }
}
#[cfg(feature = "VK_EXT_pipeline_creation_cache_control")]
impl From<PipelineCacheCreateFlagBits> for PipelineCacheCreateFlags {
    fn from(bit: PipelineCacheCreateFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(bit.bits()) }
    }
}
#[cfg(feature = "VK_EXT_pipeline_creation_cache_control")]
impl Extend<PipelineCacheCreateFlagBits> for PipelineCacheCreateFlags {
    fn extend<T: IntoIterator<Item = PipelineCacheCreateFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, Self::from(i));
        }
    }
}
#[cfg(feature = "VK_EXT_pipeline_creation_cache_control")]
impl FromIterator<PipelineCacheCreateFlagBits> for PipelineCacheCreateFlags {
    fn from_iter<T: IntoIterator<Item = PipelineCacheCreateFlagBits>>(iterator: T) -> PipelineCacheCreateFlags {
        let mut out = Self::empty();
        <Self as Extend<PipelineCacheCreateFlagBits>>::extend(&mut out, iterator);
        out
    }
}
impl std::fmt::Debug for PipelineCacheCreateFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(PipelineCacheCreateFlags);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == PipelineCacheCreateFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    #[cfg(feature = "VULKAN_1_3")]
                    if self.0.contains(PipelineCacheCreateFlags::EXTERNALLY_SYNCHRONIZED) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(EXTERNALLY_SYNCHRONIZED))?;
                    }
                    #[cfg(feature = "VK_EXT_pipeline_creation_cache_control")]
                    if self.0.contains(PipelineCacheCreateFlags::EXTERNALLY_SYNCHRONIZED_EXT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(EXTERNALLY_SYNCHRONIZED_EXT))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(PipelineCacheCreateFlags))
            .field(&Flags(*self))
            .finish()
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for PipelineCacheCreateFlags {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for PipelineCacheCreateFlags {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkPipelineDepthStencilStateCreateFlags")]
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct PipelineDepthStencilStateCreateFlags(u32);
impl PipelineDepthStencilStateCreateFlags {
    #[doc(alias = "VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_ARM")]
    pub const RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_ARM: Self = Self(1);
    #[doc(alias = "VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_ARM")]
    pub const RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_ARM: Self = Self(2);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    #[allow(unused_mut)]
    pub const fn all() -> Self {
        let mut all = Self::empty();
        #[cfg(feature = "VK_ARM_rasterization_order_attachment_access")]
        {
            all |= Self::RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_ARM;
        }
        #[cfg(feature = "VK_ARM_rasterization_order_attachment_access")]
        {
            all |= Self::RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_ARM;
        }
        all
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl std::ops::BitOr for PipelineDepthStencilStateCreateFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl std::ops::BitOrAssign for PipelineDepthStencilStateCreateFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl std::ops::BitXor for PipelineDepthStencilStateCreateFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl std::ops::BitXorAssign for PipelineDepthStencilStateCreateFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl std::ops::BitAnd for PipelineDepthStencilStateCreateFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl std::ops::BitAndAssign for PipelineDepthStencilStateCreateFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl std::ops::Sub for PipelineDepthStencilStateCreateFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl std::ops::SubAssign for PipelineDepthStencilStateCreateFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl std::ops::Not for PipelineDepthStencilStateCreateFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl Extend<PipelineDepthStencilStateCreateFlags> for PipelineDepthStencilStateCreateFlags {
    fn extend<T: IntoIterator<Item = PipelineDepthStencilStateCreateFlags>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, i);
        }
    }
}
impl FromIterator<PipelineDepthStencilStateCreateFlags> for PipelineDepthStencilStateCreateFlags {
    fn from_iter<T: IntoIterator<Item = PipelineDepthStencilStateCreateFlags>>(
        iterator: T,
    ) -> PipelineDepthStencilStateCreateFlags {
        let mut out = Self::empty();
        <Self as Extend<PipelineDepthStencilStateCreateFlags>>::extend(&mut out, iterator);
        out
    }
}
impl Default for PipelineDepthStencilStateCreateFlags {
    fn default() -> Self {
        Self::empty()
    }
}
#[cfg(feature = "VK_ARM_rasterization_order_attachment_access")]
impl From<PipelineDepthStencilStateCreateFlagBits> for PipelineDepthStencilStateCreateFlags {
    fn from(bit: PipelineDepthStencilStateCreateFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(bit.bits()) }
    }
}
#[cfg(feature = "VK_ARM_rasterization_order_attachment_access")]
impl Extend<PipelineDepthStencilStateCreateFlagBits> for PipelineDepthStencilStateCreateFlags {
    fn extend<T: IntoIterator<Item = PipelineDepthStencilStateCreateFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, Self::from(i));
        }
    }
}
#[cfg(feature = "VK_ARM_rasterization_order_attachment_access")]
impl FromIterator<PipelineDepthStencilStateCreateFlagBits> for PipelineDepthStencilStateCreateFlags {
    fn from_iter<T: IntoIterator<Item = PipelineDepthStencilStateCreateFlagBits>>(
        iterator: T,
    ) -> PipelineDepthStencilStateCreateFlags {
        let mut out = Self::empty();
        <Self as Extend<PipelineDepthStencilStateCreateFlagBits>>::extend(&mut out, iterator);
        out
    }
}
impl std::fmt::Debug for PipelineDepthStencilStateCreateFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(PipelineDepthStencilStateCreateFlags);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == PipelineDepthStencilStateCreateFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    #[cfg(feature = "VK_ARM_rasterization_order_attachment_access")]
                    if self
                        .0
                        .contains(PipelineDepthStencilStateCreateFlags::RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_ARM)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_ARM))?;
                    }
                    #[cfg(feature = "VK_ARM_rasterization_order_attachment_access")]
                    if self.0.contains(
                        PipelineDepthStencilStateCreateFlags::RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_ARM,
                    ) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_ARM))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(PipelineDepthStencilStateCreateFlags))
            .field(&Flags(*self))
            .finish()
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for PipelineDepthStencilStateCreateFlags {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for PipelineDepthStencilStateCreateFlags {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkPipelineDynamicStateCreateFlags")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct PipelineDynamicStateCreateFlags(u32);
impl PipelineDynamicStateCreateFlags {
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
}
impl Default for PipelineDynamicStateCreateFlags {
    #[inline]
    fn default() -> Self {
        Self::empty()
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for PipelineDynamicStateCreateFlags {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for PipelineDynamicStateCreateFlags {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkPipelineColorBlendStateCreateFlags")]
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct PipelineColorBlendStateCreateFlags(u32);
impl PipelineColorBlendStateCreateFlags {
    #[doc(alias = "VK_PIPELINE_COLOR_BLEND_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_ARM")]
    pub const RASTERIZATION_ORDER_ATTACHMENT_ACCESS_ARM: Self = Self(1);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    #[allow(unused_mut)]
    pub const fn all() -> Self {
        let mut all = Self::empty();
        #[cfg(feature = "VK_ARM_rasterization_order_attachment_access")]
        {
            all |= Self::RASTERIZATION_ORDER_ATTACHMENT_ACCESS_ARM;
        }
        all
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl std::ops::BitOr for PipelineColorBlendStateCreateFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl std::ops::BitOrAssign for PipelineColorBlendStateCreateFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl std::ops::BitXor for PipelineColorBlendStateCreateFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl std::ops::BitXorAssign for PipelineColorBlendStateCreateFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl std::ops::BitAnd for PipelineColorBlendStateCreateFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl std::ops::BitAndAssign for PipelineColorBlendStateCreateFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl std::ops::Sub for PipelineColorBlendStateCreateFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl std::ops::SubAssign for PipelineColorBlendStateCreateFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl std::ops::Not for PipelineColorBlendStateCreateFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl Extend<PipelineColorBlendStateCreateFlags> for PipelineColorBlendStateCreateFlags {
    fn extend<T: IntoIterator<Item = PipelineColorBlendStateCreateFlags>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, i);
        }
    }
}
impl FromIterator<PipelineColorBlendStateCreateFlags> for PipelineColorBlendStateCreateFlags {
    fn from_iter<T: IntoIterator<Item = PipelineColorBlendStateCreateFlags>>(
        iterator: T,
    ) -> PipelineColorBlendStateCreateFlags {
        let mut out = Self::empty();
        <Self as Extend<PipelineColorBlendStateCreateFlags>>::extend(&mut out, iterator);
        out
    }
}
impl Default for PipelineColorBlendStateCreateFlags {
    fn default() -> Self {
        Self::empty()
    }
}
#[cfg(feature = "VK_ARM_rasterization_order_attachment_access")]
impl From<PipelineColorBlendStateCreateFlagBits> for PipelineColorBlendStateCreateFlags {
    fn from(bit: PipelineColorBlendStateCreateFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(bit.bits()) }
    }
}
#[cfg(feature = "VK_ARM_rasterization_order_attachment_access")]
impl Extend<PipelineColorBlendStateCreateFlagBits> for PipelineColorBlendStateCreateFlags {
    fn extend<T: IntoIterator<Item = PipelineColorBlendStateCreateFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, Self::from(i));
        }
    }
}
#[cfg(feature = "VK_ARM_rasterization_order_attachment_access")]
impl FromIterator<PipelineColorBlendStateCreateFlagBits> for PipelineColorBlendStateCreateFlags {
    fn from_iter<T: IntoIterator<Item = PipelineColorBlendStateCreateFlagBits>>(
        iterator: T,
    ) -> PipelineColorBlendStateCreateFlags {
        let mut out = Self::empty();
        <Self as Extend<PipelineColorBlendStateCreateFlagBits>>::extend(&mut out, iterator);
        out
    }
}
impl std::fmt::Debug for PipelineColorBlendStateCreateFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(PipelineColorBlendStateCreateFlags);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == PipelineColorBlendStateCreateFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    #[cfg(feature = "VK_ARM_rasterization_order_attachment_access")]
                    if self
                        .0
                        .contains(PipelineColorBlendStateCreateFlags::RASTERIZATION_ORDER_ATTACHMENT_ACCESS_ARM)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(RASTERIZATION_ORDER_ATTACHMENT_ACCESS_ARM))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(PipelineColorBlendStateCreateFlags))
            .field(&Flags(*self))
            .finish()
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for PipelineColorBlendStateCreateFlags {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for PipelineColorBlendStateCreateFlags {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkPipelineMultisampleStateCreateFlags")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct PipelineMultisampleStateCreateFlags(u32);
impl PipelineMultisampleStateCreateFlags {
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
}
impl Default for PipelineMultisampleStateCreateFlags {
    #[inline]
    fn default() -> Self {
        Self::empty()
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for PipelineMultisampleStateCreateFlags {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for PipelineMultisampleStateCreateFlags {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkPipelineRasterizationStateCreateFlags")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct PipelineRasterizationStateCreateFlags(u32);
impl PipelineRasterizationStateCreateFlags {
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
}
impl Default for PipelineRasterizationStateCreateFlags {
    #[inline]
    fn default() -> Self {
        Self::empty()
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for PipelineRasterizationStateCreateFlags {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for PipelineRasterizationStateCreateFlags {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkPipelineViewportStateCreateFlags")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct PipelineViewportStateCreateFlags(u32);
impl PipelineViewportStateCreateFlags {
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
}
impl Default for PipelineViewportStateCreateFlags {
    #[inline]
    fn default() -> Self {
        Self::empty()
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for PipelineViewportStateCreateFlags {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for PipelineViewportStateCreateFlags {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkPipelineTessellationStateCreateFlags")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct PipelineTessellationStateCreateFlags(u32);
impl PipelineTessellationStateCreateFlags {
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
}
impl Default for PipelineTessellationStateCreateFlags {
    #[inline]
    fn default() -> Self {
        Self::empty()
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for PipelineTessellationStateCreateFlags {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for PipelineTessellationStateCreateFlags {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkPipelineInputAssemblyStateCreateFlags")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct PipelineInputAssemblyStateCreateFlags(u32);
impl PipelineInputAssemblyStateCreateFlags {
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
}
impl Default for PipelineInputAssemblyStateCreateFlags {
    #[inline]
    fn default() -> Self {
        Self::empty()
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for PipelineInputAssemblyStateCreateFlags {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for PipelineInputAssemblyStateCreateFlags {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkPipelineVertexInputStateCreateFlags")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct PipelineVertexInputStateCreateFlags(u32);
impl PipelineVertexInputStateCreateFlags {
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
}
impl Default for PipelineVertexInputStateCreateFlags {
    #[inline]
    fn default() -> Self {
        Self::empty()
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for PipelineVertexInputStateCreateFlags {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for PipelineVertexInputStateCreateFlags {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkPipelineShaderStageCreateFlags")]
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct PipelineShaderStageCreateFlags(u32);
impl PipelineShaderStageCreateFlags {
    #[doc(alias = "VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const ALLOW_VARYING_SUBGROUP_SIZE: Self = Self(1);
    #[doc(alias = "VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const REQUIRE_FULL_SUBGROUPS: Self = Self(2);
    #[doc(alias = "VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT")]
    #[cfg(feature = "VK_EXT_subgroup_size_control")]
    pub const ALLOW_VARYING_SUBGROUP_SIZE_EXT: Self = Self::ALLOW_VARYING_SUBGROUP_SIZE;
    #[doc(alias = "VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT")]
    #[cfg(feature = "VK_EXT_subgroup_size_control")]
    pub const REQUIRE_FULL_SUBGROUPS_EXT: Self = Self::REQUIRE_FULL_SUBGROUPS;
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    #[allow(unused_mut)]
    pub const fn all() -> Self {
        let mut all = Self::empty();
        #[cfg(feature = "VULKAN_1_3")]
        {
            all |= Self::ALLOW_VARYING_SUBGROUP_SIZE;
        }
        #[cfg(feature = "VULKAN_1_3")]
        {
            all |= Self::REQUIRE_FULL_SUBGROUPS;
        }
        #[cfg(feature = "VK_EXT_subgroup_size_control")]
        {
            all |= Self::ALLOW_VARYING_SUBGROUP_SIZE_EXT;
        }
        #[cfg(feature = "VK_EXT_subgroup_size_control")]
        {
            all |= Self::REQUIRE_FULL_SUBGROUPS_EXT;
        }
        all
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl std::ops::BitOr for PipelineShaderStageCreateFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl std::ops::BitOrAssign for PipelineShaderStageCreateFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl std::ops::BitXor for PipelineShaderStageCreateFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl std::ops::BitXorAssign for PipelineShaderStageCreateFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl std::ops::BitAnd for PipelineShaderStageCreateFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl std::ops::BitAndAssign for PipelineShaderStageCreateFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl std::ops::Sub for PipelineShaderStageCreateFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl std::ops::SubAssign for PipelineShaderStageCreateFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl std::ops::Not for PipelineShaderStageCreateFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl Extend<PipelineShaderStageCreateFlags> for PipelineShaderStageCreateFlags {
    fn extend<T: IntoIterator<Item = PipelineShaderStageCreateFlags>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, i);
        }
    }
}
impl FromIterator<PipelineShaderStageCreateFlags> for PipelineShaderStageCreateFlags {
    fn from_iter<T: IntoIterator<Item = PipelineShaderStageCreateFlags>>(
        iterator: T,
    ) -> PipelineShaderStageCreateFlags {
        let mut out = Self::empty();
        <Self as Extend<PipelineShaderStageCreateFlags>>::extend(&mut out, iterator);
        out
    }
}
impl Default for PipelineShaderStageCreateFlags {
    fn default() -> Self {
        Self::empty()
    }
}
impl From<PipelineShaderStageCreateFlagBits> for PipelineShaderStageCreateFlags {
    fn from(bit: PipelineShaderStageCreateFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(bit.bits()) }
    }
}
impl Extend<PipelineShaderStageCreateFlagBits> for PipelineShaderStageCreateFlags {
    fn extend<T: IntoIterator<Item = PipelineShaderStageCreateFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, Self::from(i));
        }
    }
}
impl FromIterator<PipelineShaderStageCreateFlagBits> for PipelineShaderStageCreateFlags {
    fn from_iter<T: IntoIterator<Item = PipelineShaderStageCreateFlagBits>>(
        iterator: T,
    ) -> PipelineShaderStageCreateFlags {
        let mut out = Self::empty();
        <Self as Extend<PipelineShaderStageCreateFlagBits>>::extend(&mut out, iterator);
        out
    }
}
impl std::fmt::Debug for PipelineShaderStageCreateFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(PipelineShaderStageCreateFlags);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == PipelineShaderStageCreateFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    #[cfg(feature = "VULKAN_1_3")]
                    if self
                        .0
                        .contains(PipelineShaderStageCreateFlags::ALLOW_VARYING_SUBGROUP_SIZE)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(ALLOW_VARYING_SUBGROUP_SIZE))?;
                    }
                    #[cfg(feature = "VULKAN_1_3")]
                    if self.0.contains(PipelineShaderStageCreateFlags::REQUIRE_FULL_SUBGROUPS) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(REQUIRE_FULL_SUBGROUPS))?;
                    }
                    #[cfg(feature = "VK_EXT_subgroup_size_control")]
                    if self
                        .0
                        .contains(PipelineShaderStageCreateFlags::ALLOW_VARYING_SUBGROUP_SIZE_EXT)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(ALLOW_VARYING_SUBGROUP_SIZE_EXT))?;
                    }
                    #[cfg(feature = "VK_EXT_subgroup_size_control")]
                    if self
                        .0
                        .contains(PipelineShaderStageCreateFlags::REQUIRE_FULL_SUBGROUPS_EXT)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(REQUIRE_FULL_SUBGROUPS_EXT))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(PipelineShaderStageCreateFlags))
            .field(&Flags(*self))
            .finish()
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for PipelineShaderStageCreateFlags {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for PipelineShaderStageCreateFlags {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkDescriptorSetLayoutCreateFlags")]
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct DescriptorSetLayoutCreateFlags(u32);
impl DescriptorSetLayoutCreateFlags {
    #[doc(alias = "VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT")]
    #[cfg(feature = "VULKAN_1_2")]
    pub const UPDATE_AFTER_BIND_POOL: Self = Self(2);
    #[doc(alias = "VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR")]
    #[cfg(feature = "VK_KHR_push_descriptor")]
    pub const PUSH_DESCRIPTOR_KHR: Self = Self(1);
    #[doc(alias = "VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_VALVE")]
    #[cfg(feature = "VK_VALVE_mutable_descriptor_type")]
    pub const HOST_ONLY_POOL_VALVE: Self = Self(4);
    #[doc(alias = "VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT")]
    #[cfg(feature = "VK_EXT_descriptor_indexing")]
    pub const UPDATE_AFTER_BIND_POOL_EXT: Self = Self::UPDATE_AFTER_BIND_POOL;
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    #[allow(unused_mut)]
    pub const fn all() -> Self {
        let mut all = Self::empty();
        #[cfg(feature = "VULKAN_1_2")]
        {
            all |= Self::UPDATE_AFTER_BIND_POOL;
        }
        #[cfg(feature = "VK_KHR_push_descriptor")]
        {
            all |= Self::PUSH_DESCRIPTOR_KHR;
        }
        #[cfg(feature = "VK_VALVE_mutable_descriptor_type")]
        {
            all |= Self::HOST_ONLY_POOL_VALVE;
        }
        #[cfg(feature = "VK_EXT_descriptor_indexing")]
        {
            all |= Self::UPDATE_AFTER_BIND_POOL_EXT;
        }
        all
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl std::ops::BitOr for DescriptorSetLayoutCreateFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl std::ops::BitOrAssign for DescriptorSetLayoutCreateFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl std::ops::BitXor for DescriptorSetLayoutCreateFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl std::ops::BitXorAssign for DescriptorSetLayoutCreateFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl std::ops::BitAnd for DescriptorSetLayoutCreateFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl std::ops::BitAndAssign for DescriptorSetLayoutCreateFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl std::ops::Sub for DescriptorSetLayoutCreateFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl std::ops::SubAssign for DescriptorSetLayoutCreateFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl std::ops::Not for DescriptorSetLayoutCreateFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl Extend<DescriptorSetLayoutCreateFlags> for DescriptorSetLayoutCreateFlags {
    fn extend<T: IntoIterator<Item = DescriptorSetLayoutCreateFlags>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, i);
        }
    }
}
impl FromIterator<DescriptorSetLayoutCreateFlags> for DescriptorSetLayoutCreateFlags {
    fn from_iter<T: IntoIterator<Item = DescriptorSetLayoutCreateFlags>>(
        iterator: T,
    ) -> DescriptorSetLayoutCreateFlags {
        let mut out = Self::empty();
        <Self as Extend<DescriptorSetLayoutCreateFlags>>::extend(&mut out, iterator);
        out
    }
}
impl Default for DescriptorSetLayoutCreateFlags {
    fn default() -> Self {
        Self::empty()
    }
}
impl From<DescriptorSetLayoutCreateFlagBits> for DescriptorSetLayoutCreateFlags {
    fn from(bit: DescriptorSetLayoutCreateFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(bit.bits()) }
    }
}
impl Extend<DescriptorSetLayoutCreateFlagBits> for DescriptorSetLayoutCreateFlags {
    fn extend<T: IntoIterator<Item = DescriptorSetLayoutCreateFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, Self::from(i));
        }
    }
}
impl FromIterator<DescriptorSetLayoutCreateFlagBits> for DescriptorSetLayoutCreateFlags {
    fn from_iter<T: IntoIterator<Item = DescriptorSetLayoutCreateFlagBits>>(
        iterator: T,
    ) -> DescriptorSetLayoutCreateFlags {
        let mut out = Self::empty();
        <Self as Extend<DescriptorSetLayoutCreateFlagBits>>::extend(&mut out, iterator);
        out
    }
}
impl std::fmt::Debug for DescriptorSetLayoutCreateFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(DescriptorSetLayoutCreateFlags);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == DescriptorSetLayoutCreateFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    #[cfg(feature = "VULKAN_1_2")]
                    if self.0.contains(DescriptorSetLayoutCreateFlags::UPDATE_AFTER_BIND_POOL) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(UPDATE_AFTER_BIND_POOL))?;
                    }
                    #[cfg(feature = "VK_KHR_push_descriptor")]
                    if self.0.contains(DescriptorSetLayoutCreateFlags::PUSH_DESCRIPTOR_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(PUSH_DESCRIPTOR_KHR))?;
                    }
                    #[cfg(feature = "VK_VALVE_mutable_descriptor_type")]
                    if self.0.contains(DescriptorSetLayoutCreateFlags::HOST_ONLY_POOL_VALVE) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(HOST_ONLY_POOL_VALVE))?;
                    }
                    #[cfg(feature = "VK_EXT_descriptor_indexing")]
                    if self
                        .0
                        .contains(DescriptorSetLayoutCreateFlags::UPDATE_AFTER_BIND_POOL_EXT)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(UPDATE_AFTER_BIND_POOL_EXT))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(DescriptorSetLayoutCreateFlags))
            .field(&Flags(*self))
            .finish()
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for DescriptorSetLayoutCreateFlags {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for DescriptorSetLayoutCreateFlags {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkBufferViewCreateFlags")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct BufferViewCreateFlags(u32);
impl BufferViewCreateFlags {
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
}
impl Default for BufferViewCreateFlags {
    #[inline]
    fn default() -> Self {
        Self::empty()
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for BufferViewCreateFlags {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for BufferViewCreateFlags {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkInstanceCreateFlags")]
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct InstanceCreateFlags(u32);
impl InstanceCreateFlags {
    #[doc(alias = "VK_INSTANCE_CREATE_ENUMERATE_PORTABILITY_BIT_KHR")]
    #[cfg(feature = "VK_KHR_portability_enumeration")]
    pub const ENUMERATE_PORTABILITY_KHR: Self = Self(1);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    #[allow(unused_mut)]
    pub const fn all() -> Self {
        let mut all = Self::empty();
        #[cfg(feature = "VK_KHR_portability_enumeration")]
        {
            all |= Self::ENUMERATE_PORTABILITY_KHR;
        }
        all
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl std::ops::BitOr for InstanceCreateFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl std::ops::BitOrAssign for InstanceCreateFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl std::ops::BitXor for InstanceCreateFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl std::ops::BitXorAssign for InstanceCreateFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl std::ops::BitAnd for InstanceCreateFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl std::ops::BitAndAssign for InstanceCreateFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl std::ops::Sub for InstanceCreateFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl std::ops::SubAssign for InstanceCreateFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl std::ops::Not for InstanceCreateFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl Extend<InstanceCreateFlags> for InstanceCreateFlags {
    fn extend<T: IntoIterator<Item = InstanceCreateFlags>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, i);
        }
    }
}
impl FromIterator<InstanceCreateFlags> for InstanceCreateFlags {
    fn from_iter<T: IntoIterator<Item = InstanceCreateFlags>>(iterator: T) -> InstanceCreateFlags {
        let mut out = Self::empty();
        <Self as Extend<InstanceCreateFlags>>::extend(&mut out, iterator);
        out
    }
}
impl Default for InstanceCreateFlags {
    fn default() -> Self {
        Self::empty()
    }
}
impl From<InstanceCreateFlagBits> for InstanceCreateFlags {
    fn from(bit: InstanceCreateFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(bit.bits()) }
    }
}
impl Extend<InstanceCreateFlagBits> for InstanceCreateFlags {
    fn extend<T: IntoIterator<Item = InstanceCreateFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, Self::from(i));
        }
    }
}
impl FromIterator<InstanceCreateFlagBits> for InstanceCreateFlags {
    fn from_iter<T: IntoIterator<Item = InstanceCreateFlagBits>>(iterator: T) -> InstanceCreateFlags {
        let mut out = Self::empty();
        <Self as Extend<InstanceCreateFlagBits>>::extend(&mut out, iterator);
        out
    }
}
impl std::fmt::Debug for InstanceCreateFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(InstanceCreateFlags);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == InstanceCreateFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    #[cfg(feature = "VK_KHR_portability_enumeration")]
                    if self.0.contains(InstanceCreateFlags::ENUMERATE_PORTABILITY_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(ENUMERATE_PORTABILITY_KHR))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(InstanceCreateFlags))
            .field(&Flags(*self))
            .finish()
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for InstanceCreateFlags {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for InstanceCreateFlags {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkDeviceCreateFlags")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct DeviceCreateFlags(u32);
impl DeviceCreateFlags {
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
}
impl Default for DeviceCreateFlags {
    #[inline]
    fn default() -> Self {
        Self::empty()
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for DeviceCreateFlags {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for DeviceCreateFlags {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkDeviceQueueCreateFlags")]
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct DeviceQueueCreateFlags(u32);
impl DeviceQueueCreateFlags {
    #[doc(alias = "VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT")]
    pub const PROTECTED: Self = Self(1);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    #[allow(unused_mut)]
    pub const fn all() -> Self {
        let mut all = Self::empty();
        {
            all |= Self::PROTECTED;
        }
        all
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl std::ops::BitOr for DeviceQueueCreateFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl std::ops::BitOrAssign for DeviceQueueCreateFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl std::ops::BitXor for DeviceQueueCreateFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl std::ops::BitXorAssign for DeviceQueueCreateFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl std::ops::BitAnd for DeviceQueueCreateFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl std::ops::BitAndAssign for DeviceQueueCreateFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl std::ops::Sub for DeviceQueueCreateFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl std::ops::SubAssign for DeviceQueueCreateFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl std::ops::Not for DeviceQueueCreateFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl Extend<DeviceQueueCreateFlags> for DeviceQueueCreateFlags {
    fn extend<T: IntoIterator<Item = DeviceQueueCreateFlags>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, i);
        }
    }
}
impl FromIterator<DeviceQueueCreateFlags> for DeviceQueueCreateFlags {
    fn from_iter<T: IntoIterator<Item = DeviceQueueCreateFlags>>(iterator: T) -> DeviceQueueCreateFlags {
        let mut out = Self::empty();
        <Self as Extend<DeviceQueueCreateFlags>>::extend(&mut out, iterator);
        out
    }
}
impl Default for DeviceQueueCreateFlags {
    fn default() -> Self {
        Self::empty()
    }
}
impl From<DeviceQueueCreateFlagBits> for DeviceQueueCreateFlags {
    fn from(bit: DeviceQueueCreateFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(bit.bits()) }
    }
}
impl Extend<DeviceQueueCreateFlagBits> for DeviceQueueCreateFlags {
    fn extend<T: IntoIterator<Item = DeviceQueueCreateFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, Self::from(i));
        }
    }
}
impl FromIterator<DeviceQueueCreateFlagBits> for DeviceQueueCreateFlags {
    fn from_iter<T: IntoIterator<Item = DeviceQueueCreateFlagBits>>(iterator: T) -> DeviceQueueCreateFlags {
        let mut out = Self::empty();
        <Self as Extend<DeviceQueueCreateFlagBits>>::extend(&mut out, iterator);
        out
    }
}
impl std::fmt::Debug for DeviceQueueCreateFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(DeviceQueueCreateFlags);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == DeviceQueueCreateFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(DeviceQueueCreateFlags::PROTECTED) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(PROTECTED))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(DeviceQueueCreateFlags))
            .field(&Flags(*self))
            .finish()
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for DeviceQueueCreateFlags {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for DeviceQueueCreateFlags {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkQueueFlags")]
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct QueueFlags(u32);
impl QueueFlags {
    #[doc(alias = "VK_QUEUE_GRAPHICS_BIT")]
    pub const GRAPHICS: Self = Self(1);
    #[doc(alias = "VK_QUEUE_COMPUTE_BIT")]
    pub const COMPUTE: Self = Self(2);
    #[doc(alias = "VK_QUEUE_TRANSFER_BIT")]
    pub const TRANSFER: Self = Self(4);
    #[doc(alias = "VK_QUEUE_SPARSE_BINDING_BIT")]
    pub const SPARSE_BINDING: Self = Self(8);
    #[doc(alias = "VK_QUEUE_PROTECTED_BIT")]
    pub const PROTECTED: Self = Self(16);
    #[doc(alias = "VK_QUEUE_VIDEO_DECODE_BIT_KHR")]
    #[cfg(feature = "VK_KHR_video_decode_queue")]
    pub const VIDEO_DECODE_KHR: Self = Self(32);
    #[doc(alias = "VK_QUEUE_VIDEO_ENCODE_BIT_KHR")]
    #[cfg(feature = "VK_KHR_video_encode_queue")]
    pub const VIDEO_ENCODE_KHR: Self = Self(64);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    #[allow(unused_mut)]
    pub const fn all() -> Self {
        let mut all = Self::empty();
        {
            all |= Self::GRAPHICS;
        }
        {
            all |= Self::COMPUTE;
        }
        {
            all |= Self::TRANSFER;
        }
        {
            all |= Self::SPARSE_BINDING;
        }
        {
            all |= Self::PROTECTED;
        }
        #[cfg(feature = "VK_KHR_video_decode_queue")]
        {
            all |= Self::VIDEO_DECODE_KHR;
        }
        #[cfg(feature = "VK_KHR_video_encode_queue")]
        {
            all |= Self::VIDEO_ENCODE_KHR;
        }
        all
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl std::ops::BitOr for QueueFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl std::ops::BitOrAssign for QueueFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl std::ops::BitXor for QueueFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl std::ops::BitXorAssign for QueueFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl std::ops::BitAnd for QueueFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl std::ops::BitAndAssign for QueueFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl std::ops::Sub for QueueFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl std::ops::SubAssign for QueueFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl std::ops::Not for QueueFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl Extend<QueueFlags> for QueueFlags {
    fn extend<T: IntoIterator<Item = QueueFlags>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, i);
        }
    }
}
impl FromIterator<QueueFlags> for QueueFlags {
    fn from_iter<T: IntoIterator<Item = QueueFlags>>(iterator: T) -> QueueFlags {
        let mut out = Self::empty();
        <Self as Extend<QueueFlags>>::extend(&mut out, iterator);
        out
    }
}
impl Default for QueueFlags {
    fn default() -> Self {
        Self::empty()
    }
}
impl From<QueueFlagBits> for QueueFlags {
    fn from(bit: QueueFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(bit.bits()) }
    }
}
impl Extend<QueueFlagBits> for QueueFlags {
    fn extend<T: IntoIterator<Item = QueueFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, Self::from(i));
        }
    }
}
impl FromIterator<QueueFlagBits> for QueueFlags {
    fn from_iter<T: IntoIterator<Item = QueueFlagBits>>(iterator: T) -> QueueFlags {
        let mut out = Self::empty();
        <Self as Extend<QueueFlagBits>>::extend(&mut out, iterator);
        out
    }
}
impl std::fmt::Debug for QueueFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(QueueFlags);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == QueueFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(QueueFlags::GRAPHICS) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(GRAPHICS))?;
                    }
                    if self.0.contains(QueueFlags::COMPUTE) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(COMPUTE))?;
                    }
                    if self.0.contains(QueueFlags::TRANSFER) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(TRANSFER))?;
                    }
                    if self.0.contains(QueueFlags::SPARSE_BINDING) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(SPARSE_BINDING))?;
                    }
                    if self.0.contains(QueueFlags::PROTECTED) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(PROTECTED))?;
                    }
                    #[cfg(feature = "VK_KHR_video_decode_queue")]
                    if self.0.contains(QueueFlags::VIDEO_DECODE_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(VIDEO_DECODE_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_video_encode_queue")]
                    if self.0.contains(QueueFlags::VIDEO_ENCODE_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(VIDEO_ENCODE_KHR))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(QueueFlags)).field(&Flags(*self)).finish()
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for QueueFlags {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for QueueFlags {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkMemoryPropertyFlags")]
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct MemoryPropertyFlags(u32);
impl MemoryPropertyFlags {
    #[doc(alias = "VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT")]
    pub const DEVICE_LOCAL: Self = Self(1);
    #[doc(alias = "VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT")]
    pub const HOST_VISIBLE: Self = Self(2);
    #[doc(alias = "VK_MEMORY_PROPERTY_HOST_COHERENT_BIT")]
    pub const HOST_COHERENT: Self = Self(4);
    #[doc(alias = "VK_MEMORY_PROPERTY_HOST_CACHED_BIT")]
    pub const HOST_CACHED: Self = Self(8);
    #[doc(alias = "VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT")]
    pub const LAZILY_ALLOCATED: Self = Self(16);
    #[doc(alias = "VK_MEMORY_PROPERTY_PROTECTED_BIT")]
    pub const PROTECTED: Self = Self(32);
    #[doc(alias = "VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD")]
    #[cfg(feature = "VK_AMD_device_coherent_memory")]
    pub const DEVICE_COHERENT_AMD: Self = Self(64);
    #[doc(alias = "VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD")]
    #[cfg(feature = "VK_AMD_device_coherent_memory")]
    pub const DEVICE_UNCACHED_AMD: Self = Self(128);
    #[doc(alias = "VK_MEMORY_PROPERTY_RDMA_CAPABLE_BIT_NV")]
    #[cfg(feature = "VK_NV_external_memory_rdma")]
    pub const RDMA_CAPABLE_NV: Self = Self(256);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    #[allow(unused_mut)]
    pub const fn all() -> Self {
        let mut all = Self::empty();
        {
            all |= Self::DEVICE_LOCAL;
        }
        {
            all |= Self::HOST_VISIBLE;
        }
        {
            all |= Self::HOST_COHERENT;
        }
        {
            all |= Self::HOST_CACHED;
        }
        {
            all |= Self::LAZILY_ALLOCATED;
        }
        {
            all |= Self::PROTECTED;
        }
        #[cfg(feature = "VK_AMD_device_coherent_memory")]
        {
            all |= Self::DEVICE_COHERENT_AMD;
        }
        #[cfg(feature = "VK_AMD_device_coherent_memory")]
        {
            all |= Self::DEVICE_UNCACHED_AMD;
        }
        #[cfg(feature = "VK_NV_external_memory_rdma")]
        {
            all |= Self::RDMA_CAPABLE_NV;
        }
        all
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl std::ops::BitOr for MemoryPropertyFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl std::ops::BitOrAssign for MemoryPropertyFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl std::ops::BitXor for MemoryPropertyFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl std::ops::BitXorAssign for MemoryPropertyFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl std::ops::BitAnd for MemoryPropertyFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl std::ops::BitAndAssign for MemoryPropertyFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl std::ops::Sub for MemoryPropertyFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl std::ops::SubAssign for MemoryPropertyFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl std::ops::Not for MemoryPropertyFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl Extend<MemoryPropertyFlags> for MemoryPropertyFlags {
    fn extend<T: IntoIterator<Item = MemoryPropertyFlags>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, i);
        }
    }
}
impl FromIterator<MemoryPropertyFlags> for MemoryPropertyFlags {
    fn from_iter<T: IntoIterator<Item = MemoryPropertyFlags>>(iterator: T) -> MemoryPropertyFlags {
        let mut out = Self::empty();
        <Self as Extend<MemoryPropertyFlags>>::extend(&mut out, iterator);
        out
    }
}
impl Default for MemoryPropertyFlags {
    fn default() -> Self {
        Self::empty()
    }
}
impl From<MemoryPropertyFlagBits> for MemoryPropertyFlags {
    fn from(bit: MemoryPropertyFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(bit.bits()) }
    }
}
impl Extend<MemoryPropertyFlagBits> for MemoryPropertyFlags {
    fn extend<T: IntoIterator<Item = MemoryPropertyFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, Self::from(i));
        }
    }
}
impl FromIterator<MemoryPropertyFlagBits> for MemoryPropertyFlags {
    fn from_iter<T: IntoIterator<Item = MemoryPropertyFlagBits>>(iterator: T) -> MemoryPropertyFlags {
        let mut out = Self::empty();
        <Self as Extend<MemoryPropertyFlagBits>>::extend(&mut out, iterator);
        out
    }
}
impl std::fmt::Debug for MemoryPropertyFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(MemoryPropertyFlags);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == MemoryPropertyFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(MemoryPropertyFlags::DEVICE_LOCAL) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(DEVICE_LOCAL))?;
                    }
                    if self.0.contains(MemoryPropertyFlags::HOST_VISIBLE) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(HOST_VISIBLE))?;
                    }
                    if self.0.contains(MemoryPropertyFlags::HOST_COHERENT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(HOST_COHERENT))?;
                    }
                    if self.0.contains(MemoryPropertyFlags::HOST_CACHED) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(HOST_CACHED))?;
                    }
                    if self.0.contains(MemoryPropertyFlags::LAZILY_ALLOCATED) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(LAZILY_ALLOCATED))?;
                    }
                    if self.0.contains(MemoryPropertyFlags::PROTECTED) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(PROTECTED))?;
                    }
                    #[cfg(feature = "VK_AMD_device_coherent_memory")]
                    if self.0.contains(MemoryPropertyFlags::DEVICE_COHERENT_AMD) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(DEVICE_COHERENT_AMD))?;
                    }
                    #[cfg(feature = "VK_AMD_device_coherent_memory")]
                    if self.0.contains(MemoryPropertyFlags::DEVICE_UNCACHED_AMD) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(DEVICE_UNCACHED_AMD))?;
                    }
                    #[cfg(feature = "VK_NV_external_memory_rdma")]
                    if self.0.contains(MemoryPropertyFlags::RDMA_CAPABLE_NV) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(RDMA_CAPABLE_NV))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(MemoryPropertyFlags))
            .field(&Flags(*self))
            .finish()
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for MemoryPropertyFlags {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for MemoryPropertyFlags {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkMemoryHeapFlags")]
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct MemoryHeapFlags(u32);
impl MemoryHeapFlags {
    #[doc(alias = "VK_MEMORY_HEAP_DEVICE_LOCAL_BIT")]
    pub const DEVICE_LOCAL: Self = Self(1);
    #[doc(alias = "VK_MEMORY_HEAP_MULTI_INSTANCE_BIT")]
    pub const MULTI_INSTANCE: Self = Self(2);
    #[doc(alias = "VK_MEMORY_HEAP_MULTI_INSTANCE_BIT_KHR")]
    #[cfg(feature = "VK_KHR_device_group_creation")]
    pub const MULTI_INSTANCE_KHR: Self = Self::MULTI_INSTANCE;
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    #[allow(unused_mut)]
    pub const fn all() -> Self {
        let mut all = Self::empty();
        {
            all |= Self::DEVICE_LOCAL;
        }
        {
            all |= Self::MULTI_INSTANCE;
        }
        #[cfg(feature = "VK_KHR_device_group_creation")]
        {
            all |= Self::MULTI_INSTANCE_KHR;
        }
        all
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl std::ops::BitOr for MemoryHeapFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl std::ops::BitOrAssign for MemoryHeapFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl std::ops::BitXor for MemoryHeapFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl std::ops::BitXorAssign for MemoryHeapFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl std::ops::BitAnd for MemoryHeapFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl std::ops::BitAndAssign for MemoryHeapFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl std::ops::Sub for MemoryHeapFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl std::ops::SubAssign for MemoryHeapFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl std::ops::Not for MemoryHeapFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl Extend<MemoryHeapFlags> for MemoryHeapFlags {
    fn extend<T: IntoIterator<Item = MemoryHeapFlags>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, i);
        }
    }
}
impl FromIterator<MemoryHeapFlags> for MemoryHeapFlags {
    fn from_iter<T: IntoIterator<Item = MemoryHeapFlags>>(iterator: T) -> MemoryHeapFlags {
        let mut out = Self::empty();
        <Self as Extend<MemoryHeapFlags>>::extend(&mut out, iterator);
        out
    }
}
impl Default for MemoryHeapFlags {
    fn default() -> Self {
        Self::empty()
    }
}
impl From<MemoryHeapFlagBits> for MemoryHeapFlags {
    fn from(bit: MemoryHeapFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(bit.bits()) }
    }
}
impl Extend<MemoryHeapFlagBits> for MemoryHeapFlags {
    fn extend<T: IntoIterator<Item = MemoryHeapFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, Self::from(i));
        }
    }
}
impl FromIterator<MemoryHeapFlagBits> for MemoryHeapFlags {
    fn from_iter<T: IntoIterator<Item = MemoryHeapFlagBits>>(iterator: T) -> MemoryHeapFlags {
        let mut out = Self::empty();
        <Self as Extend<MemoryHeapFlagBits>>::extend(&mut out, iterator);
        out
    }
}
impl std::fmt::Debug for MemoryHeapFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(MemoryHeapFlags);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == MemoryHeapFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(MemoryHeapFlags::DEVICE_LOCAL) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(DEVICE_LOCAL))?;
                    }
                    if self.0.contains(MemoryHeapFlags::MULTI_INSTANCE) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(MULTI_INSTANCE))?;
                    }
                    #[cfg(feature = "VK_KHR_device_group_creation")]
                    if self.0.contains(MemoryHeapFlags::MULTI_INSTANCE_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(MULTI_INSTANCE_KHR))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(MemoryHeapFlags)).field(&Flags(*self)).finish()
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for MemoryHeapFlags {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for MemoryHeapFlags {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkAccessFlags")]
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct AccessFlags(u32);
impl AccessFlags {
    #[doc(alias = "VK_ACCESS_INDIRECT_COMMAND_READ_BIT")]
    pub const INDIRECT_COMMAND_READ: Self = Self(1);
    #[doc(alias = "VK_ACCESS_INDEX_READ_BIT")]
    pub const INDEX_READ: Self = Self(2);
    #[doc(alias = "VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT")]
    pub const VERTEX_ATTRIBUTE_READ: Self = Self(4);
    #[doc(alias = "VK_ACCESS_UNIFORM_READ_BIT")]
    pub const UNIFORM_READ: Self = Self(8);
    #[doc(alias = "VK_ACCESS_INPUT_ATTACHMENT_READ_BIT")]
    pub const INPUT_ATTACHMENT_READ: Self = Self(16);
    #[doc(alias = "VK_ACCESS_SHADER_READ_BIT")]
    pub const SHADER_READ: Self = Self(32);
    #[doc(alias = "VK_ACCESS_SHADER_WRITE_BIT")]
    pub const SHADER_WRITE: Self = Self(64);
    #[doc(alias = "VK_ACCESS_COLOR_ATTACHMENT_READ_BIT")]
    pub const COLOR_ATTACHMENT_READ: Self = Self(128);
    #[doc(alias = "VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT")]
    pub const COLOR_ATTACHMENT_WRITE: Self = Self(256);
    #[doc(alias = "VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT")]
    pub const DEPTH_STENCIL_ATTACHMENT_READ: Self = Self(512);
    #[doc(alias = "VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT")]
    pub const DEPTH_STENCIL_ATTACHMENT_WRITE: Self = Self(1024);
    #[doc(alias = "VK_ACCESS_TRANSFER_READ_BIT")]
    pub const TRANSFER_READ: Self = Self(2048);
    #[doc(alias = "VK_ACCESS_TRANSFER_WRITE_BIT")]
    pub const TRANSFER_WRITE: Self = Self(4096);
    #[doc(alias = "VK_ACCESS_HOST_READ_BIT")]
    pub const HOST_READ: Self = Self(8192);
    #[doc(alias = "VK_ACCESS_HOST_WRITE_BIT")]
    pub const HOST_WRITE: Self = Self(16384);
    #[doc(alias = "VK_ACCESS_MEMORY_READ_BIT")]
    pub const MEMORY_READ: Self = Self(32768);
    #[doc(alias = "VK_ACCESS_MEMORY_WRITE_BIT")]
    pub const MEMORY_WRITE: Self = Self(65536);
    #[doc(alias = "VK_ACCESS_NONE")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const NONE: Self = Self(0);
    #[doc(alias = "VK_ACCESS_TRANSFORM_FEEDBACK_WRITE_BIT_EXT")]
    #[cfg(feature = "VK_EXT_transform_feedback")]
    pub const TRANSFORM_FEEDBACK_WRITE_EXT: Self = Self(33554432);
    #[doc(alias = "VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT")]
    #[cfg(feature = "VK_EXT_transform_feedback")]
    pub const TRANSFORM_FEEDBACK_COUNTER_READ_EXT: Self = Self(67108864);
    #[doc(alias = "VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT")]
    #[cfg(feature = "VK_EXT_transform_feedback")]
    pub const TRANSFORM_FEEDBACK_COUNTER_WRITE_EXT: Self = Self(134217728);
    #[doc(alias = "VK_ACCESS_CONDITIONAL_RENDERING_READ_BIT_EXT")]
    #[cfg(feature = "VK_EXT_conditional_rendering")]
    pub const CONDITIONAL_RENDERING_READ_EXT: Self = Self(1048576);
    #[doc(alias = "VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    pub const COLOR_ATTACHMENT_READ_NONCOHERENT_EXT: Self = Self(524288);
    #[doc(alias = "VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR")]
    #[cfg(feature = "VK_KHR_acceleration_structure")]
    pub const ACCELERATION_STRUCTURE_READ_KHR: Self = Self(2097152);
    #[doc(alias = "VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR")]
    #[cfg(feature = "VK_KHR_acceleration_structure")]
    pub const ACCELERATION_STRUCTURE_WRITE_KHR: Self = Self(4194304);
    #[doc(alias = "VK_ACCESS_FRAGMENT_DENSITY_MAP_READ_BIT_EXT")]
    #[cfg(feature = "VK_EXT_fragment_density_map")]
    pub const FRAGMENT_DENSITY_MAP_READ_EXT: Self = Self(16777216);
    #[doc(alias = "VK_ACCESS_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR")]
    #[cfg(feature = "VK_KHR_fragment_shading_rate")]
    pub const FRAGMENT_SHADING_RATE_ATTACHMENT_READ_KHR: Self = Self(8388608);
    #[doc(alias = "VK_ACCESS_COMMAND_PREPROCESS_READ_BIT_NV")]
    #[cfg(feature = "VK_NV_device_generated_commands")]
    pub const COMMAND_PREPROCESS_READ_NV: Self = Self(131072);
    #[doc(alias = "VK_ACCESS_COMMAND_PREPROCESS_WRITE_BIT_NV")]
    #[cfg(feature = "VK_NV_device_generated_commands")]
    pub const COMMAND_PREPROCESS_WRITE_NV: Self = Self(262144);
    #[doc(alias = "VK_ACCESS_SHADING_RATE_IMAGE_READ_BIT_NV")]
    #[cfg(feature = "VK_NV_shading_rate_image")]
    pub const SHADING_RATE_IMAGE_READ_NV: Self = Self::FRAGMENT_SHADING_RATE_ATTACHMENT_READ_KHR;
    #[doc(alias = "VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_NV")]
    #[cfg(feature = "VK_NV_ray_tracing")]
    pub const ACCELERATION_STRUCTURE_READ_NV: Self = Self::ACCELERATION_STRUCTURE_READ_KHR;
    #[doc(alias = "VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_NV")]
    #[cfg(feature = "VK_NV_ray_tracing")]
    pub const ACCELERATION_STRUCTURE_WRITE_NV: Self = Self::ACCELERATION_STRUCTURE_WRITE_KHR;
    #[doc(alias = "VK_ACCESS_NONE_KHR")]
    #[cfg(feature = "VK_KHR_synchronization2")]
    pub const NONE_KHR: Self = Self::NONE;
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    #[allow(unused_mut)]
    pub const fn all() -> Self {
        let mut all = Self::empty();
        {
            all |= Self::INDIRECT_COMMAND_READ;
        }
        {
            all |= Self::INDEX_READ;
        }
        {
            all |= Self::VERTEX_ATTRIBUTE_READ;
        }
        {
            all |= Self::UNIFORM_READ;
        }
        {
            all |= Self::INPUT_ATTACHMENT_READ;
        }
        {
            all |= Self::SHADER_READ;
        }
        {
            all |= Self::SHADER_WRITE;
        }
        {
            all |= Self::COLOR_ATTACHMENT_READ;
        }
        {
            all |= Self::COLOR_ATTACHMENT_WRITE;
        }
        {
            all |= Self::DEPTH_STENCIL_ATTACHMENT_READ;
        }
        {
            all |= Self::DEPTH_STENCIL_ATTACHMENT_WRITE;
        }
        {
            all |= Self::TRANSFER_READ;
        }
        {
            all |= Self::TRANSFER_WRITE;
        }
        {
            all |= Self::HOST_READ;
        }
        {
            all |= Self::HOST_WRITE;
        }
        {
            all |= Self::MEMORY_READ;
        }
        {
            all |= Self::MEMORY_WRITE;
        }
        #[cfg(feature = "VULKAN_1_3")]
        {
            all |= Self::NONE;
        }
        #[cfg(feature = "VK_EXT_transform_feedback")]
        {
            all |= Self::TRANSFORM_FEEDBACK_WRITE_EXT;
        }
        #[cfg(feature = "VK_EXT_transform_feedback")]
        {
            all |= Self::TRANSFORM_FEEDBACK_COUNTER_READ_EXT;
        }
        #[cfg(feature = "VK_EXT_transform_feedback")]
        {
            all |= Self::TRANSFORM_FEEDBACK_COUNTER_WRITE_EXT;
        }
        #[cfg(feature = "VK_EXT_conditional_rendering")]
        {
            all |= Self::CONDITIONAL_RENDERING_READ_EXT;
        }
        #[cfg(feature = "VK_EXT_blend_operation_advanced")]
        {
            all |= Self::COLOR_ATTACHMENT_READ_NONCOHERENT_EXT;
        }
        #[cfg(feature = "VK_KHR_acceleration_structure")]
        {
            all |= Self::ACCELERATION_STRUCTURE_READ_KHR;
        }
        #[cfg(feature = "VK_KHR_acceleration_structure")]
        {
            all |= Self::ACCELERATION_STRUCTURE_WRITE_KHR;
        }
        #[cfg(feature = "VK_EXT_fragment_density_map")]
        {
            all |= Self::FRAGMENT_DENSITY_MAP_READ_EXT;
        }
        #[cfg(feature = "VK_KHR_fragment_shading_rate")]
        {
            all |= Self::FRAGMENT_SHADING_RATE_ATTACHMENT_READ_KHR;
        }
        #[cfg(feature = "VK_NV_device_generated_commands")]
        {
            all |= Self::COMMAND_PREPROCESS_READ_NV;
        }
        #[cfg(feature = "VK_NV_device_generated_commands")]
        {
            all |= Self::COMMAND_PREPROCESS_WRITE_NV;
        }
        #[cfg(feature = "VK_NV_shading_rate_image")]
        {
            all |= Self::SHADING_RATE_IMAGE_READ_NV;
        }
        #[cfg(feature = "VK_NV_ray_tracing")]
        {
            all |= Self::ACCELERATION_STRUCTURE_READ_NV;
        }
        #[cfg(feature = "VK_NV_ray_tracing")]
        {
            all |= Self::ACCELERATION_STRUCTURE_WRITE_NV;
        }
        #[cfg(feature = "VK_KHR_synchronization2")]
        {
            all |= Self::NONE_KHR;
        }
        all
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl std::ops::BitOr for AccessFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl std::ops::BitOrAssign for AccessFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl std::ops::BitXor for AccessFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl std::ops::BitXorAssign for AccessFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl std::ops::BitAnd for AccessFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl std::ops::BitAndAssign for AccessFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl std::ops::Sub for AccessFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl std::ops::SubAssign for AccessFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl std::ops::Not for AccessFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl Extend<AccessFlags> for AccessFlags {
    fn extend<T: IntoIterator<Item = AccessFlags>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, i);
        }
    }
}
impl FromIterator<AccessFlags> for AccessFlags {
    fn from_iter<T: IntoIterator<Item = AccessFlags>>(iterator: T) -> AccessFlags {
        let mut out = Self::empty();
        <Self as Extend<AccessFlags>>::extend(&mut out, iterator);
        out
    }
}
impl Default for AccessFlags {
    fn default() -> Self {
        Self::empty()
    }
}
impl From<AccessFlagBits> for AccessFlags {
    fn from(bit: AccessFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(bit.bits()) }
    }
}
impl Extend<AccessFlagBits> for AccessFlags {
    fn extend<T: IntoIterator<Item = AccessFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, Self::from(i));
        }
    }
}
impl FromIterator<AccessFlagBits> for AccessFlags {
    fn from_iter<T: IntoIterator<Item = AccessFlagBits>>(iterator: T) -> AccessFlags {
        let mut out = Self::empty();
        <Self as Extend<AccessFlagBits>>::extend(&mut out, iterator);
        out
    }
}
impl std::fmt::Debug for AccessFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(AccessFlags);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == AccessFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(AccessFlags::INDIRECT_COMMAND_READ) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(INDIRECT_COMMAND_READ))?;
                    }
                    if self.0.contains(AccessFlags::INDEX_READ) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(INDEX_READ))?;
                    }
                    if self.0.contains(AccessFlags::VERTEX_ATTRIBUTE_READ) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(VERTEX_ATTRIBUTE_READ))?;
                    }
                    if self.0.contains(AccessFlags::UNIFORM_READ) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(UNIFORM_READ))?;
                    }
                    if self.0.contains(AccessFlags::INPUT_ATTACHMENT_READ) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(INPUT_ATTACHMENT_READ))?;
                    }
                    if self.0.contains(AccessFlags::SHADER_READ) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(SHADER_READ))?;
                    }
                    if self.0.contains(AccessFlags::SHADER_WRITE) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(SHADER_WRITE))?;
                    }
                    if self.0.contains(AccessFlags::COLOR_ATTACHMENT_READ) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(COLOR_ATTACHMENT_READ))?;
                    }
                    if self.0.contains(AccessFlags::COLOR_ATTACHMENT_WRITE) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(COLOR_ATTACHMENT_WRITE))?;
                    }
                    if self.0.contains(AccessFlags::DEPTH_STENCIL_ATTACHMENT_READ) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(DEPTH_STENCIL_ATTACHMENT_READ))?;
                    }
                    if self.0.contains(AccessFlags::DEPTH_STENCIL_ATTACHMENT_WRITE) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(DEPTH_STENCIL_ATTACHMENT_WRITE))?;
                    }
                    if self.0.contains(AccessFlags::TRANSFER_READ) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(TRANSFER_READ))?;
                    }
                    if self.0.contains(AccessFlags::TRANSFER_WRITE) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(TRANSFER_WRITE))?;
                    }
                    if self.0.contains(AccessFlags::HOST_READ) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(HOST_READ))?;
                    }
                    if self.0.contains(AccessFlags::HOST_WRITE) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(HOST_WRITE))?;
                    }
                    if self.0.contains(AccessFlags::MEMORY_READ) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(MEMORY_READ))?;
                    }
                    if self.0.contains(AccessFlags::MEMORY_WRITE) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(MEMORY_WRITE))?;
                    }
                    #[cfg(feature = "VULKAN_1_3")]
                    if self.0.contains(AccessFlags::NONE) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(NONE))?;
                    }
                    #[cfg(feature = "VK_EXT_transform_feedback")]
                    if self.0.contains(AccessFlags::TRANSFORM_FEEDBACK_WRITE_EXT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(TRANSFORM_FEEDBACK_WRITE_EXT))?;
                    }
                    #[cfg(feature = "VK_EXT_transform_feedback")]
                    if self.0.contains(AccessFlags::TRANSFORM_FEEDBACK_COUNTER_READ_EXT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(TRANSFORM_FEEDBACK_COUNTER_READ_EXT))?;
                    }
                    #[cfg(feature = "VK_EXT_transform_feedback")]
                    if self.0.contains(AccessFlags::TRANSFORM_FEEDBACK_COUNTER_WRITE_EXT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(TRANSFORM_FEEDBACK_COUNTER_WRITE_EXT))?;
                    }
                    #[cfg(feature = "VK_EXT_conditional_rendering")]
                    if self.0.contains(AccessFlags::CONDITIONAL_RENDERING_READ_EXT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(CONDITIONAL_RENDERING_READ_EXT))?;
                    }
                    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
                    if self.0.contains(AccessFlags::COLOR_ATTACHMENT_READ_NONCOHERENT_EXT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(COLOR_ATTACHMENT_READ_NONCOHERENT_EXT))?;
                    }
                    #[cfg(feature = "VK_KHR_acceleration_structure")]
                    if self.0.contains(AccessFlags::ACCELERATION_STRUCTURE_READ_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(ACCELERATION_STRUCTURE_READ_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_acceleration_structure")]
                    if self.0.contains(AccessFlags::ACCELERATION_STRUCTURE_WRITE_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(ACCELERATION_STRUCTURE_WRITE_KHR))?;
                    }
                    #[cfg(feature = "VK_EXT_fragment_density_map")]
                    if self.0.contains(AccessFlags::FRAGMENT_DENSITY_MAP_READ_EXT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(FRAGMENT_DENSITY_MAP_READ_EXT))?;
                    }
                    #[cfg(feature = "VK_KHR_fragment_shading_rate")]
                    if self.0.contains(AccessFlags::FRAGMENT_SHADING_RATE_ATTACHMENT_READ_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(FRAGMENT_SHADING_RATE_ATTACHMENT_READ_KHR))?;
                    }
                    #[cfg(feature = "VK_NV_device_generated_commands")]
                    if self.0.contains(AccessFlags::COMMAND_PREPROCESS_READ_NV) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(COMMAND_PREPROCESS_READ_NV))?;
                    }
                    #[cfg(feature = "VK_NV_device_generated_commands")]
                    if self.0.contains(AccessFlags::COMMAND_PREPROCESS_WRITE_NV) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(COMMAND_PREPROCESS_WRITE_NV))?;
                    }
                    #[cfg(feature = "VK_NV_shading_rate_image")]
                    if self.0.contains(AccessFlags::SHADING_RATE_IMAGE_READ_NV) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(SHADING_RATE_IMAGE_READ_NV))?;
                    }
                    #[cfg(feature = "VK_NV_ray_tracing")]
                    if self.0.contains(AccessFlags::ACCELERATION_STRUCTURE_READ_NV) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(ACCELERATION_STRUCTURE_READ_NV))?;
                    }
                    #[cfg(feature = "VK_NV_ray_tracing")]
                    if self.0.contains(AccessFlags::ACCELERATION_STRUCTURE_WRITE_NV) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(ACCELERATION_STRUCTURE_WRITE_NV))?;
                    }
                    #[cfg(feature = "VK_KHR_synchronization2")]
                    if self.0.contains(AccessFlags::NONE_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(NONE_KHR))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(AccessFlags)).field(&Flags(*self)).finish()
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for AccessFlags {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for AccessFlags {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkBufferUsageFlags")]
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct BufferUsageFlags(u32);
impl BufferUsageFlags {
    #[doc(alias = "VK_BUFFER_USAGE_TRANSFER_SRC_BIT")]
    pub const TRANSFER_SRC: Self = Self(1);
    #[doc(alias = "VK_BUFFER_USAGE_TRANSFER_DST_BIT")]
    pub const TRANSFER_DST: Self = Self(2);
    #[doc(alias = "VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT")]
    pub const UNIFORM_TEXEL_BUFFER: Self = Self(4);
    #[doc(alias = "VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT")]
    pub const STORAGE_TEXEL_BUFFER: Self = Self(8);
    #[doc(alias = "VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT")]
    pub const UNIFORM_BUFFER: Self = Self(16);
    #[doc(alias = "VK_BUFFER_USAGE_STORAGE_BUFFER_BIT")]
    pub const STORAGE_BUFFER: Self = Self(32);
    #[doc(alias = "VK_BUFFER_USAGE_INDEX_BUFFER_BIT")]
    pub const INDEX_BUFFER: Self = Self(64);
    #[doc(alias = "VK_BUFFER_USAGE_VERTEX_BUFFER_BIT")]
    pub const VERTEX_BUFFER: Self = Self(128);
    #[doc(alias = "VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT")]
    pub const INDIRECT_BUFFER: Self = Self(256);
    #[doc(alias = "VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT")]
    #[cfg(feature = "VULKAN_1_2")]
    pub const SHADER_DEVICE_ADDRESS: Self = Self(131072);
    #[doc(alias = "VK_BUFFER_USAGE_VIDEO_DECODE_SRC_BIT_KHR")]
    #[cfg(feature = "VK_KHR_video_decode_queue")]
    pub const VIDEO_DECODE_SRC_KHR: Self = Self(8192);
    #[doc(alias = "VK_BUFFER_USAGE_VIDEO_DECODE_DST_BIT_KHR")]
    #[cfg(feature = "VK_KHR_video_decode_queue")]
    pub const VIDEO_DECODE_DST_KHR: Self = Self(16384);
    #[doc(alias = "VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT")]
    #[cfg(feature = "VK_EXT_transform_feedback")]
    pub const TRANSFORM_FEEDBACK_BUFFER_EXT: Self = Self(2048);
    #[doc(alias = "VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT")]
    #[cfg(feature = "VK_EXT_transform_feedback")]
    pub const TRANSFORM_FEEDBACK_COUNTER_BUFFER_EXT: Self = Self(4096);
    #[doc(alias = "VK_BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT")]
    #[cfg(feature = "VK_EXT_conditional_rendering")]
    pub const CONDITIONAL_RENDERING_EXT: Self = Self(512);
    #[doc(alias = "VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR")]
    #[cfg(feature = "VK_KHR_acceleration_structure")]
    pub const ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_KHR: Self = Self(524288);
    #[doc(alias = "VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR")]
    #[cfg(feature = "VK_KHR_acceleration_structure")]
    pub const ACCELERATION_STRUCTURE_STORAGE_KHR: Self = Self(1048576);
    #[doc(alias = "VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR")]
    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
    pub const SHADER_BINDING_TABLE_KHR: Self = Self(1024);
    #[doc(alias = "VK_BUFFER_USAGE_VIDEO_ENCODE_DST_BIT_KHR")]
    #[cfg(feature = "VK_KHR_video_encode_queue")]
    pub const VIDEO_ENCODE_DST_KHR: Self = Self(32768);
    #[doc(alias = "VK_BUFFER_USAGE_VIDEO_ENCODE_SRC_BIT_KHR")]
    #[cfg(feature = "VK_KHR_video_encode_queue")]
    pub const VIDEO_ENCODE_SRC_KHR: Self = Self(65536);
    #[doc(alias = "VK_BUFFER_USAGE_RAY_TRACING_BIT_NV")]
    #[cfg(feature = "VK_NV_ray_tracing")]
    pub const RAY_TRACING_NV: Self = Self::SHADER_BINDING_TABLE_KHR;
    #[doc(alias = "VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_EXT")]
    #[cfg(feature = "VK_EXT_buffer_device_address")]
    pub const SHADER_DEVICE_ADDRESS_EXT: Self = Self::SHADER_DEVICE_ADDRESS;
    #[doc(alias = "VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_KHR")]
    #[cfg(feature = "VK_KHR_buffer_device_address")]
    pub const SHADER_DEVICE_ADDRESS_KHR: Self = Self::SHADER_DEVICE_ADDRESS;
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    #[allow(unused_mut)]
    pub const fn all() -> Self {
        let mut all = Self::empty();
        {
            all |= Self::TRANSFER_SRC;
        }
        {
            all |= Self::TRANSFER_DST;
        }
        {
            all |= Self::UNIFORM_TEXEL_BUFFER;
        }
        {
            all |= Self::STORAGE_TEXEL_BUFFER;
        }
        {
            all |= Self::UNIFORM_BUFFER;
        }
        {
            all |= Self::STORAGE_BUFFER;
        }
        {
            all |= Self::INDEX_BUFFER;
        }
        {
            all |= Self::VERTEX_BUFFER;
        }
        {
            all |= Self::INDIRECT_BUFFER;
        }
        #[cfg(feature = "VULKAN_1_2")]
        {
            all |= Self::SHADER_DEVICE_ADDRESS;
        }
        #[cfg(feature = "VK_KHR_video_decode_queue")]
        {
            all |= Self::VIDEO_DECODE_SRC_KHR;
        }
        #[cfg(feature = "VK_KHR_video_decode_queue")]
        {
            all |= Self::VIDEO_DECODE_DST_KHR;
        }
        #[cfg(feature = "VK_EXT_transform_feedback")]
        {
            all |= Self::TRANSFORM_FEEDBACK_BUFFER_EXT;
        }
        #[cfg(feature = "VK_EXT_transform_feedback")]
        {
            all |= Self::TRANSFORM_FEEDBACK_COUNTER_BUFFER_EXT;
        }
        #[cfg(feature = "VK_EXT_conditional_rendering")]
        {
            all |= Self::CONDITIONAL_RENDERING_EXT;
        }
        #[cfg(feature = "VK_KHR_acceleration_structure")]
        {
            all |= Self::ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_KHR;
        }
        #[cfg(feature = "VK_KHR_acceleration_structure")]
        {
            all |= Self::ACCELERATION_STRUCTURE_STORAGE_KHR;
        }
        #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
        {
            all |= Self::SHADER_BINDING_TABLE_KHR;
        }
        #[cfg(feature = "VK_KHR_video_encode_queue")]
        {
            all |= Self::VIDEO_ENCODE_DST_KHR;
        }
        #[cfg(feature = "VK_KHR_video_encode_queue")]
        {
            all |= Self::VIDEO_ENCODE_SRC_KHR;
        }
        #[cfg(feature = "VK_NV_ray_tracing")]
        {
            all |= Self::RAY_TRACING_NV;
        }
        #[cfg(feature = "VK_EXT_buffer_device_address")]
        {
            all |= Self::SHADER_DEVICE_ADDRESS_EXT;
        }
        #[cfg(feature = "VK_KHR_buffer_device_address")]
        {
            all |= Self::SHADER_DEVICE_ADDRESS_KHR;
        }
        all
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl std::ops::BitOr for BufferUsageFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl std::ops::BitOrAssign for BufferUsageFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl std::ops::BitXor for BufferUsageFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl std::ops::BitXorAssign for BufferUsageFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl std::ops::BitAnd for BufferUsageFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl std::ops::BitAndAssign for BufferUsageFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl std::ops::Sub for BufferUsageFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl std::ops::SubAssign for BufferUsageFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl std::ops::Not for BufferUsageFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl Extend<BufferUsageFlags> for BufferUsageFlags {
    fn extend<T: IntoIterator<Item = BufferUsageFlags>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, i);
        }
    }
}
impl FromIterator<BufferUsageFlags> for BufferUsageFlags {
    fn from_iter<T: IntoIterator<Item = BufferUsageFlags>>(iterator: T) -> BufferUsageFlags {
        let mut out = Self::empty();
        <Self as Extend<BufferUsageFlags>>::extend(&mut out, iterator);
        out
    }
}
impl Default for BufferUsageFlags {
    fn default() -> Self {
        Self::empty()
    }
}
impl From<BufferUsageFlagBits> for BufferUsageFlags {
    fn from(bit: BufferUsageFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(bit.bits()) }
    }
}
impl Extend<BufferUsageFlagBits> for BufferUsageFlags {
    fn extend<T: IntoIterator<Item = BufferUsageFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, Self::from(i));
        }
    }
}
impl FromIterator<BufferUsageFlagBits> for BufferUsageFlags {
    fn from_iter<T: IntoIterator<Item = BufferUsageFlagBits>>(iterator: T) -> BufferUsageFlags {
        let mut out = Self::empty();
        <Self as Extend<BufferUsageFlagBits>>::extend(&mut out, iterator);
        out
    }
}
impl std::fmt::Debug for BufferUsageFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(BufferUsageFlags);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == BufferUsageFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(BufferUsageFlags::TRANSFER_SRC) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(TRANSFER_SRC))?;
                    }
                    if self.0.contains(BufferUsageFlags::TRANSFER_DST) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(TRANSFER_DST))?;
                    }
                    if self.0.contains(BufferUsageFlags::UNIFORM_TEXEL_BUFFER) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(UNIFORM_TEXEL_BUFFER))?;
                    }
                    if self.0.contains(BufferUsageFlags::STORAGE_TEXEL_BUFFER) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(STORAGE_TEXEL_BUFFER))?;
                    }
                    if self.0.contains(BufferUsageFlags::UNIFORM_BUFFER) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(UNIFORM_BUFFER))?;
                    }
                    if self.0.contains(BufferUsageFlags::STORAGE_BUFFER) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(STORAGE_BUFFER))?;
                    }
                    if self.0.contains(BufferUsageFlags::INDEX_BUFFER) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(INDEX_BUFFER))?;
                    }
                    if self.0.contains(BufferUsageFlags::VERTEX_BUFFER) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(VERTEX_BUFFER))?;
                    }
                    if self.0.contains(BufferUsageFlags::INDIRECT_BUFFER) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(INDIRECT_BUFFER))?;
                    }
                    #[cfg(feature = "VULKAN_1_2")]
                    if self.0.contains(BufferUsageFlags::SHADER_DEVICE_ADDRESS) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(SHADER_DEVICE_ADDRESS))?;
                    }
                    #[cfg(feature = "VK_KHR_video_decode_queue")]
                    if self.0.contains(BufferUsageFlags::VIDEO_DECODE_SRC_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(VIDEO_DECODE_SRC_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_video_decode_queue")]
                    if self.0.contains(BufferUsageFlags::VIDEO_DECODE_DST_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(VIDEO_DECODE_DST_KHR))?;
                    }
                    #[cfg(feature = "VK_EXT_transform_feedback")]
                    if self.0.contains(BufferUsageFlags::TRANSFORM_FEEDBACK_BUFFER_EXT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(TRANSFORM_FEEDBACK_BUFFER_EXT))?;
                    }
                    #[cfg(feature = "VK_EXT_transform_feedback")]
                    if self.0.contains(BufferUsageFlags::TRANSFORM_FEEDBACK_COUNTER_BUFFER_EXT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(TRANSFORM_FEEDBACK_COUNTER_BUFFER_EXT))?;
                    }
                    #[cfg(feature = "VK_EXT_conditional_rendering")]
                    if self.0.contains(BufferUsageFlags::CONDITIONAL_RENDERING_EXT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(CONDITIONAL_RENDERING_EXT))?;
                    }
                    #[cfg(feature = "VK_KHR_acceleration_structure")]
                    if self
                        .0
                        .contains(BufferUsageFlags::ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_KHR)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_acceleration_structure")]
                    if self.0.contains(BufferUsageFlags::ACCELERATION_STRUCTURE_STORAGE_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(ACCELERATION_STRUCTURE_STORAGE_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
                    if self.0.contains(BufferUsageFlags::SHADER_BINDING_TABLE_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(SHADER_BINDING_TABLE_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_video_encode_queue")]
                    if self.0.contains(BufferUsageFlags::VIDEO_ENCODE_DST_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(VIDEO_ENCODE_DST_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_video_encode_queue")]
                    if self.0.contains(BufferUsageFlags::VIDEO_ENCODE_SRC_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(VIDEO_ENCODE_SRC_KHR))?;
                    }
                    #[cfg(feature = "VK_NV_ray_tracing")]
                    if self.0.contains(BufferUsageFlags::RAY_TRACING_NV) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(RAY_TRACING_NV))?;
                    }
                    #[cfg(feature = "VK_EXT_buffer_device_address")]
                    if self.0.contains(BufferUsageFlags::SHADER_DEVICE_ADDRESS_EXT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(SHADER_DEVICE_ADDRESS_EXT))?;
                    }
                    #[cfg(feature = "VK_KHR_buffer_device_address")]
                    if self.0.contains(BufferUsageFlags::SHADER_DEVICE_ADDRESS_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(SHADER_DEVICE_ADDRESS_KHR))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(BufferUsageFlags))
            .field(&Flags(*self))
            .finish()
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for BufferUsageFlags {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for BufferUsageFlags {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkBufferCreateFlags")]
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct BufferCreateFlags(u32);
impl BufferCreateFlags {
    #[doc(alias = "VK_BUFFER_CREATE_SPARSE_BINDING_BIT")]
    pub const SPARSE_BINDING: Self = Self(1);
    #[doc(alias = "VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT")]
    pub const SPARSE_RESIDENCY: Self = Self(2);
    #[doc(alias = "VK_BUFFER_CREATE_SPARSE_ALIASED_BIT")]
    pub const SPARSE_ALIASED: Self = Self(4);
    #[doc(alias = "VK_BUFFER_CREATE_PROTECTED_BIT")]
    pub const PROTECTED: Self = Self(8);
    #[doc(alias = "VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT")]
    #[cfg(feature = "VULKAN_1_2")]
    pub const DEVICE_ADDRESS_CAPTURE_REPLAY: Self = Self(16);
    #[doc(alias = "VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT")]
    #[cfg(feature = "VK_EXT_buffer_device_address")]
    pub const DEVICE_ADDRESS_CAPTURE_REPLAY_EXT: Self = Self::DEVICE_ADDRESS_CAPTURE_REPLAY;
    #[doc(alias = "VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR")]
    #[cfg(feature = "VK_KHR_buffer_device_address")]
    pub const DEVICE_ADDRESS_CAPTURE_REPLAY_KHR: Self = Self::DEVICE_ADDRESS_CAPTURE_REPLAY;
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    #[allow(unused_mut)]
    pub const fn all() -> Self {
        let mut all = Self::empty();
        {
            all |= Self::SPARSE_BINDING;
        }
        {
            all |= Self::SPARSE_RESIDENCY;
        }
        {
            all |= Self::SPARSE_ALIASED;
        }
        {
            all |= Self::PROTECTED;
        }
        #[cfg(feature = "VULKAN_1_2")]
        {
            all |= Self::DEVICE_ADDRESS_CAPTURE_REPLAY;
        }
        #[cfg(feature = "VK_EXT_buffer_device_address")]
        {
            all |= Self::DEVICE_ADDRESS_CAPTURE_REPLAY_EXT;
        }
        #[cfg(feature = "VK_KHR_buffer_device_address")]
        {
            all |= Self::DEVICE_ADDRESS_CAPTURE_REPLAY_KHR;
        }
        all
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl std::ops::BitOr for BufferCreateFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl std::ops::BitOrAssign for BufferCreateFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl std::ops::BitXor for BufferCreateFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl std::ops::BitXorAssign for BufferCreateFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl std::ops::BitAnd for BufferCreateFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl std::ops::BitAndAssign for BufferCreateFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl std::ops::Sub for BufferCreateFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl std::ops::SubAssign for BufferCreateFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl std::ops::Not for BufferCreateFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl Extend<BufferCreateFlags> for BufferCreateFlags {
    fn extend<T: IntoIterator<Item = BufferCreateFlags>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, i);
        }
    }
}
impl FromIterator<BufferCreateFlags> for BufferCreateFlags {
    fn from_iter<T: IntoIterator<Item = BufferCreateFlags>>(iterator: T) -> BufferCreateFlags {
        let mut out = Self::empty();
        <Self as Extend<BufferCreateFlags>>::extend(&mut out, iterator);
        out
    }
}
impl Default for BufferCreateFlags {
    fn default() -> Self {
        Self::empty()
    }
}
impl From<BufferCreateFlagBits> for BufferCreateFlags {
    fn from(bit: BufferCreateFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(bit.bits()) }
    }
}
impl Extend<BufferCreateFlagBits> for BufferCreateFlags {
    fn extend<T: IntoIterator<Item = BufferCreateFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, Self::from(i));
        }
    }
}
impl FromIterator<BufferCreateFlagBits> for BufferCreateFlags {
    fn from_iter<T: IntoIterator<Item = BufferCreateFlagBits>>(iterator: T) -> BufferCreateFlags {
        let mut out = Self::empty();
        <Self as Extend<BufferCreateFlagBits>>::extend(&mut out, iterator);
        out
    }
}
impl std::fmt::Debug for BufferCreateFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(BufferCreateFlags);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == BufferCreateFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(BufferCreateFlags::SPARSE_BINDING) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(SPARSE_BINDING))?;
                    }
                    if self.0.contains(BufferCreateFlags::SPARSE_RESIDENCY) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(SPARSE_RESIDENCY))?;
                    }
                    if self.0.contains(BufferCreateFlags::SPARSE_ALIASED) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(SPARSE_ALIASED))?;
                    }
                    if self.0.contains(BufferCreateFlags::PROTECTED) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(PROTECTED))?;
                    }
                    #[cfg(feature = "VULKAN_1_2")]
                    if self.0.contains(BufferCreateFlags::DEVICE_ADDRESS_CAPTURE_REPLAY) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(DEVICE_ADDRESS_CAPTURE_REPLAY))?;
                    }
                    #[cfg(feature = "VK_EXT_buffer_device_address")]
                    if self.0.contains(BufferCreateFlags::DEVICE_ADDRESS_CAPTURE_REPLAY_EXT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(DEVICE_ADDRESS_CAPTURE_REPLAY_EXT))?;
                    }
                    #[cfg(feature = "VK_KHR_buffer_device_address")]
                    if self.0.contains(BufferCreateFlags::DEVICE_ADDRESS_CAPTURE_REPLAY_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(DEVICE_ADDRESS_CAPTURE_REPLAY_KHR))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(BufferCreateFlags))
            .field(&Flags(*self))
            .finish()
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for BufferCreateFlags {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for BufferCreateFlags {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkShaderStageFlags")]
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct ShaderStageFlags(u32);
impl ShaderStageFlags {
    #[doc(alias = "VK_SHADER_STAGE_VERTEX_BIT")]
    pub const VERTEX: Self = Self(1);
    #[doc(alias = "VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT")]
    pub const TESSELLATION_CONTROL: Self = Self(2);
    #[doc(alias = "VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT")]
    pub const TESSELLATION_EVALUATION: Self = Self(4);
    #[doc(alias = "VK_SHADER_STAGE_GEOMETRY_BIT")]
    pub const GEOMETRY: Self = Self(8);
    #[doc(alias = "VK_SHADER_STAGE_FRAGMENT_BIT")]
    pub const FRAGMENT: Self = Self(16);
    #[doc(alias = "VK_SHADER_STAGE_COMPUTE_BIT")]
    pub const COMPUTE: Self = Self(32);
    #[doc(alias = "VK_SHADER_STAGE_ALL_GRAPHICS")]
    pub const ALL_GRAPHICS: Self = Self(31);
    #[doc(alias = "VK_SHADER_STAGE_ALL")]
    pub const ALL: Self = Self(2147483647);
    #[doc(alias = "VK_SHADER_STAGE_RAYGEN_BIT_KHR")]
    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
    pub const RAYGEN_KHR: Self = Self(256);
    #[doc(alias = "VK_SHADER_STAGE_ANY_HIT_BIT_KHR")]
    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
    pub const ANY_HIT_KHR: Self = Self(512);
    #[doc(alias = "VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR")]
    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
    pub const CLOSEST_HIT_KHR: Self = Self(1024);
    #[doc(alias = "VK_SHADER_STAGE_MISS_BIT_KHR")]
    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
    pub const MISS_KHR: Self = Self(2048);
    #[doc(alias = "VK_SHADER_STAGE_INTERSECTION_BIT_KHR")]
    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
    pub const INTERSECTION_KHR: Self = Self(4096);
    #[doc(alias = "VK_SHADER_STAGE_CALLABLE_BIT_KHR")]
    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
    pub const CALLABLE_KHR: Self = Self(8192);
    #[doc(alias = "VK_SHADER_STAGE_TASK_BIT_NV")]
    #[cfg(feature = "VK_NV_mesh_shader")]
    pub const TASK_NV: Self = Self(64);
    #[doc(alias = "VK_SHADER_STAGE_MESH_BIT_NV")]
    #[cfg(feature = "VK_NV_mesh_shader")]
    pub const MESH_NV: Self = Self(128);
    #[doc(alias = "VK_SHADER_STAGE_SUBPASS_SHADING_BIT_HUAWEI")]
    #[cfg(feature = "VK_HUAWEI_subpass_shading")]
    pub const SUBPASS_SHADING_HUAWEI: Self = Self(16384);
    #[doc(alias = "VK_SHADER_STAGE_RAYGEN_BIT_NV")]
    #[cfg(feature = "VK_NV_ray_tracing")]
    pub const RAYGEN_NV: Self = Self::RAYGEN_KHR;
    #[doc(alias = "VK_SHADER_STAGE_ANY_HIT_BIT_NV")]
    #[cfg(feature = "VK_NV_ray_tracing")]
    pub const ANY_HIT_NV: Self = Self::ANY_HIT_KHR;
    #[doc(alias = "VK_SHADER_STAGE_CLOSEST_HIT_BIT_NV")]
    #[cfg(feature = "VK_NV_ray_tracing")]
    pub const CLOSEST_HIT_NV: Self = Self::CLOSEST_HIT_KHR;
    #[doc(alias = "VK_SHADER_STAGE_MISS_BIT_NV")]
    #[cfg(feature = "VK_NV_ray_tracing")]
    pub const MISS_NV: Self = Self::MISS_KHR;
    #[doc(alias = "VK_SHADER_STAGE_INTERSECTION_BIT_NV")]
    #[cfg(feature = "VK_NV_ray_tracing")]
    pub const INTERSECTION_NV: Self = Self::INTERSECTION_KHR;
    #[doc(alias = "VK_SHADER_STAGE_CALLABLE_BIT_NV")]
    #[cfg(feature = "VK_NV_ray_tracing")]
    pub const CALLABLE_NV: Self = Self::CALLABLE_KHR;
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    #[allow(unused_mut)]
    pub const fn all() -> Self {
        let mut all = Self::empty();
        {
            all |= Self::VERTEX;
        }
        {
            all |= Self::TESSELLATION_CONTROL;
        }
        {
            all |= Self::TESSELLATION_EVALUATION;
        }
        {
            all |= Self::GEOMETRY;
        }
        {
            all |= Self::FRAGMENT;
        }
        {
            all |= Self::COMPUTE;
        }
        {
            all |= Self::ALL_GRAPHICS;
        }
        {
            all |= Self::ALL;
        }
        #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
        {
            all |= Self::RAYGEN_KHR;
        }
        #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
        {
            all |= Self::ANY_HIT_KHR;
        }
        #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
        {
            all |= Self::CLOSEST_HIT_KHR;
        }
        #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
        {
            all |= Self::MISS_KHR;
        }
        #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
        {
            all |= Self::INTERSECTION_KHR;
        }
        #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
        {
            all |= Self::CALLABLE_KHR;
        }
        #[cfg(feature = "VK_NV_mesh_shader")]
        {
            all |= Self::TASK_NV;
        }
        #[cfg(feature = "VK_NV_mesh_shader")]
        {
            all |= Self::MESH_NV;
        }
        #[cfg(feature = "VK_HUAWEI_subpass_shading")]
        {
            all |= Self::SUBPASS_SHADING_HUAWEI;
        }
        #[cfg(feature = "VK_NV_ray_tracing")]
        {
            all |= Self::RAYGEN_NV;
        }
        #[cfg(feature = "VK_NV_ray_tracing")]
        {
            all |= Self::ANY_HIT_NV;
        }
        #[cfg(feature = "VK_NV_ray_tracing")]
        {
            all |= Self::CLOSEST_HIT_NV;
        }
        #[cfg(feature = "VK_NV_ray_tracing")]
        {
            all |= Self::MISS_NV;
        }
        #[cfg(feature = "VK_NV_ray_tracing")]
        {
            all |= Self::INTERSECTION_NV;
        }
        #[cfg(feature = "VK_NV_ray_tracing")]
        {
            all |= Self::CALLABLE_NV;
        }
        all
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl std::ops::BitOr for ShaderStageFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl std::ops::BitOrAssign for ShaderStageFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl std::ops::BitXor for ShaderStageFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl std::ops::BitXorAssign for ShaderStageFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl std::ops::BitAnd for ShaderStageFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl std::ops::BitAndAssign for ShaderStageFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl std::ops::Sub for ShaderStageFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl std::ops::SubAssign for ShaderStageFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl std::ops::Not for ShaderStageFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl Extend<ShaderStageFlags> for ShaderStageFlags {
    fn extend<T: IntoIterator<Item = ShaderStageFlags>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, i);
        }
    }
}
impl FromIterator<ShaderStageFlags> for ShaderStageFlags {
    fn from_iter<T: IntoIterator<Item = ShaderStageFlags>>(iterator: T) -> ShaderStageFlags {
        let mut out = Self::empty();
        <Self as Extend<ShaderStageFlags>>::extend(&mut out, iterator);
        out
    }
}
impl Default for ShaderStageFlags {
    fn default() -> Self {
        Self::empty()
    }
}
impl From<ShaderStageFlagBits> for ShaderStageFlags {
    fn from(bit: ShaderStageFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(bit.bits()) }
    }
}
impl Extend<ShaderStageFlagBits> for ShaderStageFlags {
    fn extend<T: IntoIterator<Item = ShaderStageFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, Self::from(i));
        }
    }
}
impl FromIterator<ShaderStageFlagBits> for ShaderStageFlags {
    fn from_iter<T: IntoIterator<Item = ShaderStageFlagBits>>(iterator: T) -> ShaderStageFlags {
        let mut out = Self::empty();
        <Self as Extend<ShaderStageFlagBits>>::extend(&mut out, iterator);
        out
    }
}
impl std::fmt::Debug for ShaderStageFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(ShaderStageFlags);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == ShaderStageFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(ShaderStageFlags::VERTEX) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(VERTEX))?;
                    }
                    if self.0.contains(ShaderStageFlags::TESSELLATION_CONTROL) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(TESSELLATION_CONTROL))?;
                    }
                    if self.0.contains(ShaderStageFlags::TESSELLATION_EVALUATION) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(TESSELLATION_EVALUATION))?;
                    }
                    if self.0.contains(ShaderStageFlags::GEOMETRY) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(GEOMETRY))?;
                    }
                    if self.0.contains(ShaderStageFlags::FRAGMENT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(FRAGMENT))?;
                    }
                    if self.0.contains(ShaderStageFlags::COMPUTE) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(COMPUTE))?;
                    }
                    if self.0.contains(ShaderStageFlags::ALL_GRAPHICS) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(ALL_GRAPHICS))?;
                    }
                    if self.0.contains(ShaderStageFlags::ALL) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(ALL))?;
                    }
                    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
                    if self.0.contains(ShaderStageFlags::RAYGEN_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(RAYGEN_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
                    if self.0.contains(ShaderStageFlags::ANY_HIT_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(ANY_HIT_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
                    if self.0.contains(ShaderStageFlags::CLOSEST_HIT_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(CLOSEST_HIT_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
                    if self.0.contains(ShaderStageFlags::MISS_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(MISS_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
                    if self.0.contains(ShaderStageFlags::INTERSECTION_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(INTERSECTION_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
                    if self.0.contains(ShaderStageFlags::CALLABLE_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(CALLABLE_KHR))?;
                    }
                    #[cfg(feature = "VK_NV_mesh_shader")]
                    if self.0.contains(ShaderStageFlags::TASK_NV) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(TASK_NV))?;
                    }
                    #[cfg(feature = "VK_NV_mesh_shader")]
                    if self.0.contains(ShaderStageFlags::MESH_NV) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(MESH_NV))?;
                    }
                    #[cfg(feature = "VK_HUAWEI_subpass_shading")]
                    if self.0.contains(ShaderStageFlags::SUBPASS_SHADING_HUAWEI) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(SUBPASS_SHADING_HUAWEI))?;
                    }
                    #[cfg(feature = "VK_NV_ray_tracing")]
                    if self.0.contains(ShaderStageFlags::RAYGEN_NV) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(RAYGEN_NV))?;
                    }
                    #[cfg(feature = "VK_NV_ray_tracing")]
                    if self.0.contains(ShaderStageFlags::ANY_HIT_NV) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(ANY_HIT_NV))?;
                    }
                    #[cfg(feature = "VK_NV_ray_tracing")]
                    if self.0.contains(ShaderStageFlags::CLOSEST_HIT_NV) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(CLOSEST_HIT_NV))?;
                    }
                    #[cfg(feature = "VK_NV_ray_tracing")]
                    if self.0.contains(ShaderStageFlags::MISS_NV) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(MISS_NV))?;
                    }
                    #[cfg(feature = "VK_NV_ray_tracing")]
                    if self.0.contains(ShaderStageFlags::INTERSECTION_NV) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(INTERSECTION_NV))?;
                    }
                    #[cfg(feature = "VK_NV_ray_tracing")]
                    if self.0.contains(ShaderStageFlags::CALLABLE_NV) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(CALLABLE_NV))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(ShaderStageFlags))
            .field(&Flags(*self))
            .finish()
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for ShaderStageFlags {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for ShaderStageFlags {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkImageUsageFlags")]
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct ImageUsageFlags(u32);
impl ImageUsageFlags {
    #[doc(alias = "VK_IMAGE_USAGE_TRANSFER_SRC_BIT")]
    pub const TRANSFER_SRC: Self = Self(1);
    #[doc(alias = "VK_IMAGE_USAGE_TRANSFER_DST_BIT")]
    pub const TRANSFER_DST: Self = Self(2);
    #[doc(alias = "VK_IMAGE_USAGE_SAMPLED_BIT")]
    pub const SAMPLED: Self = Self(4);
    #[doc(alias = "VK_IMAGE_USAGE_STORAGE_BIT")]
    pub const STORAGE: Self = Self(8);
    #[doc(alias = "VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT")]
    pub const COLOR_ATTACHMENT: Self = Self(16);
    #[doc(alias = "VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT")]
    pub const DEPTH_STENCIL_ATTACHMENT: Self = Self(32);
    #[doc(alias = "VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT")]
    pub const TRANSIENT_ATTACHMENT: Self = Self(64);
    #[doc(alias = "VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT")]
    pub const INPUT_ATTACHMENT: Self = Self(128);
    #[doc(alias = "VK_IMAGE_USAGE_VIDEO_DECODE_DST_BIT_KHR")]
    #[cfg(feature = "VK_KHR_video_decode_queue")]
    pub const VIDEO_DECODE_DST_KHR: Self = Self(1024);
    #[doc(alias = "VK_IMAGE_USAGE_VIDEO_DECODE_SRC_BIT_KHR")]
    #[cfg(feature = "VK_KHR_video_decode_queue")]
    pub const VIDEO_DECODE_SRC_KHR: Self = Self(2048);
    #[doc(alias = "VK_IMAGE_USAGE_VIDEO_DECODE_DPB_BIT_KHR")]
    #[cfg(feature = "VK_KHR_video_decode_queue")]
    pub const VIDEO_DECODE_DPB_KHR: Self = Self(4096);
    #[doc(alias = "VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT")]
    #[cfg(feature = "VK_EXT_fragment_density_map")]
    pub const FRAGMENT_DENSITY_MAP_EXT: Self = Self(512);
    #[doc(alias = "VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR")]
    #[cfg(feature = "VK_KHR_fragment_shading_rate")]
    pub const FRAGMENT_SHADING_RATE_ATTACHMENT_KHR: Self = Self(256);
    #[doc(alias = "VK_IMAGE_USAGE_VIDEO_ENCODE_DST_BIT_KHR")]
    #[cfg(feature = "VK_KHR_video_encode_queue")]
    pub const VIDEO_ENCODE_DST_KHR: Self = Self(8192);
    #[doc(alias = "VK_IMAGE_USAGE_VIDEO_ENCODE_SRC_BIT_KHR")]
    #[cfg(feature = "VK_KHR_video_encode_queue")]
    pub const VIDEO_ENCODE_SRC_KHR: Self = Self(16384);
    #[doc(alias = "VK_IMAGE_USAGE_VIDEO_ENCODE_DPB_BIT_KHR")]
    #[cfg(feature = "VK_KHR_video_encode_queue")]
    pub const VIDEO_ENCODE_DPB_KHR: Self = Self(32768);
    #[doc(alias = "VK_IMAGE_USAGE_INVOCATION_MASK_BIT_HUAWEI")]
    #[cfg(feature = "VK_HUAWEI_invocation_mask")]
    pub const INVOCATION_MASK_HUAWEI: Self = Self(262144);
    #[doc(alias = "VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV")]
    #[cfg(feature = "VK_NV_shading_rate_image")]
    pub const SHADING_RATE_IMAGE_NV: Self = Self::FRAGMENT_SHADING_RATE_ATTACHMENT_KHR;
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    #[allow(unused_mut)]
    pub const fn all() -> Self {
        let mut all = Self::empty();
        {
            all |= Self::TRANSFER_SRC;
        }
        {
            all |= Self::TRANSFER_DST;
        }
        {
            all |= Self::SAMPLED;
        }
        {
            all |= Self::STORAGE;
        }
        {
            all |= Self::COLOR_ATTACHMENT;
        }
        {
            all |= Self::DEPTH_STENCIL_ATTACHMENT;
        }
        {
            all |= Self::TRANSIENT_ATTACHMENT;
        }
        {
            all |= Self::INPUT_ATTACHMENT;
        }
        #[cfg(feature = "VK_KHR_video_decode_queue")]
        {
            all |= Self::VIDEO_DECODE_DST_KHR;
        }
        #[cfg(feature = "VK_KHR_video_decode_queue")]
        {
            all |= Self::VIDEO_DECODE_SRC_KHR;
        }
        #[cfg(feature = "VK_KHR_video_decode_queue")]
        {
            all |= Self::VIDEO_DECODE_DPB_KHR;
        }
        #[cfg(feature = "VK_EXT_fragment_density_map")]
        {
            all |= Self::FRAGMENT_DENSITY_MAP_EXT;
        }
        #[cfg(feature = "VK_KHR_fragment_shading_rate")]
        {
            all |= Self::FRAGMENT_SHADING_RATE_ATTACHMENT_KHR;
        }
        #[cfg(feature = "VK_KHR_video_encode_queue")]
        {
            all |= Self::VIDEO_ENCODE_DST_KHR;
        }
        #[cfg(feature = "VK_KHR_video_encode_queue")]
        {
            all |= Self::VIDEO_ENCODE_SRC_KHR;
        }
        #[cfg(feature = "VK_KHR_video_encode_queue")]
        {
            all |= Self::VIDEO_ENCODE_DPB_KHR;
        }
        #[cfg(feature = "VK_HUAWEI_invocation_mask")]
        {
            all |= Self::INVOCATION_MASK_HUAWEI;
        }
        #[cfg(feature = "VK_NV_shading_rate_image")]
        {
            all |= Self::SHADING_RATE_IMAGE_NV;
        }
        all
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl std::ops::BitOr for ImageUsageFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl std::ops::BitOrAssign for ImageUsageFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl std::ops::BitXor for ImageUsageFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl std::ops::BitXorAssign for ImageUsageFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl std::ops::BitAnd for ImageUsageFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl std::ops::BitAndAssign for ImageUsageFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl std::ops::Sub for ImageUsageFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl std::ops::SubAssign for ImageUsageFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl std::ops::Not for ImageUsageFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl Extend<ImageUsageFlags> for ImageUsageFlags {
    fn extend<T: IntoIterator<Item = ImageUsageFlags>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, i);
        }
    }
}
impl FromIterator<ImageUsageFlags> for ImageUsageFlags {
    fn from_iter<T: IntoIterator<Item = ImageUsageFlags>>(iterator: T) -> ImageUsageFlags {
        let mut out = Self::empty();
        <Self as Extend<ImageUsageFlags>>::extend(&mut out, iterator);
        out
    }
}
impl Default for ImageUsageFlags {
    fn default() -> Self {
        Self::empty()
    }
}
impl From<ImageUsageFlagBits> for ImageUsageFlags {
    fn from(bit: ImageUsageFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(bit.bits()) }
    }
}
impl Extend<ImageUsageFlagBits> for ImageUsageFlags {
    fn extend<T: IntoIterator<Item = ImageUsageFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, Self::from(i));
        }
    }
}
impl FromIterator<ImageUsageFlagBits> for ImageUsageFlags {
    fn from_iter<T: IntoIterator<Item = ImageUsageFlagBits>>(iterator: T) -> ImageUsageFlags {
        let mut out = Self::empty();
        <Self as Extend<ImageUsageFlagBits>>::extend(&mut out, iterator);
        out
    }
}
impl std::fmt::Debug for ImageUsageFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(ImageUsageFlags);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == ImageUsageFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(ImageUsageFlags::TRANSFER_SRC) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(TRANSFER_SRC))?;
                    }
                    if self.0.contains(ImageUsageFlags::TRANSFER_DST) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(TRANSFER_DST))?;
                    }
                    if self.0.contains(ImageUsageFlags::SAMPLED) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(SAMPLED))?;
                    }
                    if self.0.contains(ImageUsageFlags::STORAGE) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(STORAGE))?;
                    }
                    if self.0.contains(ImageUsageFlags::COLOR_ATTACHMENT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(COLOR_ATTACHMENT))?;
                    }
                    if self.0.contains(ImageUsageFlags::DEPTH_STENCIL_ATTACHMENT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(DEPTH_STENCIL_ATTACHMENT))?;
                    }
                    if self.0.contains(ImageUsageFlags::TRANSIENT_ATTACHMENT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(TRANSIENT_ATTACHMENT))?;
                    }
                    if self.0.contains(ImageUsageFlags::INPUT_ATTACHMENT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(INPUT_ATTACHMENT))?;
                    }
                    #[cfg(feature = "VK_KHR_video_decode_queue")]
                    if self.0.contains(ImageUsageFlags::VIDEO_DECODE_DST_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(VIDEO_DECODE_DST_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_video_decode_queue")]
                    if self.0.contains(ImageUsageFlags::VIDEO_DECODE_SRC_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(VIDEO_DECODE_SRC_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_video_decode_queue")]
                    if self.0.contains(ImageUsageFlags::VIDEO_DECODE_DPB_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(VIDEO_DECODE_DPB_KHR))?;
                    }
                    #[cfg(feature = "VK_EXT_fragment_density_map")]
                    if self.0.contains(ImageUsageFlags::FRAGMENT_DENSITY_MAP_EXT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(FRAGMENT_DENSITY_MAP_EXT))?;
                    }
                    #[cfg(feature = "VK_KHR_fragment_shading_rate")]
                    if self.0.contains(ImageUsageFlags::FRAGMENT_SHADING_RATE_ATTACHMENT_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(FRAGMENT_SHADING_RATE_ATTACHMENT_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_video_encode_queue")]
                    if self.0.contains(ImageUsageFlags::VIDEO_ENCODE_DST_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(VIDEO_ENCODE_DST_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_video_encode_queue")]
                    if self.0.contains(ImageUsageFlags::VIDEO_ENCODE_SRC_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(VIDEO_ENCODE_SRC_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_video_encode_queue")]
                    if self.0.contains(ImageUsageFlags::VIDEO_ENCODE_DPB_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(VIDEO_ENCODE_DPB_KHR))?;
                    }
                    #[cfg(feature = "VK_HUAWEI_invocation_mask")]
                    if self.0.contains(ImageUsageFlags::INVOCATION_MASK_HUAWEI) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(INVOCATION_MASK_HUAWEI))?;
                    }
                    #[cfg(feature = "VK_NV_shading_rate_image")]
                    if self.0.contains(ImageUsageFlags::SHADING_RATE_IMAGE_NV) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(SHADING_RATE_IMAGE_NV))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(ImageUsageFlags)).field(&Flags(*self)).finish()
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for ImageUsageFlags {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for ImageUsageFlags {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkImageCreateFlags")]
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct ImageCreateFlags(u32);
impl ImageCreateFlags {
    #[doc(alias = "VK_IMAGE_CREATE_SPARSE_BINDING_BIT")]
    pub const SPARSE_BINDING: Self = Self(1);
    #[doc(alias = "VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT")]
    pub const SPARSE_RESIDENCY: Self = Self(2);
    #[doc(alias = "VK_IMAGE_CREATE_SPARSE_ALIASED_BIT")]
    pub const SPARSE_ALIASED: Self = Self(4);
    #[doc(alias = "VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT")]
    pub const MUTABLE_FORMAT: Self = Self(8);
    #[doc(alias = "VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT")]
    pub const CUBE_COMPATIBLE: Self = Self(16);
    #[doc(alias = "VK_IMAGE_CREATE_ALIAS_BIT")]
    pub const ALIAS: Self = Self(1024);
    #[doc(alias = "VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT")]
    pub const SPLIT_INSTANCE_BIND_REGIONS: Self = Self(64);
    #[doc(alias = "VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT")]
    pub const N2D_ARRAY_COMPATIBLE: Self = Self(32);
    #[doc(alias = "VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT")]
    pub const BLOCK_TEXEL_VIEW_COMPATIBLE: Self = Self(128);
    #[doc(alias = "VK_IMAGE_CREATE_EXTENDED_USAGE_BIT")]
    pub const EXTENDED_USAGE: Self = Self(256);
    #[doc(alias = "VK_IMAGE_CREATE_PROTECTED_BIT")]
    pub const PROTECTED: Self = Self(2048);
    #[doc(alias = "VK_IMAGE_CREATE_DISJOINT_BIT")]
    pub const DISJOINT: Self = Self(512);
    #[doc(alias = "VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV")]
    #[cfg(feature = "VK_NV_corner_sampled_image")]
    pub const CORNER_SAMPLED_NV: Self = Self(8192);
    #[doc(alias = "VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT")]
    #[cfg(feature = "VK_EXT_sample_locations")]
    pub const SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_EXT: Self = Self(4096);
    #[doc(alias = "VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT")]
    #[cfg(feature = "VK_EXT_fragment_density_map")]
    pub const SUBSAMPLED_EXT: Self = Self(16384);
    #[doc(alias = "VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR")]
    #[cfg(feature = "VK_KHR_device_group")]
    pub const SPLIT_INSTANCE_BIND_REGIONS_KHR: Self = Self::SPLIT_INSTANCE_BIND_REGIONS;
    #[doc(alias = "VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT_KHR")]
    #[cfg(feature = "VK_KHR_maintenance1")]
    pub const N2D_ARRAY_COMPATIBLE_KHR: Self = Self::N2D_ARRAY_COMPATIBLE;
    #[doc(alias = "VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT_KHR")]
    #[cfg(feature = "VK_KHR_maintenance2")]
    pub const BLOCK_TEXEL_VIEW_COMPATIBLE_KHR: Self = Self::BLOCK_TEXEL_VIEW_COMPATIBLE;
    #[doc(alias = "VK_IMAGE_CREATE_EXTENDED_USAGE_BIT_KHR")]
    #[cfg(feature = "VK_KHR_maintenance2")]
    pub const EXTENDED_USAGE_KHR: Self = Self::EXTENDED_USAGE;
    #[doc(alias = "VK_IMAGE_CREATE_DISJOINT_BIT_KHR")]
    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
    pub const DISJOINT_KHR: Self = Self::DISJOINT;
    #[doc(alias = "VK_IMAGE_CREATE_ALIAS_BIT_KHR")]
    #[cfg(feature = "VK_KHR_bind_memory2")]
    pub const ALIAS_KHR: Self = Self::ALIAS;
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    #[allow(unused_mut)]
    pub const fn all() -> Self {
        let mut all = Self::empty();
        {
            all |= Self::SPARSE_BINDING;
        }
        {
            all |= Self::SPARSE_RESIDENCY;
        }
        {
            all |= Self::SPARSE_ALIASED;
        }
        {
            all |= Self::MUTABLE_FORMAT;
        }
        {
            all |= Self::CUBE_COMPATIBLE;
        }
        {
            all |= Self::ALIAS;
        }
        {
            all |= Self::SPLIT_INSTANCE_BIND_REGIONS;
        }
        {
            all |= Self::N2D_ARRAY_COMPATIBLE;
        }
        {
            all |= Self::BLOCK_TEXEL_VIEW_COMPATIBLE;
        }
        {
            all |= Self::EXTENDED_USAGE;
        }
        {
            all |= Self::PROTECTED;
        }
        {
            all |= Self::DISJOINT;
        }
        #[cfg(feature = "VK_NV_corner_sampled_image")]
        {
            all |= Self::CORNER_SAMPLED_NV;
        }
        #[cfg(feature = "VK_EXT_sample_locations")]
        {
            all |= Self::SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_EXT;
        }
        #[cfg(feature = "VK_EXT_fragment_density_map")]
        {
            all |= Self::SUBSAMPLED_EXT;
        }
        #[cfg(feature = "VK_KHR_device_group")]
        {
            all |= Self::SPLIT_INSTANCE_BIND_REGIONS_KHR;
        }
        #[cfg(feature = "VK_KHR_maintenance1")]
        {
            all |= Self::N2D_ARRAY_COMPATIBLE_KHR;
        }
        #[cfg(feature = "VK_KHR_maintenance2")]
        {
            all |= Self::BLOCK_TEXEL_VIEW_COMPATIBLE_KHR;
        }
        #[cfg(feature = "VK_KHR_maintenance2")]
        {
            all |= Self::EXTENDED_USAGE_KHR;
        }
        #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
        {
            all |= Self::DISJOINT_KHR;
        }
        #[cfg(feature = "VK_KHR_bind_memory2")]
        {
            all |= Self::ALIAS_KHR;
        }
        all
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl std::ops::BitOr for ImageCreateFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl std::ops::BitOrAssign for ImageCreateFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl std::ops::BitXor for ImageCreateFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl std::ops::BitXorAssign for ImageCreateFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl std::ops::BitAnd for ImageCreateFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl std::ops::BitAndAssign for ImageCreateFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl std::ops::Sub for ImageCreateFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl std::ops::SubAssign for ImageCreateFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl std::ops::Not for ImageCreateFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl Extend<ImageCreateFlags> for ImageCreateFlags {
    fn extend<T: IntoIterator<Item = ImageCreateFlags>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, i);
        }
    }
}
impl FromIterator<ImageCreateFlags> for ImageCreateFlags {
    fn from_iter<T: IntoIterator<Item = ImageCreateFlags>>(iterator: T) -> ImageCreateFlags {
        let mut out = Self::empty();
        <Self as Extend<ImageCreateFlags>>::extend(&mut out, iterator);
        out
    }
}
impl Default for ImageCreateFlags {
    fn default() -> Self {
        Self::empty()
    }
}
impl From<ImageCreateFlagBits> for ImageCreateFlags {
    fn from(bit: ImageCreateFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(bit.bits()) }
    }
}
impl Extend<ImageCreateFlagBits> for ImageCreateFlags {
    fn extend<T: IntoIterator<Item = ImageCreateFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, Self::from(i));
        }
    }
}
impl FromIterator<ImageCreateFlagBits> for ImageCreateFlags {
    fn from_iter<T: IntoIterator<Item = ImageCreateFlagBits>>(iterator: T) -> ImageCreateFlags {
        let mut out = Self::empty();
        <Self as Extend<ImageCreateFlagBits>>::extend(&mut out, iterator);
        out
    }
}
impl std::fmt::Debug for ImageCreateFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(ImageCreateFlags);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == ImageCreateFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(ImageCreateFlags::SPARSE_BINDING) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(SPARSE_BINDING))?;
                    }
                    if self.0.contains(ImageCreateFlags::SPARSE_RESIDENCY) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(SPARSE_RESIDENCY))?;
                    }
                    if self.0.contains(ImageCreateFlags::SPARSE_ALIASED) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(SPARSE_ALIASED))?;
                    }
                    if self.0.contains(ImageCreateFlags::MUTABLE_FORMAT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(MUTABLE_FORMAT))?;
                    }
                    if self.0.contains(ImageCreateFlags::CUBE_COMPATIBLE) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(CUBE_COMPATIBLE))?;
                    }
                    if self.0.contains(ImageCreateFlags::ALIAS) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(ALIAS))?;
                    }
                    if self.0.contains(ImageCreateFlags::SPLIT_INSTANCE_BIND_REGIONS) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(SPLIT_INSTANCE_BIND_REGIONS))?;
                    }
                    if self.0.contains(ImageCreateFlags::N2D_ARRAY_COMPATIBLE) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(N2D_ARRAY_COMPATIBLE))?;
                    }
                    if self.0.contains(ImageCreateFlags::BLOCK_TEXEL_VIEW_COMPATIBLE) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(BLOCK_TEXEL_VIEW_COMPATIBLE))?;
                    }
                    if self.0.contains(ImageCreateFlags::EXTENDED_USAGE) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(EXTENDED_USAGE))?;
                    }
                    if self.0.contains(ImageCreateFlags::PROTECTED) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(PROTECTED))?;
                    }
                    if self.0.contains(ImageCreateFlags::DISJOINT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(DISJOINT))?;
                    }
                    #[cfg(feature = "VK_NV_corner_sampled_image")]
                    if self.0.contains(ImageCreateFlags::CORNER_SAMPLED_NV) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(CORNER_SAMPLED_NV))?;
                    }
                    #[cfg(feature = "VK_EXT_sample_locations")]
                    if self.0.contains(ImageCreateFlags::SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_EXT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_EXT))?;
                    }
                    #[cfg(feature = "VK_EXT_fragment_density_map")]
                    if self.0.contains(ImageCreateFlags::SUBSAMPLED_EXT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(SUBSAMPLED_EXT))?;
                    }
                    #[cfg(feature = "VK_KHR_device_group")]
                    if self.0.contains(ImageCreateFlags::SPLIT_INSTANCE_BIND_REGIONS_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(SPLIT_INSTANCE_BIND_REGIONS_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_maintenance1")]
                    if self.0.contains(ImageCreateFlags::N2D_ARRAY_COMPATIBLE_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(N2D_ARRAY_COMPATIBLE_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_maintenance2")]
                    if self.0.contains(ImageCreateFlags::BLOCK_TEXEL_VIEW_COMPATIBLE_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(BLOCK_TEXEL_VIEW_COMPATIBLE_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_maintenance2")]
                    if self.0.contains(ImageCreateFlags::EXTENDED_USAGE_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(EXTENDED_USAGE_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
                    if self.0.contains(ImageCreateFlags::DISJOINT_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(DISJOINT_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_bind_memory2")]
                    if self.0.contains(ImageCreateFlags::ALIAS_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(ALIAS_KHR))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(ImageCreateFlags))
            .field(&Flags(*self))
            .finish()
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for ImageCreateFlags {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for ImageCreateFlags {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkImageViewCreateFlags")]
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct ImageViewCreateFlags(u32);
impl ImageViewCreateFlags {
    #[doc(alias = "VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT")]
    #[cfg(feature = "VK_EXT_fragment_density_map")]
    pub const FRAGMENT_DENSITY_MAP_DYNAMIC_EXT: Self = Self(1);
    #[doc(alias = "VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DEFERRED_BIT_EXT")]
    #[cfg(feature = "VK_EXT_fragment_density_map2")]
    pub const FRAGMENT_DENSITY_MAP_DEFERRED_EXT: Self = Self(2);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    #[allow(unused_mut)]
    pub const fn all() -> Self {
        let mut all = Self::empty();
        #[cfg(feature = "VK_EXT_fragment_density_map")]
        {
            all |= Self::FRAGMENT_DENSITY_MAP_DYNAMIC_EXT;
        }
        #[cfg(feature = "VK_EXT_fragment_density_map2")]
        {
            all |= Self::FRAGMENT_DENSITY_MAP_DEFERRED_EXT;
        }
        all
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl std::ops::BitOr for ImageViewCreateFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl std::ops::BitOrAssign for ImageViewCreateFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl std::ops::BitXor for ImageViewCreateFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl std::ops::BitXorAssign for ImageViewCreateFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl std::ops::BitAnd for ImageViewCreateFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl std::ops::BitAndAssign for ImageViewCreateFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl std::ops::Sub for ImageViewCreateFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl std::ops::SubAssign for ImageViewCreateFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl std::ops::Not for ImageViewCreateFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl Extend<ImageViewCreateFlags> for ImageViewCreateFlags {
    fn extend<T: IntoIterator<Item = ImageViewCreateFlags>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, i);
        }
    }
}
impl FromIterator<ImageViewCreateFlags> for ImageViewCreateFlags {
    fn from_iter<T: IntoIterator<Item = ImageViewCreateFlags>>(iterator: T) -> ImageViewCreateFlags {
        let mut out = Self::empty();
        <Self as Extend<ImageViewCreateFlags>>::extend(&mut out, iterator);
        out
    }
}
impl Default for ImageViewCreateFlags {
    fn default() -> Self {
        Self::empty()
    }
}
impl From<ImageViewCreateFlagBits> for ImageViewCreateFlags {
    fn from(bit: ImageViewCreateFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(bit.bits()) }
    }
}
impl Extend<ImageViewCreateFlagBits> for ImageViewCreateFlags {
    fn extend<T: IntoIterator<Item = ImageViewCreateFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, Self::from(i));
        }
    }
}
impl FromIterator<ImageViewCreateFlagBits> for ImageViewCreateFlags {
    fn from_iter<T: IntoIterator<Item = ImageViewCreateFlagBits>>(iterator: T) -> ImageViewCreateFlags {
        let mut out = Self::empty();
        <Self as Extend<ImageViewCreateFlagBits>>::extend(&mut out, iterator);
        out
    }
}
impl std::fmt::Debug for ImageViewCreateFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(ImageViewCreateFlags);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == ImageViewCreateFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    #[cfg(feature = "VK_EXT_fragment_density_map")]
                    if self.0.contains(ImageViewCreateFlags::FRAGMENT_DENSITY_MAP_DYNAMIC_EXT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(FRAGMENT_DENSITY_MAP_DYNAMIC_EXT))?;
                    }
                    #[cfg(feature = "VK_EXT_fragment_density_map2")]
                    if self.0.contains(ImageViewCreateFlags::FRAGMENT_DENSITY_MAP_DEFERRED_EXT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(FRAGMENT_DENSITY_MAP_DEFERRED_EXT))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(ImageViewCreateFlags))
            .field(&Flags(*self))
            .finish()
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for ImageViewCreateFlags {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for ImageViewCreateFlags {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkPipelineCreateFlags")]
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct PipelineCreateFlags(u32);
impl PipelineCreateFlags {
    #[doc(alias = "VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT")]
    pub const DISABLE_OPTIMIZATION: Self = Self(1);
    #[doc(alias = "VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT")]
    pub const ALLOW_DERIVATIVES: Self = Self(2);
    #[doc(alias = "VK_PIPELINE_CREATE_DERIVATIVE_BIT")]
    pub const DERIVATIVE: Self = Self(4);
    #[doc(alias = "VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT")]
    pub const VIEW_INDEX_FROM_DEVICE_INDEX: Self = Self(8);
    #[doc(alias = "VK_PIPELINE_CREATE_DISPATCH_BASE_BIT")]
    pub const DISPATCH_BASE: Self = Self(16);
    #[doc(alias = "VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const FAIL_ON_PIPELINE_COMPILE_REQUIRED: Self = Self(256);
    #[doc(alias = "VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const EARLY_RETURN_ON_FAILURE: Self = Self(512);
    #[doc(alias = "VK_PIPELINE_CREATE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR")]
    #[cfg(feature = "VK_KHR_dynamic_rendering")]
    pub const RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_KHR: Self = Self(2097152);
    #[doc(alias = "VK_PIPELINE_CREATE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT")]
    #[cfg(feature = "VK_KHR_dynamic_rendering")]
    pub const RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_EXT: Self = Self(4194304);
    #[doc(alias = "VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR")]
    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
    pub const RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_KHR: Self = Self(16384);
    #[doc(alias = "VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR")]
    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
    pub const RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_KHR: Self = Self(32768);
    #[doc(alias = "VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR")]
    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
    pub const RAY_TRACING_NO_NULL_MISS_SHADERS_KHR: Self = Self(65536);
    #[doc(alias = "VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR")]
    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
    pub const RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_KHR: Self = Self(131072);
    #[doc(alias = "VK_PIPELINE_CREATE_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR")]
    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
    pub const RAY_TRACING_SKIP_TRIANGLES_KHR: Self = Self(4096);
    #[doc(alias = "VK_PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR")]
    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
    pub const RAY_TRACING_SKIP_AABBS_KHR: Self = Self(8192);
    #[doc(alias = "VK_PIPELINE_CREATE_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR")]
    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
    pub const RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_KHR: Self = Self(524288);
    #[doc(alias = "VK_PIPELINE_CREATE_DEFER_COMPILE_BIT_NV")]
    #[cfg(feature = "VK_NV_ray_tracing")]
    pub const DEFER_COMPILE_NV: Self = Self(32);
    #[doc(alias = "VK_PIPELINE_CREATE_CAPTURE_STATISTICS_BIT_KHR")]
    #[cfg(feature = "VK_KHR_pipeline_executable_properties")]
    pub const CAPTURE_STATISTICS_KHR: Self = Self(64);
    #[doc(alias = "VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR")]
    #[cfg(feature = "VK_KHR_pipeline_executable_properties")]
    pub const CAPTURE_INTERNAL_REPRESENTATIONS_KHR: Self = Self(128);
    #[doc(alias = "VK_PIPELINE_CREATE_INDIRECT_BINDABLE_BIT_NV")]
    #[cfg(feature = "VK_NV_device_generated_commands")]
    pub const INDIRECT_BINDABLE_NV: Self = Self(262144);
    #[doc(alias = "VK_PIPELINE_CREATE_LIBRARY_BIT_KHR")]
    #[cfg(feature = "VK_KHR_pipeline_library")]
    pub const LIBRARY_KHR: Self = Self(2048);
    #[doc(alias = "VK_PIPELINE_CREATE_RAY_TRACING_ALLOW_MOTION_BIT_NV")]
    #[cfg(feature = "VK_NV_ray_tracing_motion_blur")]
    pub const RAY_TRACING_ALLOW_MOTION_NV: Self = Self(1048576);
    #[doc(alias = "VK_PIPELINE_CREATE_DISPATCH_BASE")]
    pub const DISPATCH_BASE_DUP: Self = Self::DISPATCH_BASE;
    #[doc(alias = "VK_PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR")]
    #[cfg(feature = "VK_KHR_dynamic_rendering")]
    pub const PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_SHADING_RATE_ATTACHMENT_KHR: Self =
        Self::RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_KHR;
    #[doc(alias = "VK_PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT")]
    #[cfg(feature = "VK_KHR_dynamic_rendering")]
    pub const PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_DENSITY_MAP_ATTACHMENT_EXT: Self =
        Self::RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_EXT;
    #[doc(alias = "VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR")]
    #[cfg(feature = "VK_KHR_device_group")]
    pub const VIEW_INDEX_FROM_DEVICE_INDEX_KHR: Self = Self::VIEW_INDEX_FROM_DEVICE_INDEX;
    #[doc(alias = "VK_PIPELINE_CREATE_DISPATCH_BASE_KHR")]
    #[cfg(feature = "VK_KHR_device_group")]
    pub const DISPATCH_BASE_KHR: Self = Self::DISPATCH_BASE_DUP;
    #[doc(alias = "VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT_EXT")]
    #[cfg(feature = "VK_EXT_pipeline_creation_cache_control")]
    pub const FAIL_ON_PIPELINE_COMPILE_REQUIRED_EXT: Self = Self::FAIL_ON_PIPELINE_COMPILE_REQUIRED;
    #[doc(alias = "VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT_EXT")]
    #[cfg(feature = "VK_EXT_pipeline_creation_cache_control")]
    pub const EARLY_RETURN_ON_FAILURE_EXT: Self = Self::EARLY_RETURN_ON_FAILURE;
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    #[allow(unused_mut)]
    pub const fn all() -> Self {
        let mut all = Self::empty();
        {
            all |= Self::DISABLE_OPTIMIZATION;
        }
        {
            all |= Self::ALLOW_DERIVATIVES;
        }
        {
            all |= Self::DERIVATIVE;
        }
        {
            all |= Self::VIEW_INDEX_FROM_DEVICE_INDEX;
        }
        {
            all |= Self::DISPATCH_BASE;
        }
        #[cfg(feature = "VULKAN_1_3")]
        {
            all |= Self::FAIL_ON_PIPELINE_COMPILE_REQUIRED;
        }
        #[cfg(feature = "VULKAN_1_3")]
        {
            all |= Self::EARLY_RETURN_ON_FAILURE;
        }
        #[cfg(feature = "VK_KHR_dynamic_rendering")]
        {
            all |= Self::RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_KHR;
        }
        #[cfg(feature = "VK_KHR_dynamic_rendering")]
        {
            all |= Self::RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_EXT;
        }
        #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
        {
            all |= Self::RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_KHR;
        }
        #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
        {
            all |= Self::RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_KHR;
        }
        #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
        {
            all |= Self::RAY_TRACING_NO_NULL_MISS_SHADERS_KHR;
        }
        #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
        {
            all |= Self::RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_KHR;
        }
        #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
        {
            all |= Self::RAY_TRACING_SKIP_TRIANGLES_KHR;
        }
        #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
        {
            all |= Self::RAY_TRACING_SKIP_AABBS_KHR;
        }
        #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
        {
            all |= Self::RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_KHR;
        }
        #[cfg(feature = "VK_NV_ray_tracing")]
        {
            all |= Self::DEFER_COMPILE_NV;
        }
        #[cfg(feature = "VK_KHR_pipeline_executable_properties")]
        {
            all |= Self::CAPTURE_STATISTICS_KHR;
        }
        #[cfg(feature = "VK_KHR_pipeline_executable_properties")]
        {
            all |= Self::CAPTURE_INTERNAL_REPRESENTATIONS_KHR;
        }
        #[cfg(feature = "VK_NV_device_generated_commands")]
        {
            all |= Self::INDIRECT_BINDABLE_NV;
        }
        #[cfg(feature = "VK_KHR_pipeline_library")]
        {
            all |= Self::LIBRARY_KHR;
        }
        #[cfg(feature = "VK_NV_ray_tracing_motion_blur")]
        {
            all |= Self::RAY_TRACING_ALLOW_MOTION_NV;
        }
        {
            all |= Self::DISPATCH_BASE_DUP;
        }
        #[cfg(feature = "VK_KHR_dynamic_rendering")]
        {
            all |= Self::PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_SHADING_RATE_ATTACHMENT_KHR;
        }
        #[cfg(feature = "VK_KHR_dynamic_rendering")]
        {
            all |= Self::PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_DENSITY_MAP_ATTACHMENT_EXT;
        }
        #[cfg(feature = "VK_KHR_device_group")]
        {
            all |= Self::VIEW_INDEX_FROM_DEVICE_INDEX_KHR;
        }
        #[cfg(feature = "VK_KHR_device_group")]
        {
            all |= Self::DISPATCH_BASE_KHR;
        }
        #[cfg(feature = "VK_EXT_pipeline_creation_cache_control")]
        {
            all |= Self::FAIL_ON_PIPELINE_COMPILE_REQUIRED_EXT;
        }
        #[cfg(feature = "VK_EXT_pipeline_creation_cache_control")]
        {
            all |= Self::EARLY_RETURN_ON_FAILURE_EXT;
        }
        all
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl std::ops::BitOr for PipelineCreateFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl std::ops::BitOrAssign for PipelineCreateFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl std::ops::BitXor for PipelineCreateFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl std::ops::BitXorAssign for PipelineCreateFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl std::ops::BitAnd for PipelineCreateFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl std::ops::BitAndAssign for PipelineCreateFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl std::ops::Sub for PipelineCreateFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl std::ops::SubAssign for PipelineCreateFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl std::ops::Not for PipelineCreateFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl Extend<PipelineCreateFlags> for PipelineCreateFlags {
    fn extend<T: IntoIterator<Item = PipelineCreateFlags>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, i);
        }
    }
}
impl FromIterator<PipelineCreateFlags> for PipelineCreateFlags {
    fn from_iter<T: IntoIterator<Item = PipelineCreateFlags>>(iterator: T) -> PipelineCreateFlags {
        let mut out = Self::empty();
        <Self as Extend<PipelineCreateFlags>>::extend(&mut out, iterator);
        out
    }
}
impl Default for PipelineCreateFlags {
    fn default() -> Self {
        Self::empty()
    }
}
impl From<PipelineCreateFlagBits> for PipelineCreateFlags {
    fn from(bit: PipelineCreateFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(bit.bits()) }
    }
}
impl Extend<PipelineCreateFlagBits> for PipelineCreateFlags {
    fn extend<T: IntoIterator<Item = PipelineCreateFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, Self::from(i));
        }
    }
}
impl FromIterator<PipelineCreateFlagBits> for PipelineCreateFlags {
    fn from_iter<T: IntoIterator<Item = PipelineCreateFlagBits>>(iterator: T) -> PipelineCreateFlags {
        let mut out = Self::empty();
        <Self as Extend<PipelineCreateFlagBits>>::extend(&mut out, iterator);
        out
    }
}
impl std::fmt::Debug for PipelineCreateFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(PipelineCreateFlags);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == PipelineCreateFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(PipelineCreateFlags::DISABLE_OPTIMIZATION) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(DISABLE_OPTIMIZATION))?;
                    }
                    if self.0.contains(PipelineCreateFlags::ALLOW_DERIVATIVES) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(ALLOW_DERIVATIVES))?;
                    }
                    if self.0.contains(PipelineCreateFlags::DERIVATIVE) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(DERIVATIVE))?;
                    }
                    if self.0.contains(PipelineCreateFlags::VIEW_INDEX_FROM_DEVICE_INDEX) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(VIEW_INDEX_FROM_DEVICE_INDEX))?;
                    }
                    if self.0.contains(PipelineCreateFlags::DISPATCH_BASE) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(DISPATCH_BASE))?;
                    }
                    #[cfg(feature = "VULKAN_1_3")]
                    if self.0.contains(PipelineCreateFlags::FAIL_ON_PIPELINE_COMPILE_REQUIRED) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(FAIL_ON_PIPELINE_COMPILE_REQUIRED))?;
                    }
                    #[cfg(feature = "VULKAN_1_3")]
                    if self.0.contains(PipelineCreateFlags::EARLY_RETURN_ON_FAILURE) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(EARLY_RETURN_ON_FAILURE))?;
                    }
                    #[cfg(feature = "VK_KHR_dynamic_rendering")]
                    if self
                        .0
                        .contains(PipelineCreateFlags::RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_KHR)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_dynamic_rendering")]
                    if self
                        .0
                        .contains(PipelineCreateFlags::RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_EXT)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_EXT))?;
                    }
                    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
                    if self
                        .0
                        .contains(PipelineCreateFlags::RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_KHR)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
                    if self
                        .0
                        .contains(PipelineCreateFlags::RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_KHR)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
                    if self
                        .0
                        .contains(PipelineCreateFlags::RAY_TRACING_NO_NULL_MISS_SHADERS_KHR)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(RAY_TRACING_NO_NULL_MISS_SHADERS_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
                    if self
                        .0
                        .contains(PipelineCreateFlags::RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_KHR)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
                    if self.0.contains(PipelineCreateFlags::RAY_TRACING_SKIP_TRIANGLES_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(RAY_TRACING_SKIP_TRIANGLES_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
                    if self.0.contains(PipelineCreateFlags::RAY_TRACING_SKIP_AABBS_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(RAY_TRACING_SKIP_AABBS_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
                    if self
                        .0
                        .contains(PipelineCreateFlags::RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_KHR)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_KHR))?;
                    }
                    #[cfg(feature = "VK_NV_ray_tracing")]
                    if self.0.contains(PipelineCreateFlags::DEFER_COMPILE_NV) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(DEFER_COMPILE_NV))?;
                    }
                    #[cfg(feature = "VK_KHR_pipeline_executable_properties")]
                    if self.0.contains(PipelineCreateFlags::CAPTURE_STATISTICS_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(CAPTURE_STATISTICS_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_pipeline_executable_properties")]
                    if self
                        .0
                        .contains(PipelineCreateFlags::CAPTURE_INTERNAL_REPRESENTATIONS_KHR)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(CAPTURE_INTERNAL_REPRESENTATIONS_KHR))?;
                    }
                    #[cfg(feature = "VK_NV_device_generated_commands")]
                    if self.0.contains(PipelineCreateFlags::INDIRECT_BINDABLE_NV) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(INDIRECT_BINDABLE_NV))?;
                    }
                    #[cfg(feature = "VK_KHR_pipeline_library")]
                    if self.0.contains(PipelineCreateFlags::LIBRARY_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(LIBRARY_KHR))?;
                    }
                    #[cfg(feature = "VK_NV_ray_tracing_motion_blur")]
                    if self.0.contains(PipelineCreateFlags::RAY_TRACING_ALLOW_MOTION_NV) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(RAY_TRACING_ALLOW_MOTION_NV))?;
                    }
                    if self.0.contains(PipelineCreateFlags::DISPATCH_BASE_DUP) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(DISPATCH_BASE_DUP))?;
                    }
                    #[cfg(feature = "VK_KHR_dynamic_rendering")]
                    if self.0.contains(
                        PipelineCreateFlags::PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_SHADING_RATE_ATTACHMENT_KHR,
                    ) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(
                            PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_SHADING_RATE_ATTACHMENT_KHR
                        ))?;
                    }
                    #[cfg(feature = "VK_KHR_dynamic_rendering")]
                    if self.0.contains(
                        PipelineCreateFlags::PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_DENSITY_MAP_ATTACHMENT_EXT,
                    ) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(
                            PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_DENSITY_MAP_ATTACHMENT_EXT
                        ))?;
                    }
                    #[cfg(feature = "VK_KHR_device_group")]
                    if self.0.contains(PipelineCreateFlags::VIEW_INDEX_FROM_DEVICE_INDEX_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(VIEW_INDEX_FROM_DEVICE_INDEX_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_device_group")]
                    if self.0.contains(PipelineCreateFlags::DISPATCH_BASE_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(DISPATCH_BASE_KHR))?;
                    }
                    #[cfg(feature = "VK_EXT_pipeline_creation_cache_control")]
                    if self
                        .0
                        .contains(PipelineCreateFlags::FAIL_ON_PIPELINE_COMPILE_REQUIRED_EXT)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(FAIL_ON_PIPELINE_COMPILE_REQUIRED_EXT))?;
                    }
                    #[cfg(feature = "VK_EXT_pipeline_creation_cache_control")]
                    if self.0.contains(PipelineCreateFlags::EARLY_RETURN_ON_FAILURE_EXT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(EARLY_RETURN_ON_FAILURE_EXT))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(PipelineCreateFlags))
            .field(&Flags(*self))
            .finish()
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for PipelineCreateFlags {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for PipelineCreateFlags {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkColorComponentFlags")]
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct ColorComponentFlags(u32);
impl ColorComponentFlags {
    #[doc(alias = "VK_COLOR_COMPONENT_R_BIT")]
    pub const R: Self = Self(1);
    #[doc(alias = "VK_COLOR_COMPONENT_G_BIT")]
    pub const G: Self = Self(2);
    #[doc(alias = "VK_COLOR_COMPONENT_B_BIT")]
    pub const B: Self = Self(4);
    #[doc(alias = "VK_COLOR_COMPONENT_A_BIT")]
    pub const A: Self = Self(8);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    #[allow(unused_mut)]
    pub const fn all() -> Self {
        let mut all = Self::empty();
        {
            all |= Self::R;
        }
        {
            all |= Self::G;
        }
        {
            all |= Self::B;
        }
        {
            all |= Self::A;
        }
        all
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl std::ops::BitOr for ColorComponentFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl std::ops::BitOrAssign for ColorComponentFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl std::ops::BitXor for ColorComponentFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl std::ops::BitXorAssign for ColorComponentFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl std::ops::BitAnd for ColorComponentFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl std::ops::BitAndAssign for ColorComponentFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl std::ops::Sub for ColorComponentFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl std::ops::SubAssign for ColorComponentFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl std::ops::Not for ColorComponentFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl Extend<ColorComponentFlags> for ColorComponentFlags {
    fn extend<T: IntoIterator<Item = ColorComponentFlags>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, i);
        }
    }
}
impl FromIterator<ColorComponentFlags> for ColorComponentFlags {
    fn from_iter<T: IntoIterator<Item = ColorComponentFlags>>(iterator: T) -> ColorComponentFlags {
        let mut out = Self::empty();
        <Self as Extend<ColorComponentFlags>>::extend(&mut out, iterator);
        out
    }
}
impl Default for ColorComponentFlags {
    fn default() -> Self {
        Self::empty()
    }
}
impl From<ColorComponentFlagBits> for ColorComponentFlags {
    fn from(bit: ColorComponentFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(bit.bits()) }
    }
}
impl Extend<ColorComponentFlagBits> for ColorComponentFlags {
    fn extend<T: IntoIterator<Item = ColorComponentFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, Self::from(i));
        }
    }
}
impl FromIterator<ColorComponentFlagBits> for ColorComponentFlags {
    fn from_iter<T: IntoIterator<Item = ColorComponentFlagBits>>(iterator: T) -> ColorComponentFlags {
        let mut out = Self::empty();
        <Self as Extend<ColorComponentFlagBits>>::extend(&mut out, iterator);
        out
    }
}
impl std::fmt::Debug for ColorComponentFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(ColorComponentFlags);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == ColorComponentFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(ColorComponentFlags::R) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(R))?;
                    }
                    if self.0.contains(ColorComponentFlags::G) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(G))?;
                    }
                    if self.0.contains(ColorComponentFlags::B) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(B))?;
                    }
                    if self.0.contains(ColorComponentFlags::A) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(A))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(ColorComponentFlags))
            .field(&Flags(*self))
            .finish()
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for ColorComponentFlags {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for ColorComponentFlags {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkFenceCreateFlags")]
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct FenceCreateFlags(u32);
impl FenceCreateFlags {
    #[doc(alias = "VK_FENCE_CREATE_SIGNALED_BIT")]
    pub const SIGNALED: Self = Self(1);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    #[allow(unused_mut)]
    pub const fn all() -> Self {
        let mut all = Self::empty();
        {
            all |= Self::SIGNALED;
        }
        all
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl std::ops::BitOr for FenceCreateFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl std::ops::BitOrAssign for FenceCreateFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl std::ops::BitXor for FenceCreateFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl std::ops::BitXorAssign for FenceCreateFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl std::ops::BitAnd for FenceCreateFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl std::ops::BitAndAssign for FenceCreateFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl std::ops::Sub for FenceCreateFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl std::ops::SubAssign for FenceCreateFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl std::ops::Not for FenceCreateFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl Extend<FenceCreateFlags> for FenceCreateFlags {
    fn extend<T: IntoIterator<Item = FenceCreateFlags>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, i);
        }
    }
}
impl FromIterator<FenceCreateFlags> for FenceCreateFlags {
    fn from_iter<T: IntoIterator<Item = FenceCreateFlags>>(iterator: T) -> FenceCreateFlags {
        let mut out = Self::empty();
        <Self as Extend<FenceCreateFlags>>::extend(&mut out, iterator);
        out
    }
}
impl Default for FenceCreateFlags {
    fn default() -> Self {
        Self::empty()
    }
}
impl From<FenceCreateFlagBits> for FenceCreateFlags {
    fn from(bit: FenceCreateFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(bit.bits()) }
    }
}
impl Extend<FenceCreateFlagBits> for FenceCreateFlags {
    fn extend<T: IntoIterator<Item = FenceCreateFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, Self::from(i));
        }
    }
}
impl FromIterator<FenceCreateFlagBits> for FenceCreateFlags {
    fn from_iter<T: IntoIterator<Item = FenceCreateFlagBits>>(iterator: T) -> FenceCreateFlags {
        let mut out = Self::empty();
        <Self as Extend<FenceCreateFlagBits>>::extend(&mut out, iterator);
        out
    }
}
impl std::fmt::Debug for FenceCreateFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(FenceCreateFlags);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == FenceCreateFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(FenceCreateFlags::SIGNALED) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(SIGNALED))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(FenceCreateFlags))
            .field(&Flags(*self))
            .finish()
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for FenceCreateFlags {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for FenceCreateFlags {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkSemaphoreCreateFlags")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct SemaphoreCreateFlags(u32);
impl SemaphoreCreateFlags {
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
}
impl Default for SemaphoreCreateFlags {
    #[inline]
    fn default() -> Self {
        Self::empty()
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for SemaphoreCreateFlags {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for SemaphoreCreateFlags {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkFormatFeatureFlags")]
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct FormatFeatureFlags(u32);
impl FormatFeatureFlags {
    #[doc(alias = "VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT")]
    pub const SAMPLED_IMAGE: Self = Self(1);
    #[doc(alias = "VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT")]
    pub const STORAGE_IMAGE: Self = Self(2);
    #[doc(alias = "VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT")]
    pub const STORAGE_IMAGE_ATOMIC: Self = Self(4);
    #[doc(alias = "VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT")]
    pub const UNIFORM_TEXEL_BUFFER: Self = Self(8);
    #[doc(alias = "VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT")]
    pub const STORAGE_TEXEL_BUFFER: Self = Self(16);
    #[doc(alias = "VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT")]
    pub const STORAGE_TEXEL_BUFFER_ATOMIC: Self = Self(32);
    #[doc(alias = "VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT")]
    pub const VERTEX_BUFFER: Self = Self(64);
    #[doc(alias = "VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT")]
    pub const COLOR_ATTACHMENT: Self = Self(128);
    #[doc(alias = "VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT")]
    pub const COLOR_ATTACHMENT_BLEND: Self = Self(256);
    #[doc(alias = "VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT")]
    pub const DEPTH_STENCIL_ATTACHMENT: Self = Self(512);
    #[doc(alias = "VK_FORMAT_FEATURE_BLIT_SRC_BIT")]
    pub const BLIT_SRC: Self = Self(1024);
    #[doc(alias = "VK_FORMAT_FEATURE_BLIT_DST_BIT")]
    pub const BLIT_DST: Self = Self(2048);
    #[doc(alias = "VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT")]
    pub const SAMPLED_IMAGE_FILTER_LINEAR: Self = Self(4096);
    #[doc(alias = "VK_FORMAT_FEATURE_TRANSFER_SRC_BIT")]
    pub const TRANSFER_SRC: Self = Self(16384);
    #[doc(alias = "VK_FORMAT_FEATURE_TRANSFER_DST_BIT")]
    pub const TRANSFER_DST: Self = Self(32768);
    #[doc(alias = "VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT")]
    pub const MIDPOINT_CHROMA_SAMPLES: Self = Self(131072);
    #[doc(alias = "VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT")]
    pub const SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER: Self = Self(262144);
    #[doc(alias = "VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT")]
    pub const SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER: Self = Self(524288);
    #[doc(alias = "VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT")]
    pub const SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT: Self = Self(1048576);
    #[doc(alias = "VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT")]
    pub const SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE: Self = Self(2097152);
    #[doc(alias = "VK_FORMAT_FEATURE_DISJOINT_BIT")]
    pub const DISJOINT: Self = Self(4194304);
    #[doc(alias = "VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT")]
    pub const COSITED_CHROMA_SAMPLES: Self = Self(8388608);
    #[doc(alias = "VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT")]
    #[cfg(feature = "VULKAN_1_2")]
    pub const SAMPLED_IMAGE_FILTER_MINMAX: Self = Self(65536);
    #[doc(alias = "VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG")]
    #[cfg(feature = "VK_IMG_filter_cubic")]
    pub const SAMPLED_IMAGE_FILTER_CUBIC_IMG: Self = Self(8192);
    #[doc(alias = "VK_FORMAT_FEATURE_VIDEO_DECODE_OUTPUT_BIT_KHR")]
    #[cfg(feature = "VK_KHR_video_decode_queue")]
    pub const VIDEO_DECODE_OUTPUT_KHR: Self = Self(33554432);
    #[doc(alias = "VK_FORMAT_FEATURE_VIDEO_DECODE_DPB_BIT_KHR")]
    #[cfg(feature = "VK_KHR_video_decode_queue")]
    pub const VIDEO_DECODE_DPB_KHR: Self = Self(67108864);
    #[doc(alias = "VK_FORMAT_FEATURE_ACCELERATION_STRUCTURE_VERTEX_BUFFER_BIT_KHR")]
    #[cfg(feature = "VK_KHR_acceleration_structure")]
    pub const ACCELERATION_STRUCTURE_VERTEX_BUFFER_KHR: Self = Self(536870912);
    #[doc(alias = "VK_FORMAT_FEATURE_FRAGMENT_DENSITY_MAP_BIT_EXT")]
    #[cfg(feature = "VK_EXT_fragment_density_map")]
    pub const FRAGMENT_DENSITY_MAP_EXT: Self = Self(16777216);
    #[doc(alias = "VK_FORMAT_FEATURE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR")]
    #[cfg(feature = "VK_KHR_fragment_shading_rate")]
    pub const FRAGMENT_SHADING_RATE_ATTACHMENT_KHR: Self = Self(1073741824);
    #[doc(alias = "VK_FORMAT_FEATURE_VIDEO_ENCODE_INPUT_BIT_KHR")]
    #[cfg(feature = "VK_KHR_video_encode_queue")]
    pub const VIDEO_ENCODE_INPUT_KHR: Self = Self(134217728);
    #[doc(alias = "VK_FORMAT_FEATURE_VIDEO_ENCODE_DPB_BIT_KHR")]
    #[cfg(feature = "VK_KHR_video_encode_queue")]
    pub const VIDEO_ENCODE_DPB_KHR: Self = Self(268435456);
    #[doc(alias = "VK_FORMAT_FEATURE_TRANSFER_SRC_BIT_KHR")]
    #[cfg(feature = "VK_KHR_maintenance1")]
    pub const TRANSFER_SRC_KHR: Self = Self::TRANSFER_SRC;
    #[doc(alias = "VK_FORMAT_FEATURE_TRANSFER_DST_BIT_KHR")]
    #[cfg(feature = "VK_KHR_maintenance1")]
    pub const TRANSFER_DST_KHR: Self = Self::TRANSFER_DST;
    #[doc(alias = "VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT")]
    #[cfg(feature = "VK_EXT_sampler_filter_minmax")]
    pub const SAMPLED_IMAGE_FILTER_MINMAX_EXT: Self = Self::SAMPLED_IMAGE_FILTER_MINMAX;
    #[doc(alias = "VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT_KHR")]
    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
    pub const MIDPOINT_CHROMA_SAMPLES_KHR: Self = Self::MIDPOINT_CHROMA_SAMPLES;
    #[doc(alias = "VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR")]
    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
    pub const SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_KHR: Self =
        Self::SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER;
    #[doc(alias = "VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR")]
    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
    pub const SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_KHR: Self =
        Self::SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER;
    #[doc(alias = "VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR")]
    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
    pub const SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_KHR: Self =
        Self::SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT;
    #[doc(alias = "VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR")]
    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
    pub const SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_KHR: Self =
        Self::SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE;
    #[doc(alias = "VK_FORMAT_FEATURE_DISJOINT_BIT_KHR")]
    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
    pub const DISJOINT_KHR: Self = Self::DISJOINT;
    #[doc(alias = "VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT_KHR")]
    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
    pub const COSITED_CHROMA_SAMPLES_KHR: Self = Self::COSITED_CHROMA_SAMPLES;
    #[doc(alias = "VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT")]
    #[cfg(feature = "VK_EXT_filter_cubic")]
    pub const SAMPLED_IMAGE_FILTER_CUBIC_EXT: Self = Self::SAMPLED_IMAGE_FILTER_CUBIC_IMG;
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    #[allow(unused_mut)]
    pub const fn all() -> Self {
        let mut all = Self::empty();
        {
            all |= Self::SAMPLED_IMAGE;
        }
        {
            all |= Self::STORAGE_IMAGE;
        }
        {
            all |= Self::STORAGE_IMAGE_ATOMIC;
        }
        {
            all |= Self::UNIFORM_TEXEL_BUFFER;
        }
        {
            all |= Self::STORAGE_TEXEL_BUFFER;
        }
        {
            all |= Self::STORAGE_TEXEL_BUFFER_ATOMIC;
        }
        {
            all |= Self::VERTEX_BUFFER;
        }
        {
            all |= Self::COLOR_ATTACHMENT;
        }
        {
            all |= Self::COLOR_ATTACHMENT_BLEND;
        }
        {
            all |= Self::DEPTH_STENCIL_ATTACHMENT;
        }
        {
            all |= Self::BLIT_SRC;
        }
        {
            all |= Self::BLIT_DST;
        }
        {
            all |= Self::SAMPLED_IMAGE_FILTER_LINEAR;
        }
        {
            all |= Self::TRANSFER_SRC;
        }
        {
            all |= Self::TRANSFER_DST;
        }
        {
            all |= Self::MIDPOINT_CHROMA_SAMPLES;
        }
        {
            all |= Self::SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER;
        }
        {
            all |= Self::SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER;
        }
        {
            all |= Self::SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT;
        }
        {
            all |= Self::SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE;
        }
        {
            all |= Self::DISJOINT;
        }
        {
            all |= Self::COSITED_CHROMA_SAMPLES;
        }
        #[cfg(feature = "VULKAN_1_2")]
        {
            all |= Self::SAMPLED_IMAGE_FILTER_MINMAX;
        }
        #[cfg(feature = "VK_IMG_filter_cubic")]
        {
            all |= Self::SAMPLED_IMAGE_FILTER_CUBIC_IMG;
        }
        #[cfg(feature = "VK_KHR_video_decode_queue")]
        {
            all |= Self::VIDEO_DECODE_OUTPUT_KHR;
        }
        #[cfg(feature = "VK_KHR_video_decode_queue")]
        {
            all |= Self::VIDEO_DECODE_DPB_KHR;
        }
        #[cfg(feature = "VK_KHR_acceleration_structure")]
        {
            all |= Self::ACCELERATION_STRUCTURE_VERTEX_BUFFER_KHR;
        }
        #[cfg(feature = "VK_EXT_fragment_density_map")]
        {
            all |= Self::FRAGMENT_DENSITY_MAP_EXT;
        }
        #[cfg(feature = "VK_KHR_fragment_shading_rate")]
        {
            all |= Self::FRAGMENT_SHADING_RATE_ATTACHMENT_KHR;
        }
        #[cfg(feature = "VK_KHR_video_encode_queue")]
        {
            all |= Self::VIDEO_ENCODE_INPUT_KHR;
        }
        #[cfg(feature = "VK_KHR_video_encode_queue")]
        {
            all |= Self::VIDEO_ENCODE_DPB_KHR;
        }
        #[cfg(feature = "VK_KHR_maintenance1")]
        {
            all |= Self::TRANSFER_SRC_KHR;
        }
        #[cfg(feature = "VK_KHR_maintenance1")]
        {
            all |= Self::TRANSFER_DST_KHR;
        }
        #[cfg(feature = "VK_EXT_sampler_filter_minmax")]
        {
            all |= Self::SAMPLED_IMAGE_FILTER_MINMAX_EXT;
        }
        #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
        {
            all |= Self::MIDPOINT_CHROMA_SAMPLES_KHR;
        }
        #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
        {
            all |= Self::SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_KHR;
        }
        #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
        {
            all |= Self::SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_KHR;
        }
        #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
        {
            all |= Self::SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_KHR;
        }
        #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
        {
            all |= Self::SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_KHR;
        }
        #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
        {
            all |= Self::DISJOINT_KHR;
        }
        #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
        {
            all |= Self::COSITED_CHROMA_SAMPLES_KHR;
        }
        #[cfg(feature = "VK_EXT_filter_cubic")]
        {
            all |= Self::SAMPLED_IMAGE_FILTER_CUBIC_EXT;
        }
        all
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl std::ops::BitOr for FormatFeatureFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl std::ops::BitOrAssign for FormatFeatureFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl std::ops::BitXor for FormatFeatureFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl std::ops::BitXorAssign for FormatFeatureFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl std::ops::BitAnd for FormatFeatureFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl std::ops::BitAndAssign for FormatFeatureFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl std::ops::Sub for FormatFeatureFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl std::ops::SubAssign for FormatFeatureFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl std::ops::Not for FormatFeatureFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl Extend<FormatFeatureFlags> for FormatFeatureFlags {
    fn extend<T: IntoIterator<Item = FormatFeatureFlags>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, i);
        }
    }
}
impl FromIterator<FormatFeatureFlags> for FormatFeatureFlags {
    fn from_iter<T: IntoIterator<Item = FormatFeatureFlags>>(iterator: T) -> FormatFeatureFlags {
        let mut out = Self::empty();
        <Self as Extend<FormatFeatureFlags>>::extend(&mut out, iterator);
        out
    }
}
impl Default for FormatFeatureFlags {
    fn default() -> Self {
        Self::empty()
    }
}
impl From<FormatFeatureFlagBits> for FormatFeatureFlags {
    fn from(bit: FormatFeatureFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(bit.bits()) }
    }
}
impl Extend<FormatFeatureFlagBits> for FormatFeatureFlags {
    fn extend<T: IntoIterator<Item = FormatFeatureFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, Self::from(i));
        }
    }
}
impl FromIterator<FormatFeatureFlagBits> for FormatFeatureFlags {
    fn from_iter<T: IntoIterator<Item = FormatFeatureFlagBits>>(iterator: T) -> FormatFeatureFlags {
        let mut out = Self::empty();
        <Self as Extend<FormatFeatureFlagBits>>::extend(&mut out, iterator);
        out
    }
}
impl std::fmt::Debug for FormatFeatureFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(FormatFeatureFlags);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == FormatFeatureFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(FormatFeatureFlags::SAMPLED_IMAGE) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(SAMPLED_IMAGE))?;
                    }
                    if self.0.contains(FormatFeatureFlags::STORAGE_IMAGE) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(STORAGE_IMAGE))?;
                    }
                    if self.0.contains(FormatFeatureFlags::STORAGE_IMAGE_ATOMIC) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(STORAGE_IMAGE_ATOMIC))?;
                    }
                    if self.0.contains(FormatFeatureFlags::UNIFORM_TEXEL_BUFFER) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(UNIFORM_TEXEL_BUFFER))?;
                    }
                    if self.0.contains(FormatFeatureFlags::STORAGE_TEXEL_BUFFER) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(STORAGE_TEXEL_BUFFER))?;
                    }
                    if self.0.contains(FormatFeatureFlags::STORAGE_TEXEL_BUFFER_ATOMIC) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(STORAGE_TEXEL_BUFFER_ATOMIC))?;
                    }
                    if self.0.contains(FormatFeatureFlags::VERTEX_BUFFER) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(VERTEX_BUFFER))?;
                    }
                    if self.0.contains(FormatFeatureFlags::COLOR_ATTACHMENT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(COLOR_ATTACHMENT))?;
                    }
                    if self.0.contains(FormatFeatureFlags::COLOR_ATTACHMENT_BLEND) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(COLOR_ATTACHMENT_BLEND))?;
                    }
                    if self.0.contains(FormatFeatureFlags::DEPTH_STENCIL_ATTACHMENT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(DEPTH_STENCIL_ATTACHMENT))?;
                    }
                    if self.0.contains(FormatFeatureFlags::BLIT_SRC) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(BLIT_SRC))?;
                    }
                    if self.0.contains(FormatFeatureFlags::BLIT_DST) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(BLIT_DST))?;
                    }
                    if self.0.contains(FormatFeatureFlags::SAMPLED_IMAGE_FILTER_LINEAR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(SAMPLED_IMAGE_FILTER_LINEAR))?;
                    }
                    if self.0.contains(FormatFeatureFlags::TRANSFER_SRC) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(TRANSFER_SRC))?;
                    }
                    if self.0.contains(FormatFeatureFlags::TRANSFER_DST) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(TRANSFER_DST))?;
                    }
                    if self.0.contains(FormatFeatureFlags::MIDPOINT_CHROMA_SAMPLES) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(MIDPOINT_CHROMA_SAMPLES))?;
                    }
                    if self
                        .0
                        .contains(FormatFeatureFlags::SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER))?;
                    }
                    if self
                        .0
                        .contains(FormatFeatureFlags::SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(
                            SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER
                        ))?;
                    }
                    if self
                        .0
                        .contains(FormatFeatureFlags::SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(
                            SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT
                        ))?;
                    }
                    if self.0.contains(
                        FormatFeatureFlags::SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE,
                    ) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(
                            SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE
                        ))?;
                    }
                    if self.0.contains(FormatFeatureFlags::DISJOINT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(DISJOINT))?;
                    }
                    if self.0.contains(FormatFeatureFlags::COSITED_CHROMA_SAMPLES) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(COSITED_CHROMA_SAMPLES))?;
                    }
                    #[cfg(feature = "VULKAN_1_2")]
                    if self.0.contains(FormatFeatureFlags::SAMPLED_IMAGE_FILTER_MINMAX) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(SAMPLED_IMAGE_FILTER_MINMAX))?;
                    }
                    #[cfg(feature = "VK_IMG_filter_cubic")]
                    if self.0.contains(FormatFeatureFlags::SAMPLED_IMAGE_FILTER_CUBIC_IMG) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(SAMPLED_IMAGE_FILTER_CUBIC_IMG))?;
                    }
                    #[cfg(feature = "VK_KHR_video_decode_queue")]
                    if self.0.contains(FormatFeatureFlags::VIDEO_DECODE_OUTPUT_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(VIDEO_DECODE_OUTPUT_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_video_decode_queue")]
                    if self.0.contains(FormatFeatureFlags::VIDEO_DECODE_DPB_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(VIDEO_DECODE_DPB_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_acceleration_structure")]
                    if self
                        .0
                        .contains(FormatFeatureFlags::ACCELERATION_STRUCTURE_VERTEX_BUFFER_KHR)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(ACCELERATION_STRUCTURE_VERTEX_BUFFER_KHR))?;
                    }
                    #[cfg(feature = "VK_EXT_fragment_density_map")]
                    if self.0.contains(FormatFeatureFlags::FRAGMENT_DENSITY_MAP_EXT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(FRAGMENT_DENSITY_MAP_EXT))?;
                    }
                    #[cfg(feature = "VK_KHR_fragment_shading_rate")]
                    if self
                        .0
                        .contains(FormatFeatureFlags::FRAGMENT_SHADING_RATE_ATTACHMENT_KHR)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(FRAGMENT_SHADING_RATE_ATTACHMENT_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_video_encode_queue")]
                    if self.0.contains(FormatFeatureFlags::VIDEO_ENCODE_INPUT_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(VIDEO_ENCODE_INPUT_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_video_encode_queue")]
                    if self.0.contains(FormatFeatureFlags::VIDEO_ENCODE_DPB_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(VIDEO_ENCODE_DPB_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_maintenance1")]
                    if self.0.contains(FormatFeatureFlags::TRANSFER_SRC_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(TRANSFER_SRC_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_maintenance1")]
                    if self.0.contains(FormatFeatureFlags::TRANSFER_DST_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(TRANSFER_DST_KHR))?;
                    }
                    #[cfg(feature = "VK_EXT_sampler_filter_minmax")]
                    if self.0.contains(FormatFeatureFlags::SAMPLED_IMAGE_FILTER_MINMAX_EXT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(SAMPLED_IMAGE_FILTER_MINMAX_EXT))?;
                    }
                    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
                    if self.0.contains(FormatFeatureFlags::MIDPOINT_CHROMA_SAMPLES_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(MIDPOINT_CHROMA_SAMPLES_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
                    if self
                        .0
                        .contains(FormatFeatureFlags::SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_KHR)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
                    if self
                        .0
                        .contains(FormatFeatureFlags::SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_KHR)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(
                            SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_KHR
                        ))?;
                    }
                    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
                    if self
                        .0
                        .contains(FormatFeatureFlags::SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_KHR)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(
                            SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_KHR
                        ))?;
                    }
                    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
                    if self.0.contains(
                        FormatFeatureFlags::SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_KHR,
                    ) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(
                            SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_KHR
                        ))?;
                    }
                    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
                    if self.0.contains(FormatFeatureFlags::DISJOINT_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(DISJOINT_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
                    if self.0.contains(FormatFeatureFlags::COSITED_CHROMA_SAMPLES_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(COSITED_CHROMA_SAMPLES_KHR))?;
                    }
                    #[cfg(feature = "VK_EXT_filter_cubic")]
                    if self.0.contains(FormatFeatureFlags::SAMPLED_IMAGE_FILTER_CUBIC_EXT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(SAMPLED_IMAGE_FILTER_CUBIC_EXT))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(FormatFeatureFlags))
            .field(&Flags(*self))
            .finish()
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for FormatFeatureFlags {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for FormatFeatureFlags {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkQueryControlFlags")]
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct QueryControlFlags(u32);
impl QueryControlFlags {
    #[doc(alias = "VK_QUERY_CONTROL_PRECISE_BIT")]
    pub const PRECISE: Self = Self(1);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    #[allow(unused_mut)]
    pub const fn all() -> Self {
        let mut all = Self::empty();
        {
            all |= Self::PRECISE;
        }
        all
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl std::ops::BitOr for QueryControlFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl std::ops::BitOrAssign for QueryControlFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl std::ops::BitXor for QueryControlFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl std::ops::BitXorAssign for QueryControlFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl std::ops::BitAnd for QueryControlFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl std::ops::BitAndAssign for QueryControlFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl std::ops::Sub for QueryControlFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl std::ops::SubAssign for QueryControlFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl std::ops::Not for QueryControlFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl Extend<QueryControlFlags> for QueryControlFlags {
    fn extend<T: IntoIterator<Item = QueryControlFlags>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, i);
        }
    }
}
impl FromIterator<QueryControlFlags> for QueryControlFlags {
    fn from_iter<T: IntoIterator<Item = QueryControlFlags>>(iterator: T) -> QueryControlFlags {
        let mut out = Self::empty();
        <Self as Extend<QueryControlFlags>>::extend(&mut out, iterator);
        out
    }
}
impl Default for QueryControlFlags {
    fn default() -> Self {
        Self::empty()
    }
}
impl From<QueryControlFlagBits> for QueryControlFlags {
    fn from(bit: QueryControlFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(bit.bits()) }
    }
}
impl Extend<QueryControlFlagBits> for QueryControlFlags {
    fn extend<T: IntoIterator<Item = QueryControlFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, Self::from(i));
        }
    }
}
impl FromIterator<QueryControlFlagBits> for QueryControlFlags {
    fn from_iter<T: IntoIterator<Item = QueryControlFlagBits>>(iterator: T) -> QueryControlFlags {
        let mut out = Self::empty();
        <Self as Extend<QueryControlFlagBits>>::extend(&mut out, iterator);
        out
    }
}
impl std::fmt::Debug for QueryControlFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(QueryControlFlags);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == QueryControlFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(QueryControlFlags::PRECISE) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(PRECISE))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(QueryControlFlags))
            .field(&Flags(*self))
            .finish()
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for QueryControlFlags {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for QueryControlFlags {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkQueryResultFlags")]
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct QueryResultFlags(u32);
impl QueryResultFlags {
    #[doc(alias = "VK_QUERY_RESULT_64_BIT")]
    pub const N64: Self = Self(1);
    #[doc(alias = "VK_QUERY_RESULT_WAIT_BIT")]
    pub const WAIT: Self = Self(2);
    #[doc(alias = "VK_QUERY_RESULT_WITH_AVAILABILITY_BIT")]
    pub const WITH_AVAILABILITY: Self = Self(4);
    #[doc(alias = "VK_QUERY_RESULT_PARTIAL_BIT")]
    pub const PARTIAL: Self = Self(8);
    #[doc(alias = "VK_QUERY_RESULT_WITH_STATUS_BIT_KHR")]
    #[cfg(feature = "VK_KHR_video_queue")]
    pub const WITH_STATUS_KHR: Self = Self(16);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    #[allow(unused_mut)]
    pub const fn all() -> Self {
        let mut all = Self::empty();
        {
            all |= Self::N64;
        }
        {
            all |= Self::WAIT;
        }
        {
            all |= Self::WITH_AVAILABILITY;
        }
        {
            all |= Self::PARTIAL;
        }
        #[cfg(feature = "VK_KHR_video_queue")]
        {
            all |= Self::WITH_STATUS_KHR;
        }
        all
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl std::ops::BitOr for QueryResultFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl std::ops::BitOrAssign for QueryResultFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl std::ops::BitXor for QueryResultFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl std::ops::BitXorAssign for QueryResultFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl std::ops::BitAnd for QueryResultFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl std::ops::BitAndAssign for QueryResultFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl std::ops::Sub for QueryResultFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl std::ops::SubAssign for QueryResultFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl std::ops::Not for QueryResultFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl Extend<QueryResultFlags> for QueryResultFlags {
    fn extend<T: IntoIterator<Item = QueryResultFlags>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, i);
        }
    }
}
impl FromIterator<QueryResultFlags> for QueryResultFlags {
    fn from_iter<T: IntoIterator<Item = QueryResultFlags>>(iterator: T) -> QueryResultFlags {
        let mut out = Self::empty();
        <Self as Extend<QueryResultFlags>>::extend(&mut out, iterator);
        out
    }
}
impl Default for QueryResultFlags {
    fn default() -> Self {
        Self::empty()
    }
}
impl From<QueryResultFlagBits> for QueryResultFlags {
    fn from(bit: QueryResultFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(bit.bits()) }
    }
}
impl Extend<QueryResultFlagBits> for QueryResultFlags {
    fn extend<T: IntoIterator<Item = QueryResultFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, Self::from(i));
        }
    }
}
impl FromIterator<QueryResultFlagBits> for QueryResultFlags {
    fn from_iter<T: IntoIterator<Item = QueryResultFlagBits>>(iterator: T) -> QueryResultFlags {
        let mut out = Self::empty();
        <Self as Extend<QueryResultFlagBits>>::extend(&mut out, iterator);
        out
    }
}
impl std::fmt::Debug for QueryResultFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(QueryResultFlags);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == QueryResultFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(QueryResultFlags::N64) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(N64))?;
                    }
                    if self.0.contains(QueryResultFlags::WAIT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(WAIT))?;
                    }
                    if self.0.contains(QueryResultFlags::WITH_AVAILABILITY) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(WITH_AVAILABILITY))?;
                    }
                    if self.0.contains(QueryResultFlags::PARTIAL) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(PARTIAL))?;
                    }
                    #[cfg(feature = "VK_KHR_video_queue")]
                    if self.0.contains(QueryResultFlags::WITH_STATUS_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(WITH_STATUS_KHR))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(QueryResultFlags))
            .field(&Flags(*self))
            .finish()
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for QueryResultFlags {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for QueryResultFlags {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkShaderModuleCreateFlags")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct ShaderModuleCreateFlags(u32);
impl ShaderModuleCreateFlags {
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
}
impl Default for ShaderModuleCreateFlags {
    #[inline]
    fn default() -> Self {
        Self::empty()
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for ShaderModuleCreateFlags {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for ShaderModuleCreateFlags {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkEventCreateFlags")]
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct EventCreateFlags(u32);
impl EventCreateFlags {
    #[doc(alias = "VK_EVENT_CREATE_DEVICE_ONLY_BIT")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const DEVICE_ONLY: Self = Self(1);
    #[doc(alias = "VK_EVENT_CREATE_DEVICE_ONLY_BIT_KHR")]
    #[cfg(feature = "VK_KHR_synchronization2")]
    pub const DEVICE_ONLY_KHR: Self = Self::DEVICE_ONLY;
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    #[allow(unused_mut)]
    pub const fn all() -> Self {
        let mut all = Self::empty();
        #[cfg(feature = "VULKAN_1_3")]
        {
            all |= Self::DEVICE_ONLY;
        }
        #[cfg(feature = "VK_KHR_synchronization2")]
        {
            all |= Self::DEVICE_ONLY_KHR;
        }
        all
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl std::ops::BitOr for EventCreateFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl std::ops::BitOrAssign for EventCreateFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl std::ops::BitXor for EventCreateFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl std::ops::BitXorAssign for EventCreateFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl std::ops::BitAnd for EventCreateFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl std::ops::BitAndAssign for EventCreateFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl std::ops::Sub for EventCreateFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl std::ops::SubAssign for EventCreateFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl std::ops::Not for EventCreateFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl Extend<EventCreateFlags> for EventCreateFlags {
    fn extend<T: IntoIterator<Item = EventCreateFlags>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, i);
        }
    }
}
impl FromIterator<EventCreateFlags> for EventCreateFlags {
    fn from_iter<T: IntoIterator<Item = EventCreateFlags>>(iterator: T) -> EventCreateFlags {
        let mut out = Self::empty();
        <Self as Extend<EventCreateFlags>>::extend(&mut out, iterator);
        out
    }
}
impl Default for EventCreateFlags {
    fn default() -> Self {
        Self::empty()
    }
}
impl From<EventCreateFlagBits> for EventCreateFlags {
    fn from(bit: EventCreateFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(bit.bits()) }
    }
}
impl Extend<EventCreateFlagBits> for EventCreateFlags {
    fn extend<T: IntoIterator<Item = EventCreateFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, Self::from(i));
        }
    }
}
impl FromIterator<EventCreateFlagBits> for EventCreateFlags {
    fn from_iter<T: IntoIterator<Item = EventCreateFlagBits>>(iterator: T) -> EventCreateFlags {
        let mut out = Self::empty();
        <Self as Extend<EventCreateFlagBits>>::extend(&mut out, iterator);
        out
    }
}
impl std::fmt::Debug for EventCreateFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(EventCreateFlags);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == EventCreateFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    #[cfg(feature = "VULKAN_1_3")]
                    if self.0.contains(EventCreateFlags::DEVICE_ONLY) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(DEVICE_ONLY))?;
                    }
                    #[cfg(feature = "VK_KHR_synchronization2")]
                    if self.0.contains(EventCreateFlags::DEVICE_ONLY_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(DEVICE_ONLY_KHR))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(EventCreateFlags))
            .field(&Flags(*self))
            .finish()
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for EventCreateFlags {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for EventCreateFlags {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkCommandPoolCreateFlags")]
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct CommandPoolCreateFlags(u32);
impl CommandPoolCreateFlags {
    #[doc(alias = "VK_COMMAND_POOL_CREATE_TRANSIENT_BIT")]
    pub const TRANSIENT: Self = Self(1);
    #[doc(alias = "VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT")]
    pub const RESET_COMMAND_BUFFER: Self = Self(2);
    #[doc(alias = "VK_COMMAND_POOL_CREATE_PROTECTED_BIT")]
    pub const PROTECTED: Self = Self(4);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    #[allow(unused_mut)]
    pub const fn all() -> Self {
        let mut all = Self::empty();
        {
            all |= Self::TRANSIENT;
        }
        {
            all |= Self::RESET_COMMAND_BUFFER;
        }
        {
            all |= Self::PROTECTED;
        }
        all
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl std::ops::BitOr for CommandPoolCreateFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl std::ops::BitOrAssign for CommandPoolCreateFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl std::ops::BitXor for CommandPoolCreateFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl std::ops::BitXorAssign for CommandPoolCreateFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl std::ops::BitAnd for CommandPoolCreateFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl std::ops::BitAndAssign for CommandPoolCreateFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl std::ops::Sub for CommandPoolCreateFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl std::ops::SubAssign for CommandPoolCreateFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl std::ops::Not for CommandPoolCreateFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl Extend<CommandPoolCreateFlags> for CommandPoolCreateFlags {
    fn extend<T: IntoIterator<Item = CommandPoolCreateFlags>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, i);
        }
    }
}
impl FromIterator<CommandPoolCreateFlags> for CommandPoolCreateFlags {
    fn from_iter<T: IntoIterator<Item = CommandPoolCreateFlags>>(iterator: T) -> CommandPoolCreateFlags {
        let mut out = Self::empty();
        <Self as Extend<CommandPoolCreateFlags>>::extend(&mut out, iterator);
        out
    }
}
impl Default for CommandPoolCreateFlags {
    fn default() -> Self {
        Self::empty()
    }
}
impl From<CommandPoolCreateFlagBits> for CommandPoolCreateFlags {
    fn from(bit: CommandPoolCreateFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(bit.bits()) }
    }
}
impl Extend<CommandPoolCreateFlagBits> for CommandPoolCreateFlags {
    fn extend<T: IntoIterator<Item = CommandPoolCreateFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, Self::from(i));
        }
    }
}
impl FromIterator<CommandPoolCreateFlagBits> for CommandPoolCreateFlags {
    fn from_iter<T: IntoIterator<Item = CommandPoolCreateFlagBits>>(iterator: T) -> CommandPoolCreateFlags {
        let mut out = Self::empty();
        <Self as Extend<CommandPoolCreateFlagBits>>::extend(&mut out, iterator);
        out
    }
}
impl std::fmt::Debug for CommandPoolCreateFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(CommandPoolCreateFlags);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == CommandPoolCreateFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(CommandPoolCreateFlags::TRANSIENT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(TRANSIENT))?;
                    }
                    if self.0.contains(CommandPoolCreateFlags::RESET_COMMAND_BUFFER) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(RESET_COMMAND_BUFFER))?;
                    }
                    if self.0.contains(CommandPoolCreateFlags::PROTECTED) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(PROTECTED))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(CommandPoolCreateFlags))
            .field(&Flags(*self))
            .finish()
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for CommandPoolCreateFlags {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for CommandPoolCreateFlags {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkCommandPoolResetFlags")]
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct CommandPoolResetFlags(u32);
impl CommandPoolResetFlags {
    #[doc(alias = "VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT")]
    pub const RELEASE_RESOURCES: Self = Self(1);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    #[allow(unused_mut)]
    pub const fn all() -> Self {
        let mut all = Self::empty();
        {
            all |= Self::RELEASE_RESOURCES;
        }
        all
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl std::ops::BitOr for CommandPoolResetFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl std::ops::BitOrAssign for CommandPoolResetFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl std::ops::BitXor for CommandPoolResetFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl std::ops::BitXorAssign for CommandPoolResetFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl std::ops::BitAnd for CommandPoolResetFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl std::ops::BitAndAssign for CommandPoolResetFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl std::ops::Sub for CommandPoolResetFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl std::ops::SubAssign for CommandPoolResetFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl std::ops::Not for CommandPoolResetFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl Extend<CommandPoolResetFlags> for CommandPoolResetFlags {
    fn extend<T: IntoIterator<Item = CommandPoolResetFlags>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, i);
        }
    }
}
impl FromIterator<CommandPoolResetFlags> for CommandPoolResetFlags {
    fn from_iter<T: IntoIterator<Item = CommandPoolResetFlags>>(iterator: T) -> CommandPoolResetFlags {
        let mut out = Self::empty();
        <Self as Extend<CommandPoolResetFlags>>::extend(&mut out, iterator);
        out
    }
}
impl Default for CommandPoolResetFlags {
    fn default() -> Self {
        Self::empty()
    }
}
impl From<CommandPoolResetFlagBits> for CommandPoolResetFlags {
    fn from(bit: CommandPoolResetFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(bit.bits()) }
    }
}
impl Extend<CommandPoolResetFlagBits> for CommandPoolResetFlags {
    fn extend<T: IntoIterator<Item = CommandPoolResetFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, Self::from(i));
        }
    }
}
impl FromIterator<CommandPoolResetFlagBits> for CommandPoolResetFlags {
    fn from_iter<T: IntoIterator<Item = CommandPoolResetFlagBits>>(iterator: T) -> CommandPoolResetFlags {
        let mut out = Self::empty();
        <Self as Extend<CommandPoolResetFlagBits>>::extend(&mut out, iterator);
        out
    }
}
impl std::fmt::Debug for CommandPoolResetFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(CommandPoolResetFlags);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == CommandPoolResetFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(CommandPoolResetFlags::RELEASE_RESOURCES) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(RELEASE_RESOURCES))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(CommandPoolResetFlags))
            .field(&Flags(*self))
            .finish()
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for CommandPoolResetFlags {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for CommandPoolResetFlags {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkCommandBufferResetFlags")]
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct CommandBufferResetFlags(u32);
impl CommandBufferResetFlags {
    #[doc(alias = "VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT")]
    pub const RELEASE_RESOURCES: Self = Self(1);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    #[allow(unused_mut)]
    pub const fn all() -> Self {
        let mut all = Self::empty();
        {
            all |= Self::RELEASE_RESOURCES;
        }
        all
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl std::ops::BitOr for CommandBufferResetFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl std::ops::BitOrAssign for CommandBufferResetFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl std::ops::BitXor for CommandBufferResetFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl std::ops::BitXorAssign for CommandBufferResetFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl std::ops::BitAnd for CommandBufferResetFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl std::ops::BitAndAssign for CommandBufferResetFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl std::ops::Sub for CommandBufferResetFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl std::ops::SubAssign for CommandBufferResetFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl std::ops::Not for CommandBufferResetFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl Extend<CommandBufferResetFlags> for CommandBufferResetFlags {
    fn extend<T: IntoIterator<Item = CommandBufferResetFlags>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, i);
        }
    }
}
impl FromIterator<CommandBufferResetFlags> for CommandBufferResetFlags {
    fn from_iter<T: IntoIterator<Item = CommandBufferResetFlags>>(iterator: T) -> CommandBufferResetFlags {
        let mut out = Self::empty();
        <Self as Extend<CommandBufferResetFlags>>::extend(&mut out, iterator);
        out
    }
}
impl Default for CommandBufferResetFlags {
    fn default() -> Self {
        Self::empty()
    }
}
impl From<CommandBufferResetFlagBits> for CommandBufferResetFlags {
    fn from(bit: CommandBufferResetFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(bit.bits()) }
    }
}
impl Extend<CommandBufferResetFlagBits> for CommandBufferResetFlags {
    fn extend<T: IntoIterator<Item = CommandBufferResetFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, Self::from(i));
        }
    }
}
impl FromIterator<CommandBufferResetFlagBits> for CommandBufferResetFlags {
    fn from_iter<T: IntoIterator<Item = CommandBufferResetFlagBits>>(iterator: T) -> CommandBufferResetFlags {
        let mut out = Self::empty();
        <Self as Extend<CommandBufferResetFlagBits>>::extend(&mut out, iterator);
        out
    }
}
impl std::fmt::Debug for CommandBufferResetFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(CommandBufferResetFlags);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == CommandBufferResetFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(CommandBufferResetFlags::RELEASE_RESOURCES) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(RELEASE_RESOURCES))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(CommandBufferResetFlags))
            .field(&Flags(*self))
            .finish()
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for CommandBufferResetFlags {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for CommandBufferResetFlags {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkCommandBufferUsageFlags")]
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct CommandBufferUsageFlags(u32);
impl CommandBufferUsageFlags {
    #[doc(alias = "VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT")]
    pub const ONE_TIME_SUBMIT: Self = Self(1);
    #[doc(alias = "VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT")]
    pub const RENDER_PASS_CONTINUE: Self = Self(2);
    #[doc(alias = "VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT")]
    pub const SIMULTANEOUS_USE: Self = Self(4);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    #[allow(unused_mut)]
    pub const fn all() -> Self {
        let mut all = Self::empty();
        {
            all |= Self::ONE_TIME_SUBMIT;
        }
        {
            all |= Self::RENDER_PASS_CONTINUE;
        }
        {
            all |= Self::SIMULTANEOUS_USE;
        }
        all
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl std::ops::BitOr for CommandBufferUsageFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl std::ops::BitOrAssign for CommandBufferUsageFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl std::ops::BitXor for CommandBufferUsageFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl std::ops::BitXorAssign for CommandBufferUsageFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl std::ops::BitAnd for CommandBufferUsageFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl std::ops::BitAndAssign for CommandBufferUsageFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl std::ops::Sub for CommandBufferUsageFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl std::ops::SubAssign for CommandBufferUsageFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl std::ops::Not for CommandBufferUsageFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl Extend<CommandBufferUsageFlags> for CommandBufferUsageFlags {
    fn extend<T: IntoIterator<Item = CommandBufferUsageFlags>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, i);
        }
    }
}
impl FromIterator<CommandBufferUsageFlags> for CommandBufferUsageFlags {
    fn from_iter<T: IntoIterator<Item = CommandBufferUsageFlags>>(iterator: T) -> CommandBufferUsageFlags {
        let mut out = Self::empty();
        <Self as Extend<CommandBufferUsageFlags>>::extend(&mut out, iterator);
        out
    }
}
impl Default for CommandBufferUsageFlags {
    fn default() -> Self {
        Self::empty()
    }
}
impl From<CommandBufferUsageFlagBits> for CommandBufferUsageFlags {
    fn from(bit: CommandBufferUsageFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(bit.bits()) }
    }
}
impl Extend<CommandBufferUsageFlagBits> for CommandBufferUsageFlags {
    fn extend<T: IntoIterator<Item = CommandBufferUsageFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, Self::from(i));
        }
    }
}
impl FromIterator<CommandBufferUsageFlagBits> for CommandBufferUsageFlags {
    fn from_iter<T: IntoIterator<Item = CommandBufferUsageFlagBits>>(iterator: T) -> CommandBufferUsageFlags {
        let mut out = Self::empty();
        <Self as Extend<CommandBufferUsageFlagBits>>::extend(&mut out, iterator);
        out
    }
}
impl std::fmt::Debug for CommandBufferUsageFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(CommandBufferUsageFlags);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == CommandBufferUsageFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(CommandBufferUsageFlags::ONE_TIME_SUBMIT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(ONE_TIME_SUBMIT))?;
                    }
                    if self.0.contains(CommandBufferUsageFlags::RENDER_PASS_CONTINUE) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(RENDER_PASS_CONTINUE))?;
                    }
                    if self.0.contains(CommandBufferUsageFlags::SIMULTANEOUS_USE) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(SIMULTANEOUS_USE))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(CommandBufferUsageFlags))
            .field(&Flags(*self))
            .finish()
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for CommandBufferUsageFlags {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for CommandBufferUsageFlags {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkQueryPipelineStatisticFlags")]
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct QueryPipelineStatisticFlags(u32);
impl QueryPipelineStatisticFlags {
    #[doc(alias = "VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT")]
    pub const INPUT_ASSEMBLY_VERTICES: Self = Self(1);
    #[doc(alias = "VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT")]
    pub const INPUT_ASSEMBLY_PRIMITIVES: Self = Self(2);
    #[doc(alias = "VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT")]
    pub const VERTEX_SHADER_INVOCATIONS: Self = Self(4);
    #[doc(alias = "VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT")]
    pub const GEOMETRY_SHADER_INVOCATIONS: Self = Self(8);
    #[doc(alias = "VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT")]
    pub const GEOMETRY_SHADER_PRIMITIVES: Self = Self(16);
    #[doc(alias = "VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT")]
    pub const CLIPPING_INVOCATIONS: Self = Self(32);
    #[doc(alias = "VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT")]
    pub const CLIPPING_PRIMITIVES: Self = Self(64);
    #[doc(alias = "VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT")]
    pub const FRAGMENT_SHADER_INVOCATIONS: Self = Self(128);
    #[doc(alias = "VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT")]
    pub const TESSELLATION_CONTROL_SHADER_PATCHES: Self = Self(256);
    #[doc(alias = "VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT")]
    pub const TESSELLATION_EVALUATION_SHADER_INVOCATIONS: Self = Self(512);
    #[doc(alias = "VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT")]
    pub const COMPUTE_SHADER_INVOCATIONS: Self = Self(1024);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    #[allow(unused_mut)]
    pub const fn all() -> Self {
        let mut all = Self::empty();
        {
            all |= Self::INPUT_ASSEMBLY_VERTICES;
        }
        {
            all |= Self::INPUT_ASSEMBLY_PRIMITIVES;
        }
        {
            all |= Self::VERTEX_SHADER_INVOCATIONS;
        }
        {
            all |= Self::GEOMETRY_SHADER_INVOCATIONS;
        }
        {
            all |= Self::GEOMETRY_SHADER_PRIMITIVES;
        }
        {
            all |= Self::CLIPPING_INVOCATIONS;
        }
        {
            all |= Self::CLIPPING_PRIMITIVES;
        }
        {
            all |= Self::FRAGMENT_SHADER_INVOCATIONS;
        }
        {
            all |= Self::TESSELLATION_CONTROL_SHADER_PATCHES;
        }
        {
            all |= Self::TESSELLATION_EVALUATION_SHADER_INVOCATIONS;
        }
        {
            all |= Self::COMPUTE_SHADER_INVOCATIONS;
        }
        all
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl std::ops::BitOr for QueryPipelineStatisticFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl std::ops::BitOrAssign for QueryPipelineStatisticFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl std::ops::BitXor for QueryPipelineStatisticFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl std::ops::BitXorAssign for QueryPipelineStatisticFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl std::ops::BitAnd for QueryPipelineStatisticFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl std::ops::BitAndAssign for QueryPipelineStatisticFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl std::ops::Sub for QueryPipelineStatisticFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl std::ops::SubAssign for QueryPipelineStatisticFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl std::ops::Not for QueryPipelineStatisticFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl Extend<QueryPipelineStatisticFlags> for QueryPipelineStatisticFlags {
    fn extend<T: IntoIterator<Item = QueryPipelineStatisticFlags>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, i);
        }
    }
}
impl FromIterator<QueryPipelineStatisticFlags> for QueryPipelineStatisticFlags {
    fn from_iter<T: IntoIterator<Item = QueryPipelineStatisticFlags>>(iterator: T) -> QueryPipelineStatisticFlags {
        let mut out = Self::empty();
        <Self as Extend<QueryPipelineStatisticFlags>>::extend(&mut out, iterator);
        out
    }
}
impl Default for QueryPipelineStatisticFlags {
    fn default() -> Self {
        Self::empty()
    }
}
impl From<QueryPipelineStatisticFlagBits> for QueryPipelineStatisticFlags {
    fn from(bit: QueryPipelineStatisticFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(bit.bits()) }
    }
}
impl Extend<QueryPipelineStatisticFlagBits> for QueryPipelineStatisticFlags {
    fn extend<T: IntoIterator<Item = QueryPipelineStatisticFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, Self::from(i));
        }
    }
}
impl FromIterator<QueryPipelineStatisticFlagBits> for QueryPipelineStatisticFlags {
    fn from_iter<T: IntoIterator<Item = QueryPipelineStatisticFlagBits>>(iterator: T) -> QueryPipelineStatisticFlags {
        let mut out = Self::empty();
        <Self as Extend<QueryPipelineStatisticFlagBits>>::extend(&mut out, iterator);
        out
    }
}
impl std::fmt::Debug for QueryPipelineStatisticFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(QueryPipelineStatisticFlags);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == QueryPipelineStatisticFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(QueryPipelineStatisticFlags::INPUT_ASSEMBLY_VERTICES) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(INPUT_ASSEMBLY_VERTICES))?;
                    }
                    if self.0.contains(QueryPipelineStatisticFlags::INPUT_ASSEMBLY_PRIMITIVES) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(INPUT_ASSEMBLY_PRIMITIVES))?;
                    }
                    if self.0.contains(QueryPipelineStatisticFlags::VERTEX_SHADER_INVOCATIONS) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(VERTEX_SHADER_INVOCATIONS))?;
                    }
                    if self
                        .0
                        .contains(QueryPipelineStatisticFlags::GEOMETRY_SHADER_INVOCATIONS)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(GEOMETRY_SHADER_INVOCATIONS))?;
                    }
                    if self.0.contains(QueryPipelineStatisticFlags::GEOMETRY_SHADER_PRIMITIVES) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(GEOMETRY_SHADER_PRIMITIVES))?;
                    }
                    if self.0.contains(QueryPipelineStatisticFlags::CLIPPING_INVOCATIONS) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(CLIPPING_INVOCATIONS))?;
                    }
                    if self.0.contains(QueryPipelineStatisticFlags::CLIPPING_PRIMITIVES) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(CLIPPING_PRIMITIVES))?;
                    }
                    if self
                        .0
                        .contains(QueryPipelineStatisticFlags::FRAGMENT_SHADER_INVOCATIONS)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(FRAGMENT_SHADER_INVOCATIONS))?;
                    }
                    if self
                        .0
                        .contains(QueryPipelineStatisticFlags::TESSELLATION_CONTROL_SHADER_PATCHES)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(TESSELLATION_CONTROL_SHADER_PATCHES))?;
                    }
                    if self
                        .0
                        .contains(QueryPipelineStatisticFlags::TESSELLATION_EVALUATION_SHADER_INVOCATIONS)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(TESSELLATION_EVALUATION_SHADER_INVOCATIONS))?;
                    }
                    if self.0.contains(QueryPipelineStatisticFlags::COMPUTE_SHADER_INVOCATIONS) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(COMPUTE_SHADER_INVOCATIONS))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(QueryPipelineStatisticFlags))
            .field(&Flags(*self))
            .finish()
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for QueryPipelineStatisticFlags {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for QueryPipelineStatisticFlags {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkMemoryMapFlags")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct MemoryMapFlags(u32);
impl MemoryMapFlags {
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
}
impl Default for MemoryMapFlags {
    #[inline]
    fn default() -> Self {
        Self::empty()
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for MemoryMapFlags {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for MemoryMapFlags {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkImageAspectFlags")]
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct ImageAspectFlags(u32);
impl ImageAspectFlags {
    #[doc(alias = "VK_IMAGE_ASPECT_COLOR_BIT")]
    pub const COLOR: Self = Self(1);
    #[doc(alias = "VK_IMAGE_ASPECT_DEPTH_BIT")]
    pub const DEPTH: Self = Self(2);
    #[doc(alias = "VK_IMAGE_ASPECT_STENCIL_BIT")]
    pub const STENCIL: Self = Self(4);
    #[doc(alias = "VK_IMAGE_ASPECT_METADATA_BIT")]
    pub const METADATA: Self = Self(8);
    #[doc(alias = "VK_IMAGE_ASPECT_PLANE_0_BIT")]
    pub const PLANE0: Self = Self(16);
    #[doc(alias = "VK_IMAGE_ASPECT_PLANE_1_BIT")]
    pub const PLANE1: Self = Self(32);
    #[doc(alias = "VK_IMAGE_ASPECT_PLANE_2_BIT")]
    pub const PLANE2: Self = Self(64);
    #[doc(alias = "VK_IMAGE_ASPECT_NONE")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const NONE: Self = Self(0);
    #[doc(alias = "VK_IMAGE_ASPECT_MEMORY_PLANE_0_BIT_EXT")]
    #[cfg(feature = "VK_EXT_image_drm_format_modifier")]
    pub const MEMORY_PLANE0_EXT: Self = Self(128);
    #[doc(alias = "VK_IMAGE_ASPECT_MEMORY_PLANE_1_BIT_EXT")]
    #[cfg(feature = "VK_EXT_image_drm_format_modifier")]
    pub const MEMORY_PLANE1_EXT: Self = Self(256);
    #[doc(alias = "VK_IMAGE_ASPECT_MEMORY_PLANE_2_BIT_EXT")]
    #[cfg(feature = "VK_EXT_image_drm_format_modifier")]
    pub const MEMORY_PLANE2_EXT: Self = Self(512);
    #[doc(alias = "VK_IMAGE_ASPECT_MEMORY_PLANE_3_BIT_EXT")]
    #[cfg(feature = "VK_EXT_image_drm_format_modifier")]
    pub const MEMORY_PLANE3_EXT: Self = Self(1024);
    #[doc(alias = "VK_IMAGE_ASPECT_PLANE_0_BIT_KHR")]
    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
    pub const PLANE0_KHR: Self = Self::PLANE0;
    #[doc(alias = "VK_IMAGE_ASPECT_PLANE_1_BIT_KHR")]
    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
    pub const PLANE1_KHR: Self = Self::PLANE1;
    #[doc(alias = "VK_IMAGE_ASPECT_PLANE_2_BIT_KHR")]
    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
    pub const PLANE2_KHR: Self = Self::PLANE2;
    #[doc(alias = "VK_IMAGE_ASPECT_NONE_KHR")]
    #[cfg(feature = "VK_KHR_maintenance4")]
    pub const NONE_KHR: Self = Self::NONE;
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    #[allow(unused_mut)]
    pub const fn all() -> Self {
        let mut all = Self::empty();
        {
            all |= Self::COLOR;
        }
        {
            all |= Self::DEPTH;
        }
        {
            all |= Self::STENCIL;
        }
        {
            all |= Self::METADATA;
        }
        {
            all |= Self::PLANE0;
        }
        {
            all |= Self::PLANE1;
        }
        {
            all |= Self::PLANE2;
        }
        #[cfg(feature = "VULKAN_1_3")]
        {
            all |= Self::NONE;
        }
        #[cfg(feature = "VK_EXT_image_drm_format_modifier")]
        {
            all |= Self::MEMORY_PLANE0_EXT;
        }
        #[cfg(feature = "VK_EXT_image_drm_format_modifier")]
        {
            all |= Self::MEMORY_PLANE1_EXT;
        }
        #[cfg(feature = "VK_EXT_image_drm_format_modifier")]
        {
            all |= Self::MEMORY_PLANE2_EXT;
        }
        #[cfg(feature = "VK_EXT_image_drm_format_modifier")]
        {
            all |= Self::MEMORY_PLANE3_EXT;
        }
        #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
        {
            all |= Self::PLANE0_KHR;
        }
        #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
        {
            all |= Self::PLANE1_KHR;
        }
        #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
        {
            all |= Self::PLANE2_KHR;
        }
        #[cfg(feature = "VK_KHR_maintenance4")]
        {
            all |= Self::NONE_KHR;
        }
        all
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl std::ops::BitOr for ImageAspectFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl std::ops::BitOrAssign for ImageAspectFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl std::ops::BitXor for ImageAspectFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl std::ops::BitXorAssign for ImageAspectFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl std::ops::BitAnd for ImageAspectFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl std::ops::BitAndAssign for ImageAspectFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl std::ops::Sub for ImageAspectFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl std::ops::SubAssign for ImageAspectFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl std::ops::Not for ImageAspectFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl Extend<ImageAspectFlags> for ImageAspectFlags {
    fn extend<T: IntoIterator<Item = ImageAspectFlags>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, i);
        }
    }
}
impl FromIterator<ImageAspectFlags> for ImageAspectFlags {
    fn from_iter<T: IntoIterator<Item = ImageAspectFlags>>(iterator: T) -> ImageAspectFlags {
        let mut out = Self::empty();
        <Self as Extend<ImageAspectFlags>>::extend(&mut out, iterator);
        out
    }
}
impl Default for ImageAspectFlags {
    fn default() -> Self {
        Self::empty()
    }
}
impl From<ImageAspectFlagBits> for ImageAspectFlags {
    fn from(bit: ImageAspectFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(bit.bits()) }
    }
}
impl Extend<ImageAspectFlagBits> for ImageAspectFlags {
    fn extend<T: IntoIterator<Item = ImageAspectFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, Self::from(i));
        }
    }
}
impl FromIterator<ImageAspectFlagBits> for ImageAspectFlags {
    fn from_iter<T: IntoIterator<Item = ImageAspectFlagBits>>(iterator: T) -> ImageAspectFlags {
        let mut out = Self::empty();
        <Self as Extend<ImageAspectFlagBits>>::extend(&mut out, iterator);
        out
    }
}
impl std::fmt::Debug for ImageAspectFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(ImageAspectFlags);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == ImageAspectFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(ImageAspectFlags::COLOR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(COLOR))?;
                    }
                    if self.0.contains(ImageAspectFlags::DEPTH) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(DEPTH))?;
                    }
                    if self.0.contains(ImageAspectFlags::STENCIL) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(STENCIL))?;
                    }
                    if self.0.contains(ImageAspectFlags::METADATA) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(METADATA))?;
                    }
                    if self.0.contains(ImageAspectFlags::PLANE0) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(PLANE0))?;
                    }
                    if self.0.contains(ImageAspectFlags::PLANE1) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(PLANE1))?;
                    }
                    if self.0.contains(ImageAspectFlags::PLANE2) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(PLANE2))?;
                    }
                    #[cfg(feature = "VULKAN_1_3")]
                    if self.0.contains(ImageAspectFlags::NONE) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(NONE))?;
                    }
                    #[cfg(feature = "VK_EXT_image_drm_format_modifier")]
                    if self.0.contains(ImageAspectFlags::MEMORY_PLANE0_EXT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(MEMORY_PLANE0_EXT))?;
                    }
                    #[cfg(feature = "VK_EXT_image_drm_format_modifier")]
                    if self.0.contains(ImageAspectFlags::MEMORY_PLANE1_EXT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(MEMORY_PLANE1_EXT))?;
                    }
                    #[cfg(feature = "VK_EXT_image_drm_format_modifier")]
                    if self.0.contains(ImageAspectFlags::MEMORY_PLANE2_EXT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(MEMORY_PLANE2_EXT))?;
                    }
                    #[cfg(feature = "VK_EXT_image_drm_format_modifier")]
                    if self.0.contains(ImageAspectFlags::MEMORY_PLANE3_EXT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(MEMORY_PLANE3_EXT))?;
                    }
                    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
                    if self.0.contains(ImageAspectFlags::PLANE0_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(PLANE0_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
                    if self.0.contains(ImageAspectFlags::PLANE1_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(PLANE1_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
                    if self.0.contains(ImageAspectFlags::PLANE2_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(PLANE2_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_maintenance4")]
                    if self.0.contains(ImageAspectFlags::NONE_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(NONE_KHR))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(ImageAspectFlags))
            .field(&Flags(*self))
            .finish()
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for ImageAspectFlags {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for ImageAspectFlags {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkSparseMemoryBindFlags")]
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct SparseMemoryBindFlags(u32);
impl SparseMemoryBindFlags {
    #[doc(alias = "VK_SPARSE_MEMORY_BIND_METADATA_BIT")]
    pub const METADATA: Self = Self(1);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    #[allow(unused_mut)]
    pub const fn all() -> Self {
        let mut all = Self::empty();
        {
            all |= Self::METADATA;
        }
        all
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl std::ops::BitOr for SparseMemoryBindFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl std::ops::BitOrAssign for SparseMemoryBindFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl std::ops::BitXor for SparseMemoryBindFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl std::ops::BitXorAssign for SparseMemoryBindFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl std::ops::BitAnd for SparseMemoryBindFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl std::ops::BitAndAssign for SparseMemoryBindFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl std::ops::Sub for SparseMemoryBindFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl std::ops::SubAssign for SparseMemoryBindFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl std::ops::Not for SparseMemoryBindFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl Extend<SparseMemoryBindFlags> for SparseMemoryBindFlags {
    fn extend<T: IntoIterator<Item = SparseMemoryBindFlags>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, i);
        }
    }
}
impl FromIterator<SparseMemoryBindFlags> for SparseMemoryBindFlags {
    fn from_iter<T: IntoIterator<Item = SparseMemoryBindFlags>>(iterator: T) -> SparseMemoryBindFlags {
        let mut out = Self::empty();
        <Self as Extend<SparseMemoryBindFlags>>::extend(&mut out, iterator);
        out
    }
}
impl Default for SparseMemoryBindFlags {
    fn default() -> Self {
        Self::empty()
    }
}
impl From<SparseMemoryBindFlagBits> for SparseMemoryBindFlags {
    fn from(bit: SparseMemoryBindFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(bit.bits()) }
    }
}
impl Extend<SparseMemoryBindFlagBits> for SparseMemoryBindFlags {
    fn extend<T: IntoIterator<Item = SparseMemoryBindFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, Self::from(i));
        }
    }
}
impl FromIterator<SparseMemoryBindFlagBits> for SparseMemoryBindFlags {
    fn from_iter<T: IntoIterator<Item = SparseMemoryBindFlagBits>>(iterator: T) -> SparseMemoryBindFlags {
        let mut out = Self::empty();
        <Self as Extend<SparseMemoryBindFlagBits>>::extend(&mut out, iterator);
        out
    }
}
impl std::fmt::Debug for SparseMemoryBindFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(SparseMemoryBindFlags);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == SparseMemoryBindFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(SparseMemoryBindFlags::METADATA) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(METADATA))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(SparseMemoryBindFlags))
            .field(&Flags(*self))
            .finish()
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for SparseMemoryBindFlags {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for SparseMemoryBindFlags {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkSparseImageFormatFlags")]
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct SparseImageFormatFlags(u32);
impl SparseImageFormatFlags {
    #[doc(alias = "VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT")]
    pub const SINGLE_MIPTAIL: Self = Self(1);
    #[doc(alias = "VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT")]
    pub const ALIGNED_MIP_SIZE: Self = Self(2);
    #[doc(alias = "VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT")]
    pub const NONSTANDARD_BLOCK_SIZE: Self = Self(4);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    #[allow(unused_mut)]
    pub const fn all() -> Self {
        let mut all = Self::empty();
        {
            all |= Self::SINGLE_MIPTAIL;
        }
        {
            all |= Self::ALIGNED_MIP_SIZE;
        }
        {
            all |= Self::NONSTANDARD_BLOCK_SIZE;
        }
        all
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl std::ops::BitOr for SparseImageFormatFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl std::ops::BitOrAssign for SparseImageFormatFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl std::ops::BitXor for SparseImageFormatFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl std::ops::BitXorAssign for SparseImageFormatFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl std::ops::BitAnd for SparseImageFormatFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl std::ops::BitAndAssign for SparseImageFormatFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl std::ops::Sub for SparseImageFormatFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl std::ops::SubAssign for SparseImageFormatFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl std::ops::Not for SparseImageFormatFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl Extend<SparseImageFormatFlags> for SparseImageFormatFlags {
    fn extend<T: IntoIterator<Item = SparseImageFormatFlags>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, i);
        }
    }
}
impl FromIterator<SparseImageFormatFlags> for SparseImageFormatFlags {
    fn from_iter<T: IntoIterator<Item = SparseImageFormatFlags>>(iterator: T) -> SparseImageFormatFlags {
        let mut out = Self::empty();
        <Self as Extend<SparseImageFormatFlags>>::extend(&mut out, iterator);
        out
    }
}
impl Default for SparseImageFormatFlags {
    fn default() -> Self {
        Self::empty()
    }
}
impl From<SparseImageFormatFlagBits> for SparseImageFormatFlags {
    fn from(bit: SparseImageFormatFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(bit.bits()) }
    }
}
impl Extend<SparseImageFormatFlagBits> for SparseImageFormatFlags {
    fn extend<T: IntoIterator<Item = SparseImageFormatFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, Self::from(i));
        }
    }
}
impl FromIterator<SparseImageFormatFlagBits> for SparseImageFormatFlags {
    fn from_iter<T: IntoIterator<Item = SparseImageFormatFlagBits>>(iterator: T) -> SparseImageFormatFlags {
        let mut out = Self::empty();
        <Self as Extend<SparseImageFormatFlagBits>>::extend(&mut out, iterator);
        out
    }
}
impl std::fmt::Debug for SparseImageFormatFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(SparseImageFormatFlags);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == SparseImageFormatFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(SparseImageFormatFlags::SINGLE_MIPTAIL) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(SINGLE_MIPTAIL))?;
                    }
                    if self.0.contains(SparseImageFormatFlags::ALIGNED_MIP_SIZE) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(ALIGNED_MIP_SIZE))?;
                    }
                    if self.0.contains(SparseImageFormatFlags::NONSTANDARD_BLOCK_SIZE) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(NONSTANDARD_BLOCK_SIZE))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(SparseImageFormatFlags))
            .field(&Flags(*self))
            .finish()
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for SparseImageFormatFlags {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for SparseImageFormatFlags {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkSubpassDescriptionFlags")]
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct SubpassDescriptionFlags(u32);
impl SubpassDescriptionFlags {
    #[doc(alias = "VK_SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX")]
    #[cfg(feature = "VK_NVX_multiview_per_view_attributes")]
    pub const PER_VIEW_ATTRIBUTES_NVX: Self = Self(1);
    #[doc(alias = "VK_SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX")]
    #[cfg(feature = "VK_NVX_multiview_per_view_attributes")]
    pub const PER_VIEW_POSITION_X_ONLY_NVX: Self = Self(2);
    #[doc(alias = "VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_COLOR_ACCESS_BIT_ARM")]
    #[cfg(feature = "VK_ARM_rasterization_order_attachment_access")]
    pub const RASTERIZATION_ORDER_ATTACHMENT_COLOR_ACCESS_ARM: Self = Self(16);
    #[doc(alias = "VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_ARM")]
    #[cfg(feature = "VK_ARM_rasterization_order_attachment_access")]
    pub const RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_ARM: Self = Self(32);
    #[doc(alias = "VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_ARM")]
    #[cfg(feature = "VK_ARM_rasterization_order_attachment_access")]
    pub const RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_ARM: Self = Self(64);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    #[allow(unused_mut)]
    pub const fn all() -> Self {
        let mut all = Self::empty();
        #[cfg(feature = "VK_NVX_multiview_per_view_attributes")]
        {
            all |= Self::PER_VIEW_ATTRIBUTES_NVX;
        }
        #[cfg(feature = "VK_NVX_multiview_per_view_attributes")]
        {
            all |= Self::PER_VIEW_POSITION_X_ONLY_NVX;
        }
        #[cfg(feature = "VK_ARM_rasterization_order_attachment_access")]
        {
            all |= Self::RASTERIZATION_ORDER_ATTACHMENT_COLOR_ACCESS_ARM;
        }
        #[cfg(feature = "VK_ARM_rasterization_order_attachment_access")]
        {
            all |= Self::RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_ARM;
        }
        #[cfg(feature = "VK_ARM_rasterization_order_attachment_access")]
        {
            all |= Self::RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_ARM;
        }
        all
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl std::ops::BitOr for SubpassDescriptionFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl std::ops::BitOrAssign for SubpassDescriptionFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl std::ops::BitXor for SubpassDescriptionFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl std::ops::BitXorAssign for SubpassDescriptionFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl std::ops::BitAnd for SubpassDescriptionFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl std::ops::BitAndAssign for SubpassDescriptionFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl std::ops::Sub for SubpassDescriptionFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl std::ops::SubAssign for SubpassDescriptionFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl std::ops::Not for SubpassDescriptionFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl Extend<SubpassDescriptionFlags> for SubpassDescriptionFlags {
    fn extend<T: IntoIterator<Item = SubpassDescriptionFlags>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, i);
        }
    }
}
impl FromIterator<SubpassDescriptionFlags> for SubpassDescriptionFlags {
    fn from_iter<T: IntoIterator<Item = SubpassDescriptionFlags>>(iterator: T) -> SubpassDescriptionFlags {
        let mut out = Self::empty();
        <Self as Extend<SubpassDescriptionFlags>>::extend(&mut out, iterator);
        out
    }
}
impl Default for SubpassDescriptionFlags {
    fn default() -> Self {
        Self::empty()
    }
}
impl From<SubpassDescriptionFlagBits> for SubpassDescriptionFlags {
    fn from(bit: SubpassDescriptionFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(bit.bits()) }
    }
}
impl Extend<SubpassDescriptionFlagBits> for SubpassDescriptionFlags {
    fn extend<T: IntoIterator<Item = SubpassDescriptionFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, Self::from(i));
        }
    }
}
impl FromIterator<SubpassDescriptionFlagBits> for SubpassDescriptionFlags {
    fn from_iter<T: IntoIterator<Item = SubpassDescriptionFlagBits>>(iterator: T) -> SubpassDescriptionFlags {
        let mut out = Self::empty();
        <Self as Extend<SubpassDescriptionFlagBits>>::extend(&mut out, iterator);
        out
    }
}
impl std::fmt::Debug for SubpassDescriptionFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(SubpassDescriptionFlags);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == SubpassDescriptionFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    #[cfg(feature = "VK_NVX_multiview_per_view_attributes")]
                    if self.0.contains(SubpassDescriptionFlags::PER_VIEW_ATTRIBUTES_NVX) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(PER_VIEW_ATTRIBUTES_NVX))?;
                    }
                    #[cfg(feature = "VK_NVX_multiview_per_view_attributes")]
                    if self.0.contains(SubpassDescriptionFlags::PER_VIEW_POSITION_X_ONLY_NVX) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(PER_VIEW_POSITION_X_ONLY_NVX))?;
                    }
                    #[cfg(feature = "VK_ARM_rasterization_order_attachment_access")]
                    if self
                        .0
                        .contains(SubpassDescriptionFlags::RASTERIZATION_ORDER_ATTACHMENT_COLOR_ACCESS_ARM)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(RASTERIZATION_ORDER_ATTACHMENT_COLOR_ACCESS_ARM))?;
                    }
                    #[cfg(feature = "VK_ARM_rasterization_order_attachment_access")]
                    if self
                        .0
                        .contains(SubpassDescriptionFlags::RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_ARM)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_ARM))?;
                    }
                    #[cfg(feature = "VK_ARM_rasterization_order_attachment_access")]
                    if self
                        .0
                        .contains(SubpassDescriptionFlags::RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_ARM)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_ARM))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(SubpassDescriptionFlags))
            .field(&Flags(*self))
            .finish()
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for SubpassDescriptionFlags {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for SubpassDescriptionFlags {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkPipelineStageFlags")]
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct PipelineStageFlags(u32);
impl PipelineStageFlags {
    #[doc(alias = "VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT")]
    pub const TOP_OF_PIPE: Self = Self(1);
    #[doc(alias = "VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT")]
    pub const DRAW_INDIRECT: Self = Self(2);
    #[doc(alias = "VK_PIPELINE_STAGE_VERTEX_INPUT_BIT")]
    pub const VERTEX_INPUT: Self = Self(4);
    #[doc(alias = "VK_PIPELINE_STAGE_VERTEX_SHADER_BIT")]
    pub const VERTEX_SHADER: Self = Self(8);
    #[doc(alias = "VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT")]
    pub const TESSELLATION_CONTROL_SHADER: Self = Self(16);
    #[doc(alias = "VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT")]
    pub const TESSELLATION_EVALUATION_SHADER: Self = Self(32);
    #[doc(alias = "VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT")]
    pub const GEOMETRY_SHADER: Self = Self(64);
    #[doc(alias = "VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT")]
    pub const FRAGMENT_SHADER: Self = Self(128);
    #[doc(alias = "VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT")]
    pub const EARLY_FRAGMENT_TESTS: Self = Self(256);
    #[doc(alias = "VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT")]
    pub const LATE_FRAGMENT_TESTS: Self = Self(512);
    #[doc(alias = "VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT")]
    pub const COLOR_ATTACHMENT_OUTPUT: Self = Self(1024);
    #[doc(alias = "VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT")]
    pub const COMPUTE_SHADER: Self = Self(2048);
    #[doc(alias = "VK_PIPELINE_STAGE_TRANSFER_BIT")]
    pub const TRANSFER: Self = Self(4096);
    #[doc(alias = "VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT")]
    pub const BOTTOM_OF_PIPE: Self = Self(8192);
    #[doc(alias = "VK_PIPELINE_STAGE_HOST_BIT")]
    pub const HOST: Self = Self(16384);
    #[doc(alias = "VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT")]
    pub const ALL_GRAPHICS: Self = Self(32768);
    #[doc(alias = "VK_PIPELINE_STAGE_ALL_COMMANDS_BIT")]
    pub const ALL_COMMANDS: Self = Self(65536);
    #[doc(alias = "VK_PIPELINE_STAGE_NONE")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const NONE: Self = Self(0);
    #[doc(alias = "VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT")]
    #[cfg(feature = "VK_EXT_transform_feedback")]
    pub const TRANSFORM_FEEDBACK_EXT: Self = Self(16777216);
    #[doc(alias = "VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT")]
    #[cfg(feature = "VK_EXT_conditional_rendering")]
    pub const CONDITIONAL_RENDERING_EXT: Self = Self(262144);
    #[doc(alias = "VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR")]
    #[cfg(feature = "VK_KHR_acceleration_structure")]
    pub const ACCELERATION_STRUCTURE_BUILD_KHR: Self = Self(33554432);
    #[doc(alias = "VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_KHR")]
    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
    pub const RAY_TRACING_SHADER_KHR: Self = Self(2097152);
    #[doc(alias = "VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV")]
    #[cfg(feature = "VK_NV_mesh_shader")]
    pub const TASK_SHADER_NV: Self = Self(524288);
    #[doc(alias = "VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV")]
    #[cfg(feature = "VK_NV_mesh_shader")]
    pub const MESH_SHADER_NV: Self = Self(1048576);
    #[doc(alias = "VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT")]
    #[cfg(feature = "VK_EXT_fragment_density_map")]
    pub const FRAGMENT_DENSITY_PROCESS_EXT: Self = Self(8388608);
    #[doc(alias = "VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR")]
    #[cfg(feature = "VK_KHR_fragment_shading_rate")]
    pub const FRAGMENT_SHADING_RATE_ATTACHMENT_KHR: Self = Self(4194304);
    #[doc(alias = "VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_NV")]
    #[cfg(feature = "VK_NV_device_generated_commands")]
    pub const COMMAND_PREPROCESS_NV: Self = Self(131072);
    #[doc(alias = "VK_PIPELINE_STAGE_SHADING_RATE_IMAGE_BIT_NV")]
    #[cfg(feature = "VK_NV_shading_rate_image")]
    pub const SHADING_RATE_IMAGE_NV: Self = Self::FRAGMENT_SHADING_RATE_ATTACHMENT_KHR;
    #[doc(alias = "VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_NV")]
    #[cfg(feature = "VK_NV_ray_tracing")]
    pub const RAY_TRACING_SHADER_NV: Self = Self::RAY_TRACING_SHADER_KHR;
    #[doc(alias = "VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_NV")]
    #[cfg(feature = "VK_NV_ray_tracing")]
    pub const ACCELERATION_STRUCTURE_BUILD_NV: Self = Self::ACCELERATION_STRUCTURE_BUILD_KHR;
    #[doc(alias = "VK_PIPELINE_STAGE_NONE_KHR")]
    #[cfg(feature = "VK_KHR_synchronization2")]
    pub const NONE_KHR: Self = Self::NONE;
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    #[allow(unused_mut)]
    pub const fn all() -> Self {
        let mut all = Self::empty();
        {
            all |= Self::TOP_OF_PIPE;
        }
        {
            all |= Self::DRAW_INDIRECT;
        }
        {
            all |= Self::VERTEX_INPUT;
        }
        {
            all |= Self::VERTEX_SHADER;
        }
        {
            all |= Self::TESSELLATION_CONTROL_SHADER;
        }
        {
            all |= Self::TESSELLATION_EVALUATION_SHADER;
        }
        {
            all |= Self::GEOMETRY_SHADER;
        }
        {
            all |= Self::FRAGMENT_SHADER;
        }
        {
            all |= Self::EARLY_FRAGMENT_TESTS;
        }
        {
            all |= Self::LATE_FRAGMENT_TESTS;
        }
        {
            all |= Self::COLOR_ATTACHMENT_OUTPUT;
        }
        {
            all |= Self::COMPUTE_SHADER;
        }
        {
            all |= Self::TRANSFER;
        }
        {
            all |= Self::BOTTOM_OF_PIPE;
        }
        {
            all |= Self::HOST;
        }
        {
            all |= Self::ALL_GRAPHICS;
        }
        {
            all |= Self::ALL_COMMANDS;
        }
        #[cfg(feature = "VULKAN_1_3")]
        {
            all |= Self::NONE;
        }
        #[cfg(feature = "VK_EXT_transform_feedback")]
        {
            all |= Self::TRANSFORM_FEEDBACK_EXT;
        }
        #[cfg(feature = "VK_EXT_conditional_rendering")]
        {
            all |= Self::CONDITIONAL_RENDERING_EXT;
        }
        #[cfg(feature = "VK_KHR_acceleration_structure")]
        {
            all |= Self::ACCELERATION_STRUCTURE_BUILD_KHR;
        }
        #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
        {
            all |= Self::RAY_TRACING_SHADER_KHR;
        }
        #[cfg(feature = "VK_NV_mesh_shader")]
        {
            all |= Self::TASK_SHADER_NV;
        }
        #[cfg(feature = "VK_NV_mesh_shader")]
        {
            all |= Self::MESH_SHADER_NV;
        }
        #[cfg(feature = "VK_EXT_fragment_density_map")]
        {
            all |= Self::FRAGMENT_DENSITY_PROCESS_EXT;
        }
        #[cfg(feature = "VK_KHR_fragment_shading_rate")]
        {
            all |= Self::FRAGMENT_SHADING_RATE_ATTACHMENT_KHR;
        }
        #[cfg(feature = "VK_NV_device_generated_commands")]
        {
            all |= Self::COMMAND_PREPROCESS_NV;
        }
        #[cfg(feature = "VK_NV_shading_rate_image")]
        {
            all |= Self::SHADING_RATE_IMAGE_NV;
        }
        #[cfg(feature = "VK_NV_ray_tracing")]
        {
            all |= Self::RAY_TRACING_SHADER_NV;
        }
        #[cfg(feature = "VK_NV_ray_tracing")]
        {
            all |= Self::ACCELERATION_STRUCTURE_BUILD_NV;
        }
        #[cfg(feature = "VK_KHR_synchronization2")]
        {
            all |= Self::NONE_KHR;
        }
        all
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl std::ops::BitOr for PipelineStageFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl std::ops::BitOrAssign for PipelineStageFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl std::ops::BitXor for PipelineStageFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl std::ops::BitXorAssign for PipelineStageFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl std::ops::BitAnd for PipelineStageFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl std::ops::BitAndAssign for PipelineStageFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl std::ops::Sub for PipelineStageFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl std::ops::SubAssign for PipelineStageFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl std::ops::Not for PipelineStageFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl Extend<PipelineStageFlags> for PipelineStageFlags {
    fn extend<T: IntoIterator<Item = PipelineStageFlags>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, i);
        }
    }
}
impl FromIterator<PipelineStageFlags> for PipelineStageFlags {
    fn from_iter<T: IntoIterator<Item = PipelineStageFlags>>(iterator: T) -> PipelineStageFlags {
        let mut out = Self::empty();
        <Self as Extend<PipelineStageFlags>>::extend(&mut out, iterator);
        out
    }
}
impl Default for PipelineStageFlags {
    fn default() -> Self {
        Self::empty()
    }
}
impl From<PipelineStageFlagBits> for PipelineStageFlags {
    fn from(bit: PipelineStageFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(bit.bits()) }
    }
}
impl Extend<PipelineStageFlagBits> for PipelineStageFlags {
    fn extend<T: IntoIterator<Item = PipelineStageFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, Self::from(i));
        }
    }
}
impl FromIterator<PipelineStageFlagBits> for PipelineStageFlags {
    fn from_iter<T: IntoIterator<Item = PipelineStageFlagBits>>(iterator: T) -> PipelineStageFlags {
        let mut out = Self::empty();
        <Self as Extend<PipelineStageFlagBits>>::extend(&mut out, iterator);
        out
    }
}
impl std::fmt::Debug for PipelineStageFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(PipelineStageFlags);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == PipelineStageFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(PipelineStageFlags::TOP_OF_PIPE) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(TOP_OF_PIPE))?;
                    }
                    if self.0.contains(PipelineStageFlags::DRAW_INDIRECT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(DRAW_INDIRECT))?;
                    }
                    if self.0.contains(PipelineStageFlags::VERTEX_INPUT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(VERTEX_INPUT))?;
                    }
                    if self.0.contains(PipelineStageFlags::VERTEX_SHADER) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(VERTEX_SHADER))?;
                    }
                    if self.0.contains(PipelineStageFlags::TESSELLATION_CONTROL_SHADER) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(TESSELLATION_CONTROL_SHADER))?;
                    }
                    if self.0.contains(PipelineStageFlags::TESSELLATION_EVALUATION_SHADER) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(TESSELLATION_EVALUATION_SHADER))?;
                    }
                    if self.0.contains(PipelineStageFlags::GEOMETRY_SHADER) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(GEOMETRY_SHADER))?;
                    }
                    if self.0.contains(PipelineStageFlags::FRAGMENT_SHADER) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(FRAGMENT_SHADER))?;
                    }
                    if self.0.contains(PipelineStageFlags::EARLY_FRAGMENT_TESTS) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(EARLY_FRAGMENT_TESTS))?;
                    }
                    if self.0.contains(PipelineStageFlags::LATE_FRAGMENT_TESTS) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(LATE_FRAGMENT_TESTS))?;
                    }
                    if self.0.contains(PipelineStageFlags::COLOR_ATTACHMENT_OUTPUT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(COLOR_ATTACHMENT_OUTPUT))?;
                    }
                    if self.0.contains(PipelineStageFlags::COMPUTE_SHADER) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(COMPUTE_SHADER))?;
                    }
                    if self.0.contains(PipelineStageFlags::TRANSFER) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(TRANSFER))?;
                    }
                    if self.0.contains(PipelineStageFlags::BOTTOM_OF_PIPE) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(BOTTOM_OF_PIPE))?;
                    }
                    if self.0.contains(PipelineStageFlags::HOST) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(HOST))?;
                    }
                    if self.0.contains(PipelineStageFlags::ALL_GRAPHICS) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(ALL_GRAPHICS))?;
                    }
                    if self.0.contains(PipelineStageFlags::ALL_COMMANDS) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(ALL_COMMANDS))?;
                    }
                    #[cfg(feature = "VULKAN_1_3")]
                    if self.0.contains(PipelineStageFlags::NONE) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(NONE))?;
                    }
                    #[cfg(feature = "VK_EXT_transform_feedback")]
                    if self.0.contains(PipelineStageFlags::TRANSFORM_FEEDBACK_EXT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(TRANSFORM_FEEDBACK_EXT))?;
                    }
                    #[cfg(feature = "VK_EXT_conditional_rendering")]
                    if self.0.contains(PipelineStageFlags::CONDITIONAL_RENDERING_EXT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(CONDITIONAL_RENDERING_EXT))?;
                    }
                    #[cfg(feature = "VK_KHR_acceleration_structure")]
                    if self.0.contains(PipelineStageFlags::ACCELERATION_STRUCTURE_BUILD_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(ACCELERATION_STRUCTURE_BUILD_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
                    if self.0.contains(PipelineStageFlags::RAY_TRACING_SHADER_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(RAY_TRACING_SHADER_KHR))?;
                    }
                    #[cfg(feature = "VK_NV_mesh_shader")]
                    if self.0.contains(PipelineStageFlags::TASK_SHADER_NV) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(TASK_SHADER_NV))?;
                    }
                    #[cfg(feature = "VK_NV_mesh_shader")]
                    if self.0.contains(PipelineStageFlags::MESH_SHADER_NV) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(MESH_SHADER_NV))?;
                    }
                    #[cfg(feature = "VK_EXT_fragment_density_map")]
                    if self.0.contains(PipelineStageFlags::FRAGMENT_DENSITY_PROCESS_EXT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(FRAGMENT_DENSITY_PROCESS_EXT))?;
                    }
                    #[cfg(feature = "VK_KHR_fragment_shading_rate")]
                    if self
                        .0
                        .contains(PipelineStageFlags::FRAGMENT_SHADING_RATE_ATTACHMENT_KHR)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(FRAGMENT_SHADING_RATE_ATTACHMENT_KHR))?;
                    }
                    #[cfg(feature = "VK_NV_device_generated_commands")]
                    if self.0.contains(PipelineStageFlags::COMMAND_PREPROCESS_NV) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(COMMAND_PREPROCESS_NV))?;
                    }
                    #[cfg(feature = "VK_NV_shading_rate_image")]
                    if self.0.contains(PipelineStageFlags::SHADING_RATE_IMAGE_NV) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(SHADING_RATE_IMAGE_NV))?;
                    }
                    #[cfg(feature = "VK_NV_ray_tracing")]
                    if self.0.contains(PipelineStageFlags::RAY_TRACING_SHADER_NV) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(RAY_TRACING_SHADER_NV))?;
                    }
                    #[cfg(feature = "VK_NV_ray_tracing")]
                    if self.0.contains(PipelineStageFlags::ACCELERATION_STRUCTURE_BUILD_NV) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(ACCELERATION_STRUCTURE_BUILD_NV))?;
                    }
                    #[cfg(feature = "VK_KHR_synchronization2")]
                    if self.0.contains(PipelineStageFlags::NONE_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(NONE_KHR))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(PipelineStageFlags))
            .field(&Flags(*self))
            .finish()
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for PipelineStageFlags {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for PipelineStageFlags {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkSampleCountFlags")]
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct SampleCountFlags(u32);
impl SampleCountFlags {
    #[doc(alias = "VK_SAMPLE_COUNT_1_BIT")]
    pub const N1: Self = Self(1);
    #[doc(alias = "VK_SAMPLE_COUNT_2_BIT")]
    pub const N2: Self = Self(2);
    #[doc(alias = "VK_SAMPLE_COUNT_4_BIT")]
    pub const N4: Self = Self(4);
    #[doc(alias = "VK_SAMPLE_COUNT_8_BIT")]
    pub const N8: Self = Self(8);
    #[doc(alias = "VK_SAMPLE_COUNT_16_BIT")]
    pub const N16: Self = Self(16);
    #[doc(alias = "VK_SAMPLE_COUNT_32_BIT")]
    pub const N32: Self = Self(32);
    #[doc(alias = "VK_SAMPLE_COUNT_64_BIT")]
    pub const N64: Self = Self(64);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    #[allow(unused_mut)]
    pub const fn all() -> Self {
        let mut all = Self::empty();
        {
            all |= Self::N1;
        }
        {
            all |= Self::N2;
        }
        {
            all |= Self::N4;
        }
        {
            all |= Self::N8;
        }
        {
            all |= Self::N16;
        }
        {
            all |= Self::N32;
        }
        {
            all |= Self::N64;
        }
        all
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl std::ops::BitOr for SampleCountFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl std::ops::BitOrAssign for SampleCountFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl std::ops::BitXor for SampleCountFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl std::ops::BitXorAssign for SampleCountFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl std::ops::BitAnd for SampleCountFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl std::ops::BitAndAssign for SampleCountFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl std::ops::Sub for SampleCountFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl std::ops::SubAssign for SampleCountFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl std::ops::Not for SampleCountFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl Extend<SampleCountFlags> for SampleCountFlags {
    fn extend<T: IntoIterator<Item = SampleCountFlags>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, i);
        }
    }
}
impl FromIterator<SampleCountFlags> for SampleCountFlags {
    fn from_iter<T: IntoIterator<Item = SampleCountFlags>>(iterator: T) -> SampleCountFlags {
        let mut out = Self::empty();
        <Self as Extend<SampleCountFlags>>::extend(&mut out, iterator);
        out
    }
}
impl Default for SampleCountFlags {
    fn default() -> Self {
        Self::empty()
    }
}
impl From<SampleCountFlagBits> for SampleCountFlags {
    fn from(bit: SampleCountFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(bit.bits()) }
    }
}
impl Extend<SampleCountFlagBits> for SampleCountFlags {
    fn extend<T: IntoIterator<Item = SampleCountFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, Self::from(i));
        }
    }
}
impl FromIterator<SampleCountFlagBits> for SampleCountFlags {
    fn from_iter<T: IntoIterator<Item = SampleCountFlagBits>>(iterator: T) -> SampleCountFlags {
        let mut out = Self::empty();
        <Self as Extend<SampleCountFlagBits>>::extend(&mut out, iterator);
        out
    }
}
impl std::fmt::Debug for SampleCountFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(SampleCountFlags);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == SampleCountFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(SampleCountFlags::N1) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(N1))?;
                    }
                    if self.0.contains(SampleCountFlags::N2) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(N2))?;
                    }
                    if self.0.contains(SampleCountFlags::N4) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(N4))?;
                    }
                    if self.0.contains(SampleCountFlags::N8) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(N8))?;
                    }
                    if self.0.contains(SampleCountFlags::N16) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(N16))?;
                    }
                    if self.0.contains(SampleCountFlags::N32) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(N32))?;
                    }
                    if self.0.contains(SampleCountFlags::N64) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(N64))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(SampleCountFlags))
            .field(&Flags(*self))
            .finish()
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for SampleCountFlags {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for SampleCountFlags {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkAttachmentDescriptionFlags")]
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct AttachmentDescriptionFlags(u32);
impl AttachmentDescriptionFlags {
    #[doc(alias = "VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT")]
    pub const MAY_ALIAS: Self = Self(1);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    #[allow(unused_mut)]
    pub const fn all() -> Self {
        let mut all = Self::empty();
        {
            all |= Self::MAY_ALIAS;
        }
        all
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl std::ops::BitOr for AttachmentDescriptionFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl std::ops::BitOrAssign for AttachmentDescriptionFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl std::ops::BitXor for AttachmentDescriptionFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl std::ops::BitXorAssign for AttachmentDescriptionFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl std::ops::BitAnd for AttachmentDescriptionFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl std::ops::BitAndAssign for AttachmentDescriptionFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl std::ops::Sub for AttachmentDescriptionFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl std::ops::SubAssign for AttachmentDescriptionFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl std::ops::Not for AttachmentDescriptionFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl Extend<AttachmentDescriptionFlags> for AttachmentDescriptionFlags {
    fn extend<T: IntoIterator<Item = AttachmentDescriptionFlags>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, i);
        }
    }
}
impl FromIterator<AttachmentDescriptionFlags> for AttachmentDescriptionFlags {
    fn from_iter<T: IntoIterator<Item = AttachmentDescriptionFlags>>(iterator: T) -> AttachmentDescriptionFlags {
        let mut out = Self::empty();
        <Self as Extend<AttachmentDescriptionFlags>>::extend(&mut out, iterator);
        out
    }
}
impl Default for AttachmentDescriptionFlags {
    fn default() -> Self {
        Self::empty()
    }
}
impl From<AttachmentDescriptionFlagBits> for AttachmentDescriptionFlags {
    fn from(bit: AttachmentDescriptionFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(bit.bits()) }
    }
}
impl Extend<AttachmentDescriptionFlagBits> for AttachmentDescriptionFlags {
    fn extend<T: IntoIterator<Item = AttachmentDescriptionFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, Self::from(i));
        }
    }
}
impl FromIterator<AttachmentDescriptionFlagBits> for AttachmentDescriptionFlags {
    fn from_iter<T: IntoIterator<Item = AttachmentDescriptionFlagBits>>(iterator: T) -> AttachmentDescriptionFlags {
        let mut out = Self::empty();
        <Self as Extend<AttachmentDescriptionFlagBits>>::extend(&mut out, iterator);
        out
    }
}
impl std::fmt::Debug for AttachmentDescriptionFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(AttachmentDescriptionFlags);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == AttachmentDescriptionFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(AttachmentDescriptionFlags::MAY_ALIAS) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(MAY_ALIAS))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(AttachmentDescriptionFlags))
            .field(&Flags(*self))
            .finish()
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for AttachmentDescriptionFlags {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for AttachmentDescriptionFlags {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkStencilFaceFlags")]
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct StencilFaceFlags(u32);
impl StencilFaceFlags {
    #[doc(alias = "VK_STENCIL_FACE_FRONT_BIT")]
    pub const FRONT: Self = Self(1);
    #[doc(alias = "VK_STENCIL_FACE_BACK_BIT")]
    pub const BACK: Self = Self(2);
    #[doc(alias = "VK_STENCIL_FACE_FRONT_AND_BACK")]
    pub const FRONT_AND_BACK: Self = Self(3);
    #[doc(alias = "VK_STENCIL_FRONT_AND_BACK")]
    pub const STENCIL_FRONT_AND_BACK: Self = Self::FRONT_AND_BACK;
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    #[allow(unused_mut)]
    pub const fn all() -> Self {
        let mut all = Self::empty();
        {
            all |= Self::FRONT;
        }
        {
            all |= Self::BACK;
        }
        {
            all |= Self::FRONT_AND_BACK;
        }
        {
            all |= Self::STENCIL_FRONT_AND_BACK;
        }
        all
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl std::ops::BitOr for StencilFaceFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl std::ops::BitOrAssign for StencilFaceFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl std::ops::BitXor for StencilFaceFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl std::ops::BitXorAssign for StencilFaceFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl std::ops::BitAnd for StencilFaceFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl std::ops::BitAndAssign for StencilFaceFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl std::ops::Sub for StencilFaceFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl std::ops::SubAssign for StencilFaceFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl std::ops::Not for StencilFaceFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl Extend<StencilFaceFlags> for StencilFaceFlags {
    fn extend<T: IntoIterator<Item = StencilFaceFlags>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, i);
        }
    }
}
impl FromIterator<StencilFaceFlags> for StencilFaceFlags {
    fn from_iter<T: IntoIterator<Item = StencilFaceFlags>>(iterator: T) -> StencilFaceFlags {
        let mut out = Self::empty();
        <Self as Extend<StencilFaceFlags>>::extend(&mut out, iterator);
        out
    }
}
impl Default for StencilFaceFlags {
    fn default() -> Self {
        Self::empty()
    }
}
impl From<StencilFaceFlagBits> for StencilFaceFlags {
    fn from(bit: StencilFaceFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(bit.bits()) }
    }
}
impl Extend<StencilFaceFlagBits> for StencilFaceFlags {
    fn extend<T: IntoIterator<Item = StencilFaceFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, Self::from(i));
        }
    }
}
impl FromIterator<StencilFaceFlagBits> for StencilFaceFlags {
    fn from_iter<T: IntoIterator<Item = StencilFaceFlagBits>>(iterator: T) -> StencilFaceFlags {
        let mut out = Self::empty();
        <Self as Extend<StencilFaceFlagBits>>::extend(&mut out, iterator);
        out
    }
}
impl std::fmt::Debug for StencilFaceFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(StencilFaceFlags);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == StencilFaceFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(StencilFaceFlags::FRONT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(FRONT))?;
                    }
                    if self.0.contains(StencilFaceFlags::BACK) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(BACK))?;
                    }
                    if self.0.contains(StencilFaceFlags::FRONT_AND_BACK) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(FRONT_AND_BACK))?;
                    }
                    if self.0.contains(StencilFaceFlags::STENCIL_FRONT_AND_BACK) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(STENCIL_FRONT_AND_BACK))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(StencilFaceFlags))
            .field(&Flags(*self))
            .finish()
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for StencilFaceFlags {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for StencilFaceFlags {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkCullModeFlags")]
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct CullModeFlags(u32);
impl CullModeFlags {
    #[doc(alias = "VK_CULL_MODE_NONE")]
    pub const NONE: Self = Self(0);
    #[doc(alias = "VK_CULL_MODE_FRONT_BIT")]
    pub const FRONT: Self = Self(1);
    #[doc(alias = "VK_CULL_MODE_BACK_BIT")]
    pub const BACK: Self = Self(2);
    #[doc(alias = "VK_CULL_MODE_FRONT_AND_BACK")]
    pub const FRONT_AND_BACK: Self = Self(3);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    #[allow(unused_mut)]
    pub const fn all() -> Self {
        let mut all = Self::empty();
        {
            all |= Self::NONE;
        }
        {
            all |= Self::FRONT;
        }
        {
            all |= Self::BACK;
        }
        {
            all |= Self::FRONT_AND_BACK;
        }
        all
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl std::ops::BitOr for CullModeFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl std::ops::BitOrAssign for CullModeFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl std::ops::BitXor for CullModeFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl std::ops::BitXorAssign for CullModeFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl std::ops::BitAnd for CullModeFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl std::ops::BitAndAssign for CullModeFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl std::ops::Sub for CullModeFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl std::ops::SubAssign for CullModeFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl std::ops::Not for CullModeFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl Extend<CullModeFlags> for CullModeFlags {
    fn extend<T: IntoIterator<Item = CullModeFlags>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, i);
        }
    }
}
impl FromIterator<CullModeFlags> for CullModeFlags {
    fn from_iter<T: IntoIterator<Item = CullModeFlags>>(iterator: T) -> CullModeFlags {
        let mut out = Self::empty();
        <Self as Extend<CullModeFlags>>::extend(&mut out, iterator);
        out
    }
}
impl Default for CullModeFlags {
    fn default() -> Self {
        Self::empty()
    }
}
impl From<CullModeFlagBits> for CullModeFlags {
    fn from(bit: CullModeFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(bit.bits()) }
    }
}
impl Extend<CullModeFlagBits> for CullModeFlags {
    fn extend<T: IntoIterator<Item = CullModeFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, Self::from(i));
        }
    }
}
impl FromIterator<CullModeFlagBits> for CullModeFlags {
    fn from_iter<T: IntoIterator<Item = CullModeFlagBits>>(iterator: T) -> CullModeFlags {
        let mut out = Self::empty();
        <Self as Extend<CullModeFlagBits>>::extend(&mut out, iterator);
        out
    }
}
impl std::fmt::Debug for CullModeFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(CullModeFlags);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == CullModeFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(CullModeFlags::NONE) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(NONE))?;
                    }
                    if self.0.contains(CullModeFlags::FRONT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(FRONT))?;
                    }
                    if self.0.contains(CullModeFlags::BACK) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(BACK))?;
                    }
                    if self.0.contains(CullModeFlags::FRONT_AND_BACK) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(FRONT_AND_BACK))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(CullModeFlags)).field(&Flags(*self)).finish()
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for CullModeFlags {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for CullModeFlags {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkDescriptorPoolCreateFlags")]
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct DescriptorPoolCreateFlags(u32);
impl DescriptorPoolCreateFlags {
    #[doc(alias = "VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT")]
    pub const FREE_DESCRIPTOR_SET: Self = Self(1);
    #[doc(alias = "VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT")]
    #[cfg(feature = "VULKAN_1_2")]
    pub const UPDATE_AFTER_BIND: Self = Self(2);
    #[doc(alias = "VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_VALVE")]
    #[cfg(feature = "VK_VALVE_mutable_descriptor_type")]
    pub const HOST_ONLY_VALVE: Self = Self(4);
    #[doc(alias = "VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT")]
    #[cfg(feature = "VK_EXT_descriptor_indexing")]
    pub const UPDATE_AFTER_BIND_EXT: Self = Self::UPDATE_AFTER_BIND;
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    #[allow(unused_mut)]
    pub const fn all() -> Self {
        let mut all = Self::empty();
        {
            all |= Self::FREE_DESCRIPTOR_SET;
        }
        #[cfg(feature = "VULKAN_1_2")]
        {
            all |= Self::UPDATE_AFTER_BIND;
        }
        #[cfg(feature = "VK_VALVE_mutable_descriptor_type")]
        {
            all |= Self::HOST_ONLY_VALVE;
        }
        #[cfg(feature = "VK_EXT_descriptor_indexing")]
        {
            all |= Self::UPDATE_AFTER_BIND_EXT;
        }
        all
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl std::ops::BitOr for DescriptorPoolCreateFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl std::ops::BitOrAssign for DescriptorPoolCreateFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl std::ops::BitXor for DescriptorPoolCreateFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl std::ops::BitXorAssign for DescriptorPoolCreateFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl std::ops::BitAnd for DescriptorPoolCreateFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl std::ops::BitAndAssign for DescriptorPoolCreateFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl std::ops::Sub for DescriptorPoolCreateFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl std::ops::SubAssign for DescriptorPoolCreateFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl std::ops::Not for DescriptorPoolCreateFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl Extend<DescriptorPoolCreateFlags> for DescriptorPoolCreateFlags {
    fn extend<T: IntoIterator<Item = DescriptorPoolCreateFlags>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, i);
        }
    }
}
impl FromIterator<DescriptorPoolCreateFlags> for DescriptorPoolCreateFlags {
    fn from_iter<T: IntoIterator<Item = DescriptorPoolCreateFlags>>(iterator: T) -> DescriptorPoolCreateFlags {
        let mut out = Self::empty();
        <Self as Extend<DescriptorPoolCreateFlags>>::extend(&mut out, iterator);
        out
    }
}
impl Default for DescriptorPoolCreateFlags {
    fn default() -> Self {
        Self::empty()
    }
}
impl From<DescriptorPoolCreateFlagBits> for DescriptorPoolCreateFlags {
    fn from(bit: DescriptorPoolCreateFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(bit.bits()) }
    }
}
impl Extend<DescriptorPoolCreateFlagBits> for DescriptorPoolCreateFlags {
    fn extend<T: IntoIterator<Item = DescriptorPoolCreateFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, Self::from(i));
        }
    }
}
impl FromIterator<DescriptorPoolCreateFlagBits> for DescriptorPoolCreateFlags {
    fn from_iter<T: IntoIterator<Item = DescriptorPoolCreateFlagBits>>(iterator: T) -> DescriptorPoolCreateFlags {
        let mut out = Self::empty();
        <Self as Extend<DescriptorPoolCreateFlagBits>>::extend(&mut out, iterator);
        out
    }
}
impl std::fmt::Debug for DescriptorPoolCreateFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(DescriptorPoolCreateFlags);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == DescriptorPoolCreateFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(DescriptorPoolCreateFlags::FREE_DESCRIPTOR_SET) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(FREE_DESCRIPTOR_SET))?;
                    }
                    #[cfg(feature = "VULKAN_1_2")]
                    if self.0.contains(DescriptorPoolCreateFlags::UPDATE_AFTER_BIND) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(UPDATE_AFTER_BIND))?;
                    }
                    #[cfg(feature = "VK_VALVE_mutable_descriptor_type")]
                    if self.0.contains(DescriptorPoolCreateFlags::HOST_ONLY_VALVE) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(HOST_ONLY_VALVE))?;
                    }
                    #[cfg(feature = "VK_EXT_descriptor_indexing")]
                    if self.0.contains(DescriptorPoolCreateFlags::UPDATE_AFTER_BIND_EXT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(UPDATE_AFTER_BIND_EXT))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(DescriptorPoolCreateFlags))
            .field(&Flags(*self))
            .finish()
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for DescriptorPoolCreateFlags {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for DescriptorPoolCreateFlags {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkDescriptorPoolResetFlags")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct DescriptorPoolResetFlags(u32);
impl DescriptorPoolResetFlags {
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
}
impl Default for DescriptorPoolResetFlags {
    #[inline]
    fn default() -> Self {
        Self::empty()
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for DescriptorPoolResetFlags {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for DescriptorPoolResetFlags {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkDependencyFlags")]
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct DependencyFlags(u32);
impl DependencyFlags {
    #[doc(alias = "VK_DEPENDENCY_BY_REGION_BIT")]
    pub const BY_REGION: Self = Self(1);
    #[doc(alias = "VK_DEPENDENCY_DEVICE_GROUP_BIT")]
    pub const DEVICE_GROUP: Self = Self(4);
    #[doc(alias = "VK_DEPENDENCY_VIEW_LOCAL_BIT")]
    pub const VIEW_LOCAL: Self = Self(2);
    #[doc(alias = "VK_DEPENDENCY_VIEW_LOCAL_BIT_KHR")]
    #[cfg(feature = "VK_KHR_multiview")]
    pub const VIEW_LOCAL_KHR: Self = Self::VIEW_LOCAL;
    #[doc(alias = "VK_DEPENDENCY_DEVICE_GROUP_BIT_KHR")]
    #[cfg(feature = "VK_KHR_device_group")]
    pub const DEVICE_GROUP_KHR: Self = Self::DEVICE_GROUP;
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    #[allow(unused_mut)]
    pub const fn all() -> Self {
        let mut all = Self::empty();
        {
            all |= Self::BY_REGION;
        }
        {
            all |= Self::DEVICE_GROUP;
        }
        {
            all |= Self::VIEW_LOCAL;
        }
        #[cfg(feature = "VK_KHR_multiview")]
        {
            all |= Self::VIEW_LOCAL_KHR;
        }
        #[cfg(feature = "VK_KHR_device_group")]
        {
            all |= Self::DEVICE_GROUP_KHR;
        }
        all
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl std::ops::BitOr for DependencyFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl std::ops::BitOrAssign for DependencyFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl std::ops::BitXor for DependencyFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl std::ops::BitXorAssign for DependencyFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl std::ops::BitAnd for DependencyFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl std::ops::BitAndAssign for DependencyFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl std::ops::Sub for DependencyFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl std::ops::SubAssign for DependencyFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl std::ops::Not for DependencyFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl Extend<DependencyFlags> for DependencyFlags {
    fn extend<T: IntoIterator<Item = DependencyFlags>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, i);
        }
    }
}
impl FromIterator<DependencyFlags> for DependencyFlags {
    fn from_iter<T: IntoIterator<Item = DependencyFlags>>(iterator: T) -> DependencyFlags {
        let mut out = Self::empty();
        <Self as Extend<DependencyFlags>>::extend(&mut out, iterator);
        out
    }
}
impl Default for DependencyFlags {
    fn default() -> Self {
        Self::empty()
    }
}
impl From<DependencyFlagBits> for DependencyFlags {
    fn from(bit: DependencyFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(bit.bits()) }
    }
}
impl Extend<DependencyFlagBits> for DependencyFlags {
    fn extend<T: IntoIterator<Item = DependencyFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, Self::from(i));
        }
    }
}
impl FromIterator<DependencyFlagBits> for DependencyFlags {
    fn from_iter<T: IntoIterator<Item = DependencyFlagBits>>(iterator: T) -> DependencyFlags {
        let mut out = Self::empty();
        <Self as Extend<DependencyFlagBits>>::extend(&mut out, iterator);
        out
    }
}
impl std::fmt::Debug for DependencyFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(DependencyFlags);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == DependencyFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(DependencyFlags::BY_REGION) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(BY_REGION))?;
                    }
                    if self.0.contains(DependencyFlags::DEVICE_GROUP) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(DEVICE_GROUP))?;
                    }
                    if self.0.contains(DependencyFlags::VIEW_LOCAL) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(VIEW_LOCAL))?;
                    }
                    #[cfg(feature = "VK_KHR_multiview")]
                    if self.0.contains(DependencyFlags::VIEW_LOCAL_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(VIEW_LOCAL_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_device_group")]
                    if self.0.contains(DependencyFlags::DEVICE_GROUP_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(DEVICE_GROUP_KHR))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(DependencyFlags)).field(&Flags(*self)).finish()
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for DependencyFlags {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for DependencyFlags {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VK_MAX_PHYSICAL_DEVICE_NAME_SIZE")]
pub const MAX_PHYSICAL_DEVICE_NAME_SIZE: u32 = 256;
#[doc(alias = "VK_UUID_SIZE")]
pub const UUID_SIZE: u32 = 16;
#[doc(alias = "VK_LUID_SIZE")]
pub const LUID_SIZE: u32 = 8;
#[doc(alias = "VK_MAX_EXTENSION_NAME_SIZE")]
pub const MAX_EXTENSION_NAME_SIZE: u32 = 256;
#[doc(alias = "VK_MAX_DESCRIPTION_SIZE")]
pub const MAX_DESCRIPTION_SIZE: u32 = 256;
#[doc(alias = "VK_MAX_MEMORY_TYPES")]
pub const MAX_MEMORY_TYPES: u32 = 32;
#[doc(alias = "VK_MAX_MEMORY_HEAPS")]
pub const MAX_MEMORY_HEAPS: u32 = 16;
#[doc(alias = "VK_LOD_CLAMP_NONE")]
pub const LOD_CLAMP_NONE: f32 = 1000.0;
#[doc(alias = "VK_REMAINING_MIP_LEVELS")]
pub const REMAINING_MIP_LEVELS: u32 = !0;
#[doc(alias = "VK_REMAINING_ARRAY_LAYERS")]
pub const REMAINING_ARRAY_LAYERS: u32 = !0;
#[doc(alias = "VK_WHOLE_SIZE")]
pub const WHOLE_SIZE: u64 = !0;
#[doc(alias = "VK_ATTACHMENT_UNUSED")]
pub const ATTACHMENT_UNUSED: u32 = !0;
#[doc(alias = "VK_TRUE")]
pub const TRUE: u32 = 1;
#[doc(alias = "VK_FALSE")]
pub const FALSE: u32 = 0;
#[doc(alias = "VK_QUEUE_FAMILY_IGNORED")]
pub const QUEUE_FAMILY_IGNORED: u32 = !0;
#[doc(alias = "VK_QUEUE_FAMILY_EXTERNAL")]
pub const QUEUE_FAMILY_EXTERNAL: u32 = !1;
#[doc(alias = "VK_QUEUE_FAMILY_FOREIGN_EXT")]
pub const QUEUE_FAMILY_FOREIGN_EXT: u32 = !2;
#[doc(alias = "VK_SUBPASS_EXTERNAL")]
pub const SUBPASS_EXTERNAL: u32 = !0;
#[doc(alias = "VK_MAX_DEVICE_GROUP_SIZE")]
pub const MAX_DEVICE_GROUP_SIZE: u32 = 32;
#[doc(alias = "VK_MAX_DRIVER_NAME_SIZE")]
pub const MAX_DRIVER_NAME_SIZE: u32 = 256;
#[doc(alias = "VK_MAX_DRIVER_INFO_SIZE")]
pub const MAX_DRIVER_INFO_SIZE: u32 = 256;
#[doc(alias = "VK_SHADER_UNUSED_KHR")]
pub const SHADER_UNUSED_KHR: u32 = !0;
#[doc(alias = "VK_MAX_GLOBAL_PRIORITY_SIZE_KHR")]
pub const MAX_GLOBAL_PRIORITY_SIZE_KHR: u32 = 16;
#[doc(alias = "VkQueueFlagBits")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct QueueFlagBits(u32);
impl Default for QueueFlagBits {
    #[inline]
    fn default() -> Self {
        Self::empty()
    }
}
impl QueueFlagBits {
    #[doc(alias = "VK_QUEUE_GRAPHICS_BIT")]
    pub const GRAPHICS: Self = Self(1);
    #[doc(alias = "VK_QUEUE_COMPUTE_BIT")]
    pub const COMPUTE: Self = Self(2);
    #[doc(alias = "VK_QUEUE_TRANSFER_BIT")]
    pub const TRANSFER: Self = Self(4);
    #[doc(alias = "VK_QUEUE_SPARSE_BINDING_BIT")]
    pub const SPARSE_BINDING: Self = Self(8);
    #[doc(alias = "VK_QUEUE_PROTECTED_BIT")]
    pub const PROTECTED: Self = Self(16);
    #[doc(alias = "VK_QUEUE_VIDEO_DECODE_BIT_KHR")]
    #[cfg(feature = "VK_KHR_video_decode_queue")]
    pub const VIDEO_DECODE_KHR: Self = Self(32);
    #[doc(alias = "VK_QUEUE_VIDEO_ENCODE_BIT_KHR")]
    #[cfg(feature = "VK_KHR_video_encode_queue")]
    pub const VIDEO_ENCODE_KHR: Self = Self(64);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        match bits {
            x if x == Self::GRAPHICS.bits() => Some(Self(x)),
            x if x == Self::COMPUTE.bits() => Some(Self(x)),
            x if x == Self::TRANSFER.bits() => Some(Self(x)),
            x if x == Self::SPARSE_BINDING.bits() => Some(Self(x)),
            x if x == Self::PROTECTED.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_video_decode_queue")]
            x if x == Self::VIDEO_DECODE_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_video_encode_queue")]
            x if x == Self::VIDEO_ENCODE_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_QCOM_extension_440")]
            x if x == Self::RESERVED7_QCOM.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for QueueFlagBits {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for QueueFlagBits {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkCullModeFlagBits")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct CullModeFlagBits(u32);
impl Default for CullModeFlagBits {
    #[inline]
    fn default() -> Self {
        Self::empty()
    }
}
impl CullModeFlagBits {
    #[doc(alias = "VK_CULL_MODE_NONE")]
    pub const NONE: Self = Self(0);
    #[doc(alias = "VK_CULL_MODE_FRONT_BIT")]
    pub const FRONT: Self = Self(1);
    #[doc(alias = "VK_CULL_MODE_BACK_BIT")]
    pub const BACK: Self = Self(2);
    #[doc(alias = "VK_CULL_MODE_FRONT_AND_BACK")]
    pub const FRONT_AND_BACK: Self = Self(3);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        match bits {
            x if x == Self::NONE.bits() => Some(Self(x)),
            x if x == Self::FRONT.bits() => Some(Self(x)),
            x if x == Self::BACK.bits() => Some(Self(x)),
            x if x == Self::FRONT_AND_BACK.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for CullModeFlagBits {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for CullModeFlagBits {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkRenderPassCreateFlagBits")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct RenderPassCreateFlagBits(u32);
impl Default for RenderPassCreateFlagBits {
    #[inline]
    fn default() -> Self {
        Self::empty()
    }
}
impl RenderPassCreateFlagBits {
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        match bits {
            #[cfg(feature = "VK_KHR_extension_221")]
            x if x == Self::RESERVED0_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_QCOM_render_pass_transform")]
            x if x == Self::TRANSFORM_QCOM.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for RenderPassCreateFlagBits {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for RenderPassCreateFlagBits {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkMemoryPropertyFlagBits")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct MemoryPropertyFlagBits(u32);
impl Default for MemoryPropertyFlagBits {
    #[inline]
    fn default() -> Self {
        Self::empty()
    }
}
impl MemoryPropertyFlagBits {
    #[doc(alias = "VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT")]
    pub const DEVICE_LOCAL: Self = Self(1);
    #[doc(alias = "VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT")]
    pub const HOST_VISIBLE: Self = Self(2);
    #[doc(alias = "VK_MEMORY_PROPERTY_HOST_COHERENT_BIT")]
    pub const HOST_COHERENT: Self = Self(4);
    #[doc(alias = "VK_MEMORY_PROPERTY_HOST_CACHED_BIT")]
    pub const HOST_CACHED: Self = Self(8);
    #[doc(alias = "VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT")]
    pub const LAZILY_ALLOCATED: Self = Self(16);
    #[doc(alias = "VK_MEMORY_PROPERTY_PROTECTED_BIT")]
    pub const PROTECTED: Self = Self(32);
    #[doc(alias = "VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD")]
    #[cfg(feature = "VK_AMD_device_coherent_memory")]
    pub const DEVICE_COHERENT_AMD: Self = Self(64);
    #[doc(alias = "VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD")]
    #[cfg(feature = "VK_AMD_device_coherent_memory")]
    pub const DEVICE_UNCACHED_AMD: Self = Self(128);
    #[doc(alias = "VK_MEMORY_PROPERTY_RDMA_CAPABLE_BIT_NV")]
    #[cfg(feature = "VK_NV_external_memory_rdma")]
    pub const RDMA_CAPABLE_NV: Self = Self(256);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        match bits {
            x if x == Self::DEVICE_LOCAL.bits() => Some(Self(x)),
            x if x == Self::HOST_VISIBLE.bits() => Some(Self(x)),
            x if x == Self::HOST_COHERENT.bits() => Some(Self(x)),
            x if x == Self::HOST_CACHED.bits() => Some(Self(x)),
            x if x == Self::LAZILY_ALLOCATED.bits() => Some(Self(x)),
            x if x == Self::PROTECTED.bits() => Some(Self(x)),
            #[cfg(feature = "VK_AMD_device_coherent_memory")]
            x if x == Self::DEVICE_COHERENT_AMD.bits() => Some(Self(x)),
            #[cfg(feature = "VK_AMD_device_coherent_memory")]
            x if x == Self::DEVICE_UNCACHED_AMD.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_external_memory_rdma")]
            x if x == Self::RDMA_CAPABLE_NV.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for MemoryPropertyFlagBits {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for MemoryPropertyFlagBits {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkMemoryHeapFlagBits")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct MemoryHeapFlagBits(u32);
impl Default for MemoryHeapFlagBits {
    #[inline]
    fn default() -> Self {
        Self::empty()
    }
}
impl MemoryHeapFlagBits {
    #[doc(alias = "VK_MEMORY_HEAP_DEVICE_LOCAL_BIT")]
    pub const DEVICE_LOCAL: Self = Self(1);
    #[doc(alias = "VK_MEMORY_HEAP_MULTI_INSTANCE_BIT")]
    pub const MULTI_INSTANCE: Self = Self(2);
    #[doc(alias = "VK_MEMORY_HEAP_MULTI_INSTANCE_BIT_KHR")]
    #[cfg(feature = "VK_KHR_device_group_creation")]
    pub const MULTI_INSTANCE_KHR: Self = Self::MULTI_INSTANCE;
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        match bits {
            x if x == Self::DEVICE_LOCAL.bits() => Some(Self(x)),
            x if x == Self::MULTI_INSTANCE.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_extension_299")]
            x if x == Self::RESERVED2_KHR.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for MemoryHeapFlagBits {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for MemoryHeapFlagBits {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkAccessFlagBits")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct AccessFlagBits(u32);
impl Default for AccessFlagBits {
    #[inline]
    fn default() -> Self {
        Self::empty()
    }
}
impl AccessFlagBits {
    #[doc(alias = "VK_ACCESS_INDIRECT_COMMAND_READ_BIT")]
    pub const INDIRECT_COMMAND_READ: Self = Self(1);
    #[doc(alias = "VK_ACCESS_INDEX_READ_BIT")]
    pub const INDEX_READ: Self = Self(2);
    #[doc(alias = "VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT")]
    pub const VERTEX_ATTRIBUTE_READ: Self = Self(4);
    #[doc(alias = "VK_ACCESS_UNIFORM_READ_BIT")]
    pub const UNIFORM_READ: Self = Self(8);
    #[doc(alias = "VK_ACCESS_INPUT_ATTACHMENT_READ_BIT")]
    pub const INPUT_ATTACHMENT_READ: Self = Self(16);
    #[doc(alias = "VK_ACCESS_SHADER_READ_BIT")]
    pub const SHADER_READ: Self = Self(32);
    #[doc(alias = "VK_ACCESS_SHADER_WRITE_BIT")]
    pub const SHADER_WRITE: Self = Self(64);
    #[doc(alias = "VK_ACCESS_COLOR_ATTACHMENT_READ_BIT")]
    pub const COLOR_ATTACHMENT_READ: Self = Self(128);
    #[doc(alias = "VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT")]
    pub const COLOR_ATTACHMENT_WRITE: Self = Self(256);
    #[doc(alias = "VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT")]
    pub const DEPTH_STENCIL_ATTACHMENT_READ: Self = Self(512);
    #[doc(alias = "VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT")]
    pub const DEPTH_STENCIL_ATTACHMENT_WRITE: Self = Self(1024);
    #[doc(alias = "VK_ACCESS_TRANSFER_READ_BIT")]
    pub const TRANSFER_READ: Self = Self(2048);
    #[doc(alias = "VK_ACCESS_TRANSFER_WRITE_BIT")]
    pub const TRANSFER_WRITE: Self = Self(4096);
    #[doc(alias = "VK_ACCESS_HOST_READ_BIT")]
    pub const HOST_READ: Self = Self(8192);
    #[doc(alias = "VK_ACCESS_HOST_WRITE_BIT")]
    pub const HOST_WRITE: Self = Self(16384);
    #[doc(alias = "VK_ACCESS_MEMORY_READ_BIT")]
    pub const MEMORY_READ: Self = Self(32768);
    #[doc(alias = "VK_ACCESS_MEMORY_WRITE_BIT")]
    pub const MEMORY_WRITE: Self = Self(65536);
    #[doc(alias = "VK_ACCESS_NONE")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const NONE: Self = Self(0);
    #[doc(alias = "VK_ACCESS_TRANSFORM_FEEDBACK_WRITE_BIT_EXT")]
    #[cfg(feature = "VK_EXT_transform_feedback")]
    pub const TRANSFORM_FEEDBACK_WRITE_EXT: Self = Self(33554432);
    #[doc(alias = "VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT")]
    #[cfg(feature = "VK_EXT_transform_feedback")]
    pub const TRANSFORM_FEEDBACK_COUNTER_READ_EXT: Self = Self(67108864);
    #[doc(alias = "VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT")]
    #[cfg(feature = "VK_EXT_transform_feedback")]
    pub const TRANSFORM_FEEDBACK_COUNTER_WRITE_EXT: Self = Self(134217728);
    #[doc(alias = "VK_ACCESS_CONDITIONAL_RENDERING_READ_BIT_EXT")]
    #[cfg(feature = "VK_EXT_conditional_rendering")]
    pub const CONDITIONAL_RENDERING_READ_EXT: Self = Self(1048576);
    #[doc(alias = "VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    pub const COLOR_ATTACHMENT_READ_NONCOHERENT_EXT: Self = Self(524288);
    #[doc(alias = "VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR")]
    #[cfg(feature = "VK_KHR_acceleration_structure")]
    pub const ACCELERATION_STRUCTURE_READ_KHR: Self = Self(2097152);
    #[doc(alias = "VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR")]
    #[cfg(feature = "VK_KHR_acceleration_structure")]
    pub const ACCELERATION_STRUCTURE_WRITE_KHR: Self = Self(4194304);
    #[doc(alias = "VK_ACCESS_FRAGMENT_DENSITY_MAP_READ_BIT_EXT")]
    #[cfg(feature = "VK_EXT_fragment_density_map")]
    pub const FRAGMENT_DENSITY_MAP_READ_EXT: Self = Self(16777216);
    #[doc(alias = "VK_ACCESS_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR")]
    #[cfg(feature = "VK_KHR_fragment_shading_rate")]
    pub const FRAGMENT_SHADING_RATE_ATTACHMENT_READ_KHR: Self = Self(8388608);
    #[doc(alias = "VK_ACCESS_COMMAND_PREPROCESS_READ_BIT_NV")]
    #[cfg(feature = "VK_NV_device_generated_commands")]
    pub const COMMAND_PREPROCESS_READ_NV: Self = Self(131072);
    #[doc(alias = "VK_ACCESS_COMMAND_PREPROCESS_WRITE_BIT_NV")]
    #[cfg(feature = "VK_NV_device_generated_commands")]
    pub const COMMAND_PREPROCESS_WRITE_NV: Self = Self(262144);
    #[doc(alias = "VK_ACCESS_SHADING_RATE_IMAGE_READ_BIT_NV")]
    #[cfg(feature = "VK_NV_shading_rate_image")]
    pub const SHADING_RATE_IMAGE_READ_NV: Self = Self::FRAGMENT_SHADING_RATE_ATTACHMENT_READ_KHR;
    #[doc(alias = "VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_NV")]
    #[cfg(feature = "VK_NV_ray_tracing")]
    pub const ACCELERATION_STRUCTURE_READ_NV: Self = Self::ACCELERATION_STRUCTURE_READ_KHR;
    #[doc(alias = "VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_NV")]
    #[cfg(feature = "VK_NV_ray_tracing")]
    pub const ACCELERATION_STRUCTURE_WRITE_NV: Self = Self::ACCELERATION_STRUCTURE_WRITE_KHR;
    #[doc(alias = "VK_ACCESS_NONE_KHR")]
    #[cfg(feature = "VK_KHR_synchronization2")]
    pub const NONE_KHR: Self = Self::NONE;
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        match bits {
            x if x == Self::INDIRECT_COMMAND_READ.bits() => Some(Self(x)),
            x if x == Self::INDEX_READ.bits() => Some(Self(x)),
            x if x == Self::VERTEX_ATTRIBUTE_READ.bits() => Some(Self(x)),
            x if x == Self::UNIFORM_READ.bits() => Some(Self(x)),
            x if x == Self::INPUT_ATTACHMENT_READ.bits() => Some(Self(x)),
            x if x == Self::SHADER_READ.bits() => Some(Self(x)),
            x if x == Self::SHADER_WRITE.bits() => Some(Self(x)),
            x if x == Self::COLOR_ATTACHMENT_READ.bits() => Some(Self(x)),
            x if x == Self::COLOR_ATTACHMENT_WRITE.bits() => Some(Self(x)),
            x if x == Self::DEPTH_STENCIL_ATTACHMENT_READ.bits() => Some(Self(x)),
            x if x == Self::DEPTH_STENCIL_ATTACHMENT_WRITE.bits() => Some(Self(x)),
            x if x == Self::TRANSFER_READ.bits() => Some(Self(x)),
            x if x == Self::TRANSFER_WRITE.bits() => Some(Self(x)),
            x if x == Self::HOST_READ.bits() => Some(Self(x)),
            x if x == Self::HOST_WRITE.bits() => Some(Self(x)),
            x if x == Self::MEMORY_READ.bits() => Some(Self(x)),
            x if x == Self::MEMORY_WRITE.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::NONE.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_transform_feedback")]
            x if x == Self::TRANSFORM_FEEDBACK_WRITE_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_transform_feedback")]
            x if x == Self::TRANSFORM_FEEDBACK_COUNTER_READ_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_transform_feedback")]
            x if x == Self::TRANSFORM_FEEDBACK_COUNTER_WRITE_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_conditional_rendering")]
            x if x == Self::CONDITIONAL_RENDERING_READ_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::COLOR_ATTACHMENT_READ_NONCOHERENT_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_acceleration_structure")]
            x if x == Self::ACCELERATION_STRUCTURE_READ_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_acceleration_structure")]
            x if x == Self::ACCELERATION_STRUCTURE_WRITE_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_fragment_density_map")]
            x if x == Self::FRAGMENT_DENSITY_MAP_READ_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_fragment_shading_rate")]
            x if x == Self::FRAGMENT_SHADING_RATE_ATTACHMENT_READ_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_device_generated_commands")]
            x if x == Self::COMMAND_PREPROCESS_READ_NV.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_device_generated_commands")]
            x if x == Self::COMMAND_PREPROCESS_WRITE_NV.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for AccessFlagBits {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for AccessFlagBits {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkBufferUsageFlagBits")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct BufferUsageFlagBits(u32);
impl Default for BufferUsageFlagBits {
    #[inline]
    fn default() -> Self {
        Self::empty()
    }
}
impl BufferUsageFlagBits {
    #[doc(alias = "VK_BUFFER_USAGE_TRANSFER_SRC_BIT")]
    pub const TRANSFER_SRC: Self = Self(1);
    #[doc(alias = "VK_BUFFER_USAGE_TRANSFER_DST_BIT")]
    pub const TRANSFER_DST: Self = Self(2);
    #[doc(alias = "VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT")]
    pub const UNIFORM_TEXEL_BUFFER: Self = Self(4);
    #[doc(alias = "VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT")]
    pub const STORAGE_TEXEL_BUFFER: Self = Self(8);
    #[doc(alias = "VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT")]
    pub const UNIFORM_BUFFER: Self = Self(16);
    #[doc(alias = "VK_BUFFER_USAGE_STORAGE_BUFFER_BIT")]
    pub const STORAGE_BUFFER: Self = Self(32);
    #[doc(alias = "VK_BUFFER_USAGE_INDEX_BUFFER_BIT")]
    pub const INDEX_BUFFER: Self = Self(64);
    #[doc(alias = "VK_BUFFER_USAGE_VERTEX_BUFFER_BIT")]
    pub const VERTEX_BUFFER: Self = Self(128);
    #[doc(alias = "VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT")]
    pub const INDIRECT_BUFFER: Self = Self(256);
    #[doc(alias = "VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT")]
    #[cfg(feature = "VULKAN_1_2")]
    pub const SHADER_DEVICE_ADDRESS: Self = Self(131072);
    #[doc(alias = "VK_BUFFER_USAGE_VIDEO_DECODE_SRC_BIT_KHR")]
    #[cfg(feature = "VK_KHR_video_decode_queue")]
    pub const VIDEO_DECODE_SRC_KHR: Self = Self(8192);
    #[doc(alias = "VK_BUFFER_USAGE_VIDEO_DECODE_DST_BIT_KHR")]
    #[cfg(feature = "VK_KHR_video_decode_queue")]
    pub const VIDEO_DECODE_DST_KHR: Self = Self(16384);
    #[doc(alias = "VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT")]
    #[cfg(feature = "VK_EXT_transform_feedback")]
    pub const TRANSFORM_FEEDBACK_BUFFER_EXT: Self = Self(2048);
    #[doc(alias = "VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT")]
    #[cfg(feature = "VK_EXT_transform_feedback")]
    pub const TRANSFORM_FEEDBACK_COUNTER_BUFFER_EXT: Self = Self(4096);
    #[doc(alias = "VK_BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT")]
    #[cfg(feature = "VK_EXT_conditional_rendering")]
    pub const CONDITIONAL_RENDERING_EXT: Self = Self(512);
    #[doc(alias = "VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR")]
    #[cfg(feature = "VK_KHR_acceleration_structure")]
    pub const ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_KHR: Self = Self(524288);
    #[doc(alias = "VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR")]
    #[cfg(feature = "VK_KHR_acceleration_structure")]
    pub const ACCELERATION_STRUCTURE_STORAGE_KHR: Self = Self(1048576);
    #[doc(alias = "VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR")]
    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
    pub const SHADER_BINDING_TABLE_KHR: Self = Self(1024);
    #[doc(alias = "VK_BUFFER_USAGE_VIDEO_ENCODE_DST_BIT_KHR")]
    #[cfg(feature = "VK_KHR_video_encode_queue")]
    pub const VIDEO_ENCODE_DST_KHR: Self = Self(32768);
    #[doc(alias = "VK_BUFFER_USAGE_VIDEO_ENCODE_SRC_BIT_KHR")]
    #[cfg(feature = "VK_KHR_video_encode_queue")]
    pub const VIDEO_ENCODE_SRC_KHR: Self = Self(65536);
    #[doc(alias = "VK_BUFFER_USAGE_RAY_TRACING_BIT_NV")]
    #[cfg(feature = "VK_NV_ray_tracing")]
    pub const RAY_TRACING_NV: Self = Self::SHADER_BINDING_TABLE_KHR;
    #[doc(alias = "VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_EXT")]
    #[cfg(feature = "VK_EXT_buffer_device_address")]
    pub const SHADER_DEVICE_ADDRESS_EXT: Self = Self::SHADER_DEVICE_ADDRESS;
    #[doc(alias = "VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_KHR")]
    #[cfg(feature = "VK_KHR_buffer_device_address")]
    pub const SHADER_DEVICE_ADDRESS_KHR: Self = Self::SHADER_DEVICE_ADDRESS;
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        match bits {
            x if x == Self::TRANSFER_SRC.bits() => Some(Self(x)),
            x if x == Self::TRANSFER_DST.bits() => Some(Self(x)),
            x if x == Self::UNIFORM_TEXEL_BUFFER.bits() => Some(Self(x)),
            x if x == Self::STORAGE_TEXEL_BUFFER.bits() => Some(Self(x)),
            x if x == Self::UNIFORM_BUFFER.bits() => Some(Self(x)),
            x if x == Self::STORAGE_BUFFER.bits() => Some(Self(x)),
            x if x == Self::INDEX_BUFFER.bits() => Some(Self(x)),
            x if x == Self::VERTEX_BUFFER.bits() => Some(Self(x)),
            x if x == Self::INDIRECT_BUFFER.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::SHADER_DEVICE_ADDRESS.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_video_decode_queue")]
            x if x == Self::VIDEO_DECODE_SRC_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_video_decode_queue")]
            x if x == Self::VIDEO_DECODE_DST_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_transform_feedback")]
            x if x == Self::TRANSFORM_FEEDBACK_BUFFER_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_transform_feedback")]
            x if x == Self::TRANSFORM_FEEDBACK_COUNTER_BUFFER_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_conditional_rendering")]
            x if x == Self::CONDITIONAL_RENDERING_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_acceleration_structure")]
            x if x == Self::ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_acceleration_structure")]
            x if x == Self::ACCELERATION_STRUCTURE_STORAGE_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
            x if x == Self::SHADER_BINDING_TABLE_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_QCOM_extension_173")]
            x if x == Self::RESERVED18_QCOM.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_video_encode_queue")]
            x if x == Self::VIDEO_ENCODE_DST_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_video_encode_queue")]
            x if x == Self::VIDEO_ENCODE_SRC_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_AMD_extension_317")]
            x if x == Self::RESERVED21_AMD.bits() => Some(Self(x)),
            #[cfg(feature = "VK_AMD_extension_317")]
            x if x == Self::RESERVED22_AMD.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for BufferUsageFlagBits {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for BufferUsageFlagBits {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkBufferCreateFlagBits")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct BufferCreateFlagBits(u32);
impl Default for BufferCreateFlagBits {
    #[inline]
    fn default() -> Self {
        Self::empty()
    }
}
impl BufferCreateFlagBits {
    #[doc(alias = "VK_BUFFER_CREATE_SPARSE_BINDING_BIT")]
    pub const SPARSE_BINDING: Self = Self(1);
    #[doc(alias = "VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT")]
    pub const SPARSE_RESIDENCY: Self = Self(2);
    #[doc(alias = "VK_BUFFER_CREATE_SPARSE_ALIASED_BIT")]
    pub const SPARSE_ALIASED: Self = Self(4);
    #[doc(alias = "VK_BUFFER_CREATE_PROTECTED_BIT")]
    pub const PROTECTED: Self = Self(8);
    #[doc(alias = "VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT")]
    #[cfg(feature = "VULKAN_1_2")]
    pub const DEVICE_ADDRESS_CAPTURE_REPLAY: Self = Self(16);
    #[doc(alias = "VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT")]
    #[cfg(feature = "VK_EXT_buffer_device_address")]
    pub const DEVICE_ADDRESS_CAPTURE_REPLAY_EXT: Self = Self::DEVICE_ADDRESS_CAPTURE_REPLAY;
    #[doc(alias = "VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR")]
    #[cfg(feature = "VK_KHR_buffer_device_address")]
    pub const DEVICE_ADDRESS_CAPTURE_REPLAY_KHR: Self = Self::DEVICE_ADDRESS_CAPTURE_REPLAY;
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        match bits {
            x if x == Self::SPARSE_BINDING.bits() => Some(Self(x)),
            x if x == Self::SPARSE_RESIDENCY.bits() => Some(Self(x)),
            x if x == Self::SPARSE_ALIASED.bits() => Some(Self(x)),
            x if x == Self::PROTECTED.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::DEVICE_ADDRESS_CAPTURE_REPLAY.bits() => Some(Self(x)),
            #[cfg(feature = "VK_AMD_extension_317")]
            x if x == Self::RESERVED5_AMD.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for BufferCreateFlagBits {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for BufferCreateFlagBits {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkShaderStageFlagBits")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct ShaderStageFlagBits(u32);
impl Default for ShaderStageFlagBits {
    #[inline]
    fn default() -> Self {
        Self::empty()
    }
}
impl ShaderStageFlagBits {
    #[doc(alias = "VK_SHADER_STAGE_VERTEX_BIT")]
    pub const VERTEX: Self = Self(1);
    #[doc(alias = "VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT")]
    pub const TESSELLATION_CONTROL: Self = Self(2);
    #[doc(alias = "VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT")]
    pub const TESSELLATION_EVALUATION: Self = Self(4);
    #[doc(alias = "VK_SHADER_STAGE_GEOMETRY_BIT")]
    pub const GEOMETRY: Self = Self(8);
    #[doc(alias = "VK_SHADER_STAGE_FRAGMENT_BIT")]
    pub const FRAGMENT: Self = Self(16);
    #[doc(alias = "VK_SHADER_STAGE_COMPUTE_BIT")]
    pub const COMPUTE: Self = Self(32);
    #[doc(alias = "VK_SHADER_STAGE_ALL_GRAPHICS")]
    pub const ALL_GRAPHICS: Self = Self(31);
    #[doc(alias = "VK_SHADER_STAGE_ALL")]
    pub const ALL: Self = Self(2147483647);
    #[doc(alias = "VK_SHADER_STAGE_RAYGEN_BIT_KHR")]
    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
    pub const RAYGEN_KHR: Self = Self(256);
    #[doc(alias = "VK_SHADER_STAGE_ANY_HIT_BIT_KHR")]
    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
    pub const ANY_HIT_KHR: Self = Self(512);
    #[doc(alias = "VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR")]
    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
    pub const CLOSEST_HIT_KHR: Self = Self(1024);
    #[doc(alias = "VK_SHADER_STAGE_MISS_BIT_KHR")]
    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
    pub const MISS_KHR: Self = Self(2048);
    #[doc(alias = "VK_SHADER_STAGE_INTERSECTION_BIT_KHR")]
    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
    pub const INTERSECTION_KHR: Self = Self(4096);
    #[doc(alias = "VK_SHADER_STAGE_CALLABLE_BIT_KHR")]
    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
    pub const CALLABLE_KHR: Self = Self(8192);
    #[doc(alias = "VK_SHADER_STAGE_TASK_BIT_NV")]
    #[cfg(feature = "VK_NV_mesh_shader")]
    pub const TASK_NV: Self = Self(64);
    #[doc(alias = "VK_SHADER_STAGE_MESH_BIT_NV")]
    #[cfg(feature = "VK_NV_mesh_shader")]
    pub const MESH_NV: Self = Self(128);
    #[doc(alias = "VK_SHADER_STAGE_SUBPASS_SHADING_BIT_HUAWEI")]
    #[cfg(feature = "VK_HUAWEI_subpass_shading")]
    pub const SUBPASS_SHADING_HUAWEI: Self = Self(16384);
    #[doc(alias = "VK_SHADER_STAGE_RAYGEN_BIT_NV")]
    #[cfg(feature = "VK_NV_ray_tracing")]
    pub const RAYGEN_NV: Self = Self::RAYGEN_KHR;
    #[doc(alias = "VK_SHADER_STAGE_ANY_HIT_BIT_NV")]
    #[cfg(feature = "VK_NV_ray_tracing")]
    pub const ANY_HIT_NV: Self = Self::ANY_HIT_KHR;
    #[doc(alias = "VK_SHADER_STAGE_CLOSEST_HIT_BIT_NV")]
    #[cfg(feature = "VK_NV_ray_tracing")]
    pub const CLOSEST_HIT_NV: Self = Self::CLOSEST_HIT_KHR;
    #[doc(alias = "VK_SHADER_STAGE_MISS_BIT_NV")]
    #[cfg(feature = "VK_NV_ray_tracing")]
    pub const MISS_NV: Self = Self::MISS_KHR;
    #[doc(alias = "VK_SHADER_STAGE_INTERSECTION_BIT_NV")]
    #[cfg(feature = "VK_NV_ray_tracing")]
    pub const INTERSECTION_NV: Self = Self::INTERSECTION_KHR;
    #[doc(alias = "VK_SHADER_STAGE_CALLABLE_BIT_NV")]
    #[cfg(feature = "VK_NV_ray_tracing")]
    pub const CALLABLE_NV: Self = Self::CALLABLE_KHR;
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        match bits {
            x if x == Self::VERTEX.bits() => Some(Self(x)),
            x if x == Self::TESSELLATION_CONTROL.bits() => Some(Self(x)),
            x if x == Self::TESSELLATION_EVALUATION.bits() => Some(Self(x)),
            x if x == Self::GEOMETRY.bits() => Some(Self(x)),
            x if x == Self::FRAGMENT.bits() => Some(Self(x)),
            x if x == Self::COMPUTE.bits() => Some(Self(x)),
            x if x == Self::ALL_GRAPHICS.bits() => Some(Self(x)),
            x if x == Self::ALL.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
            x if x == Self::RAYGEN_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
            x if x == Self::ANY_HIT_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
            x if x == Self::CLOSEST_HIT_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
            x if x == Self::MISS_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
            x if x == Self::INTERSECTION_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
            x if x == Self::CALLABLE_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_mesh_shader")]
            x if x == Self::TASK_NV.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_mesh_shader")]
            x if x == Self::MESH_NV.bits() => Some(Self(x)),
            #[cfg(feature = "VK_HUAWEI_subpass_shading")]
            x if x == Self::SUBPASS_SHADING_HUAWEI.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for ShaderStageFlagBits {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for ShaderStageFlagBits {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkImageUsageFlagBits")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct ImageUsageFlagBits(u32);
impl Default for ImageUsageFlagBits {
    #[inline]
    fn default() -> Self {
        Self::empty()
    }
}
impl ImageUsageFlagBits {
    #[doc(alias = "VK_IMAGE_USAGE_TRANSFER_SRC_BIT")]
    pub const TRANSFER_SRC: Self = Self(1);
    #[doc(alias = "VK_IMAGE_USAGE_TRANSFER_DST_BIT")]
    pub const TRANSFER_DST: Self = Self(2);
    #[doc(alias = "VK_IMAGE_USAGE_SAMPLED_BIT")]
    pub const SAMPLED: Self = Self(4);
    #[doc(alias = "VK_IMAGE_USAGE_STORAGE_BIT")]
    pub const STORAGE: Self = Self(8);
    #[doc(alias = "VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT")]
    pub const COLOR_ATTACHMENT: Self = Self(16);
    #[doc(alias = "VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT")]
    pub const DEPTH_STENCIL_ATTACHMENT: Self = Self(32);
    #[doc(alias = "VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT")]
    pub const TRANSIENT_ATTACHMENT: Self = Self(64);
    #[doc(alias = "VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT")]
    pub const INPUT_ATTACHMENT: Self = Self(128);
    #[doc(alias = "VK_IMAGE_USAGE_VIDEO_DECODE_DST_BIT_KHR")]
    #[cfg(feature = "VK_KHR_video_decode_queue")]
    pub const VIDEO_DECODE_DST_KHR: Self = Self(1024);
    #[doc(alias = "VK_IMAGE_USAGE_VIDEO_DECODE_SRC_BIT_KHR")]
    #[cfg(feature = "VK_KHR_video_decode_queue")]
    pub const VIDEO_DECODE_SRC_KHR: Self = Self(2048);
    #[doc(alias = "VK_IMAGE_USAGE_VIDEO_DECODE_DPB_BIT_KHR")]
    #[cfg(feature = "VK_KHR_video_decode_queue")]
    pub const VIDEO_DECODE_DPB_KHR: Self = Self(4096);
    #[doc(alias = "VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT")]
    #[cfg(feature = "VK_EXT_fragment_density_map")]
    pub const FRAGMENT_DENSITY_MAP_EXT: Self = Self(512);
    #[doc(alias = "VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR")]
    #[cfg(feature = "VK_KHR_fragment_shading_rate")]
    pub const FRAGMENT_SHADING_RATE_ATTACHMENT_KHR: Self = Self(256);
    #[doc(alias = "VK_IMAGE_USAGE_VIDEO_ENCODE_DST_BIT_KHR")]
    #[cfg(feature = "VK_KHR_video_encode_queue")]
    pub const VIDEO_ENCODE_DST_KHR: Self = Self(8192);
    #[doc(alias = "VK_IMAGE_USAGE_VIDEO_ENCODE_SRC_BIT_KHR")]
    #[cfg(feature = "VK_KHR_video_encode_queue")]
    pub const VIDEO_ENCODE_SRC_KHR: Self = Self(16384);
    #[doc(alias = "VK_IMAGE_USAGE_VIDEO_ENCODE_DPB_BIT_KHR")]
    #[cfg(feature = "VK_KHR_video_encode_queue")]
    pub const VIDEO_ENCODE_DPB_KHR: Self = Self(32768);
    #[doc(alias = "VK_IMAGE_USAGE_INVOCATION_MASK_BIT_HUAWEI")]
    #[cfg(feature = "VK_HUAWEI_invocation_mask")]
    pub const INVOCATION_MASK_HUAWEI: Self = Self(262144);
    #[doc(alias = "VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV")]
    #[cfg(feature = "VK_NV_shading_rate_image")]
    pub const SHADING_RATE_IMAGE_NV: Self = Self::FRAGMENT_SHADING_RATE_ATTACHMENT_KHR;
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        match bits {
            x if x == Self::TRANSFER_SRC.bits() => Some(Self(x)),
            x if x == Self::TRANSFER_DST.bits() => Some(Self(x)),
            x if x == Self::SAMPLED.bits() => Some(Self(x)),
            x if x == Self::STORAGE.bits() => Some(Self(x)),
            x if x == Self::COLOR_ATTACHMENT.bits() => Some(Self(x)),
            x if x == Self::DEPTH_STENCIL_ATTACHMENT.bits() => Some(Self(x)),
            x if x == Self::TRANSIENT_ATTACHMENT.bits() => Some(Self(x)),
            x if x == Self::INPUT_ATTACHMENT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_video_decode_queue")]
            x if x == Self::VIDEO_DECODE_DST_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_video_decode_queue")]
            x if x == Self::VIDEO_DECODE_SRC_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_video_decode_queue")]
            x if x == Self::VIDEO_DECODE_DPB_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_QCOM_extension_173")]
            x if x == Self::RESERVED16_QCOM.bits() => Some(Self(x)),
            #[cfg(feature = "VK_QCOM_extension_173")]
            x if x == Self::RESERVED17_QCOM.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_fragment_density_map")]
            x if x == Self::FRAGMENT_DENSITY_MAP_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_fragment_shading_rate")]
            x if x == Self::FRAGMENT_SHADING_RATE_ATTACHMENT_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_INTEL_extension_271")]
            x if x == Self::RESERVED22_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_video_encode_queue")]
            x if x == Self::VIDEO_ENCODE_DST_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_video_encode_queue")]
            x if x == Self::VIDEO_ENCODE_SRC_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_video_encode_queue")]
            x if x == Self::VIDEO_ENCODE_DPB_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_extension_340")]
            x if x == Self::RESERVED19_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_HUAWEI_invocation_mask")]
            x if x == Self::INVOCATION_MASK_HUAWEI.bits() => Some(Self(x)),
            #[cfg(feature = "VK_QCOM_extension_441")]
            x if x == Self::RESERVED20_QCOM.bits() => Some(Self(x)),
            #[cfg(feature = "VK_QCOM_extension_441")]
            x if x == Self::RESERVED21_QCOM.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for ImageUsageFlagBits {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for ImageUsageFlagBits {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkImageCreateFlagBits")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct ImageCreateFlagBits(u32);
impl Default for ImageCreateFlagBits {
    #[inline]
    fn default() -> Self {
        Self::empty()
    }
}
impl ImageCreateFlagBits {
    #[doc(alias = "VK_IMAGE_CREATE_SPARSE_BINDING_BIT")]
    pub const SPARSE_BINDING: Self = Self(1);
    #[doc(alias = "VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT")]
    pub const SPARSE_RESIDENCY: Self = Self(2);
    #[doc(alias = "VK_IMAGE_CREATE_SPARSE_ALIASED_BIT")]
    pub const SPARSE_ALIASED: Self = Self(4);
    #[doc(alias = "VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT")]
    pub const MUTABLE_FORMAT: Self = Self(8);
    #[doc(alias = "VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT")]
    pub const CUBE_COMPATIBLE: Self = Self(16);
    #[doc(alias = "VK_IMAGE_CREATE_ALIAS_BIT")]
    pub const ALIAS: Self = Self(1024);
    #[doc(alias = "VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT")]
    pub const SPLIT_INSTANCE_BIND_REGIONS: Self = Self(64);
    #[doc(alias = "VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT")]
    pub const N2D_ARRAY_COMPATIBLE: Self = Self(32);
    #[doc(alias = "VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT")]
    pub const BLOCK_TEXEL_VIEW_COMPATIBLE: Self = Self(128);
    #[doc(alias = "VK_IMAGE_CREATE_EXTENDED_USAGE_BIT")]
    pub const EXTENDED_USAGE: Self = Self(256);
    #[doc(alias = "VK_IMAGE_CREATE_PROTECTED_BIT")]
    pub const PROTECTED: Self = Self(2048);
    #[doc(alias = "VK_IMAGE_CREATE_DISJOINT_BIT")]
    pub const DISJOINT: Self = Self(512);
    #[doc(alias = "VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV")]
    #[cfg(feature = "VK_NV_corner_sampled_image")]
    pub const CORNER_SAMPLED_NV: Self = Self(8192);
    #[doc(alias = "VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT")]
    #[cfg(feature = "VK_EXT_sample_locations")]
    pub const SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_EXT: Self = Self(4096);
    #[doc(alias = "VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT")]
    #[cfg(feature = "VK_EXT_fragment_density_map")]
    pub const SUBSAMPLED_EXT: Self = Self(16384);
    #[doc(alias = "VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR")]
    #[cfg(feature = "VK_KHR_device_group")]
    pub const SPLIT_INSTANCE_BIND_REGIONS_KHR: Self = Self::SPLIT_INSTANCE_BIND_REGIONS;
    #[doc(alias = "VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT_KHR")]
    #[cfg(feature = "VK_KHR_maintenance1")]
    pub const N2D_ARRAY_COMPATIBLE_KHR: Self = Self::N2D_ARRAY_COMPATIBLE;
    #[doc(alias = "VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT_KHR")]
    #[cfg(feature = "VK_KHR_maintenance2")]
    pub const BLOCK_TEXEL_VIEW_COMPATIBLE_KHR: Self = Self::BLOCK_TEXEL_VIEW_COMPATIBLE;
    #[doc(alias = "VK_IMAGE_CREATE_EXTENDED_USAGE_BIT_KHR")]
    #[cfg(feature = "VK_KHR_maintenance2")]
    pub const EXTENDED_USAGE_KHR: Self = Self::EXTENDED_USAGE;
    #[doc(alias = "VK_IMAGE_CREATE_DISJOINT_BIT_KHR")]
    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
    pub const DISJOINT_KHR: Self = Self::DISJOINT;
    #[doc(alias = "VK_IMAGE_CREATE_ALIAS_BIT_KHR")]
    #[cfg(feature = "VK_KHR_bind_memory2")]
    pub const ALIAS_KHR: Self = Self::ALIAS;
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        match bits {
            x if x == Self::SPARSE_BINDING.bits() => Some(Self(x)),
            x if x == Self::SPARSE_RESIDENCY.bits() => Some(Self(x)),
            x if x == Self::SPARSE_ALIASED.bits() => Some(Self(x)),
            x if x == Self::MUTABLE_FORMAT.bits() => Some(Self(x)),
            x if x == Self::CUBE_COMPATIBLE.bits() => Some(Self(x)),
            x if x == Self::ALIAS.bits() => Some(Self(x)),
            x if x == Self::SPLIT_INSTANCE_BIND_REGIONS.bits() => Some(Self(x)),
            x if x == Self::N2D_ARRAY_COMPATIBLE.bits() => Some(Self(x)),
            x if x == Self::BLOCK_TEXEL_VIEW_COMPATIBLE.bits() => Some(Self(x)),
            x if x == Self::EXTENDED_USAGE.bits() => Some(Self(x)),
            x if x == Self::PROTECTED.bits() => Some(Self(x)),
            x if x == Self::DISJOINT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_corner_sampled_image")]
            x if x == Self::CORNER_SAMPLED_NV.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_sample_locations")]
            x if x == Self::SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_fragment_density_map")]
            x if x == Self::SUBSAMPLED_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_AMD_extension_317")]
            x if x == Self::RESERVED16_AMD.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_extension_377")]
            x if x == Self::RESERVED18_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_extension_394")]
            x if x == Self::RESERVED394_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_QCOM_fragment_density_map_offset")]
            x if x == Self::FRAGMENT_DENSITY_MAP_OFFSET_QCOM.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for ImageCreateFlagBits {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for ImageCreateFlagBits {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkImageViewCreateFlagBits")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct ImageViewCreateFlagBits(u32);
impl Default for ImageViewCreateFlagBits {
    #[inline]
    fn default() -> Self {
        Self::empty()
    }
}
impl ImageViewCreateFlagBits {
    #[doc(alias = "VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT")]
    #[cfg(feature = "VK_EXT_fragment_density_map")]
    pub const FRAGMENT_DENSITY_MAP_DYNAMIC_EXT: Self = Self(1);
    #[doc(alias = "VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DEFERRED_BIT_EXT")]
    #[cfg(feature = "VK_EXT_fragment_density_map2")]
    pub const FRAGMENT_DENSITY_MAP_DEFERRED_EXT: Self = Self(2);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        match bits {
            #[cfg(feature = "VK_EXT_fragment_density_map")]
            x if x == Self::FRAGMENT_DENSITY_MAP_DYNAMIC_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_AMD_extension_317")]
            x if x == Self::RESERVED2_AMD.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_fragment_density_map2")]
            x if x == Self::FRAGMENT_DENSITY_MAP_DEFERRED_EXT.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for ImageViewCreateFlagBits {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for ImageViewCreateFlagBits {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkSamplerCreateFlagBits")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct SamplerCreateFlagBits(u32);
impl Default for SamplerCreateFlagBits {
    #[inline]
    fn default() -> Self {
        Self::empty()
    }
}
impl SamplerCreateFlagBits {
    #[doc(alias = "VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT")]
    #[cfg(feature = "VK_EXT_fragment_density_map")]
    pub const SUBSAMPLED_EXT: Self = Self(1);
    #[doc(alias = "VK_SAMPLER_CREATE_SUBSAMPLED_COARSE_RECONSTRUCTION_BIT_EXT")]
    #[cfg(feature = "VK_EXT_fragment_density_map")]
    pub const SUBSAMPLED_COARSE_RECONSTRUCTION_EXT: Self = Self(2);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        match bits {
            #[cfg(feature = "VK_EXT_fragment_density_map")]
            x if x == Self::SUBSAMPLED_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_fragment_density_map")]
            x if x == Self::SUBSAMPLED_COARSE_RECONSTRUCTION_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_AMD_extension_317")]
            x if x == Self::RESERVED3_AMD.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_disable_cube_map_wrap")]
            x if x == Self::RESERVED2_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_QCOM_extension_441")]
            x if x == Self::IMAGE_PROCESSING_QCOM.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for SamplerCreateFlagBits {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for SamplerCreateFlagBits {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkPipelineCreateFlagBits")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct PipelineCreateFlagBits(u32);
impl Default for PipelineCreateFlagBits {
    #[inline]
    fn default() -> Self {
        Self::empty()
    }
}
impl PipelineCreateFlagBits {
    #[doc(alias = "VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT")]
    pub const DISABLE_OPTIMIZATION: Self = Self(1);
    #[doc(alias = "VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT")]
    pub const ALLOW_DERIVATIVES: Self = Self(2);
    #[doc(alias = "VK_PIPELINE_CREATE_DERIVATIVE_BIT")]
    pub const DERIVATIVE: Self = Self(4);
    #[doc(alias = "VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT")]
    pub const VIEW_INDEX_FROM_DEVICE_INDEX: Self = Self(8);
    #[doc(alias = "VK_PIPELINE_CREATE_DISPATCH_BASE_BIT")]
    pub const DISPATCH_BASE: Self = Self(16);
    #[doc(alias = "VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const FAIL_ON_PIPELINE_COMPILE_REQUIRED: Self = Self(256);
    #[doc(alias = "VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const EARLY_RETURN_ON_FAILURE: Self = Self(512);
    #[doc(alias = "VK_PIPELINE_CREATE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR")]
    #[cfg(feature = "VK_KHR_dynamic_rendering")]
    pub const RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_KHR: Self = Self(2097152);
    #[doc(alias = "VK_PIPELINE_CREATE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT")]
    #[cfg(feature = "VK_KHR_dynamic_rendering")]
    pub const RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_EXT: Self = Self(4194304);
    #[doc(alias = "VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR")]
    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
    pub const RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_KHR: Self = Self(16384);
    #[doc(alias = "VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR")]
    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
    pub const RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_KHR: Self = Self(32768);
    #[doc(alias = "VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR")]
    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
    pub const RAY_TRACING_NO_NULL_MISS_SHADERS_KHR: Self = Self(65536);
    #[doc(alias = "VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR")]
    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
    pub const RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_KHR: Self = Self(131072);
    #[doc(alias = "VK_PIPELINE_CREATE_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR")]
    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
    pub const RAY_TRACING_SKIP_TRIANGLES_KHR: Self = Self(4096);
    #[doc(alias = "VK_PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR")]
    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
    pub const RAY_TRACING_SKIP_AABBS_KHR: Self = Self(8192);
    #[doc(alias = "VK_PIPELINE_CREATE_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR")]
    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
    pub const RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_KHR: Self = Self(524288);
    #[doc(alias = "VK_PIPELINE_CREATE_DEFER_COMPILE_BIT_NV")]
    #[cfg(feature = "VK_NV_ray_tracing")]
    pub const DEFER_COMPILE_NV: Self = Self(32);
    #[doc(alias = "VK_PIPELINE_CREATE_CAPTURE_STATISTICS_BIT_KHR")]
    #[cfg(feature = "VK_KHR_pipeline_executable_properties")]
    pub const CAPTURE_STATISTICS_KHR: Self = Self(64);
    #[doc(alias = "VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR")]
    #[cfg(feature = "VK_KHR_pipeline_executable_properties")]
    pub const CAPTURE_INTERNAL_REPRESENTATIONS_KHR: Self = Self(128);
    #[doc(alias = "VK_PIPELINE_CREATE_INDIRECT_BINDABLE_BIT_NV")]
    #[cfg(feature = "VK_NV_device_generated_commands")]
    pub const INDIRECT_BINDABLE_NV: Self = Self(262144);
    #[doc(alias = "VK_PIPELINE_CREATE_LIBRARY_BIT_KHR")]
    #[cfg(feature = "VK_KHR_pipeline_library")]
    pub const LIBRARY_KHR: Self = Self(2048);
    #[doc(alias = "VK_PIPELINE_CREATE_RAY_TRACING_ALLOW_MOTION_BIT_NV")]
    #[cfg(feature = "VK_NV_ray_tracing_motion_blur")]
    pub const RAY_TRACING_ALLOW_MOTION_NV: Self = Self(1048576);
    #[doc(alias = "VK_PIPELINE_CREATE_DISPATCH_BASE")]
    pub const DISPATCH_BASE_DUP: Self = Self::DISPATCH_BASE;
    #[doc(alias = "VK_PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR")]
    #[cfg(feature = "VK_KHR_dynamic_rendering")]
    pub const PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_SHADING_RATE_ATTACHMENT_KHR: Self =
        Self::RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_KHR;
    #[doc(alias = "VK_PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT")]
    #[cfg(feature = "VK_KHR_dynamic_rendering")]
    pub const PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_DENSITY_MAP_ATTACHMENT_EXT: Self =
        Self::RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_EXT;
    #[doc(alias = "VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR")]
    #[cfg(feature = "VK_KHR_device_group")]
    pub const VIEW_INDEX_FROM_DEVICE_INDEX_KHR: Self = Self::VIEW_INDEX_FROM_DEVICE_INDEX;
    #[doc(alias = "VK_PIPELINE_CREATE_DISPATCH_BASE_KHR")]
    #[cfg(feature = "VK_KHR_device_group")]
    pub const DISPATCH_BASE_KHR: Self = Self::DISPATCH_BASE_DUP;
    #[doc(alias = "VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT_EXT")]
    #[cfg(feature = "VK_EXT_pipeline_creation_cache_control")]
    pub const FAIL_ON_PIPELINE_COMPILE_REQUIRED_EXT: Self = Self::FAIL_ON_PIPELINE_COMPILE_REQUIRED;
    #[doc(alias = "VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT_EXT")]
    #[cfg(feature = "VK_EXT_pipeline_creation_cache_control")]
    pub const EARLY_RETURN_ON_FAILURE_EXT: Self = Self::EARLY_RETURN_ON_FAILURE;
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        match bits {
            x if x == Self::DISABLE_OPTIMIZATION.bits() => Some(Self(x)),
            x if x == Self::ALLOW_DERIVATIVES.bits() => Some(Self(x)),
            x if x == Self::DERIVATIVE.bits() => Some(Self(x)),
            x if x == Self::VIEW_INDEX_FROM_DEVICE_INDEX.bits() => Some(Self(x)),
            x if x == Self::DISPATCH_BASE.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::FAIL_ON_PIPELINE_COMPILE_REQUIRED.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::EARLY_RETURN_ON_FAILURE.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_dynamic_rendering")]
            x if x == Self::RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_dynamic_rendering")]
            x if x == Self::RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
            x if x == Self::RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
            x if x == Self::RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
            x if x == Self::RAY_TRACING_NO_NULL_MISS_SHADERS_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
            x if x == Self::RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
            x if x == Self::RAY_TRACING_SKIP_TRIANGLES_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
            x if x == Self::RAY_TRACING_SKIP_AABBS_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
            x if x == Self::RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_ray_tracing")]
            x if x == Self::DEFER_COMPILE_NV.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_pipeline_executable_properties")]
            x if x == Self::CAPTURE_STATISTICS_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_pipeline_executable_properties")]
            x if x == Self::CAPTURE_INTERNAL_REPRESENTATIONS_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_device_generated_commands")]
            x if x == Self::INDIRECT_BINDABLE_NV.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_pipeline_library")]
            x if x == Self::LIBRARY_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_AMD_extension_321")]
            x if x == Self::RESERVED23_AMD.bits() => Some(Self(x)),
            #[cfg(feature = "VK_AMD_extension_321")]
            x if x == Self::RESERVED10_AMD.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_ray_tracing_motion_blur")]
            x if x == Self::RAY_TRACING_ALLOW_MOTION_NV.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for PipelineCreateFlagBits {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for PipelineCreateFlagBits {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkPipelineShaderStageCreateFlagBits")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct PipelineShaderStageCreateFlagBits(u32);
impl Default for PipelineShaderStageCreateFlagBits {
    #[inline]
    fn default() -> Self {
        Self::empty()
    }
}
impl PipelineShaderStageCreateFlagBits {
    #[doc(alias = "VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const ALLOW_VARYING_SUBGROUP_SIZE: Self = Self(1);
    #[doc(alias = "VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const REQUIRE_FULL_SUBGROUPS: Self = Self(2);
    #[doc(alias = "VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT")]
    #[cfg(feature = "VK_EXT_subgroup_size_control")]
    pub const ALLOW_VARYING_SUBGROUP_SIZE_EXT: Self = Self::ALLOW_VARYING_SUBGROUP_SIZE;
    #[doc(alias = "VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT")]
    #[cfg(feature = "VK_EXT_subgroup_size_control")]
    pub const REQUIRE_FULL_SUBGROUPS_EXT: Self = Self::REQUIRE_FULL_SUBGROUPS;
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        match bits {
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::ALLOW_VARYING_SUBGROUP_SIZE.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::REQUIRE_FULL_SUBGROUPS.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_extension_52")]
            x if x == Self::RESERVED2_NV.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_extension_297")]
            x if x == Self::RESERVED3_KHR.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for PipelineShaderStageCreateFlagBits {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for PipelineShaderStageCreateFlagBits {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkColorComponentFlagBits")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct ColorComponentFlagBits(u32);
impl Default for ColorComponentFlagBits {
    #[inline]
    fn default() -> Self {
        Self::empty()
    }
}
impl ColorComponentFlagBits {
    #[doc(alias = "VK_COLOR_COMPONENT_R_BIT")]
    pub const R: Self = Self(1);
    #[doc(alias = "VK_COLOR_COMPONENT_G_BIT")]
    pub const G: Self = Self(2);
    #[doc(alias = "VK_COLOR_COMPONENT_B_BIT")]
    pub const B: Self = Self(4);
    #[doc(alias = "VK_COLOR_COMPONENT_A_BIT")]
    pub const A: Self = Self(8);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        match bits {
            x if x == Self::R.bits() => Some(Self(x)),
            x if x == Self::G.bits() => Some(Self(x)),
            x if x == Self::B.bits() => Some(Self(x)),
            x if x == Self::A.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for ColorComponentFlagBits {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for ColorComponentFlagBits {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkFenceCreateFlagBits")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct FenceCreateFlagBits(u32);
impl Default for FenceCreateFlagBits {
    #[inline]
    fn default() -> Self {
        Self::empty()
    }
}
impl FenceCreateFlagBits {
    #[doc(alias = "VK_FENCE_CREATE_SIGNALED_BIT")]
    pub const SIGNALED: Self = Self(1);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        match bits {
            x if x == Self::SIGNALED.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for FenceCreateFlagBits {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for FenceCreateFlagBits {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkFormatFeatureFlagBits")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct FormatFeatureFlagBits(u32);
impl Default for FormatFeatureFlagBits {
    #[inline]
    fn default() -> Self {
        Self::empty()
    }
}
impl FormatFeatureFlagBits {
    #[doc(alias = "VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT")]
    pub const SAMPLED_IMAGE: Self = Self(1);
    #[doc(alias = "VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT")]
    pub const STORAGE_IMAGE: Self = Self(2);
    #[doc(alias = "VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT")]
    pub const STORAGE_IMAGE_ATOMIC: Self = Self(4);
    #[doc(alias = "VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT")]
    pub const UNIFORM_TEXEL_BUFFER: Self = Self(8);
    #[doc(alias = "VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT")]
    pub const STORAGE_TEXEL_BUFFER: Self = Self(16);
    #[doc(alias = "VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT")]
    pub const STORAGE_TEXEL_BUFFER_ATOMIC: Self = Self(32);
    #[doc(alias = "VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT")]
    pub const VERTEX_BUFFER: Self = Self(64);
    #[doc(alias = "VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT")]
    pub const COLOR_ATTACHMENT: Self = Self(128);
    #[doc(alias = "VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT")]
    pub const COLOR_ATTACHMENT_BLEND: Self = Self(256);
    #[doc(alias = "VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT")]
    pub const DEPTH_STENCIL_ATTACHMENT: Self = Self(512);
    #[doc(alias = "VK_FORMAT_FEATURE_BLIT_SRC_BIT")]
    pub const BLIT_SRC: Self = Self(1024);
    #[doc(alias = "VK_FORMAT_FEATURE_BLIT_DST_BIT")]
    pub const BLIT_DST: Self = Self(2048);
    #[doc(alias = "VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT")]
    pub const SAMPLED_IMAGE_FILTER_LINEAR: Self = Self(4096);
    #[doc(alias = "VK_FORMAT_FEATURE_TRANSFER_SRC_BIT")]
    pub const TRANSFER_SRC: Self = Self(16384);
    #[doc(alias = "VK_FORMAT_FEATURE_TRANSFER_DST_BIT")]
    pub const TRANSFER_DST: Self = Self(32768);
    #[doc(alias = "VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT")]
    pub const MIDPOINT_CHROMA_SAMPLES: Self = Self(131072);
    #[doc(alias = "VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT")]
    pub const SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER: Self = Self(262144);
    #[doc(alias = "VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT")]
    pub const SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER: Self = Self(524288);
    #[doc(alias = "VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT")]
    pub const SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT: Self = Self(1048576);
    #[doc(alias = "VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT")]
    pub const SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE: Self = Self(2097152);
    #[doc(alias = "VK_FORMAT_FEATURE_DISJOINT_BIT")]
    pub const DISJOINT: Self = Self(4194304);
    #[doc(alias = "VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT")]
    pub const COSITED_CHROMA_SAMPLES: Self = Self(8388608);
    #[doc(alias = "VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT")]
    #[cfg(feature = "VULKAN_1_2")]
    pub const SAMPLED_IMAGE_FILTER_MINMAX: Self = Self(65536);
    #[doc(alias = "VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG")]
    #[cfg(feature = "VK_IMG_filter_cubic")]
    pub const SAMPLED_IMAGE_FILTER_CUBIC_IMG: Self = Self(8192);
    #[doc(alias = "VK_FORMAT_FEATURE_VIDEO_DECODE_OUTPUT_BIT_KHR")]
    #[cfg(feature = "VK_KHR_video_decode_queue")]
    pub const VIDEO_DECODE_OUTPUT_KHR: Self = Self(33554432);
    #[doc(alias = "VK_FORMAT_FEATURE_VIDEO_DECODE_DPB_BIT_KHR")]
    #[cfg(feature = "VK_KHR_video_decode_queue")]
    pub const VIDEO_DECODE_DPB_KHR: Self = Self(67108864);
    #[doc(alias = "VK_FORMAT_FEATURE_ACCELERATION_STRUCTURE_VERTEX_BUFFER_BIT_KHR")]
    #[cfg(feature = "VK_KHR_acceleration_structure")]
    pub const ACCELERATION_STRUCTURE_VERTEX_BUFFER_KHR: Self = Self(536870912);
    #[doc(alias = "VK_FORMAT_FEATURE_FRAGMENT_DENSITY_MAP_BIT_EXT")]
    #[cfg(feature = "VK_EXT_fragment_density_map")]
    pub const FRAGMENT_DENSITY_MAP_EXT: Self = Self(16777216);
    #[doc(alias = "VK_FORMAT_FEATURE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR")]
    #[cfg(feature = "VK_KHR_fragment_shading_rate")]
    pub const FRAGMENT_SHADING_RATE_ATTACHMENT_KHR: Self = Self(1073741824);
    #[doc(alias = "VK_FORMAT_FEATURE_VIDEO_ENCODE_INPUT_BIT_KHR")]
    #[cfg(feature = "VK_KHR_video_encode_queue")]
    pub const VIDEO_ENCODE_INPUT_KHR: Self = Self(134217728);
    #[doc(alias = "VK_FORMAT_FEATURE_VIDEO_ENCODE_DPB_BIT_KHR")]
    #[cfg(feature = "VK_KHR_video_encode_queue")]
    pub const VIDEO_ENCODE_DPB_KHR: Self = Self(268435456);
    #[doc(alias = "VK_FORMAT_FEATURE_TRANSFER_SRC_BIT_KHR")]
    #[cfg(feature = "VK_KHR_maintenance1")]
    pub const TRANSFER_SRC_KHR: Self = Self::TRANSFER_SRC;
    #[doc(alias = "VK_FORMAT_FEATURE_TRANSFER_DST_BIT_KHR")]
    #[cfg(feature = "VK_KHR_maintenance1")]
    pub const TRANSFER_DST_KHR: Self = Self::TRANSFER_DST;
    #[doc(alias = "VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT")]
    #[cfg(feature = "VK_EXT_sampler_filter_minmax")]
    pub const SAMPLED_IMAGE_FILTER_MINMAX_EXT: Self = Self::SAMPLED_IMAGE_FILTER_MINMAX;
    #[doc(alias = "VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT_KHR")]
    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
    pub const MIDPOINT_CHROMA_SAMPLES_KHR: Self = Self::MIDPOINT_CHROMA_SAMPLES;
    #[doc(alias = "VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR")]
    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
    pub const SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_KHR: Self =
        Self::SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER;
    #[doc(alias = "VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR")]
    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
    pub const SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_KHR: Self =
        Self::SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER;
    #[doc(alias = "VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR")]
    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
    pub const SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_KHR: Self =
        Self::SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT;
    #[doc(alias = "VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR")]
    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
    pub const SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_KHR: Self =
        Self::SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE;
    #[doc(alias = "VK_FORMAT_FEATURE_DISJOINT_BIT_KHR")]
    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
    pub const DISJOINT_KHR: Self = Self::DISJOINT;
    #[doc(alias = "VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT_KHR")]
    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
    pub const COSITED_CHROMA_SAMPLES_KHR: Self = Self::COSITED_CHROMA_SAMPLES;
    #[doc(alias = "VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT")]
    #[cfg(feature = "VK_EXT_filter_cubic")]
    pub const SAMPLED_IMAGE_FILTER_CUBIC_EXT: Self = Self::SAMPLED_IMAGE_FILTER_CUBIC_IMG;
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        match bits {
            x if x == Self::SAMPLED_IMAGE.bits() => Some(Self(x)),
            x if x == Self::STORAGE_IMAGE.bits() => Some(Self(x)),
            x if x == Self::STORAGE_IMAGE_ATOMIC.bits() => Some(Self(x)),
            x if x == Self::UNIFORM_TEXEL_BUFFER.bits() => Some(Self(x)),
            x if x == Self::STORAGE_TEXEL_BUFFER.bits() => Some(Self(x)),
            x if x == Self::STORAGE_TEXEL_BUFFER_ATOMIC.bits() => Some(Self(x)),
            x if x == Self::VERTEX_BUFFER.bits() => Some(Self(x)),
            x if x == Self::COLOR_ATTACHMENT.bits() => Some(Self(x)),
            x if x == Self::COLOR_ATTACHMENT_BLEND.bits() => Some(Self(x)),
            x if x == Self::DEPTH_STENCIL_ATTACHMENT.bits() => Some(Self(x)),
            x if x == Self::BLIT_SRC.bits() => Some(Self(x)),
            x if x == Self::BLIT_DST.bits() => Some(Self(x)),
            x if x == Self::SAMPLED_IMAGE_FILTER_LINEAR.bits() => Some(Self(x)),
            x if x == Self::TRANSFER_SRC.bits() => Some(Self(x)),
            x if x == Self::TRANSFER_DST.bits() => Some(Self(x)),
            x if x == Self::MIDPOINT_CHROMA_SAMPLES.bits() => Some(Self(x)),
            x if x == Self::SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER.bits() => Some(Self(x)),
            x if x == Self::SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER.bits() => Some(Self(x)),
            x if x == Self::SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT.bits() => Some(Self(x)),
            x if x == Self::SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE.bits() => {
                Some(Self(x))
            },
            x if x == Self::DISJOINT.bits() => Some(Self(x)),
            x if x == Self::COSITED_CHROMA_SAMPLES.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::SAMPLED_IMAGE_FILTER_MINMAX.bits() => Some(Self(x)),
            #[cfg(feature = "VK_IMG_filter_cubic")]
            x if x == Self::SAMPLED_IMAGE_FILTER_CUBIC_IMG.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_video_decode_queue")]
            x if x == Self::VIDEO_DECODE_OUTPUT_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_video_decode_queue")]
            x if x == Self::VIDEO_DECODE_DPB_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_acceleration_structure")]
            x if x == Self::ACCELERATION_STRUCTURE_VERTEX_BUFFER_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_fragment_density_map")]
            x if x == Self::FRAGMENT_DENSITY_MAP_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_fragment_shading_rate")]
            x if x == Self::FRAGMENT_SHADING_RATE_ATTACHMENT_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_video_encode_queue")]
            x if x == Self::VIDEO_ENCODE_INPUT_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_video_encode_queue")]
            x if x == Self::VIDEO_ENCODE_DPB_KHR.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for FormatFeatureFlagBits {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for FormatFeatureFlagBits {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkQueryControlFlagBits")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct QueryControlFlagBits(u32);
impl Default for QueryControlFlagBits {
    #[inline]
    fn default() -> Self {
        Self::empty()
    }
}
impl QueryControlFlagBits {
    #[doc(alias = "VK_QUERY_CONTROL_PRECISE_BIT")]
    pub const PRECISE: Self = Self(1);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        match bits {
            x if x == Self::PRECISE.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for QueryControlFlagBits {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for QueryControlFlagBits {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkQueryResultFlagBits")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct QueryResultFlagBits(u32);
impl Default for QueryResultFlagBits {
    #[inline]
    fn default() -> Self {
        Self::empty()
    }
}
impl QueryResultFlagBits {
    #[doc(alias = "VK_QUERY_RESULT_64_BIT")]
    pub const N64: Self = Self(1);
    #[doc(alias = "VK_QUERY_RESULT_WAIT_BIT")]
    pub const WAIT: Self = Self(2);
    #[doc(alias = "VK_QUERY_RESULT_WITH_AVAILABILITY_BIT")]
    pub const WITH_AVAILABILITY: Self = Self(4);
    #[doc(alias = "VK_QUERY_RESULT_PARTIAL_BIT")]
    pub const PARTIAL: Self = Self(8);
    #[doc(alias = "VK_QUERY_RESULT_WITH_STATUS_BIT_KHR")]
    #[cfg(feature = "VK_KHR_video_queue")]
    pub const WITH_STATUS_KHR: Self = Self(16);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        match bits {
            x if x == Self::N64.bits() => Some(Self(x)),
            x if x == Self::WAIT.bits() => Some(Self(x)),
            x if x == Self::WITH_AVAILABILITY.bits() => Some(Self(x)),
            x if x == Self::PARTIAL.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_video_queue")]
            x if x == Self::WITH_STATUS_KHR.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for QueryResultFlagBits {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for QueryResultFlagBits {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkCommandBufferUsageFlagBits")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct CommandBufferUsageFlagBits(u32);
impl Default for CommandBufferUsageFlagBits {
    #[inline]
    fn default() -> Self {
        Self::empty()
    }
}
impl CommandBufferUsageFlagBits {
    #[doc(alias = "VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT")]
    pub const ONE_TIME_SUBMIT: Self = Self(1);
    #[doc(alias = "VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT")]
    pub const RENDER_PASS_CONTINUE: Self = Self(2);
    #[doc(alias = "VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT")]
    pub const SIMULTANEOUS_USE: Self = Self(4);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        match bits {
            x if x == Self::ONE_TIME_SUBMIT.bits() => Some(Self(x)),
            x if x == Self::RENDER_PASS_CONTINUE.bits() => Some(Self(x)),
            x if x == Self::SIMULTANEOUS_USE.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for CommandBufferUsageFlagBits {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for CommandBufferUsageFlagBits {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkQueryPipelineStatisticFlagBits")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct QueryPipelineStatisticFlagBits(u32);
impl Default for QueryPipelineStatisticFlagBits {
    #[inline]
    fn default() -> Self {
        Self::empty()
    }
}
impl QueryPipelineStatisticFlagBits {
    #[doc(alias = "VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT")]
    pub const INPUT_ASSEMBLY_VERTICES: Self = Self(1);
    #[doc(alias = "VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT")]
    pub const INPUT_ASSEMBLY_PRIMITIVES: Self = Self(2);
    #[doc(alias = "VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT")]
    pub const VERTEX_SHADER_INVOCATIONS: Self = Self(4);
    #[doc(alias = "VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT")]
    pub const GEOMETRY_SHADER_INVOCATIONS: Self = Self(8);
    #[doc(alias = "VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT")]
    pub const GEOMETRY_SHADER_PRIMITIVES: Self = Self(16);
    #[doc(alias = "VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT")]
    pub const CLIPPING_INVOCATIONS: Self = Self(32);
    #[doc(alias = "VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT")]
    pub const CLIPPING_PRIMITIVES: Self = Self(64);
    #[doc(alias = "VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT")]
    pub const FRAGMENT_SHADER_INVOCATIONS: Self = Self(128);
    #[doc(alias = "VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT")]
    pub const TESSELLATION_CONTROL_SHADER_PATCHES: Self = Self(256);
    #[doc(alias = "VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT")]
    pub const TESSELLATION_EVALUATION_SHADER_INVOCATIONS: Self = Self(512);
    #[doc(alias = "VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT")]
    pub const COMPUTE_SHADER_INVOCATIONS: Self = Self(1024);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        match bits {
            x if x == Self::INPUT_ASSEMBLY_VERTICES.bits() => Some(Self(x)),
            x if x == Self::INPUT_ASSEMBLY_PRIMITIVES.bits() => Some(Self(x)),
            x if x == Self::VERTEX_SHADER_INVOCATIONS.bits() => Some(Self(x)),
            x if x == Self::GEOMETRY_SHADER_INVOCATIONS.bits() => Some(Self(x)),
            x if x == Self::GEOMETRY_SHADER_PRIMITIVES.bits() => Some(Self(x)),
            x if x == Self::CLIPPING_INVOCATIONS.bits() => Some(Self(x)),
            x if x == Self::CLIPPING_PRIMITIVES.bits() => Some(Self(x)),
            x if x == Self::FRAGMENT_SHADER_INVOCATIONS.bits() => Some(Self(x)),
            x if x == Self::TESSELLATION_CONTROL_SHADER_PATCHES.bits() => Some(Self(x)),
            x if x == Self::TESSELLATION_EVALUATION_SHADER_INVOCATIONS.bits() => Some(Self(x)),
            x if x == Self::COMPUTE_SHADER_INVOCATIONS.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for QueryPipelineStatisticFlagBits {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for QueryPipelineStatisticFlagBits {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkImageAspectFlagBits")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct ImageAspectFlagBits(u32);
impl Default for ImageAspectFlagBits {
    #[inline]
    fn default() -> Self {
        Self::empty()
    }
}
impl ImageAspectFlagBits {
    #[doc(alias = "VK_IMAGE_ASPECT_COLOR_BIT")]
    pub const COLOR: Self = Self(1);
    #[doc(alias = "VK_IMAGE_ASPECT_DEPTH_BIT")]
    pub const DEPTH: Self = Self(2);
    #[doc(alias = "VK_IMAGE_ASPECT_STENCIL_BIT")]
    pub const STENCIL: Self = Self(4);
    #[doc(alias = "VK_IMAGE_ASPECT_METADATA_BIT")]
    pub const METADATA: Self = Self(8);
    #[doc(alias = "VK_IMAGE_ASPECT_PLANE_0_BIT")]
    pub const PLANE0: Self = Self(16);
    #[doc(alias = "VK_IMAGE_ASPECT_PLANE_1_BIT")]
    pub const PLANE1: Self = Self(32);
    #[doc(alias = "VK_IMAGE_ASPECT_PLANE_2_BIT")]
    pub const PLANE2: Self = Self(64);
    #[doc(alias = "VK_IMAGE_ASPECT_NONE")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const NONE: Self = Self(0);
    #[doc(alias = "VK_IMAGE_ASPECT_MEMORY_PLANE_0_BIT_EXT")]
    #[cfg(feature = "VK_EXT_image_drm_format_modifier")]
    pub const MEMORY_PLANE0_EXT: Self = Self(128);
    #[doc(alias = "VK_IMAGE_ASPECT_MEMORY_PLANE_1_BIT_EXT")]
    #[cfg(feature = "VK_EXT_image_drm_format_modifier")]
    pub const MEMORY_PLANE1_EXT: Self = Self(256);
    #[doc(alias = "VK_IMAGE_ASPECT_MEMORY_PLANE_2_BIT_EXT")]
    #[cfg(feature = "VK_EXT_image_drm_format_modifier")]
    pub const MEMORY_PLANE2_EXT: Self = Self(512);
    #[doc(alias = "VK_IMAGE_ASPECT_MEMORY_PLANE_3_BIT_EXT")]
    #[cfg(feature = "VK_EXT_image_drm_format_modifier")]
    pub const MEMORY_PLANE3_EXT: Self = Self(1024);
    #[doc(alias = "VK_IMAGE_ASPECT_PLANE_0_BIT_KHR")]
    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
    pub const PLANE0_KHR: Self = Self::PLANE0;
    #[doc(alias = "VK_IMAGE_ASPECT_PLANE_1_BIT_KHR")]
    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
    pub const PLANE1_KHR: Self = Self::PLANE1;
    #[doc(alias = "VK_IMAGE_ASPECT_PLANE_2_BIT_KHR")]
    #[cfg(feature = "VK_KHR_sampler_ycbcr_conversion")]
    pub const PLANE2_KHR: Self = Self::PLANE2;
    #[doc(alias = "VK_IMAGE_ASPECT_NONE_KHR")]
    #[cfg(feature = "VK_KHR_maintenance4")]
    pub const NONE_KHR: Self = Self::NONE;
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        match bits {
            x if x == Self::COLOR.bits() => Some(Self(x)),
            x if x == Self::DEPTH.bits() => Some(Self(x)),
            x if x == Self::STENCIL.bits() => Some(Self(x)),
            x if x == Self::METADATA.bits() => Some(Self(x)),
            x if x == Self::PLANE0.bits() => Some(Self(x)),
            x if x == Self::PLANE1.bits() => Some(Self(x)),
            x if x == Self::PLANE2.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::NONE.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_image_drm_format_modifier")]
            x if x == Self::MEMORY_PLANE0_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_image_drm_format_modifier")]
            x if x == Self::MEMORY_PLANE1_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_image_drm_format_modifier")]
            x if x == Self::MEMORY_PLANE2_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_image_drm_format_modifier")]
            x if x == Self::MEMORY_PLANE3_EXT.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for ImageAspectFlagBits {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for ImageAspectFlagBits {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkSparseImageFormatFlagBits")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct SparseImageFormatFlagBits(u32);
impl Default for SparseImageFormatFlagBits {
    #[inline]
    fn default() -> Self {
        Self::empty()
    }
}
impl SparseImageFormatFlagBits {
    #[doc(alias = "VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT")]
    pub const SINGLE_MIPTAIL: Self = Self(1);
    #[doc(alias = "VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT")]
    pub const ALIGNED_MIP_SIZE: Self = Self(2);
    #[doc(alias = "VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT")]
    pub const NONSTANDARD_BLOCK_SIZE: Self = Self(4);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        match bits {
            x if x == Self::SINGLE_MIPTAIL.bits() => Some(Self(x)),
            x if x == Self::ALIGNED_MIP_SIZE.bits() => Some(Self(x)),
            x if x == Self::NONSTANDARD_BLOCK_SIZE.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for SparseImageFormatFlagBits {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for SparseImageFormatFlagBits {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkSparseMemoryBindFlagBits")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct SparseMemoryBindFlagBits(u32);
impl Default for SparseMemoryBindFlagBits {
    #[inline]
    fn default() -> Self {
        Self::empty()
    }
}
impl SparseMemoryBindFlagBits {
    #[doc(alias = "VK_SPARSE_MEMORY_BIND_METADATA_BIT")]
    pub const METADATA: Self = Self(1);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        match bits {
            x if x == Self::METADATA.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for SparseMemoryBindFlagBits {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for SparseMemoryBindFlagBits {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkPipelineStageFlagBits")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct PipelineStageFlagBits(u32);
impl Default for PipelineStageFlagBits {
    #[inline]
    fn default() -> Self {
        Self::empty()
    }
}
impl PipelineStageFlagBits {
    #[doc(alias = "VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT")]
    pub const TOP_OF_PIPE: Self = Self(1);
    #[doc(alias = "VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT")]
    pub const DRAW_INDIRECT: Self = Self(2);
    #[doc(alias = "VK_PIPELINE_STAGE_VERTEX_INPUT_BIT")]
    pub const VERTEX_INPUT: Self = Self(4);
    #[doc(alias = "VK_PIPELINE_STAGE_VERTEX_SHADER_BIT")]
    pub const VERTEX_SHADER: Self = Self(8);
    #[doc(alias = "VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT")]
    pub const TESSELLATION_CONTROL_SHADER: Self = Self(16);
    #[doc(alias = "VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT")]
    pub const TESSELLATION_EVALUATION_SHADER: Self = Self(32);
    #[doc(alias = "VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT")]
    pub const GEOMETRY_SHADER: Self = Self(64);
    #[doc(alias = "VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT")]
    pub const FRAGMENT_SHADER: Self = Self(128);
    #[doc(alias = "VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT")]
    pub const EARLY_FRAGMENT_TESTS: Self = Self(256);
    #[doc(alias = "VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT")]
    pub const LATE_FRAGMENT_TESTS: Self = Self(512);
    #[doc(alias = "VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT")]
    pub const COLOR_ATTACHMENT_OUTPUT: Self = Self(1024);
    #[doc(alias = "VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT")]
    pub const COMPUTE_SHADER: Self = Self(2048);
    #[doc(alias = "VK_PIPELINE_STAGE_TRANSFER_BIT")]
    pub const TRANSFER: Self = Self(4096);
    #[doc(alias = "VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT")]
    pub const BOTTOM_OF_PIPE: Self = Self(8192);
    #[doc(alias = "VK_PIPELINE_STAGE_HOST_BIT")]
    pub const HOST: Self = Self(16384);
    #[doc(alias = "VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT")]
    pub const ALL_GRAPHICS: Self = Self(32768);
    #[doc(alias = "VK_PIPELINE_STAGE_ALL_COMMANDS_BIT")]
    pub const ALL_COMMANDS: Self = Self(65536);
    #[doc(alias = "VK_PIPELINE_STAGE_NONE")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const NONE: Self = Self(0);
    #[doc(alias = "VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT")]
    #[cfg(feature = "VK_EXT_transform_feedback")]
    pub const TRANSFORM_FEEDBACK_EXT: Self = Self(16777216);
    #[doc(alias = "VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT")]
    #[cfg(feature = "VK_EXT_conditional_rendering")]
    pub const CONDITIONAL_RENDERING_EXT: Self = Self(262144);
    #[doc(alias = "VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR")]
    #[cfg(feature = "VK_KHR_acceleration_structure")]
    pub const ACCELERATION_STRUCTURE_BUILD_KHR: Self = Self(33554432);
    #[doc(alias = "VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_KHR")]
    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
    pub const RAY_TRACING_SHADER_KHR: Self = Self(2097152);
    #[doc(alias = "VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV")]
    #[cfg(feature = "VK_NV_mesh_shader")]
    pub const TASK_SHADER_NV: Self = Self(524288);
    #[doc(alias = "VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV")]
    #[cfg(feature = "VK_NV_mesh_shader")]
    pub const MESH_SHADER_NV: Self = Self(1048576);
    #[doc(alias = "VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT")]
    #[cfg(feature = "VK_EXT_fragment_density_map")]
    pub const FRAGMENT_DENSITY_PROCESS_EXT: Self = Self(8388608);
    #[doc(alias = "VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR")]
    #[cfg(feature = "VK_KHR_fragment_shading_rate")]
    pub const FRAGMENT_SHADING_RATE_ATTACHMENT_KHR: Self = Self(4194304);
    #[doc(alias = "VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_NV")]
    #[cfg(feature = "VK_NV_device_generated_commands")]
    pub const COMMAND_PREPROCESS_NV: Self = Self(131072);
    #[doc(alias = "VK_PIPELINE_STAGE_SHADING_RATE_IMAGE_BIT_NV")]
    #[cfg(feature = "VK_NV_shading_rate_image")]
    pub const SHADING_RATE_IMAGE_NV: Self = Self::FRAGMENT_SHADING_RATE_ATTACHMENT_KHR;
    #[doc(alias = "VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_NV")]
    #[cfg(feature = "VK_NV_ray_tracing")]
    pub const RAY_TRACING_SHADER_NV: Self = Self::RAY_TRACING_SHADER_KHR;
    #[doc(alias = "VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_NV")]
    #[cfg(feature = "VK_NV_ray_tracing")]
    pub const ACCELERATION_STRUCTURE_BUILD_NV: Self = Self::ACCELERATION_STRUCTURE_BUILD_KHR;
    #[doc(alias = "VK_PIPELINE_STAGE_NONE_KHR")]
    #[cfg(feature = "VK_KHR_synchronization2")]
    pub const NONE_KHR: Self = Self::NONE;
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        match bits {
            x if x == Self::TOP_OF_PIPE.bits() => Some(Self(x)),
            x if x == Self::DRAW_INDIRECT.bits() => Some(Self(x)),
            x if x == Self::VERTEX_INPUT.bits() => Some(Self(x)),
            x if x == Self::VERTEX_SHADER.bits() => Some(Self(x)),
            x if x == Self::TESSELLATION_CONTROL_SHADER.bits() => Some(Self(x)),
            x if x == Self::TESSELLATION_EVALUATION_SHADER.bits() => Some(Self(x)),
            x if x == Self::GEOMETRY_SHADER.bits() => Some(Self(x)),
            x if x == Self::FRAGMENT_SHADER.bits() => Some(Self(x)),
            x if x == Self::EARLY_FRAGMENT_TESTS.bits() => Some(Self(x)),
            x if x == Self::LATE_FRAGMENT_TESTS.bits() => Some(Self(x)),
            x if x == Self::COLOR_ATTACHMENT_OUTPUT.bits() => Some(Self(x)),
            x if x == Self::COMPUTE_SHADER.bits() => Some(Self(x)),
            x if x == Self::TRANSFER.bits() => Some(Self(x)),
            x if x == Self::BOTTOM_OF_PIPE.bits() => Some(Self(x)),
            x if x == Self::HOST.bits() => Some(Self(x)),
            x if x == Self::ALL_GRAPHICS.bits() => Some(Self(x)),
            x if x == Self::ALL_COMMANDS.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::NONE.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_transform_feedback")]
            x if x == Self::TRANSFORM_FEEDBACK_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_conditional_rendering")]
            x if x == Self::CONDITIONAL_RENDERING_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_acceleration_structure")]
            x if x == Self::ACCELERATION_STRUCTURE_BUILD_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
            x if x == Self::RAY_TRACING_SHADER_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_mesh_shader")]
            x if x == Self::TASK_SHADER_NV.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_mesh_shader")]
            x if x == Self::MESH_SHADER_NV.bits() => Some(Self(x)),
            #[cfg(feature = "VK_EXT_fragment_density_map")]
            x if x == Self::FRAGMENT_DENSITY_PROCESS_EXT.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_fragment_shading_rate")]
            x if x == Self::FRAGMENT_SHADING_RATE_ATTACHMENT_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NV_device_generated_commands")]
            x if x == Self::COMMAND_PREPROCESS_NV.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for PipelineStageFlagBits {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for PipelineStageFlagBits {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkCommandPoolCreateFlagBits")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct CommandPoolCreateFlagBits(u32);
impl Default for CommandPoolCreateFlagBits {
    #[inline]
    fn default() -> Self {
        Self::empty()
    }
}
impl CommandPoolCreateFlagBits {
    #[doc(alias = "VK_COMMAND_POOL_CREATE_TRANSIENT_BIT")]
    pub const TRANSIENT: Self = Self(1);
    #[doc(alias = "VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT")]
    pub const RESET_COMMAND_BUFFER: Self = Self(2);
    #[doc(alias = "VK_COMMAND_POOL_CREATE_PROTECTED_BIT")]
    pub const PROTECTED: Self = Self(4);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        match bits {
            x if x == Self::TRANSIENT.bits() => Some(Self(x)),
            x if x == Self::RESET_COMMAND_BUFFER.bits() => Some(Self(x)),
            x if x == Self::PROTECTED.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for CommandPoolCreateFlagBits {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for CommandPoolCreateFlagBits {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkCommandPoolResetFlagBits")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct CommandPoolResetFlagBits(u32);
impl Default for CommandPoolResetFlagBits {
    #[inline]
    fn default() -> Self {
        Self::empty()
    }
}
impl CommandPoolResetFlagBits {
    #[doc(alias = "VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT")]
    pub const RELEASE_RESOURCES: Self = Self(1);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        match bits {
            x if x == Self::RELEASE_RESOURCES.bits() => Some(Self(x)),
            #[cfg(feature = "VK_COREAVI_extension_444")]
            x if x == Self::RESERVED1_COREAVI.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for CommandPoolResetFlagBits {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for CommandPoolResetFlagBits {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkCommandBufferResetFlagBits")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct CommandBufferResetFlagBits(u32);
impl Default for CommandBufferResetFlagBits {
    #[inline]
    fn default() -> Self {
        Self::empty()
    }
}
impl CommandBufferResetFlagBits {
    #[doc(alias = "VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT")]
    pub const RELEASE_RESOURCES: Self = Self(1);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        match bits {
            x if x == Self::RELEASE_RESOURCES.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for CommandBufferResetFlagBits {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for CommandBufferResetFlagBits {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkSampleCountFlagBits")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct SampleCountFlagBits(u32);
impl Default for SampleCountFlagBits {
    #[inline]
    fn default() -> Self {
        Self::empty()
    }
}
impl SampleCountFlagBits {
    #[doc(alias = "VK_SAMPLE_COUNT_1_BIT")]
    pub const N1: Self = Self(1);
    #[doc(alias = "VK_SAMPLE_COUNT_2_BIT")]
    pub const N2: Self = Self(2);
    #[doc(alias = "VK_SAMPLE_COUNT_4_BIT")]
    pub const N4: Self = Self(4);
    #[doc(alias = "VK_SAMPLE_COUNT_8_BIT")]
    pub const N8: Self = Self(8);
    #[doc(alias = "VK_SAMPLE_COUNT_16_BIT")]
    pub const N16: Self = Self(16);
    #[doc(alias = "VK_SAMPLE_COUNT_32_BIT")]
    pub const N32: Self = Self(32);
    #[doc(alias = "VK_SAMPLE_COUNT_64_BIT")]
    pub const N64: Self = Self(64);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        match bits {
            x if x == Self::N1.bits() => Some(Self(x)),
            x if x == Self::N2.bits() => Some(Self(x)),
            x if x == Self::N4.bits() => Some(Self(x)),
            x if x == Self::N8.bits() => Some(Self(x)),
            x if x == Self::N16.bits() => Some(Self(x)),
            x if x == Self::N32.bits() => Some(Self(x)),
            x if x == Self::N64.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for SampleCountFlagBits {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for SampleCountFlagBits {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkAttachmentDescriptionFlagBits")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct AttachmentDescriptionFlagBits(u32);
impl Default for AttachmentDescriptionFlagBits {
    #[inline]
    fn default() -> Self {
        Self::empty()
    }
}
impl AttachmentDescriptionFlagBits {
    #[doc(alias = "VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT")]
    pub const MAY_ALIAS: Self = Self(1);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        match bits {
            x if x == Self::MAY_ALIAS.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for AttachmentDescriptionFlagBits {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for AttachmentDescriptionFlagBits {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkStencilFaceFlagBits")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct StencilFaceFlagBits(u32);
impl Default for StencilFaceFlagBits {
    #[inline]
    fn default() -> Self {
        Self::empty()
    }
}
impl StencilFaceFlagBits {
    #[doc(alias = "VK_STENCIL_FACE_FRONT_BIT")]
    pub const FRONT: Self = Self(1);
    #[doc(alias = "VK_STENCIL_FACE_BACK_BIT")]
    pub const BACK: Self = Self(2);
    #[doc(alias = "VK_STENCIL_FACE_FRONT_AND_BACK")]
    pub const FRONT_AND_BACK: Self = Self(3);
    #[doc(alias = "VK_STENCIL_FRONT_AND_BACK")]
    pub const STENCIL_FRONT_AND_BACK: Self = Self::FRONT_AND_BACK;
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        match bits {
            x if x == Self::FRONT.bits() => Some(Self(x)),
            x if x == Self::BACK.bits() => Some(Self(x)),
            x if x == Self::FRONT_AND_BACK.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for StencilFaceFlagBits {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for StencilFaceFlagBits {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkDescriptorPoolCreateFlagBits")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct DescriptorPoolCreateFlagBits(u32);
impl Default for DescriptorPoolCreateFlagBits {
    #[inline]
    fn default() -> Self {
        Self::empty()
    }
}
impl DescriptorPoolCreateFlagBits {
    #[doc(alias = "VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT")]
    pub const FREE_DESCRIPTOR_SET: Self = Self(1);
    #[doc(alias = "VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT")]
    #[cfg(feature = "VULKAN_1_2")]
    pub const UPDATE_AFTER_BIND: Self = Self(2);
    #[doc(alias = "VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_VALVE")]
    #[cfg(feature = "VK_VALVE_mutable_descriptor_type")]
    pub const HOST_ONLY_VALVE: Self = Self(4);
    #[doc(alias = "VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT")]
    #[cfg(feature = "VK_EXT_descriptor_indexing")]
    pub const UPDATE_AFTER_BIND_EXT: Self = Self::UPDATE_AFTER_BIND;
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        match bits {
            x if x == Self::FREE_DESCRIPTOR_SET.bits() => Some(Self(x)),
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::UPDATE_AFTER_BIND.bits() => Some(Self(x)),
            #[cfg(feature = "VK_VALVE_mutable_descriptor_type")]
            x if x == Self::HOST_ONLY_VALVE.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for DescriptorPoolCreateFlagBits {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for DescriptorPoolCreateFlagBits {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkDependencyFlagBits")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct DependencyFlagBits(u32);
impl Default for DependencyFlagBits {
    #[inline]
    fn default() -> Self {
        Self::empty()
    }
}
impl DependencyFlagBits {
    #[doc(alias = "VK_DEPENDENCY_BY_REGION_BIT")]
    pub const BY_REGION: Self = Self(1);
    #[doc(alias = "VK_DEPENDENCY_DEVICE_GROUP_BIT")]
    pub const DEVICE_GROUP: Self = Self(4);
    #[doc(alias = "VK_DEPENDENCY_VIEW_LOCAL_BIT")]
    pub const VIEW_LOCAL: Self = Self(2);
    #[doc(alias = "VK_DEPENDENCY_VIEW_LOCAL_BIT_KHR")]
    #[cfg(feature = "VK_KHR_multiview")]
    pub const VIEW_LOCAL_KHR: Self = Self::VIEW_LOCAL;
    #[doc(alias = "VK_DEPENDENCY_DEVICE_GROUP_BIT_KHR")]
    #[cfg(feature = "VK_KHR_device_group")]
    pub const DEVICE_GROUP_KHR: Self = Self::DEVICE_GROUP;
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        match bits {
            x if x == Self::BY_REGION.bits() => Some(Self(x)),
            x if x == Self::DEVICE_GROUP.bits() => Some(Self(x)),
            x if x == Self::VIEW_LOCAL.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for DependencyFlagBits {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for DependencyFlagBits {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkDescriptorSetLayoutCreateFlagBits")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct DescriptorSetLayoutCreateFlagBits(u32);
impl Default for DescriptorSetLayoutCreateFlagBits {
    #[inline]
    fn default() -> Self {
        Self::empty()
    }
}
impl DescriptorSetLayoutCreateFlagBits {
    #[doc(alias = "VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT")]
    #[cfg(feature = "VULKAN_1_2")]
    pub const UPDATE_AFTER_BIND_POOL: Self = Self(2);
    #[doc(alias = "VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR")]
    #[cfg(feature = "VK_KHR_push_descriptor")]
    pub const PUSH_DESCRIPTOR_KHR: Self = Self(1);
    #[doc(alias = "VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_VALVE")]
    #[cfg(feature = "VK_VALVE_mutable_descriptor_type")]
    pub const HOST_ONLY_POOL_VALVE: Self = Self(4);
    #[doc(alias = "VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT")]
    #[cfg(feature = "VK_EXT_descriptor_indexing")]
    pub const UPDATE_AFTER_BIND_POOL_EXT: Self = Self::UPDATE_AFTER_BIND_POOL;
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        match bits {
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::UPDATE_AFTER_BIND_POOL.bits() => Some(Self(x)),
            #[cfg(feature = "VK_KHR_push_descriptor")]
            x if x == Self::PUSH_DESCRIPTOR_KHR.bits() => Some(Self(x)),
            #[cfg(feature = "VK_AMD_extension_317")]
            x if x == Self::RESERVED4_AMD.bits() => Some(Self(x)),
            #[cfg(feature = "VK_AMD_extension_319")]
            x if x == Self::RESERVED3_AMD.bits() => Some(Self(x)),
            #[cfg(feature = "VK_VALVE_mutable_descriptor_type")]
            x if x == Self::HOST_ONLY_POOL_VALVE.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for DescriptorSetLayoutCreateFlagBits {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for DescriptorSetLayoutCreateFlagBits {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkSubpassDescriptionFlagBits")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct SubpassDescriptionFlagBits(u32);
impl Default for SubpassDescriptionFlagBits {
    #[inline]
    fn default() -> Self {
        Self::empty()
    }
}
impl SubpassDescriptionFlagBits {
    #[doc(alias = "VK_SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX")]
    #[cfg(feature = "VK_NVX_multiview_per_view_attributes")]
    pub const PER_VIEW_ATTRIBUTES_NVX: Self = Self(1);
    #[doc(alias = "VK_SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX")]
    #[cfg(feature = "VK_NVX_multiview_per_view_attributes")]
    pub const PER_VIEW_POSITION_X_ONLY_NVX: Self = Self(2);
    #[doc(alias = "VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_COLOR_ACCESS_BIT_ARM")]
    #[cfg(feature = "VK_ARM_rasterization_order_attachment_access")]
    pub const RASTERIZATION_ORDER_ATTACHMENT_COLOR_ACCESS_ARM: Self = Self(16);
    #[doc(alias = "VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_ARM")]
    #[cfg(feature = "VK_ARM_rasterization_order_attachment_access")]
    pub const RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_ARM: Self = Self(32);
    #[doc(alias = "VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_ARM")]
    #[cfg(feature = "VK_ARM_rasterization_order_attachment_access")]
    pub const RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_ARM: Self = Self(64);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        match bits {
            #[cfg(feature = "VK_NVX_multiview_per_view_attributes")]
            x if x == Self::PER_VIEW_ATTRIBUTES_NVX.bits() => Some(Self(x)),
            #[cfg(feature = "VK_NVX_multiview_per_view_attributes")]
            x if x == Self::PER_VIEW_POSITION_X_ONLY_NVX.bits() => Some(Self(x)),
            #[cfg(feature = "VK_QCOM_render_pass_shader_resolve")]
            x if x == Self::FRAGMENT_REGION_QCOM.bits() => Some(Self(x)),
            #[cfg(feature = "VK_QCOM_render_pass_shader_resolve")]
            x if x == Self::SHADER_RESOLVE_QCOM.bits() => Some(Self(x)),
            #[cfg(feature = "VK_ARM_rasterization_order_attachment_access")]
            x if x == Self::RASTERIZATION_ORDER_ATTACHMENT_COLOR_ACCESS_ARM.bits() => Some(Self(x)),
            #[cfg(feature = "VK_ARM_rasterization_order_attachment_access")]
            x if x == Self::RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_ARM.bits() => Some(Self(x)),
            #[cfg(feature = "VK_ARM_rasterization_order_attachment_access")]
            x if x == Self::RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_ARM.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for SubpassDescriptionFlagBits {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for SubpassDescriptionFlagBits {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkFramebufferCreateFlagBits")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct FramebufferCreateFlagBits(u32);
impl Default for FramebufferCreateFlagBits {
    #[inline]
    fn default() -> Self {
        Self::empty()
    }
}
impl FramebufferCreateFlagBits {
    #[doc(alias = "VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT")]
    #[cfg(feature = "VULKAN_1_2")]
    pub const IMAGELESS: Self = Self(1);
    #[doc(alias = "VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT_KHR")]
    #[cfg(feature = "VK_KHR_imageless_framebuffer")]
    pub const IMAGELESS_KHR: Self = Self::IMAGELESS;
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        match bits {
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::IMAGELESS.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for FramebufferCreateFlagBits {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for FramebufferCreateFlagBits {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkEventCreateFlagBits")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct EventCreateFlagBits(u32);
impl Default for EventCreateFlagBits {
    #[inline]
    fn default() -> Self {
        Self::empty()
    }
}
impl EventCreateFlagBits {
    #[doc(alias = "VK_EVENT_CREATE_DEVICE_ONLY_BIT")]
    #[cfg(feature = "VULKAN_1_3")]
    pub const DEVICE_ONLY: Self = Self(1);
    #[doc(alias = "VK_EVENT_CREATE_DEVICE_ONLY_BIT_KHR")]
    #[cfg(feature = "VK_KHR_synchronization2")]
    pub const DEVICE_ONLY_KHR: Self = Self::DEVICE_ONLY;
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        match bits {
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::DEVICE_ONLY.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for EventCreateFlagBits {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for EventCreateFlagBits {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkInstanceCreateFlagBits")]
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub struct InstanceCreateFlagBits(u32);
impl Default for InstanceCreateFlagBits {
    #[inline]
    fn default() -> Self {
        Self::empty()
    }
}
impl InstanceCreateFlagBits {
    #[doc(alias = "VK_INSTANCE_CREATE_ENUMERATE_PORTABILITY_BIT_KHR")]
    #[cfg(feature = "VK_KHR_portability_enumeration")]
    pub const ENUMERATE_PORTABILITY_KHR: Self = Self(1);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self(0)
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        match bits {
            #[cfg(feature = "VK_KHR_portability_enumeration")]
            x if x == Self::ENUMERATE_PORTABILITY_KHR.bits() => Some(Self(x)),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for InstanceCreateFlagBits {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for InstanceCreateFlagBits {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkImageLayout")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub enum ImageLayout {
    #[doc(alias = "VK_IMAGE_LAYOUT_UNDEFINED")]
    Undefined = 0,
    #[doc(alias = "VK_IMAGE_LAYOUT_GENERAL")]
    General = 1,
    #[doc(alias = "VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL")]
    ColorAttachmentOptimal = 2,
    #[doc(alias = "VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL")]
    DepthStencilAttachmentOptimal = 3,
    #[doc(alias = "VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL")]
    DepthStencilReadOnlyOptimal = 4,
    #[doc(alias = "VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL")]
    ShaderReadOnlyOptimal = 5,
    #[doc(alias = "VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL")]
    TransferSrcOptimal = 6,
    #[doc(alias = "VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL")]
    TransferDstOptimal = 7,
    #[doc(alias = "VK_IMAGE_LAYOUT_PREINITIALIZED")]
    Preinitialized = 8,
    #[doc(alias = "VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL")]
    #[doc(alias = "VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL_KHR")]
    DepthReadOnlyStencilAttachmentOptimal = 1000117000,
    #[doc(alias = "VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL")]
    #[doc(alias = "VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL_KHR")]
    DepthAttachmentStencilReadOnlyOptimal = 1000117001,
    #[doc(alias = "VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL")]
    #[doc(alias = "VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL_KHR")]
    #[cfg(feature = "VULKAN_1_2")]
    DepthAttachmentOptimal = 1000241000,
    #[doc(alias = "VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL")]
    #[doc(alias = "VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL_KHR")]
    #[cfg(feature = "VULKAN_1_2")]
    DepthReadOnlyOptimal = 1000241001,
    #[doc(alias = "VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL")]
    #[doc(alias = "VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL_KHR")]
    #[cfg(feature = "VULKAN_1_2")]
    StencilAttachmentOptimal = 1000241002,
    #[doc(alias = "VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL")]
    #[doc(alias = "VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL_KHR")]
    #[cfg(feature = "VULKAN_1_2")]
    StencilReadOnlyOptimal = 1000241003,
    #[doc(alias = "VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL")]
    #[doc(alias = "VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL_KHR")]
    #[cfg(feature = "VULKAN_1_3")]
    ReadOnlyOptimal = 1000314000,
    #[doc(alias = "VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL")]
    #[doc(alias = "VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL_KHR")]
    #[cfg(feature = "VULKAN_1_3")]
    AttachmentOptimal = 1000314001,
    #[doc(alias = "VK_IMAGE_LAYOUT_PRESENT_SRC_KHR")]
    #[cfg(feature = "VK_KHR_swapchain")]
    PresentSrcKhr = 1000001002,
    #[doc(alias = "VK_IMAGE_LAYOUT_VIDEO_DECODE_DST_KHR")]
    #[cfg(feature = "VK_KHR_video_decode_queue")]
    VideoDecodeDstKhr = 1000024000,
    #[doc(alias = "VK_IMAGE_LAYOUT_VIDEO_DECODE_SRC_KHR")]
    #[cfg(feature = "VK_KHR_video_decode_queue")]
    VideoDecodeSrcKhr = 1000024001,
    #[doc(alias = "VK_IMAGE_LAYOUT_VIDEO_DECODE_DPB_KHR")]
    #[cfg(feature = "VK_KHR_video_decode_queue")]
    VideoDecodeDpbKhr = 1000024002,
    #[doc(alias = "VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR")]
    #[cfg(feature = "VK_KHR_shared_presentable_image")]
    SharedPresentKhr = 1000111000,
    #[doc(alias = "VK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT")]
    #[cfg(feature = "VK_EXT_fragment_density_map")]
    FragmentDensityMapOptimalExt = 1000218000,
    #[doc(alias = "VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR")]
    #[doc(alias = "VK_IMAGE_LAYOUT_SHADING_RATE_OPTIMAL_NV")]
    #[cfg(feature = "VK_KHR_fragment_shading_rate")]
    FragmentShadingRateAttachmentOptimalKhr = 1000164003,
    #[doc(alias = "VK_IMAGE_LAYOUT_VIDEO_ENCODE_DST_KHR")]
    #[cfg(feature = "VK_KHR_video_encode_queue")]
    VideoEncodeDstKhr = 1000299000,
    #[doc(alias = "VK_IMAGE_LAYOUT_VIDEO_ENCODE_SRC_KHR")]
    #[cfg(feature = "VK_KHR_video_encode_queue")]
    VideoEncodeSrcKhr = 1000299001,
    #[doc(alias = "VK_IMAGE_LAYOUT_VIDEO_ENCODE_DPB_KHR")]
    #[cfg(feature = "VK_KHR_video_encode_queue")]
    VideoEncodeDpbKhr = 1000299002,
}
impl Default for ImageLayout {
    #[inline]
    fn default() -> Self {
        Self::empty()
    }
}
impl ImageLayout {
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        unsafe { Self::from_bits_unchecked(0) }
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> i32 {
        *self as i32
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: i32) -> Option<Self> {
        match bits {
            x if x == Self::Undefined.bits() => Some(Self::Undefined),
            x if x == Self::General.bits() => Some(Self::General),
            x if x == Self::ColorAttachmentOptimal.bits() => Some(Self::ColorAttachmentOptimal),
            x if x == Self::DepthStencilAttachmentOptimal.bits() => Some(Self::DepthStencilAttachmentOptimal),
            x if x == Self::DepthStencilReadOnlyOptimal.bits() => Some(Self::DepthStencilReadOnlyOptimal),
            x if x == Self::ShaderReadOnlyOptimal.bits() => Some(Self::ShaderReadOnlyOptimal),
            x if x == Self::TransferSrcOptimal.bits() => Some(Self::TransferSrcOptimal),
            x if x == Self::TransferDstOptimal.bits() => Some(Self::TransferDstOptimal),
            x if x == Self::Preinitialized.bits() => Some(Self::Preinitialized),
            x if x == Self::DepthReadOnlyStencilAttachmentOptimal.bits() => {
                Some(Self::DepthReadOnlyStencilAttachmentOptimal)
            },
            x if x == Self::DepthAttachmentStencilReadOnlyOptimal.bits() => {
                Some(Self::DepthAttachmentStencilReadOnlyOptimal)
            },
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::DepthAttachmentOptimal.bits() => Some(Self::DepthAttachmentOptimal),
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::DepthReadOnlyOptimal.bits() => Some(Self::DepthReadOnlyOptimal),
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::StencilAttachmentOptimal.bits() => Some(Self::StencilAttachmentOptimal),
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::StencilReadOnlyOptimal.bits() => Some(Self::StencilReadOnlyOptimal),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::ReadOnlyOptimal.bits() => Some(Self::ReadOnlyOptimal),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::AttachmentOptimal.bits() => Some(Self::AttachmentOptimal),
            #[cfg(feature = "VK_KHR_swapchain")]
            x if x == Self::PresentSrcKhr.bits() => Some(Self::PresentSrcKhr),
            #[cfg(feature = "VK_KHR_video_decode_queue")]
            x if x == Self::VideoDecodeDstKhr.bits() => Some(Self::VideoDecodeDstKhr),
            #[cfg(feature = "VK_KHR_video_decode_queue")]
            x if x == Self::VideoDecodeSrcKhr.bits() => Some(Self::VideoDecodeSrcKhr),
            #[cfg(feature = "VK_KHR_video_decode_queue")]
            x if x == Self::VideoDecodeDpbKhr.bits() => Some(Self::VideoDecodeDpbKhr),
            #[cfg(feature = "VK_KHR_shared_presentable_image")]
            x if x == Self::SharedPresentKhr.bits() => Some(Self::SharedPresentKhr),
            #[cfg(feature = "VK_EXT_fragment_density_map")]
            x if x == Self::FragmentDensityMapOptimalExt.bits() => Some(Self::FragmentDensityMapOptimalExt),
            #[cfg(feature = "VK_KHR_fragment_shading_rate")]
            x if x == Self::FragmentShadingRateAttachmentOptimalKhr.bits() => {
                Some(Self::FragmentShadingRateAttachmentOptimalKhr)
            },
            #[cfg(feature = "VK_KHR_video_encode_queue")]
            x if x == Self::VideoEncodeDstKhr.bits() => Some(Self::VideoEncodeDstKhr),
            #[cfg(feature = "VK_KHR_video_encode_queue")]
            x if x == Self::VideoEncodeSrcKhr.bits() => Some(Self::VideoEncodeSrcKhr),
            #[cfg(feature = "VK_KHR_video_encode_queue")]
            x if x == Self::VideoEncodeDpbKhr.bits() => Some(Self::VideoEncodeDpbKhr),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: i32) -> Self {
        std::mem::transmute(bits)
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for ImageLayout {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for ImageLayout {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkAttachmentLoadOp")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub enum AttachmentLoadOp {
    #[doc(alias = "VK_ATTACHMENT_LOAD_OP_LOAD")]
    Load = 0,
    #[doc(alias = "VK_ATTACHMENT_LOAD_OP_CLEAR")]
    Clear = 1,
    #[doc(alias = "VK_ATTACHMENT_LOAD_OP_DONT_CARE")]
    DontCare = 2,
    #[doc(alias = "VK_ATTACHMENT_LOAD_OP_NONE_EXT")]
    #[cfg(feature = "VK_EXT_load_store_op_none")]
    NoneExt = 1000400000,
}
impl Default for AttachmentLoadOp {
    #[inline]
    fn default() -> Self {
        Self::empty()
    }
}
impl AttachmentLoadOp {
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        unsafe { Self::from_bits_unchecked(0) }
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> i32 {
        *self as i32
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: i32) -> Option<Self> {
        match bits {
            x if x == Self::Load.bits() => Some(Self::Load),
            x if x == Self::Clear.bits() => Some(Self::Clear),
            x if x == Self::DontCare.bits() => Some(Self::DontCare),
            #[cfg(feature = "VK_EXT_load_store_op_none")]
            x if x == Self::NoneExt.bits() => Some(Self::NoneExt),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: i32) -> Self {
        std::mem::transmute(bits)
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for AttachmentLoadOp {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for AttachmentLoadOp {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkAttachmentStoreOp")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub enum AttachmentStoreOp {
    #[doc(alias = "VK_ATTACHMENT_STORE_OP_STORE")]
    Store = 0,
    #[doc(alias = "VK_ATTACHMENT_STORE_OP_DONT_CARE")]
    DontCare = 1,
    #[doc(alias = "VK_ATTACHMENT_STORE_OP_NONE")]
    #[doc(alias = "VK_ATTACHMENT_STORE_OP_NONE_KHR")]
    #[doc(alias = "VK_ATTACHMENT_STORE_OP_NONE_QCOM")]
    #[doc(alias = "VK_ATTACHMENT_STORE_OP_NONE_EXT")]
    #[cfg(feature = "VULKAN_1_3")]
    None = 1000301000,
}
impl Default for AttachmentStoreOp {
    #[inline]
    fn default() -> Self {
        Self::empty()
    }
}
impl AttachmentStoreOp {
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        unsafe { Self::from_bits_unchecked(0) }
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> i32 {
        *self as i32
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: i32) -> Option<Self> {
        match bits {
            x if x == Self::Store.bits() => Some(Self::Store),
            x if x == Self::DontCare.bits() => Some(Self::DontCare),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::None.bits() => Some(Self::None),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: i32) -> Self {
        std::mem::transmute(bits)
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for AttachmentStoreOp {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for AttachmentStoreOp {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkImageType")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub enum ImageType {
    #[doc(alias = "VK_IMAGE_TYPE_1D")]
    N1d = 0,
    #[doc(alias = "VK_IMAGE_TYPE_2D")]
    N2d = 1,
    #[doc(alias = "VK_IMAGE_TYPE_3D")]
    N3d = 2,
}
impl Default for ImageType {
    #[inline]
    fn default() -> Self {
        Self::empty()
    }
}
impl ImageType {
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        unsafe { Self::from_bits_unchecked(0) }
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> i32 {
        *self as i32
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: i32) -> Option<Self> {
        match bits {
            x if x == Self::N1d.bits() => Some(Self::N1d),
            x if x == Self::N2d.bits() => Some(Self::N2d),
            x if x == Self::N3d.bits() => Some(Self::N3d),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: i32) -> Self {
        std::mem::transmute(bits)
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for ImageType {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for ImageType {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkImageTiling")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub enum ImageTiling {
    #[doc(alias = "VK_IMAGE_TILING_OPTIMAL")]
    Optimal = 0,
    #[doc(alias = "VK_IMAGE_TILING_LINEAR")]
    Linear = 1,
    #[doc(alias = "VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT")]
    #[cfg(feature = "VK_EXT_image_drm_format_modifier")]
    DrmFormatModifierExt = 1000158000,
}
impl Default for ImageTiling {
    #[inline]
    fn default() -> Self {
        Self::empty()
    }
}
impl ImageTiling {
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        unsafe { Self::from_bits_unchecked(0) }
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> i32 {
        *self as i32
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: i32) -> Option<Self> {
        match bits {
            x if x == Self::Optimal.bits() => Some(Self::Optimal),
            x if x == Self::Linear.bits() => Some(Self::Linear),
            #[cfg(feature = "VK_EXT_image_drm_format_modifier")]
            x if x == Self::DrmFormatModifierExt.bits() => Some(Self::DrmFormatModifierExt),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: i32) -> Self {
        std::mem::transmute(bits)
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for ImageTiling {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for ImageTiling {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkImageViewType")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub enum ImageViewType {
    #[doc(alias = "VK_IMAGE_VIEW_TYPE_1D")]
    N1d = 0,
    #[doc(alias = "VK_IMAGE_VIEW_TYPE_2D")]
    N2d = 1,
    #[doc(alias = "VK_IMAGE_VIEW_TYPE_3D")]
    N3d = 2,
    #[doc(alias = "VK_IMAGE_VIEW_TYPE_CUBE")]
    Cube = 3,
    #[doc(alias = "VK_IMAGE_VIEW_TYPE_1D_ARRAY")]
    N1dArray = 4,
    #[doc(alias = "VK_IMAGE_VIEW_TYPE_2D_ARRAY")]
    N2dArray = 5,
    #[doc(alias = "VK_IMAGE_VIEW_TYPE_CUBE_ARRAY")]
    CubeArray = 6,
}
impl Default for ImageViewType {
    #[inline]
    fn default() -> Self {
        Self::empty()
    }
}
impl ImageViewType {
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        unsafe { Self::from_bits_unchecked(0) }
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> i32 {
        *self as i32
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: i32) -> Option<Self> {
        match bits {
            x if x == Self::N1d.bits() => Some(Self::N1d),
            x if x == Self::N2d.bits() => Some(Self::N2d),
            x if x == Self::N3d.bits() => Some(Self::N3d),
            x if x == Self::Cube.bits() => Some(Self::Cube),
            x if x == Self::N1dArray.bits() => Some(Self::N1dArray),
            x if x == Self::N2dArray.bits() => Some(Self::N2dArray),
            x if x == Self::CubeArray.bits() => Some(Self::CubeArray),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: i32) -> Self {
        std::mem::transmute(bits)
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for ImageViewType {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for ImageViewType {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkCommandBufferLevel")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub enum CommandBufferLevel {
    #[doc(alias = "VK_COMMAND_BUFFER_LEVEL_PRIMARY")]
    Primary = 0,
    #[doc(alias = "VK_COMMAND_BUFFER_LEVEL_SECONDARY")]
    Secondary = 1,
}
impl Default for CommandBufferLevel {
    #[inline]
    fn default() -> Self {
        Self::empty()
    }
}
impl CommandBufferLevel {
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        unsafe { Self::from_bits_unchecked(0) }
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> i32 {
        *self as i32
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: i32) -> Option<Self> {
        match bits {
            x if x == Self::Primary.bits() => Some(Self::Primary),
            x if x == Self::Secondary.bits() => Some(Self::Secondary),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: i32) -> Self {
        std::mem::transmute(bits)
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for CommandBufferLevel {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for CommandBufferLevel {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkComponentSwizzle")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub enum ComponentSwizzle {
    #[doc(alias = "VK_COMPONENT_SWIZZLE_IDENTITY")]
    Identity = 0,
    #[doc(alias = "VK_COMPONENT_SWIZZLE_ZERO")]
    Zero = 1,
    #[doc(alias = "VK_COMPONENT_SWIZZLE_ONE")]
    One = 2,
    #[doc(alias = "VK_COMPONENT_SWIZZLE_R")]
    R = 3,
    #[doc(alias = "VK_COMPONENT_SWIZZLE_G")]
    G = 4,
    #[doc(alias = "VK_COMPONENT_SWIZZLE_B")]
    B = 5,
    #[doc(alias = "VK_COMPONENT_SWIZZLE_A")]
    A = 6,
}
impl Default for ComponentSwizzle {
    #[inline]
    fn default() -> Self {
        Self::empty()
    }
}
impl ComponentSwizzle {
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        unsafe { Self::from_bits_unchecked(0) }
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> i32 {
        *self as i32
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: i32) -> Option<Self> {
        match bits {
            x if x == Self::Identity.bits() => Some(Self::Identity),
            x if x == Self::Zero.bits() => Some(Self::Zero),
            x if x == Self::One.bits() => Some(Self::One),
            x if x == Self::R.bits() => Some(Self::R),
            x if x == Self::G.bits() => Some(Self::G),
            x if x == Self::B.bits() => Some(Self::B),
            x if x == Self::A.bits() => Some(Self::A),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: i32) -> Self {
        std::mem::transmute(bits)
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for ComponentSwizzle {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for ComponentSwizzle {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkDescriptorType")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub enum DescriptorType {
    #[doc(alias = "VK_DESCRIPTOR_TYPE_SAMPLER")]
    Sampler = 0,
    #[doc(alias = "VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER")]
    CombinedImageSampler = 1,
    #[doc(alias = "VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE")]
    SampledImage = 2,
    #[doc(alias = "VK_DESCRIPTOR_TYPE_STORAGE_IMAGE")]
    StorageImage = 3,
    #[doc(alias = "VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER")]
    UniformTexelBuffer = 4,
    #[doc(alias = "VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER")]
    StorageTexelBuffer = 5,
    #[doc(alias = "VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER")]
    UniformBuffer = 6,
    #[doc(alias = "VK_DESCRIPTOR_TYPE_STORAGE_BUFFER")]
    StorageBuffer = 7,
    #[doc(alias = "VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC")]
    UniformBufferDynamic = 8,
    #[doc(alias = "VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC")]
    StorageBufferDynamic = 9,
    #[doc(alias = "VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT")]
    InputAttachment = 10,
    #[doc(alias = "VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK")]
    #[doc(alias = "VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT")]
    #[cfg(feature = "VULKAN_1_3")]
    InlineUniformBlock = 1000138000,
    #[doc(alias = "VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR")]
    #[cfg(feature = "VK_KHR_acceleration_structure")]
    AccelerationStructureKhr = 1000150000,
    #[doc(alias = "VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV")]
    #[cfg(feature = "VK_NV_ray_tracing")]
    AccelerationStructureNv = 1000165000,
    #[doc(alias = "VK_DESCRIPTOR_TYPE_MUTABLE_VALVE")]
    #[cfg(feature = "VK_VALVE_mutable_descriptor_type")]
    MutableValve = 1000351000,
}
impl Default for DescriptorType {
    #[inline]
    fn default() -> Self {
        Self::empty()
    }
}
impl DescriptorType {
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        unsafe { Self::from_bits_unchecked(0) }
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> i32 {
        *self as i32
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: i32) -> Option<Self> {
        match bits {
            x if x == Self::Sampler.bits() => Some(Self::Sampler),
            x if x == Self::CombinedImageSampler.bits() => Some(Self::CombinedImageSampler),
            x if x == Self::SampledImage.bits() => Some(Self::SampledImage),
            x if x == Self::StorageImage.bits() => Some(Self::StorageImage),
            x if x == Self::UniformTexelBuffer.bits() => Some(Self::UniformTexelBuffer),
            x if x == Self::StorageTexelBuffer.bits() => Some(Self::StorageTexelBuffer),
            x if x == Self::UniformBuffer.bits() => Some(Self::UniformBuffer),
            x if x == Self::StorageBuffer.bits() => Some(Self::StorageBuffer),
            x if x == Self::UniformBufferDynamic.bits() => Some(Self::UniformBufferDynamic),
            x if x == Self::StorageBufferDynamic.bits() => Some(Self::StorageBufferDynamic),
            x if x == Self::InputAttachment.bits() => Some(Self::InputAttachment),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::InlineUniformBlock.bits() => Some(Self::InlineUniformBlock),
            #[cfg(feature = "VK_KHR_acceleration_structure")]
            x if x == Self::AccelerationStructureKhr.bits() => Some(Self::AccelerationStructureKhr),
            #[cfg(feature = "VK_NV_ray_tracing")]
            x if x == Self::AccelerationStructureNv.bits() => Some(Self::AccelerationStructureNv),
            #[cfg(feature = "VK_VALVE_mutable_descriptor_type")]
            x if x == Self::MutableValve.bits() => Some(Self::MutableValve),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: i32) -> Self {
        std::mem::transmute(bits)
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for DescriptorType {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for DescriptorType {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkQueryType")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub enum QueryType {
    #[doc(alias = "VK_QUERY_TYPE_OCCLUSION")]
    Occlusion = 0,
    #[doc(alias = "VK_QUERY_TYPE_PIPELINE_STATISTICS")]
    PipelineStatistics = 1,
    #[doc(alias = "VK_QUERY_TYPE_TIMESTAMP")]
    Timestamp = 2,
    #[doc(alias = "VK_QUERY_TYPE_RESULT_STATUS_ONLY_KHR")]
    #[cfg(feature = "VK_KHR_video_queue")]
    ResultStatusOnlyKhr = 1000023000,
    #[doc(alias = "VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT")]
    #[cfg(feature = "VK_EXT_transform_feedback")]
    TransformFeedbackStreamExt = 1000028004,
    #[doc(alias = "VK_QUERY_TYPE_PERFORMANCE_QUERY_KHR")]
    #[cfg(feature = "VK_KHR_performance_query")]
    PerformanceQueryKhr = 1000116000,
    #[doc(alias = "VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_KHR")]
    #[cfg(feature = "VK_KHR_acceleration_structure")]
    AccelerationStructureCompactedSizeKhr = 1000150000,
    #[doc(alias = "VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_SIZE_KHR")]
    #[cfg(feature = "VK_KHR_acceleration_structure")]
    AccelerationStructureSerializationSizeKhr = 1000150001,
    #[doc(alias = "VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_NV")]
    #[cfg(feature = "VK_NV_ray_tracing")]
    AccelerationStructureCompactedSizeNv = 1000165000,
    #[doc(alias = "VK_QUERY_TYPE_PERFORMANCE_QUERY_INTEL")]
    #[cfg(feature = "VK_INTEL_performance_query")]
    PerformanceQueryIntel = 1000210000,
    #[doc(alias = "VK_QUERY_TYPE_VIDEO_ENCODE_BITSTREAM_BUFFER_RANGE_KHR")]
    #[cfg(feature = "VK_KHR_video_encode_queue")]
    VideoEncodeBitstreamBufferRangeKhr = 1000299000,
}
impl Default for QueryType {
    #[inline]
    fn default() -> Self {
        Self::empty()
    }
}
impl QueryType {
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        unsafe { Self::from_bits_unchecked(0) }
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> i32 {
        *self as i32
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: i32) -> Option<Self> {
        match bits {
            x if x == Self::Occlusion.bits() => Some(Self::Occlusion),
            x if x == Self::PipelineStatistics.bits() => Some(Self::PipelineStatistics),
            x if x == Self::Timestamp.bits() => Some(Self::Timestamp),
            #[cfg(feature = "VK_KHR_video_queue")]
            x if x == Self::ResultStatusOnlyKhr.bits() => Some(Self::ResultStatusOnlyKhr),
            #[cfg(feature = "VK_EXT_transform_feedback")]
            x if x == Self::TransformFeedbackStreamExt.bits() => Some(Self::TransformFeedbackStreamExt),
            #[cfg(feature = "VK_KHR_performance_query")]
            x if x == Self::PerformanceQueryKhr.bits() => Some(Self::PerformanceQueryKhr),
            #[cfg(feature = "VK_KHR_acceleration_structure")]
            x if x == Self::AccelerationStructureCompactedSizeKhr.bits() => {
                Some(Self::AccelerationStructureCompactedSizeKhr)
            },
            #[cfg(feature = "VK_KHR_acceleration_structure")]
            x if x == Self::AccelerationStructureSerializationSizeKhr.bits() => {
                Some(Self::AccelerationStructureSerializationSizeKhr)
            },
            #[cfg(feature = "VK_NV_ray_tracing")]
            x if x == Self::AccelerationStructureCompactedSizeNv.bits() => {
                Some(Self::AccelerationStructureCompactedSizeNv)
            },
            #[cfg(feature = "VK_INTEL_performance_query")]
            x if x == Self::PerformanceQueryIntel.bits() => Some(Self::PerformanceQueryIntel),
            #[cfg(feature = "VK_KHR_video_encode_queue")]
            x if x == Self::VideoEncodeBitstreamBufferRangeKhr.bits() => Some(Self::VideoEncodeBitstreamBufferRangeKhr),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: i32) -> Self {
        std::mem::transmute(bits)
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for QueryType {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for QueryType {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkBorderColor")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub enum BorderColor {
    #[doc(alias = "VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK")]
    FloatTransparentBlack = 0,
    #[doc(alias = "VK_BORDER_COLOR_INT_TRANSPARENT_BLACK")]
    IntTransparentBlack = 1,
    #[doc(alias = "VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK")]
    FloatOpaqueBlack = 2,
    #[doc(alias = "VK_BORDER_COLOR_INT_OPAQUE_BLACK")]
    IntOpaqueBlack = 3,
    #[doc(alias = "VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE")]
    FloatOpaqueWhite = 4,
    #[doc(alias = "VK_BORDER_COLOR_INT_OPAQUE_WHITE")]
    IntOpaqueWhite = 5,
    #[doc(alias = "VK_BORDER_COLOR_FLOAT_CUSTOM_EXT")]
    #[cfg(feature = "VK_EXT_custom_border_color")]
    FloatCustomExt = 1000287003,
    #[doc(alias = "VK_BORDER_COLOR_INT_CUSTOM_EXT")]
    #[cfg(feature = "VK_EXT_custom_border_color")]
    IntCustomExt = 1000287004,
}
impl Default for BorderColor {
    #[inline]
    fn default() -> Self {
        Self::empty()
    }
}
impl BorderColor {
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        unsafe { Self::from_bits_unchecked(0) }
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> i32 {
        *self as i32
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: i32) -> Option<Self> {
        match bits {
            x if x == Self::FloatTransparentBlack.bits() => Some(Self::FloatTransparentBlack),
            x if x == Self::IntTransparentBlack.bits() => Some(Self::IntTransparentBlack),
            x if x == Self::FloatOpaqueBlack.bits() => Some(Self::FloatOpaqueBlack),
            x if x == Self::IntOpaqueBlack.bits() => Some(Self::IntOpaqueBlack),
            x if x == Self::FloatOpaqueWhite.bits() => Some(Self::FloatOpaqueWhite),
            x if x == Self::IntOpaqueWhite.bits() => Some(Self::IntOpaqueWhite),
            #[cfg(feature = "VK_EXT_custom_border_color")]
            x if x == Self::FloatCustomExt.bits() => Some(Self::FloatCustomExt),
            #[cfg(feature = "VK_EXT_custom_border_color")]
            x if x == Self::IntCustomExt.bits() => Some(Self::IntCustomExt),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: i32) -> Self {
        std::mem::transmute(bits)
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for BorderColor {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for BorderColor {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkPipelineBindPoint")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub enum PipelineBindPoint {
    #[doc(alias = "VK_PIPELINE_BIND_POINT_GRAPHICS")]
    Graphics = 0,
    #[doc(alias = "VK_PIPELINE_BIND_POINT_COMPUTE")]
    Compute = 1,
    #[doc(alias = "VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR")]
    #[doc(alias = "VK_PIPELINE_BIND_POINT_RAY_TRACING_NV")]
    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
    RayTracingKhr = 1000165000,
    #[doc(alias = "VK_PIPELINE_BIND_POINT_SUBPASS_SHADING_HUAWEI")]
    #[cfg(feature = "VK_HUAWEI_subpass_shading")]
    SubpassShadingHuawei = 1000369003,
}
impl Default for PipelineBindPoint {
    #[inline]
    fn default() -> Self {
        Self::empty()
    }
}
impl PipelineBindPoint {
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        unsafe { Self::from_bits_unchecked(0) }
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> i32 {
        *self as i32
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: i32) -> Option<Self> {
        match bits {
            x if x == Self::Graphics.bits() => Some(Self::Graphics),
            x if x == Self::Compute.bits() => Some(Self::Compute),
            #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
            x if x == Self::RayTracingKhr.bits() => Some(Self::RayTracingKhr),
            #[cfg(feature = "VK_HUAWEI_subpass_shading")]
            x if x == Self::SubpassShadingHuawei.bits() => Some(Self::SubpassShadingHuawei),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: i32) -> Self {
        std::mem::transmute(bits)
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for PipelineBindPoint {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for PipelineBindPoint {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkPipelineCacheHeaderVersion")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub enum PipelineCacheHeaderVersion {
    Empty = 0,
    #[doc(alias = "VK_PIPELINE_CACHE_HEADER_VERSION_ONE")]
    One = 1,
}
impl Default for PipelineCacheHeaderVersion {
    #[inline]
    fn default() -> Self {
        Self::empty()
    }
}
impl PipelineCacheHeaderVersion {
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        unsafe { Self::from_bits_unchecked(0) }
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> i32 {
        *self as i32
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: i32) -> Option<Self> {
        match bits {
            x if x == Self::One.bits() => Some(Self::One),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: i32) -> Self {
        std::mem::transmute(bits)
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for PipelineCacheHeaderVersion {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for PipelineCacheHeaderVersion {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkPrimitiveTopology")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub enum PrimitiveTopology {
    #[doc(alias = "VK_PRIMITIVE_TOPOLOGY_POINT_LIST")]
    PointList = 0,
    #[doc(alias = "VK_PRIMITIVE_TOPOLOGY_LINE_LIST")]
    LineList = 1,
    #[doc(alias = "VK_PRIMITIVE_TOPOLOGY_LINE_STRIP")]
    LineStrip = 2,
    #[doc(alias = "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST")]
    TriangleList = 3,
    #[doc(alias = "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP")]
    TriangleStrip = 4,
    #[doc(alias = "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN")]
    TriangleFan = 5,
    #[doc(alias = "VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY")]
    LineListWithAdjacency = 6,
    #[doc(alias = "VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY")]
    LineStripWithAdjacency = 7,
    #[doc(alias = "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY")]
    TriangleListWithAdjacency = 8,
    #[doc(alias = "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY")]
    TriangleStripWithAdjacency = 9,
    #[doc(alias = "VK_PRIMITIVE_TOPOLOGY_PATCH_LIST")]
    PatchList = 10,
}
impl Default for PrimitiveTopology {
    #[inline]
    fn default() -> Self {
        Self::empty()
    }
}
impl PrimitiveTopology {
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        unsafe { Self::from_bits_unchecked(0) }
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> i32 {
        *self as i32
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: i32) -> Option<Self> {
        match bits {
            x if x == Self::PointList.bits() => Some(Self::PointList),
            x if x == Self::LineList.bits() => Some(Self::LineList),
            x if x == Self::LineStrip.bits() => Some(Self::LineStrip),
            x if x == Self::TriangleList.bits() => Some(Self::TriangleList),
            x if x == Self::TriangleStrip.bits() => Some(Self::TriangleStrip),
            x if x == Self::TriangleFan.bits() => Some(Self::TriangleFan),
            x if x == Self::LineListWithAdjacency.bits() => Some(Self::LineListWithAdjacency),
            x if x == Self::LineStripWithAdjacency.bits() => Some(Self::LineStripWithAdjacency),
            x if x == Self::TriangleListWithAdjacency.bits() => Some(Self::TriangleListWithAdjacency),
            x if x == Self::TriangleStripWithAdjacency.bits() => Some(Self::TriangleStripWithAdjacency),
            x if x == Self::PatchList.bits() => Some(Self::PatchList),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: i32) -> Self {
        std::mem::transmute(bits)
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for PrimitiveTopology {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for PrimitiveTopology {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkSharingMode")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub enum SharingMode {
    #[doc(alias = "VK_SHARING_MODE_EXCLUSIVE")]
    Exclusive = 0,
    #[doc(alias = "VK_SHARING_MODE_CONCURRENT")]
    Concurrent = 1,
}
impl Default for SharingMode {
    #[inline]
    fn default() -> Self {
        Self::empty()
    }
}
impl SharingMode {
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        unsafe { Self::from_bits_unchecked(0) }
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> i32 {
        *self as i32
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: i32) -> Option<Self> {
        match bits {
            x if x == Self::Exclusive.bits() => Some(Self::Exclusive),
            x if x == Self::Concurrent.bits() => Some(Self::Concurrent),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: i32) -> Self {
        std::mem::transmute(bits)
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for SharingMode {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for SharingMode {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkIndexType")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub enum IndexType {
    #[doc(alias = "VK_INDEX_TYPE_UINT16")]
    Uint16 = 0,
    #[doc(alias = "VK_INDEX_TYPE_UINT32")]
    Uint32 = 1,
    #[doc(alias = "VK_INDEX_TYPE_NONE_KHR")]
    #[doc(alias = "VK_INDEX_TYPE_NONE_NV")]
    #[cfg(feature = "VK_KHR_acceleration_structure")]
    NoneKhr = 1000165000,
    #[doc(alias = "VK_INDEX_TYPE_UINT8_EXT")]
    #[cfg(feature = "VK_EXT_index_type_uint8")]
    Uint8Ext = 1000265000,
}
impl Default for IndexType {
    #[inline]
    fn default() -> Self {
        Self::empty()
    }
}
impl IndexType {
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        unsafe { Self::from_bits_unchecked(0) }
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> i32 {
        *self as i32
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: i32) -> Option<Self> {
        match bits {
            x if x == Self::Uint16.bits() => Some(Self::Uint16),
            x if x == Self::Uint32.bits() => Some(Self::Uint32),
            #[cfg(feature = "VK_KHR_acceleration_structure")]
            x if x == Self::NoneKhr.bits() => Some(Self::NoneKhr),
            #[cfg(feature = "VK_EXT_index_type_uint8")]
            x if x == Self::Uint8Ext.bits() => Some(Self::Uint8Ext),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: i32) -> Self {
        std::mem::transmute(bits)
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for IndexType {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for IndexType {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkFilter")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub enum Filter {
    #[doc(alias = "VK_FILTER_NEAREST")]
    Nearest = 0,
    #[doc(alias = "VK_FILTER_LINEAR")]
    Linear = 1,
    #[doc(alias = "VK_FILTER_CUBIC_IMG")]
    #[doc(alias = "VK_FILTER_CUBIC_EXT")]
    #[cfg(feature = "VK_IMG_filter_cubic")]
    CubicImg = 1000015000,
}
impl Default for Filter {
    #[inline]
    fn default() -> Self {
        Self::empty()
    }
}
impl Filter {
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        unsafe { Self::from_bits_unchecked(0) }
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> i32 {
        *self as i32
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: i32) -> Option<Self> {
        match bits {
            x if x == Self::Nearest.bits() => Some(Self::Nearest),
            x if x == Self::Linear.bits() => Some(Self::Linear),
            #[cfg(feature = "VK_IMG_filter_cubic")]
            x if x == Self::CubicImg.bits() => Some(Self::CubicImg),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: i32) -> Self {
        std::mem::transmute(bits)
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for Filter {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for Filter {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkSamplerMipmapMode")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub enum SamplerMipmapMode {
    #[doc(alias = "VK_SAMPLER_MIPMAP_MODE_NEAREST")]
    Nearest = 0,
    #[doc(alias = "VK_SAMPLER_MIPMAP_MODE_LINEAR")]
    Linear = 1,
}
impl Default for SamplerMipmapMode {
    #[inline]
    fn default() -> Self {
        Self::empty()
    }
}
impl SamplerMipmapMode {
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        unsafe { Self::from_bits_unchecked(0) }
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> i32 {
        *self as i32
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: i32) -> Option<Self> {
        match bits {
            x if x == Self::Nearest.bits() => Some(Self::Nearest),
            x if x == Self::Linear.bits() => Some(Self::Linear),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: i32) -> Self {
        std::mem::transmute(bits)
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for SamplerMipmapMode {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for SamplerMipmapMode {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkSamplerAddressMode")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub enum SamplerAddressMode {
    #[doc(alias = "VK_SAMPLER_ADDRESS_MODE_REPEAT")]
    Repeat = 0,
    #[doc(alias = "VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT")]
    MirroredRepeat = 1,
    #[doc(alias = "VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE")]
    ClampToEdge = 2,
    #[doc(alias = "VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER")]
    ClampToBorder = 3,
    #[doc(alias = "VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE")]
    #[doc(alias = "VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE_KHR")]
    #[cfg(feature = "VK_KHR_sampler_mirror_clamp_to_edge")]
    MirrorClampToEdge = 4,
}
impl Default for SamplerAddressMode {
    #[inline]
    fn default() -> Self {
        Self::empty()
    }
}
impl SamplerAddressMode {
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        unsafe { Self::from_bits_unchecked(0) }
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> i32 {
        *self as i32
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: i32) -> Option<Self> {
        match bits {
            x if x == Self::Repeat.bits() => Some(Self::Repeat),
            x if x == Self::MirroredRepeat.bits() => Some(Self::MirroredRepeat),
            x if x == Self::ClampToEdge.bits() => Some(Self::ClampToEdge),
            x if x == Self::ClampToBorder.bits() => Some(Self::ClampToBorder),
            #[cfg(feature = "VK_KHR_sampler_mirror_clamp_to_edge")]
            x if x == Self::MirrorClampToEdge.bits() => Some(Self::MirrorClampToEdge),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: i32) -> Self {
        std::mem::transmute(bits)
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for SamplerAddressMode {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for SamplerAddressMode {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkCompareOp")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub enum CompareOp {
    #[doc(alias = "VK_COMPARE_OP_NEVER")]
    Never = 0,
    #[doc(alias = "VK_COMPARE_OP_LESS")]
    Less = 1,
    #[doc(alias = "VK_COMPARE_OP_EQUAL")]
    Equal = 2,
    #[doc(alias = "VK_COMPARE_OP_LESS_OR_EQUAL")]
    LessOrEqual = 3,
    #[doc(alias = "VK_COMPARE_OP_GREATER")]
    Greater = 4,
    #[doc(alias = "VK_COMPARE_OP_NOT_EQUAL")]
    NotEqual = 5,
    #[doc(alias = "VK_COMPARE_OP_GREATER_OR_EQUAL")]
    GreaterOrEqual = 6,
    #[doc(alias = "VK_COMPARE_OP_ALWAYS")]
    Always = 7,
}
impl Default for CompareOp {
    #[inline]
    fn default() -> Self {
        Self::empty()
    }
}
impl CompareOp {
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        unsafe { Self::from_bits_unchecked(0) }
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> i32 {
        *self as i32
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: i32) -> Option<Self> {
        match bits {
            x if x == Self::Never.bits() => Some(Self::Never),
            x if x == Self::Less.bits() => Some(Self::Less),
            x if x == Self::Equal.bits() => Some(Self::Equal),
            x if x == Self::LessOrEqual.bits() => Some(Self::LessOrEqual),
            x if x == Self::Greater.bits() => Some(Self::Greater),
            x if x == Self::NotEqual.bits() => Some(Self::NotEqual),
            x if x == Self::GreaterOrEqual.bits() => Some(Self::GreaterOrEqual),
            x if x == Self::Always.bits() => Some(Self::Always),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: i32) -> Self {
        std::mem::transmute(bits)
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for CompareOp {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for CompareOp {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkPolygonMode")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub enum PolygonMode {
    #[doc(alias = "VK_POLYGON_MODE_FILL")]
    Fill = 0,
    #[doc(alias = "VK_POLYGON_MODE_LINE")]
    Line = 1,
    #[doc(alias = "VK_POLYGON_MODE_POINT")]
    Point = 2,
    #[doc(alias = "VK_POLYGON_MODE_FILL_RECTANGLE_NV")]
    #[cfg(feature = "VK_NV_fill_rectangle")]
    FillRectangleNv = 1000153000,
}
impl Default for PolygonMode {
    #[inline]
    fn default() -> Self {
        Self::empty()
    }
}
impl PolygonMode {
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        unsafe { Self::from_bits_unchecked(0) }
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> i32 {
        *self as i32
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: i32) -> Option<Self> {
        match bits {
            x if x == Self::Fill.bits() => Some(Self::Fill),
            x if x == Self::Line.bits() => Some(Self::Line),
            x if x == Self::Point.bits() => Some(Self::Point),
            #[cfg(feature = "VK_NV_fill_rectangle")]
            x if x == Self::FillRectangleNv.bits() => Some(Self::FillRectangleNv),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: i32) -> Self {
        std::mem::transmute(bits)
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for PolygonMode {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for PolygonMode {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkFrontFace")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub enum FrontFace {
    #[doc(alias = "VK_FRONT_FACE_COUNTER_CLOCKWISE")]
    CounterClockwise = 0,
    #[doc(alias = "VK_FRONT_FACE_CLOCKWISE")]
    Clockwise = 1,
}
impl Default for FrontFace {
    #[inline]
    fn default() -> Self {
        Self::empty()
    }
}
impl FrontFace {
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        unsafe { Self::from_bits_unchecked(0) }
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> i32 {
        *self as i32
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: i32) -> Option<Self> {
        match bits {
            x if x == Self::CounterClockwise.bits() => Some(Self::CounterClockwise),
            x if x == Self::Clockwise.bits() => Some(Self::Clockwise),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: i32) -> Self {
        std::mem::transmute(bits)
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for FrontFace {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for FrontFace {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkBlendFactor")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub enum BlendFactor {
    #[doc(alias = "VK_BLEND_FACTOR_ZERO")]
    Zero = 0,
    #[doc(alias = "VK_BLEND_FACTOR_ONE")]
    One = 1,
    #[doc(alias = "VK_BLEND_FACTOR_SRC_COLOR")]
    SrcColor = 2,
    #[doc(alias = "VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR")]
    OneMinusSrcColor = 3,
    #[doc(alias = "VK_BLEND_FACTOR_DST_COLOR")]
    DstColor = 4,
    #[doc(alias = "VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR")]
    OneMinusDstColor = 5,
    #[doc(alias = "VK_BLEND_FACTOR_SRC_ALPHA")]
    SrcAlpha = 6,
    #[doc(alias = "VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA")]
    OneMinusSrcAlpha = 7,
    #[doc(alias = "VK_BLEND_FACTOR_DST_ALPHA")]
    DstAlpha = 8,
    #[doc(alias = "VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA")]
    OneMinusDstAlpha = 9,
    #[doc(alias = "VK_BLEND_FACTOR_CONSTANT_COLOR")]
    ConstantColor = 10,
    #[doc(alias = "VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR")]
    OneMinusConstantColor = 11,
    #[doc(alias = "VK_BLEND_FACTOR_CONSTANT_ALPHA")]
    ConstantAlpha = 12,
    #[doc(alias = "VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA")]
    OneMinusConstantAlpha = 13,
    #[doc(alias = "VK_BLEND_FACTOR_SRC_ALPHA_SATURATE")]
    SrcAlphaSaturate = 14,
    #[doc(alias = "VK_BLEND_FACTOR_SRC1_COLOR")]
    Src1Color = 15,
    #[doc(alias = "VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR")]
    OneMinusSrc1Color = 16,
    #[doc(alias = "VK_BLEND_FACTOR_SRC1_ALPHA")]
    Src1Alpha = 17,
    #[doc(alias = "VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA")]
    OneMinusSrc1Alpha = 18,
}
impl Default for BlendFactor {
    #[inline]
    fn default() -> Self {
        Self::empty()
    }
}
impl BlendFactor {
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        unsafe { Self::from_bits_unchecked(0) }
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> i32 {
        *self as i32
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: i32) -> Option<Self> {
        match bits {
            x if x == Self::Zero.bits() => Some(Self::Zero),
            x if x == Self::One.bits() => Some(Self::One),
            x if x == Self::SrcColor.bits() => Some(Self::SrcColor),
            x if x == Self::OneMinusSrcColor.bits() => Some(Self::OneMinusSrcColor),
            x if x == Self::DstColor.bits() => Some(Self::DstColor),
            x if x == Self::OneMinusDstColor.bits() => Some(Self::OneMinusDstColor),
            x if x == Self::SrcAlpha.bits() => Some(Self::SrcAlpha),
            x if x == Self::OneMinusSrcAlpha.bits() => Some(Self::OneMinusSrcAlpha),
            x if x == Self::DstAlpha.bits() => Some(Self::DstAlpha),
            x if x == Self::OneMinusDstAlpha.bits() => Some(Self::OneMinusDstAlpha),
            x if x == Self::ConstantColor.bits() => Some(Self::ConstantColor),
            x if x == Self::OneMinusConstantColor.bits() => Some(Self::OneMinusConstantColor),
            x if x == Self::ConstantAlpha.bits() => Some(Self::ConstantAlpha),
            x if x == Self::OneMinusConstantAlpha.bits() => Some(Self::OneMinusConstantAlpha),
            x if x == Self::SrcAlphaSaturate.bits() => Some(Self::SrcAlphaSaturate),
            x if x == Self::Src1Color.bits() => Some(Self::Src1Color),
            x if x == Self::OneMinusSrc1Color.bits() => Some(Self::OneMinusSrc1Color),
            x if x == Self::Src1Alpha.bits() => Some(Self::Src1Alpha),
            x if x == Self::OneMinusSrc1Alpha.bits() => Some(Self::OneMinusSrc1Alpha),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: i32) -> Self {
        std::mem::transmute(bits)
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for BlendFactor {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for BlendFactor {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkBlendOp")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub enum BlendOp {
    #[doc(alias = "VK_BLEND_OP_ADD")]
    Add = 0,
    #[doc(alias = "VK_BLEND_OP_SUBTRACT")]
    Subtract = 1,
    #[doc(alias = "VK_BLEND_OP_REVERSE_SUBTRACT")]
    ReverseSubtract = 2,
    #[doc(alias = "VK_BLEND_OP_MIN")]
    Min = 3,
    #[doc(alias = "VK_BLEND_OP_MAX")]
    Max = 4,
    #[doc(alias = "VK_BLEND_OP_ZERO_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    ZeroExt = 1000148000,
    #[doc(alias = "VK_BLEND_OP_SRC_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    SrcExt = 1000148001,
    #[doc(alias = "VK_BLEND_OP_DST_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    DstExt = 1000148002,
    #[doc(alias = "VK_BLEND_OP_SRC_OVER_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    SrcOverExt = 1000148003,
    #[doc(alias = "VK_BLEND_OP_DST_OVER_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    DstOverExt = 1000148004,
    #[doc(alias = "VK_BLEND_OP_SRC_IN_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    SrcInExt = 1000148005,
    #[doc(alias = "VK_BLEND_OP_DST_IN_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    DstInExt = 1000148006,
    #[doc(alias = "VK_BLEND_OP_SRC_OUT_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    SrcOutExt = 1000148007,
    #[doc(alias = "VK_BLEND_OP_DST_OUT_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    DstOutExt = 1000148008,
    #[doc(alias = "VK_BLEND_OP_SRC_ATOP_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    SrcAtopExt = 1000148009,
    #[doc(alias = "VK_BLEND_OP_DST_ATOP_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    DstAtopExt = 1000148010,
    #[doc(alias = "VK_BLEND_OP_XOR_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    XorExt = 1000148011,
    #[doc(alias = "VK_BLEND_OP_MULTIPLY_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    MultiplyExt = 1000148012,
    #[doc(alias = "VK_BLEND_OP_SCREEN_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    ScreenExt = 1000148013,
    #[doc(alias = "VK_BLEND_OP_OVERLAY_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    OverlayExt = 1000148014,
    #[doc(alias = "VK_BLEND_OP_DARKEN_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    DarkenExt = 1000148015,
    #[doc(alias = "VK_BLEND_OP_LIGHTEN_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    LightenExt = 1000148016,
    #[doc(alias = "VK_BLEND_OP_COLORDODGE_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    ColordodgeExt = 1000148017,
    #[doc(alias = "VK_BLEND_OP_COLORBURN_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    ColorburnExt = 1000148018,
    #[doc(alias = "VK_BLEND_OP_HARDLIGHT_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    HardlightExt = 1000148019,
    #[doc(alias = "VK_BLEND_OP_SOFTLIGHT_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    SoftlightExt = 1000148020,
    #[doc(alias = "VK_BLEND_OP_DIFFERENCE_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    DifferenceExt = 1000148021,
    #[doc(alias = "VK_BLEND_OP_EXCLUSION_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    ExclusionExt = 1000148022,
    #[doc(alias = "VK_BLEND_OP_INVERT_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    InvertExt = 1000148023,
    #[doc(alias = "VK_BLEND_OP_INVERT_RGB_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    InvertRgbExt = 1000148024,
    #[doc(alias = "VK_BLEND_OP_LINEARDODGE_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    LineardodgeExt = 1000148025,
    #[doc(alias = "VK_BLEND_OP_LINEARBURN_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    LinearburnExt = 1000148026,
    #[doc(alias = "VK_BLEND_OP_VIVIDLIGHT_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    VividlightExt = 1000148027,
    #[doc(alias = "VK_BLEND_OP_LINEARLIGHT_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    LinearlightExt = 1000148028,
    #[doc(alias = "VK_BLEND_OP_PINLIGHT_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    PinlightExt = 1000148029,
    #[doc(alias = "VK_BLEND_OP_HARDMIX_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    HardmixExt = 1000148030,
    #[doc(alias = "VK_BLEND_OP_HSL_HUE_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    HslHueExt = 1000148031,
    #[doc(alias = "VK_BLEND_OP_HSL_SATURATION_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    HslSaturationExt = 1000148032,
    #[doc(alias = "VK_BLEND_OP_HSL_COLOR_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    HslColorExt = 1000148033,
    #[doc(alias = "VK_BLEND_OP_HSL_LUMINOSITY_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    HslLuminosityExt = 1000148034,
    #[doc(alias = "VK_BLEND_OP_PLUS_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    PlusExt = 1000148035,
    #[doc(alias = "VK_BLEND_OP_PLUS_CLAMPED_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    PlusClampedExt = 1000148036,
    #[doc(alias = "VK_BLEND_OP_PLUS_CLAMPED_ALPHA_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    PlusClampedAlphaExt = 1000148037,
    #[doc(alias = "VK_BLEND_OP_PLUS_DARKER_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    PlusDarkerExt = 1000148038,
    #[doc(alias = "VK_BLEND_OP_MINUS_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    MinusExt = 1000148039,
    #[doc(alias = "VK_BLEND_OP_MINUS_CLAMPED_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    MinusClampedExt = 1000148040,
    #[doc(alias = "VK_BLEND_OP_CONTRAST_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    ContrastExt = 1000148041,
    #[doc(alias = "VK_BLEND_OP_INVERT_OVG_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    InvertOvgExt = 1000148042,
    #[doc(alias = "VK_BLEND_OP_RED_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    RedExt = 1000148043,
    #[doc(alias = "VK_BLEND_OP_GREEN_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    GreenExt = 1000148044,
    #[doc(alias = "VK_BLEND_OP_BLUE_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    BlueExt = 1000148045,
}
impl Default for BlendOp {
    #[inline]
    fn default() -> Self {
        Self::empty()
    }
}
impl BlendOp {
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        unsafe { Self::from_bits_unchecked(0) }
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> i32 {
        *self as i32
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: i32) -> Option<Self> {
        match bits {
            x if x == Self::Add.bits() => Some(Self::Add),
            x if x == Self::Subtract.bits() => Some(Self::Subtract),
            x if x == Self::ReverseSubtract.bits() => Some(Self::ReverseSubtract),
            x if x == Self::Min.bits() => Some(Self::Min),
            x if x == Self::Max.bits() => Some(Self::Max),
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::ZeroExt.bits() => Some(Self::ZeroExt),
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::SrcExt.bits() => Some(Self::SrcExt),
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::DstExt.bits() => Some(Self::DstExt),
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::SrcOverExt.bits() => Some(Self::SrcOverExt),
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::DstOverExt.bits() => Some(Self::DstOverExt),
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::SrcInExt.bits() => Some(Self::SrcInExt),
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::DstInExt.bits() => Some(Self::DstInExt),
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::SrcOutExt.bits() => Some(Self::SrcOutExt),
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::DstOutExt.bits() => Some(Self::DstOutExt),
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::SrcAtopExt.bits() => Some(Self::SrcAtopExt),
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::DstAtopExt.bits() => Some(Self::DstAtopExt),
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::XorExt.bits() => Some(Self::XorExt),
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::MultiplyExt.bits() => Some(Self::MultiplyExt),
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::ScreenExt.bits() => Some(Self::ScreenExt),
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::OverlayExt.bits() => Some(Self::OverlayExt),
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::DarkenExt.bits() => Some(Self::DarkenExt),
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::LightenExt.bits() => Some(Self::LightenExt),
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::ColordodgeExt.bits() => Some(Self::ColordodgeExt),
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::ColorburnExt.bits() => Some(Self::ColorburnExt),
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::HardlightExt.bits() => Some(Self::HardlightExt),
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::SoftlightExt.bits() => Some(Self::SoftlightExt),
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::DifferenceExt.bits() => Some(Self::DifferenceExt),
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::ExclusionExt.bits() => Some(Self::ExclusionExt),
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::InvertExt.bits() => Some(Self::InvertExt),
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::InvertRgbExt.bits() => Some(Self::InvertRgbExt),
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::LineardodgeExt.bits() => Some(Self::LineardodgeExt),
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::LinearburnExt.bits() => Some(Self::LinearburnExt),
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::VividlightExt.bits() => Some(Self::VividlightExt),
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::LinearlightExt.bits() => Some(Self::LinearlightExt),
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::PinlightExt.bits() => Some(Self::PinlightExt),
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::HardmixExt.bits() => Some(Self::HardmixExt),
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::HslHueExt.bits() => Some(Self::HslHueExt),
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::HslSaturationExt.bits() => Some(Self::HslSaturationExt),
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::HslColorExt.bits() => Some(Self::HslColorExt),
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::HslLuminosityExt.bits() => Some(Self::HslLuminosityExt),
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::PlusExt.bits() => Some(Self::PlusExt),
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::PlusClampedExt.bits() => Some(Self::PlusClampedExt),
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::PlusClampedAlphaExt.bits() => Some(Self::PlusClampedAlphaExt),
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::PlusDarkerExt.bits() => Some(Self::PlusDarkerExt),
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::MinusExt.bits() => Some(Self::MinusExt),
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::MinusClampedExt.bits() => Some(Self::MinusClampedExt),
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::ContrastExt.bits() => Some(Self::ContrastExt),
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::InvertOvgExt.bits() => Some(Self::InvertOvgExt),
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::RedExt.bits() => Some(Self::RedExt),
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::GreenExt.bits() => Some(Self::GreenExt),
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::BlueExt.bits() => Some(Self::BlueExt),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: i32) -> Self {
        std::mem::transmute(bits)
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for BlendOp {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for BlendOp {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkStencilOp")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub enum StencilOp {
    #[doc(alias = "VK_STENCIL_OP_KEEP")]
    Keep = 0,
    #[doc(alias = "VK_STENCIL_OP_ZERO")]
    Zero = 1,
    #[doc(alias = "VK_STENCIL_OP_REPLACE")]
    Replace = 2,
    #[doc(alias = "VK_STENCIL_OP_INCREMENT_AND_CLAMP")]
    IncrementAndClamp = 3,
    #[doc(alias = "VK_STENCIL_OP_DECREMENT_AND_CLAMP")]
    DecrementAndClamp = 4,
    #[doc(alias = "VK_STENCIL_OP_INVERT")]
    Invert = 5,
    #[doc(alias = "VK_STENCIL_OP_INCREMENT_AND_WRAP")]
    IncrementAndWrap = 6,
    #[doc(alias = "VK_STENCIL_OP_DECREMENT_AND_WRAP")]
    DecrementAndWrap = 7,
}
impl Default for StencilOp {
    #[inline]
    fn default() -> Self {
        Self::empty()
    }
}
impl StencilOp {
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        unsafe { Self::from_bits_unchecked(0) }
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> i32 {
        *self as i32
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: i32) -> Option<Self> {
        match bits {
            x if x == Self::Keep.bits() => Some(Self::Keep),
            x if x == Self::Zero.bits() => Some(Self::Zero),
            x if x == Self::Replace.bits() => Some(Self::Replace),
            x if x == Self::IncrementAndClamp.bits() => Some(Self::IncrementAndClamp),
            x if x == Self::DecrementAndClamp.bits() => Some(Self::DecrementAndClamp),
            x if x == Self::Invert.bits() => Some(Self::Invert),
            x if x == Self::IncrementAndWrap.bits() => Some(Self::IncrementAndWrap),
            x if x == Self::DecrementAndWrap.bits() => Some(Self::DecrementAndWrap),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: i32) -> Self {
        std::mem::transmute(bits)
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for StencilOp {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for StencilOp {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkLogicOp")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub enum LogicOp {
    #[doc(alias = "VK_LOGIC_OP_CLEAR")]
    Clear = 0,
    #[doc(alias = "VK_LOGIC_OP_AND")]
    And = 1,
    #[doc(alias = "VK_LOGIC_OP_AND_REVERSE")]
    AndReverse = 2,
    #[doc(alias = "VK_LOGIC_OP_COPY")]
    Copy = 3,
    #[doc(alias = "VK_LOGIC_OP_AND_INVERTED")]
    AndInverted = 4,
    #[doc(alias = "VK_LOGIC_OP_NO_OP")]
    NoOp = 5,
    #[doc(alias = "VK_LOGIC_OP_XOR")]
    Xor = 6,
    #[doc(alias = "VK_LOGIC_OP_OR")]
    Or = 7,
    #[doc(alias = "VK_LOGIC_OP_NOR")]
    Nor = 8,
    #[doc(alias = "VK_LOGIC_OP_EQUIVALENT")]
    Equivalent = 9,
    #[doc(alias = "VK_LOGIC_OP_INVERT")]
    Invert = 10,
    #[doc(alias = "VK_LOGIC_OP_OR_REVERSE")]
    OrReverse = 11,
    #[doc(alias = "VK_LOGIC_OP_COPY_INVERTED")]
    CopyInverted = 12,
    #[doc(alias = "VK_LOGIC_OP_OR_INVERTED")]
    OrInverted = 13,
    #[doc(alias = "VK_LOGIC_OP_NAND")]
    Nand = 14,
    #[doc(alias = "VK_LOGIC_OP_SET")]
    Set = 15,
}
impl Default for LogicOp {
    #[inline]
    fn default() -> Self {
        Self::empty()
    }
}
impl LogicOp {
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        unsafe { Self::from_bits_unchecked(0) }
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> i32 {
        *self as i32
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: i32) -> Option<Self> {
        match bits {
            x if x == Self::Clear.bits() => Some(Self::Clear),
            x if x == Self::And.bits() => Some(Self::And),
            x if x == Self::AndReverse.bits() => Some(Self::AndReverse),
            x if x == Self::Copy.bits() => Some(Self::Copy),
            x if x == Self::AndInverted.bits() => Some(Self::AndInverted),
            x if x == Self::NoOp.bits() => Some(Self::NoOp),
            x if x == Self::Xor.bits() => Some(Self::Xor),
            x if x == Self::Or.bits() => Some(Self::Or),
            x if x == Self::Nor.bits() => Some(Self::Nor),
            x if x == Self::Equivalent.bits() => Some(Self::Equivalent),
            x if x == Self::Invert.bits() => Some(Self::Invert),
            x if x == Self::OrReverse.bits() => Some(Self::OrReverse),
            x if x == Self::CopyInverted.bits() => Some(Self::CopyInverted),
            x if x == Self::OrInverted.bits() => Some(Self::OrInverted),
            x if x == Self::Nand.bits() => Some(Self::Nand),
            x if x == Self::Set.bits() => Some(Self::Set),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: i32) -> Self {
        std::mem::transmute(bits)
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for LogicOp {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for LogicOp {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkInternalAllocationType")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub enum InternalAllocationType {
    #[doc(alias = "VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE")]
    Executable = 0,
}
impl Default for InternalAllocationType {
    #[inline]
    fn default() -> Self {
        Self::empty()
    }
}
impl InternalAllocationType {
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        unsafe { Self::from_bits_unchecked(0) }
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> i32 {
        *self as i32
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: i32) -> Option<Self> {
        match bits {
            x if x == Self::Executable.bits() => Some(Self::Executable),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: i32) -> Self {
        std::mem::transmute(bits)
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for InternalAllocationType {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for InternalAllocationType {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkSystemAllocationScope")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub enum SystemAllocationScope {
    #[doc(alias = "VK_SYSTEM_ALLOCATION_SCOPE_COMMAND")]
    Command = 0,
    #[doc(alias = "VK_SYSTEM_ALLOCATION_SCOPE_OBJECT")]
    Object = 1,
    #[doc(alias = "VK_SYSTEM_ALLOCATION_SCOPE_CACHE")]
    Cache = 2,
    #[doc(alias = "VK_SYSTEM_ALLOCATION_SCOPE_DEVICE")]
    Device = 3,
    #[doc(alias = "VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE")]
    Instance = 4,
}
impl Default for SystemAllocationScope {
    #[inline]
    fn default() -> Self {
        Self::empty()
    }
}
impl SystemAllocationScope {
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        unsafe { Self::from_bits_unchecked(0) }
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> i32 {
        *self as i32
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: i32) -> Option<Self> {
        match bits {
            x if x == Self::Command.bits() => Some(Self::Command),
            x if x == Self::Object.bits() => Some(Self::Object),
            x if x == Self::Cache.bits() => Some(Self::Cache),
            x if x == Self::Device.bits() => Some(Self::Device),
            x if x == Self::Instance.bits() => Some(Self::Instance),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: i32) -> Self {
        std::mem::transmute(bits)
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for SystemAllocationScope {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for SystemAllocationScope {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkPhysicalDeviceType")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub enum PhysicalDeviceType {
    #[doc(alias = "VK_PHYSICAL_DEVICE_TYPE_OTHER")]
    Other = 0,
    #[doc(alias = "VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU")]
    IntegratedGpu = 1,
    #[doc(alias = "VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU")]
    DiscreteGpu = 2,
    #[doc(alias = "VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU")]
    VirtualGpu = 3,
    #[doc(alias = "VK_PHYSICAL_DEVICE_TYPE_CPU")]
    Cpu = 4,
}
impl Default for PhysicalDeviceType {
    #[inline]
    fn default() -> Self {
        Self::empty()
    }
}
impl PhysicalDeviceType {
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        unsafe { Self::from_bits_unchecked(0) }
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> i32 {
        *self as i32
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: i32) -> Option<Self> {
        match bits {
            x if x == Self::Other.bits() => Some(Self::Other),
            x if x == Self::IntegratedGpu.bits() => Some(Self::IntegratedGpu),
            x if x == Self::DiscreteGpu.bits() => Some(Self::DiscreteGpu),
            x if x == Self::VirtualGpu.bits() => Some(Self::VirtualGpu),
            x if x == Self::Cpu.bits() => Some(Self::Cpu),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: i32) -> Self {
        std::mem::transmute(bits)
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for PhysicalDeviceType {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for PhysicalDeviceType {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkVertexInputRate")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub enum VertexInputRate {
    #[doc(alias = "VK_VERTEX_INPUT_RATE_VERTEX")]
    Vertex = 0,
    #[doc(alias = "VK_VERTEX_INPUT_RATE_INSTANCE")]
    Instance = 1,
}
impl Default for VertexInputRate {
    #[inline]
    fn default() -> Self {
        Self::empty()
    }
}
impl VertexInputRate {
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        unsafe { Self::from_bits_unchecked(0) }
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> i32 {
        *self as i32
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: i32) -> Option<Self> {
        match bits {
            x if x == Self::Vertex.bits() => Some(Self::Vertex),
            x if x == Self::Instance.bits() => Some(Self::Instance),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: i32) -> Self {
        std::mem::transmute(bits)
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for VertexInputRate {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for VertexInputRate {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkFormat")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub enum Format {
    #[doc(alias = "VK_FORMAT_UNDEFINED")]
    Undefined = 0,
    #[doc(alias = "VK_FORMAT_R4G4_UNORM_PACK8")]
    R4g4UnormPack8 = 1,
    #[doc(alias = "VK_FORMAT_R4G4B4A4_UNORM_PACK16")]
    R4g4b4a4UnormPack16 = 2,
    #[doc(alias = "VK_FORMAT_B4G4R4A4_UNORM_PACK16")]
    B4g4r4a4UnormPack16 = 3,
    #[doc(alias = "VK_FORMAT_R5G6B5_UNORM_PACK16")]
    R5g6b5UnormPack16 = 4,
    #[doc(alias = "VK_FORMAT_B5G6R5_UNORM_PACK16")]
    B5g6r5UnormPack16 = 5,
    #[doc(alias = "VK_FORMAT_R5G5B5A1_UNORM_PACK16")]
    R5g5b5a1UnormPack16 = 6,
    #[doc(alias = "VK_FORMAT_B5G5R5A1_UNORM_PACK16")]
    B5g5r5a1UnormPack16 = 7,
    #[doc(alias = "VK_FORMAT_A1R5G5B5_UNORM_PACK16")]
    A1r5g5b5UnormPack16 = 8,
    #[doc(alias = "VK_FORMAT_R8_UNORM")]
    R8Unorm = 9,
    #[doc(alias = "VK_FORMAT_R8_SNORM")]
    R8Snorm = 10,
    #[doc(alias = "VK_FORMAT_R8_USCALED")]
    R8Uscaled = 11,
    #[doc(alias = "VK_FORMAT_R8_SSCALED")]
    R8Sscaled = 12,
    #[doc(alias = "VK_FORMAT_R8_UINT")]
    R8Uint = 13,
    #[doc(alias = "VK_FORMAT_R8_SINT")]
    R8Sint = 14,
    #[doc(alias = "VK_FORMAT_R8_SRGB")]
    R8Srgb = 15,
    #[doc(alias = "VK_FORMAT_R8G8_UNORM")]
    R8g8Unorm = 16,
    #[doc(alias = "VK_FORMAT_R8G8_SNORM")]
    R8g8Snorm = 17,
    #[doc(alias = "VK_FORMAT_R8G8_USCALED")]
    R8g8Uscaled = 18,
    #[doc(alias = "VK_FORMAT_R8G8_SSCALED")]
    R8g8Sscaled = 19,
    #[doc(alias = "VK_FORMAT_R8G8_UINT")]
    R8g8Uint = 20,
    #[doc(alias = "VK_FORMAT_R8G8_SINT")]
    R8g8Sint = 21,
    #[doc(alias = "VK_FORMAT_R8G8_SRGB")]
    R8g8Srgb = 22,
    #[doc(alias = "VK_FORMAT_R8G8B8_UNORM")]
    R8g8b8Unorm = 23,
    #[doc(alias = "VK_FORMAT_R8G8B8_SNORM")]
    R8g8b8Snorm = 24,
    #[doc(alias = "VK_FORMAT_R8G8B8_USCALED")]
    R8g8b8Uscaled = 25,
    #[doc(alias = "VK_FORMAT_R8G8B8_SSCALED")]
    R8g8b8Sscaled = 26,
    #[doc(alias = "VK_FORMAT_R8G8B8_UINT")]
    R8g8b8Uint = 27,
    #[doc(alias = "VK_FORMAT_R8G8B8_SINT")]
    R8g8b8Sint = 28,
    #[doc(alias = "VK_FORMAT_R8G8B8_SRGB")]
    R8g8b8Srgb = 29,
    #[doc(alias = "VK_FORMAT_B8G8R8_UNORM")]
    B8g8r8Unorm = 30,
    #[doc(alias = "VK_FORMAT_B8G8R8_SNORM")]
    B8g8r8Snorm = 31,
    #[doc(alias = "VK_FORMAT_B8G8R8_USCALED")]
    B8g8r8Uscaled = 32,
    #[doc(alias = "VK_FORMAT_B8G8R8_SSCALED")]
    B8g8r8Sscaled = 33,
    #[doc(alias = "VK_FORMAT_B8G8R8_UINT")]
    B8g8r8Uint = 34,
    #[doc(alias = "VK_FORMAT_B8G8R8_SINT")]
    B8g8r8Sint = 35,
    #[doc(alias = "VK_FORMAT_B8G8R8_SRGB")]
    B8g8r8Srgb = 36,
    #[doc(alias = "VK_FORMAT_R8G8B8A8_UNORM")]
    R8g8b8a8Unorm = 37,
    #[doc(alias = "VK_FORMAT_R8G8B8A8_SNORM")]
    R8g8b8a8Snorm = 38,
    #[doc(alias = "VK_FORMAT_R8G8B8A8_USCALED")]
    R8g8b8a8Uscaled = 39,
    #[doc(alias = "VK_FORMAT_R8G8B8A8_SSCALED")]
    R8g8b8a8Sscaled = 40,
    #[doc(alias = "VK_FORMAT_R8G8B8A8_UINT")]
    R8g8b8a8Uint = 41,
    #[doc(alias = "VK_FORMAT_R8G8B8A8_SINT")]
    R8g8b8a8Sint = 42,
    #[doc(alias = "VK_FORMAT_R8G8B8A8_SRGB")]
    R8g8b8a8Srgb = 43,
    #[doc(alias = "VK_FORMAT_B8G8R8A8_UNORM")]
    B8g8r8a8Unorm = 44,
    #[doc(alias = "VK_FORMAT_B8G8R8A8_SNORM")]
    B8g8r8a8Snorm = 45,
    #[doc(alias = "VK_FORMAT_B8G8R8A8_USCALED")]
    B8g8r8a8Uscaled = 46,
    #[doc(alias = "VK_FORMAT_B8G8R8A8_SSCALED")]
    B8g8r8a8Sscaled = 47,
    #[doc(alias = "VK_FORMAT_B8G8R8A8_UINT")]
    B8g8r8a8Uint = 48,
    #[doc(alias = "VK_FORMAT_B8G8R8A8_SINT")]
    B8g8r8a8Sint = 49,
    #[doc(alias = "VK_FORMAT_B8G8R8A8_SRGB")]
    B8g8r8a8Srgb = 50,
    #[doc(alias = "VK_FORMAT_A8B8G8R8_UNORM_PACK32")]
    A8b8g8r8UnormPack32 = 51,
    #[doc(alias = "VK_FORMAT_A8B8G8R8_SNORM_PACK32")]
    A8b8g8r8SnormPack32 = 52,
    #[doc(alias = "VK_FORMAT_A8B8G8R8_USCALED_PACK32")]
    A8b8g8r8UscaledPack32 = 53,
    #[doc(alias = "VK_FORMAT_A8B8G8R8_SSCALED_PACK32")]
    A8b8g8r8SscaledPack32 = 54,
    #[doc(alias = "VK_FORMAT_A8B8G8R8_UINT_PACK32")]
    A8b8g8r8UintPack32 = 55,
    #[doc(alias = "VK_FORMAT_A8B8G8R8_SINT_PACK32")]
    A8b8g8r8SintPack32 = 56,
    #[doc(alias = "VK_FORMAT_A8B8G8R8_SRGB_PACK32")]
    A8b8g8r8SrgbPack32 = 57,
    #[doc(alias = "VK_FORMAT_A2R10G10B10_UNORM_PACK32")]
    A2r10g10b10UnormPack32 = 58,
    #[doc(alias = "VK_FORMAT_A2R10G10B10_SNORM_PACK32")]
    A2r10g10b10SnormPack32 = 59,
    #[doc(alias = "VK_FORMAT_A2R10G10B10_USCALED_PACK32")]
    A2r10g10b10UscaledPack32 = 60,
    #[doc(alias = "VK_FORMAT_A2R10G10B10_SSCALED_PACK32")]
    A2r10g10b10SscaledPack32 = 61,
    #[doc(alias = "VK_FORMAT_A2R10G10B10_UINT_PACK32")]
    A2r10g10b10UintPack32 = 62,
    #[doc(alias = "VK_FORMAT_A2R10G10B10_SINT_PACK32")]
    A2r10g10b10SintPack32 = 63,
    #[doc(alias = "VK_FORMAT_A2B10G10R10_UNORM_PACK32")]
    A2b10g10r10UnormPack32 = 64,
    #[doc(alias = "VK_FORMAT_A2B10G10R10_SNORM_PACK32")]
    A2b10g10r10SnormPack32 = 65,
    #[doc(alias = "VK_FORMAT_A2B10G10R10_USCALED_PACK32")]
    A2b10g10r10UscaledPack32 = 66,
    #[doc(alias = "VK_FORMAT_A2B10G10R10_SSCALED_PACK32")]
    A2b10g10r10SscaledPack32 = 67,
    #[doc(alias = "VK_FORMAT_A2B10G10R10_UINT_PACK32")]
    A2b10g10r10UintPack32 = 68,
    #[doc(alias = "VK_FORMAT_A2B10G10R10_SINT_PACK32")]
    A2b10g10r10SintPack32 = 69,
    #[doc(alias = "VK_FORMAT_R16_UNORM")]
    R16Unorm = 70,
    #[doc(alias = "VK_FORMAT_R16_SNORM")]
    R16Snorm = 71,
    #[doc(alias = "VK_FORMAT_R16_USCALED")]
    R16Uscaled = 72,
    #[doc(alias = "VK_FORMAT_R16_SSCALED")]
    R16Sscaled = 73,
    #[doc(alias = "VK_FORMAT_R16_UINT")]
    R16Uint = 74,
    #[doc(alias = "VK_FORMAT_R16_SINT")]
    R16Sint = 75,
    #[doc(alias = "VK_FORMAT_R16_SFLOAT")]
    R16Sfloat = 76,
    #[doc(alias = "VK_FORMAT_R16G16_UNORM")]
    R16g16Unorm = 77,
    #[doc(alias = "VK_FORMAT_R16G16_SNORM")]
    R16g16Snorm = 78,
    #[doc(alias = "VK_FORMAT_R16G16_USCALED")]
    R16g16Uscaled = 79,
    #[doc(alias = "VK_FORMAT_R16G16_SSCALED")]
    R16g16Sscaled = 80,
    #[doc(alias = "VK_FORMAT_R16G16_UINT")]
    R16g16Uint = 81,
    #[doc(alias = "VK_FORMAT_R16G16_SINT")]
    R16g16Sint = 82,
    #[doc(alias = "VK_FORMAT_R16G16_SFLOAT")]
    R16g16Sfloat = 83,
    #[doc(alias = "VK_FORMAT_R16G16B16_UNORM")]
    R16g16b16Unorm = 84,
    #[doc(alias = "VK_FORMAT_R16G16B16_SNORM")]
    R16g16b16Snorm = 85,
    #[doc(alias = "VK_FORMAT_R16G16B16_USCALED")]
    R16g16b16Uscaled = 86,
    #[doc(alias = "VK_FORMAT_R16G16B16_SSCALED")]
    R16g16b16Sscaled = 87,
    #[doc(alias = "VK_FORMAT_R16G16B16_UINT")]
    R16g16b16Uint = 88,
    #[doc(alias = "VK_FORMAT_R16G16B16_SINT")]
    R16g16b16Sint = 89,
    #[doc(alias = "VK_FORMAT_R16G16B16_SFLOAT")]
    R16g16b16Sfloat = 90,
    #[doc(alias = "VK_FORMAT_R16G16B16A16_UNORM")]
    R16g16b16a16Unorm = 91,
    #[doc(alias = "VK_FORMAT_R16G16B16A16_SNORM")]
    R16g16b16a16Snorm = 92,
    #[doc(alias = "VK_FORMAT_R16G16B16A16_USCALED")]
    R16g16b16a16Uscaled = 93,
    #[doc(alias = "VK_FORMAT_R16G16B16A16_SSCALED")]
    R16g16b16a16Sscaled = 94,
    #[doc(alias = "VK_FORMAT_R16G16B16A16_UINT")]
    R16g16b16a16Uint = 95,
    #[doc(alias = "VK_FORMAT_R16G16B16A16_SINT")]
    R16g16b16a16Sint = 96,
    #[doc(alias = "VK_FORMAT_R16G16B16A16_SFLOAT")]
    R16g16b16a16Sfloat = 97,
    #[doc(alias = "VK_FORMAT_R32_UINT")]
    R32Uint = 98,
    #[doc(alias = "VK_FORMAT_R32_SINT")]
    R32Sint = 99,
    #[doc(alias = "VK_FORMAT_R32_SFLOAT")]
    R32Sfloat = 100,
    #[doc(alias = "VK_FORMAT_R32G32_UINT")]
    R32g32Uint = 101,
    #[doc(alias = "VK_FORMAT_R32G32_SINT")]
    R32g32Sint = 102,
    #[doc(alias = "VK_FORMAT_R32G32_SFLOAT")]
    R32g32Sfloat = 103,
    #[doc(alias = "VK_FORMAT_R32G32B32_UINT")]
    R32g32b32Uint = 104,
    #[doc(alias = "VK_FORMAT_R32G32B32_SINT")]
    R32g32b32Sint = 105,
    #[doc(alias = "VK_FORMAT_R32G32B32_SFLOAT")]
    R32g32b32Sfloat = 106,
    #[doc(alias = "VK_FORMAT_R32G32B32A32_UINT")]
    R32g32b32a32Uint = 107,
    #[doc(alias = "VK_FORMAT_R32G32B32A32_SINT")]
    R32g32b32a32Sint = 108,
    #[doc(alias = "VK_FORMAT_R32G32B32A32_SFLOAT")]
    R32g32b32a32Sfloat = 109,
    #[doc(alias = "VK_FORMAT_R64_UINT")]
    R64Uint = 110,
    #[doc(alias = "VK_FORMAT_R64_SINT")]
    R64Sint = 111,
    #[doc(alias = "VK_FORMAT_R64_SFLOAT")]
    R64Sfloat = 112,
    #[doc(alias = "VK_FORMAT_R64G64_UINT")]
    R64g64Uint = 113,
    #[doc(alias = "VK_FORMAT_R64G64_SINT")]
    R64g64Sint = 114,
    #[doc(alias = "VK_FORMAT_R64G64_SFLOAT")]
    R64g64Sfloat = 115,
    #[doc(alias = "VK_FORMAT_R64G64B64_UINT")]
    R64g64b64Uint = 116,
    #[doc(alias = "VK_FORMAT_R64G64B64_SINT")]
    R64g64b64Sint = 117,
    #[doc(alias = "VK_FORMAT_R64G64B64_SFLOAT")]
    R64g64b64Sfloat = 118,
    #[doc(alias = "VK_FORMAT_R64G64B64A64_UINT")]
    R64g64b64a64Uint = 119,
    #[doc(alias = "VK_FORMAT_R64G64B64A64_SINT")]
    R64g64b64a64Sint = 120,
    #[doc(alias = "VK_FORMAT_R64G64B64A64_SFLOAT")]
    R64g64b64a64Sfloat = 121,
    #[doc(alias = "VK_FORMAT_B10G11R11_UFLOAT_PACK32")]
    B10g11r11UfloatPack32 = 122,
    #[doc(alias = "VK_FORMAT_E5B9G9R9_UFLOAT_PACK32")]
    E5b9g9r9UfloatPack32 = 123,
    #[doc(alias = "VK_FORMAT_D16_UNORM")]
    D16Unorm = 124,
    #[doc(alias = "VK_FORMAT_X8_D24_UNORM_PACK32")]
    X8d24UnormPack32 = 125,
    #[doc(alias = "VK_FORMAT_D32_SFLOAT")]
    D32Sfloat = 126,
    #[doc(alias = "VK_FORMAT_S8_UINT")]
    S8Uint = 127,
    #[doc(alias = "VK_FORMAT_D16_UNORM_S8_UINT")]
    D16UnormS8Uint = 128,
    #[doc(alias = "VK_FORMAT_D24_UNORM_S8_UINT")]
    D24UnormS8Uint = 129,
    #[doc(alias = "VK_FORMAT_D32_SFLOAT_S8_UINT")]
    D32SfloatS8Uint = 130,
    #[doc(alias = "VK_FORMAT_BC1_RGB_UNORM_BLOCK")]
    Bc1RgbUnormBlock = 131,
    #[doc(alias = "VK_FORMAT_BC1_RGB_SRGB_BLOCK")]
    Bc1RgbSrgbBlock = 132,
    #[doc(alias = "VK_FORMAT_BC1_RGBA_UNORM_BLOCK")]
    Bc1RgbaUnormBlock = 133,
    #[doc(alias = "VK_FORMAT_BC1_RGBA_SRGB_BLOCK")]
    Bc1RgbaSrgbBlock = 134,
    #[doc(alias = "VK_FORMAT_BC2_UNORM_BLOCK")]
    Bc2UnormBlock = 135,
    #[doc(alias = "VK_FORMAT_BC2_SRGB_BLOCK")]
    Bc2SrgbBlock = 136,
    #[doc(alias = "VK_FORMAT_BC3_UNORM_BLOCK")]
    Bc3UnormBlock = 137,
    #[doc(alias = "VK_FORMAT_BC3_SRGB_BLOCK")]
    Bc3SrgbBlock = 138,
    #[doc(alias = "VK_FORMAT_BC4_UNORM_BLOCK")]
    Bc4UnormBlock = 139,
    #[doc(alias = "VK_FORMAT_BC4_SNORM_BLOCK")]
    Bc4SnormBlock = 140,
    #[doc(alias = "VK_FORMAT_BC5_UNORM_BLOCK")]
    Bc5UnormBlock = 141,
    #[doc(alias = "VK_FORMAT_BC5_SNORM_BLOCK")]
    Bc5SnormBlock = 142,
    #[doc(alias = "VK_FORMAT_BC6H_UFLOAT_BLOCK")]
    Bc6hUfloatBlock = 143,
    #[doc(alias = "VK_FORMAT_BC6H_SFLOAT_BLOCK")]
    Bc6hSfloatBlock = 144,
    #[doc(alias = "VK_FORMAT_BC7_UNORM_BLOCK")]
    Bc7UnormBlock = 145,
    #[doc(alias = "VK_FORMAT_BC7_SRGB_BLOCK")]
    Bc7SrgbBlock = 146,
    #[doc(alias = "VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK")]
    Etc2R8g8b8UnormBlock = 147,
    #[doc(alias = "VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK")]
    Etc2R8g8b8SrgbBlock = 148,
    #[doc(alias = "VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK")]
    Etc2R8g8b8a1UnormBlock = 149,
    #[doc(alias = "VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK")]
    Etc2R8g8b8a1SrgbBlock = 150,
    #[doc(alias = "VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK")]
    Etc2R8g8b8a8UnormBlock = 151,
    #[doc(alias = "VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK")]
    Etc2R8g8b8a8SrgbBlock = 152,
    #[doc(alias = "VK_FORMAT_EAC_R11_UNORM_BLOCK")]
    EacR11UnormBlock = 153,
    #[doc(alias = "VK_FORMAT_EAC_R11_SNORM_BLOCK")]
    EacR11SnormBlock = 154,
    #[doc(alias = "VK_FORMAT_EAC_R11G11_UNORM_BLOCK")]
    EacR11g11UnormBlock = 155,
    #[doc(alias = "VK_FORMAT_EAC_R11G11_SNORM_BLOCK")]
    EacR11g11SnormBlock = 156,
    #[doc(alias = "VK_FORMAT_ASTC_4x4_UNORM_BLOCK")]
    Astc4x4UnormBlock = 157,
    #[doc(alias = "VK_FORMAT_ASTC_4x4_SRGB_BLOCK")]
    Astc4x4SrgbBlock = 158,
    #[doc(alias = "VK_FORMAT_ASTC_5x4_UNORM_BLOCK")]
    Astc5x4UnormBlock = 159,
    #[doc(alias = "VK_FORMAT_ASTC_5x4_SRGB_BLOCK")]
    Astc5x4SrgbBlock = 160,
    #[doc(alias = "VK_FORMAT_ASTC_5x5_UNORM_BLOCK")]
    Astc5x5UnormBlock = 161,
    #[doc(alias = "VK_FORMAT_ASTC_5x5_SRGB_BLOCK")]
    Astc5x5SrgbBlock = 162,
    #[doc(alias = "VK_FORMAT_ASTC_6x5_UNORM_BLOCK")]
    Astc6x5UnormBlock = 163,
    #[doc(alias = "VK_FORMAT_ASTC_6x5_SRGB_BLOCK")]
    Astc6x5SrgbBlock = 164,
    #[doc(alias = "VK_FORMAT_ASTC_6x6_UNORM_BLOCK")]
    Astc6x6UnormBlock = 165,
    #[doc(alias = "VK_FORMAT_ASTC_6x6_SRGB_BLOCK")]
    Astc6x6SrgbBlock = 166,
    #[doc(alias = "VK_FORMAT_ASTC_8x5_UNORM_BLOCK")]
    Astc8x5UnormBlock = 167,
    #[doc(alias = "VK_FORMAT_ASTC_8x5_SRGB_BLOCK")]
    Astc8x5SrgbBlock = 168,
    #[doc(alias = "VK_FORMAT_ASTC_8x6_UNORM_BLOCK")]
    Astc8x6UnormBlock = 169,
    #[doc(alias = "VK_FORMAT_ASTC_8x6_SRGB_BLOCK")]
    Astc8x6SrgbBlock = 170,
    #[doc(alias = "VK_FORMAT_ASTC_8x8_UNORM_BLOCK")]
    Astc8x8UnormBlock = 171,
    #[doc(alias = "VK_FORMAT_ASTC_8x8_SRGB_BLOCK")]
    Astc8x8SrgbBlock = 172,
    #[doc(alias = "VK_FORMAT_ASTC_10x5_UNORM_BLOCK")]
    Astc10x5UnormBlock = 173,
    #[doc(alias = "VK_FORMAT_ASTC_10x5_SRGB_BLOCK")]
    Astc10x5SrgbBlock = 174,
    #[doc(alias = "VK_FORMAT_ASTC_10x6_UNORM_BLOCK")]
    Astc10x6UnormBlock = 175,
    #[doc(alias = "VK_FORMAT_ASTC_10x6_SRGB_BLOCK")]
    Astc10x6SrgbBlock = 176,
    #[doc(alias = "VK_FORMAT_ASTC_10x8_UNORM_BLOCK")]
    Astc10x8UnormBlock = 177,
    #[doc(alias = "VK_FORMAT_ASTC_10x8_SRGB_BLOCK")]
    Astc10x8SrgbBlock = 178,
    #[doc(alias = "VK_FORMAT_ASTC_10x10_UNORM_BLOCK")]
    Astc10x10UnormBlock = 179,
    #[doc(alias = "VK_FORMAT_ASTC_10x10_SRGB_BLOCK")]
    Astc10x10SrgbBlock = 180,
    #[doc(alias = "VK_FORMAT_ASTC_12x10_UNORM_BLOCK")]
    Astc12x10UnormBlock = 181,
    #[doc(alias = "VK_FORMAT_ASTC_12x10_SRGB_BLOCK")]
    Astc12x10SrgbBlock = 182,
    #[doc(alias = "VK_FORMAT_ASTC_12x12_UNORM_BLOCK")]
    Astc12x12UnormBlock = 183,
    #[doc(alias = "VK_FORMAT_ASTC_12x12_SRGB_BLOCK")]
    Astc12x12SrgbBlock = 184,
    #[doc(alias = "VK_FORMAT_G8B8G8R8_422_UNORM")]
    #[doc(alias = "VK_FORMAT_G8B8G8R8_422_UNORM_KHR")]
    G8b8g8r8422Unorm = 1000156000,
    #[doc(alias = "VK_FORMAT_B8G8R8G8_422_UNORM")]
    #[doc(alias = "VK_FORMAT_B8G8R8G8_422_UNORM_KHR")]
    B8g8r8g8422Unorm = 1000156001,
    #[doc(alias = "VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM")]
    #[doc(alias = "VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM_KHR")]
    G8b8r83plane420Unorm = 1000156002,
    #[doc(alias = "VK_FORMAT_G8_B8R8_2PLANE_420_UNORM")]
    #[doc(alias = "VK_FORMAT_G8_B8R8_2PLANE_420_UNORM_KHR")]
    G8b8r82plane420Unorm = 1000156003,
    #[doc(alias = "VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM")]
    #[doc(alias = "VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM_KHR")]
    G8b8r83plane422Unorm = 1000156004,
    #[doc(alias = "VK_FORMAT_G8_B8R8_2PLANE_422_UNORM")]
    #[doc(alias = "VK_FORMAT_G8_B8R8_2PLANE_422_UNORM_KHR")]
    G8b8r82plane422Unorm = 1000156005,
    #[doc(alias = "VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM")]
    #[doc(alias = "VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM_KHR")]
    G8b8r83plane444Unorm = 1000156006,
    #[doc(alias = "VK_FORMAT_R10X6_UNORM_PACK16")]
    #[doc(alias = "VK_FORMAT_R10X6_UNORM_PACK16_KHR")]
    R10x6UnormPack16 = 1000156007,
    #[doc(alias = "VK_FORMAT_R10X6G10X6_UNORM_2PACK16")]
    #[doc(alias = "VK_FORMAT_R10X6G10X6_UNORM_2PACK16_KHR")]
    R10x6g10x6Unorm2pack16 = 1000156008,
    #[doc(alias = "VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16")]
    #[doc(alias = "VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16_KHR")]
    R10x6g10x6b10x6a10x6Unorm4pack16 = 1000156009,
    #[doc(alias = "VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16")]
    #[doc(alias = "VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16_KHR")]
    G10x6b10x6g10x6r10x6422Unorm4pack16 = 1000156010,
    #[doc(alias = "VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16")]
    #[doc(alias = "VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16_KHR")]
    B10x6g10x6r10x6g10x6422Unorm4pack16 = 1000156011,
    #[doc(alias = "VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16")]
    #[doc(alias = "VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16_KHR")]
    G10x6B10x6R10x63plane420Unorm3pack16 = 1000156012,
    #[doc(alias = "VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16")]
    #[doc(alias = "VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16_KHR")]
    G10x6B10x6r10x62plane420Unorm3pack16 = 1000156013,
    #[doc(alias = "VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16")]
    #[doc(alias = "VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16_KHR")]
    G10x6B10x6R10x63plane422Unorm3pack16 = 1000156014,
    #[doc(alias = "VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16")]
    #[doc(alias = "VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16_KHR")]
    G10x6B10x6r10x62plane422Unorm3pack16 = 1000156015,
    #[doc(alias = "VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16")]
    #[doc(alias = "VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16_KHR")]
    G10x6B10x6R10x63plane444Unorm3pack16 = 1000156016,
    #[doc(alias = "VK_FORMAT_R12X4_UNORM_PACK16")]
    #[doc(alias = "VK_FORMAT_R12X4_UNORM_PACK16_KHR")]
    R12x4UnormPack16 = 1000156017,
    #[doc(alias = "VK_FORMAT_R12X4G12X4_UNORM_2PACK16")]
    #[doc(alias = "VK_FORMAT_R12X4G12X4_UNORM_2PACK16_KHR")]
    R12x4g12x4Unorm2pack16 = 1000156018,
    #[doc(alias = "VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16")]
    #[doc(alias = "VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16_KHR")]
    R12x4g12x4b12x4a12x4Unorm4pack16 = 1000156019,
    #[doc(alias = "VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16")]
    #[doc(alias = "VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16_KHR")]
    G12x4b12x4g12x4r12x4422Unorm4pack16 = 1000156020,
    #[doc(alias = "VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16")]
    #[doc(alias = "VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16_KHR")]
    B12x4g12x4r12x4g12x4422Unorm4pack16 = 1000156021,
    #[doc(alias = "VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16")]
    #[doc(alias = "VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16_KHR")]
    G12x4B12x4R12x43plane420Unorm3pack16 = 1000156022,
    #[doc(alias = "VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16")]
    #[doc(alias = "VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16_KHR")]
    G12x4B12x4r12x42plane420Unorm3pack16 = 1000156023,
    #[doc(alias = "VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16")]
    #[doc(alias = "VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16_KHR")]
    G12x4B12x4R12x43plane422Unorm3pack16 = 1000156024,
    #[doc(alias = "VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16")]
    #[doc(alias = "VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16_KHR")]
    G12x4B12x4r12x42plane422Unorm3pack16 = 1000156025,
    #[doc(alias = "VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16")]
    #[doc(alias = "VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16_KHR")]
    G12x4B12x4R12x43plane444Unorm3pack16 = 1000156026,
    #[doc(alias = "VK_FORMAT_G16B16G16R16_422_UNORM")]
    #[doc(alias = "VK_FORMAT_G16B16G16R16_422_UNORM_KHR")]
    G16b16g16r16422Unorm = 1000156027,
    #[doc(alias = "VK_FORMAT_B16G16R16G16_422_UNORM")]
    #[doc(alias = "VK_FORMAT_B16G16R16G16_422_UNORM_KHR")]
    B16g16r16g16422Unorm = 1000156028,
    #[doc(alias = "VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM")]
    #[doc(alias = "VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM_KHR")]
    G16b16r163plane420Unorm = 1000156029,
    #[doc(alias = "VK_FORMAT_G16_B16R16_2PLANE_420_UNORM")]
    #[doc(alias = "VK_FORMAT_G16_B16R16_2PLANE_420_UNORM_KHR")]
    G16b16r162plane420Unorm = 1000156030,
    #[doc(alias = "VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM")]
    #[doc(alias = "VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM_KHR")]
    G16b16r163plane422Unorm = 1000156031,
    #[doc(alias = "VK_FORMAT_G16_B16R16_2PLANE_422_UNORM")]
    #[doc(alias = "VK_FORMAT_G16_B16R16_2PLANE_422_UNORM_KHR")]
    G16b16r162plane422Unorm = 1000156032,
    #[doc(alias = "VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM")]
    #[doc(alias = "VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM_KHR")]
    G16b16r163plane444Unorm = 1000156033,
    #[doc(alias = "VK_FORMAT_G8_B8R8_2PLANE_444_UNORM")]
    #[doc(alias = "VK_FORMAT_G8_B8R8_2PLANE_444_UNORM_EXT")]
    #[cfg(feature = "VULKAN_1_3")]
    G8b8r82plane444Unorm = 1000330000,
    #[doc(alias = "VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16")]
    #[doc(alias = "VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16_EXT")]
    #[cfg(feature = "VULKAN_1_3")]
    G10x6B10x6r10x62plane444Unorm3pack16 = 1000330001,
    #[doc(alias = "VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16")]
    #[doc(alias = "VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16_EXT")]
    #[cfg(feature = "VULKAN_1_3")]
    G12x4B12x4r12x42plane444Unorm3pack16 = 1000330002,
    #[doc(alias = "VK_FORMAT_G16_B16R16_2PLANE_444_UNORM")]
    #[doc(alias = "VK_FORMAT_G16_B16R16_2PLANE_444_UNORM_EXT")]
    #[cfg(feature = "VULKAN_1_3")]
    G16b16r162plane444Unorm = 1000330003,
    #[doc(alias = "VK_FORMAT_A4R4G4B4_UNORM_PACK16")]
    #[doc(alias = "VK_FORMAT_A4R4G4B4_UNORM_PACK16_EXT")]
    #[cfg(feature = "VULKAN_1_3")]
    A4r4g4b4UnormPack16 = 1000340000,
    #[doc(alias = "VK_FORMAT_A4B4G4R4_UNORM_PACK16")]
    #[doc(alias = "VK_FORMAT_A4B4G4R4_UNORM_PACK16_EXT")]
    #[cfg(feature = "VULKAN_1_3")]
    A4b4g4r4UnormPack16 = 1000340001,
    #[doc(alias = "VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK")]
    #[doc(alias = "VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK_EXT")]
    #[cfg(feature = "VULKAN_1_3")]
    Astc4x4SfloatBlock = 1000066000,
    #[doc(alias = "VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK")]
    #[doc(alias = "VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK_EXT")]
    #[cfg(feature = "VULKAN_1_3")]
    Astc5x4SfloatBlock = 1000066001,
    #[doc(alias = "VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK")]
    #[doc(alias = "VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK_EXT")]
    #[cfg(feature = "VULKAN_1_3")]
    Astc5x5SfloatBlock = 1000066002,
    #[doc(alias = "VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK")]
    #[doc(alias = "VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK_EXT")]
    #[cfg(feature = "VULKAN_1_3")]
    Astc6x5SfloatBlock = 1000066003,
    #[doc(alias = "VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK")]
    #[doc(alias = "VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK_EXT")]
    #[cfg(feature = "VULKAN_1_3")]
    Astc6x6SfloatBlock = 1000066004,
    #[doc(alias = "VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK")]
    #[doc(alias = "VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK_EXT")]
    #[cfg(feature = "VULKAN_1_3")]
    Astc8x5SfloatBlock = 1000066005,
    #[doc(alias = "VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK")]
    #[doc(alias = "VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK_EXT")]
    #[cfg(feature = "VULKAN_1_3")]
    Astc8x6SfloatBlock = 1000066006,
    #[doc(alias = "VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK")]
    #[doc(alias = "VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK_EXT")]
    #[cfg(feature = "VULKAN_1_3")]
    Astc8x8SfloatBlock = 1000066007,
    #[doc(alias = "VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK")]
    #[doc(alias = "VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK_EXT")]
    #[cfg(feature = "VULKAN_1_3")]
    Astc10x5SfloatBlock = 1000066008,
    #[doc(alias = "VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK")]
    #[doc(alias = "VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK_EXT")]
    #[cfg(feature = "VULKAN_1_3")]
    Astc10x6SfloatBlock = 1000066009,
    #[doc(alias = "VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK")]
    #[doc(alias = "VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK_EXT")]
    #[cfg(feature = "VULKAN_1_3")]
    Astc10x8SfloatBlock = 1000066010,
    #[doc(alias = "VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK")]
    #[doc(alias = "VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK_EXT")]
    #[cfg(feature = "VULKAN_1_3")]
    Astc10x10SfloatBlock = 1000066011,
    #[doc(alias = "VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK")]
    #[doc(alias = "VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK_EXT")]
    #[cfg(feature = "VULKAN_1_3")]
    Astc12x10SfloatBlock = 1000066012,
    #[doc(alias = "VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK")]
    #[doc(alias = "VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK_EXT")]
    #[cfg(feature = "VULKAN_1_3")]
    Astc12x12SfloatBlock = 1000066013,
    #[doc(alias = "VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG")]
    #[cfg(feature = "VK_IMG_format_pvrtc")]
    Pvrtc12bppUnormBlockImg = 1000054000,
    #[doc(alias = "VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG")]
    #[cfg(feature = "VK_IMG_format_pvrtc")]
    Pvrtc14bppUnormBlockImg = 1000054001,
    #[doc(alias = "VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG")]
    #[cfg(feature = "VK_IMG_format_pvrtc")]
    Pvrtc22bppUnormBlockImg = 1000054002,
    #[doc(alias = "VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG")]
    #[cfg(feature = "VK_IMG_format_pvrtc")]
    Pvrtc24bppUnormBlockImg = 1000054003,
    #[doc(alias = "VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG")]
    #[cfg(feature = "VK_IMG_format_pvrtc")]
    Pvrtc12bppSrgbBlockImg = 1000054004,
    #[doc(alias = "VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG")]
    #[cfg(feature = "VK_IMG_format_pvrtc")]
    Pvrtc14bppSrgbBlockImg = 1000054005,
    #[doc(alias = "VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG")]
    #[cfg(feature = "VK_IMG_format_pvrtc")]
    Pvrtc22bppSrgbBlockImg = 1000054006,
    #[doc(alias = "VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG")]
    #[cfg(feature = "VK_IMG_format_pvrtc")]
    Pvrtc24bppSrgbBlockImg = 1000054007,
}
impl Default for Format {
    #[inline]
    fn default() -> Self {
        Self::empty()
    }
}
impl Format {
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        unsafe { Self::from_bits_unchecked(0) }
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> i32 {
        *self as i32
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: i32) -> Option<Self> {
        match bits {
            x if x == Self::Undefined.bits() => Some(Self::Undefined),
            x if x == Self::R4g4UnormPack8.bits() => Some(Self::R4g4UnormPack8),
            x if x == Self::R4g4b4a4UnormPack16.bits() => Some(Self::R4g4b4a4UnormPack16),
            x if x == Self::B4g4r4a4UnormPack16.bits() => Some(Self::B4g4r4a4UnormPack16),
            x if x == Self::R5g6b5UnormPack16.bits() => Some(Self::R5g6b5UnormPack16),
            x if x == Self::B5g6r5UnormPack16.bits() => Some(Self::B5g6r5UnormPack16),
            x if x == Self::R5g5b5a1UnormPack16.bits() => Some(Self::R5g5b5a1UnormPack16),
            x if x == Self::B5g5r5a1UnormPack16.bits() => Some(Self::B5g5r5a1UnormPack16),
            x if x == Self::A1r5g5b5UnormPack16.bits() => Some(Self::A1r5g5b5UnormPack16),
            x if x == Self::R8Unorm.bits() => Some(Self::R8Unorm),
            x if x == Self::R8Snorm.bits() => Some(Self::R8Snorm),
            x if x == Self::R8Uscaled.bits() => Some(Self::R8Uscaled),
            x if x == Self::R8Sscaled.bits() => Some(Self::R8Sscaled),
            x if x == Self::R8Uint.bits() => Some(Self::R8Uint),
            x if x == Self::R8Sint.bits() => Some(Self::R8Sint),
            x if x == Self::R8Srgb.bits() => Some(Self::R8Srgb),
            x if x == Self::R8g8Unorm.bits() => Some(Self::R8g8Unorm),
            x if x == Self::R8g8Snorm.bits() => Some(Self::R8g8Snorm),
            x if x == Self::R8g8Uscaled.bits() => Some(Self::R8g8Uscaled),
            x if x == Self::R8g8Sscaled.bits() => Some(Self::R8g8Sscaled),
            x if x == Self::R8g8Uint.bits() => Some(Self::R8g8Uint),
            x if x == Self::R8g8Sint.bits() => Some(Self::R8g8Sint),
            x if x == Self::R8g8Srgb.bits() => Some(Self::R8g8Srgb),
            x if x == Self::R8g8b8Unorm.bits() => Some(Self::R8g8b8Unorm),
            x if x == Self::R8g8b8Snorm.bits() => Some(Self::R8g8b8Snorm),
            x if x == Self::R8g8b8Uscaled.bits() => Some(Self::R8g8b8Uscaled),
            x if x == Self::R8g8b8Sscaled.bits() => Some(Self::R8g8b8Sscaled),
            x if x == Self::R8g8b8Uint.bits() => Some(Self::R8g8b8Uint),
            x if x == Self::R8g8b8Sint.bits() => Some(Self::R8g8b8Sint),
            x if x == Self::R8g8b8Srgb.bits() => Some(Self::R8g8b8Srgb),
            x if x == Self::B8g8r8Unorm.bits() => Some(Self::B8g8r8Unorm),
            x if x == Self::B8g8r8Snorm.bits() => Some(Self::B8g8r8Snorm),
            x if x == Self::B8g8r8Uscaled.bits() => Some(Self::B8g8r8Uscaled),
            x if x == Self::B8g8r8Sscaled.bits() => Some(Self::B8g8r8Sscaled),
            x if x == Self::B8g8r8Uint.bits() => Some(Self::B8g8r8Uint),
            x if x == Self::B8g8r8Sint.bits() => Some(Self::B8g8r8Sint),
            x if x == Self::B8g8r8Srgb.bits() => Some(Self::B8g8r8Srgb),
            x if x == Self::R8g8b8a8Unorm.bits() => Some(Self::R8g8b8a8Unorm),
            x if x == Self::R8g8b8a8Snorm.bits() => Some(Self::R8g8b8a8Snorm),
            x if x == Self::R8g8b8a8Uscaled.bits() => Some(Self::R8g8b8a8Uscaled),
            x if x == Self::R8g8b8a8Sscaled.bits() => Some(Self::R8g8b8a8Sscaled),
            x if x == Self::R8g8b8a8Uint.bits() => Some(Self::R8g8b8a8Uint),
            x if x == Self::R8g8b8a8Sint.bits() => Some(Self::R8g8b8a8Sint),
            x if x == Self::R8g8b8a8Srgb.bits() => Some(Self::R8g8b8a8Srgb),
            x if x == Self::B8g8r8a8Unorm.bits() => Some(Self::B8g8r8a8Unorm),
            x if x == Self::B8g8r8a8Snorm.bits() => Some(Self::B8g8r8a8Snorm),
            x if x == Self::B8g8r8a8Uscaled.bits() => Some(Self::B8g8r8a8Uscaled),
            x if x == Self::B8g8r8a8Sscaled.bits() => Some(Self::B8g8r8a8Sscaled),
            x if x == Self::B8g8r8a8Uint.bits() => Some(Self::B8g8r8a8Uint),
            x if x == Self::B8g8r8a8Sint.bits() => Some(Self::B8g8r8a8Sint),
            x if x == Self::B8g8r8a8Srgb.bits() => Some(Self::B8g8r8a8Srgb),
            x if x == Self::A8b8g8r8UnormPack32.bits() => Some(Self::A8b8g8r8UnormPack32),
            x if x == Self::A8b8g8r8SnormPack32.bits() => Some(Self::A8b8g8r8SnormPack32),
            x if x == Self::A8b8g8r8UscaledPack32.bits() => Some(Self::A8b8g8r8UscaledPack32),
            x if x == Self::A8b8g8r8SscaledPack32.bits() => Some(Self::A8b8g8r8SscaledPack32),
            x if x == Self::A8b8g8r8UintPack32.bits() => Some(Self::A8b8g8r8UintPack32),
            x if x == Self::A8b8g8r8SintPack32.bits() => Some(Self::A8b8g8r8SintPack32),
            x if x == Self::A8b8g8r8SrgbPack32.bits() => Some(Self::A8b8g8r8SrgbPack32),
            x if x == Self::A2r10g10b10UnormPack32.bits() => Some(Self::A2r10g10b10UnormPack32),
            x if x == Self::A2r10g10b10SnormPack32.bits() => Some(Self::A2r10g10b10SnormPack32),
            x if x == Self::A2r10g10b10UscaledPack32.bits() => Some(Self::A2r10g10b10UscaledPack32),
            x if x == Self::A2r10g10b10SscaledPack32.bits() => Some(Self::A2r10g10b10SscaledPack32),
            x if x == Self::A2r10g10b10UintPack32.bits() => Some(Self::A2r10g10b10UintPack32),
            x if x == Self::A2r10g10b10SintPack32.bits() => Some(Self::A2r10g10b10SintPack32),
            x if x == Self::A2b10g10r10UnormPack32.bits() => Some(Self::A2b10g10r10UnormPack32),
            x if x == Self::A2b10g10r10SnormPack32.bits() => Some(Self::A2b10g10r10SnormPack32),
            x if x == Self::A2b10g10r10UscaledPack32.bits() => Some(Self::A2b10g10r10UscaledPack32),
            x if x == Self::A2b10g10r10SscaledPack32.bits() => Some(Self::A2b10g10r10SscaledPack32),
            x if x == Self::A2b10g10r10UintPack32.bits() => Some(Self::A2b10g10r10UintPack32),
            x if x == Self::A2b10g10r10SintPack32.bits() => Some(Self::A2b10g10r10SintPack32),
            x if x == Self::R16Unorm.bits() => Some(Self::R16Unorm),
            x if x == Self::R16Snorm.bits() => Some(Self::R16Snorm),
            x if x == Self::R16Uscaled.bits() => Some(Self::R16Uscaled),
            x if x == Self::R16Sscaled.bits() => Some(Self::R16Sscaled),
            x if x == Self::R16Uint.bits() => Some(Self::R16Uint),
            x if x == Self::R16Sint.bits() => Some(Self::R16Sint),
            x if x == Self::R16Sfloat.bits() => Some(Self::R16Sfloat),
            x if x == Self::R16g16Unorm.bits() => Some(Self::R16g16Unorm),
            x if x == Self::R16g16Snorm.bits() => Some(Self::R16g16Snorm),
            x if x == Self::R16g16Uscaled.bits() => Some(Self::R16g16Uscaled),
            x if x == Self::R16g16Sscaled.bits() => Some(Self::R16g16Sscaled),
            x if x == Self::R16g16Uint.bits() => Some(Self::R16g16Uint),
            x if x == Self::R16g16Sint.bits() => Some(Self::R16g16Sint),
            x if x == Self::R16g16Sfloat.bits() => Some(Self::R16g16Sfloat),
            x if x == Self::R16g16b16Unorm.bits() => Some(Self::R16g16b16Unorm),
            x if x == Self::R16g16b16Snorm.bits() => Some(Self::R16g16b16Snorm),
            x if x == Self::R16g16b16Uscaled.bits() => Some(Self::R16g16b16Uscaled),
            x if x == Self::R16g16b16Sscaled.bits() => Some(Self::R16g16b16Sscaled),
            x if x == Self::R16g16b16Uint.bits() => Some(Self::R16g16b16Uint),
            x if x == Self::R16g16b16Sint.bits() => Some(Self::R16g16b16Sint),
            x if x == Self::R16g16b16Sfloat.bits() => Some(Self::R16g16b16Sfloat),
            x if x == Self::R16g16b16a16Unorm.bits() => Some(Self::R16g16b16a16Unorm),
            x if x == Self::R16g16b16a16Snorm.bits() => Some(Self::R16g16b16a16Snorm),
            x if x == Self::R16g16b16a16Uscaled.bits() => Some(Self::R16g16b16a16Uscaled),
            x if x == Self::R16g16b16a16Sscaled.bits() => Some(Self::R16g16b16a16Sscaled),
            x if x == Self::R16g16b16a16Uint.bits() => Some(Self::R16g16b16a16Uint),
            x if x == Self::R16g16b16a16Sint.bits() => Some(Self::R16g16b16a16Sint),
            x if x == Self::R16g16b16a16Sfloat.bits() => Some(Self::R16g16b16a16Sfloat),
            x if x == Self::R32Uint.bits() => Some(Self::R32Uint),
            x if x == Self::R32Sint.bits() => Some(Self::R32Sint),
            x if x == Self::R32Sfloat.bits() => Some(Self::R32Sfloat),
            x if x == Self::R32g32Uint.bits() => Some(Self::R32g32Uint),
            x if x == Self::R32g32Sint.bits() => Some(Self::R32g32Sint),
            x if x == Self::R32g32Sfloat.bits() => Some(Self::R32g32Sfloat),
            x if x == Self::R32g32b32Uint.bits() => Some(Self::R32g32b32Uint),
            x if x == Self::R32g32b32Sint.bits() => Some(Self::R32g32b32Sint),
            x if x == Self::R32g32b32Sfloat.bits() => Some(Self::R32g32b32Sfloat),
            x if x == Self::R32g32b32a32Uint.bits() => Some(Self::R32g32b32a32Uint),
            x if x == Self::R32g32b32a32Sint.bits() => Some(Self::R32g32b32a32Sint),
            x if x == Self::R32g32b32a32Sfloat.bits() => Some(Self::R32g32b32a32Sfloat),
            x if x == Self::R64Uint.bits() => Some(Self::R64Uint),
            x if x == Self::R64Sint.bits() => Some(Self::R64Sint),
            x if x == Self::R64Sfloat.bits() => Some(Self::R64Sfloat),
            x if x == Self::R64g64Uint.bits() => Some(Self::R64g64Uint),
            x if x == Self::R64g64Sint.bits() => Some(Self::R64g64Sint),
            x if x == Self::R64g64Sfloat.bits() => Some(Self::R64g64Sfloat),
            x if x == Self::R64g64b64Uint.bits() => Some(Self::R64g64b64Uint),
            x if x == Self::R64g64b64Sint.bits() => Some(Self::R64g64b64Sint),
            x if x == Self::R64g64b64Sfloat.bits() => Some(Self::R64g64b64Sfloat),
            x if x == Self::R64g64b64a64Uint.bits() => Some(Self::R64g64b64a64Uint),
            x if x == Self::R64g64b64a64Sint.bits() => Some(Self::R64g64b64a64Sint),
            x if x == Self::R64g64b64a64Sfloat.bits() => Some(Self::R64g64b64a64Sfloat),
            x if x == Self::B10g11r11UfloatPack32.bits() => Some(Self::B10g11r11UfloatPack32),
            x if x == Self::E5b9g9r9UfloatPack32.bits() => Some(Self::E5b9g9r9UfloatPack32),
            x if x == Self::D16Unorm.bits() => Some(Self::D16Unorm),
            x if x == Self::X8d24UnormPack32.bits() => Some(Self::X8d24UnormPack32),
            x if x == Self::D32Sfloat.bits() => Some(Self::D32Sfloat),
            x if x == Self::S8Uint.bits() => Some(Self::S8Uint),
            x if x == Self::D16UnormS8Uint.bits() => Some(Self::D16UnormS8Uint),
            x if x == Self::D24UnormS8Uint.bits() => Some(Self::D24UnormS8Uint),
            x if x == Self::D32SfloatS8Uint.bits() => Some(Self::D32SfloatS8Uint),
            x if x == Self::Bc1RgbUnormBlock.bits() => Some(Self::Bc1RgbUnormBlock),
            x if x == Self::Bc1RgbSrgbBlock.bits() => Some(Self::Bc1RgbSrgbBlock),
            x if x == Self::Bc1RgbaUnormBlock.bits() => Some(Self::Bc1RgbaUnormBlock),
            x if x == Self::Bc1RgbaSrgbBlock.bits() => Some(Self::Bc1RgbaSrgbBlock),
            x if x == Self::Bc2UnormBlock.bits() => Some(Self::Bc2UnormBlock),
            x if x == Self::Bc2SrgbBlock.bits() => Some(Self::Bc2SrgbBlock),
            x if x == Self::Bc3UnormBlock.bits() => Some(Self::Bc3UnormBlock),
            x if x == Self::Bc3SrgbBlock.bits() => Some(Self::Bc3SrgbBlock),
            x if x == Self::Bc4UnormBlock.bits() => Some(Self::Bc4UnormBlock),
            x if x == Self::Bc4SnormBlock.bits() => Some(Self::Bc4SnormBlock),
            x if x == Self::Bc5UnormBlock.bits() => Some(Self::Bc5UnormBlock),
            x if x == Self::Bc5SnormBlock.bits() => Some(Self::Bc5SnormBlock),
            x if x == Self::Bc6hUfloatBlock.bits() => Some(Self::Bc6hUfloatBlock),
            x if x == Self::Bc6hSfloatBlock.bits() => Some(Self::Bc6hSfloatBlock),
            x if x == Self::Bc7UnormBlock.bits() => Some(Self::Bc7UnormBlock),
            x if x == Self::Bc7SrgbBlock.bits() => Some(Self::Bc7SrgbBlock),
            x if x == Self::Etc2R8g8b8UnormBlock.bits() => Some(Self::Etc2R8g8b8UnormBlock),
            x if x == Self::Etc2R8g8b8SrgbBlock.bits() => Some(Self::Etc2R8g8b8SrgbBlock),
            x if x == Self::Etc2R8g8b8a1UnormBlock.bits() => Some(Self::Etc2R8g8b8a1UnormBlock),
            x if x == Self::Etc2R8g8b8a1SrgbBlock.bits() => Some(Self::Etc2R8g8b8a1SrgbBlock),
            x if x == Self::Etc2R8g8b8a8UnormBlock.bits() => Some(Self::Etc2R8g8b8a8UnormBlock),
            x if x == Self::Etc2R8g8b8a8SrgbBlock.bits() => Some(Self::Etc2R8g8b8a8SrgbBlock),
            x if x == Self::EacR11UnormBlock.bits() => Some(Self::EacR11UnormBlock),
            x if x == Self::EacR11SnormBlock.bits() => Some(Self::EacR11SnormBlock),
            x if x == Self::EacR11g11UnormBlock.bits() => Some(Self::EacR11g11UnormBlock),
            x if x == Self::EacR11g11SnormBlock.bits() => Some(Self::EacR11g11SnormBlock),
            x if x == Self::Astc4x4UnormBlock.bits() => Some(Self::Astc4x4UnormBlock),
            x if x == Self::Astc4x4SrgbBlock.bits() => Some(Self::Astc4x4SrgbBlock),
            x if x == Self::Astc5x4UnormBlock.bits() => Some(Self::Astc5x4UnormBlock),
            x if x == Self::Astc5x4SrgbBlock.bits() => Some(Self::Astc5x4SrgbBlock),
            x if x == Self::Astc5x5UnormBlock.bits() => Some(Self::Astc5x5UnormBlock),
            x if x == Self::Astc5x5SrgbBlock.bits() => Some(Self::Astc5x5SrgbBlock),
            x if x == Self::Astc6x5UnormBlock.bits() => Some(Self::Astc6x5UnormBlock),
            x if x == Self::Astc6x5SrgbBlock.bits() => Some(Self::Astc6x5SrgbBlock),
            x if x == Self::Astc6x6UnormBlock.bits() => Some(Self::Astc6x6UnormBlock),
            x if x == Self::Astc6x6SrgbBlock.bits() => Some(Self::Astc6x6SrgbBlock),
            x if x == Self::Astc8x5UnormBlock.bits() => Some(Self::Astc8x5UnormBlock),
            x if x == Self::Astc8x5SrgbBlock.bits() => Some(Self::Astc8x5SrgbBlock),
            x if x == Self::Astc8x6UnormBlock.bits() => Some(Self::Astc8x6UnormBlock),
            x if x == Self::Astc8x6SrgbBlock.bits() => Some(Self::Astc8x6SrgbBlock),
            x if x == Self::Astc8x8UnormBlock.bits() => Some(Self::Astc8x8UnormBlock),
            x if x == Self::Astc8x8SrgbBlock.bits() => Some(Self::Astc8x8SrgbBlock),
            x if x == Self::Astc10x5UnormBlock.bits() => Some(Self::Astc10x5UnormBlock),
            x if x == Self::Astc10x5SrgbBlock.bits() => Some(Self::Astc10x5SrgbBlock),
            x if x == Self::Astc10x6UnormBlock.bits() => Some(Self::Astc10x6UnormBlock),
            x if x == Self::Astc10x6SrgbBlock.bits() => Some(Self::Astc10x6SrgbBlock),
            x if x == Self::Astc10x8UnormBlock.bits() => Some(Self::Astc10x8UnormBlock),
            x if x == Self::Astc10x8SrgbBlock.bits() => Some(Self::Astc10x8SrgbBlock),
            x if x == Self::Astc10x10UnormBlock.bits() => Some(Self::Astc10x10UnormBlock),
            x if x == Self::Astc10x10SrgbBlock.bits() => Some(Self::Astc10x10SrgbBlock),
            x if x == Self::Astc12x10UnormBlock.bits() => Some(Self::Astc12x10UnormBlock),
            x if x == Self::Astc12x10SrgbBlock.bits() => Some(Self::Astc12x10SrgbBlock),
            x if x == Self::Astc12x12UnormBlock.bits() => Some(Self::Astc12x12UnormBlock),
            x if x == Self::Astc12x12SrgbBlock.bits() => Some(Self::Astc12x12SrgbBlock),
            x if x == Self::G8b8g8r8422Unorm.bits() => Some(Self::G8b8g8r8422Unorm),
            x if x == Self::B8g8r8g8422Unorm.bits() => Some(Self::B8g8r8g8422Unorm),
            x if x == Self::G8b8r83plane420Unorm.bits() => Some(Self::G8b8r83plane420Unorm),
            x if x == Self::G8b8r82plane420Unorm.bits() => Some(Self::G8b8r82plane420Unorm),
            x if x == Self::G8b8r83plane422Unorm.bits() => Some(Self::G8b8r83plane422Unorm),
            x if x == Self::G8b8r82plane422Unorm.bits() => Some(Self::G8b8r82plane422Unorm),
            x if x == Self::G8b8r83plane444Unorm.bits() => Some(Self::G8b8r83plane444Unorm),
            x if x == Self::R10x6UnormPack16.bits() => Some(Self::R10x6UnormPack16),
            x if x == Self::R10x6g10x6Unorm2pack16.bits() => Some(Self::R10x6g10x6Unorm2pack16),
            x if x == Self::R10x6g10x6b10x6a10x6Unorm4pack16.bits() => Some(Self::R10x6g10x6b10x6a10x6Unorm4pack16),
            x if x == Self::G10x6b10x6g10x6r10x6422Unorm4pack16.bits() => {
                Some(Self::G10x6b10x6g10x6r10x6422Unorm4pack16)
            },
            x if x == Self::B10x6g10x6r10x6g10x6422Unorm4pack16.bits() => {
                Some(Self::B10x6g10x6r10x6g10x6422Unorm4pack16)
            },
            x if x == Self::G10x6B10x6R10x63plane420Unorm3pack16.bits() => {
                Some(Self::G10x6B10x6R10x63plane420Unorm3pack16)
            },
            x if x == Self::G10x6B10x6r10x62plane420Unorm3pack16.bits() => {
                Some(Self::G10x6B10x6r10x62plane420Unorm3pack16)
            },
            x if x == Self::G10x6B10x6R10x63plane422Unorm3pack16.bits() => {
                Some(Self::G10x6B10x6R10x63plane422Unorm3pack16)
            },
            x if x == Self::G10x6B10x6r10x62plane422Unorm3pack16.bits() => {
                Some(Self::G10x6B10x6r10x62plane422Unorm3pack16)
            },
            x if x == Self::G10x6B10x6R10x63plane444Unorm3pack16.bits() => {
                Some(Self::G10x6B10x6R10x63plane444Unorm3pack16)
            },
            x if x == Self::R12x4UnormPack16.bits() => Some(Self::R12x4UnormPack16),
            x if x == Self::R12x4g12x4Unorm2pack16.bits() => Some(Self::R12x4g12x4Unorm2pack16),
            x if x == Self::R12x4g12x4b12x4a12x4Unorm4pack16.bits() => Some(Self::R12x4g12x4b12x4a12x4Unorm4pack16),
            x if x == Self::G12x4b12x4g12x4r12x4422Unorm4pack16.bits() => {
                Some(Self::G12x4b12x4g12x4r12x4422Unorm4pack16)
            },
            x if x == Self::B12x4g12x4r12x4g12x4422Unorm4pack16.bits() => {
                Some(Self::B12x4g12x4r12x4g12x4422Unorm4pack16)
            },
            x if x == Self::G12x4B12x4R12x43plane420Unorm3pack16.bits() => {
                Some(Self::G12x4B12x4R12x43plane420Unorm3pack16)
            },
            x if x == Self::G12x4B12x4r12x42plane420Unorm3pack16.bits() => {
                Some(Self::G12x4B12x4r12x42plane420Unorm3pack16)
            },
            x if x == Self::G12x4B12x4R12x43plane422Unorm3pack16.bits() => {
                Some(Self::G12x4B12x4R12x43plane422Unorm3pack16)
            },
            x if x == Self::G12x4B12x4r12x42plane422Unorm3pack16.bits() => {
                Some(Self::G12x4B12x4r12x42plane422Unorm3pack16)
            },
            x if x == Self::G12x4B12x4R12x43plane444Unorm3pack16.bits() => {
                Some(Self::G12x4B12x4R12x43plane444Unorm3pack16)
            },
            x if x == Self::G16b16g16r16422Unorm.bits() => Some(Self::G16b16g16r16422Unorm),
            x if x == Self::B16g16r16g16422Unorm.bits() => Some(Self::B16g16r16g16422Unorm),
            x if x == Self::G16b16r163plane420Unorm.bits() => Some(Self::G16b16r163plane420Unorm),
            x if x == Self::G16b16r162plane420Unorm.bits() => Some(Self::G16b16r162plane420Unorm),
            x if x == Self::G16b16r163plane422Unorm.bits() => Some(Self::G16b16r163plane422Unorm),
            x if x == Self::G16b16r162plane422Unorm.bits() => Some(Self::G16b16r162plane422Unorm),
            x if x == Self::G16b16r163plane444Unorm.bits() => Some(Self::G16b16r163plane444Unorm),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::G8b8r82plane444Unorm.bits() => Some(Self::G8b8r82plane444Unorm),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::G10x6B10x6r10x62plane444Unorm3pack16.bits() => {
                Some(Self::G10x6B10x6r10x62plane444Unorm3pack16)
            },
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::G12x4B12x4r12x42plane444Unorm3pack16.bits() => {
                Some(Self::G12x4B12x4r12x42plane444Unorm3pack16)
            },
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::G16b16r162plane444Unorm.bits() => Some(Self::G16b16r162plane444Unorm),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::A4r4g4b4UnormPack16.bits() => Some(Self::A4r4g4b4UnormPack16),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::A4b4g4r4UnormPack16.bits() => Some(Self::A4b4g4r4UnormPack16),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::Astc4x4SfloatBlock.bits() => Some(Self::Astc4x4SfloatBlock),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::Astc5x4SfloatBlock.bits() => Some(Self::Astc5x4SfloatBlock),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::Astc5x5SfloatBlock.bits() => Some(Self::Astc5x5SfloatBlock),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::Astc6x5SfloatBlock.bits() => Some(Self::Astc6x5SfloatBlock),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::Astc6x6SfloatBlock.bits() => Some(Self::Astc6x6SfloatBlock),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::Astc8x5SfloatBlock.bits() => Some(Self::Astc8x5SfloatBlock),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::Astc8x6SfloatBlock.bits() => Some(Self::Astc8x6SfloatBlock),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::Astc8x8SfloatBlock.bits() => Some(Self::Astc8x8SfloatBlock),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::Astc10x5SfloatBlock.bits() => Some(Self::Astc10x5SfloatBlock),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::Astc10x6SfloatBlock.bits() => Some(Self::Astc10x6SfloatBlock),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::Astc10x8SfloatBlock.bits() => Some(Self::Astc10x8SfloatBlock),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::Astc10x10SfloatBlock.bits() => Some(Self::Astc10x10SfloatBlock),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::Astc12x10SfloatBlock.bits() => Some(Self::Astc12x10SfloatBlock),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::Astc12x12SfloatBlock.bits() => Some(Self::Astc12x12SfloatBlock),
            #[cfg(feature = "VK_IMG_format_pvrtc")]
            x if x == Self::Pvrtc12bppUnormBlockImg.bits() => Some(Self::Pvrtc12bppUnormBlockImg),
            #[cfg(feature = "VK_IMG_format_pvrtc")]
            x if x == Self::Pvrtc14bppUnormBlockImg.bits() => Some(Self::Pvrtc14bppUnormBlockImg),
            #[cfg(feature = "VK_IMG_format_pvrtc")]
            x if x == Self::Pvrtc22bppUnormBlockImg.bits() => Some(Self::Pvrtc22bppUnormBlockImg),
            #[cfg(feature = "VK_IMG_format_pvrtc")]
            x if x == Self::Pvrtc24bppUnormBlockImg.bits() => Some(Self::Pvrtc24bppUnormBlockImg),
            #[cfg(feature = "VK_IMG_format_pvrtc")]
            x if x == Self::Pvrtc12bppSrgbBlockImg.bits() => Some(Self::Pvrtc12bppSrgbBlockImg),
            #[cfg(feature = "VK_IMG_format_pvrtc")]
            x if x == Self::Pvrtc14bppSrgbBlockImg.bits() => Some(Self::Pvrtc14bppSrgbBlockImg),
            #[cfg(feature = "VK_IMG_format_pvrtc")]
            x if x == Self::Pvrtc22bppSrgbBlockImg.bits() => Some(Self::Pvrtc22bppSrgbBlockImg),
            #[cfg(feature = "VK_IMG_format_pvrtc")]
            x if x == Self::Pvrtc24bppSrgbBlockImg.bits() => Some(Self::Pvrtc24bppSrgbBlockImg),
            #[cfg(feature = "VK_EXT_extension_289")]
            x if x == Self::Astc3x3x3UnormBlockExt.bits() => Some(Self::Astc3x3x3UnormBlockExt),
            #[cfg(feature = "VK_EXT_extension_289")]
            x if x == Self::Astc3x3x3SrgbBlockExt.bits() => Some(Self::Astc3x3x3SrgbBlockExt),
            #[cfg(feature = "VK_EXT_extension_289")]
            x if x == Self::Astc3x3x3SfloatBlockExt.bits() => Some(Self::Astc3x3x3SfloatBlockExt),
            #[cfg(feature = "VK_EXT_extension_289")]
            x if x == Self::Astc4x3x3UnormBlockExt.bits() => Some(Self::Astc4x3x3UnormBlockExt),
            #[cfg(feature = "VK_EXT_extension_289")]
            x if x == Self::Astc4x3x3SrgbBlockExt.bits() => Some(Self::Astc4x3x3SrgbBlockExt),
            #[cfg(feature = "VK_EXT_extension_289")]
            x if x == Self::Astc4x3x3SfloatBlockExt.bits() => Some(Self::Astc4x3x3SfloatBlockExt),
            #[cfg(feature = "VK_EXT_extension_289")]
            x if x == Self::Astc4x4x3UnormBlockExt.bits() => Some(Self::Astc4x4x3UnormBlockExt),
            #[cfg(feature = "VK_EXT_extension_289")]
            x if x == Self::Astc4x4x3SrgbBlockExt.bits() => Some(Self::Astc4x4x3SrgbBlockExt),
            #[cfg(feature = "VK_EXT_extension_289")]
            x if x == Self::Astc4x4x3SfloatBlockExt.bits() => Some(Self::Astc4x4x3SfloatBlockExt),
            #[cfg(feature = "VK_EXT_extension_289")]
            x if x == Self::Astc4x4x4UnormBlockExt.bits() => Some(Self::Astc4x4x4UnormBlockExt),
            #[cfg(feature = "VK_EXT_extension_289")]
            x if x == Self::Astc4x4x4SrgbBlockExt.bits() => Some(Self::Astc4x4x4SrgbBlockExt),
            #[cfg(feature = "VK_EXT_extension_289")]
            x if x == Self::Astc4x4x4SfloatBlockExt.bits() => Some(Self::Astc4x4x4SfloatBlockExt),
            #[cfg(feature = "VK_EXT_extension_289")]
            x if x == Self::Astc5x4x4UnormBlockExt.bits() => Some(Self::Astc5x4x4UnormBlockExt),
            #[cfg(feature = "VK_EXT_extension_289")]
            x if x == Self::Astc5x4x4SrgbBlockExt.bits() => Some(Self::Astc5x4x4SrgbBlockExt),
            #[cfg(feature = "VK_EXT_extension_289")]
            x if x == Self::Astc5x4x4SfloatBlockExt.bits() => Some(Self::Astc5x4x4SfloatBlockExt),
            #[cfg(feature = "VK_EXT_extension_289")]
            x if x == Self::Astc5x5x4UnormBlockExt.bits() => Some(Self::Astc5x5x4UnormBlockExt),
            #[cfg(feature = "VK_EXT_extension_289")]
            x if x == Self::Astc5x5x4SrgbBlockExt.bits() => Some(Self::Astc5x5x4SrgbBlockExt),
            #[cfg(feature = "VK_EXT_extension_289")]
            x if x == Self::Astc5x5x4SfloatBlockExt.bits() => Some(Self::Astc5x5x4SfloatBlockExt),
            #[cfg(feature = "VK_EXT_extension_289")]
            x if x == Self::Astc5x5x5UnormBlockExt.bits() => Some(Self::Astc5x5x5UnormBlockExt),
            #[cfg(feature = "VK_EXT_extension_289")]
            x if x == Self::Astc5x5x5SrgbBlockExt.bits() => Some(Self::Astc5x5x5SrgbBlockExt),
            #[cfg(feature = "VK_EXT_extension_289")]
            x if x == Self::Astc5x5x5SfloatBlockExt.bits() => Some(Self::Astc5x5x5SfloatBlockExt),
            #[cfg(feature = "VK_EXT_extension_289")]
            x if x == Self::Astc6x5x5UnormBlockExt.bits() => Some(Self::Astc6x5x5UnormBlockExt),
            #[cfg(feature = "VK_EXT_extension_289")]
            x if x == Self::Astc6x5x5SrgbBlockExt.bits() => Some(Self::Astc6x5x5SrgbBlockExt),
            #[cfg(feature = "VK_EXT_extension_289")]
            x if x == Self::Astc6x5x5SfloatBlockExt.bits() => Some(Self::Astc6x5x5SfloatBlockExt),
            #[cfg(feature = "VK_EXT_extension_289")]
            x if x == Self::Astc6x6x5UnormBlockExt.bits() => Some(Self::Astc6x6x5UnormBlockExt),
            #[cfg(feature = "VK_EXT_extension_289")]
            x if x == Self::Astc6x6x5SrgbBlockExt.bits() => Some(Self::Astc6x6x5SrgbBlockExt),
            #[cfg(feature = "VK_EXT_extension_289")]
            x if x == Self::Astc6x6x5SfloatBlockExt.bits() => Some(Self::Astc6x6x5SfloatBlockExt),
            #[cfg(feature = "VK_EXT_extension_289")]
            x if x == Self::Astc6x6x6UnormBlockExt.bits() => Some(Self::Astc6x6x6UnormBlockExt),
            #[cfg(feature = "VK_EXT_extension_289")]
            x if x == Self::Astc6x6x6SrgbBlockExt.bits() => Some(Self::Astc6x6x6SrgbBlockExt),
            #[cfg(feature = "VK_EXT_extension_289")]
            x if x == Self::Astc6x6x6SfloatBlockExt.bits() => Some(Self::Astc6x6x6SfloatBlockExt),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: i32) -> Self {
        std::mem::transmute(bits)
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for Format {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for Format {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkStructureType")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub enum StructureType {
    #[doc(alias = "VK_STRUCTURE_TYPE_APPLICATION_INFO")]
    ApplicationInfo = 0,
    #[doc(alias = "VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO")]
    InstanceCreateInfo = 1,
    #[doc(alias = "VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO")]
    DeviceQueueCreateInfo = 2,
    #[doc(alias = "VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO")]
    DeviceCreateInfo = 3,
    #[doc(alias = "VK_STRUCTURE_TYPE_SUBMIT_INFO")]
    SubmitInfo = 4,
    #[doc(alias = "VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO")]
    MemoryAllocateInfo = 5,
    #[doc(alias = "VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE")]
    MappedMemoryRange = 6,
    #[doc(alias = "VK_STRUCTURE_TYPE_BIND_SPARSE_INFO")]
    BindSparseInfo = 7,
    #[doc(alias = "VK_STRUCTURE_TYPE_FENCE_CREATE_INFO")]
    FenceCreateInfo = 8,
    #[doc(alias = "VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO")]
    SemaphoreCreateInfo = 9,
    #[doc(alias = "VK_STRUCTURE_TYPE_EVENT_CREATE_INFO")]
    EventCreateInfo = 10,
    #[doc(alias = "VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO")]
    QueryPoolCreateInfo = 11,
    #[doc(alias = "VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO")]
    BufferCreateInfo = 12,
    #[doc(alias = "VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO")]
    BufferViewCreateInfo = 13,
    #[doc(alias = "VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO")]
    ImageCreateInfo = 14,
    #[doc(alias = "VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO")]
    ImageViewCreateInfo = 15,
    #[doc(alias = "VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO")]
    ShaderModuleCreateInfo = 16,
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO")]
    PipelineCacheCreateInfo = 17,
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO")]
    PipelineShaderStageCreateInfo = 18,
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO")]
    PipelineVertexInputStateCreateInfo = 19,
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO")]
    PipelineInputAssemblyStateCreateInfo = 20,
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO")]
    PipelineTessellationStateCreateInfo = 21,
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO")]
    PipelineViewportStateCreateInfo = 22,
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO")]
    PipelineRasterizationStateCreateInfo = 23,
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO")]
    PipelineMultisampleStateCreateInfo = 24,
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO")]
    PipelineDepthStencilStateCreateInfo = 25,
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO")]
    PipelineColorBlendStateCreateInfo = 26,
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO")]
    PipelineDynamicStateCreateInfo = 27,
    #[doc(alias = "VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO")]
    GraphicsPipelineCreateInfo = 28,
    #[doc(alias = "VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO")]
    ComputePipelineCreateInfo = 29,
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO")]
    PipelineLayoutCreateInfo = 30,
    #[doc(alias = "VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO")]
    SamplerCreateInfo = 31,
    #[doc(alias = "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO")]
    DescriptorSetLayoutCreateInfo = 32,
    #[doc(alias = "VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO")]
    DescriptorPoolCreateInfo = 33,
    #[doc(alias = "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO")]
    DescriptorSetAllocateInfo = 34,
    #[doc(alias = "VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET")]
    WriteDescriptorSet = 35,
    #[doc(alias = "VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET")]
    CopyDescriptorSet = 36,
    #[doc(alias = "VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO")]
    FramebufferCreateInfo = 37,
    #[doc(alias = "VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO")]
    RenderPassCreateInfo = 38,
    #[doc(alias = "VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO")]
    CommandPoolCreateInfo = 39,
    #[doc(alias = "VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO")]
    CommandBufferAllocateInfo = 40,
    #[doc(alias = "VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO")]
    CommandBufferInheritanceInfo = 41,
    #[doc(alias = "VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO")]
    CommandBufferBeginInfo = 42,
    #[doc(alias = "VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO")]
    RenderPassBeginInfo = 43,
    #[doc(alias = "VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER")]
    BufferMemoryBarrier = 44,
    #[doc(alias = "VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER")]
    ImageMemoryBarrier = 45,
    #[doc(alias = "VK_STRUCTURE_TYPE_MEMORY_BARRIER")]
    MemoryBarrier = 46,
    #[doc(alias = "VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO")]
    LoaderInstanceCreateInfo = 47,
    #[doc(alias = "VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO")]
    LoaderDeviceCreateInfo = 48,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES")]
    PhysicalDeviceSubgroupProperties = 1000094000,
    #[doc(alias = "VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO")]
    #[doc(alias = "VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO_KHR")]
    BindBufferMemoryInfo = 1000157000,
    #[doc(alias = "VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO")]
    #[doc(alias = "VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO_KHR")]
    BindImageMemoryInfo = 1000157001,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES")]
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES_KHR")]
    PhysicalDevice16bitStorageFeatures = 1000083000,
    #[doc(alias = "VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS")]
    #[doc(alias = "VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS_KHR")]
    MemoryDedicatedRequirements = 1000127000,
    #[doc(alias = "VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO")]
    #[doc(alias = "VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_KHR")]
    MemoryDedicatedAllocateInfo = 1000127001,
    #[doc(alias = "VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO")]
    #[doc(alias = "VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO_KHR")]
    MemoryAllocateFlagsInfo = 1000060000,
    #[doc(alias = "VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO")]
    #[doc(alias = "VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO_KHR")]
    DeviceGroupRenderPassBeginInfo = 1000060003,
    #[doc(alias = "VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO")]
    #[doc(alias = "VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO_KHR")]
    DeviceGroupCommandBufferBeginInfo = 1000060004,
    #[doc(alias = "VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO")]
    #[doc(alias = "VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO_KHR")]
    DeviceGroupSubmitInfo = 1000060005,
    #[doc(alias = "VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO")]
    #[doc(alias = "VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO_KHR")]
    DeviceGroupBindSparseInfo = 1000060006,
    #[doc(alias = "VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO")]
    #[doc(alias = "VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO_KHR")]
    BindBufferMemoryDeviceGroupInfo = 1000060013,
    #[doc(alias = "VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO")]
    #[doc(alias = "VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO_KHR")]
    BindImageMemoryDeviceGroupInfo = 1000060014,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES")]
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES_KHR")]
    PhysicalDeviceGroupProperties = 1000070000,
    #[doc(alias = "VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO")]
    #[doc(alias = "VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO_KHR")]
    DeviceGroupDeviceCreateInfo = 1000070001,
    #[doc(alias = "VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2")]
    #[doc(alias = "VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2_KHR")]
    BufferMemoryRequirementsInfo2 = 1000146000,
    #[doc(alias = "VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2")]
    #[doc(alias = "VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2_KHR")]
    ImageMemoryRequirementsInfo2 = 1000146001,
    #[doc(alias = "VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2")]
    #[doc(alias = "VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2_KHR")]
    ImageSparseMemoryRequirementsInfo2 = 1000146002,
    #[doc(alias = "VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2")]
    #[doc(alias = "VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2_KHR")]
    MemoryRequirements2 = 1000146003,
    #[doc(alias = "VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2")]
    #[doc(alias = "VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2_KHR")]
    SparseImageMemoryRequirements2 = 1000146004,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2")]
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2_KHR")]
    PhysicalDeviceFeatures2 = 1000059000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2")]
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2_KHR")]
    PhysicalDeviceProperties2 = 1000059001,
    #[doc(alias = "VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2")]
    #[doc(alias = "VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2_KHR")]
    FormatProperties2 = 1000059002,
    #[doc(alias = "VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2")]
    #[doc(alias = "VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2_KHR")]
    ImageFormatProperties2 = 1000059003,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2")]
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2_KHR")]
    PhysicalDeviceImageFormatInfo2 = 1000059004,
    #[doc(alias = "VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2")]
    #[doc(alias = "VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2_KHR")]
    QueueFamilyProperties2 = 1000059005,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2")]
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2_KHR")]
    PhysicalDeviceMemoryProperties2 = 1000059006,
    #[doc(alias = "VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2")]
    #[doc(alias = "VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2_KHR")]
    SparseImageFormatProperties2 = 1000059007,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2")]
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2_KHR")]
    PhysicalDeviceSparseImageFormatInfo2 = 1000059008,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES")]
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES_KHR")]
    PhysicalDevicePointClippingProperties = 1000117000,
    #[doc(alias = "VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO")]
    #[doc(alias = "VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO_KHR")]
    RenderPassInputAttachmentAspectCreateInfo = 1000117001,
    #[doc(alias = "VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO")]
    #[doc(alias = "VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO_KHR")]
    ImageViewUsageCreateInfo = 1000117002,
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO")]
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO_KHR")]
    PipelineTessellationDomainOriginStateCreateInfo = 1000117003,
    #[doc(alias = "VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO")]
    #[doc(alias = "VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO_KHR")]
    RenderPassMultiviewCreateInfo = 1000053000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES")]
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES_KHR")]
    PhysicalDeviceMultiviewFeatures = 1000053001,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES")]
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES_KHR")]
    PhysicalDeviceMultiviewProperties = 1000053002,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES")]
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES")]
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES_KHR")]
    PhysicalDeviceVariablePointersFeatures = 1000120000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO")]
    ProtectedSubmitInfo = 1000145000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES")]
    PhysicalDeviceProtectedMemoryFeatures = 1000145001,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES")]
    PhysicalDeviceProtectedMemoryProperties = 1000145002,
    #[doc(alias = "VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2")]
    DeviceQueueInfo2 = 1000145003,
    #[doc(alias = "VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO")]
    #[doc(alias = "VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO_KHR")]
    SamplerYcbcrConversionCreateInfo = 1000156000,
    #[doc(alias = "VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO")]
    #[doc(alias = "VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO_KHR")]
    SamplerYcbcrConversionInfo = 1000156001,
    #[doc(alias = "VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO")]
    #[doc(alias = "VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO_KHR")]
    BindImagePlaneMemoryInfo = 1000156002,
    #[doc(alias = "VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO")]
    #[doc(alias = "VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO_KHR")]
    ImagePlaneMemoryRequirementsInfo = 1000156003,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES")]
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES_KHR")]
    PhysicalDeviceSamplerYcbcrConversionFeatures = 1000156004,
    #[doc(alias = "VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES")]
    #[doc(alias = "VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES_KHR")]
    SamplerYcbcrConversionImageFormatProperties = 1000156005,
    #[doc(alias = "VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO")]
    #[doc(alias = "VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO_KHR")]
    DescriptorUpdateTemplateCreateInfo = 1000085000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO")]
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO_KHR")]
    PhysicalDeviceExternalImageFormatInfo = 1000071000,
    #[doc(alias = "VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES")]
    #[doc(alias = "VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES_KHR")]
    ExternalImageFormatProperties = 1000071001,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO")]
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO_KHR")]
    PhysicalDeviceExternalBufferInfo = 1000071002,
    #[doc(alias = "VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES")]
    #[doc(alias = "VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES_KHR")]
    ExternalBufferProperties = 1000071003,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES")]
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES_KHR")]
    PhysicalDeviceIdProperties = 1000071004,
    #[doc(alias = "VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO")]
    #[doc(alias = "VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO_KHR")]
    ExternalMemoryBufferCreateInfo = 1000072000,
    #[doc(alias = "VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO")]
    #[doc(alias = "VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_KHR")]
    ExternalMemoryImageCreateInfo = 1000072001,
    #[doc(alias = "VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO")]
    #[doc(alias = "VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_KHR")]
    ExportMemoryAllocateInfo = 1000072002,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO")]
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO_KHR")]
    PhysicalDeviceExternalFenceInfo = 1000112000,
    #[doc(alias = "VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES")]
    #[doc(alias = "VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES_KHR")]
    ExternalFenceProperties = 1000112001,
    #[doc(alias = "VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO")]
    #[doc(alias = "VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO_KHR")]
    ExportFenceCreateInfo = 1000113000,
    #[doc(alias = "VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO")]
    #[doc(alias = "VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO_KHR")]
    ExportSemaphoreCreateInfo = 1000077000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO")]
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO_KHR")]
    PhysicalDeviceExternalSemaphoreInfo = 1000076000,
    #[doc(alias = "VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES")]
    #[doc(alias = "VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES_KHR")]
    ExternalSemaphoreProperties = 1000076001,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES")]
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES_KHR")]
    PhysicalDeviceMaintenance3Properties = 1000168000,
    #[doc(alias = "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT")]
    #[doc(alias = "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT_KHR")]
    DescriptorSetLayoutSupport = 1000168001,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES")]
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES")]
    PhysicalDeviceShaderDrawParametersFeatures = 1000063000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES")]
    #[cfg(feature = "VULKAN_1_2")]
    PhysicalDeviceVulkan11Features = 49,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES")]
    #[cfg(feature = "VULKAN_1_2")]
    PhysicalDeviceVulkan11Properties = 50,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES")]
    #[cfg(feature = "VULKAN_1_2")]
    PhysicalDeviceVulkan12Features = 51,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES")]
    #[cfg(feature = "VULKAN_1_2")]
    PhysicalDeviceVulkan12Properties = 52,
    #[doc(alias = "VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO")]
    #[doc(alias = "VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR")]
    #[cfg(feature = "VULKAN_1_2")]
    ImageFormatListCreateInfo = 1000147000,
    #[doc(alias = "VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2")]
    #[doc(alias = "VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2_KHR")]
    #[cfg(feature = "VULKAN_1_2")]
    AttachmentDescription2 = 1000109000,
    #[doc(alias = "VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2")]
    #[doc(alias = "VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2_KHR")]
    #[cfg(feature = "VULKAN_1_2")]
    AttachmentReference2 = 1000109001,
    #[doc(alias = "VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2")]
    #[doc(alias = "VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2_KHR")]
    #[cfg(feature = "VULKAN_1_2")]
    SubpassDescription2 = 1000109002,
    #[doc(alias = "VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2")]
    #[doc(alias = "VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2_KHR")]
    #[cfg(feature = "VULKAN_1_2")]
    SubpassDependency2 = 1000109003,
    #[doc(alias = "VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2")]
    #[doc(alias = "VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2_KHR")]
    #[cfg(feature = "VULKAN_1_2")]
    RenderPassCreateInfo2 = 1000109004,
    #[doc(alias = "VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO")]
    #[doc(alias = "VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO_KHR")]
    #[cfg(feature = "VULKAN_1_2")]
    SubpassBeginInfo = 1000109005,
    #[doc(alias = "VK_STRUCTURE_TYPE_SUBPASS_END_INFO")]
    #[doc(alias = "VK_STRUCTURE_TYPE_SUBPASS_END_INFO_KHR")]
    #[cfg(feature = "VULKAN_1_2")]
    SubpassEndInfo = 1000109006,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES")]
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR")]
    #[cfg(feature = "VULKAN_1_2")]
    PhysicalDevice8bitStorageFeatures = 1000177000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES")]
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES_KHR")]
    #[cfg(feature = "VULKAN_1_2")]
    PhysicalDeviceDriverProperties = 1000196000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES")]
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES_KHR")]
    #[cfg(feature = "VULKAN_1_2")]
    PhysicalDeviceShaderAtomicInt64Features = 1000180000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES")]
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES_KHR")]
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT16_INT8_FEATURES_KHR")]
    #[cfg(feature = "VULKAN_1_2")]
    PhysicalDeviceShaderFloat16Int8Features = 1000082000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES")]
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES_KHR")]
    #[cfg(feature = "VULKAN_1_2")]
    PhysicalDeviceFloatControlsProperties = 1000197000,
    #[doc(alias = "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO")]
    #[doc(alias = "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT")]
    #[cfg(feature = "VULKAN_1_2")]
    DescriptorSetLayoutBindingFlagsCreateInfo = 1000161000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES")]
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT")]
    #[cfg(feature = "VULKAN_1_2")]
    PhysicalDeviceDescriptorIndexingFeatures = 1000161001,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES")]
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT")]
    #[cfg(feature = "VULKAN_1_2")]
    PhysicalDeviceDescriptorIndexingProperties = 1000161002,
    #[doc(alias = "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO")]
    #[doc(alias = "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT")]
    #[cfg(feature = "VULKAN_1_2")]
    DescriptorSetVariableDescriptorCountAllocateInfo = 1000161003,
    #[doc(alias = "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT")]
    #[doc(alias = "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT")]
    #[cfg(feature = "VULKAN_1_2")]
    DescriptorSetVariableDescriptorCountLayoutSupport = 1000161004,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES")]
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES_KHR")]
    #[cfg(feature = "VULKAN_1_2")]
    PhysicalDeviceDepthStencilResolveProperties = 1000199000,
    #[doc(alias = "VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE")]
    #[doc(alias = "VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE_KHR")]
    #[cfg(feature = "VULKAN_1_2")]
    SubpassDescriptionDepthStencilResolve = 1000199001,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES")]
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES_EXT")]
    #[cfg(feature = "VULKAN_1_2")]
    PhysicalDeviceScalarBlockLayoutFeatures = 1000221000,
    #[doc(alias = "VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO")]
    #[doc(alias = "VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO_EXT")]
    #[cfg(feature = "VULKAN_1_2")]
    ImageStencilUsageCreateInfo = 1000246000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES")]
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT")]
    #[cfg(feature = "VULKAN_1_2")]
    PhysicalDeviceSamplerFilterMinmaxProperties = 1000130000,
    #[doc(alias = "VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO")]
    #[doc(alias = "VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT")]
    #[cfg(feature = "VULKAN_1_2")]
    SamplerReductionModeCreateInfo = 1000130001,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES")]
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES_KHR")]
    #[cfg(feature = "VULKAN_1_2")]
    PhysicalDeviceVulkanMemoryModelFeatures = 1000211000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES")]
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES_KHR")]
    #[cfg(feature = "VULKAN_1_2")]
    PhysicalDeviceImagelessFramebufferFeatures = 1000108000,
    #[doc(alias = "VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO")]
    #[doc(alias = "VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO_KHR")]
    #[cfg(feature = "VULKAN_1_2")]
    FramebufferAttachmentsCreateInfo = 1000108001,
    #[doc(alias = "VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO")]
    #[doc(alias = "VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO_KHR")]
    #[cfg(feature = "VULKAN_1_2")]
    FramebufferAttachmentImageInfo = 1000108002,
    #[doc(alias = "VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO")]
    #[doc(alias = "VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO_KHR")]
    #[cfg(feature = "VULKAN_1_2")]
    RenderPassAttachmentBeginInfo = 1000108003,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES")]
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES_KHR")]
    #[cfg(feature = "VULKAN_1_2")]
    PhysicalDeviceUniformBufferStandardLayoutFeatures = 1000253000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES")]
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES_KHR")]
    #[cfg(feature = "VULKAN_1_2")]
    PhysicalDeviceShaderSubgroupExtendedTypesFeatures = 1000175000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES")]
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES_KHR")]
    #[cfg(feature = "VULKAN_1_2")]
    PhysicalDeviceSeparateDepthStencilLayoutsFeatures = 1000241000,
    #[doc(alias = "VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT")]
    #[doc(alias = "VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT_KHR")]
    #[cfg(feature = "VULKAN_1_2")]
    AttachmentReferenceStencilLayout = 1000241001,
    #[doc(alias = "VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT")]
    #[doc(alias = "VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT_KHR")]
    #[cfg(feature = "VULKAN_1_2")]
    AttachmentDescriptionStencilLayout = 1000241002,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES")]
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES_EXT")]
    #[cfg(feature = "VULKAN_1_2")]
    PhysicalDeviceHostQueryResetFeatures = 1000261000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES")]
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES_KHR")]
    #[cfg(feature = "VULKAN_1_2")]
    PhysicalDeviceTimelineSemaphoreFeatures = 1000207000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES")]
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES_KHR")]
    #[cfg(feature = "VULKAN_1_2")]
    PhysicalDeviceTimelineSemaphoreProperties = 1000207001,
    #[doc(alias = "VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO")]
    #[doc(alias = "VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO_KHR")]
    #[cfg(feature = "VULKAN_1_2")]
    SemaphoreTypeCreateInfo = 1000207002,
    #[doc(alias = "VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO")]
    #[doc(alias = "VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO_KHR")]
    #[cfg(feature = "VULKAN_1_2")]
    TimelineSemaphoreSubmitInfo = 1000207003,
    #[doc(alias = "VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO")]
    #[doc(alias = "VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO_KHR")]
    #[cfg(feature = "VULKAN_1_2")]
    SemaphoreWaitInfo = 1000207004,
    #[doc(alias = "VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO")]
    #[doc(alias = "VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO_KHR")]
    #[cfg(feature = "VULKAN_1_2")]
    SemaphoreSignalInfo = 1000207005,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES")]
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_KHR")]
    #[cfg(feature = "VULKAN_1_2")]
    PhysicalDeviceBufferDeviceAddressFeatures = 1000257000,
    #[doc(alias = "VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO")]
    #[doc(alias = "VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_EXT")]
    #[doc(alias = "VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_KHR")]
    #[cfg(feature = "VULKAN_1_2")]
    BufferDeviceAddressInfo = 1000244001,
    #[doc(alias = "VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO")]
    #[doc(alias = "VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO_KHR")]
    #[cfg(feature = "VULKAN_1_2")]
    BufferOpaqueCaptureAddressCreateInfo = 1000257002,
    #[doc(alias = "VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO")]
    #[doc(alias = "VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO_KHR")]
    #[cfg(feature = "VULKAN_1_2")]
    MemoryOpaqueCaptureAddressAllocateInfo = 1000257003,
    #[doc(alias = "VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO")]
    #[doc(alias = "VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO_KHR")]
    #[cfg(feature = "VULKAN_1_2")]
    DeviceMemoryOpaqueCaptureAddressInfo = 1000257004,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES")]
    #[cfg(feature = "VULKAN_1_3")]
    PhysicalDeviceVulkan13Features = 53,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES")]
    #[cfg(feature = "VULKAN_1_3")]
    PhysicalDeviceVulkan13Properties = 54,
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO")]
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO_EXT")]
    #[cfg(feature = "VULKAN_1_3")]
    PipelineCreationFeedbackCreateInfo = 1000192000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES")]
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES_KHR")]
    #[cfg(feature = "VULKAN_1_3")]
    PhysicalDeviceShaderTerminateInvocationFeatures = 1000215000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES")]
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES_EXT")]
    #[cfg(feature = "VULKAN_1_3")]
    PhysicalDeviceToolProperties = 1000245000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES")]
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES_EXT")]
    #[cfg(feature = "VULKAN_1_3")]
    PhysicalDeviceShaderDemoteToHelperInvocationFeatures = 1000276000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES")]
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES_EXT")]
    #[cfg(feature = "VULKAN_1_3")]
    PhysicalDevicePrivateDataFeatures = 1000295000,
    #[doc(alias = "VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO")]
    #[doc(alias = "VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO_EXT")]
    #[cfg(feature = "VULKAN_1_3")]
    DevicePrivateDataCreateInfo = 1000295001,
    #[doc(alias = "VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO")]
    #[doc(alias = "VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO_EXT")]
    #[cfg(feature = "VULKAN_1_3")]
    PrivateDataSlotCreateInfo = 1000295002,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES")]
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES_EXT")]
    #[cfg(feature = "VULKAN_1_3")]
    PhysicalDevicePipelineCreationCacheControlFeatures = 1000297000,
    #[doc(alias = "VK_STRUCTURE_TYPE_MEMORY_BARRIER_2")]
    #[doc(alias = "VK_STRUCTURE_TYPE_MEMORY_BARRIER_2_KHR")]
    #[cfg(feature = "VULKAN_1_3")]
    MemoryBarrier2 = 1000314000,
    #[doc(alias = "VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2")]
    #[doc(alias = "VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2_KHR")]
    #[cfg(feature = "VULKAN_1_3")]
    BufferMemoryBarrier2 = 1000314001,
    #[doc(alias = "VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2")]
    #[doc(alias = "VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2_KHR")]
    #[cfg(feature = "VULKAN_1_3")]
    ImageMemoryBarrier2 = 1000314002,
    #[doc(alias = "VK_STRUCTURE_TYPE_DEPENDENCY_INFO")]
    #[doc(alias = "VK_STRUCTURE_TYPE_DEPENDENCY_INFO_KHR")]
    #[cfg(feature = "VULKAN_1_3")]
    DependencyInfo = 1000314003,
    #[doc(alias = "VK_STRUCTURE_TYPE_SUBMIT_INFO_2")]
    #[doc(alias = "VK_STRUCTURE_TYPE_SUBMIT_INFO_2_KHR")]
    #[cfg(feature = "VULKAN_1_3")]
    SubmitInfo2 = 1000314004,
    #[doc(alias = "VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO")]
    #[doc(alias = "VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO_KHR")]
    #[cfg(feature = "VULKAN_1_3")]
    SemaphoreSubmitInfo = 1000314005,
    #[doc(alias = "VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO")]
    #[doc(alias = "VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO_KHR")]
    #[cfg(feature = "VULKAN_1_3")]
    CommandBufferSubmitInfo = 1000314006,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES")]
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES_KHR")]
    #[cfg(feature = "VULKAN_1_3")]
    PhysicalDeviceSynchronization2Features = 1000314007,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES")]
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES_KHR")]
    #[cfg(feature = "VULKAN_1_3")]
    PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures = 1000325000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES")]
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES_EXT")]
    #[cfg(feature = "VULKAN_1_3")]
    PhysicalDeviceImageRobustnessFeatures = 1000335000,
    #[doc(alias = "VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2")]
    #[doc(alias = "VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2_KHR")]
    #[cfg(feature = "VULKAN_1_3")]
    CopyBufferInfo2 = 1000337000,
    #[doc(alias = "VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2")]
    #[doc(alias = "VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2_KHR")]
    #[cfg(feature = "VULKAN_1_3")]
    CopyImageInfo2 = 1000337001,
    #[doc(alias = "VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2")]
    #[doc(alias = "VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2_KHR")]
    #[cfg(feature = "VULKAN_1_3")]
    CopyBufferToImageInfo2 = 1000337002,
    #[doc(alias = "VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2")]
    #[doc(alias = "VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2_KHR")]
    #[cfg(feature = "VULKAN_1_3")]
    CopyImageToBufferInfo2 = 1000337003,
    #[doc(alias = "VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2")]
    #[doc(alias = "VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2_KHR")]
    #[cfg(feature = "VULKAN_1_3")]
    BlitImageInfo2 = 1000337004,
    #[doc(alias = "VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2")]
    #[doc(alias = "VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2_KHR")]
    #[cfg(feature = "VULKAN_1_3")]
    ResolveImageInfo2 = 1000337005,
    #[doc(alias = "VK_STRUCTURE_TYPE_BUFFER_COPY_2")]
    #[doc(alias = "VK_STRUCTURE_TYPE_BUFFER_COPY_2_KHR")]
    #[cfg(feature = "VULKAN_1_3")]
    BufferCopy2 = 1000337006,
    #[doc(alias = "VK_STRUCTURE_TYPE_IMAGE_COPY_2")]
    #[doc(alias = "VK_STRUCTURE_TYPE_IMAGE_COPY_2_KHR")]
    #[cfg(feature = "VULKAN_1_3")]
    ImageCopy2 = 1000337007,
    #[doc(alias = "VK_STRUCTURE_TYPE_IMAGE_BLIT_2")]
    #[doc(alias = "VK_STRUCTURE_TYPE_IMAGE_BLIT_2_KHR")]
    #[cfg(feature = "VULKAN_1_3")]
    ImageBlit2 = 1000337008,
    #[doc(alias = "VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2")]
    #[doc(alias = "VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2_KHR")]
    #[cfg(feature = "VULKAN_1_3")]
    BufferImageCopy2 = 1000337009,
    #[doc(alias = "VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2")]
    #[doc(alias = "VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2_KHR")]
    #[cfg(feature = "VULKAN_1_3")]
    ImageResolve2 = 1000337010,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES")]
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES_EXT")]
    #[cfg(feature = "VULKAN_1_3")]
    PhysicalDeviceSubgroupSizeControlProperties = 1000225000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO")]
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO_EXT")]
    #[cfg(feature = "VULKAN_1_3")]
    PipelineShaderStageRequiredSubgroupSizeCreateInfo = 1000225001,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES")]
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES_EXT")]
    #[cfg(feature = "VULKAN_1_3")]
    PhysicalDeviceSubgroupSizeControlFeatures = 1000225002,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES")]
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT")]
    #[cfg(feature = "VULKAN_1_3")]
    PhysicalDeviceInlineUniformBlockFeatures = 1000138000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES")]
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES_EXT")]
    #[cfg(feature = "VULKAN_1_3")]
    PhysicalDeviceInlineUniformBlockProperties = 1000138001,
    #[doc(alias = "VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK")]
    #[doc(alias = "VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT")]
    #[cfg(feature = "VULKAN_1_3")]
    WriteDescriptorSetInlineUniformBlock = 1000138002,
    #[doc(alias = "VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO")]
    #[doc(alias = "VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO_EXT")]
    #[cfg(feature = "VULKAN_1_3")]
    DescriptorPoolInlineUniformBlockCreateInfo = 1000138003,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES")]
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES_EXT")]
    #[cfg(feature = "VULKAN_1_3")]
    PhysicalDeviceTextureCompressionAstcHdrFeatures = 1000066000,
    #[doc(alias = "VK_STRUCTURE_TYPE_RENDERING_INFO")]
    #[doc(alias = "VK_STRUCTURE_TYPE_RENDERING_INFO_KHR")]
    #[cfg(feature = "VULKAN_1_3")]
    RenderingInfo = 1000044000,
    #[doc(alias = "VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO")]
    #[doc(alias = "VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO_KHR")]
    #[cfg(feature = "VULKAN_1_3")]
    RenderingAttachmentInfo = 1000044001,
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO")]
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO_KHR")]
    #[cfg(feature = "VULKAN_1_3")]
    PipelineRenderingCreateInfo = 1000044002,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES")]
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES_KHR")]
    #[cfg(feature = "VULKAN_1_3")]
    PhysicalDeviceDynamicRenderingFeatures = 1000044003,
    #[doc(alias = "VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO")]
    #[doc(alias = "VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO_KHR")]
    #[cfg(feature = "VULKAN_1_3")]
    CommandBufferInheritanceRenderingInfo = 1000044004,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES")]
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES_KHR")]
    #[cfg(feature = "VULKAN_1_3")]
    PhysicalDeviceShaderIntegerDotProductFeatures = 1000280000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES")]
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES_KHR")]
    #[cfg(feature = "VULKAN_1_3")]
    PhysicalDeviceShaderIntegerDotProductProperties = 1000280001,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES")]
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES_EXT")]
    #[cfg(feature = "VULKAN_1_3")]
    PhysicalDeviceTexelBufferAlignmentProperties = 1000281001,
    #[doc(alias = "VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3")]
    #[doc(alias = "VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3_KHR")]
    #[cfg(feature = "VULKAN_1_3")]
    FormatProperties3 = 1000360000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES")]
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES_KHR")]
    #[cfg(feature = "VULKAN_1_3")]
    PhysicalDeviceMaintenance4Features = 1000413000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES")]
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES_KHR")]
    #[cfg(feature = "VULKAN_1_3")]
    PhysicalDeviceMaintenance4Properties = 1000413001,
    #[doc(alias = "VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS")]
    #[doc(alias = "VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS_KHR")]
    #[cfg(feature = "VULKAN_1_3")]
    DeviceBufferMemoryRequirements = 1000413002,
    #[doc(alias = "VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS")]
    #[doc(alias = "VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS_KHR")]
    #[cfg(feature = "VULKAN_1_3")]
    DeviceImageMemoryRequirements = 1000413003,
    #[doc(alias = "VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR")]
    #[cfg(feature = "VK_KHR_swapchain")]
    SwapchainCreateInfoKhr = 1000001000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PRESENT_INFO_KHR")]
    #[cfg(feature = "VK_KHR_swapchain")]
    PresentInfoKhr = 1000001001,
    #[doc(alias = "VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR")]
    #[cfg(feature = "VK_KHR_device_group")]
    DeviceGroupPresentCapabilitiesKhr = 1000060007,
    #[doc(alias = "VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR")]
    #[cfg(feature = "VK_KHR_device_group")]
    ImageSwapchainCreateInfoKhr = 1000060008,
    #[doc(alias = "VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR")]
    #[cfg(feature = "VK_KHR_device_group")]
    BindImageMemorySwapchainInfoKhr = 1000060009,
    #[doc(alias = "VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR")]
    #[cfg(feature = "VK_KHR_device_group")]
    AcquireNextImageInfoKhr = 1000060010,
    #[doc(alias = "VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR")]
    #[cfg(feature = "VK_KHR_device_group")]
    DeviceGroupPresentInfoKhr = 1000060011,
    #[doc(alias = "VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR")]
    #[cfg(feature = "VK_KHR_device_group")]
    DeviceGroupSwapchainCreateInfoKhr = 1000060012,
    #[doc(alias = "VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR")]
    #[cfg(feature = "VK_KHR_display")]
    DisplayModeCreateInfoKhr = 1000002000,
    #[doc(alias = "VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR")]
    #[cfg(feature = "VK_KHR_display")]
    DisplaySurfaceCreateInfoKhr = 1000002001,
    #[doc(alias = "VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR")]
    #[cfg(feature = "VK_KHR_display_swapchain")]
    DisplayPresentInfoKhr = 1000003000,
    #[doc(alias = "VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR")]
    #[cfg(feature = "VK_KHR_xlib_surface")]
    XlibSurfaceCreateInfoKhr = 1000004000,
    #[doc(alias = "VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR")]
    #[cfg(feature = "VK_KHR_xcb_surface")]
    XcbSurfaceCreateInfoKhr = 1000005000,
    #[doc(alias = "VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR")]
    #[cfg(feature = "VK_KHR_wayland_surface")]
    WaylandSurfaceCreateInfoKhr = 1000006000,
    #[doc(alias = "VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR")]
    #[cfg(feature = "VK_KHR_android_surface")]
    AndroidSurfaceCreateInfoKhr = 1000008000,
    #[doc(alias = "VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR")]
    #[cfg(feature = "VK_KHR_win32_surface")]
    Win32SurfaceCreateInfoKhr = 1000009000,
    #[doc(alias = "VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT")]
    #[doc(alias = "VK_STRUCTURE_TYPE_DEBUG_REPORT_CREATE_INFO_EXT")]
    #[cfg(feature = "VK_EXT_debug_report")]
    DebugReportCallbackCreateInfoExt = 1000011000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD")]
    #[cfg(feature = "VK_AMD_rasterization_order")]
    PipelineRasterizationStateRasterizationOrderAmd = 1000018000,
    #[doc(alias = "VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT")]
    #[cfg(feature = "VK_EXT_debug_marker")]
    DebugMarkerObjectNameInfoExt = 1000022000,
    #[doc(alias = "VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT")]
    #[cfg(feature = "VK_EXT_debug_marker")]
    DebugMarkerObjectTagInfoExt = 1000022001,
    #[doc(alias = "VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT")]
    #[cfg(feature = "VK_EXT_debug_marker")]
    DebugMarkerMarkerInfoExt = 1000022002,
    #[doc(alias = "VK_STRUCTURE_TYPE_VIDEO_PROFILE_KHR")]
    #[cfg(feature = "VK_KHR_video_queue")]
    VideoProfileKhr = 1000023000,
    #[doc(alias = "VK_STRUCTURE_TYPE_VIDEO_CAPABILITIES_KHR")]
    #[cfg(feature = "VK_KHR_video_queue")]
    VideoCapabilitiesKhr = 1000023001,
    #[doc(alias = "VK_STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_KHR")]
    #[cfg(feature = "VK_KHR_video_queue")]
    VideoPictureResourceKhr = 1000023002,
    #[doc(alias = "VK_STRUCTURE_TYPE_VIDEO_GET_MEMORY_PROPERTIES_KHR")]
    #[cfg(feature = "VK_KHR_video_queue")]
    VideoGetMemoryPropertiesKhr = 1000023003,
    #[doc(alias = "VK_STRUCTURE_TYPE_VIDEO_BIND_MEMORY_KHR")]
    #[cfg(feature = "VK_KHR_video_queue")]
    VideoBindMemoryKhr = 1000023004,
    #[doc(alias = "VK_STRUCTURE_TYPE_VIDEO_SESSION_CREATE_INFO_KHR")]
    #[cfg(feature = "VK_KHR_video_queue")]
    VideoSessionCreateInfoKhr = 1000023005,
    #[doc(alias = "VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_CREATE_INFO_KHR")]
    #[cfg(feature = "VK_KHR_video_queue")]
    VideoSessionParametersCreateInfoKhr = 1000023006,
    #[doc(alias = "VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_UPDATE_INFO_KHR")]
    #[cfg(feature = "VK_KHR_video_queue")]
    VideoSessionParametersUpdateInfoKhr = 1000023007,
    #[doc(alias = "VK_STRUCTURE_TYPE_VIDEO_BEGIN_CODING_INFO_KHR")]
    #[cfg(feature = "VK_KHR_video_queue")]
    VideoBeginCodingInfoKhr = 1000023008,
    #[doc(alias = "VK_STRUCTURE_TYPE_VIDEO_END_CODING_INFO_KHR")]
    #[cfg(feature = "VK_KHR_video_queue")]
    VideoEndCodingInfoKhr = 1000023009,
    #[doc(alias = "VK_STRUCTURE_TYPE_VIDEO_CODING_CONTROL_INFO_KHR")]
    #[cfg(feature = "VK_KHR_video_queue")]
    VideoCodingControlInfoKhr = 1000023010,
    #[doc(alias = "VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_KHR")]
    #[cfg(feature = "VK_KHR_video_queue")]
    VideoReferenceSlotKhr = 1000023011,
    #[doc(alias = "VK_STRUCTURE_TYPE_VIDEO_QUEUE_FAMILY_PROPERTIES_2_KHR")]
    #[cfg(feature = "VK_KHR_video_queue")]
    VideoQueueFamilyProperties2Khr = 1000023012,
    #[doc(alias = "VK_STRUCTURE_TYPE_VIDEO_PROFILES_KHR")]
    #[cfg(feature = "VK_KHR_video_queue")]
    VideoProfilesKhr = 1000023013,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_FORMAT_INFO_KHR")]
    #[cfg(feature = "VK_KHR_video_queue")]
    PhysicalDeviceVideoFormatInfoKhr = 1000023014,
    #[doc(alias = "VK_STRUCTURE_TYPE_VIDEO_FORMAT_PROPERTIES_KHR")]
    #[cfg(feature = "VK_KHR_video_queue")]
    VideoFormatPropertiesKhr = 1000023015,
    #[doc(alias = "VK_STRUCTURE_TYPE_QUEUE_FAMILY_QUERY_RESULT_STATUS_PROPERTIES_2_KHR")]
    #[cfg(feature = "VK_KHR_video_queue")]
    QueueFamilyQueryResultStatusProperties2Khr = 1000023016,
    #[doc(alias = "VK_STRUCTURE_TYPE_VIDEO_DECODE_INFO_KHR")]
    #[cfg(feature = "VK_KHR_video_decode_queue")]
    VideoDecodeInfoKhr = 1000024000,
    #[doc(alias = "VK_STRUCTURE_TYPE_VIDEO_DECODE_CAPABILITIES_KHR")]
    #[cfg(feature = "VK_KHR_video_decode_queue")]
    VideoDecodeCapabilitiesKhr = 1000024001,
    #[doc(alias = "VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV")]
    #[cfg(feature = "VK_NV_dedicated_allocation")]
    DedicatedAllocationImageCreateInfoNv = 1000026000,
    #[doc(alias = "VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV")]
    #[cfg(feature = "VK_NV_dedicated_allocation")]
    DedicatedAllocationBufferCreateInfoNv = 1000026001,
    #[doc(alias = "VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV")]
    #[cfg(feature = "VK_NV_dedicated_allocation")]
    DedicatedAllocationMemoryAllocateInfoNv = 1000026002,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT")]
    #[cfg(feature = "VK_EXT_transform_feedback")]
    PhysicalDeviceTransformFeedbackFeaturesExt = 1000028000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT")]
    #[cfg(feature = "VK_EXT_transform_feedback")]
    PhysicalDeviceTransformFeedbackPropertiesExt = 1000028001,
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT")]
    #[cfg(feature = "VK_EXT_transform_feedback")]
    PipelineRasterizationStateStreamCreateInfoExt = 1000028002,
    #[doc(alias = "VK_STRUCTURE_TYPE_CU_MODULE_CREATE_INFO_NVX")]
    #[cfg(feature = "VK_NVX_binary_import")]
    CuModuleCreateInfoNvx = 1000029000,
    #[doc(alias = "VK_STRUCTURE_TYPE_CU_FUNCTION_CREATE_INFO_NVX")]
    #[cfg(feature = "VK_NVX_binary_import")]
    CuFunctionCreateInfoNvx = 1000029001,
    #[doc(alias = "VK_STRUCTURE_TYPE_CU_LAUNCH_INFO_NVX")]
    #[cfg(feature = "VK_NVX_binary_import")]
    CuLaunchInfoNvx = 1000029002,
    #[doc(alias = "VK_STRUCTURE_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX")]
    #[cfg(feature = "VK_NVX_image_view_handle")]
    ImageViewHandleInfoNvx = 1000030000,
    #[doc(alias = "VK_STRUCTURE_TYPE_IMAGE_VIEW_ADDRESS_PROPERTIES_NVX")]
    #[cfg(feature = "VK_NVX_image_view_handle")]
    ImageViewAddressPropertiesNvx = 1000030001,
    #[doc(alias = "VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD")]
    #[cfg(feature = "VK_AMD_texture_gather_bias_lod")]
    TextureLodGatherFormatPropertiesAmd = 1000041000,
    #[doc(alias = "VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR")]
    #[cfg(feature = "VK_KHR_dynamic_rendering")]
    RenderingFragmentShadingRateAttachmentInfoKhr = 1000044006,
    #[doc(alias = "VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT")]
    #[cfg(feature = "VK_KHR_dynamic_rendering")]
    RenderingFragmentDensityMapAttachmentInfoExt = 1000044007,
    #[doc(alias = "VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD")]
    #[doc(alias = "VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_NV")]
    #[cfg(feature = "VK_KHR_dynamic_rendering")]
    AttachmentSampleCountInfoAmd = 1000044008,
    #[doc(alias = "VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX")]
    #[cfg(feature = "VK_KHR_dynamic_rendering")]
    MultiviewPerViewAttributesInfoNvx = 1000044009,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV")]
    #[cfg(feature = "VK_NV_corner_sampled_image")]
    PhysicalDeviceCornerSampledImageFeaturesNv = 1000050000,
    #[doc(alias = "VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV")]
    #[cfg(feature = "VK_NV_external_memory")]
    ExternalMemoryImageCreateInfoNv = 1000056000,
    #[doc(alias = "VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV")]
    #[cfg(feature = "VK_NV_external_memory")]
    ExportMemoryAllocateInfoNv = 1000056001,
    #[doc(alias = "VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV")]
    #[cfg(feature = "VK_NV_external_memory_win32")]
    ImportMemoryWin32HandleInfoNv = 1000057000,
    #[doc(alias = "VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV")]
    #[cfg(feature = "VK_NV_external_memory_win32")]
    ExportMemoryWin32HandleInfoNv = 1000057001,
    #[doc(alias = "VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV")]
    #[cfg(feature = "VK_NV_win32_keyed_mutex")]
    Win32KeyedMutexAcquireReleaseInfoNv = 1000058000,
    #[doc(alias = "VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT")]
    #[cfg(feature = "VK_EXT_validation_flags")]
    ValidationFlagsExt = 1000061000,
    #[doc(alias = "VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN")]
    #[cfg(feature = "VK_NN_vi_surface")]
    ViSurfaceCreateInfoNn = 1000062000,
    #[doc(alias = "VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT")]
    #[cfg(feature = "VK_EXT_astc_decode_mode")]
    ImageViewAstcDecodeModeExt = 1000067000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT")]
    #[cfg(feature = "VK_EXT_astc_decode_mode")]
    PhysicalDeviceAstcDecodeFeaturesExt = 1000067001,
    #[doc(alias = "VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR")]
    #[cfg(feature = "VK_KHR_external_memory_win32")]
    ImportMemoryWin32HandleInfoKhr = 1000073000,
    #[doc(alias = "VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR")]
    #[cfg(feature = "VK_KHR_external_memory_win32")]
    ExportMemoryWin32HandleInfoKhr = 1000073001,
    #[doc(alias = "VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR")]
    #[cfg(feature = "VK_KHR_external_memory_win32")]
    MemoryWin32HandlePropertiesKhr = 1000073002,
    #[doc(alias = "VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR")]
    #[cfg(feature = "VK_KHR_external_memory_win32")]
    MemoryGetWin32HandleInfoKhr = 1000073003,
    #[doc(alias = "VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR")]
    #[cfg(feature = "VK_KHR_external_memory_fd")]
    ImportMemoryFdInfoKhr = 1000074000,
    #[doc(alias = "VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR")]
    #[cfg(feature = "VK_KHR_external_memory_fd")]
    MemoryFdPropertiesKhr = 1000074001,
    #[doc(alias = "VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR")]
    #[cfg(feature = "VK_KHR_external_memory_fd")]
    MemoryGetFdInfoKhr = 1000074002,
    #[doc(alias = "VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR")]
    #[cfg(feature = "VK_KHR_win32_keyed_mutex")]
    Win32KeyedMutexAcquireReleaseInfoKhr = 1000075000,
    #[doc(alias = "VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR")]
    #[cfg(feature = "VK_KHR_external_semaphore_win32")]
    ImportSemaphoreWin32HandleInfoKhr = 1000078000,
    #[doc(alias = "VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR")]
    #[cfg(feature = "VK_KHR_external_semaphore_win32")]
    ExportSemaphoreWin32HandleInfoKhr = 1000078001,
    #[doc(alias = "VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR")]
    #[cfg(feature = "VK_KHR_external_semaphore_win32")]
    D3d12FenceSubmitInfoKhr = 1000078002,
    #[doc(alias = "VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR")]
    #[cfg(feature = "VK_KHR_external_semaphore_win32")]
    SemaphoreGetWin32HandleInfoKhr = 1000078003,
    #[doc(alias = "VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR")]
    #[cfg(feature = "VK_KHR_external_semaphore_fd")]
    ImportSemaphoreFdInfoKhr = 1000079000,
    #[doc(alias = "VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR")]
    #[cfg(feature = "VK_KHR_external_semaphore_fd")]
    SemaphoreGetFdInfoKhr = 1000079001,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR")]
    #[cfg(feature = "VK_KHR_push_descriptor")]
    PhysicalDevicePushDescriptorPropertiesKhr = 1000080000,
    #[doc(alias = "VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT")]
    #[cfg(feature = "VK_EXT_conditional_rendering")]
    CommandBufferInheritanceConditionalRenderingInfoExt = 1000081000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT")]
    #[cfg(feature = "VK_EXT_conditional_rendering")]
    PhysicalDeviceConditionalRenderingFeaturesExt = 1000081001,
    #[doc(alias = "VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT")]
    #[cfg(feature = "VK_EXT_conditional_rendering")]
    ConditionalRenderingBeginInfoExt = 1000081002,
    #[doc(alias = "VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR")]
    #[cfg(feature = "VK_KHR_incremental_present")]
    PresentRegionsKhr = 1000084000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV")]
    #[cfg(feature = "VK_NV_clip_space_w_scaling")]
    PipelineViewportWScalingStateCreateInfoNv = 1000087000,
    #[doc(alias = "VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT")]
    #[doc(alias = "VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES2_EXT")]
    #[cfg(feature = "VK_EXT_display_surface_counter")]
    SurfaceCapabilities2Ext = 1000090000,
    #[doc(alias = "VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT")]
    #[cfg(feature = "VK_EXT_display_control")]
    DisplayPowerInfoExt = 1000091000,
    #[doc(alias = "VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT")]
    #[cfg(feature = "VK_EXT_display_control")]
    DeviceEventInfoExt = 1000091001,
    #[doc(alias = "VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT")]
    #[cfg(feature = "VK_EXT_display_control")]
    DisplayEventInfoExt = 1000091002,
    #[doc(alias = "VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT")]
    #[cfg(feature = "VK_EXT_display_control")]
    SwapchainCounterCreateInfoExt = 1000091003,
    #[doc(alias = "VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE")]
    #[cfg(feature = "VK_GOOGLE_display_timing")]
    PresentTimesInfoGoogle = 1000092000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX")]
    #[cfg(feature = "VK_NVX_multiview_per_view_attributes")]
    PhysicalDeviceMultiviewPerViewAttributesPropertiesNvx = 1000097000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV")]
    #[cfg(feature = "VK_NV_viewport_swizzle")]
    PipelineViewportSwizzleStateCreateInfoNv = 1000098000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT")]
    #[cfg(feature = "VK_EXT_discard_rectangles")]
    PhysicalDeviceDiscardRectanglePropertiesExt = 1000099000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT")]
    #[cfg(feature = "VK_EXT_discard_rectangles")]
    PipelineDiscardRectangleStateCreateInfoExt = 1000099001,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT")]
    #[cfg(feature = "VK_EXT_conservative_rasterization")]
    PhysicalDeviceConservativeRasterizationPropertiesExt = 1000101000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT")]
    #[cfg(feature = "VK_EXT_conservative_rasterization")]
    PipelineRasterizationConservativeStateCreateInfoExt = 1000101001,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT")]
    #[cfg(feature = "VK_EXT_depth_clip_enable")]
    PhysicalDeviceDepthClipEnableFeaturesExt = 1000102000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT")]
    #[cfg(feature = "VK_EXT_depth_clip_enable")]
    PipelineRasterizationDepthClipStateCreateInfoExt = 1000102001,
    #[doc(alias = "VK_STRUCTURE_TYPE_HDR_METADATA_EXT")]
    #[cfg(feature = "VK_EXT_hdr_metadata")]
    HdrMetadataExt = 1000105000,
    #[doc(alias = "VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR")]
    #[cfg(feature = "VK_KHR_shared_presentable_image")]
    SharedPresentSurfaceCapabilitiesKhr = 1000111000,
    #[doc(alias = "VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR")]
    #[cfg(feature = "VK_KHR_external_fence_win32")]
    ImportFenceWin32HandleInfoKhr = 1000114000,
    #[doc(alias = "VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR")]
    #[cfg(feature = "VK_KHR_external_fence_win32")]
    ExportFenceWin32HandleInfoKhr = 1000114001,
    #[doc(alias = "VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR")]
    #[cfg(feature = "VK_KHR_external_fence_win32")]
    FenceGetWin32HandleInfoKhr = 1000114002,
    #[doc(alias = "VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR")]
    #[cfg(feature = "VK_KHR_external_fence_fd")]
    ImportFenceFdInfoKhr = 1000115000,
    #[doc(alias = "VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR")]
    #[cfg(feature = "VK_KHR_external_fence_fd")]
    FenceGetFdInfoKhr = 1000115001,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR")]
    #[cfg(feature = "VK_KHR_performance_query")]
    PhysicalDevicePerformanceQueryFeaturesKhr = 1000116000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR")]
    #[cfg(feature = "VK_KHR_performance_query")]
    PhysicalDevicePerformanceQueryPropertiesKhr = 1000116001,
    #[doc(alias = "VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR")]
    #[cfg(feature = "VK_KHR_performance_query")]
    QueryPoolPerformanceCreateInfoKhr = 1000116002,
    #[doc(alias = "VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR")]
    #[cfg(feature = "VK_KHR_performance_query")]
    PerformanceQuerySubmitInfoKhr = 1000116003,
    #[doc(alias = "VK_STRUCTURE_TYPE_ACQUIRE_PROFILING_LOCK_INFO_KHR")]
    #[cfg(feature = "VK_KHR_performance_query")]
    AcquireProfilingLockInfoKhr = 1000116004,
    #[doc(alias = "VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_KHR")]
    #[cfg(feature = "VK_KHR_performance_query")]
    PerformanceCounterKhr = 1000116005,
    #[doc(alias = "VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_KHR")]
    #[cfg(feature = "VK_KHR_performance_query")]
    PerformanceCounterDescriptionKhr = 1000116006,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR")]
    #[cfg(feature = "VK_KHR_get_surface_capabilities2")]
    PhysicalDeviceSurfaceInfo2Khr = 1000119000,
    #[doc(alias = "VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR")]
    #[cfg(feature = "VK_KHR_get_surface_capabilities2")]
    SurfaceCapabilities2Khr = 1000119001,
    #[doc(alias = "VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR")]
    #[cfg(feature = "VK_KHR_get_surface_capabilities2")]
    SurfaceFormat2Khr = 1000119002,
    #[doc(alias = "VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR")]
    #[cfg(feature = "VK_KHR_get_display_properties2")]
    DisplayProperties2Khr = 1000121000,
    #[doc(alias = "VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR")]
    #[cfg(feature = "VK_KHR_get_display_properties2")]
    DisplayPlaneProperties2Khr = 1000121001,
    #[doc(alias = "VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR")]
    #[cfg(feature = "VK_KHR_get_display_properties2")]
    DisplayModeProperties2Khr = 1000121002,
    #[doc(alias = "VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR")]
    #[cfg(feature = "VK_KHR_get_display_properties2")]
    DisplayPlaneInfo2Khr = 1000121003,
    #[doc(alias = "VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR")]
    #[cfg(feature = "VK_KHR_get_display_properties2")]
    DisplayPlaneCapabilities2Khr = 1000121004,
    #[doc(alias = "VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK")]
    #[cfg(feature = "VK_MVK_ios_surface")]
    IosSurfaceCreateInfoMvk = 1000122000,
    #[doc(alias = "VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK")]
    #[cfg(feature = "VK_MVK_macos_surface")]
    MacosSurfaceCreateInfoMvk = 1000123000,
    #[doc(alias = "VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT")]
    #[cfg(feature = "VK_EXT_debug_utils")]
    DebugUtilsObjectNameInfoExt = 1000128000,
    #[doc(alias = "VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT")]
    #[cfg(feature = "VK_EXT_debug_utils")]
    DebugUtilsObjectTagInfoExt = 1000128001,
    #[doc(alias = "VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT")]
    #[cfg(feature = "VK_EXT_debug_utils")]
    DebugUtilsLabelExt = 1000128002,
    #[doc(alias = "VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT")]
    #[cfg(feature = "VK_EXT_debug_utils")]
    DebugUtilsMessengerCallbackDataExt = 1000128003,
    #[doc(alias = "VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT")]
    #[cfg(feature = "VK_EXT_debug_utils")]
    DebugUtilsMessengerCreateInfoExt = 1000128004,
    #[doc(alias = "VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID")]
    #[cfg(feature = "VK_ANDROID_external_memory_android_hardware_buffer")]
    AndroidHardwareBufferUsageAndroid = 1000129000,
    #[doc(alias = "VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID")]
    #[cfg(feature = "VK_ANDROID_external_memory_android_hardware_buffer")]
    AndroidHardwareBufferPropertiesAndroid = 1000129001,
    #[doc(alias = "VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID")]
    #[cfg(feature = "VK_ANDROID_external_memory_android_hardware_buffer")]
    AndroidHardwareBufferFormatPropertiesAndroid = 1000129002,
    #[doc(alias = "VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID")]
    #[cfg(feature = "VK_ANDROID_external_memory_android_hardware_buffer")]
    ImportAndroidHardwareBufferInfoAndroid = 1000129003,
    #[doc(alias = "VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID")]
    #[cfg(feature = "VK_ANDROID_external_memory_android_hardware_buffer")]
    MemoryGetAndroidHardwareBufferInfoAndroid = 1000129004,
    #[doc(alias = "VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID")]
    #[cfg(feature = "VK_ANDROID_external_memory_android_hardware_buffer")]
    ExternalFormatAndroid = 1000129005,
    #[doc(alias = "VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_2_ANDROID")]
    #[cfg(feature = "VK_ANDROID_external_memory_android_hardware_buffer")]
    AndroidHardwareBufferFormatProperties2Android = 1000129006,
    #[doc(alias = "VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT")]
    #[cfg(feature = "VK_EXT_sample_locations")]
    SampleLocationsInfoExt = 1000143000,
    #[doc(alias = "VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT")]
    #[cfg(feature = "VK_EXT_sample_locations")]
    RenderPassSampleLocationsBeginInfoExt = 1000143001,
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT")]
    #[cfg(feature = "VK_EXT_sample_locations")]
    PipelineSampleLocationsStateCreateInfoExt = 1000143002,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT")]
    #[cfg(feature = "VK_EXT_sample_locations")]
    PhysicalDeviceSampleLocationsPropertiesExt = 1000143003,
    #[doc(alias = "VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT")]
    #[cfg(feature = "VK_EXT_sample_locations")]
    MultisamplePropertiesExt = 1000143004,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    PhysicalDeviceBlendOperationAdvancedFeaturesExt = 1000148000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    PhysicalDeviceBlendOperationAdvancedPropertiesExt = 1000148001,
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT")]
    #[cfg(feature = "VK_EXT_blend_operation_advanced")]
    PipelineColorBlendAdvancedStateCreateInfoExt = 1000148002,
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV")]
    #[cfg(feature = "VK_NV_fragment_coverage_to_color")]
    PipelineCoverageToColorStateCreateInfoNv = 1000149000,
    #[doc(alias = "VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR")]
    #[cfg(feature = "VK_KHR_acceleration_structure")]
    WriteDescriptorSetAccelerationStructureKhr = 1000150007,
    #[doc(alias = "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR")]
    #[cfg(feature = "VK_KHR_acceleration_structure")]
    AccelerationStructureBuildGeometryInfoKhr = 1000150000,
    #[doc(alias = "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR")]
    #[cfg(feature = "VK_KHR_acceleration_structure")]
    AccelerationStructureDeviceAddressInfoKhr = 1000150002,
    #[doc(alias = "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR")]
    #[cfg(feature = "VK_KHR_acceleration_structure")]
    AccelerationStructureGeometryAabbsDataKhr = 1000150003,
    #[doc(alias = "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR")]
    #[cfg(feature = "VK_KHR_acceleration_structure")]
    AccelerationStructureGeometryInstancesDataKhr = 1000150004,
    #[doc(alias = "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR")]
    #[cfg(feature = "VK_KHR_acceleration_structure")]
    AccelerationStructureGeometryTrianglesDataKhr = 1000150005,
    #[doc(alias = "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR")]
    #[cfg(feature = "VK_KHR_acceleration_structure")]
    AccelerationStructureGeometryKhr = 1000150006,
    #[doc(alias = "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_VERSION_INFO_KHR")]
    #[cfg(feature = "VK_KHR_acceleration_structure")]
    AccelerationStructureVersionInfoKhr = 1000150009,
    #[doc(alias = "VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_INFO_KHR")]
    #[cfg(feature = "VK_KHR_acceleration_structure")]
    CopyAccelerationStructureInfoKhr = 1000150010,
    #[doc(alias = "VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR")]
    #[cfg(feature = "VK_KHR_acceleration_structure")]
    CopyAccelerationStructureToMemoryInfoKhr = 1000150011,
    #[doc(alias = "VK_STRUCTURE_TYPE_COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR")]
    #[cfg(feature = "VK_KHR_acceleration_structure")]
    CopyMemoryToAccelerationStructureInfoKhr = 1000150012,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR")]
    #[cfg(feature = "VK_KHR_acceleration_structure")]
    PhysicalDeviceAccelerationStructureFeaturesKhr = 1000150013,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR")]
    #[cfg(feature = "VK_KHR_acceleration_structure")]
    PhysicalDeviceAccelerationStructurePropertiesKhr = 1000150014,
    #[doc(alias = "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR")]
    #[cfg(feature = "VK_KHR_acceleration_structure")]
    AccelerationStructureCreateInfoKhr = 1000150017,
    #[doc(alias = "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR")]
    #[cfg(feature = "VK_KHR_acceleration_structure")]
    AccelerationStructureBuildSizesInfoKhr = 1000150020,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR")]
    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
    PhysicalDeviceRayTracingPipelineFeaturesKhr = 1000347000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR")]
    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
    PhysicalDeviceRayTracingPipelinePropertiesKhr = 1000347001,
    #[doc(alias = "VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR")]
    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
    RayTracingPipelineCreateInfoKhr = 1000150015,
    #[doc(alias = "VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR")]
    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
    RayTracingShaderGroupCreateInfoKhr = 1000150016,
    #[doc(alias = "VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_INTERFACE_CREATE_INFO_KHR")]
    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
    RayTracingPipelineInterfaceCreateInfoKhr = 1000150018,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR")]
    #[cfg(feature = "VK_KHR_ray_query")]
    PhysicalDeviceRayQueryFeaturesKhr = 1000348013,
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV")]
    #[cfg(feature = "VK_NV_framebuffer_mixed_samples")]
    PipelineCoverageModulationStateCreateInfoNv = 1000152000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV")]
    #[cfg(feature = "VK_NV_shader_sm_builtins")]
    PhysicalDeviceShaderSmBuiltinsFeaturesNv = 1000154000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV")]
    #[cfg(feature = "VK_NV_shader_sm_builtins")]
    PhysicalDeviceShaderSmBuiltinsPropertiesNv = 1000154001,
    #[doc(alias = "VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT")]
    #[cfg(feature = "VK_EXT_image_drm_format_modifier")]
    DrmFormatModifierPropertiesListExt = 1000158000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT")]
    #[cfg(feature = "VK_EXT_image_drm_format_modifier")]
    PhysicalDeviceImageDrmFormatModifierInfoExt = 1000158002,
    #[doc(alias = "VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT")]
    #[cfg(feature = "VK_EXT_image_drm_format_modifier")]
    ImageDrmFormatModifierListCreateInfoExt = 1000158003,
    #[doc(alias = "VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT")]
    #[cfg(feature = "VK_EXT_image_drm_format_modifier")]
    ImageDrmFormatModifierExplicitCreateInfoExt = 1000158004,
    #[doc(alias = "VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT")]
    #[cfg(feature = "VK_EXT_image_drm_format_modifier")]
    ImageDrmFormatModifierPropertiesExt = 1000158005,
    #[doc(alias = "VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT")]
    #[cfg(feature = "VK_EXT_image_drm_format_modifier")]
    DrmFormatModifierPropertiesList2Ext = 1000158006,
    #[doc(alias = "VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT")]
    #[cfg(feature = "VK_EXT_validation_cache")]
    ValidationCacheCreateInfoExt = 1000160000,
    #[doc(alias = "VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT")]
    #[cfg(feature = "VK_EXT_validation_cache")]
    ShaderModuleValidationCacheCreateInfoExt = 1000160001,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR")]
    #[cfg(feature = "VK_KHR_portability_subset")]
    PhysicalDevicePortabilitySubsetFeaturesKhr = 1000163000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_PROPERTIES_KHR")]
    #[cfg(feature = "VK_KHR_portability_subset")]
    PhysicalDevicePortabilitySubsetPropertiesKhr = 1000163001,
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV")]
    #[cfg(feature = "VK_NV_shading_rate_image")]
    PipelineViewportShadingRateImageStateCreateInfoNv = 1000164000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV")]
    #[cfg(feature = "VK_NV_shading_rate_image")]
    PhysicalDeviceShadingRateImageFeaturesNv = 1000164001,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV")]
    #[cfg(feature = "VK_NV_shading_rate_image")]
    PhysicalDeviceShadingRateImagePropertiesNv = 1000164002,
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV")]
    #[cfg(feature = "VK_NV_shading_rate_image")]
    PipelineViewportCoarseSampleOrderStateCreateInfoNv = 1000164005,
    #[doc(alias = "VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV")]
    #[cfg(feature = "VK_NV_ray_tracing")]
    RayTracingPipelineCreateInfoNv = 1000165000,
    #[doc(alias = "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV")]
    #[cfg(feature = "VK_NV_ray_tracing")]
    AccelerationStructureCreateInfoNv = 1000165001,
    #[doc(alias = "VK_STRUCTURE_TYPE_GEOMETRY_NV")]
    #[cfg(feature = "VK_NV_ray_tracing")]
    GeometryNv = 1000165003,
    #[doc(alias = "VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV")]
    #[cfg(feature = "VK_NV_ray_tracing")]
    GeometryTrianglesNv = 1000165004,
    #[doc(alias = "VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV")]
    #[cfg(feature = "VK_NV_ray_tracing")]
    GeometryAabbNv = 1000165005,
    #[doc(alias = "VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV")]
    #[cfg(feature = "VK_NV_ray_tracing")]
    BindAccelerationStructureMemoryInfoNv = 1000165006,
    #[doc(alias = "VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV")]
    #[cfg(feature = "VK_NV_ray_tracing")]
    WriteDescriptorSetAccelerationStructureNv = 1000165007,
    #[doc(alias = "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV")]
    #[cfg(feature = "VK_NV_ray_tracing")]
    AccelerationStructureMemoryRequirementsInfoNv = 1000165008,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV")]
    #[cfg(feature = "VK_NV_ray_tracing")]
    PhysicalDeviceRayTracingPropertiesNv = 1000165009,
    #[doc(alias = "VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV")]
    #[cfg(feature = "VK_NV_ray_tracing")]
    RayTracingShaderGroupCreateInfoNv = 1000165011,
    #[doc(alias = "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV")]
    #[cfg(feature = "VK_NV_ray_tracing")]
    AccelerationStructureInfoNv = 1000165012,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV")]
    #[cfg(feature = "VK_NV_representative_fragment_test")]
    PhysicalDeviceRepresentativeFragmentTestFeaturesNv = 1000166000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV")]
    #[cfg(feature = "VK_NV_representative_fragment_test")]
    PipelineRepresentativeFragmentTestStateCreateInfoNv = 1000166001,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT")]
    #[cfg(feature = "VK_EXT_filter_cubic")]
    PhysicalDeviceImageViewImageFormatInfoExt = 1000170000,
    #[doc(alias = "VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT")]
    #[cfg(feature = "VK_EXT_filter_cubic")]
    FilterCubicImageViewImageFormatPropertiesExt = 1000170001,
    #[doc(alias = "VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT")]
    #[cfg(feature = "VK_EXT_external_memory_host")]
    ImportMemoryHostPointerInfoExt = 1000178000,
    #[doc(alias = "VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT")]
    #[cfg(feature = "VK_EXT_external_memory_host")]
    MemoryHostPointerPropertiesExt = 1000178001,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT")]
    #[cfg(feature = "VK_EXT_external_memory_host")]
    PhysicalDeviceExternalMemoryHostPropertiesExt = 1000178002,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR")]
    #[cfg(feature = "VK_KHR_shader_clock")]
    PhysicalDeviceShaderClockFeaturesKhr = 1000181000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD")]
    #[cfg(feature = "VK_AMD_pipeline_compiler_control")]
    PipelineCompilerControlCreateInfoAmd = 1000183000,
    #[doc(alias = "VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_EXT")]
    #[cfg(feature = "VK_EXT_calibrated_timestamps")]
    CalibratedTimestampInfoExt = 1000184000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD")]
    #[cfg(feature = "VK_AMD_shader_core_properties")]
    PhysicalDeviceShaderCorePropertiesAmd = 1000185000,
    #[doc(alias = "VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_KHR")]
    #[doc(alias = "VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT")]
    #[cfg(feature = "VK_KHR_global_priority")]
    DeviceQueueGlobalPriorityCreateInfoKhr = 1000174000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_KHR")]
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_EXT")]
    #[cfg(feature = "VK_KHR_global_priority")]
    PhysicalDeviceGlobalPriorityQueryFeaturesKhr = 1000388000,
    #[doc(alias = "VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_KHR")]
    #[doc(alias = "VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_EXT")]
    #[cfg(feature = "VK_KHR_global_priority")]
    QueueFamilyGlobalPriorityPropertiesKhr = 1000388001,
    #[doc(alias = "VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD")]
    #[cfg(feature = "VK_AMD_memory_overallocation_behavior")]
    DeviceMemoryOverallocationCreateInfoAmd = 1000189000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT")]
    #[cfg(feature = "VK_EXT_vertex_attribute_divisor")]
    PhysicalDeviceVertexAttributeDivisorPropertiesExt = 1000190000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT")]
    #[cfg(feature = "VK_EXT_vertex_attribute_divisor")]
    PipelineVertexInputDivisorStateCreateInfoExt = 1000190001,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT")]
    #[cfg(feature = "VK_EXT_vertex_attribute_divisor")]
    PhysicalDeviceVertexAttributeDivisorFeaturesExt = 1000190002,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV")]
    #[cfg(feature = "VK_NV_compute_shader_derivatives")]
    PhysicalDeviceComputeShaderDerivativesFeaturesNv = 1000201000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV")]
    #[cfg(feature = "VK_NV_mesh_shader")]
    PhysicalDeviceMeshShaderFeaturesNv = 1000202000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV")]
    #[cfg(feature = "VK_NV_mesh_shader")]
    PhysicalDeviceMeshShaderPropertiesNv = 1000202001,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_NV")]
    #[cfg(feature = "VK_NV_fragment_shader_barycentric")]
    PhysicalDeviceFragmentShaderBarycentricFeaturesNv = 1000203000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV")]
    #[cfg(feature = "VK_NV_shader_image_footprint")]
    PhysicalDeviceShaderImageFootprintFeaturesNv = 1000204000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV")]
    #[cfg(feature = "VK_NV_scissor_exclusive")]
    PipelineViewportExclusiveScissorStateCreateInfoNv = 1000205000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV")]
    #[cfg(feature = "VK_NV_scissor_exclusive")]
    PhysicalDeviceExclusiveScissorFeaturesNv = 1000205002,
    #[doc(alias = "VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV")]
    #[cfg(feature = "VK_NV_device_diagnostic_checkpoints")]
    CheckpointDataNv = 1000206000,
    #[doc(alias = "VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV")]
    #[cfg(feature = "VK_NV_device_diagnostic_checkpoints")]
    QueueFamilyCheckpointPropertiesNv = 1000206001,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL")]
    #[cfg(feature = "VK_INTEL_shader_integer_functions2")]
    PhysicalDeviceShaderIntegerFunctions2FeaturesIntel = 1000209000,
    #[doc(alias = "VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL")]
    #[doc(alias = "VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO_INTEL")]
    #[cfg(feature = "VK_INTEL_performance_query")]
    QueryPoolPerformanceQueryCreateInfoIntel = 1000210000,
    #[doc(alias = "VK_STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL")]
    #[cfg(feature = "VK_INTEL_performance_query")]
    InitializePerformanceApiInfoIntel = 1000210001,
    #[doc(alias = "VK_STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL")]
    #[cfg(feature = "VK_INTEL_performance_query")]
    PerformanceMarkerInfoIntel = 1000210002,
    #[doc(alias = "VK_STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL")]
    #[cfg(feature = "VK_INTEL_performance_query")]
    PerformanceStreamMarkerInfoIntel = 1000210003,
    #[doc(alias = "VK_STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL")]
    #[cfg(feature = "VK_INTEL_performance_query")]
    PerformanceOverrideInfoIntel = 1000210004,
    #[doc(alias = "VK_STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL")]
    #[cfg(feature = "VK_INTEL_performance_query")]
    PerformanceConfigurationAcquireInfoIntel = 1000210005,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT")]
    #[cfg(feature = "VK_EXT_pci_bus_info")]
    PhysicalDevicePciBusInfoPropertiesExt = 1000212000,
    #[doc(alias = "VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD")]
    #[cfg(feature = "VK_AMD_display_native_hdr")]
    DisplayNativeHdrSurfaceCapabilitiesAmd = 1000213000,
    #[doc(alias = "VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD")]
    #[cfg(feature = "VK_AMD_display_native_hdr")]
    SwapchainDisplayNativeHdrCreateInfoAmd = 1000213001,
    #[doc(alias = "VK_STRUCTURE_TYPE_IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA")]
    #[cfg(feature = "VK_FUCHSIA_imagepipe_surface")]
    ImagepipeSurfaceCreateInfoFuchsia = 1000214000,
    #[doc(alias = "VK_STRUCTURE_TYPE_METAL_SURFACE_CREATE_INFO_EXT")]
    #[cfg(feature = "VK_EXT_metal_surface")]
    MetalSurfaceCreateInfoExt = 1000217000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT")]
    #[cfg(feature = "VK_EXT_fragment_density_map")]
    PhysicalDeviceFragmentDensityMapFeaturesExt = 1000218000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT")]
    #[cfg(feature = "VK_EXT_fragment_density_map")]
    PhysicalDeviceFragmentDensityMapPropertiesExt = 1000218001,
    #[doc(alias = "VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT")]
    #[cfg(feature = "VK_EXT_fragment_density_map")]
    RenderPassFragmentDensityMapCreateInfoExt = 1000218002,
    #[doc(alias = "VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR")]
    #[cfg(feature = "VK_KHR_fragment_shading_rate")]
    FragmentShadingRateAttachmentInfoKhr = 1000226000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR")]
    #[cfg(feature = "VK_KHR_fragment_shading_rate")]
    PipelineFragmentShadingRateStateCreateInfoKhr = 1000226001,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR")]
    #[cfg(feature = "VK_KHR_fragment_shading_rate")]
    PhysicalDeviceFragmentShadingRatePropertiesKhr = 1000226002,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR")]
    #[cfg(feature = "VK_KHR_fragment_shading_rate")]
    PhysicalDeviceFragmentShadingRateFeaturesKhr = 1000226003,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR")]
    #[cfg(feature = "VK_KHR_fragment_shading_rate")]
    PhysicalDeviceFragmentShadingRateKhr = 1000226004,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD")]
    #[cfg(feature = "VK_AMD_shader_core_properties2")]
    PhysicalDeviceShaderCoreProperties2Amd = 1000227000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD")]
    #[cfg(feature = "VK_AMD_device_coherent_memory")]
    PhysicalDeviceCoherentMemoryFeaturesAmd = 1000229000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT")]
    #[cfg(feature = "VK_EXT_shader_image_atomic_int64")]
    PhysicalDeviceShaderImageAtomicInt64FeaturesExt = 1000234000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT")]
    #[cfg(feature = "VK_EXT_memory_budget")]
    PhysicalDeviceMemoryBudgetPropertiesExt = 1000237000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT")]
    #[cfg(feature = "VK_EXT_memory_priority")]
    PhysicalDeviceMemoryPriorityFeaturesExt = 1000238000,
    #[doc(alias = "VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT")]
    #[cfg(feature = "VK_EXT_memory_priority")]
    MemoryPriorityAllocateInfoExt = 1000238001,
    #[doc(alias = "VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR")]
    #[cfg(feature = "VK_KHR_surface_protected_capabilities")]
    SurfaceProtectedCapabilitiesKhr = 1000239000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV")]
    #[cfg(feature = "VK_NV_dedicated_allocation_image_aliasing")]
    PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNv = 1000240000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT")]
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_ADDRESS_FEATURES_EXT")]
    #[cfg(feature = "VK_EXT_buffer_device_address")]
    PhysicalDeviceBufferDeviceAddressFeaturesExt = 1000244000,
    #[doc(alias = "VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT")]
    #[cfg(feature = "VK_EXT_buffer_device_address")]
    BufferDeviceAddressCreateInfoExt = 1000244002,
    #[doc(alias = "VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT")]
    #[cfg(feature = "VK_EXT_validation_features")]
    ValidationFeaturesExt = 1000247000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR")]
    #[cfg(feature = "VK_KHR_present_wait")]
    PhysicalDevicePresentWaitFeaturesKhr = 1000248000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV")]
    #[cfg(feature = "VK_NV_cooperative_matrix")]
    PhysicalDeviceCooperativeMatrixFeaturesNv = 1000249000,
    #[doc(alias = "VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV")]
    #[cfg(feature = "VK_NV_cooperative_matrix")]
    CooperativeMatrixPropertiesNv = 1000249001,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV")]
    #[cfg(feature = "VK_NV_cooperative_matrix")]
    PhysicalDeviceCooperativeMatrixPropertiesNv = 1000249002,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV")]
    #[cfg(feature = "VK_NV_coverage_reduction_mode")]
    PhysicalDeviceCoverageReductionModeFeaturesNv = 1000250000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV")]
    #[cfg(feature = "VK_NV_coverage_reduction_mode")]
    PipelineCoverageReductionStateCreateInfoNv = 1000250001,
    #[doc(alias = "VK_STRUCTURE_TYPE_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV")]
    #[cfg(feature = "VK_NV_coverage_reduction_mode")]
    FramebufferMixedSamplesCombinationNv = 1000250002,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT")]
    #[cfg(feature = "VK_EXT_fragment_shader_interlock")]
    PhysicalDeviceFragmentShaderInterlockFeaturesExt = 1000251000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT")]
    #[cfg(feature = "VK_EXT_ycbcr_image_arrays")]
    PhysicalDeviceYcbcrImageArraysFeaturesExt = 1000252000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT")]
    #[cfg(feature = "VK_EXT_provoking_vertex")]
    PhysicalDeviceProvokingVertexFeaturesExt = 1000254000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT")]
    #[cfg(feature = "VK_EXT_provoking_vertex")]
    PipelineRasterizationProvokingVertexStateCreateInfoExt = 1000254001,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT")]
    #[cfg(feature = "VK_EXT_provoking_vertex")]
    PhysicalDeviceProvokingVertexPropertiesExt = 1000254002,
    #[doc(alias = "VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT")]
    #[cfg(feature = "VK_EXT_full_screen_exclusive")]
    SurfaceFullScreenExclusiveInfoExt = 1000255000,
    #[doc(alias = "VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT")]
    #[cfg(feature = "VK_EXT_full_screen_exclusive")]
    SurfaceCapabilitiesFullScreenExclusiveExt = 1000255002,
    #[doc(alias = "VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT")]
    #[cfg(feature = "VK_EXT_full_screen_exclusive")]
    SurfaceFullScreenExclusiveWin32InfoExt = 1000255001,
    #[doc(alias = "VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT")]
    #[cfg(feature = "VK_EXT_headless_surface")]
    HeadlessSurfaceCreateInfoExt = 1000256000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT")]
    #[cfg(feature = "VK_EXT_line_rasterization")]
    PhysicalDeviceLineRasterizationFeaturesExt = 1000259000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT")]
    #[cfg(feature = "VK_EXT_line_rasterization")]
    PipelineRasterizationLineStateCreateInfoExt = 1000259001,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT")]
    #[cfg(feature = "VK_EXT_line_rasterization")]
    PhysicalDeviceLineRasterizationPropertiesExt = 1000259002,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT")]
    #[cfg(feature = "VK_EXT_shader_atomic_float")]
    PhysicalDeviceShaderAtomicFloatFeaturesExt = 1000260000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT")]
    #[cfg(feature = "VK_EXT_index_type_uint8")]
    PhysicalDeviceIndexTypeUint8FeaturesExt = 1000265000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT")]
    #[cfg(feature = "VK_EXT_extended_dynamic_state")]
    PhysicalDeviceExtendedDynamicStateFeaturesExt = 1000267000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR")]
    #[cfg(feature = "VK_KHR_pipeline_executable_properties")]
    PhysicalDevicePipelineExecutablePropertiesFeaturesKhr = 1000269000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR")]
    #[cfg(feature = "VK_KHR_pipeline_executable_properties")]
    PipelineInfoKhr = 1000269001,
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR")]
    #[cfg(feature = "VK_KHR_pipeline_executable_properties")]
    PipelineExecutablePropertiesKhr = 1000269002,
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR")]
    #[cfg(feature = "VK_KHR_pipeline_executable_properties")]
    PipelineExecutableInfoKhr = 1000269003,
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR")]
    #[cfg(feature = "VK_KHR_pipeline_executable_properties")]
    PipelineExecutableStatisticKhr = 1000269004,
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR")]
    #[cfg(feature = "VK_KHR_pipeline_executable_properties")]
    PipelineExecutableInternalRepresentationKhr = 1000269005,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT")]
    #[cfg(feature = "VK_EXT_shader_atomic_float2")]
    PhysicalDeviceShaderAtomicFloat2FeaturesExt = 1000273000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV")]
    #[cfg(feature = "VK_NV_device_generated_commands")]
    PhysicalDeviceDeviceGeneratedCommandsPropertiesNv = 1000277000,
    #[doc(alias = "VK_STRUCTURE_TYPE_GRAPHICS_SHADER_GROUP_CREATE_INFO_NV")]
    #[cfg(feature = "VK_NV_device_generated_commands")]
    GraphicsShaderGroupCreateInfoNv = 1000277001,
    #[doc(alias = "VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV")]
    #[cfg(feature = "VK_NV_device_generated_commands")]
    GraphicsPipelineShaderGroupsCreateInfoNv = 1000277002,
    #[doc(alias = "VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_NV")]
    #[cfg(feature = "VK_NV_device_generated_commands")]
    IndirectCommandsLayoutTokenNv = 1000277003,
    #[doc(alias = "VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NV")]
    #[cfg(feature = "VK_NV_device_generated_commands")]
    IndirectCommandsLayoutCreateInfoNv = 1000277004,
    #[doc(alias = "VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_NV")]
    #[cfg(feature = "VK_NV_device_generated_commands")]
    GeneratedCommandsInfoNv = 1000277005,
    #[doc(alias = "VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_NV")]
    #[cfg(feature = "VK_NV_device_generated_commands")]
    GeneratedCommandsMemoryRequirementsInfoNv = 1000277006,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV")]
    #[cfg(feature = "VK_NV_device_generated_commands")]
    PhysicalDeviceDeviceGeneratedCommandsFeaturesNv = 1000277007,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV")]
    #[cfg(feature = "VK_NV_inherited_viewport_scissor")]
    PhysicalDeviceInheritedViewportScissorFeaturesNv = 1000278000,
    #[doc(alias = "VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV")]
    #[cfg(feature = "VK_NV_inherited_viewport_scissor")]
    CommandBufferInheritanceViewportScissorInfoNv = 1000278001,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT")]
    #[cfg(feature = "VK_EXT_texel_buffer_alignment")]
    PhysicalDeviceTexelBufferAlignmentFeaturesExt = 1000281000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT")]
    #[cfg(feature = "VK_EXT_device_memory_report")]
    PhysicalDeviceDeviceMemoryReportFeaturesExt = 1000284000,
    #[doc(alias = "VK_STRUCTURE_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT")]
    #[cfg(feature = "VK_EXT_device_memory_report")]
    DeviceDeviceMemoryReportCreateInfoExt = 1000284001,
    #[doc(alias = "VK_STRUCTURE_TYPE_DEVICE_MEMORY_REPORT_CALLBACK_DATA_EXT")]
    #[cfg(feature = "VK_EXT_device_memory_report")]
    DeviceMemoryReportCallbackDataExt = 1000284002,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT")]
    #[cfg(feature = "VK_EXT_robustness2")]
    PhysicalDeviceRobustness2FeaturesExt = 1000286000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_EXT")]
    #[cfg(feature = "VK_EXT_robustness2")]
    PhysicalDeviceRobustness2PropertiesExt = 1000286001,
    #[doc(alias = "VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT")]
    #[cfg(feature = "VK_EXT_custom_border_color")]
    SamplerCustomBorderColorCreateInfoExt = 1000287000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT")]
    #[cfg(feature = "VK_EXT_custom_border_color")]
    PhysicalDeviceCustomBorderColorPropertiesExt = 1000287001,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT")]
    #[cfg(feature = "VK_EXT_custom_border_color")]
    PhysicalDeviceCustomBorderColorFeaturesExt = 1000287002,
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR")]
    #[cfg(feature = "VK_KHR_pipeline_library")]
    PipelineLibraryCreateInfoKhr = 1000290000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PRESENT_ID_KHR")]
    #[cfg(feature = "VK_KHR_present_id")]
    PresentIdKhr = 1000294000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR")]
    #[cfg(feature = "VK_KHR_present_id")]
    PhysicalDevicePresentIdFeaturesKhr = 1000294001,
    #[doc(alias = "VK_STRUCTURE_TYPE_VIDEO_ENCODE_INFO_KHR")]
    #[cfg(feature = "VK_KHR_video_encode_queue")]
    VideoEncodeInfoKhr = 1000299000,
    #[doc(alias = "VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_INFO_KHR")]
    #[cfg(feature = "VK_KHR_video_encode_queue")]
    VideoEncodeRateControlInfoKhr = 1000299001,
    #[doc(alias = "VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_LAYER_INFO_KHR")]
    #[cfg(feature = "VK_KHR_video_encode_queue")]
    VideoEncodeRateControlLayerInfoKhr = 1000299002,
    #[doc(alias = "VK_STRUCTURE_TYPE_VIDEO_ENCODE_CAPABILITIES_KHR")]
    #[cfg(feature = "VK_KHR_video_encode_queue")]
    VideoEncodeCapabilitiesKhr = 1000299003,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV")]
    #[cfg(feature = "VK_NV_device_diagnostics_config")]
    PhysicalDeviceDiagnosticsConfigFeaturesNv = 1000300000,
    #[doc(alias = "VK_STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV")]
    #[cfg(feature = "VK_NV_device_diagnostics_config")]
    DeviceDiagnosticsConfigCreateInfoNv = 1000300001,
    #[doc(alias = "VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV")]
    #[cfg(feature = "VK_KHR_synchronization2")]
    QueueFamilyCheckpointProperties2Nv = 1000314008,
    #[doc(alias = "VK_STRUCTURE_TYPE_CHECKPOINT_DATA_2_NV")]
    #[cfg(feature = "VK_KHR_synchronization2")]
    CheckpointData2Nv = 1000314009,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR")]
    #[cfg(feature = "VK_KHR_shader_subgroup_uniform_control_flow")]
    PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKhr = 1000323000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV")]
    #[cfg(feature = "VK_NV_fragment_shading_rate_enums")]
    PhysicalDeviceFragmentShadingRateEnumsPropertiesNv = 1000326000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV")]
    #[cfg(feature = "VK_NV_fragment_shading_rate_enums")]
    PhysicalDeviceFragmentShadingRateEnumsFeaturesNv = 1000326001,
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV")]
    #[cfg(feature = "VK_NV_fragment_shading_rate_enums")]
    PipelineFragmentShadingRateEnumStateCreateInfoNv = 1000326002,
    #[doc(alias = "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_MOTION_TRIANGLES_DATA_NV")]
    #[cfg(feature = "VK_NV_ray_tracing_motion_blur")]
    AccelerationStructureGeometryMotionTrianglesDataNv = 1000327000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV")]
    #[cfg(feature = "VK_NV_ray_tracing_motion_blur")]
    PhysicalDeviceRayTracingMotionBlurFeaturesNv = 1000327001,
    #[doc(alias = "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MOTION_INFO_NV")]
    #[cfg(feature = "VK_NV_ray_tracing_motion_blur")]
    AccelerationStructureMotionInfoNv = 1000327002,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT")]
    #[cfg(feature = "VK_EXT_ycbcr_2plane_444_formats")]
    PhysicalDeviceYcbcr2Plane444FormatsFeaturesExt = 1000330000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT")]
    #[cfg(feature = "VK_EXT_fragment_density_map2")]
    PhysicalDeviceFragmentDensityMap2FeaturesExt = 1000332000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT")]
    #[cfg(feature = "VK_EXT_fragment_density_map2")]
    PhysicalDeviceFragmentDensityMap2PropertiesExt = 1000332001,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR")]
    #[cfg(feature = "VK_KHR_workgroup_memory_explicit_layout")]
    PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKhr = 1000336000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT")]
    #[cfg(feature = "VK_EXT_4444_formats")]
    PhysicalDevice4444FormatsFeaturesExt = 1000340000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_ARM")]
    #[cfg(feature = "VK_ARM_rasterization_order_attachment_access")]
    PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesArm = 1000342000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT")]
    #[cfg(feature = "VK_EXT_rgba10x6_formats")]
    PhysicalDeviceRgba10x6FormatsFeaturesExt = 1000344000,
    #[doc(alias = "VK_STRUCTURE_TYPE_DIRECTFB_SURFACE_CREATE_INFO_EXT")]
    #[cfg(feature = "VK_EXT_directfb_surface")]
    DirectfbSurfaceCreateInfoExt = 1000346000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_VALVE")]
    #[cfg(feature = "VK_VALVE_mutable_descriptor_type")]
    PhysicalDeviceMutableDescriptorTypeFeaturesValve = 1000351000,
    #[doc(alias = "VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_VALVE")]
    #[cfg(feature = "VK_VALVE_mutable_descriptor_type")]
    MutableDescriptorTypeCreateInfoValve = 1000351002,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT")]
    #[cfg(feature = "VK_EXT_vertex_input_dynamic_state")]
    PhysicalDeviceVertexInputDynamicStateFeaturesExt = 1000352000,
    #[doc(alias = "VK_STRUCTURE_TYPE_VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT")]
    #[cfg(feature = "VK_EXT_vertex_input_dynamic_state")]
    VertexInputBindingDescription2Ext = 1000352001,
    #[doc(alias = "VK_STRUCTURE_TYPE_VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT")]
    #[cfg(feature = "VK_EXT_vertex_input_dynamic_state")]
    VertexInputAttributeDescription2Ext = 1000352002,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRM_PROPERTIES_EXT")]
    #[cfg(feature = "VK_EXT_physical_device_drm")]
    PhysicalDeviceDrmPropertiesExt = 1000353000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT")]
    #[cfg(feature = "VK_EXT_depth_clip_control")]
    PhysicalDeviceDepthClipControlFeaturesExt = 1000355000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_EXT")]
    #[cfg(feature = "VK_EXT_depth_clip_control")]
    PipelineViewportDepthClipControlCreateInfoExt = 1000355001,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT")]
    #[cfg(feature = "VK_EXT_primitive_topology_list_restart")]
    PhysicalDevicePrimitiveTopologyListRestartFeaturesExt = 1000356000,
    #[doc(alias = "VK_STRUCTURE_TYPE_IMPORT_MEMORY_ZIRCON_HANDLE_INFO_FUCHSIA")]
    #[cfg(feature = "VK_FUCHSIA_external_memory")]
    ImportMemoryZirconHandleInfoFuchsia = 1000364000,
    #[doc(alias = "VK_STRUCTURE_TYPE_MEMORY_ZIRCON_HANDLE_PROPERTIES_FUCHSIA")]
    #[cfg(feature = "VK_FUCHSIA_external_memory")]
    MemoryZirconHandlePropertiesFuchsia = 1000364001,
    #[doc(alias = "VK_STRUCTURE_TYPE_MEMORY_GET_ZIRCON_HANDLE_INFO_FUCHSIA")]
    #[cfg(feature = "VK_FUCHSIA_external_memory")]
    MemoryGetZirconHandleInfoFuchsia = 1000364002,
    #[doc(alias = "VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_ZIRCON_HANDLE_INFO_FUCHSIA")]
    #[cfg(feature = "VK_FUCHSIA_external_semaphore")]
    ImportSemaphoreZirconHandleInfoFuchsia = 1000365000,
    #[doc(alias = "VK_STRUCTURE_TYPE_SEMAPHORE_GET_ZIRCON_HANDLE_INFO_FUCHSIA")]
    #[cfg(feature = "VK_FUCHSIA_external_semaphore")]
    SemaphoreGetZirconHandleInfoFuchsia = 1000365001,
    #[doc(alias = "VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CREATE_INFO_FUCHSIA")]
    #[cfg(feature = "VK_FUCHSIA_buffer_collection")]
    BufferCollectionCreateInfoFuchsia = 1000366000,
    #[doc(alias = "VK_STRUCTURE_TYPE_IMPORT_MEMORY_BUFFER_COLLECTION_FUCHSIA")]
    #[cfg(feature = "VK_FUCHSIA_buffer_collection")]
    ImportMemoryBufferCollectionFuchsia = 1000366001,
    #[doc(alias = "VK_STRUCTURE_TYPE_BUFFER_COLLECTION_IMAGE_CREATE_INFO_FUCHSIA")]
    #[cfg(feature = "VK_FUCHSIA_buffer_collection")]
    BufferCollectionImageCreateInfoFuchsia = 1000366002,
    #[doc(alias = "VK_STRUCTURE_TYPE_BUFFER_COLLECTION_PROPERTIES_FUCHSIA")]
    #[cfg(feature = "VK_FUCHSIA_buffer_collection")]
    BufferCollectionPropertiesFuchsia = 1000366003,
    #[doc(alias = "VK_STRUCTURE_TYPE_BUFFER_CONSTRAINTS_INFO_FUCHSIA")]
    #[cfg(feature = "VK_FUCHSIA_buffer_collection")]
    BufferConstraintsInfoFuchsia = 1000366004,
    #[doc(alias = "VK_STRUCTURE_TYPE_BUFFER_COLLECTION_BUFFER_CREATE_INFO_FUCHSIA")]
    #[cfg(feature = "VK_FUCHSIA_buffer_collection")]
    BufferCollectionBufferCreateInfoFuchsia = 1000366005,
    #[doc(alias = "VK_STRUCTURE_TYPE_IMAGE_CONSTRAINTS_INFO_FUCHSIA")]
    #[cfg(feature = "VK_FUCHSIA_buffer_collection")]
    ImageConstraintsInfoFuchsia = 1000366006,
    #[doc(alias = "VK_STRUCTURE_TYPE_IMAGE_FORMAT_CONSTRAINTS_INFO_FUCHSIA")]
    #[cfg(feature = "VK_FUCHSIA_buffer_collection")]
    ImageFormatConstraintsInfoFuchsia = 1000366007,
    #[doc(alias = "VK_STRUCTURE_TYPE_SYSMEM_COLOR_SPACE_FUCHSIA")]
    #[cfg(feature = "VK_FUCHSIA_buffer_collection")]
    SysmemColorSpaceFuchsia = 1000366008,
    #[doc(alias = "VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CONSTRAINTS_INFO_FUCHSIA")]
    #[cfg(feature = "VK_FUCHSIA_buffer_collection")]
    BufferCollectionConstraintsInfoFuchsia = 1000366009,
    #[doc(alias = "VK_STRUCTURE_TYPE_SUBPASS_SHADING_PIPELINE_CREATE_INFO_HUAWEI")]
    #[cfg(feature = "VK_HUAWEI_subpass_shading")]
    SubpassShadingPipelineCreateInfoHuawei = 1000369000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI")]
    #[cfg(feature = "VK_HUAWEI_subpass_shading")]
    PhysicalDeviceSubpassShadingFeaturesHuawei = 1000369001,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI")]
    #[cfg(feature = "VK_HUAWEI_subpass_shading")]
    PhysicalDeviceSubpassShadingPropertiesHuawei = 1000369002,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI")]
    #[cfg(feature = "VK_HUAWEI_invocation_mask")]
    PhysicalDeviceInvocationMaskFeaturesHuawei = 1000370000,
    #[doc(alias = "VK_STRUCTURE_TYPE_MEMORY_GET_REMOTE_ADDRESS_INFO_NV")]
    #[cfg(feature = "VK_NV_external_memory_rdma")]
    MemoryGetRemoteAddressInfoNv = 1000371000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_RDMA_FEATURES_NV")]
    #[cfg(feature = "VK_NV_external_memory_rdma")]
    PhysicalDeviceExternalMemoryRdmaFeaturesNv = 1000371001,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT")]
    #[cfg(feature = "VK_EXT_extended_dynamic_state2")]
    PhysicalDeviceExtendedDynamicState2FeaturesExt = 1000377000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT")]
    #[cfg(feature = "VK_EXT_color_write_enable")]
    PhysicalDeviceColorWriteEnableFeaturesExt = 1000381000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PIPELINE_COLOR_WRITE_CREATE_INFO_EXT")]
    #[cfg(feature = "VK_EXT_color_write_enable")]
    PipelineColorWriteCreateInfoExt = 1000381001,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT")]
    #[cfg(feature = "VK_EXT_image_view_min_lod")]
    PhysicalDeviceImageViewMinLodFeaturesExt = 1000391000,
    #[doc(alias = "VK_STRUCTURE_TYPE_IMAGE_VIEW_MIN_LOD_CREATE_INFO_EXT")]
    #[cfg(feature = "VK_EXT_image_view_min_lod")]
    ImageViewMinLodCreateInfoExt = 1000391001,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT")]
    #[cfg(feature = "VK_EXT_multi_draw")]
    PhysicalDeviceMultiDrawFeaturesExt = 1000392000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT")]
    #[cfg(feature = "VK_EXT_multi_draw")]
    PhysicalDeviceMultiDrawPropertiesExt = 1000392001,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT")]
    #[cfg(feature = "VK_EXT_border_color_swizzle")]
    PhysicalDeviceBorderColorSwizzleFeaturesExt = 1000411000,
    #[doc(alias = "VK_STRUCTURE_TYPE_SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT")]
    #[cfg(feature = "VK_EXT_border_color_swizzle")]
    SamplerBorderColorComponentMappingCreateInfoExt = 1000411001,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT")]
    #[cfg(feature = "VK_EXT_pageable_device_local_memory")]
    PhysicalDevicePageableDeviceLocalMemoryFeaturesExt = 1000412000,
    #[doc(alias = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV")]
    #[cfg(feature = "VK_NV_linear_color_attachment")]
    PhysicalDeviceLinearColorAttachmentFeaturesNv = 1000430000,
}
impl Default for StructureType {
    #[inline]
    fn default() -> Self {
        Self::empty()
    }
}
impl StructureType {
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        unsafe { Self::from_bits_unchecked(0) }
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> i32 {
        *self as i32
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: i32) -> Option<Self> {
        match bits {
            x if x == Self::ApplicationInfo.bits() => Some(Self::ApplicationInfo),
            x if x == Self::InstanceCreateInfo.bits() => Some(Self::InstanceCreateInfo),
            x if x == Self::DeviceQueueCreateInfo.bits() => Some(Self::DeviceQueueCreateInfo),
            x if x == Self::DeviceCreateInfo.bits() => Some(Self::DeviceCreateInfo),
            x if x == Self::SubmitInfo.bits() => Some(Self::SubmitInfo),
            x if x == Self::MemoryAllocateInfo.bits() => Some(Self::MemoryAllocateInfo),
            x if x == Self::MappedMemoryRange.bits() => Some(Self::MappedMemoryRange),
            x if x == Self::BindSparseInfo.bits() => Some(Self::BindSparseInfo),
            x if x == Self::FenceCreateInfo.bits() => Some(Self::FenceCreateInfo),
            x if x == Self::SemaphoreCreateInfo.bits() => Some(Self::SemaphoreCreateInfo),
            x if x == Self::EventCreateInfo.bits() => Some(Self::EventCreateInfo),
            x if x == Self::QueryPoolCreateInfo.bits() => Some(Self::QueryPoolCreateInfo),
            x if x == Self::BufferCreateInfo.bits() => Some(Self::BufferCreateInfo),
            x if x == Self::BufferViewCreateInfo.bits() => Some(Self::BufferViewCreateInfo),
            x if x == Self::ImageCreateInfo.bits() => Some(Self::ImageCreateInfo),
            x if x == Self::ImageViewCreateInfo.bits() => Some(Self::ImageViewCreateInfo),
            x if x == Self::ShaderModuleCreateInfo.bits() => Some(Self::ShaderModuleCreateInfo),
            x if x == Self::PipelineCacheCreateInfo.bits() => Some(Self::PipelineCacheCreateInfo),
            x if x == Self::PipelineShaderStageCreateInfo.bits() => Some(Self::PipelineShaderStageCreateInfo),
            x if x == Self::PipelineVertexInputStateCreateInfo.bits() => Some(Self::PipelineVertexInputStateCreateInfo),
            x if x == Self::PipelineInputAssemblyStateCreateInfo.bits() => {
                Some(Self::PipelineInputAssemblyStateCreateInfo)
            },
            x if x == Self::PipelineTessellationStateCreateInfo.bits() => {
                Some(Self::PipelineTessellationStateCreateInfo)
            },
            x if x == Self::PipelineViewportStateCreateInfo.bits() => Some(Self::PipelineViewportStateCreateInfo),
            x if x == Self::PipelineRasterizationStateCreateInfo.bits() => {
                Some(Self::PipelineRasterizationStateCreateInfo)
            },
            x if x == Self::PipelineMultisampleStateCreateInfo.bits() => Some(Self::PipelineMultisampleStateCreateInfo),
            x if x == Self::PipelineDepthStencilStateCreateInfo.bits() => {
                Some(Self::PipelineDepthStencilStateCreateInfo)
            },
            x if x == Self::PipelineColorBlendStateCreateInfo.bits() => Some(Self::PipelineColorBlendStateCreateInfo),
            x if x == Self::PipelineDynamicStateCreateInfo.bits() => Some(Self::PipelineDynamicStateCreateInfo),
            x if x == Self::GraphicsPipelineCreateInfo.bits() => Some(Self::GraphicsPipelineCreateInfo),
            x if x == Self::ComputePipelineCreateInfo.bits() => Some(Self::ComputePipelineCreateInfo),
            x if x == Self::PipelineLayoutCreateInfo.bits() => Some(Self::PipelineLayoutCreateInfo),
            x if x == Self::SamplerCreateInfo.bits() => Some(Self::SamplerCreateInfo),
            x if x == Self::DescriptorSetLayoutCreateInfo.bits() => Some(Self::DescriptorSetLayoutCreateInfo),
            x if x == Self::DescriptorPoolCreateInfo.bits() => Some(Self::DescriptorPoolCreateInfo),
            x if x == Self::DescriptorSetAllocateInfo.bits() => Some(Self::DescriptorSetAllocateInfo),
            x if x == Self::WriteDescriptorSet.bits() => Some(Self::WriteDescriptorSet),
            x if x == Self::CopyDescriptorSet.bits() => Some(Self::CopyDescriptorSet),
            x if x == Self::FramebufferCreateInfo.bits() => Some(Self::FramebufferCreateInfo),
            x if x == Self::RenderPassCreateInfo.bits() => Some(Self::RenderPassCreateInfo),
            x if x == Self::CommandPoolCreateInfo.bits() => Some(Self::CommandPoolCreateInfo),
            x if x == Self::CommandBufferAllocateInfo.bits() => Some(Self::CommandBufferAllocateInfo),
            x if x == Self::CommandBufferInheritanceInfo.bits() => Some(Self::CommandBufferInheritanceInfo),
            x if x == Self::CommandBufferBeginInfo.bits() => Some(Self::CommandBufferBeginInfo),
            x if x == Self::RenderPassBeginInfo.bits() => Some(Self::RenderPassBeginInfo),
            x if x == Self::BufferMemoryBarrier.bits() => Some(Self::BufferMemoryBarrier),
            x if x == Self::ImageMemoryBarrier.bits() => Some(Self::ImageMemoryBarrier),
            x if x == Self::MemoryBarrier.bits() => Some(Self::MemoryBarrier),
            x if x == Self::LoaderInstanceCreateInfo.bits() => Some(Self::LoaderInstanceCreateInfo),
            x if x == Self::LoaderDeviceCreateInfo.bits() => Some(Self::LoaderDeviceCreateInfo),
            x if x == Self::PhysicalDeviceSubgroupProperties.bits() => Some(Self::PhysicalDeviceSubgroupProperties),
            x if x == Self::BindBufferMemoryInfo.bits() => Some(Self::BindBufferMemoryInfo),
            x if x == Self::BindImageMemoryInfo.bits() => Some(Self::BindImageMemoryInfo),
            x if x == Self::PhysicalDevice16bitStorageFeatures.bits() => Some(Self::PhysicalDevice16bitStorageFeatures),
            x if x == Self::MemoryDedicatedRequirements.bits() => Some(Self::MemoryDedicatedRequirements),
            x if x == Self::MemoryDedicatedAllocateInfo.bits() => Some(Self::MemoryDedicatedAllocateInfo),
            x if x == Self::MemoryAllocateFlagsInfo.bits() => Some(Self::MemoryAllocateFlagsInfo),
            x if x == Self::DeviceGroupRenderPassBeginInfo.bits() => Some(Self::DeviceGroupRenderPassBeginInfo),
            x if x == Self::DeviceGroupCommandBufferBeginInfo.bits() => Some(Self::DeviceGroupCommandBufferBeginInfo),
            x if x == Self::DeviceGroupSubmitInfo.bits() => Some(Self::DeviceGroupSubmitInfo),
            x if x == Self::DeviceGroupBindSparseInfo.bits() => Some(Self::DeviceGroupBindSparseInfo),
            x if x == Self::BindBufferMemoryDeviceGroupInfo.bits() => Some(Self::BindBufferMemoryDeviceGroupInfo),
            x if x == Self::BindImageMemoryDeviceGroupInfo.bits() => Some(Self::BindImageMemoryDeviceGroupInfo),
            x if x == Self::PhysicalDeviceGroupProperties.bits() => Some(Self::PhysicalDeviceGroupProperties),
            x if x == Self::DeviceGroupDeviceCreateInfo.bits() => Some(Self::DeviceGroupDeviceCreateInfo),
            x if x == Self::BufferMemoryRequirementsInfo2.bits() => Some(Self::BufferMemoryRequirementsInfo2),
            x if x == Self::ImageMemoryRequirementsInfo2.bits() => Some(Self::ImageMemoryRequirementsInfo2),
            x if x == Self::ImageSparseMemoryRequirementsInfo2.bits() => Some(Self::ImageSparseMemoryRequirementsInfo2),
            x if x == Self::MemoryRequirements2.bits() => Some(Self::MemoryRequirements2),
            x if x == Self::SparseImageMemoryRequirements2.bits() => Some(Self::SparseImageMemoryRequirements2),
            x if x == Self::PhysicalDeviceFeatures2.bits() => Some(Self::PhysicalDeviceFeatures2),
            x if x == Self::PhysicalDeviceProperties2.bits() => Some(Self::PhysicalDeviceProperties2),
            x if x == Self::FormatProperties2.bits() => Some(Self::FormatProperties2),
            x if x == Self::ImageFormatProperties2.bits() => Some(Self::ImageFormatProperties2),
            x if x == Self::PhysicalDeviceImageFormatInfo2.bits() => Some(Self::PhysicalDeviceImageFormatInfo2),
            x if x == Self::QueueFamilyProperties2.bits() => Some(Self::QueueFamilyProperties2),
            x if x == Self::PhysicalDeviceMemoryProperties2.bits() => Some(Self::PhysicalDeviceMemoryProperties2),
            x if x == Self::SparseImageFormatProperties2.bits() => Some(Self::SparseImageFormatProperties2),
            x if x == Self::PhysicalDeviceSparseImageFormatInfo2.bits() => {
                Some(Self::PhysicalDeviceSparseImageFormatInfo2)
            },
            x if x == Self::PhysicalDevicePointClippingProperties.bits() => {
                Some(Self::PhysicalDevicePointClippingProperties)
            },
            x if x == Self::RenderPassInputAttachmentAspectCreateInfo.bits() => {
                Some(Self::RenderPassInputAttachmentAspectCreateInfo)
            },
            x if x == Self::ImageViewUsageCreateInfo.bits() => Some(Self::ImageViewUsageCreateInfo),
            x if x == Self::PipelineTessellationDomainOriginStateCreateInfo.bits() => {
                Some(Self::PipelineTessellationDomainOriginStateCreateInfo)
            },
            x if x == Self::RenderPassMultiviewCreateInfo.bits() => Some(Self::RenderPassMultiviewCreateInfo),
            x if x == Self::PhysicalDeviceMultiviewFeatures.bits() => Some(Self::PhysicalDeviceMultiviewFeatures),
            x if x == Self::PhysicalDeviceMultiviewProperties.bits() => Some(Self::PhysicalDeviceMultiviewProperties),
            x if x == Self::PhysicalDeviceVariablePointersFeatures.bits() => {
                Some(Self::PhysicalDeviceVariablePointersFeatures)
            },
            x if x == Self::ProtectedSubmitInfo.bits() => Some(Self::ProtectedSubmitInfo),
            x if x == Self::PhysicalDeviceProtectedMemoryFeatures.bits() => {
                Some(Self::PhysicalDeviceProtectedMemoryFeatures)
            },
            x if x == Self::PhysicalDeviceProtectedMemoryProperties.bits() => {
                Some(Self::PhysicalDeviceProtectedMemoryProperties)
            },
            x if x == Self::DeviceQueueInfo2.bits() => Some(Self::DeviceQueueInfo2),
            x if x == Self::SamplerYcbcrConversionCreateInfo.bits() => Some(Self::SamplerYcbcrConversionCreateInfo),
            x if x == Self::SamplerYcbcrConversionInfo.bits() => Some(Self::SamplerYcbcrConversionInfo),
            x if x == Self::BindImagePlaneMemoryInfo.bits() => Some(Self::BindImagePlaneMemoryInfo),
            x if x == Self::ImagePlaneMemoryRequirementsInfo.bits() => Some(Self::ImagePlaneMemoryRequirementsInfo),
            x if x == Self::PhysicalDeviceSamplerYcbcrConversionFeatures.bits() => {
                Some(Self::PhysicalDeviceSamplerYcbcrConversionFeatures)
            },
            x if x == Self::SamplerYcbcrConversionImageFormatProperties.bits() => {
                Some(Self::SamplerYcbcrConversionImageFormatProperties)
            },
            x if x == Self::DescriptorUpdateTemplateCreateInfo.bits() => Some(Self::DescriptorUpdateTemplateCreateInfo),
            x if x == Self::PhysicalDeviceExternalImageFormatInfo.bits() => {
                Some(Self::PhysicalDeviceExternalImageFormatInfo)
            },
            x if x == Self::ExternalImageFormatProperties.bits() => Some(Self::ExternalImageFormatProperties),
            x if x == Self::PhysicalDeviceExternalBufferInfo.bits() => Some(Self::PhysicalDeviceExternalBufferInfo),
            x if x == Self::ExternalBufferProperties.bits() => Some(Self::ExternalBufferProperties),
            x if x == Self::PhysicalDeviceIdProperties.bits() => Some(Self::PhysicalDeviceIdProperties),
            x if x == Self::ExternalMemoryBufferCreateInfo.bits() => Some(Self::ExternalMemoryBufferCreateInfo),
            x if x == Self::ExternalMemoryImageCreateInfo.bits() => Some(Self::ExternalMemoryImageCreateInfo),
            x if x == Self::ExportMemoryAllocateInfo.bits() => Some(Self::ExportMemoryAllocateInfo),
            x if x == Self::PhysicalDeviceExternalFenceInfo.bits() => Some(Self::PhysicalDeviceExternalFenceInfo),
            x if x == Self::ExternalFenceProperties.bits() => Some(Self::ExternalFenceProperties),
            x if x == Self::ExportFenceCreateInfo.bits() => Some(Self::ExportFenceCreateInfo),
            x if x == Self::ExportSemaphoreCreateInfo.bits() => Some(Self::ExportSemaphoreCreateInfo),
            x if x == Self::PhysicalDeviceExternalSemaphoreInfo.bits() => {
                Some(Self::PhysicalDeviceExternalSemaphoreInfo)
            },
            x if x == Self::ExternalSemaphoreProperties.bits() => Some(Self::ExternalSemaphoreProperties),
            x if x == Self::PhysicalDeviceMaintenance3Properties.bits() => {
                Some(Self::PhysicalDeviceMaintenance3Properties)
            },
            x if x == Self::DescriptorSetLayoutSupport.bits() => Some(Self::DescriptorSetLayoutSupport),
            x if x == Self::PhysicalDeviceShaderDrawParametersFeatures.bits() => {
                Some(Self::PhysicalDeviceShaderDrawParametersFeatures)
            },
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::PhysicalDeviceVulkan11Features.bits() => Some(Self::PhysicalDeviceVulkan11Features),
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::PhysicalDeviceVulkan11Properties.bits() => Some(Self::PhysicalDeviceVulkan11Properties),
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::PhysicalDeviceVulkan12Features.bits() => Some(Self::PhysicalDeviceVulkan12Features),
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::PhysicalDeviceVulkan12Properties.bits() => Some(Self::PhysicalDeviceVulkan12Properties),
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::ImageFormatListCreateInfo.bits() => Some(Self::ImageFormatListCreateInfo),
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::AttachmentDescription2.bits() => Some(Self::AttachmentDescription2),
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::AttachmentReference2.bits() => Some(Self::AttachmentReference2),
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::SubpassDescription2.bits() => Some(Self::SubpassDescription2),
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::SubpassDependency2.bits() => Some(Self::SubpassDependency2),
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::RenderPassCreateInfo2.bits() => Some(Self::RenderPassCreateInfo2),
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::SubpassBeginInfo.bits() => Some(Self::SubpassBeginInfo),
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::SubpassEndInfo.bits() => Some(Self::SubpassEndInfo),
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::PhysicalDevice8bitStorageFeatures.bits() => Some(Self::PhysicalDevice8bitStorageFeatures),
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::PhysicalDeviceDriverProperties.bits() => Some(Self::PhysicalDeviceDriverProperties),
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::PhysicalDeviceShaderAtomicInt64Features.bits() => {
                Some(Self::PhysicalDeviceShaderAtomicInt64Features)
            },
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::PhysicalDeviceShaderFloat16Int8Features.bits() => {
                Some(Self::PhysicalDeviceShaderFloat16Int8Features)
            },
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::PhysicalDeviceFloatControlsProperties.bits() => {
                Some(Self::PhysicalDeviceFloatControlsProperties)
            },
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::DescriptorSetLayoutBindingFlagsCreateInfo.bits() => {
                Some(Self::DescriptorSetLayoutBindingFlagsCreateInfo)
            },
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::PhysicalDeviceDescriptorIndexingFeatures.bits() => {
                Some(Self::PhysicalDeviceDescriptorIndexingFeatures)
            },
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::PhysicalDeviceDescriptorIndexingProperties.bits() => {
                Some(Self::PhysicalDeviceDescriptorIndexingProperties)
            },
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::DescriptorSetVariableDescriptorCountAllocateInfo.bits() => {
                Some(Self::DescriptorSetVariableDescriptorCountAllocateInfo)
            },
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::DescriptorSetVariableDescriptorCountLayoutSupport.bits() => {
                Some(Self::DescriptorSetVariableDescriptorCountLayoutSupport)
            },
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::PhysicalDeviceDepthStencilResolveProperties.bits() => {
                Some(Self::PhysicalDeviceDepthStencilResolveProperties)
            },
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::SubpassDescriptionDepthStencilResolve.bits() => {
                Some(Self::SubpassDescriptionDepthStencilResolve)
            },
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::PhysicalDeviceScalarBlockLayoutFeatures.bits() => {
                Some(Self::PhysicalDeviceScalarBlockLayoutFeatures)
            },
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::ImageStencilUsageCreateInfo.bits() => Some(Self::ImageStencilUsageCreateInfo),
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::PhysicalDeviceSamplerFilterMinmaxProperties.bits() => {
                Some(Self::PhysicalDeviceSamplerFilterMinmaxProperties)
            },
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::SamplerReductionModeCreateInfo.bits() => Some(Self::SamplerReductionModeCreateInfo),
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::PhysicalDeviceVulkanMemoryModelFeatures.bits() => {
                Some(Self::PhysicalDeviceVulkanMemoryModelFeatures)
            },
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::PhysicalDeviceImagelessFramebufferFeatures.bits() => {
                Some(Self::PhysicalDeviceImagelessFramebufferFeatures)
            },
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::FramebufferAttachmentsCreateInfo.bits() => Some(Self::FramebufferAttachmentsCreateInfo),
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::FramebufferAttachmentImageInfo.bits() => Some(Self::FramebufferAttachmentImageInfo),
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::RenderPassAttachmentBeginInfo.bits() => Some(Self::RenderPassAttachmentBeginInfo),
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::PhysicalDeviceUniformBufferStandardLayoutFeatures.bits() => {
                Some(Self::PhysicalDeviceUniformBufferStandardLayoutFeatures)
            },
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::PhysicalDeviceShaderSubgroupExtendedTypesFeatures.bits() => {
                Some(Self::PhysicalDeviceShaderSubgroupExtendedTypesFeatures)
            },
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::PhysicalDeviceSeparateDepthStencilLayoutsFeatures.bits() => {
                Some(Self::PhysicalDeviceSeparateDepthStencilLayoutsFeatures)
            },
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::AttachmentReferenceStencilLayout.bits() => Some(Self::AttachmentReferenceStencilLayout),
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::AttachmentDescriptionStencilLayout.bits() => Some(Self::AttachmentDescriptionStencilLayout),
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::PhysicalDeviceHostQueryResetFeatures.bits() => {
                Some(Self::PhysicalDeviceHostQueryResetFeatures)
            },
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::PhysicalDeviceTimelineSemaphoreFeatures.bits() => {
                Some(Self::PhysicalDeviceTimelineSemaphoreFeatures)
            },
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::PhysicalDeviceTimelineSemaphoreProperties.bits() => {
                Some(Self::PhysicalDeviceTimelineSemaphoreProperties)
            },
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::SemaphoreTypeCreateInfo.bits() => Some(Self::SemaphoreTypeCreateInfo),
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::TimelineSemaphoreSubmitInfo.bits() => Some(Self::TimelineSemaphoreSubmitInfo),
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::SemaphoreWaitInfo.bits() => Some(Self::SemaphoreWaitInfo),
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::SemaphoreSignalInfo.bits() => Some(Self::SemaphoreSignalInfo),
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::PhysicalDeviceBufferDeviceAddressFeatures.bits() => {
                Some(Self::PhysicalDeviceBufferDeviceAddressFeatures)
            },
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::BufferDeviceAddressInfo.bits() => Some(Self::BufferDeviceAddressInfo),
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::BufferOpaqueCaptureAddressCreateInfo.bits() => {
                Some(Self::BufferOpaqueCaptureAddressCreateInfo)
            },
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::MemoryOpaqueCaptureAddressAllocateInfo.bits() => {
                Some(Self::MemoryOpaqueCaptureAddressAllocateInfo)
            },
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::DeviceMemoryOpaqueCaptureAddressInfo.bits() => {
                Some(Self::DeviceMemoryOpaqueCaptureAddressInfo)
            },
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::PhysicalDeviceVulkan13Features.bits() => Some(Self::PhysicalDeviceVulkan13Features),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::PhysicalDeviceVulkan13Properties.bits() => Some(Self::PhysicalDeviceVulkan13Properties),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::PipelineCreationFeedbackCreateInfo.bits() => Some(Self::PipelineCreationFeedbackCreateInfo),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::PhysicalDeviceShaderTerminateInvocationFeatures.bits() => {
                Some(Self::PhysicalDeviceShaderTerminateInvocationFeatures)
            },
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::PhysicalDeviceToolProperties.bits() => Some(Self::PhysicalDeviceToolProperties),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::PhysicalDeviceShaderDemoteToHelperInvocationFeatures.bits() => {
                Some(Self::PhysicalDeviceShaderDemoteToHelperInvocationFeatures)
            },
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::PhysicalDevicePrivateDataFeatures.bits() => Some(Self::PhysicalDevicePrivateDataFeatures),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::DevicePrivateDataCreateInfo.bits() => Some(Self::DevicePrivateDataCreateInfo),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::PrivateDataSlotCreateInfo.bits() => Some(Self::PrivateDataSlotCreateInfo),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::PhysicalDevicePipelineCreationCacheControlFeatures.bits() => {
                Some(Self::PhysicalDevicePipelineCreationCacheControlFeatures)
            },
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::MemoryBarrier2.bits() => Some(Self::MemoryBarrier2),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::BufferMemoryBarrier2.bits() => Some(Self::BufferMemoryBarrier2),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::ImageMemoryBarrier2.bits() => Some(Self::ImageMemoryBarrier2),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::DependencyInfo.bits() => Some(Self::DependencyInfo),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::SubmitInfo2.bits() => Some(Self::SubmitInfo2),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::SemaphoreSubmitInfo.bits() => Some(Self::SemaphoreSubmitInfo),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::CommandBufferSubmitInfo.bits() => Some(Self::CommandBufferSubmitInfo),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::PhysicalDeviceSynchronization2Features.bits() => {
                Some(Self::PhysicalDeviceSynchronization2Features)
            },
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures.bits() => {
                Some(Self::PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures)
            },
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::PhysicalDeviceImageRobustnessFeatures.bits() => {
                Some(Self::PhysicalDeviceImageRobustnessFeatures)
            },
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::CopyBufferInfo2.bits() => Some(Self::CopyBufferInfo2),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::CopyImageInfo2.bits() => Some(Self::CopyImageInfo2),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::CopyBufferToImageInfo2.bits() => Some(Self::CopyBufferToImageInfo2),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::CopyImageToBufferInfo2.bits() => Some(Self::CopyImageToBufferInfo2),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::BlitImageInfo2.bits() => Some(Self::BlitImageInfo2),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::ResolveImageInfo2.bits() => Some(Self::ResolveImageInfo2),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::BufferCopy2.bits() => Some(Self::BufferCopy2),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::ImageCopy2.bits() => Some(Self::ImageCopy2),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::ImageBlit2.bits() => Some(Self::ImageBlit2),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::BufferImageCopy2.bits() => Some(Self::BufferImageCopy2),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::ImageResolve2.bits() => Some(Self::ImageResolve2),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::PhysicalDeviceSubgroupSizeControlProperties.bits() => {
                Some(Self::PhysicalDeviceSubgroupSizeControlProperties)
            },
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::PipelineShaderStageRequiredSubgroupSizeCreateInfo.bits() => {
                Some(Self::PipelineShaderStageRequiredSubgroupSizeCreateInfo)
            },
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::PhysicalDeviceSubgroupSizeControlFeatures.bits() => {
                Some(Self::PhysicalDeviceSubgroupSizeControlFeatures)
            },
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::PhysicalDeviceInlineUniformBlockFeatures.bits() => {
                Some(Self::PhysicalDeviceInlineUniformBlockFeatures)
            },
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::PhysicalDeviceInlineUniformBlockProperties.bits() => {
                Some(Self::PhysicalDeviceInlineUniformBlockProperties)
            },
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::WriteDescriptorSetInlineUniformBlock.bits() => {
                Some(Self::WriteDescriptorSetInlineUniformBlock)
            },
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::DescriptorPoolInlineUniformBlockCreateInfo.bits() => {
                Some(Self::DescriptorPoolInlineUniformBlockCreateInfo)
            },
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::PhysicalDeviceTextureCompressionAstcHdrFeatures.bits() => {
                Some(Self::PhysicalDeviceTextureCompressionAstcHdrFeatures)
            },
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::RenderingInfo.bits() => Some(Self::RenderingInfo),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::RenderingAttachmentInfo.bits() => Some(Self::RenderingAttachmentInfo),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::PipelineRenderingCreateInfo.bits() => Some(Self::PipelineRenderingCreateInfo),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::PhysicalDeviceDynamicRenderingFeatures.bits() => {
                Some(Self::PhysicalDeviceDynamicRenderingFeatures)
            },
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::CommandBufferInheritanceRenderingInfo.bits() => {
                Some(Self::CommandBufferInheritanceRenderingInfo)
            },
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::PhysicalDeviceShaderIntegerDotProductFeatures.bits() => {
                Some(Self::PhysicalDeviceShaderIntegerDotProductFeatures)
            },
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::PhysicalDeviceShaderIntegerDotProductProperties.bits() => {
                Some(Self::PhysicalDeviceShaderIntegerDotProductProperties)
            },
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::PhysicalDeviceTexelBufferAlignmentProperties.bits() => {
                Some(Self::PhysicalDeviceTexelBufferAlignmentProperties)
            },
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::FormatProperties3.bits() => Some(Self::FormatProperties3),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::PhysicalDeviceMaintenance4Features.bits() => Some(Self::PhysicalDeviceMaintenance4Features),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::PhysicalDeviceMaintenance4Properties.bits() => {
                Some(Self::PhysicalDeviceMaintenance4Properties)
            },
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::DeviceBufferMemoryRequirements.bits() => Some(Self::DeviceBufferMemoryRequirements),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::DeviceImageMemoryRequirements.bits() => Some(Self::DeviceImageMemoryRequirements),
            #[cfg(feature = "VK_KHR_swapchain")]
            x if x == Self::SwapchainCreateInfoKhr.bits() => Some(Self::SwapchainCreateInfoKhr),
            #[cfg(feature = "VK_KHR_swapchain")]
            x if x == Self::PresentInfoKhr.bits() => Some(Self::PresentInfoKhr),
            #[cfg(feature = "VK_KHR_device_group")]
            x if x == Self::DeviceGroupPresentCapabilitiesKhr.bits() => Some(Self::DeviceGroupPresentCapabilitiesKhr),
            #[cfg(feature = "VK_KHR_device_group")]
            x if x == Self::ImageSwapchainCreateInfoKhr.bits() => Some(Self::ImageSwapchainCreateInfoKhr),
            #[cfg(feature = "VK_KHR_device_group")]
            x if x == Self::BindImageMemorySwapchainInfoKhr.bits() => Some(Self::BindImageMemorySwapchainInfoKhr),
            #[cfg(feature = "VK_KHR_device_group")]
            x if x == Self::AcquireNextImageInfoKhr.bits() => Some(Self::AcquireNextImageInfoKhr),
            #[cfg(feature = "VK_KHR_device_group")]
            x if x == Self::DeviceGroupPresentInfoKhr.bits() => Some(Self::DeviceGroupPresentInfoKhr),
            #[cfg(feature = "VK_KHR_device_group")]
            x if x == Self::DeviceGroupSwapchainCreateInfoKhr.bits() => Some(Self::DeviceGroupSwapchainCreateInfoKhr),
            #[cfg(feature = "VK_KHR_display")]
            x if x == Self::DisplayModeCreateInfoKhr.bits() => Some(Self::DisplayModeCreateInfoKhr),
            #[cfg(feature = "VK_KHR_display")]
            x if x == Self::DisplaySurfaceCreateInfoKhr.bits() => Some(Self::DisplaySurfaceCreateInfoKhr),
            #[cfg(feature = "VK_KHR_display_swapchain")]
            x if x == Self::DisplayPresentInfoKhr.bits() => Some(Self::DisplayPresentInfoKhr),
            #[cfg(feature = "VK_KHR_xlib_surface")]
            x if x == Self::XlibSurfaceCreateInfoKhr.bits() => Some(Self::XlibSurfaceCreateInfoKhr),
            #[cfg(feature = "VK_KHR_xcb_surface")]
            x if x == Self::XcbSurfaceCreateInfoKhr.bits() => Some(Self::XcbSurfaceCreateInfoKhr),
            #[cfg(feature = "VK_KHR_wayland_surface")]
            x if x == Self::WaylandSurfaceCreateInfoKhr.bits() => Some(Self::WaylandSurfaceCreateInfoKhr),
            #[cfg(feature = "VK_KHR_android_surface")]
            x if x == Self::AndroidSurfaceCreateInfoKhr.bits() => Some(Self::AndroidSurfaceCreateInfoKhr),
            #[cfg(feature = "VK_KHR_win32_surface")]
            x if x == Self::Win32SurfaceCreateInfoKhr.bits() => Some(Self::Win32SurfaceCreateInfoKhr),
            #[cfg(feature = "VK_ANDROID_native_buffer")]
            x if x == Self::NativeBufferAndroid.bits() => Some(Self::NativeBufferAndroid),
            #[cfg(feature = "VK_ANDROID_native_buffer")]
            x if x == Self::SwapchainImageCreateInfoAndroid.bits() => Some(Self::SwapchainImageCreateInfoAndroid),
            #[cfg(feature = "VK_ANDROID_native_buffer")]
            x if x == Self::PhysicalDevicePresentationPropertiesAndroid.bits() => {
                Some(Self::PhysicalDevicePresentationPropertiesAndroid)
            },
            #[cfg(feature = "VK_EXT_debug_report")]
            x if x == Self::DebugReportCallbackCreateInfoExt.bits() => Some(Self::DebugReportCallbackCreateInfoExt),
            #[cfg(feature = "VK_AMD_rasterization_order")]
            x if x == Self::PipelineRasterizationStateRasterizationOrderAmd.bits() => {
                Some(Self::PipelineRasterizationStateRasterizationOrderAmd)
            },
            #[cfg(feature = "VK_EXT_debug_marker")]
            x if x == Self::DebugMarkerObjectNameInfoExt.bits() => Some(Self::DebugMarkerObjectNameInfoExt),
            #[cfg(feature = "VK_EXT_debug_marker")]
            x if x == Self::DebugMarkerObjectTagInfoExt.bits() => Some(Self::DebugMarkerObjectTagInfoExt),
            #[cfg(feature = "VK_EXT_debug_marker")]
            x if x == Self::DebugMarkerMarkerInfoExt.bits() => Some(Self::DebugMarkerMarkerInfoExt),
            #[cfg(feature = "VK_KHR_video_queue")]
            x if x == Self::VideoProfileKhr.bits() => Some(Self::VideoProfileKhr),
            #[cfg(feature = "VK_KHR_video_queue")]
            x if x == Self::VideoCapabilitiesKhr.bits() => Some(Self::VideoCapabilitiesKhr),
            #[cfg(feature = "VK_KHR_video_queue")]
            x if x == Self::VideoPictureResourceKhr.bits() => Some(Self::VideoPictureResourceKhr),
            #[cfg(feature = "VK_KHR_video_queue")]
            x if x == Self::VideoGetMemoryPropertiesKhr.bits() => Some(Self::VideoGetMemoryPropertiesKhr),
            #[cfg(feature = "VK_KHR_video_queue")]
            x if x == Self::VideoBindMemoryKhr.bits() => Some(Self::VideoBindMemoryKhr),
            #[cfg(feature = "VK_KHR_video_queue")]
            x if x == Self::VideoSessionCreateInfoKhr.bits() => Some(Self::VideoSessionCreateInfoKhr),
            #[cfg(feature = "VK_KHR_video_queue")]
            x if x == Self::VideoSessionParametersCreateInfoKhr.bits() => {
                Some(Self::VideoSessionParametersCreateInfoKhr)
            },
            #[cfg(feature = "VK_KHR_video_queue")]
            x if x == Self::VideoSessionParametersUpdateInfoKhr.bits() => {
                Some(Self::VideoSessionParametersUpdateInfoKhr)
            },
            #[cfg(feature = "VK_KHR_video_queue")]
            x if x == Self::VideoBeginCodingInfoKhr.bits() => Some(Self::VideoBeginCodingInfoKhr),
            #[cfg(feature = "VK_KHR_video_queue")]
            x if x == Self::VideoEndCodingInfoKhr.bits() => Some(Self::VideoEndCodingInfoKhr),
            #[cfg(feature = "VK_KHR_video_queue")]
            x if x == Self::VideoCodingControlInfoKhr.bits() => Some(Self::VideoCodingControlInfoKhr),
            #[cfg(feature = "VK_KHR_video_queue")]
            x if x == Self::VideoReferenceSlotKhr.bits() => Some(Self::VideoReferenceSlotKhr),
            #[cfg(feature = "VK_KHR_video_queue")]
            x if x == Self::VideoQueueFamilyProperties2Khr.bits() => Some(Self::VideoQueueFamilyProperties2Khr),
            #[cfg(feature = "VK_KHR_video_queue")]
            x if x == Self::VideoProfilesKhr.bits() => Some(Self::VideoProfilesKhr),
            #[cfg(feature = "VK_KHR_video_queue")]
            x if x == Self::PhysicalDeviceVideoFormatInfoKhr.bits() => Some(Self::PhysicalDeviceVideoFormatInfoKhr),
            #[cfg(feature = "VK_KHR_video_queue")]
            x if x == Self::VideoFormatPropertiesKhr.bits() => Some(Self::VideoFormatPropertiesKhr),
            #[cfg(feature = "VK_KHR_video_queue")]
            x if x == Self::QueueFamilyQueryResultStatusProperties2Khr.bits() => {
                Some(Self::QueueFamilyQueryResultStatusProperties2Khr)
            },
            #[cfg(feature = "VK_KHR_video_decode_queue")]
            x if x == Self::VideoDecodeInfoKhr.bits() => Some(Self::VideoDecodeInfoKhr),
            #[cfg(feature = "VK_KHR_video_decode_queue")]
            x if x == Self::VideoDecodeCapabilitiesKhr.bits() => Some(Self::VideoDecodeCapabilitiesKhr),
            #[cfg(feature = "VK_NV_dedicated_allocation")]
            x if x == Self::DedicatedAllocationImageCreateInfoNv.bits() => {
                Some(Self::DedicatedAllocationImageCreateInfoNv)
            },
            #[cfg(feature = "VK_NV_dedicated_allocation")]
            x if x == Self::DedicatedAllocationBufferCreateInfoNv.bits() => {
                Some(Self::DedicatedAllocationBufferCreateInfoNv)
            },
            #[cfg(feature = "VK_NV_dedicated_allocation")]
            x if x == Self::DedicatedAllocationMemoryAllocateInfoNv.bits() => {
                Some(Self::DedicatedAllocationMemoryAllocateInfoNv)
            },
            #[cfg(feature = "VK_EXT_transform_feedback")]
            x if x == Self::PhysicalDeviceTransformFeedbackFeaturesExt.bits() => {
                Some(Self::PhysicalDeviceTransformFeedbackFeaturesExt)
            },
            #[cfg(feature = "VK_EXT_transform_feedback")]
            x if x == Self::PhysicalDeviceTransformFeedbackPropertiesExt.bits() => {
                Some(Self::PhysicalDeviceTransformFeedbackPropertiesExt)
            },
            #[cfg(feature = "VK_EXT_transform_feedback")]
            x if x == Self::PipelineRasterizationStateStreamCreateInfoExt.bits() => {
                Some(Self::PipelineRasterizationStateStreamCreateInfoExt)
            },
            #[cfg(feature = "VK_NVX_binary_import")]
            x if x == Self::CuModuleCreateInfoNvx.bits() => Some(Self::CuModuleCreateInfoNvx),
            #[cfg(feature = "VK_NVX_binary_import")]
            x if x == Self::CuFunctionCreateInfoNvx.bits() => Some(Self::CuFunctionCreateInfoNvx),
            #[cfg(feature = "VK_NVX_binary_import")]
            x if x == Self::CuLaunchInfoNvx.bits() => Some(Self::CuLaunchInfoNvx),
            #[cfg(feature = "VK_NVX_image_view_handle")]
            x if x == Self::ImageViewHandleInfoNvx.bits() => Some(Self::ImageViewHandleInfoNvx),
            #[cfg(feature = "VK_NVX_image_view_handle")]
            x if x == Self::ImageViewAddressPropertiesNvx.bits() => Some(Self::ImageViewAddressPropertiesNvx),
            #[cfg(feature = "VK_EXT_video_encode_h264")]
            x if x == Self::VideoEncodeH264CapabilitiesExt.bits() => Some(Self::VideoEncodeH264CapabilitiesExt),
            #[cfg(feature = "VK_EXT_video_encode_h264")]
            x if x == Self::VideoEncodeH264SessionParametersCreateInfoExt.bits() => {
                Some(Self::VideoEncodeH264SessionParametersCreateInfoExt)
            },
            #[cfg(feature = "VK_EXT_video_encode_h264")]
            x if x == Self::VideoEncodeH264SessionParametersAddInfoExt.bits() => {
                Some(Self::VideoEncodeH264SessionParametersAddInfoExt)
            },
            #[cfg(feature = "VK_EXT_video_encode_h264")]
            x if x == Self::VideoEncodeH264VclFrameInfoExt.bits() => Some(Self::VideoEncodeH264VclFrameInfoExt),
            #[cfg(feature = "VK_EXT_video_encode_h264")]
            x if x == Self::VideoEncodeH264DpbSlotInfoExt.bits() => Some(Self::VideoEncodeH264DpbSlotInfoExt),
            #[cfg(feature = "VK_EXT_video_encode_h264")]
            x if x == Self::VideoEncodeH264NaluSliceExt.bits() => Some(Self::VideoEncodeH264NaluSliceExt),
            #[cfg(feature = "VK_EXT_video_encode_h264")]
            x if x == Self::VideoEncodeH264EmitPictureParametersExt.bits() => {
                Some(Self::VideoEncodeH264EmitPictureParametersExt)
            },
            #[cfg(feature = "VK_EXT_video_encode_h264")]
            x if x == Self::VideoEncodeH264ProfileExt.bits() => Some(Self::VideoEncodeH264ProfileExt),
            #[cfg(feature = "VK_EXT_video_encode_h264")]
            x if x == Self::VideoEncodeH264RateControlInfoExt.bits() => Some(Self::VideoEncodeH264RateControlInfoExt),
            #[cfg(feature = "VK_EXT_video_encode_h264")]
            x if x == Self::VideoEncodeH264RateControlLayerInfoExt.bits() => {
                Some(Self::VideoEncodeH264RateControlLayerInfoExt)
            },
            #[cfg(feature = "VK_EXT_video_encode_h264")]
            x if x == Self::VideoEncodeH264ReferenceListsExt.bits() => Some(Self::VideoEncodeH264ReferenceListsExt),
            #[cfg(feature = "VK_EXT_video_encode_h265")]
            x if x == Self::VideoEncodeH265CapabilitiesExt.bits() => Some(Self::VideoEncodeH265CapabilitiesExt),
            #[cfg(feature = "VK_EXT_video_encode_h265")]
            x if x == Self::VideoEncodeH265SessionParametersCreateInfoExt.bits() => {
                Some(Self::VideoEncodeH265SessionParametersCreateInfoExt)
            },
            #[cfg(feature = "VK_EXT_video_encode_h265")]
            x if x == Self::VideoEncodeH265SessionParametersAddInfoExt.bits() => {
                Some(Self::VideoEncodeH265SessionParametersAddInfoExt)
            },
            #[cfg(feature = "VK_EXT_video_encode_h265")]
            x if x == Self::VideoEncodeH265VclFrameInfoExt.bits() => Some(Self::VideoEncodeH265VclFrameInfoExt),
            #[cfg(feature = "VK_EXT_video_encode_h265")]
            x if x == Self::VideoEncodeH265DpbSlotInfoExt.bits() => Some(Self::VideoEncodeH265DpbSlotInfoExt),
            #[cfg(feature = "VK_EXT_video_encode_h265")]
            x if x == Self::VideoEncodeH265NaluSliceSegmentExt.bits() => Some(Self::VideoEncodeH265NaluSliceSegmentExt),
            #[cfg(feature = "VK_EXT_video_encode_h265")]
            x if x == Self::VideoEncodeH265EmitPictureParametersExt.bits() => {
                Some(Self::VideoEncodeH265EmitPictureParametersExt)
            },
            #[cfg(feature = "VK_EXT_video_encode_h265")]
            x if x == Self::VideoEncodeH265ProfileExt.bits() => Some(Self::VideoEncodeH265ProfileExt),
            #[cfg(feature = "VK_EXT_video_encode_h265")]
            x if x == Self::VideoEncodeH265ReferenceListsExt.bits() => Some(Self::VideoEncodeH265ReferenceListsExt),
            #[cfg(feature = "VK_EXT_video_encode_h265")]
            x if x == Self::VideoEncodeH265RateControlInfoExt.bits() => Some(Self::VideoEncodeH265RateControlInfoExt),
            #[cfg(feature = "VK_EXT_video_encode_h265")]
            x if x == Self::VideoEncodeH265RateControlLayerInfoExt.bits() => {
                Some(Self::VideoEncodeH265RateControlLayerInfoExt)
            },
            #[cfg(feature = "VK_EXT_video_decode_h264")]
            x if x == Self::VideoDecodeH264CapabilitiesExt.bits() => Some(Self::VideoDecodeH264CapabilitiesExt),
            #[cfg(feature = "VK_EXT_video_decode_h264")]
            x if x == Self::VideoDecodeH264PictureInfoExt.bits() => Some(Self::VideoDecodeH264PictureInfoExt),
            #[cfg(feature = "VK_EXT_video_decode_h264")]
            x if x == Self::VideoDecodeH264MvcExt.bits() => Some(Self::VideoDecodeH264MvcExt),
            #[cfg(feature = "VK_EXT_video_decode_h264")]
            x if x == Self::VideoDecodeH264ProfileExt.bits() => Some(Self::VideoDecodeH264ProfileExt),
            #[cfg(feature = "VK_EXT_video_decode_h264")]
            x if x == Self::VideoDecodeH264SessionParametersCreateInfoExt.bits() => {
                Some(Self::VideoDecodeH264SessionParametersCreateInfoExt)
            },
            #[cfg(feature = "VK_EXT_video_decode_h264")]
            x if x == Self::VideoDecodeH264SessionParametersAddInfoExt.bits() => {
                Some(Self::VideoDecodeH264SessionParametersAddInfoExt)
            },
            #[cfg(feature = "VK_EXT_video_decode_h264")]
            x if x == Self::VideoDecodeH264DpbSlotInfoExt.bits() => Some(Self::VideoDecodeH264DpbSlotInfoExt),
            #[cfg(feature = "VK_AMD_texture_gather_bias_lod")]
            x if x == Self::TextureLodGatherFormatPropertiesAmd.bits() => {
                Some(Self::TextureLodGatherFormatPropertiesAmd)
            },
            #[cfg(feature = "VK_KHR_dynamic_rendering")]
            x if x == Self::RenderingFragmentShadingRateAttachmentInfoKhr.bits() => {
                Some(Self::RenderingFragmentShadingRateAttachmentInfoKhr)
            },
            #[cfg(feature = "VK_KHR_dynamic_rendering")]
            x if x == Self::RenderingFragmentDensityMapAttachmentInfoExt.bits() => {
                Some(Self::RenderingFragmentDensityMapAttachmentInfoExt)
            },
            #[cfg(feature = "VK_KHR_dynamic_rendering")]
            x if x == Self::AttachmentSampleCountInfoAmd.bits() => Some(Self::AttachmentSampleCountInfoAmd),
            #[cfg(feature = "VK_KHR_dynamic_rendering")]
            x if x == Self::MultiviewPerViewAttributesInfoNvx.bits() => Some(Self::MultiviewPerViewAttributesInfoNvx),
            #[cfg(feature = "VK_GGP_stream_descriptor_surface")]
            x if x == Self::StreamDescriptorSurfaceCreateInfoGgp.bits() => {
                Some(Self::StreamDescriptorSurfaceCreateInfoGgp)
            },
            #[cfg(feature = "VK_NV_corner_sampled_image")]
            x if x == Self::PhysicalDeviceCornerSampledImageFeaturesNv.bits() => {
                Some(Self::PhysicalDeviceCornerSampledImageFeaturesNv)
            },
            #[cfg(feature = "VK_NV_external_memory")]
            x if x == Self::ExternalMemoryImageCreateInfoNv.bits() => Some(Self::ExternalMemoryImageCreateInfoNv),
            #[cfg(feature = "VK_NV_external_memory")]
            x if x == Self::ExportMemoryAllocateInfoNv.bits() => Some(Self::ExportMemoryAllocateInfoNv),
            #[cfg(feature = "VK_NV_external_memory_win32")]
            x if x == Self::ImportMemoryWin32HandleInfoNv.bits() => Some(Self::ImportMemoryWin32HandleInfoNv),
            #[cfg(feature = "VK_NV_external_memory_win32")]
            x if x == Self::ExportMemoryWin32HandleInfoNv.bits() => Some(Self::ExportMemoryWin32HandleInfoNv),
            #[cfg(feature = "VK_NV_win32_keyed_mutex")]
            x if x == Self::Win32KeyedMutexAcquireReleaseInfoNv.bits() => {
                Some(Self::Win32KeyedMutexAcquireReleaseInfoNv)
            },
            #[cfg(feature = "VK_EXT_validation_flags")]
            x if x == Self::ValidationFlagsExt.bits() => Some(Self::ValidationFlagsExt),
            #[cfg(feature = "VK_NN_vi_surface")]
            x if x == Self::ViSurfaceCreateInfoNn.bits() => Some(Self::ViSurfaceCreateInfoNn),
            #[cfg(feature = "VK_EXT_astc_decode_mode")]
            x if x == Self::ImageViewAstcDecodeModeExt.bits() => Some(Self::ImageViewAstcDecodeModeExt),
            #[cfg(feature = "VK_EXT_astc_decode_mode")]
            x if x == Self::PhysicalDeviceAstcDecodeFeaturesExt.bits() => {
                Some(Self::PhysicalDeviceAstcDecodeFeaturesExt)
            },
            #[cfg(feature = "VK_KHR_external_memory_win32")]
            x if x == Self::ImportMemoryWin32HandleInfoKhr.bits() => Some(Self::ImportMemoryWin32HandleInfoKhr),
            #[cfg(feature = "VK_KHR_external_memory_win32")]
            x if x == Self::ExportMemoryWin32HandleInfoKhr.bits() => Some(Self::ExportMemoryWin32HandleInfoKhr),
            #[cfg(feature = "VK_KHR_external_memory_win32")]
            x if x == Self::MemoryWin32HandlePropertiesKhr.bits() => Some(Self::MemoryWin32HandlePropertiesKhr),
            #[cfg(feature = "VK_KHR_external_memory_win32")]
            x if x == Self::MemoryGetWin32HandleInfoKhr.bits() => Some(Self::MemoryGetWin32HandleInfoKhr),
            #[cfg(feature = "VK_KHR_external_memory_fd")]
            x if x == Self::ImportMemoryFdInfoKhr.bits() => Some(Self::ImportMemoryFdInfoKhr),
            #[cfg(feature = "VK_KHR_external_memory_fd")]
            x if x == Self::MemoryFdPropertiesKhr.bits() => Some(Self::MemoryFdPropertiesKhr),
            #[cfg(feature = "VK_KHR_external_memory_fd")]
            x if x == Self::MemoryGetFdInfoKhr.bits() => Some(Self::MemoryGetFdInfoKhr),
            #[cfg(feature = "VK_KHR_win32_keyed_mutex")]
            x if x == Self::Win32KeyedMutexAcquireReleaseInfoKhr.bits() => {
                Some(Self::Win32KeyedMutexAcquireReleaseInfoKhr)
            },
            #[cfg(feature = "VK_KHR_external_semaphore_win32")]
            x if x == Self::ImportSemaphoreWin32HandleInfoKhr.bits() => Some(Self::ImportSemaphoreWin32HandleInfoKhr),
            #[cfg(feature = "VK_KHR_external_semaphore_win32")]
            x if x == Self::ExportSemaphoreWin32HandleInfoKhr.bits() => Some(Self::ExportSemaphoreWin32HandleInfoKhr),
            #[cfg(feature = "VK_KHR_external_semaphore_win32")]
            x if x == Self::D3d12FenceSubmitInfoKhr.bits() => Some(Self::D3d12FenceSubmitInfoKhr),
            #[cfg(feature = "VK_KHR_external_semaphore_win32")]
            x if x == Self::SemaphoreGetWin32HandleInfoKhr.bits() => Some(Self::SemaphoreGetWin32HandleInfoKhr),
            #[cfg(feature = "VK_KHR_external_semaphore_fd")]
            x if x == Self::ImportSemaphoreFdInfoKhr.bits() => Some(Self::ImportSemaphoreFdInfoKhr),
            #[cfg(feature = "VK_KHR_external_semaphore_fd")]
            x if x == Self::SemaphoreGetFdInfoKhr.bits() => Some(Self::SemaphoreGetFdInfoKhr),
            #[cfg(feature = "VK_KHR_push_descriptor")]
            x if x == Self::PhysicalDevicePushDescriptorPropertiesKhr.bits() => {
                Some(Self::PhysicalDevicePushDescriptorPropertiesKhr)
            },
            #[cfg(feature = "VK_EXT_conditional_rendering")]
            x if x == Self::CommandBufferInheritanceConditionalRenderingInfoExt.bits() => {
                Some(Self::CommandBufferInheritanceConditionalRenderingInfoExt)
            },
            #[cfg(feature = "VK_EXT_conditional_rendering")]
            x if x == Self::PhysicalDeviceConditionalRenderingFeaturesExt.bits() => {
                Some(Self::PhysicalDeviceConditionalRenderingFeaturesExt)
            },
            #[cfg(feature = "VK_EXT_conditional_rendering")]
            x if x == Self::ConditionalRenderingBeginInfoExt.bits() => Some(Self::ConditionalRenderingBeginInfoExt),
            #[cfg(feature = "VK_KHR_incremental_present")]
            x if x == Self::PresentRegionsKhr.bits() => Some(Self::PresentRegionsKhr),
            #[cfg(feature = "VK_NV_clip_space_w_scaling")]
            x if x == Self::PipelineViewportWScalingStateCreateInfoNv.bits() => {
                Some(Self::PipelineViewportWScalingStateCreateInfoNv)
            },
            #[cfg(feature = "VK_EXT_display_surface_counter")]
            x if x == Self::SurfaceCapabilities2Ext.bits() => Some(Self::SurfaceCapabilities2Ext),
            #[cfg(feature = "VK_EXT_display_control")]
            x if x == Self::DisplayPowerInfoExt.bits() => Some(Self::DisplayPowerInfoExt),
            #[cfg(feature = "VK_EXT_display_control")]
            x if x == Self::DeviceEventInfoExt.bits() => Some(Self::DeviceEventInfoExt),
            #[cfg(feature = "VK_EXT_display_control")]
            x if x == Self::DisplayEventInfoExt.bits() => Some(Self::DisplayEventInfoExt),
            #[cfg(feature = "VK_EXT_display_control")]
            x if x == Self::SwapchainCounterCreateInfoExt.bits() => Some(Self::SwapchainCounterCreateInfoExt),
            #[cfg(feature = "VK_GOOGLE_display_timing")]
            x if x == Self::PresentTimesInfoGoogle.bits() => Some(Self::PresentTimesInfoGoogle),
            #[cfg(feature = "VK_NVX_multiview_per_view_attributes")]
            x if x == Self::PhysicalDeviceMultiviewPerViewAttributesPropertiesNvx.bits() => {
                Some(Self::PhysicalDeviceMultiviewPerViewAttributesPropertiesNvx)
            },
            #[cfg(feature = "VK_NV_viewport_swizzle")]
            x if x == Self::PipelineViewportSwizzleStateCreateInfoNv.bits() => {
                Some(Self::PipelineViewportSwizzleStateCreateInfoNv)
            },
            #[cfg(feature = "VK_EXT_discard_rectangles")]
            x if x == Self::PhysicalDeviceDiscardRectanglePropertiesExt.bits() => {
                Some(Self::PhysicalDeviceDiscardRectanglePropertiesExt)
            },
            #[cfg(feature = "VK_EXT_discard_rectangles")]
            x if x == Self::PipelineDiscardRectangleStateCreateInfoExt.bits() => {
                Some(Self::PipelineDiscardRectangleStateCreateInfoExt)
            },
            #[cfg(feature = "VK_EXT_conservative_rasterization")]
            x if x == Self::PhysicalDeviceConservativeRasterizationPropertiesExt.bits() => {
                Some(Self::PhysicalDeviceConservativeRasterizationPropertiesExt)
            },
            #[cfg(feature = "VK_EXT_conservative_rasterization")]
            x if x == Self::PipelineRasterizationConservativeStateCreateInfoExt.bits() => {
                Some(Self::PipelineRasterizationConservativeStateCreateInfoExt)
            },
            #[cfg(feature = "VK_EXT_depth_clip_enable")]
            x if x == Self::PhysicalDeviceDepthClipEnableFeaturesExt.bits() => {
                Some(Self::PhysicalDeviceDepthClipEnableFeaturesExt)
            },
            #[cfg(feature = "VK_EXT_depth_clip_enable")]
            x if x == Self::PipelineRasterizationDepthClipStateCreateInfoExt.bits() => {
                Some(Self::PipelineRasterizationDepthClipStateCreateInfoExt)
            },
            #[cfg(feature = "VK_EXT_hdr_metadata")]
            x if x == Self::HdrMetadataExt.bits() => Some(Self::HdrMetadataExt),
            #[cfg(feature = "VK_KHR_shared_presentable_image")]
            x if x == Self::SharedPresentSurfaceCapabilitiesKhr.bits() => {
                Some(Self::SharedPresentSurfaceCapabilitiesKhr)
            },
            #[cfg(feature = "VK_KHR_external_fence_win32")]
            x if x == Self::ImportFenceWin32HandleInfoKhr.bits() => Some(Self::ImportFenceWin32HandleInfoKhr),
            #[cfg(feature = "VK_KHR_external_fence_win32")]
            x if x == Self::ExportFenceWin32HandleInfoKhr.bits() => Some(Self::ExportFenceWin32HandleInfoKhr),
            #[cfg(feature = "VK_KHR_external_fence_win32")]
            x if x == Self::FenceGetWin32HandleInfoKhr.bits() => Some(Self::FenceGetWin32HandleInfoKhr),
            #[cfg(feature = "VK_KHR_external_fence_fd")]
            x if x == Self::ImportFenceFdInfoKhr.bits() => Some(Self::ImportFenceFdInfoKhr),
            #[cfg(feature = "VK_KHR_external_fence_fd")]
            x if x == Self::FenceGetFdInfoKhr.bits() => Some(Self::FenceGetFdInfoKhr),
            #[cfg(feature = "VK_KHR_performance_query")]
            x if x == Self::PhysicalDevicePerformanceQueryFeaturesKhr.bits() => {
                Some(Self::PhysicalDevicePerformanceQueryFeaturesKhr)
            },
            #[cfg(feature = "VK_KHR_performance_query")]
            x if x == Self::PhysicalDevicePerformanceQueryPropertiesKhr.bits() => {
                Some(Self::PhysicalDevicePerformanceQueryPropertiesKhr)
            },
            #[cfg(feature = "VK_KHR_performance_query")]
            x if x == Self::QueryPoolPerformanceCreateInfoKhr.bits() => Some(Self::QueryPoolPerformanceCreateInfoKhr),
            #[cfg(feature = "VK_KHR_performance_query")]
            x if x == Self::PerformanceQuerySubmitInfoKhr.bits() => Some(Self::PerformanceQuerySubmitInfoKhr),
            #[cfg(feature = "VK_KHR_performance_query")]
            x if x == Self::AcquireProfilingLockInfoKhr.bits() => Some(Self::AcquireProfilingLockInfoKhr),
            #[cfg(feature = "VK_KHR_performance_query")]
            x if x == Self::PerformanceCounterKhr.bits() => Some(Self::PerformanceCounterKhr),
            #[cfg(feature = "VK_KHR_performance_query")]
            x if x == Self::PerformanceCounterDescriptionKhr.bits() => Some(Self::PerformanceCounterDescriptionKhr),
            #[cfg(feature = "VK_KHR_get_surface_capabilities2")]
            x if x == Self::PhysicalDeviceSurfaceInfo2Khr.bits() => Some(Self::PhysicalDeviceSurfaceInfo2Khr),
            #[cfg(feature = "VK_KHR_get_surface_capabilities2")]
            x if x == Self::SurfaceCapabilities2Khr.bits() => Some(Self::SurfaceCapabilities2Khr),
            #[cfg(feature = "VK_KHR_get_surface_capabilities2")]
            x if x == Self::SurfaceFormat2Khr.bits() => Some(Self::SurfaceFormat2Khr),
            #[cfg(feature = "VK_KHR_get_display_properties2")]
            x if x == Self::DisplayProperties2Khr.bits() => Some(Self::DisplayProperties2Khr),
            #[cfg(feature = "VK_KHR_get_display_properties2")]
            x if x == Self::DisplayPlaneProperties2Khr.bits() => Some(Self::DisplayPlaneProperties2Khr),
            #[cfg(feature = "VK_KHR_get_display_properties2")]
            x if x == Self::DisplayModeProperties2Khr.bits() => Some(Self::DisplayModeProperties2Khr),
            #[cfg(feature = "VK_KHR_get_display_properties2")]
            x if x == Self::DisplayPlaneInfo2Khr.bits() => Some(Self::DisplayPlaneInfo2Khr),
            #[cfg(feature = "VK_KHR_get_display_properties2")]
            x if x == Self::DisplayPlaneCapabilities2Khr.bits() => Some(Self::DisplayPlaneCapabilities2Khr),
            #[cfg(feature = "VK_MVK_ios_surface")]
            x if x == Self::IosSurfaceCreateInfoMvk.bits() => Some(Self::IosSurfaceCreateInfoMvk),
            #[cfg(feature = "VK_MVK_macos_surface")]
            x if x == Self::MacosSurfaceCreateInfoMvk.bits() => Some(Self::MacosSurfaceCreateInfoMvk),
            #[cfg(feature = "VK_EXT_debug_utils")]
            x if x == Self::DebugUtilsObjectNameInfoExt.bits() => Some(Self::DebugUtilsObjectNameInfoExt),
            #[cfg(feature = "VK_EXT_debug_utils")]
            x if x == Self::DebugUtilsObjectTagInfoExt.bits() => Some(Self::DebugUtilsObjectTagInfoExt),
            #[cfg(feature = "VK_EXT_debug_utils")]
            x if x == Self::DebugUtilsLabelExt.bits() => Some(Self::DebugUtilsLabelExt),
            #[cfg(feature = "VK_EXT_debug_utils")]
            x if x == Self::DebugUtilsMessengerCallbackDataExt.bits() => Some(Self::DebugUtilsMessengerCallbackDataExt),
            #[cfg(feature = "VK_EXT_debug_utils")]
            x if x == Self::DebugUtilsMessengerCreateInfoExt.bits() => Some(Self::DebugUtilsMessengerCreateInfoExt),
            #[cfg(feature = "VK_ANDROID_external_memory_android_hardware_buffer")]
            x if x == Self::AndroidHardwareBufferUsageAndroid.bits() => Some(Self::AndroidHardwareBufferUsageAndroid),
            #[cfg(feature = "VK_ANDROID_external_memory_android_hardware_buffer")]
            x if x == Self::AndroidHardwareBufferPropertiesAndroid.bits() => {
                Some(Self::AndroidHardwareBufferPropertiesAndroid)
            },
            #[cfg(feature = "VK_ANDROID_external_memory_android_hardware_buffer")]
            x if x == Self::AndroidHardwareBufferFormatPropertiesAndroid.bits() => {
                Some(Self::AndroidHardwareBufferFormatPropertiesAndroid)
            },
            #[cfg(feature = "VK_ANDROID_external_memory_android_hardware_buffer")]
            x if x == Self::ImportAndroidHardwareBufferInfoAndroid.bits() => {
                Some(Self::ImportAndroidHardwareBufferInfoAndroid)
            },
            #[cfg(feature = "VK_ANDROID_external_memory_android_hardware_buffer")]
            x if x == Self::MemoryGetAndroidHardwareBufferInfoAndroid.bits() => {
                Some(Self::MemoryGetAndroidHardwareBufferInfoAndroid)
            },
            #[cfg(feature = "VK_ANDROID_external_memory_android_hardware_buffer")]
            x if x == Self::ExternalFormatAndroid.bits() => Some(Self::ExternalFormatAndroid),
            #[cfg(feature = "VK_ANDROID_external_memory_android_hardware_buffer")]
            x if x == Self::AndroidHardwareBufferFormatProperties2Android.bits() => {
                Some(Self::AndroidHardwareBufferFormatProperties2Android)
            },
            #[cfg(feature = "VK_EXT_sample_locations")]
            x if x == Self::SampleLocationsInfoExt.bits() => Some(Self::SampleLocationsInfoExt),
            #[cfg(feature = "VK_EXT_sample_locations")]
            x if x == Self::RenderPassSampleLocationsBeginInfoExt.bits() => {
                Some(Self::RenderPassSampleLocationsBeginInfoExt)
            },
            #[cfg(feature = "VK_EXT_sample_locations")]
            x if x == Self::PipelineSampleLocationsStateCreateInfoExt.bits() => {
                Some(Self::PipelineSampleLocationsStateCreateInfoExt)
            },
            #[cfg(feature = "VK_EXT_sample_locations")]
            x if x == Self::PhysicalDeviceSampleLocationsPropertiesExt.bits() => {
                Some(Self::PhysicalDeviceSampleLocationsPropertiesExt)
            },
            #[cfg(feature = "VK_EXT_sample_locations")]
            x if x == Self::MultisamplePropertiesExt.bits() => Some(Self::MultisamplePropertiesExt),
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::PhysicalDeviceBlendOperationAdvancedFeaturesExt.bits() => {
                Some(Self::PhysicalDeviceBlendOperationAdvancedFeaturesExt)
            },
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::PhysicalDeviceBlendOperationAdvancedPropertiesExt.bits() => {
                Some(Self::PhysicalDeviceBlendOperationAdvancedPropertiesExt)
            },
            #[cfg(feature = "VK_EXT_blend_operation_advanced")]
            x if x == Self::PipelineColorBlendAdvancedStateCreateInfoExt.bits() => {
                Some(Self::PipelineColorBlendAdvancedStateCreateInfoExt)
            },
            #[cfg(feature = "VK_NV_fragment_coverage_to_color")]
            x if x == Self::PipelineCoverageToColorStateCreateInfoNv.bits() => {
                Some(Self::PipelineCoverageToColorStateCreateInfoNv)
            },
            #[cfg(feature = "VK_KHR_acceleration_structure")]
            x if x == Self::WriteDescriptorSetAccelerationStructureKhr.bits() => {
                Some(Self::WriteDescriptorSetAccelerationStructureKhr)
            },
            #[cfg(feature = "VK_KHR_acceleration_structure")]
            x if x == Self::AccelerationStructureBuildGeometryInfoKhr.bits() => {
                Some(Self::AccelerationStructureBuildGeometryInfoKhr)
            },
            #[cfg(feature = "VK_KHR_acceleration_structure")]
            x if x == Self::AccelerationStructureDeviceAddressInfoKhr.bits() => {
                Some(Self::AccelerationStructureDeviceAddressInfoKhr)
            },
            #[cfg(feature = "VK_KHR_acceleration_structure")]
            x if x == Self::AccelerationStructureGeometryAabbsDataKhr.bits() => {
                Some(Self::AccelerationStructureGeometryAabbsDataKhr)
            },
            #[cfg(feature = "VK_KHR_acceleration_structure")]
            x if x == Self::AccelerationStructureGeometryInstancesDataKhr.bits() => {
                Some(Self::AccelerationStructureGeometryInstancesDataKhr)
            },
            #[cfg(feature = "VK_KHR_acceleration_structure")]
            x if x == Self::AccelerationStructureGeometryTrianglesDataKhr.bits() => {
                Some(Self::AccelerationStructureGeometryTrianglesDataKhr)
            },
            #[cfg(feature = "VK_KHR_acceleration_structure")]
            x if x == Self::AccelerationStructureGeometryKhr.bits() => Some(Self::AccelerationStructureGeometryKhr),
            #[cfg(feature = "VK_KHR_acceleration_structure")]
            x if x == Self::AccelerationStructureVersionInfoKhr.bits() => {
                Some(Self::AccelerationStructureVersionInfoKhr)
            },
            #[cfg(feature = "VK_KHR_acceleration_structure")]
            x if x == Self::CopyAccelerationStructureInfoKhr.bits() => Some(Self::CopyAccelerationStructureInfoKhr),
            #[cfg(feature = "VK_KHR_acceleration_structure")]
            x if x == Self::CopyAccelerationStructureToMemoryInfoKhr.bits() => {
                Some(Self::CopyAccelerationStructureToMemoryInfoKhr)
            },
            #[cfg(feature = "VK_KHR_acceleration_structure")]
            x if x == Self::CopyMemoryToAccelerationStructureInfoKhr.bits() => {
                Some(Self::CopyMemoryToAccelerationStructureInfoKhr)
            },
            #[cfg(feature = "VK_KHR_acceleration_structure")]
            x if x == Self::PhysicalDeviceAccelerationStructureFeaturesKhr.bits() => {
                Some(Self::PhysicalDeviceAccelerationStructureFeaturesKhr)
            },
            #[cfg(feature = "VK_KHR_acceleration_structure")]
            x if x == Self::PhysicalDeviceAccelerationStructurePropertiesKhr.bits() => {
                Some(Self::PhysicalDeviceAccelerationStructurePropertiesKhr)
            },
            #[cfg(feature = "VK_KHR_acceleration_structure")]
            x if x == Self::AccelerationStructureCreateInfoKhr.bits() => Some(Self::AccelerationStructureCreateInfoKhr),
            #[cfg(feature = "VK_KHR_acceleration_structure")]
            x if x == Self::AccelerationStructureBuildSizesInfoKhr.bits() => {
                Some(Self::AccelerationStructureBuildSizesInfoKhr)
            },
            #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
            x if x == Self::PhysicalDeviceRayTracingPipelineFeaturesKhr.bits() => {
                Some(Self::PhysicalDeviceRayTracingPipelineFeaturesKhr)
            },
            #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
            x if x == Self::PhysicalDeviceRayTracingPipelinePropertiesKhr.bits() => {
                Some(Self::PhysicalDeviceRayTracingPipelinePropertiesKhr)
            },
            #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
            x if x == Self::RayTracingPipelineCreateInfoKhr.bits() => Some(Self::RayTracingPipelineCreateInfoKhr),
            #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
            x if x == Self::RayTracingShaderGroupCreateInfoKhr.bits() => Some(Self::RayTracingShaderGroupCreateInfoKhr),
            #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
            x if x == Self::RayTracingPipelineInterfaceCreateInfoKhr.bits() => {
                Some(Self::RayTracingPipelineInterfaceCreateInfoKhr)
            },
            #[cfg(feature = "VK_KHR_ray_query")]
            x if x == Self::PhysicalDeviceRayQueryFeaturesKhr.bits() => Some(Self::PhysicalDeviceRayQueryFeaturesKhr),
            #[cfg(feature = "VK_NV_framebuffer_mixed_samples")]
            x if x == Self::PipelineCoverageModulationStateCreateInfoNv.bits() => {
                Some(Self::PipelineCoverageModulationStateCreateInfoNv)
            },
            #[cfg(feature = "VK_NV_shader_sm_builtins")]
            x if x == Self::PhysicalDeviceShaderSmBuiltinsFeaturesNv.bits() => {
                Some(Self::PhysicalDeviceShaderSmBuiltinsFeaturesNv)
            },
            #[cfg(feature = "VK_NV_shader_sm_builtins")]
            x if x == Self::PhysicalDeviceShaderSmBuiltinsPropertiesNv.bits() => {
                Some(Self::PhysicalDeviceShaderSmBuiltinsPropertiesNv)
            },
            #[cfg(feature = "VK_EXT_image_drm_format_modifier")]
            x if x == Self::DrmFormatModifierPropertiesListExt.bits() => Some(Self::DrmFormatModifierPropertiesListExt),
            #[cfg(feature = "VK_EXT_image_drm_format_modifier")]
            x if x == Self::PhysicalDeviceImageDrmFormatModifierInfoExt.bits() => {
                Some(Self::PhysicalDeviceImageDrmFormatModifierInfoExt)
            },
            #[cfg(feature = "VK_EXT_image_drm_format_modifier")]
            x if x == Self::ImageDrmFormatModifierListCreateInfoExt.bits() => {
                Some(Self::ImageDrmFormatModifierListCreateInfoExt)
            },
            #[cfg(feature = "VK_EXT_image_drm_format_modifier")]
            x if x == Self::ImageDrmFormatModifierExplicitCreateInfoExt.bits() => {
                Some(Self::ImageDrmFormatModifierExplicitCreateInfoExt)
            },
            #[cfg(feature = "VK_EXT_image_drm_format_modifier")]
            x if x == Self::ImageDrmFormatModifierPropertiesExt.bits() => {
                Some(Self::ImageDrmFormatModifierPropertiesExt)
            },
            #[cfg(feature = "VK_EXT_image_drm_format_modifier")]
            x if x == Self::DrmFormatModifierPropertiesList2Ext.bits() => {
                Some(Self::DrmFormatModifierPropertiesList2Ext)
            },
            #[cfg(feature = "VK_EXT_validation_cache")]
            x if x == Self::ValidationCacheCreateInfoExt.bits() => Some(Self::ValidationCacheCreateInfoExt),
            #[cfg(feature = "VK_EXT_validation_cache")]
            x if x == Self::ShaderModuleValidationCacheCreateInfoExt.bits() => {
                Some(Self::ShaderModuleValidationCacheCreateInfoExt)
            },
            #[cfg(feature = "VK_KHR_portability_subset")]
            x if x == Self::PhysicalDevicePortabilitySubsetFeaturesKhr.bits() => {
                Some(Self::PhysicalDevicePortabilitySubsetFeaturesKhr)
            },
            #[cfg(feature = "VK_KHR_portability_subset")]
            x if x == Self::PhysicalDevicePortabilitySubsetPropertiesKhr.bits() => {
                Some(Self::PhysicalDevicePortabilitySubsetPropertiesKhr)
            },
            #[cfg(feature = "VK_NV_shading_rate_image")]
            x if x == Self::PipelineViewportShadingRateImageStateCreateInfoNv.bits() => {
                Some(Self::PipelineViewportShadingRateImageStateCreateInfoNv)
            },
            #[cfg(feature = "VK_NV_shading_rate_image")]
            x if x == Self::PhysicalDeviceShadingRateImageFeaturesNv.bits() => {
                Some(Self::PhysicalDeviceShadingRateImageFeaturesNv)
            },
            #[cfg(feature = "VK_NV_shading_rate_image")]
            x if x == Self::PhysicalDeviceShadingRateImagePropertiesNv.bits() => {
                Some(Self::PhysicalDeviceShadingRateImagePropertiesNv)
            },
            #[cfg(feature = "VK_NV_shading_rate_image")]
            x if x == Self::PipelineViewportCoarseSampleOrderStateCreateInfoNv.bits() => {
                Some(Self::PipelineViewportCoarseSampleOrderStateCreateInfoNv)
            },
            #[cfg(feature = "VK_NV_ray_tracing")]
            x if x == Self::RayTracingPipelineCreateInfoNv.bits() => Some(Self::RayTracingPipelineCreateInfoNv),
            #[cfg(feature = "VK_NV_ray_tracing")]
            x if x == Self::AccelerationStructureCreateInfoNv.bits() => Some(Self::AccelerationStructureCreateInfoNv),
            #[cfg(feature = "VK_NV_ray_tracing")]
            x if x == Self::GeometryNv.bits() => Some(Self::GeometryNv),
            #[cfg(feature = "VK_NV_ray_tracing")]
            x if x == Self::GeometryTrianglesNv.bits() => Some(Self::GeometryTrianglesNv),
            #[cfg(feature = "VK_NV_ray_tracing")]
            x if x == Self::GeometryAabbNv.bits() => Some(Self::GeometryAabbNv),
            #[cfg(feature = "VK_NV_ray_tracing")]
            x if x == Self::BindAccelerationStructureMemoryInfoNv.bits() => {
                Some(Self::BindAccelerationStructureMemoryInfoNv)
            },
            #[cfg(feature = "VK_NV_ray_tracing")]
            x if x == Self::WriteDescriptorSetAccelerationStructureNv.bits() => {
                Some(Self::WriteDescriptorSetAccelerationStructureNv)
            },
            #[cfg(feature = "VK_NV_ray_tracing")]
            x if x == Self::AccelerationStructureMemoryRequirementsInfoNv.bits() => {
                Some(Self::AccelerationStructureMemoryRequirementsInfoNv)
            },
            #[cfg(feature = "VK_NV_ray_tracing")]
            x if x == Self::PhysicalDeviceRayTracingPropertiesNv.bits() => {
                Some(Self::PhysicalDeviceRayTracingPropertiesNv)
            },
            #[cfg(feature = "VK_NV_ray_tracing")]
            x if x == Self::RayTracingShaderGroupCreateInfoNv.bits() => Some(Self::RayTracingShaderGroupCreateInfoNv),
            #[cfg(feature = "VK_NV_ray_tracing")]
            x if x == Self::AccelerationStructureInfoNv.bits() => Some(Self::AccelerationStructureInfoNv),
            #[cfg(feature = "VK_NV_representative_fragment_test")]
            x if x == Self::PhysicalDeviceRepresentativeFragmentTestFeaturesNv.bits() => {
                Some(Self::PhysicalDeviceRepresentativeFragmentTestFeaturesNv)
            },
            #[cfg(feature = "VK_NV_representative_fragment_test")]
            x if x == Self::PipelineRepresentativeFragmentTestStateCreateInfoNv.bits() => {
                Some(Self::PipelineRepresentativeFragmentTestStateCreateInfoNv)
            },
            #[cfg(feature = "VK_EXT_filter_cubic")]
            x if x == Self::PhysicalDeviceImageViewImageFormatInfoExt.bits() => {
                Some(Self::PhysicalDeviceImageViewImageFormatInfoExt)
            },
            #[cfg(feature = "VK_EXT_filter_cubic")]
            x if x == Self::FilterCubicImageViewImageFormatPropertiesExt.bits() => {
                Some(Self::FilterCubicImageViewImageFormatPropertiesExt)
            },
            #[cfg(feature = "VK_EXT_external_memory_host")]
            x if x == Self::ImportMemoryHostPointerInfoExt.bits() => Some(Self::ImportMemoryHostPointerInfoExt),
            #[cfg(feature = "VK_EXT_external_memory_host")]
            x if x == Self::MemoryHostPointerPropertiesExt.bits() => Some(Self::MemoryHostPointerPropertiesExt),
            #[cfg(feature = "VK_EXT_external_memory_host")]
            x if x == Self::PhysicalDeviceExternalMemoryHostPropertiesExt.bits() => {
                Some(Self::PhysicalDeviceExternalMemoryHostPropertiesExt)
            },
            #[cfg(feature = "VK_KHR_shader_clock")]
            x if x == Self::PhysicalDeviceShaderClockFeaturesKhr.bits() => {
                Some(Self::PhysicalDeviceShaderClockFeaturesKhr)
            },
            #[cfg(feature = "VK_AMD_pipeline_compiler_control")]
            x if x == Self::PipelineCompilerControlCreateInfoAmd.bits() => {
                Some(Self::PipelineCompilerControlCreateInfoAmd)
            },
            #[cfg(feature = "VK_EXT_calibrated_timestamps")]
            x if x == Self::CalibratedTimestampInfoExt.bits() => Some(Self::CalibratedTimestampInfoExt),
            #[cfg(feature = "VK_AMD_shader_core_properties")]
            x if x == Self::PhysicalDeviceShaderCorePropertiesAmd.bits() => {
                Some(Self::PhysicalDeviceShaderCorePropertiesAmd)
            },
            #[cfg(feature = "VK_EXT_video_decode_h265")]
            x if x == Self::VideoDecodeH265CapabilitiesExt.bits() => Some(Self::VideoDecodeH265CapabilitiesExt),
            #[cfg(feature = "VK_EXT_video_decode_h265")]
            x if x == Self::VideoDecodeH265SessionParametersCreateInfoExt.bits() => {
                Some(Self::VideoDecodeH265SessionParametersCreateInfoExt)
            },
            #[cfg(feature = "VK_EXT_video_decode_h265")]
            x if x == Self::VideoDecodeH265SessionParametersAddInfoExt.bits() => {
                Some(Self::VideoDecodeH265SessionParametersAddInfoExt)
            },
            #[cfg(feature = "VK_EXT_video_decode_h265")]
            x if x == Self::VideoDecodeH265ProfileExt.bits() => Some(Self::VideoDecodeH265ProfileExt),
            #[cfg(feature = "VK_EXT_video_decode_h265")]
            x if x == Self::VideoDecodeH265PictureInfoExt.bits() => Some(Self::VideoDecodeH265PictureInfoExt),
            #[cfg(feature = "VK_EXT_video_decode_h265")]
            x if x == Self::VideoDecodeH265DpbSlotInfoExt.bits() => Some(Self::VideoDecodeH265DpbSlotInfoExt),
            #[cfg(feature = "VK_KHR_global_priority")]
            x if x == Self::DeviceQueueGlobalPriorityCreateInfoKhr.bits() => {
                Some(Self::DeviceQueueGlobalPriorityCreateInfoKhr)
            },
            #[cfg(feature = "VK_KHR_global_priority")]
            x if x == Self::PhysicalDeviceGlobalPriorityQueryFeaturesKhr.bits() => {
                Some(Self::PhysicalDeviceGlobalPriorityQueryFeaturesKhr)
            },
            #[cfg(feature = "VK_KHR_global_priority")]
            x if x == Self::QueueFamilyGlobalPriorityPropertiesKhr.bits() => {
                Some(Self::QueueFamilyGlobalPriorityPropertiesKhr)
            },
            #[cfg(feature = "VK_AMD_memory_overallocation_behavior")]
            x if x == Self::DeviceMemoryOverallocationCreateInfoAmd.bits() => {
                Some(Self::DeviceMemoryOverallocationCreateInfoAmd)
            },
            #[cfg(feature = "VK_EXT_vertex_attribute_divisor")]
            x if x == Self::PhysicalDeviceVertexAttributeDivisorPropertiesExt.bits() => {
                Some(Self::PhysicalDeviceVertexAttributeDivisorPropertiesExt)
            },
            #[cfg(feature = "VK_EXT_vertex_attribute_divisor")]
            x if x == Self::PipelineVertexInputDivisorStateCreateInfoExt.bits() => {
                Some(Self::PipelineVertexInputDivisorStateCreateInfoExt)
            },
            #[cfg(feature = "VK_EXT_vertex_attribute_divisor")]
            x if x == Self::PhysicalDeviceVertexAttributeDivisorFeaturesExt.bits() => {
                Some(Self::PhysicalDeviceVertexAttributeDivisorFeaturesExt)
            },
            #[cfg(feature = "VK_GGP_frame_token")]
            x if x == Self::PresentFrameTokenGgp.bits() => Some(Self::PresentFrameTokenGgp),
            #[cfg(feature = "VK_NV_compute_shader_derivatives")]
            x if x == Self::PhysicalDeviceComputeShaderDerivativesFeaturesNv.bits() => {
                Some(Self::PhysicalDeviceComputeShaderDerivativesFeaturesNv)
            },
            #[cfg(feature = "VK_NV_mesh_shader")]
            x if x == Self::PhysicalDeviceMeshShaderFeaturesNv.bits() => Some(Self::PhysicalDeviceMeshShaderFeaturesNv),
            #[cfg(feature = "VK_NV_mesh_shader")]
            x if x == Self::PhysicalDeviceMeshShaderPropertiesNv.bits() => {
                Some(Self::PhysicalDeviceMeshShaderPropertiesNv)
            },
            #[cfg(feature = "VK_NV_fragment_shader_barycentric")]
            x if x == Self::PhysicalDeviceFragmentShaderBarycentricFeaturesNv.bits() => {
                Some(Self::PhysicalDeviceFragmentShaderBarycentricFeaturesNv)
            },
            #[cfg(feature = "VK_NV_shader_image_footprint")]
            x if x == Self::PhysicalDeviceShaderImageFootprintFeaturesNv.bits() => {
                Some(Self::PhysicalDeviceShaderImageFootprintFeaturesNv)
            },
            #[cfg(feature = "VK_NV_scissor_exclusive")]
            x if x == Self::PipelineViewportExclusiveScissorStateCreateInfoNv.bits() => {
                Some(Self::PipelineViewportExclusiveScissorStateCreateInfoNv)
            },
            #[cfg(feature = "VK_NV_scissor_exclusive")]
            x if x == Self::PhysicalDeviceExclusiveScissorFeaturesNv.bits() => {
                Some(Self::PhysicalDeviceExclusiveScissorFeaturesNv)
            },
            #[cfg(feature = "VK_NV_device_diagnostic_checkpoints")]
            x if x == Self::CheckpointDataNv.bits() => Some(Self::CheckpointDataNv),
            #[cfg(feature = "VK_NV_device_diagnostic_checkpoints")]
            x if x == Self::QueueFamilyCheckpointPropertiesNv.bits() => Some(Self::QueueFamilyCheckpointPropertiesNv),
            #[cfg(feature = "VK_INTEL_shader_integer_functions2")]
            x if x == Self::PhysicalDeviceShaderIntegerFunctions2FeaturesIntel.bits() => {
                Some(Self::PhysicalDeviceShaderIntegerFunctions2FeaturesIntel)
            },
            #[cfg(feature = "VK_INTEL_performance_query")]
            x if x == Self::QueryPoolPerformanceQueryCreateInfoIntel.bits() => {
                Some(Self::QueryPoolPerformanceQueryCreateInfoIntel)
            },
            #[cfg(feature = "VK_INTEL_performance_query")]
            x if x == Self::InitializePerformanceApiInfoIntel.bits() => Some(Self::InitializePerformanceApiInfoIntel),
            #[cfg(feature = "VK_INTEL_performance_query")]
            x if x == Self::PerformanceMarkerInfoIntel.bits() => Some(Self::PerformanceMarkerInfoIntel),
            #[cfg(feature = "VK_INTEL_performance_query")]
            x if x == Self::PerformanceStreamMarkerInfoIntel.bits() => Some(Self::PerformanceStreamMarkerInfoIntel),
            #[cfg(feature = "VK_INTEL_performance_query")]
            x if x == Self::PerformanceOverrideInfoIntel.bits() => Some(Self::PerformanceOverrideInfoIntel),
            #[cfg(feature = "VK_INTEL_performance_query")]
            x if x == Self::PerformanceConfigurationAcquireInfoIntel.bits() => {
                Some(Self::PerformanceConfigurationAcquireInfoIntel)
            },
            #[cfg(feature = "VK_EXT_pci_bus_info")]
            x if x == Self::PhysicalDevicePciBusInfoPropertiesExt.bits() => {
                Some(Self::PhysicalDevicePciBusInfoPropertiesExt)
            },
            #[cfg(feature = "VK_AMD_display_native_hdr")]
            x if x == Self::DisplayNativeHdrSurfaceCapabilitiesAmd.bits() => {
                Some(Self::DisplayNativeHdrSurfaceCapabilitiesAmd)
            },
            #[cfg(feature = "VK_AMD_display_native_hdr")]
            x if x == Self::SwapchainDisplayNativeHdrCreateInfoAmd.bits() => {
                Some(Self::SwapchainDisplayNativeHdrCreateInfoAmd)
            },
            #[cfg(feature = "VK_FUCHSIA_imagepipe_surface")]
            x if x == Self::ImagepipeSurfaceCreateInfoFuchsia.bits() => Some(Self::ImagepipeSurfaceCreateInfoFuchsia),
            #[cfg(feature = "VK_EXT_metal_surface")]
            x if x == Self::MetalSurfaceCreateInfoExt.bits() => Some(Self::MetalSurfaceCreateInfoExt),
            #[cfg(feature = "VK_EXT_fragment_density_map")]
            x if x == Self::PhysicalDeviceFragmentDensityMapFeaturesExt.bits() => {
                Some(Self::PhysicalDeviceFragmentDensityMapFeaturesExt)
            },
            #[cfg(feature = "VK_EXT_fragment_density_map")]
            x if x == Self::PhysicalDeviceFragmentDensityMapPropertiesExt.bits() => {
                Some(Self::PhysicalDeviceFragmentDensityMapPropertiesExt)
            },
            #[cfg(feature = "VK_EXT_fragment_density_map")]
            x if x == Self::RenderPassFragmentDensityMapCreateInfoExt.bits() => {
                Some(Self::RenderPassFragmentDensityMapCreateInfoExt)
            },
            #[cfg(feature = "VK_KHR_fragment_shading_rate")]
            x if x == Self::FragmentShadingRateAttachmentInfoKhr.bits() => {
                Some(Self::FragmentShadingRateAttachmentInfoKhr)
            },
            #[cfg(feature = "VK_KHR_fragment_shading_rate")]
            x if x == Self::PipelineFragmentShadingRateStateCreateInfoKhr.bits() => {
                Some(Self::PipelineFragmentShadingRateStateCreateInfoKhr)
            },
            #[cfg(feature = "VK_KHR_fragment_shading_rate")]
            x if x == Self::PhysicalDeviceFragmentShadingRatePropertiesKhr.bits() => {
                Some(Self::PhysicalDeviceFragmentShadingRatePropertiesKhr)
            },
            #[cfg(feature = "VK_KHR_fragment_shading_rate")]
            x if x == Self::PhysicalDeviceFragmentShadingRateFeaturesKhr.bits() => {
                Some(Self::PhysicalDeviceFragmentShadingRateFeaturesKhr)
            },
            #[cfg(feature = "VK_KHR_fragment_shading_rate")]
            x if x == Self::PhysicalDeviceFragmentShadingRateKhr.bits() => {
                Some(Self::PhysicalDeviceFragmentShadingRateKhr)
            },
            #[cfg(feature = "VK_AMD_shader_core_properties2")]
            x if x == Self::PhysicalDeviceShaderCoreProperties2Amd.bits() => {
                Some(Self::PhysicalDeviceShaderCoreProperties2Amd)
            },
            #[cfg(feature = "VK_AMD_device_coherent_memory")]
            x if x == Self::PhysicalDeviceCoherentMemoryFeaturesAmd.bits() => {
                Some(Self::PhysicalDeviceCoherentMemoryFeaturesAmd)
            },
            #[cfg(feature = "VK_EXT_shader_image_atomic_int64")]
            x if x == Self::PhysicalDeviceShaderImageAtomicInt64FeaturesExt.bits() => {
                Some(Self::PhysicalDeviceShaderImageAtomicInt64FeaturesExt)
            },
            #[cfg(feature = "VK_EXT_memory_budget")]
            x if x == Self::PhysicalDeviceMemoryBudgetPropertiesExt.bits() => {
                Some(Self::PhysicalDeviceMemoryBudgetPropertiesExt)
            },
            #[cfg(feature = "VK_EXT_memory_priority")]
            x if x == Self::PhysicalDeviceMemoryPriorityFeaturesExt.bits() => {
                Some(Self::PhysicalDeviceMemoryPriorityFeaturesExt)
            },
            #[cfg(feature = "VK_EXT_memory_priority")]
            x if x == Self::MemoryPriorityAllocateInfoExt.bits() => Some(Self::MemoryPriorityAllocateInfoExt),
            #[cfg(feature = "VK_KHR_surface_protected_capabilities")]
            x if x == Self::SurfaceProtectedCapabilitiesKhr.bits() => Some(Self::SurfaceProtectedCapabilitiesKhr),
            #[cfg(feature = "VK_NV_dedicated_allocation_image_aliasing")]
            x if x == Self::PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNv.bits() => {
                Some(Self::PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNv)
            },
            #[cfg(feature = "VK_EXT_buffer_device_address")]
            x if x == Self::PhysicalDeviceBufferDeviceAddressFeaturesExt.bits() => {
                Some(Self::PhysicalDeviceBufferDeviceAddressFeaturesExt)
            },
            #[cfg(feature = "VK_EXT_buffer_device_address")]
            x if x == Self::BufferDeviceAddressCreateInfoExt.bits() => Some(Self::BufferDeviceAddressCreateInfoExt),
            #[cfg(feature = "VK_EXT_validation_features")]
            x if x == Self::ValidationFeaturesExt.bits() => Some(Self::ValidationFeaturesExt),
            #[cfg(feature = "VK_KHR_present_wait")]
            x if x == Self::PhysicalDevicePresentWaitFeaturesKhr.bits() => {
                Some(Self::PhysicalDevicePresentWaitFeaturesKhr)
            },
            #[cfg(feature = "VK_NV_cooperative_matrix")]
            x if x == Self::PhysicalDeviceCooperativeMatrixFeaturesNv.bits() => {
                Some(Self::PhysicalDeviceCooperativeMatrixFeaturesNv)
            },
            #[cfg(feature = "VK_NV_cooperative_matrix")]
            x if x == Self::CooperativeMatrixPropertiesNv.bits() => Some(Self::CooperativeMatrixPropertiesNv),
            #[cfg(feature = "VK_NV_cooperative_matrix")]
            x if x == Self::PhysicalDeviceCooperativeMatrixPropertiesNv.bits() => {
                Some(Self::PhysicalDeviceCooperativeMatrixPropertiesNv)
            },
            #[cfg(feature = "VK_NV_coverage_reduction_mode")]
            x if x == Self::PhysicalDeviceCoverageReductionModeFeaturesNv.bits() => {
                Some(Self::PhysicalDeviceCoverageReductionModeFeaturesNv)
            },
            #[cfg(feature = "VK_NV_coverage_reduction_mode")]
            x if x == Self::PipelineCoverageReductionStateCreateInfoNv.bits() => {
                Some(Self::PipelineCoverageReductionStateCreateInfoNv)
            },
            #[cfg(feature = "VK_NV_coverage_reduction_mode")]
            x if x == Self::FramebufferMixedSamplesCombinationNv.bits() => {
                Some(Self::FramebufferMixedSamplesCombinationNv)
            },
            #[cfg(feature = "VK_EXT_fragment_shader_interlock")]
            x if x == Self::PhysicalDeviceFragmentShaderInterlockFeaturesExt.bits() => {
                Some(Self::PhysicalDeviceFragmentShaderInterlockFeaturesExt)
            },
            #[cfg(feature = "VK_EXT_ycbcr_image_arrays")]
            x if x == Self::PhysicalDeviceYcbcrImageArraysFeaturesExt.bits() => {
                Some(Self::PhysicalDeviceYcbcrImageArraysFeaturesExt)
            },
            #[cfg(feature = "VK_EXT_provoking_vertex")]
            x if x == Self::PhysicalDeviceProvokingVertexFeaturesExt.bits() => {
                Some(Self::PhysicalDeviceProvokingVertexFeaturesExt)
            },
            #[cfg(feature = "VK_EXT_provoking_vertex")]
            x if x == Self::PipelineRasterizationProvokingVertexStateCreateInfoExt.bits() => {
                Some(Self::PipelineRasterizationProvokingVertexStateCreateInfoExt)
            },
            #[cfg(feature = "VK_EXT_provoking_vertex")]
            x if x == Self::PhysicalDeviceProvokingVertexPropertiesExt.bits() => {
                Some(Self::PhysicalDeviceProvokingVertexPropertiesExt)
            },
            #[cfg(feature = "VK_EXT_full_screen_exclusive")]
            x if x == Self::SurfaceFullScreenExclusiveInfoExt.bits() => Some(Self::SurfaceFullScreenExclusiveInfoExt),
            #[cfg(feature = "VK_EXT_full_screen_exclusive")]
            x if x == Self::SurfaceCapabilitiesFullScreenExclusiveExt.bits() => {
                Some(Self::SurfaceCapabilitiesFullScreenExclusiveExt)
            },
            #[cfg(feature = "VK_EXT_full_screen_exclusive")]
            x if x == Self::SurfaceFullScreenExclusiveWin32InfoExt.bits() => {
                Some(Self::SurfaceFullScreenExclusiveWin32InfoExt)
            },
            #[cfg(feature = "VK_EXT_headless_surface")]
            x if x == Self::HeadlessSurfaceCreateInfoExt.bits() => Some(Self::HeadlessSurfaceCreateInfoExt),
            #[cfg(feature = "VK_EXT_line_rasterization")]
            x if x == Self::PhysicalDeviceLineRasterizationFeaturesExt.bits() => {
                Some(Self::PhysicalDeviceLineRasterizationFeaturesExt)
            },
            #[cfg(feature = "VK_EXT_line_rasterization")]
            x if x == Self::PipelineRasterizationLineStateCreateInfoExt.bits() => {
                Some(Self::PipelineRasterizationLineStateCreateInfoExt)
            },
            #[cfg(feature = "VK_EXT_line_rasterization")]
            x if x == Self::PhysicalDeviceLineRasterizationPropertiesExt.bits() => {
                Some(Self::PhysicalDeviceLineRasterizationPropertiesExt)
            },
            #[cfg(feature = "VK_EXT_shader_atomic_float")]
            x if x == Self::PhysicalDeviceShaderAtomicFloatFeaturesExt.bits() => {
                Some(Self::PhysicalDeviceShaderAtomicFloatFeaturesExt)
            },
            #[cfg(feature = "VK_EXT_index_type_uint8")]
            x if x == Self::PhysicalDeviceIndexTypeUint8FeaturesExt.bits() => {
                Some(Self::PhysicalDeviceIndexTypeUint8FeaturesExt)
            },
            #[cfg(feature = "VK_EXT_extended_dynamic_state")]
            x if x == Self::PhysicalDeviceExtendedDynamicStateFeaturesExt.bits() => {
                Some(Self::PhysicalDeviceExtendedDynamicStateFeaturesExt)
            },
            #[cfg(feature = "VK_KHR_pipeline_executable_properties")]
            x if x == Self::PhysicalDevicePipelineExecutablePropertiesFeaturesKhr.bits() => {
                Some(Self::PhysicalDevicePipelineExecutablePropertiesFeaturesKhr)
            },
            #[cfg(feature = "VK_KHR_pipeline_executable_properties")]
            x if x == Self::PipelineInfoKhr.bits() => Some(Self::PipelineInfoKhr),
            #[cfg(feature = "VK_KHR_pipeline_executable_properties")]
            x if x == Self::PipelineExecutablePropertiesKhr.bits() => Some(Self::PipelineExecutablePropertiesKhr),
            #[cfg(feature = "VK_KHR_pipeline_executable_properties")]
            x if x == Self::PipelineExecutableInfoKhr.bits() => Some(Self::PipelineExecutableInfoKhr),
            #[cfg(feature = "VK_KHR_pipeline_executable_properties")]
            x if x == Self::PipelineExecutableStatisticKhr.bits() => Some(Self::PipelineExecutableStatisticKhr),
            #[cfg(feature = "VK_KHR_pipeline_executable_properties")]
            x if x == Self::PipelineExecutableInternalRepresentationKhr.bits() => {
                Some(Self::PipelineExecutableInternalRepresentationKhr)
            },
            #[cfg(feature = "VK_EXT_shader_atomic_float2")]
            x if x == Self::PhysicalDeviceShaderAtomicFloat2FeaturesExt.bits() => {
                Some(Self::PhysicalDeviceShaderAtomicFloat2FeaturesExt)
            },
            #[cfg(feature = "VK_NV_device_generated_commands")]
            x if x == Self::PhysicalDeviceDeviceGeneratedCommandsPropertiesNv.bits() => {
                Some(Self::PhysicalDeviceDeviceGeneratedCommandsPropertiesNv)
            },
            #[cfg(feature = "VK_NV_device_generated_commands")]
            x if x == Self::GraphicsShaderGroupCreateInfoNv.bits() => Some(Self::GraphicsShaderGroupCreateInfoNv),
            #[cfg(feature = "VK_NV_device_generated_commands")]
            x if x == Self::GraphicsPipelineShaderGroupsCreateInfoNv.bits() => {
                Some(Self::GraphicsPipelineShaderGroupsCreateInfoNv)
            },
            #[cfg(feature = "VK_NV_device_generated_commands")]
            x if x == Self::IndirectCommandsLayoutTokenNv.bits() => Some(Self::IndirectCommandsLayoutTokenNv),
            #[cfg(feature = "VK_NV_device_generated_commands")]
            x if x == Self::IndirectCommandsLayoutCreateInfoNv.bits() => Some(Self::IndirectCommandsLayoutCreateInfoNv),
            #[cfg(feature = "VK_NV_device_generated_commands")]
            x if x == Self::GeneratedCommandsInfoNv.bits() => Some(Self::GeneratedCommandsInfoNv),
            #[cfg(feature = "VK_NV_device_generated_commands")]
            x if x == Self::GeneratedCommandsMemoryRequirementsInfoNv.bits() => {
                Some(Self::GeneratedCommandsMemoryRequirementsInfoNv)
            },
            #[cfg(feature = "VK_NV_device_generated_commands")]
            x if x == Self::PhysicalDeviceDeviceGeneratedCommandsFeaturesNv.bits() => {
                Some(Self::PhysicalDeviceDeviceGeneratedCommandsFeaturesNv)
            },
            #[cfg(feature = "VK_NV_inherited_viewport_scissor")]
            x if x == Self::PhysicalDeviceInheritedViewportScissorFeaturesNv.bits() => {
                Some(Self::PhysicalDeviceInheritedViewportScissorFeaturesNv)
            },
            #[cfg(feature = "VK_NV_inherited_viewport_scissor")]
            x if x == Self::CommandBufferInheritanceViewportScissorInfoNv.bits() => {
                Some(Self::CommandBufferInheritanceViewportScissorInfoNv)
            },
            #[cfg(feature = "VK_EXT_texel_buffer_alignment")]
            x if x == Self::PhysicalDeviceTexelBufferAlignmentFeaturesExt.bits() => {
                Some(Self::PhysicalDeviceTexelBufferAlignmentFeaturesExt)
            },
            #[cfg(feature = "VK_QCOM_render_pass_transform")]
            x if x == Self::CommandBufferInheritanceRenderPassTransformInfoQcom.bits() => {
                Some(Self::CommandBufferInheritanceRenderPassTransformInfoQcom)
            },
            #[cfg(feature = "VK_QCOM_render_pass_transform")]
            x if x == Self::RenderPassTransformBeginInfoQcom.bits() => Some(Self::RenderPassTransformBeginInfoQcom),
            #[cfg(feature = "VK_EXT_device_memory_report")]
            x if x == Self::PhysicalDeviceDeviceMemoryReportFeaturesExt.bits() => {
                Some(Self::PhysicalDeviceDeviceMemoryReportFeaturesExt)
            },
            #[cfg(feature = "VK_EXT_device_memory_report")]
            x if x == Self::DeviceDeviceMemoryReportCreateInfoExt.bits() => {
                Some(Self::DeviceDeviceMemoryReportCreateInfoExt)
            },
            #[cfg(feature = "VK_EXT_device_memory_report")]
            x if x == Self::DeviceMemoryReportCallbackDataExt.bits() => Some(Self::DeviceMemoryReportCallbackDataExt),
            #[cfg(feature = "VK_EXT_robustness2")]
            x if x == Self::PhysicalDeviceRobustness2FeaturesExt.bits() => {
                Some(Self::PhysicalDeviceRobustness2FeaturesExt)
            },
            #[cfg(feature = "VK_EXT_robustness2")]
            x if x == Self::PhysicalDeviceRobustness2PropertiesExt.bits() => {
                Some(Self::PhysicalDeviceRobustness2PropertiesExt)
            },
            #[cfg(feature = "VK_EXT_custom_border_color")]
            x if x == Self::SamplerCustomBorderColorCreateInfoExt.bits() => {
                Some(Self::SamplerCustomBorderColorCreateInfoExt)
            },
            #[cfg(feature = "VK_EXT_custom_border_color")]
            x if x == Self::PhysicalDeviceCustomBorderColorPropertiesExt.bits() => {
                Some(Self::PhysicalDeviceCustomBorderColorPropertiesExt)
            },
            #[cfg(feature = "VK_EXT_custom_border_color")]
            x if x == Self::PhysicalDeviceCustomBorderColorFeaturesExt.bits() => {
                Some(Self::PhysicalDeviceCustomBorderColorFeaturesExt)
            },
            #[cfg(feature = "VK_KHR_pipeline_library")]
            x if x == Self::PipelineLibraryCreateInfoKhr.bits() => Some(Self::PipelineLibraryCreateInfoKhr),
            #[cfg(feature = "VK_KHR_present_id")]
            x if x == Self::PresentIdKhr.bits() => Some(Self::PresentIdKhr),
            #[cfg(feature = "VK_KHR_present_id")]
            x if x == Self::PhysicalDevicePresentIdFeaturesKhr.bits() => Some(Self::PhysicalDevicePresentIdFeaturesKhr),
            #[cfg(feature = "VK_KHR_video_encode_queue")]
            x if x == Self::VideoEncodeInfoKhr.bits() => Some(Self::VideoEncodeInfoKhr),
            #[cfg(feature = "VK_KHR_video_encode_queue")]
            x if x == Self::VideoEncodeRateControlInfoKhr.bits() => Some(Self::VideoEncodeRateControlInfoKhr),
            #[cfg(feature = "VK_KHR_video_encode_queue")]
            x if x == Self::VideoEncodeRateControlLayerInfoKhr.bits() => Some(Self::VideoEncodeRateControlLayerInfoKhr),
            #[cfg(feature = "VK_KHR_video_encode_queue")]
            x if x == Self::VideoEncodeCapabilitiesKhr.bits() => Some(Self::VideoEncodeCapabilitiesKhr),
            #[cfg(feature = "VK_NV_device_diagnostics_config")]
            x if x == Self::PhysicalDeviceDiagnosticsConfigFeaturesNv.bits() => {
                Some(Self::PhysicalDeviceDiagnosticsConfigFeaturesNv)
            },
            #[cfg(feature = "VK_NV_device_diagnostics_config")]
            x if x == Self::DeviceDiagnosticsConfigCreateInfoNv.bits() => {
                Some(Self::DeviceDiagnosticsConfigCreateInfoNv)
            },
            #[cfg(feature = "VK_QCOM_extension_310")]
            x if x == Self::ReservedQcom.bits() => Some(Self::ReservedQcom),
            #[cfg(feature = "VK_KHR_synchronization2")]
            x if x == Self::QueueFamilyCheckpointProperties2Nv.bits() => Some(Self::QueueFamilyCheckpointProperties2Nv),
            #[cfg(feature = "VK_KHR_synchronization2")]
            x if x == Self::CheckpointData2Nv.bits() => Some(Self::CheckpointData2Nv),
            #[cfg(feature = "VK_KHR_shader_subgroup_uniform_control_flow")]
            x if x == Self::PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKhr.bits() => {
                Some(Self::PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKhr)
            },
            #[cfg(feature = "VK_NV_fragment_shading_rate_enums")]
            x if x == Self::PhysicalDeviceFragmentShadingRateEnumsPropertiesNv.bits() => {
                Some(Self::PhysicalDeviceFragmentShadingRateEnumsPropertiesNv)
            },
            #[cfg(feature = "VK_NV_fragment_shading_rate_enums")]
            x if x == Self::PhysicalDeviceFragmentShadingRateEnumsFeaturesNv.bits() => {
                Some(Self::PhysicalDeviceFragmentShadingRateEnumsFeaturesNv)
            },
            #[cfg(feature = "VK_NV_fragment_shading_rate_enums")]
            x if x == Self::PipelineFragmentShadingRateEnumStateCreateInfoNv.bits() => {
                Some(Self::PipelineFragmentShadingRateEnumStateCreateInfoNv)
            },
            #[cfg(feature = "VK_NV_ray_tracing_motion_blur")]
            x if x == Self::AccelerationStructureGeometryMotionTrianglesDataNv.bits() => {
                Some(Self::AccelerationStructureGeometryMotionTrianglesDataNv)
            },
            #[cfg(feature = "VK_NV_ray_tracing_motion_blur")]
            x if x == Self::PhysicalDeviceRayTracingMotionBlurFeaturesNv.bits() => {
                Some(Self::PhysicalDeviceRayTracingMotionBlurFeaturesNv)
            },
            #[cfg(feature = "VK_NV_ray_tracing_motion_blur")]
            x if x == Self::AccelerationStructureMotionInfoNv.bits() => Some(Self::AccelerationStructureMotionInfoNv),
            #[cfg(feature = "VK_EXT_ycbcr_2plane_444_formats")]
            x if x == Self::PhysicalDeviceYcbcr2Plane444FormatsFeaturesExt.bits() => {
                Some(Self::PhysicalDeviceYcbcr2Plane444FormatsFeaturesExt)
            },
            #[cfg(feature = "VK_EXT_fragment_density_map2")]
            x if x == Self::PhysicalDeviceFragmentDensityMap2FeaturesExt.bits() => {
                Some(Self::PhysicalDeviceFragmentDensityMap2FeaturesExt)
            },
            #[cfg(feature = "VK_EXT_fragment_density_map2")]
            x if x == Self::PhysicalDeviceFragmentDensityMap2PropertiesExt.bits() => {
                Some(Self::PhysicalDeviceFragmentDensityMap2PropertiesExt)
            },
            #[cfg(feature = "VK_QCOM_rotated_copy_commands")]
            x if x == Self::CopyCommandTransformInfoQcom.bits() => Some(Self::CopyCommandTransformInfoQcom),
            #[cfg(feature = "VK_KHR_workgroup_memory_explicit_layout")]
            x if x == Self::PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKhr.bits() => {
                Some(Self::PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKhr)
            },
            #[cfg(feature = "VK_EXT_4444_formats")]
            x if x == Self::PhysicalDevice4444FormatsFeaturesExt.bits() => {
                Some(Self::PhysicalDevice4444FormatsFeaturesExt)
            },
            #[cfg(feature = "VK_ARM_rasterization_order_attachment_access")]
            x if x == Self::PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesArm.bits() => {
                Some(Self::PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesArm)
            },
            #[cfg(feature = "VK_EXT_rgba10x6_formats")]
            x if x == Self::PhysicalDeviceRgba10x6FormatsFeaturesExt.bits() => {
                Some(Self::PhysicalDeviceRgba10x6FormatsFeaturesExt)
            },
            #[cfg(feature = "VK_EXT_directfb_surface")]
            x if x == Self::DirectfbSurfaceCreateInfoExt.bits() => Some(Self::DirectfbSurfaceCreateInfoExt),
            #[cfg(feature = "VK_VALVE_mutable_descriptor_type")]
            x if x == Self::PhysicalDeviceMutableDescriptorTypeFeaturesValve.bits() => {
                Some(Self::PhysicalDeviceMutableDescriptorTypeFeaturesValve)
            },
            #[cfg(feature = "VK_VALVE_mutable_descriptor_type")]
            x if x == Self::MutableDescriptorTypeCreateInfoValve.bits() => {
                Some(Self::MutableDescriptorTypeCreateInfoValve)
            },
            #[cfg(feature = "VK_EXT_vertex_input_dynamic_state")]
            x if x == Self::PhysicalDeviceVertexInputDynamicStateFeaturesExt.bits() => {
                Some(Self::PhysicalDeviceVertexInputDynamicStateFeaturesExt)
            },
            #[cfg(feature = "VK_EXT_vertex_input_dynamic_state")]
            x if x == Self::VertexInputBindingDescription2Ext.bits() => Some(Self::VertexInputBindingDescription2Ext),
            #[cfg(feature = "VK_EXT_vertex_input_dynamic_state")]
            x if x == Self::VertexInputAttributeDescription2Ext.bits() => {
                Some(Self::VertexInputAttributeDescription2Ext)
            },
            #[cfg(feature = "VK_EXT_physical_device_drm")]
            x if x == Self::PhysicalDeviceDrmPropertiesExt.bits() => Some(Self::PhysicalDeviceDrmPropertiesExt),
            #[cfg(feature = "VK_EXT_depth_clip_control")]
            x if x == Self::PhysicalDeviceDepthClipControlFeaturesExt.bits() => {
                Some(Self::PhysicalDeviceDepthClipControlFeaturesExt)
            },
            #[cfg(feature = "VK_EXT_depth_clip_control")]
            x if x == Self::PipelineViewportDepthClipControlCreateInfoExt.bits() => {
                Some(Self::PipelineViewportDepthClipControlCreateInfoExt)
            },
            #[cfg(feature = "VK_EXT_primitive_topology_list_restart")]
            x if x == Self::PhysicalDevicePrimitiveTopologyListRestartFeaturesExt.bits() => {
                Some(Self::PhysicalDevicePrimitiveTopologyListRestartFeaturesExt)
            },
            #[cfg(feature = "VK_FUCHSIA_external_memory")]
            x if x == Self::ImportMemoryZirconHandleInfoFuchsia.bits() => {
                Some(Self::ImportMemoryZirconHandleInfoFuchsia)
            },
            #[cfg(feature = "VK_FUCHSIA_external_memory")]
            x if x == Self::MemoryZirconHandlePropertiesFuchsia.bits() => {
                Some(Self::MemoryZirconHandlePropertiesFuchsia)
            },
            #[cfg(feature = "VK_FUCHSIA_external_memory")]
            x if x == Self::MemoryGetZirconHandleInfoFuchsia.bits() => Some(Self::MemoryGetZirconHandleInfoFuchsia),
            #[cfg(feature = "VK_FUCHSIA_external_semaphore")]
            x if x == Self::ImportSemaphoreZirconHandleInfoFuchsia.bits() => {
                Some(Self::ImportSemaphoreZirconHandleInfoFuchsia)
            },
            #[cfg(feature = "VK_FUCHSIA_external_semaphore")]
            x if x == Self::SemaphoreGetZirconHandleInfoFuchsia.bits() => {
                Some(Self::SemaphoreGetZirconHandleInfoFuchsia)
            },
            #[cfg(feature = "VK_FUCHSIA_buffer_collection")]
            x if x == Self::BufferCollectionCreateInfoFuchsia.bits() => Some(Self::BufferCollectionCreateInfoFuchsia),
            #[cfg(feature = "VK_FUCHSIA_buffer_collection")]
            x if x == Self::ImportMemoryBufferCollectionFuchsia.bits() => {
                Some(Self::ImportMemoryBufferCollectionFuchsia)
            },
            #[cfg(feature = "VK_FUCHSIA_buffer_collection")]
            x if x == Self::BufferCollectionImageCreateInfoFuchsia.bits() => {
                Some(Self::BufferCollectionImageCreateInfoFuchsia)
            },
            #[cfg(feature = "VK_FUCHSIA_buffer_collection")]
            x if x == Self::BufferCollectionPropertiesFuchsia.bits() => Some(Self::BufferCollectionPropertiesFuchsia),
            #[cfg(feature = "VK_FUCHSIA_buffer_collection")]
            x if x == Self::BufferConstraintsInfoFuchsia.bits() => Some(Self::BufferConstraintsInfoFuchsia),
            #[cfg(feature = "VK_FUCHSIA_buffer_collection")]
            x if x == Self::BufferCollectionBufferCreateInfoFuchsia.bits() => {
                Some(Self::BufferCollectionBufferCreateInfoFuchsia)
            },
            #[cfg(feature = "VK_FUCHSIA_buffer_collection")]
            x if x == Self::ImageConstraintsInfoFuchsia.bits() => Some(Self::ImageConstraintsInfoFuchsia),
            #[cfg(feature = "VK_FUCHSIA_buffer_collection")]
            x if x == Self::ImageFormatConstraintsInfoFuchsia.bits() => Some(Self::ImageFormatConstraintsInfoFuchsia),
            #[cfg(feature = "VK_FUCHSIA_buffer_collection")]
            x if x == Self::SysmemColorSpaceFuchsia.bits() => Some(Self::SysmemColorSpaceFuchsia),
            #[cfg(feature = "VK_FUCHSIA_buffer_collection")]
            x if x == Self::BufferCollectionConstraintsInfoFuchsia.bits() => {
                Some(Self::BufferCollectionConstraintsInfoFuchsia)
            },
            #[cfg(feature = "VK_HUAWEI_subpass_shading")]
            x if x == Self::SubpassShadingPipelineCreateInfoHuawei.bits() => {
                Some(Self::SubpassShadingPipelineCreateInfoHuawei)
            },
            #[cfg(feature = "VK_HUAWEI_subpass_shading")]
            x if x == Self::PhysicalDeviceSubpassShadingFeaturesHuawei.bits() => {
                Some(Self::PhysicalDeviceSubpassShadingFeaturesHuawei)
            },
            #[cfg(feature = "VK_HUAWEI_subpass_shading")]
            x if x == Self::PhysicalDeviceSubpassShadingPropertiesHuawei.bits() => {
                Some(Self::PhysicalDeviceSubpassShadingPropertiesHuawei)
            },
            #[cfg(feature = "VK_HUAWEI_invocation_mask")]
            x if x == Self::PhysicalDeviceInvocationMaskFeaturesHuawei.bits() => {
                Some(Self::PhysicalDeviceInvocationMaskFeaturesHuawei)
            },
            #[cfg(feature = "VK_NV_external_memory_rdma")]
            x if x == Self::MemoryGetRemoteAddressInfoNv.bits() => Some(Self::MemoryGetRemoteAddressInfoNv),
            #[cfg(feature = "VK_NV_external_memory_rdma")]
            x if x == Self::PhysicalDeviceExternalMemoryRdmaFeaturesNv.bits() => {
                Some(Self::PhysicalDeviceExternalMemoryRdmaFeaturesNv)
            },
            #[cfg(feature = "VK_EXT_extended_dynamic_state2")]
            x if x == Self::PhysicalDeviceExtendedDynamicState2FeaturesExt.bits() => {
                Some(Self::PhysicalDeviceExtendedDynamicState2FeaturesExt)
            },
            #[cfg(feature = "VK_QNX_screen_surface")]
            x if x == Self::ScreenSurfaceCreateInfoQnx.bits() => Some(Self::ScreenSurfaceCreateInfoQnx),
            #[cfg(feature = "VK_EXT_color_write_enable")]
            x if x == Self::PhysicalDeviceColorWriteEnableFeaturesExt.bits() => {
                Some(Self::PhysicalDeviceColorWriteEnableFeaturesExt)
            },
            #[cfg(feature = "VK_EXT_color_write_enable")]
            x if x == Self::PipelineColorWriteCreateInfoExt.bits() => Some(Self::PipelineColorWriteCreateInfoExt),
            #[cfg(feature = "VK_EXT_image_view_min_lod")]
            x if x == Self::PhysicalDeviceImageViewMinLodFeaturesExt.bits() => {
                Some(Self::PhysicalDeviceImageViewMinLodFeaturesExt)
            },
            #[cfg(feature = "VK_EXT_image_view_min_lod")]
            x if x == Self::ImageViewMinLodCreateInfoExt.bits() => Some(Self::ImageViewMinLodCreateInfoExt),
            #[cfg(feature = "VK_EXT_multi_draw")]
            x if x == Self::PhysicalDeviceMultiDrawFeaturesExt.bits() => Some(Self::PhysicalDeviceMultiDrawFeaturesExt),
            #[cfg(feature = "VK_EXT_multi_draw")]
            x if x == Self::PhysicalDeviceMultiDrawPropertiesExt.bits() => {
                Some(Self::PhysicalDeviceMultiDrawPropertiesExt)
            },
            #[cfg(feature = "VK_EXT_border_color_swizzle")]
            x if x == Self::PhysicalDeviceBorderColorSwizzleFeaturesExt.bits() => {
                Some(Self::PhysicalDeviceBorderColorSwizzleFeaturesExt)
            },
            #[cfg(feature = "VK_EXT_border_color_swizzle")]
            x if x == Self::SamplerBorderColorComponentMappingCreateInfoExt.bits() => {
                Some(Self::SamplerBorderColorComponentMappingCreateInfoExt)
            },
            #[cfg(feature = "VK_EXT_pageable_device_local_memory")]
            x if x == Self::PhysicalDevicePageableDeviceLocalMemoryFeaturesExt.bits() => {
                Some(Self::PhysicalDevicePageableDeviceLocalMemoryFeaturesExt)
            },
            #[cfg(feature = "VK_VALVE_descriptor_set_host_mapping")]
            x if x == Self::PhysicalDeviceDescriptorSetHostMappingFeaturesValve.bits() => {
                Some(Self::PhysicalDeviceDescriptorSetHostMappingFeaturesValve)
            },
            #[cfg(feature = "VK_VALVE_descriptor_set_host_mapping")]
            x if x == Self::DescriptorSetBindingReferenceValve.bits() => Some(Self::DescriptorSetBindingReferenceValve),
            #[cfg(feature = "VK_VALVE_descriptor_set_host_mapping")]
            x if x == Self::DescriptorSetLayoutHostMappingInfoValve.bits() => {
                Some(Self::DescriptorSetLayoutHostMappingInfoValve)
            },
            #[cfg(feature = "VK_QCOM_fragment_density_map_offset")]
            x if x == Self::PhysicalDeviceFragmentDensityMapOffsetFeaturesQcom.bits() => {
                Some(Self::PhysicalDeviceFragmentDensityMapOffsetFeaturesQcom)
            },
            #[cfg(feature = "VK_QCOM_fragment_density_map_offset")]
            x if x == Self::PhysicalDeviceFragmentDensityMapOffsetPropertiesQcom.bits() => {
                Some(Self::PhysicalDeviceFragmentDensityMapOffsetPropertiesQcom)
            },
            #[cfg(feature = "VK_QCOM_fragment_density_map_offset")]
            x if x == Self::SubpassFragmentDensityMapOffsetEndInfoQcom.bits() => {
                Some(Self::SubpassFragmentDensityMapOffsetEndInfoQcom)
            },
            #[cfg(feature = "VK_NV_linear_color_attachment")]
            x if x == Self::PhysicalDeviceLinearColorAttachmentFeaturesNv.bits() => {
                Some(Self::PhysicalDeviceLinearColorAttachmentFeaturesNv)
            },
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: i32) -> Self {
        std::mem::transmute(bits)
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for StructureType {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for StructureType {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkSubpassContents")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub enum SubpassContents {
    #[doc(alias = "VK_SUBPASS_CONTENTS_INLINE")]
    Inline = 0,
    #[doc(alias = "VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS")]
    SecondaryCommandBuffers = 1,
}
impl Default for SubpassContents {
    #[inline]
    fn default() -> Self {
        Self::empty()
    }
}
impl SubpassContents {
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        unsafe { Self::from_bits_unchecked(0) }
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> i32 {
        *self as i32
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: i32) -> Option<Self> {
        match bits {
            x if x == Self::Inline.bits() => Some(Self::Inline),
            x if x == Self::SecondaryCommandBuffers.bits() => Some(Self::SecondaryCommandBuffers),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: i32) -> Self {
        std::mem::transmute(bits)
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for SubpassContents {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for SubpassContents {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkResult")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub enum VulkanResultCodes {
    #[doc(alias = "VK_SUCCESS")]
    Success = 0,
    #[doc(alias = "VK_NOT_READY")]
    NotReady = 1,
    #[doc(alias = "VK_TIMEOUT")]
    Timeout = 2,
    #[doc(alias = "VK_EVENT_SET")]
    EventSet = 3,
    #[doc(alias = "VK_EVENT_RESET")]
    EventReset = 4,
    #[doc(alias = "VK_INCOMPLETE")]
    Incomplete = 5,
    #[doc(alias = "VK_ERROR_OUT_OF_HOST_MEMORY")]
    ErrorOutOfHostMemory = -1,
    #[doc(alias = "VK_ERROR_OUT_OF_DEVICE_MEMORY")]
    ErrorOutOfDeviceMemory = -2,
    #[doc(alias = "VK_ERROR_INITIALIZATION_FAILED")]
    ErrorInitializationFailed = -3,
    #[doc(alias = "VK_ERROR_DEVICE_LOST")]
    ErrorDeviceLost = -4,
    #[doc(alias = "VK_ERROR_MEMORY_MAP_FAILED")]
    ErrorMemoryMapFailed = -5,
    #[doc(alias = "VK_ERROR_LAYER_NOT_PRESENT")]
    ErrorLayerNotPresent = -6,
    #[doc(alias = "VK_ERROR_EXTENSION_NOT_PRESENT")]
    ErrorExtensionNotPresent = -7,
    #[doc(alias = "VK_ERROR_FEATURE_NOT_PRESENT")]
    ErrorFeatureNotPresent = -8,
    #[doc(alias = "VK_ERROR_INCOMPATIBLE_DRIVER")]
    ErrorIncompatibleDriver = -9,
    #[doc(alias = "VK_ERROR_TOO_MANY_OBJECTS")]
    ErrorTooManyObjects = -10,
    #[doc(alias = "VK_ERROR_FORMAT_NOT_SUPPORTED")]
    ErrorFormatNotSupported = -11,
    #[doc(alias = "VK_ERROR_FRAGMENTED_POOL")]
    ErrorFragmentedPool = -12,
    #[doc(alias = "VK_ERROR_UNKNOWN")]
    ErrorUnknown = -13,
    #[doc(alias = "VK_ERROR_OUT_OF_POOL_MEMORY")]
    #[doc(alias = "VK_ERROR_OUT_OF_POOL_MEMORY_KHR")]
    ErrorOutOfPoolMemory = -1000069000,
    #[doc(alias = "VK_ERROR_INVALID_EXTERNAL_HANDLE")]
    #[doc(alias = "VK_ERROR_INVALID_EXTERNAL_HANDLE_KHR")]
    ErrorInvalidExternalHandle = -1000072003,
    #[doc(alias = "VK_ERROR_FRAGMENTATION")]
    #[doc(alias = "VK_ERROR_FRAGMENTATION_EXT")]
    #[cfg(feature = "VULKAN_1_2")]
    ErrorFragmentation = -1000161000,
    #[doc(alias = "VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS")]
    #[doc(alias = "VK_ERROR_INVALID_DEVICE_ADDRESS_EXT")]
    #[doc(alias = "VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS_KHR")]
    #[cfg(feature = "VULKAN_1_2")]
    ErrorInvalidOpaqueCaptureAddress = -1000257000,
    #[doc(alias = "VK_PIPELINE_COMPILE_REQUIRED")]
    #[doc(alias = "VK_PIPELINE_COMPILE_REQUIRED_EXT")]
    #[doc(alias = "VK_ERROR_PIPELINE_COMPILE_REQUIRED_EXT")]
    #[cfg(feature = "VULKAN_1_3")]
    PipelineCompileRequired = 1000297000,
    #[doc(alias = "VK_ERROR_SURFACE_LOST_KHR")]
    #[cfg(feature = "VK_KHR_surface")]
    ErrorSurfaceLostKhr = -1000000000,
    #[doc(alias = "VK_ERROR_NATIVE_WINDOW_IN_USE_KHR")]
    #[cfg(feature = "VK_KHR_surface")]
    ErrorNativeWindowInUseKhr = -1000000001,
    #[doc(alias = "VK_SUBOPTIMAL_KHR")]
    #[cfg(feature = "VK_KHR_swapchain")]
    SuboptimalKhr = 1000001003,
    #[doc(alias = "VK_ERROR_OUT_OF_DATE_KHR")]
    #[cfg(feature = "VK_KHR_swapchain")]
    ErrorOutOfDateKhr = -1000001004,
    #[doc(alias = "VK_ERROR_INCOMPATIBLE_DISPLAY_KHR")]
    #[cfg(feature = "VK_KHR_display_swapchain")]
    ErrorIncompatibleDisplayKhr = -1000003001,
    #[doc(alias = "VK_ERROR_VALIDATION_FAILED_EXT")]
    #[cfg(feature = "VK_EXT_debug_report")]
    ErrorValidationFailedExt = -1000011001,
    #[doc(alias = "VK_ERROR_INVALID_SHADER_NV")]
    #[cfg(feature = "VK_NV_glsl_shader")]
    ErrorInvalidShaderNv = -1000012000,
    #[doc(alias = "VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT")]
    #[cfg(feature = "VK_EXT_image_drm_format_modifier")]
    ErrorInvalidDrmFormatModifierPlaneLayoutExt = -1000158000,
    #[doc(alias = "VK_ERROR_NOT_PERMITTED_KHR")]
    #[doc(alias = "VK_ERROR_NOT_PERMITTED_EXT")]
    #[cfg(feature = "VK_KHR_global_priority")]
    ErrorNotPermittedKhr = -1000174001,
    #[doc(alias = "VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT")]
    #[cfg(feature = "VK_EXT_full_screen_exclusive")]
    ErrorFullScreenExclusiveModeLostExt = -1000255000,
    #[doc(alias = "VK_THREAD_IDLE_KHR")]
    #[cfg(feature = "VK_KHR_deferred_host_operations")]
    ThreadIdleKhr = 1000268000,
    #[doc(alias = "VK_THREAD_DONE_KHR")]
    #[cfg(feature = "VK_KHR_deferred_host_operations")]
    ThreadDoneKhr = 1000268001,
    #[doc(alias = "VK_OPERATION_DEFERRED_KHR")]
    #[cfg(feature = "VK_KHR_deferred_host_operations")]
    OperationDeferredKhr = 1000268002,
    #[doc(alias = "VK_OPERATION_NOT_DEFERRED_KHR")]
    #[cfg(feature = "VK_KHR_deferred_host_operations")]
    OperationNotDeferredKhr = 1000268003,
}
impl Default for VulkanResultCodes {
    #[inline]
    fn default() -> Self {
        Self::empty()
    }
}
impl VulkanResultCodes {
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        unsafe { Self::from_bits_unchecked(0) }
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> i32 {
        *self as i32
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: i32) -> Option<Self> {
        match bits {
            x if x == Self::Success.bits() => Some(Self::Success),
            x if x == Self::NotReady.bits() => Some(Self::NotReady),
            x if x == Self::Timeout.bits() => Some(Self::Timeout),
            x if x == Self::EventSet.bits() => Some(Self::EventSet),
            x if x == Self::EventReset.bits() => Some(Self::EventReset),
            x if x == Self::Incomplete.bits() => Some(Self::Incomplete),
            x if x == Self::ErrorOutOfHostMemory.bits() => Some(Self::ErrorOutOfHostMemory),
            x if x == Self::ErrorOutOfDeviceMemory.bits() => Some(Self::ErrorOutOfDeviceMemory),
            x if x == Self::ErrorInitializationFailed.bits() => Some(Self::ErrorInitializationFailed),
            x if x == Self::ErrorDeviceLost.bits() => Some(Self::ErrorDeviceLost),
            x if x == Self::ErrorMemoryMapFailed.bits() => Some(Self::ErrorMemoryMapFailed),
            x if x == Self::ErrorLayerNotPresent.bits() => Some(Self::ErrorLayerNotPresent),
            x if x == Self::ErrorExtensionNotPresent.bits() => Some(Self::ErrorExtensionNotPresent),
            x if x == Self::ErrorFeatureNotPresent.bits() => Some(Self::ErrorFeatureNotPresent),
            x if x == Self::ErrorIncompatibleDriver.bits() => Some(Self::ErrorIncompatibleDriver),
            x if x == Self::ErrorTooManyObjects.bits() => Some(Self::ErrorTooManyObjects),
            x if x == Self::ErrorFormatNotSupported.bits() => Some(Self::ErrorFormatNotSupported),
            x if x == Self::ErrorFragmentedPool.bits() => Some(Self::ErrorFragmentedPool),
            x if x == Self::ErrorUnknown.bits() => Some(Self::ErrorUnknown),
            x if x == Self::ErrorOutOfPoolMemory.bits() => Some(Self::ErrorOutOfPoolMemory),
            x if x == Self::ErrorInvalidExternalHandle.bits() => Some(Self::ErrorInvalidExternalHandle),
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::ErrorFragmentation.bits() => Some(Self::ErrorFragmentation),
            #[cfg(feature = "VULKAN_1_2")]
            x if x == Self::ErrorInvalidOpaqueCaptureAddress.bits() => Some(Self::ErrorInvalidOpaqueCaptureAddress),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::PipelineCompileRequired.bits() => Some(Self::PipelineCompileRequired),
            #[cfg(feature = "VK_KHR_surface")]
            x if x == Self::ErrorSurfaceLostKhr.bits() => Some(Self::ErrorSurfaceLostKhr),
            #[cfg(feature = "VK_KHR_surface")]
            x if x == Self::ErrorNativeWindowInUseKhr.bits() => Some(Self::ErrorNativeWindowInUseKhr),
            #[cfg(feature = "VK_KHR_swapchain")]
            x if x == Self::SuboptimalKhr.bits() => Some(Self::SuboptimalKhr),
            #[cfg(feature = "VK_KHR_swapchain")]
            x if x == Self::ErrorOutOfDateKhr.bits() => Some(Self::ErrorOutOfDateKhr),
            #[cfg(feature = "VK_KHR_display_swapchain")]
            x if x == Self::ErrorIncompatibleDisplayKhr.bits() => Some(Self::ErrorIncompatibleDisplayKhr),
            #[cfg(feature = "VK_EXT_debug_report")]
            x if x == Self::ErrorValidationFailedExt.bits() => Some(Self::ErrorValidationFailedExt),
            #[cfg(feature = "VK_NV_glsl_shader")]
            x if x == Self::ErrorInvalidShaderNv.bits() => Some(Self::ErrorInvalidShaderNv),
            #[cfg(feature = "VK_EXT_image_drm_format_modifier")]
            x if x == Self::ErrorInvalidDrmFormatModifierPlaneLayoutExt.bits() => {
                Some(Self::ErrorInvalidDrmFormatModifierPlaneLayoutExt)
            },
            #[cfg(feature = "VK_KHR_global_priority")]
            x if x == Self::ErrorNotPermittedKhr.bits() => Some(Self::ErrorNotPermittedKhr),
            #[cfg(feature = "VK_EXT_full_screen_exclusive")]
            x if x == Self::ErrorFullScreenExclusiveModeLostExt.bits() => {
                Some(Self::ErrorFullScreenExclusiveModeLostExt)
            },
            #[cfg(feature = "VK_KHR_deferred_host_operations")]
            x if x == Self::ThreadIdleKhr.bits() => Some(Self::ThreadIdleKhr),
            #[cfg(feature = "VK_KHR_deferred_host_operations")]
            x if x == Self::ThreadDoneKhr.bits() => Some(Self::ThreadDoneKhr),
            #[cfg(feature = "VK_KHR_deferred_host_operations")]
            x if x == Self::OperationDeferredKhr.bits() => Some(Self::OperationDeferredKhr),
            #[cfg(feature = "VK_KHR_deferred_host_operations")]
            x if x == Self::OperationNotDeferredKhr.bits() => Some(Self::OperationNotDeferredKhr),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: i32) -> Self {
        std::mem::transmute(bits)
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for VulkanResultCodes {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for VulkanResultCodes {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkDynamicState")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub enum DynamicState {
    #[doc(alias = "VK_DYNAMIC_STATE_VIEWPORT")]
    Viewport = 0,
    #[doc(alias = "VK_DYNAMIC_STATE_SCISSOR")]
    Scissor = 1,
    #[doc(alias = "VK_DYNAMIC_STATE_LINE_WIDTH")]
    LineWidth = 2,
    #[doc(alias = "VK_DYNAMIC_STATE_DEPTH_BIAS")]
    DepthBias = 3,
    #[doc(alias = "VK_DYNAMIC_STATE_BLEND_CONSTANTS")]
    BlendConstants = 4,
    #[doc(alias = "VK_DYNAMIC_STATE_DEPTH_BOUNDS")]
    DepthBounds = 5,
    #[doc(alias = "VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK")]
    StencilCompareMask = 6,
    #[doc(alias = "VK_DYNAMIC_STATE_STENCIL_WRITE_MASK")]
    StencilWriteMask = 7,
    #[doc(alias = "VK_DYNAMIC_STATE_STENCIL_REFERENCE")]
    StencilReference = 8,
    #[doc(alias = "VK_DYNAMIC_STATE_CULL_MODE")]
    #[doc(alias = "VK_DYNAMIC_STATE_CULL_MODE_EXT")]
    #[cfg(feature = "VULKAN_1_3")]
    CullMode = 1000267000,
    #[doc(alias = "VK_DYNAMIC_STATE_FRONT_FACE")]
    #[doc(alias = "VK_DYNAMIC_STATE_FRONT_FACE_EXT")]
    #[cfg(feature = "VULKAN_1_3")]
    FrontFace = 1000267001,
    #[doc(alias = "VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY")]
    #[doc(alias = "VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY_EXT")]
    #[cfg(feature = "VULKAN_1_3")]
    PrimitiveTopology = 1000267002,
    #[doc(alias = "VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT")]
    #[doc(alias = "VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT_EXT")]
    #[cfg(feature = "VULKAN_1_3")]
    ViewportWithCount = 1000267003,
    #[doc(alias = "VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT")]
    #[doc(alias = "VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT_EXT")]
    #[cfg(feature = "VULKAN_1_3")]
    ScissorWithCount = 1000267004,
    #[doc(alias = "VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE")]
    #[doc(alias = "VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE_EXT")]
    #[cfg(feature = "VULKAN_1_3")]
    VertexInputBindingStride = 1000267005,
    #[doc(alias = "VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE")]
    #[doc(alias = "VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE_EXT")]
    #[cfg(feature = "VULKAN_1_3")]
    DepthTestEnable = 1000267006,
    #[doc(alias = "VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE")]
    #[doc(alias = "VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE_EXT")]
    #[cfg(feature = "VULKAN_1_3")]
    DepthWriteEnable = 1000267007,
    #[doc(alias = "VK_DYNAMIC_STATE_DEPTH_COMPARE_OP")]
    #[doc(alias = "VK_DYNAMIC_STATE_DEPTH_COMPARE_OP_EXT")]
    #[cfg(feature = "VULKAN_1_3")]
    DepthCompareOp = 1000267008,
    #[doc(alias = "VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE")]
    #[doc(alias = "VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE_EXT")]
    #[cfg(feature = "VULKAN_1_3")]
    DepthBoundsTestEnable = 1000267009,
    #[doc(alias = "VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE")]
    #[doc(alias = "VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE_EXT")]
    #[cfg(feature = "VULKAN_1_3")]
    StencilTestEnable = 1000267010,
    #[doc(alias = "VK_DYNAMIC_STATE_STENCIL_OP")]
    #[doc(alias = "VK_DYNAMIC_STATE_STENCIL_OP_EXT")]
    #[cfg(feature = "VULKAN_1_3")]
    StencilOp = 1000267011,
    #[doc(alias = "VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE")]
    #[doc(alias = "VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE_EXT")]
    #[cfg(feature = "VULKAN_1_3")]
    RasterizerDiscardEnable = 1000377001,
    #[doc(alias = "VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE")]
    #[doc(alias = "VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE_EXT")]
    #[cfg(feature = "VULKAN_1_3")]
    DepthBiasEnable = 1000377002,
    #[doc(alias = "VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE")]
    #[doc(alias = "VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE_EXT")]
    #[cfg(feature = "VULKAN_1_3")]
    PrimitiveRestartEnable = 1000377004,
    #[doc(alias = "VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV")]
    #[cfg(feature = "VK_NV_clip_space_w_scaling")]
    ViewportWScalingNv = 1000087000,
    #[doc(alias = "VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT")]
    #[cfg(feature = "VK_EXT_discard_rectangles")]
    DiscardRectangleExt = 1000099000,
    #[doc(alias = "VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT")]
    #[cfg(feature = "VK_EXT_sample_locations")]
    SampleLocationsExt = 1000143000,
    #[doc(alias = "VK_DYNAMIC_STATE_RAY_TRACING_PIPELINE_STACK_SIZE_KHR")]
    #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
    RayTracingPipelineStackSizeKhr = 1000347000,
    #[doc(alias = "VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV")]
    #[cfg(feature = "VK_NV_shading_rate_image")]
    ViewportShadingRatePaletteNv = 1000164004,
    #[doc(alias = "VK_DYNAMIC_STATE_VIEWPORT_COARSE_SAMPLE_ORDER_NV")]
    #[cfg(feature = "VK_NV_shading_rate_image")]
    ViewportCoarseSampleOrderNv = 1000164006,
    #[doc(alias = "VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_NV")]
    #[cfg(feature = "VK_NV_scissor_exclusive")]
    ExclusiveScissorNv = 1000205001,
    #[doc(alias = "VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR")]
    #[cfg(feature = "VK_KHR_fragment_shading_rate")]
    FragmentShadingRateKhr = 1000226000,
    #[doc(alias = "VK_DYNAMIC_STATE_LINE_STIPPLE_EXT")]
    #[cfg(feature = "VK_EXT_line_rasterization")]
    LineStippleExt = 1000259000,
    #[doc(alias = "VK_DYNAMIC_STATE_VERTEX_INPUT_EXT")]
    #[cfg(feature = "VK_EXT_vertex_input_dynamic_state")]
    VertexInputExt = 1000352000,
    #[doc(alias = "VK_DYNAMIC_STATE_PATCH_CONTROL_POINTS_EXT")]
    #[cfg(feature = "VK_EXT_extended_dynamic_state2")]
    PatchControlPointsExt = 1000377000,
    #[doc(alias = "VK_DYNAMIC_STATE_LOGIC_OP_EXT")]
    #[cfg(feature = "VK_EXT_extended_dynamic_state2")]
    LogicOpExt = 1000377003,
    #[doc(alias = "VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT")]
    #[cfg(feature = "VK_EXT_color_write_enable")]
    ColorWriteEnableExt = 1000381000,
}
impl Default for DynamicState {
    #[inline]
    fn default() -> Self {
        Self::empty()
    }
}
impl DynamicState {
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        unsafe { Self::from_bits_unchecked(0) }
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> i32 {
        *self as i32
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: i32) -> Option<Self> {
        match bits {
            x if x == Self::Viewport.bits() => Some(Self::Viewport),
            x if x == Self::Scissor.bits() => Some(Self::Scissor),
            x if x == Self::LineWidth.bits() => Some(Self::LineWidth),
            x if x == Self::DepthBias.bits() => Some(Self::DepthBias),
            x if x == Self::BlendConstants.bits() => Some(Self::BlendConstants),
            x if x == Self::DepthBounds.bits() => Some(Self::DepthBounds),
            x if x == Self::StencilCompareMask.bits() => Some(Self::StencilCompareMask),
            x if x == Self::StencilWriteMask.bits() => Some(Self::StencilWriteMask),
            x if x == Self::StencilReference.bits() => Some(Self::StencilReference),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::CullMode.bits() => Some(Self::CullMode),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::FrontFace.bits() => Some(Self::FrontFace),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::PrimitiveTopology.bits() => Some(Self::PrimitiveTopology),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::ViewportWithCount.bits() => Some(Self::ViewportWithCount),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::ScissorWithCount.bits() => Some(Self::ScissorWithCount),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::VertexInputBindingStride.bits() => Some(Self::VertexInputBindingStride),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::DepthTestEnable.bits() => Some(Self::DepthTestEnable),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::DepthWriteEnable.bits() => Some(Self::DepthWriteEnable),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::DepthCompareOp.bits() => Some(Self::DepthCompareOp),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::DepthBoundsTestEnable.bits() => Some(Self::DepthBoundsTestEnable),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::StencilTestEnable.bits() => Some(Self::StencilTestEnable),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::StencilOp.bits() => Some(Self::StencilOp),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::RasterizerDiscardEnable.bits() => Some(Self::RasterizerDiscardEnable),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::DepthBiasEnable.bits() => Some(Self::DepthBiasEnable),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::PrimitiveRestartEnable.bits() => Some(Self::PrimitiveRestartEnable),
            #[cfg(feature = "VK_NV_clip_space_w_scaling")]
            x if x == Self::ViewportWScalingNv.bits() => Some(Self::ViewportWScalingNv),
            #[cfg(feature = "VK_EXT_discard_rectangles")]
            x if x == Self::DiscardRectangleExt.bits() => Some(Self::DiscardRectangleExt),
            #[cfg(feature = "VK_EXT_sample_locations")]
            x if x == Self::SampleLocationsExt.bits() => Some(Self::SampleLocationsExt),
            #[cfg(feature = "VK_KHR_ray_tracing_pipeline")]
            x if x == Self::RayTracingPipelineStackSizeKhr.bits() => Some(Self::RayTracingPipelineStackSizeKhr),
            #[cfg(feature = "VK_NV_shading_rate_image")]
            x if x == Self::ViewportShadingRatePaletteNv.bits() => Some(Self::ViewportShadingRatePaletteNv),
            #[cfg(feature = "VK_NV_shading_rate_image")]
            x if x == Self::ViewportCoarseSampleOrderNv.bits() => Some(Self::ViewportCoarseSampleOrderNv),
            #[cfg(feature = "VK_NV_scissor_exclusive")]
            x if x == Self::ExclusiveScissorNv.bits() => Some(Self::ExclusiveScissorNv),
            #[cfg(feature = "VK_KHR_fragment_shading_rate")]
            x if x == Self::FragmentShadingRateKhr.bits() => Some(Self::FragmentShadingRateKhr),
            #[cfg(feature = "VK_EXT_line_rasterization")]
            x if x == Self::LineStippleExt.bits() => Some(Self::LineStippleExt),
            #[cfg(feature = "VK_EXT_vertex_input_dynamic_state")]
            x if x == Self::VertexInputExt.bits() => Some(Self::VertexInputExt),
            #[cfg(feature = "VK_EXT_extended_dynamic_state2")]
            x if x == Self::PatchControlPointsExt.bits() => Some(Self::PatchControlPointsExt),
            #[cfg(feature = "VK_EXT_extended_dynamic_state2")]
            x if x == Self::LogicOpExt.bits() => Some(Self::LogicOpExt),
            #[cfg(feature = "VK_EXT_color_write_enable")]
            x if x == Self::ColorWriteEnableExt.bits() => Some(Self::ColorWriteEnableExt),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: i32) -> Self {
        std::mem::transmute(bits)
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for DynamicState {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for DynamicState {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkObjectType")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub enum ObjectType {
    #[doc(alias = "VK_OBJECT_TYPE_UNKNOWN")]
    Unknown = 0,
    #[doc(alias = "VK_OBJECT_TYPE_INSTANCE")]
    Instance = 1,
    #[doc(alias = "VK_OBJECT_TYPE_PHYSICAL_DEVICE")]
    PhysicalDevice = 2,
    #[doc(alias = "VK_OBJECT_TYPE_DEVICE")]
    Device = 3,
    #[doc(alias = "VK_OBJECT_TYPE_QUEUE")]
    Queue = 4,
    #[doc(alias = "VK_OBJECT_TYPE_SEMAPHORE")]
    Semaphore = 5,
    #[doc(alias = "VK_OBJECT_TYPE_COMMAND_BUFFER")]
    CommandBuffer = 6,
    #[doc(alias = "VK_OBJECT_TYPE_FENCE")]
    Fence = 7,
    #[doc(alias = "VK_OBJECT_TYPE_DEVICE_MEMORY")]
    DeviceMemory = 8,
    #[doc(alias = "VK_OBJECT_TYPE_BUFFER")]
    Buffer = 9,
    #[doc(alias = "VK_OBJECT_TYPE_IMAGE")]
    Image = 10,
    #[doc(alias = "VK_OBJECT_TYPE_EVENT")]
    Event = 11,
    #[doc(alias = "VK_OBJECT_TYPE_QUERY_POOL")]
    QueryPool = 12,
    #[doc(alias = "VK_OBJECT_TYPE_BUFFER_VIEW")]
    BufferView = 13,
    #[doc(alias = "VK_OBJECT_TYPE_IMAGE_VIEW")]
    ImageView = 14,
    #[doc(alias = "VK_OBJECT_TYPE_SHADER_MODULE")]
    ShaderModule = 15,
    #[doc(alias = "VK_OBJECT_TYPE_PIPELINE_CACHE")]
    PipelineCache = 16,
    #[doc(alias = "VK_OBJECT_TYPE_PIPELINE_LAYOUT")]
    PipelineLayout = 17,
    #[doc(alias = "VK_OBJECT_TYPE_RENDER_PASS")]
    RenderPass = 18,
    #[doc(alias = "VK_OBJECT_TYPE_PIPELINE")]
    Pipeline = 19,
    #[doc(alias = "VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT")]
    DescriptorSetLayout = 20,
    #[doc(alias = "VK_OBJECT_TYPE_SAMPLER")]
    Sampler = 21,
    #[doc(alias = "VK_OBJECT_TYPE_DESCRIPTOR_POOL")]
    DescriptorPool = 22,
    #[doc(alias = "VK_OBJECT_TYPE_DESCRIPTOR_SET")]
    DescriptorSet = 23,
    #[doc(alias = "VK_OBJECT_TYPE_FRAMEBUFFER")]
    Framebuffer = 24,
    #[doc(alias = "VK_OBJECT_TYPE_COMMAND_POOL")]
    CommandPool = 25,
    #[doc(alias = "VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION")]
    #[doc(alias = "VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR")]
    SamplerYcbcrConversion = 1000156000,
    #[doc(alias = "VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE")]
    #[doc(alias = "VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR")]
    DescriptorUpdateTemplate = 1000085000,
    #[doc(alias = "VK_OBJECT_TYPE_PRIVATE_DATA_SLOT")]
    #[doc(alias = "VK_OBJECT_TYPE_PRIVATE_DATA_SLOT_EXT")]
    #[cfg(feature = "VULKAN_1_3")]
    PrivateDataSlot = 1000295000,
    #[doc(alias = "VK_OBJECT_TYPE_SURFACE_KHR")]
    #[cfg(feature = "VK_KHR_surface")]
    SurfaceKhr = 1000000000,
    #[doc(alias = "VK_OBJECT_TYPE_SWAPCHAIN_KHR")]
    #[cfg(feature = "VK_KHR_swapchain")]
    SwapchainKhr = 1000001000,
    #[doc(alias = "VK_OBJECT_TYPE_DISPLAY_KHR")]
    #[cfg(feature = "VK_KHR_display")]
    DisplayKhr = 1000002000,
    #[doc(alias = "VK_OBJECT_TYPE_DISPLAY_MODE_KHR")]
    #[cfg(feature = "VK_KHR_display")]
    DisplayModeKhr = 1000002001,
    #[doc(alias = "VK_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT")]
    #[cfg(feature = "VK_EXT_debug_report")]
    DebugReportCallbackExt = 1000011000,
    #[doc(alias = "VK_OBJECT_TYPE_VIDEO_SESSION_KHR")]
    #[cfg(feature = "VK_KHR_video_queue")]
    VideoSessionKhr = 1000023000,
    #[doc(alias = "VK_OBJECT_TYPE_VIDEO_SESSION_PARAMETERS_KHR")]
    #[cfg(feature = "VK_KHR_video_queue")]
    VideoSessionParametersKhr = 1000023001,
    #[doc(alias = "VK_OBJECT_TYPE_CU_MODULE_NVX")]
    #[cfg(feature = "VK_NVX_binary_import")]
    CuModuleNvx = 1000029000,
    #[doc(alias = "VK_OBJECT_TYPE_CU_FUNCTION_NVX")]
    #[cfg(feature = "VK_NVX_binary_import")]
    CuFunctionNvx = 1000029001,
    #[doc(alias = "VK_OBJECT_TYPE_DEBUG_UTILS_MESSENGER_EXT")]
    #[cfg(feature = "VK_EXT_debug_utils")]
    DebugUtilsMessengerExt = 1000128000,
    #[doc(alias = "VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR")]
    #[cfg(feature = "VK_KHR_acceleration_structure")]
    AccelerationStructureKhr = 1000150000,
    #[doc(alias = "VK_OBJECT_TYPE_VALIDATION_CACHE_EXT")]
    #[cfg(feature = "VK_EXT_validation_cache")]
    ValidationCacheExt = 1000160000,
    #[doc(alias = "VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV")]
    #[cfg(feature = "VK_NV_ray_tracing")]
    AccelerationStructureNv = 1000165000,
    #[doc(alias = "VK_OBJECT_TYPE_PERFORMANCE_CONFIGURATION_INTEL")]
    #[cfg(feature = "VK_INTEL_performance_query")]
    PerformanceConfigurationIntel = 1000210000,
    #[doc(alias = "VK_OBJECT_TYPE_DEFERRED_OPERATION_KHR")]
    #[cfg(feature = "VK_KHR_deferred_host_operations")]
    DeferredOperationKhr = 1000268000,
    #[doc(alias = "VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NV")]
    #[cfg(feature = "VK_NV_device_generated_commands")]
    IndirectCommandsLayoutNv = 1000277000,
    #[doc(alias = "VK_OBJECT_TYPE_BUFFER_COLLECTION_FUCHSIA")]
    #[cfg(feature = "VK_FUCHSIA_buffer_collection")]
    BufferCollectionFuchsia = 1000366000,
}
impl Default for ObjectType {
    #[inline]
    fn default() -> Self {
        Self::empty()
    }
}
impl ObjectType {
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        unsafe { Self::from_bits_unchecked(0) }
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> i32 {
        *self as i32
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: i32) -> Option<Self> {
        match bits {
            x if x == Self::Unknown.bits() => Some(Self::Unknown),
            x if x == Self::Instance.bits() => Some(Self::Instance),
            x if x == Self::PhysicalDevice.bits() => Some(Self::PhysicalDevice),
            x if x == Self::Device.bits() => Some(Self::Device),
            x if x == Self::Queue.bits() => Some(Self::Queue),
            x if x == Self::Semaphore.bits() => Some(Self::Semaphore),
            x if x == Self::CommandBuffer.bits() => Some(Self::CommandBuffer),
            x if x == Self::Fence.bits() => Some(Self::Fence),
            x if x == Self::DeviceMemory.bits() => Some(Self::DeviceMemory),
            x if x == Self::Buffer.bits() => Some(Self::Buffer),
            x if x == Self::Image.bits() => Some(Self::Image),
            x if x == Self::Event.bits() => Some(Self::Event),
            x if x == Self::QueryPool.bits() => Some(Self::QueryPool),
            x if x == Self::BufferView.bits() => Some(Self::BufferView),
            x if x == Self::ImageView.bits() => Some(Self::ImageView),
            x if x == Self::ShaderModule.bits() => Some(Self::ShaderModule),
            x if x == Self::PipelineCache.bits() => Some(Self::PipelineCache),
            x if x == Self::PipelineLayout.bits() => Some(Self::PipelineLayout),
            x if x == Self::RenderPass.bits() => Some(Self::RenderPass),
            x if x == Self::Pipeline.bits() => Some(Self::Pipeline),
            x if x == Self::DescriptorSetLayout.bits() => Some(Self::DescriptorSetLayout),
            x if x == Self::Sampler.bits() => Some(Self::Sampler),
            x if x == Self::DescriptorPool.bits() => Some(Self::DescriptorPool),
            x if x == Self::DescriptorSet.bits() => Some(Self::DescriptorSet),
            x if x == Self::Framebuffer.bits() => Some(Self::Framebuffer),
            x if x == Self::CommandPool.bits() => Some(Self::CommandPool),
            x if x == Self::SamplerYcbcrConversion.bits() => Some(Self::SamplerYcbcrConversion),
            x if x == Self::DescriptorUpdateTemplate.bits() => Some(Self::DescriptorUpdateTemplate),
            #[cfg(feature = "VULKAN_1_3")]
            x if x == Self::PrivateDataSlot.bits() => Some(Self::PrivateDataSlot),
            #[cfg(feature = "VK_KHR_surface")]
            x if x == Self::SurfaceKhr.bits() => Some(Self::SurfaceKhr),
            #[cfg(feature = "VK_KHR_swapchain")]
            x if x == Self::SwapchainKhr.bits() => Some(Self::SwapchainKhr),
            #[cfg(feature = "VK_KHR_display")]
            x if x == Self::DisplayKhr.bits() => Some(Self::DisplayKhr),
            #[cfg(feature = "VK_KHR_display")]
            x if x == Self::DisplayModeKhr.bits() => Some(Self::DisplayModeKhr),
            #[cfg(feature = "VK_EXT_debug_report")]
            x if x == Self::DebugReportCallbackExt.bits() => Some(Self::DebugReportCallbackExt),
            #[cfg(feature = "VK_KHR_video_queue")]
            x if x == Self::VideoSessionKhr.bits() => Some(Self::VideoSessionKhr),
            #[cfg(feature = "VK_KHR_video_queue")]
            x if x == Self::VideoSessionParametersKhr.bits() => Some(Self::VideoSessionParametersKhr),
            #[cfg(feature = "VK_NVX_binary_import")]
            x if x == Self::CuModuleNvx.bits() => Some(Self::CuModuleNvx),
            #[cfg(feature = "VK_NVX_binary_import")]
            x if x == Self::CuFunctionNvx.bits() => Some(Self::CuFunctionNvx),
            #[cfg(feature = "VK_EXT_debug_utils")]
            x if x == Self::DebugUtilsMessengerExt.bits() => Some(Self::DebugUtilsMessengerExt),
            #[cfg(feature = "VK_KHR_acceleration_structure")]
            x if x == Self::AccelerationStructureKhr.bits() => Some(Self::AccelerationStructureKhr),
            #[cfg(feature = "VK_EXT_validation_cache")]
            x if x == Self::ValidationCacheExt.bits() => Some(Self::ValidationCacheExt),
            #[cfg(feature = "VK_NV_ray_tracing")]
            x if x == Self::AccelerationStructureNv.bits() => Some(Self::AccelerationStructureNv),
            #[cfg(feature = "VK_INTEL_performance_query")]
            x if x == Self::PerformanceConfigurationIntel.bits() => Some(Self::PerformanceConfigurationIntel),
            #[cfg(feature = "VK_KHR_deferred_host_operations")]
            x if x == Self::DeferredOperationKhr.bits() => Some(Self::DeferredOperationKhr),
            #[cfg(feature = "VK_NV_device_generated_commands")]
            x if x == Self::IndirectCommandsLayoutNv.bits() => Some(Self::IndirectCommandsLayoutNv),
            #[cfg(feature = "VK_FUCHSIA_buffer_collection")]
            x if x == Self::BufferCollectionFuchsia.bits() => Some(Self::BufferCollectionFuchsia),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: i32) -> Self {
        std::mem::transmute(bits)
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for ObjectType {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for ObjectType {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
#[doc(alias = "VkVendorId")]
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub enum VendorId {
    Empty = 0,
    #[doc(alias = "VK_VENDOR_ID_VIV")]
    Viv = 65537,
    #[doc(alias = "VK_VENDOR_ID_VSI")]
    Vsi = 65538,
    #[doc(alias = "VK_VENDOR_ID_KAZAN")]
    Kazan = 65539,
    #[doc(alias = "VK_VENDOR_ID_CODEPLAY")]
    Codeplay = 65540,
    #[doc(alias = "VK_VENDOR_ID_MESA")]
    Mesa = 65541,
    #[doc(alias = "VK_VENDOR_ID_POCL")]
    Pocl = 65542,
}
impl Default for VendorId {
    #[inline]
    fn default() -> Self {
        Self::empty()
    }
}
impl VendorId {
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        unsafe { Self::from_bits_unchecked(0) }
    }
    ///The bits of this variant
    #[inline]
    pub const fn bits(&self) -> i32 {
        *self as i32
    }
    ///Builds a bitmask from the bits of this variant
    #[inline]
    pub const fn from_bits(bits: i32) -> Option<Self> {
        match bits {
            x if x == Self::Viv.bits() => Some(Self::Viv),
            x if x == Self::Vsi.bits() => Some(Self::Vsi),
            x if x == Self::Kazan.bits() => Some(Self::Kazan),
            x if x == Self::Codeplay.bits() => Some(Self::Codeplay),
            x if x == Self::Mesa.bits() => Some(Self::Mesa),
            x if x == Self::Pocl.bits() => Some(Self::Pocl),
            _ => None,
        }
    }
    ///Builds a bitmask from the bits of this variant without validating it
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: i32) -> Self {
        std::mem::transmute(bits)
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::IntoLowLevel for VendorId {
    type LowLevel = Self;
    unsafe fn into_low_level(
        &self,
        context: &std::sync::Arc<crate::context::Context>,
        bump: &bumpalo::Bump,
    ) -> Self::LowLevel {
        *self
    }
}
#[cfg(feature = "native")]
unsafe impl crate::conv::FromLowLevel for VendorId {
    unsafe fn from_low_level(
        context: &std::sync::Arc<crate::context::Context>,
        value: <Self as crate::conv::IntoLowLevel>::LowLevel,
    ) -> Self {
        value
    }
}
