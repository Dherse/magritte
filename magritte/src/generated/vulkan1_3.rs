//![VK_VERSION_1_3](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_VERSION_1_3.html) - Vulkan version 1.3
//!# Description
//!Vulkan Version 1.3 [promoted](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#extendingvulkan-compatibility-promotion) a
//!number of key extensions into the core API:
//! - `[`khr_copy_commands2`]`
//! - `[`khr_dynamic_rendering`]`
//! - `[`khr_format_feature_flags2`]`
//! - `[`khr_maintenance4`]`
//! - `[`khr_shader_integer_dot_product`]`
//! - `[`khr_shader_non_semantic_info`]`
//! - `[`khr_shader_terminate_invocation`]`
//! - `[`khr_synchronization2`]`
//! - `[`khr_zero_initialize_workgroup_memory`]`
//! - `[`ext_4444_formats`]`
//! - `[`ext_extended_dynamic_state`]`
//! - `[`ext_extended_dynamic_state2`]`
//! - `[`ext_image_robustness`]`
//! - `[`ext_inline_uniform_block`]`
//! - `[`ext_pipeline_creation_cache_control`]`
//! - `[`ext_pipeline_creation_feedback`]`
//! - `[`ext_private_data`]`
//! - `[`ext_shader_demote_to_helper_invocation`]`
//! - `[`ext_subgroup_size_control`]`
//! - `[`ext_texel_buffer_alignment`]`
//! - `[`ext_texture_compression_astc_hdr`]`
//! - `[`ext_tooling_info`]`
//! - `[`ext_ycbcr_2plane_444_formats`]`
//!All differences in behavior between these extensions and the corresponding
//!Vulkan 1.3 functionality are summarized in the [Vulkan 1.3 specification appendix](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#versions-1.3-promotions).
//!### []()New Macros
//!
//! - [`crate::Version::VULKAN1_3`]
//!
//!### []()New Object Types
//!
//! - [`PrivateDataSlot`]
//!
//!### []()New Commands
//!
//! - [`cmd_begin_rendering`]
//! - [`cmd_bind_vertex_buffers2`]
//! - [`cmd_blit_image2`]
//! - [`cmd_copy_buffer2`]
//! - [`cmd_copy_buffer_to_image2`]
//! - [`cmd_copy_image2`]
//! - [`cmd_copy_image_to_buffer2`]
//! - [`cmd_end_rendering`]
//! - [`cmd_pipeline_barrier2`]
//! - [`cmd_reset_event2`]
//! - [`cmd_resolve_image2`]
//! - [`cmd_set_cull_mode`]
//! - [`cmd_set_depth_bias_enable`]
//! - [`cmd_set_depth_bounds_test_enable`]
//! - [`cmd_set_depth_compare_op`]
//! - [`cmd_set_depth_test_enable`]
//! - [`cmd_set_depth_write_enable`]
//! - [`cmd_set_event2`]
//! - [`cmd_set_front_face`]
//! - [`cmd_set_primitive_restart_enable`]
//! - [`cmd_set_primitive_topology`]
//! - [`cmd_set_rasterizer_discard_enable`]
//! - [`cmd_set_scissor_with_count`]
//! - [`cmd_set_stencil_op`]
//! - [`cmd_set_stencil_test_enable`]
//! - [`cmd_set_viewport_with_count`]
//! - [`cmd_wait_events2`]
//! - [`cmd_write_timestamp2`]
//! - [`create_private_data_slot`]
//! - [`destroy_private_data_slot`]
//! - [`get_device_buffer_memory_requirements`]
//! - [`get_device_image_memory_requirements`]
//! - [`get_device_image_sparse_memory_requirements`]
//! - [`get_physical_device_tool_properties`]
//! - [`get_private_data`]
//! - [`queue_submit2`]
//! - [`set_private_data`]
//!
//!### []()New Structures
//!
//! - [`BlitImageInfo2`]
//! - [`BufferCopy2`]
//! - [`BufferImageCopy2`]
//! - [`BufferMemoryBarrier2`]
//! - [`CommandBufferSubmitInfo`]
//! - [`CopyBufferInfo2`]
//! - [`CopyBufferToImageInfo2`]
//! - [`CopyImageInfo2`]
//! - [`CopyImageToBufferInfo2`]
//! - [`DependencyInfo`]
//! - [`DeviceBufferMemoryRequirements`]
//! - [`DeviceImageMemoryRequirements`]
//! - [`ImageBlit2`]
//! - [`ImageCopy2`]
//! - [`ImageMemoryBarrier2`]
//! - [`ImageResolve2`]
//! - [`PhysicalDeviceToolProperties`]
//! - [`PipelineCreationFeedback`]
//! - [`PrivateDataSlotCreateInfo`]
//! - [`RenderingAttachmentInfo`]
//! - [`RenderingInfo`]
//! - [`ResolveImageInfo2`]
//! - [`SemaphoreSubmitInfo`]
//! - [`SubmitInfo2`]
//! - Extending [`CommandBufferInheritanceInfo`]:  - [`CommandBufferInheritanceRenderingInfo`]
//! - Extending [`DescriptorPoolCreateInfo`]:  - [`DescriptorPoolInlineUniformBlockCreateInfo`]
//! - Extending [`DeviceCreateInfo`]:  - [`DevicePrivateDataCreateInfo`]
//! - Extending [`FormatProperties2`]:  - [`FormatProperties3`]
//! - Extending [`GraphicsPipelineCreateInfo`]:  - [`PipelineRenderingCreateInfo`]
//! - Extending [`GraphicsPipelineCreateInfo`], [`ComputePipelineCreateInfo`],
//!   [`RayTracingPipelineCreateInfoNV`], [`RayTracingPipelineCreateInfoKHR`]:  -
//!   [`PipelineCreationFeedbackCreateInfo`]
//! - Extending [`PhysicalDeviceFeatures2`], [`DeviceCreateInfo`]:  -
//!   [`PhysicalDeviceDynamicRenderingFeatures`]  - [`PhysicalDeviceImageRobustnessFeatures`]  -
//!   [`PhysicalDeviceInlineUniformBlockFeatures`]  - [`PhysicalDeviceMaintenance4Features`]  -
//!   [`PhysicalDevicePipelineCreationCacheControlFeatures`]  -
//!   [`PhysicalDevicePrivateDataFeatures`]  -
//!   [`PhysicalDeviceShaderDemoteToHelperInvocationFeatures`]  -
//!   [`PhysicalDeviceShaderIntegerDotProductFeatures`]  -
//!   [`PhysicalDeviceShaderTerminateInvocationFeatures`]  -
//!   [`PhysicalDeviceSubgroupSizeControlFeatures`]  - [`PhysicalDeviceSynchronization2Features`]  -
//!   [`PhysicalDeviceTextureCompressionAstchdrFeatures`]  - [`PhysicalDeviceVulkan13Features`]  -
//!   [`PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures`]
//! - Extending [`PhysicalDeviceProperties2`]:  - [`PhysicalDeviceInlineUniformBlockProperties`]  -
//!   [`PhysicalDeviceMaintenance4Properties`]  -
//!   [`PhysicalDeviceShaderIntegerDotProductProperties`]  -
//!   [`PhysicalDeviceSubgroupSizeControlProperties`]  -
//!   [`PhysicalDeviceTexelBufferAlignmentProperties`]  - [`PhysicalDeviceVulkan13Properties`]
//! - Extending [`PipelineShaderStageCreateInfo`]:  -
//!   [`PipelineShaderStageRequiredSubgroupSizeCreateInfo`]
//! - Extending [`SubpassDependency2`]:  - [`MemoryBarrier2`]
//! - Extending [`WriteDescriptorSet`]:  - [`WriteDescriptorSetInlineUniformBlock`]
//!
//!### []()New Enums
//!
//! - [`AccessFlagBits2`]
//! - [`FormatFeatureFlagBits2`]
//! - [`PipelineCreationFeedbackFlagBits`]
//! - [`PipelineStageFlagBits2`]
//! - [`RenderingFlagBits`]
//! - [`SubmitFlagBits`]
//! - [`ToolPurposeFlagBits`]
//!
//!### []()New Bitmasks
//!
//! - [`AccessFlags2`]
//! - [`FormatFeatureFlags2`]
//! - [`PipelineCreationFeedbackFlags`]
//! - [`PipelineStageFlags2`]
//! - [`PrivateDataSlotCreateFlags`]
//! - [`RenderingFlags`]
//! - [`SubmitFlags`]
//! - [`ToolPurposeFlags`]
//!
//!### []()New Enum Constants
//!
//! - Extending [`AccessFlagBits`]:  - `VK_ACCESS_NONE`
//! - Extending [`AttachmentStoreOp`]:  - `VK_ATTACHMENT_STORE_OP_NONE`
//! - Extending [`DescriptorType`]:  - `VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK`
//! - Extending [`DynamicState`]:  - `VK_DYNAMIC_STATE_CULL_MODE`  -
//!   `VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE`  - `VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE`  -
//!   `VK_DYNAMIC_STATE_DEPTH_COMPARE_OP`  - `VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE`  -
//!   `VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE`  - `VK_DYNAMIC_STATE_FRONT_FACE`  -
//!   `VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE`  - `VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY`  -
//!   `VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE`  - `VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT`  -
//!   `VK_DYNAMIC_STATE_STENCIL_OP`  - `VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE`  -
//!   `VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE`  - `VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT`
//! - Extending [`EventCreateFlagBits`]:  - `VK_EVENT_CREATE_DEVICE_ONLY_BIT`
//! - Extending [`Format`]:  - `VK_FORMAT_A4B4G4R4_UNORM_PACK16`  -
//!   `VK_FORMAT_A4R4G4B4_UNORM_PACK16`  - `VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK`  -
//!   `VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK`  - `VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK`  -
//!   `VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK`  - `VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK`  -
//!   `VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK`  - `VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK`  -
//!   `VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK`  - `VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK`  -
//!   `VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK`  - `VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK`  -
//!   `VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK`  - `VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK`  -
//!   `VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK`  - `VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16`  -
//!   `VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16`  -
//!   `VK_FORMAT_G16_B16R16_2PLANE_444_UNORM`  - `VK_FORMAT_G8_B8R8_2PLANE_444_UNORM`
//! - Extending [`ImageAspectFlagBits`]:  - `VK_IMAGE_ASPECT_NONE`
//! - Extending [`ImageLayout`]:  - `VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL`  -
//!   `VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL`
//! - Extending [`ObjectType`]:  - `VK_OBJECT_TYPE_PRIVATE_DATA_SLOT`
//! - Extending [`PipelineCacheCreateFlagBits`]:  -
//!   `VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT`
//! - Extending [`PipelineCreateFlagBits`]:  - `VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT`  -
//!   `VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT`
//! - Extending [`PipelineShaderStageCreateFlagBits`]:  -
//!   `VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT`  -
//!   `VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT`
//! - Extending [`PipelineStageFlagBits`]:  - `VK_PIPELINE_STAGE_NONE`
//! - Extending [`VulkanResultCodes`]:  - `VK_PIPELINE_COMPILE_REQUIRED`
//! - Extending [`StructureType`]:  - `VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2`  -
//!   `VK_STRUCTURE_TYPE_BUFFER_COPY_2`  - `VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2`  -
//!   `VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2`  -
//!   `VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO`  -
//!   `VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO`  - `VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2`  -
//!   `VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2`  - `VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2`  -
//!   `VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2`  - `VK_STRUCTURE_TYPE_DEPENDENCY_INFO`  -
//!   `VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO`  -
//!   `VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS`  -
//!   `VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS`  -
//!   `VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO`  - `VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3`
//!   - `VK_STRUCTURE_TYPE_IMAGE_BLIT_2`  - `VK_STRUCTURE_TYPE_IMAGE_COPY_2`  -
//!   `VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2`  - `VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2`  -
//!   `VK_STRUCTURE_TYPE_MEMORY_BARRIER_2`  -
//!   `VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES`  -
//!   `VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES`  -
//!   `VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES`  -
//!   `VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES`  -
//!   `VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES`  -
//!   `VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES`  -
//!   `VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES`  -
//!   `VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES`  -
//!   `VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES`  -
//!   `VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES`  -
//!   `VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES`  -
//!   `VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES`  -
//!   `VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES`  -
//!   `VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES`  -
//!   `VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES`  -
//!   `VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES`  -
//!   `VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES`  -
//!   `VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES`  -
//!   `VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES`  -
//!   `VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES`  -
//!   `VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES`  -
//!   `VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO`  -
//!   `VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO`  -
//!   `VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO`  -
//!   `VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO`  -
//!   `VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO`  - `VK_STRUCTURE_TYPE_RENDERING_INFO`  -
//!   `VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2`  - `VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO`  -
//!   `VK_STRUCTURE_TYPE_SUBMIT_INFO_2`  -
//!   `VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK`
//!# Related
//! - [`crate::vulkan1_0`]
//! - [`crate::vulkan1_1`]
//! - [`crate::vulkan1_2`]
//!
//!# Notes and documentation
//!For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
//!
//!This documentation is generated from the Vulkan specification and documentation.
//!The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
//! Commons Attribution 4.0 International*.
//!This license explicitely allows adapting the source material as long as proper credit is given.
#[cfg(feature = "VK_EXT_sample_locations")]
use crate::extensions::ext_sample_locations::SampleLocationsInfoEXT;
#[cfg(feature = "VK_KHR_dynamic_rendering")]
use crate::extensions::khr_dynamic_rendering::MultiviewPerViewAttributesInfoNVX;
#[cfg(feature = "VK_KHR_dynamic_rendering")]
use crate::extensions::khr_dynamic_rendering::RenderingFragmentDensityMapAttachmentInfoEXT;
#[cfg(feature = "VK_KHR_dynamic_rendering")]
use crate::extensions::khr_dynamic_rendering::RenderingFragmentShadingRateAttachmentInfoKHR;
#[cfg(feature = "VK_KHR_performance_query")]
use crate::extensions::khr_performance_query::PerformanceQuerySubmitInfoKHR;
#[cfg(feature = "VK_KHR_win32_keyed_mutex")]
use crate::extensions::khr_win32_keyed_mutex::Win32KeyedMutexAcquireReleaseInfoKHR;
#[cfg(any(feature = "VK_NV_win32_keyed_mutex", feature = "VK_KHR_win32_keyed_mutex"))]
use crate::extensions::nv_win32_keyed_mutex::Win32KeyedMutexAcquireReleaseInfoNV;
#[cfg(feature = "VK_QCOM_rotated_copy_commands")]
use crate::extensions::qcom_rotated_copy_commands::CopyCommandTransformInfoQCOM;
use crate::{
    core::{MAX_DESCRIPTION_SIZE, MAX_EXTENSION_NAME_SIZE},
    entry::Entry,
    vulkan1_0::{
        AllocationCallbacks, AttachmentLoadOp, AttachmentStoreOp, BaseInStructure, BaseOutStructure, Bool32, Buffer,
        BufferCreateInfo, ClearValue, CommandBuffer, CompareOp, CullModeFlags, DependencyFlags, Device, DeviceSize,
        Event, Extent3D, Fence, Filter, Format, FrontFace, Image, ImageAspectFlagBits, ImageCreateInfo, ImageLayout,
        ImageSubresourceLayers, ImageSubresourceRange, ImageView, Instance, ObjectType, Offset3D, PhysicalDevice,
        PrimitiveTopology, QueryPool, Queue, Rect2D, SampleCountFlagBits, Semaphore, ShaderStageFlags,
        StencilFaceFlags, StencilOp, StructureType, Viewport, VulkanResultCodes,
    },
    vulkan1_1::{DeviceGroupRenderPassBeginInfo, MemoryRequirements2, SparseImageMemoryRequirements2},
    vulkan1_2::ResolveModeFlagBits,
    AsRaw, Handle, SmallVec, Unique, VulkanResult,
};
#[cfg(feature = "serde")]
use serde::{Deserialize, Serialize};
use std::{
    ffi::c_void,
    iter::{Extend, FromIterator, IntoIterator},
    marker::PhantomData,
    mem::MaybeUninit,
    os::raw::c_char,
    sync::{
        atomic::{AtomicBool, Ordering},
        Arc,
    },
};
///[vkGetDeviceBufferMemoryRequirements](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceBufferMemoryRequirements.html) - Returns the memory requirements for specified Vulkan object
///# C Specifications
///To determine the memory requirements for a buffer resource without creating
///an object, call:
///```c
///// Provided by VK_VERSION_1_3
///void vkGetDeviceBufferMemoryRequirements(
///    VkDevice                                    device,
///    const VkDeviceBufferMemoryRequirements*     pInfo,
///    VkMemoryRequirements2*                      pMemoryRequirements);
///```
///or the equivalent command
///```c
///// Provided by VK_KHR_maintenance4
///void vkGetDeviceBufferMemoryRequirementsKHR(
///    VkDevice                                    device,
///    const VkDeviceBufferMemoryRequirements*     pInfo,
///    VkMemoryRequirements2*                      pMemoryRequirements);
///```
///# Parameters
/// - [`device`] is the logical device intended to own the buffer.
/// - [`p_info`] is a pointer to a [`DeviceBufferMemoryRequirements`] structure containing
///   parameters required for the memory requirements query.
/// - [`p_memory_requirements`] is a pointer to a [`MemoryRequirements2`] structure in which the
///   memory requirements of the buffer object are returned.
///# Description
///## Valid Usage (Implicit)
/// - [`device`] **must**  be a valid [`Device`] handle
/// - [`p_info`] **must**  be a valid pointer to a valid [`DeviceBufferMemoryRequirements`]
///   structure
/// - [`p_memory_requirements`] **must**  be a valid pointer to a [`MemoryRequirements2`] structure
///# Related
/// - [`khr_maintenance4`]
/// - [`crate::vulkan1_3`]
/// - [`Device`]
/// - [`DeviceBufferMemoryRequirements`]
/// - [`MemoryRequirements2`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "vkGetDeviceBufferMemoryRequirements")]
pub type FNGetDeviceBufferMemoryRequirements = Option<
    for<'lt> unsafe extern "system" fn(
        device: Device,
        p_info: *const DeviceBufferMemoryRequirements<'lt>,
        p_memory_requirements: *mut MemoryRequirements2<'lt>,
    ),
>;
///[vkGetDeviceImageMemoryRequirements](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceImageMemoryRequirements.html) - Returns the memory requirements for specified Vulkan object
///# C Specifications
///To determine the memory requirements for an image resource without creating
///an object, call:
///```c
///// Provided by VK_VERSION_1_3
///void vkGetDeviceImageMemoryRequirements(
///    VkDevice                                    device,
///    const VkDeviceImageMemoryRequirements*      pInfo,
///    VkMemoryRequirements2*                      pMemoryRequirements);
///```
///or the equivalent command
///```c
///// Provided by VK_KHR_maintenance4
///void vkGetDeviceImageMemoryRequirementsKHR(
///    VkDevice                                    device,
///    const VkDeviceImageMemoryRequirements*      pInfo,
///    VkMemoryRequirements2*                      pMemoryRequirements);
///```
///# Parameters
/// - [`device`] is the logical device intended to own the image.
/// - [`p_info`] is a pointer to a [`DeviceImageMemoryRequirements`] structure containing parameters
///   required for the memory requirements query.
/// - [`p_memory_requirements`] is a pointer to a [`MemoryRequirements2`] structure in which the
///   memory requirements of the image object are returned.
///# Description
///## Valid Usage (Implicit)
/// - [`device`] **must**  be a valid [`Device`] handle
/// - [`p_info`] **must**  be a valid pointer to a valid [`DeviceImageMemoryRequirements`] structure
/// - [`p_memory_requirements`] **must**  be a valid pointer to a [`MemoryRequirements2`] structure
///# Related
/// - [`khr_maintenance4`]
/// - [`crate::vulkan1_3`]
/// - [`Device`]
/// - [`DeviceImageMemoryRequirements`]
/// - [`MemoryRequirements2`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "vkGetDeviceImageMemoryRequirements")]
pub type FNGetDeviceImageMemoryRequirements = Option<
    for<'lt> unsafe extern "system" fn(
        device: Device,
        p_info: *const DeviceImageMemoryRequirements<'lt>,
        p_memory_requirements: *mut MemoryRequirements2<'lt>,
    ),
>;
///[vkGetDeviceImageSparseMemoryRequirements](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceImageSparseMemoryRequirements.html) - Query the memory requirements for a sparse image
///# C Specifications
///To determine the sparse memory requirements for an image resource without
///creating an object, call:
///```c
///// Provided by VK_VERSION_1_3
///void vkGetDeviceImageSparseMemoryRequirements(
///    VkDevice                                    device,
///    const VkDeviceImageMemoryRequirements*      pInfo,
///    uint32_t*                                   pSparseMemoryRequirementCount,
///    VkSparseImageMemoryRequirements2*           pSparseMemoryRequirements);
///```
///or the equivalent command
///```c
///// Provided by VK_KHR_maintenance4
///void vkGetDeviceImageSparseMemoryRequirementsKHR(
///    VkDevice                                    device,
///    const VkDeviceImageMemoryRequirements*      pInfo,
///    uint32_t*                                   pSparseMemoryRequirementCount,
///    VkSparseImageMemoryRequirements2*           pSparseMemoryRequirements);
///```
///# Parameters
/// - [`device`] is the logical device intended to own the image.
/// - [`p_info`] is a pointer to a [`DeviceImageMemoryRequirements`] structure containing parameters
///   required for the memory requirements query.
/// - [`p_sparse_memory_requirement_count`] is a pointer to an integer related to the number of
///   sparse memory requirements available or queried, as described below.
/// - [`p_sparse_memory_requirements`] is either `NULL` or a pointer to an array of
///   [`SparseImageMemoryRequirements2`] structures.
///# Description
///## Valid Usage (Implicit)
/// - [`device`] **must**  be a valid [`Device`] handle
/// - [`p_info`] **must**  be a valid pointer to a valid [`DeviceImageMemoryRequirements`] structure
/// - [`p_sparse_memory_requirement_count`] **must**  be a valid pointer to a `uint32_t` value
/// - If the value referenced by [`p_sparse_memory_requirement_count`] is not `0`, and
///   [`p_sparse_memory_requirements`] is not `NULL`, [`p_sparse_memory_requirements`] **must**  be
///   a valid pointer to an array of
///   [`p_sparse_memory_requirement_count`][`SparseImageMemoryRequirements2`] structures
///# Related
/// - [`khr_maintenance4`]
/// - [`crate::vulkan1_3`]
/// - [`Device`]
/// - [`DeviceImageMemoryRequirements`]
/// - [`SparseImageMemoryRequirements2`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "vkGetDeviceImageSparseMemoryRequirements")]
pub type FNGetDeviceImageSparseMemoryRequirements = Option<
    for<'lt> unsafe extern "system" fn(
        device: Device,
        p_info: *const DeviceImageMemoryRequirements<'lt>,
        p_sparse_memory_requirement_count: *mut u32,
        p_sparse_memory_requirements: *mut SparseImageMemoryRequirements2<'lt>,
    ),
>;
///[vkGetPhysicalDeviceToolProperties](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceToolProperties.html) - Reports properties of tools active on the specified physical device
///# C Specifications
///Information about tools providing debugging, profiling, or similar services,
///active for a given physical device, can be obtained by calling:
///```c
///// Provided by VK_VERSION_1_3
///VkResult vkGetPhysicalDeviceToolProperties(
///    VkPhysicalDevice                            physicalDevice,
///    uint32_t*                                   pToolCount,
///    VkPhysicalDeviceToolProperties*             pToolProperties);
///```
///or the equivalent command
///```c
///// Provided by VK_EXT_tooling_info
///VkResult vkGetPhysicalDeviceToolPropertiesEXT(
///    VkPhysicalDevice                            physicalDevice,
///    uint32_t*                                   pToolCount,
///    VkPhysicalDeviceToolProperties*             pToolProperties);
///```
///# Parameters
/// - [`physical_device`] is the handle to the physical device to query for active tools.
/// - [`p_tool_count`] is a pointer to an integer describing the number of tools active on
///   [`physical_device`].
/// - [`p_tool_properties`] is either `NULL` or a pointer to an array of
///   [`PhysicalDeviceToolProperties`] structures.
///# Description
///If [`p_tool_properties`] is `NULL`, then the number of tools currently
///active on [`physical_device`] is returned in [`p_tool_count`].
///Otherwise, [`p_tool_count`] **must**  point to a variable set by the user to the
///number of elements in the [`p_tool_properties`] array, and on return the
///variable is overwritten with the number of structures actually written to
///[`p_tool_properties`].
///If [`p_tool_count`] is less than the number of currently active tools, at
///most [`p_tool_count`] structures will be written.The count and properties of active tools
/// **may**  change in response to events
///outside the scope of the specification.
///An application  **should**  assume these properties might change at any given
///time.
///## Valid Usage (Implicit)
/// - [`physical_device`] **must**  be a valid [`PhysicalDevice`] handle
/// - [`p_tool_count`] **must**  be a valid pointer to a `uint32_t` value
/// - If the value referenced by [`p_tool_count`] is not `0`, and [`p_tool_properties`] is not
///   `NULL`, [`p_tool_properties`] **must**  be a valid pointer to an array of
///   [`p_tool_count`][`PhysicalDeviceToolProperties`] structures
///
///## Return Codes
/// * - `VK_SUCCESS`  - `VK_INCOMPLETE`
/// * - `VK_ERROR_OUT_OF_HOST_MEMORY`
///# Related
/// - [`ext_tooling_info`]
/// - [`crate::vulkan1_3`]
/// - [`PhysicalDevice`]
/// - [`PhysicalDeviceToolProperties`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "vkGetPhysicalDeviceToolProperties")]
pub type FNGetPhysicalDeviceToolProperties = Option<
    for<'lt> unsafe extern "system" fn(
        physical_device: PhysicalDevice,
        p_tool_count: *mut u32,
        p_tool_properties: *mut PhysicalDeviceToolProperties<'lt>,
    ) -> VulkanResultCodes,
>;
///[vkCreatePrivateDataSlot](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreatePrivateDataSlot.html) - Create a slot for private data storage
///# C Specifications
///To create a private data slot, call:
///```c
///// Provided by VK_VERSION_1_3
///VkResult vkCreatePrivateDataSlot(
///    VkDevice                                    device,
///    const VkPrivateDataSlotCreateInfo*          pCreateInfo,
///    const VkAllocationCallbacks*                pAllocator,
///    VkPrivateDataSlot*                          pPrivateDataSlot);
///```
///or the equivalent command
///```c
///// Provided by VK_EXT_private_data
///VkResult vkCreatePrivateDataSlotEXT(
///    VkDevice                                    device,
///    const VkPrivateDataSlotCreateInfo*          pCreateInfo,
///    const VkAllocationCallbacks*                pAllocator,
///    VkPrivateDataSlot*                          pPrivateDataSlot);
///```
///# Parameters
/// - [`device`] is the logical device associated with the creation of the object(s) holding the
///   private data slot.
/// - [`p_create_info`] is a pointer to a [`PrivateDataSlotCreateInfo`]
/// - [`p_allocator`] controls host memory allocation as described in the [Memory Allocation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#memory-allocation)
///   chapter.
/// - [`p_private_data_slot`] is a pointer to a [`PrivateDataSlot`] handle in which the resulting
///   private data slot is returned
///# Description
///## Valid Usage
/// - The [`privateData`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-privateData)
///   feature  **must**  be enabled
///
///## Valid Usage (Implicit)
/// - [`device`] **must**  be a valid [`Device`] handle
/// - [`p_create_info`] **must**  be a valid pointer to a valid [`PrivateDataSlotCreateInfo`]
///   structure
/// - If [`p_allocator`] is not `NULL`, [`p_allocator`] **must**  be a valid pointer to a valid
///   [`AllocationCallbacks`] structure
/// - [`p_private_data_slot`] **must**  be a valid pointer to a [`PrivateDataSlot`] handle
///
///## Return Codes
/// * - `VK_SUCCESS`
/// * - `VK_ERROR_OUT_OF_HOST_MEMORY`
///# Related
/// - [`ext_private_data`]
/// - [`crate::vulkan1_3`]
/// - [`AllocationCallbacks`]
/// - [`Device`]
/// - [`PrivateDataSlot`]
/// - [`PrivateDataSlotCreateInfo`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "vkCreatePrivateDataSlot")]
pub type FNCreatePrivateDataSlot = Option<
    for<'lt> unsafe extern "system" fn(
        device: Device,
        p_create_info: *const PrivateDataSlotCreateInfo<'lt>,
        p_allocator: *const AllocationCallbacks<'lt>,
        p_private_data_slot: *mut PrivateDataSlot,
    ) -> VulkanResultCodes,
>;
///[vkDestroyPrivateDataSlot](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyPrivateDataSlot.html) - Destroy a private data slot
///# C Specifications
///To destroy a private data slot, call:
///```c
///// Provided by VK_VERSION_1_3
///void vkDestroyPrivateDataSlot(
///    VkDevice                                    device,
///    VkPrivateDataSlot                           privateDataSlot,
///    const VkAllocationCallbacks*                pAllocator);
///```
///or the equivalent command
///```c
///// Provided by VK_EXT_private_data
///void vkDestroyPrivateDataSlotEXT(
///    VkDevice                                    device,
///    VkPrivateDataSlot                           privateDataSlot,
///    const VkAllocationCallbacks*                pAllocator);
///```
///# Parameters
/// - [`device`] is the logical device associated with the creation of the object(s) holding the
///   private data slot.
/// - [`p_allocator`] controls host memory allocation as described in the [Memory Allocation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#memory-allocation)
///   chapter.
/// - [`private_data_slot`] is the private data slot to destroy.
///# Description
///## Valid Usage
/// - If [`AllocationCallbacks`] were provided when [`private_data_slot`] was created, a compatible
///   set of callbacks  **must**  be provided here
/// - If no [`AllocationCallbacks`] were provided when [`private_data_slot`] was created,
///   [`p_allocator`] **must**  be `NULL`
///
///## Valid Usage (Implicit)
/// - [`device`] **must**  be a valid [`Device`] handle
/// - If [`private_data_slot`] is not [`crate::Handle::null`], [`private_data_slot`] **must**  be a
///   valid [`PrivateDataSlot`] handle
/// - If [`p_allocator`] is not `NULL`, [`p_allocator`] **must**  be a valid pointer to a valid
///   [`AllocationCallbacks`] structure
/// - If [`private_data_slot`] is a valid handle, it  **must**  have been created, allocated, or
///   retrieved from [`device`]
///
///## Host Synchronization
/// - Host access to [`private_data_slot`] **must**  be externally synchronized
///# Related
/// - [`ext_private_data`]
/// - [`crate::vulkan1_3`]
/// - [`AllocationCallbacks`]
/// - [`Device`]
/// - [`PrivateDataSlot`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "vkDestroyPrivateDataSlot")]
pub type FNDestroyPrivateDataSlot = Option<
    for<'lt> unsafe extern "system" fn(
        device: Device,
        private_data_slot: PrivateDataSlot,
        p_allocator: *const AllocationCallbacks<'lt>,
    ),
>;
///[vkSetPrivateData](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkSetPrivateData.html) - Associate data with a Vulkan object
///# C Specifications
///To store user defined data in a slot associated with a Vulkan object, call:
///```c
///// Provided by VK_VERSION_1_3
///VkResult vkSetPrivateData(
///    VkDevice                                    device,
///    VkObjectType                                objectType,
///    uint64_t                                    objectHandle,
///    VkPrivateDataSlot                           privateDataSlot,
///    uint64_t                                    data);
///```
///or the equivalent command
///```c
///// Provided by VK_EXT_private_data
///VkResult vkSetPrivateDataEXT(
///    VkDevice                                    device,
///    VkObjectType                                objectType,
///    uint64_t                                    objectHandle,
///    VkPrivateDataSlot                           privateDataSlot,
///    uint64_t                                    data);
///```
///# Parameters
/// - [`device`] is the device that created the object.
/// - [`object_type`] is a [`ObjectType`] specifying the type of object to associate data with.
/// - [`object_handle`] is a handle to the object to associate data with.
/// - [`private_data_slot`] is a handle to a [`PrivateDataSlot`] specifying location of private data
///   storage.
/// - [`data`] is user defined data to associate the object with. This data will be stored at
///   [`private_data_slot`].
///# Description
///## Valid Usage
/// - [`object_handle`] **must**  be [`device`] or a child of [`device`]
/// - [`object_handle`] **must**  be a valid handle to an object of type [`object_type`]
///
///## Valid Usage (Implicit)
/// - [`device`] **must**  be a valid [`Device`] handle
/// - [`object_type`] **must**  be a valid [`ObjectType`] value
/// - [`private_data_slot`] **must**  be a valid [`PrivateDataSlot`] handle
/// - [`private_data_slot`] **must**  have been created, allocated, or retrieved from [`device`]
///
///## Return Codes
/// * - `VK_SUCCESS`
/// * - `VK_ERROR_OUT_OF_HOST_MEMORY`
///# Related
/// - [`ext_private_data`]
/// - [`crate::vulkan1_3`]
/// - [`Device`]
/// - [`ObjectType`]
/// - [`PrivateDataSlot`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "vkSetPrivateData")]
pub type FNSetPrivateData = Option<
    unsafe extern "system" fn(
        device: Device,
        object_type: ObjectType,
        object_handle: u64,
        private_data_slot: PrivateDataSlot,
        data: u64,
    ) -> VulkanResultCodes,
>;
///[vkGetPrivateData](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPrivateData.html) - Retrieve data associated with a Vulkan object
///# C Specifications
///To retrieve user defined data from a slot associated with a Vulkan object,
///call:
///```c
///// Provided by VK_VERSION_1_3
///void vkGetPrivateData(
///    VkDevice                                    device,
///    VkObjectType                                objectType,
///    uint64_t                                    objectHandle,
///    VkPrivateDataSlot                           privateDataSlot,
///    uint64_t*                                   pData);
///```
///or the equivalent command
///```c
///// Provided by VK_EXT_private_data
///void vkGetPrivateDataEXT(
///    VkDevice                                    device,
///    VkObjectType                                objectType,
///    uint64_t                                    objectHandle,
///    VkPrivateDataSlot                           privateDataSlot,
///    uint64_t*                                   pData);
///```
///# Parameters
/// - [`device`] is the device that created the object
/// - [`object_type`] is a [`ObjectType`] specifying the type of object data is associated with.
/// - [`object_handle`] is a handle to the object data is associated with.
/// - [`private_data_slot`] is a handle to a [`PrivateDataSlot`] specifying location of private data
///   pointer storage.
/// - [`p_data`] is a pointer to specify where user data is returned. `0` will be written in the
///   absence of a previous call to [`set_private_data`] using the object specified by
///   [`object_handle`].
///# Description
///## Valid Usage
/// - [`object_type`] **must**  be `VK_OBJECT_TYPE_DEVICE`, or an object type whose parent is
///   [`Device`]
///
///## Valid Usage (Implicit)
/// - [`device`] **must**  be a valid [`Device`] handle
/// - [`object_type`] **must**  be a valid [`ObjectType`] value
/// - [`private_data_slot`] **must**  be a valid [`PrivateDataSlot`] handle
/// - [`p_data`] **must**  be a valid pointer to a `uint64_t` value
/// - [`private_data_slot`] **must**  have been created, allocated, or retrieved from [`device`]
///# Related
/// - [`ext_private_data`]
/// - [`crate::vulkan1_3`]
/// - [`Device`]
/// - [`ObjectType`]
/// - [`PrivateDataSlot`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "vkGetPrivateData")]
pub type FNGetPrivateData = Option<
    unsafe extern "system" fn(
        device: Device,
        object_type: ObjectType,
        object_handle: u64,
        private_data_slot: PrivateDataSlot,
        p_data: *mut u64,
    ),
>;
///[vkQueueSubmit2](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkQueueSubmit2.html) - Submits command buffers to a queue
///# C Specifications
///To submit command buffers to a queue, call:
///```c
///// Provided by VK_VERSION_1_3
///VkResult vkQueueSubmit2(
///    VkQueue                                     queue,
///    uint32_t                                    submitCount,
///    const VkSubmitInfo2*                        pSubmits,
///    VkFence                                     fence);
///```
///or the equivalent command
///```c
///// Provided by VK_KHR_synchronization2
///VkResult vkQueueSubmit2KHR(
///    VkQueue                                     queue,
///    uint32_t                                    submitCount,
///    const VkSubmitInfo2*                        pSubmits,
///    VkFence                                     fence);
///```
///# Parameters
/// - [`queue`] is the queue that the command buffers will be submitted to.
/// - [`submit_count`] is the number of elements in the [`p_submits`] array.
/// - [`p_submits`] is a pointer to an array of [`SubmitInfo2`] structures, each specifying a
///   command buffer submission batch.
/// - [`fence`] is an  **optional**  handle to a fence to be signaled once all submitted command buffers have completed execution. If [`fence`] is not [`crate::Handle::null`], it defines a [fence signal operation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-fences-signaling).
///# Description
///[`queue_submit2`] is a [queue submission
///command](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#devsandqueues-submission), with each batch defined by an element of [`p_submits`].Semaphore operations submitted with [`queue_submit2`] have additional
///ordering constraints compared to other submission commands, with
///dependencies involving previous and subsequent queue operations.
///Information about these additional constraints can be found in the
///[semaphore](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-semaphores) section of [the
///synchronization chapter](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization).If any command buffer submitted to this queue is in the
///[executable state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#commandbuffers-lifecycle), it is moved to the
///[pending state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#commandbuffers-lifecycle).
///Once execution of all submissions of a command buffer complete, it moves
///from the [pending state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#commandbuffers-lifecycle), back to the
///[executable state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#commandbuffers-lifecycle).
///If a command buffer was recorded with the
///`VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT` flag, it instead moves
///back to the [invalid state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#commandbuffers-lifecycle).If [`queue_submit2`] fails, it  **may**  return
///`VK_ERROR_OUT_OF_HOST_MEMORY` or `VK_ERROR_OUT_OF_DEVICE_MEMORY`.
///If it does, the implementation  **must**  ensure that the state and contents of
///any resources or synchronization primitives referenced by the submitted
///command buffers and any semaphores referenced by [`p_submits`] is
///unaffected by the call or its failure.
///If [`queue_submit2`] fails in such a way that the implementation is
///unable to make that guarantee, the implementation  **must**  return
///`VK_ERROR_DEVICE_LOST`.
///See [Lost Device](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#devsandqueues-lost-device).
///## Valid Usage
/// - If [`fence`] is not [`crate::Handle::null`], [`fence`] **must**  be unsignaled
/// - If [`fence`] is not [`crate::Handle::null`], [`fence`] **must**  not be associated with any
///   other queue command that has not yet completed execution on that queue
/// - The [`synchronization2`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-synchronization2)
///   feature  **must**  be enabled
/// - If a command recorded into the `commandBuffer` member of any element of the
///   `pCommandBufferInfos` member of any element of [`p_submits`] referenced an [`Event`], that
///   event  **must**  not be referenced by a command that has been submitted to another queue and
///   is still in the *pending state*
/// - The `semaphore` member of any binary semaphore element of the `pSignalSemaphoreInfos` member
///   of any element of [`p_submits`] **must**  be unsignaled when the semaphore signal operation it
///   defines is executed on the device
/// - The `stageMask` member of any element of the `pSignalSemaphoreInfos` member of any element of
///   [`p_submits`] **must**  only include pipeline stages that are supported by the queue family
///   which [`queue`] belongs to
/// - The `stageMask` member of any element of the `pWaitSemaphoreInfos` member of any element of
///   [`p_submits`] **must**  only include pipeline stages that are supported by the queue family
///   which [`queue`] belongs to
/// - When a semaphore wait operation for a binary semaphore is executed, as defined by the
///   `semaphore` member of any element of the `pWaitSemaphoreInfos` member of any element of
///   [`p_submits`], there  **must**  be no other queues waiting on the same semaphore
/// -    The `semaphore` member of any element of the `pWaitSemaphoreInfos` member of any element of [`p_submits`] **must**  be semaphores that are signaled, or have [semaphore signal operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-semaphores-signaling) previously submitted for execution
/// - Any `semaphore` member of any element of the `pWaitSemaphoreInfos` member of any element of
///   [`p_submits`] that was created with a [`SemaphoreTypeKHR`] of `VK_SEMAPHORE_TYPE_BINARY_KHR`
///   **must**  reference a semaphore signal operation that has been submitted for execution and any
///   semaphore signal operations on which it depends (if any)  **must**  have also been submitted
///   for execution
/// -    The `commandBuffer` member of any element of the `pCommandBufferInfos` member of any element of [`p_submits`] **must**  be in the [pending or executable state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#commandbuffers-lifecycle)
/// -    If a command recorded into the `commandBuffer` member of any element of the `pCommandBufferInfos` member of any element of [`p_submits`] was not recorded with the `VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT`, it  **must**  not be in the [pending state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#commandbuffers-lifecycle)
/// -    Any [secondary command buffers recorded](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#commandbuffers-secondary) into the `commandBuffer` member of any element of the `pCommandBufferInfos` member of any element of [`p_submits`] **must**  be in the [pending or executable state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#commandbuffers-lifecycle)
/// -    If any [secondary command buffers recorded](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#commandbuffers-secondary) into the `commandBuffer` member of any element of the `pCommandBufferInfos` member of any element of [`p_submits`] was not recorded with the `VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT`, it  **must**  not be in the [pending state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#commandbuffers-lifecycle)
/// - The `commandBuffer` member of any element of the `pCommandBufferInfos` member of any element
///   of [`p_submits`] **must**  have been allocated from a [`CommandPool`] that was created for the
///   same queue family [`queue`] belongs to
/// -    If a command recorded into the `commandBuffer` member of any element of the `pCommandBufferInfos` member of any element of [`p_submits`] includes a [Queue Family Transfer Acquire Operation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-queue-transfers-acquire), there  **must**  exist a previously submitted [Queue Family Transfer Release Operation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-queue-transfers-release) on a queue in the queue family identified by the acquire operation, with parameters matching the acquire operation as defined in the definition of such [acquire operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-queue-transfers-acquire), and which happens before the acquire operation
/// -    If a command recorded into the `commandBuffer` member of any element of the `pCommandBufferInfos` member of any element of [`p_submits`] was a [`cmd_begin_query`] whose `queryPool` was created with a `queryType` of `VK_QUERY_TYPE_PERFORMANCE_QUERY_KHR`, the [profiling lock](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#profiling-lock) **must**  have been held continuously on the [`Device`] that [`queue`] was retrieved from, throughout recording of those command buffers
/// - If [`queue`] was not created with `VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT`, the `flags` member
///   of any element of [`p_submits`] **must**  not include `VK_SUBMIT_PROTECTED_BIT_KHR`
///
///## Valid Usage (Implicit)
/// - [`queue`] **must**  be a valid [`Queue`] handle
/// - If [`submit_count`] is not `0`, [`p_submits`] **must**  be a valid pointer to an array of
///   [`submit_count`] valid [`SubmitInfo2`] structures
/// - If [`fence`] is not [`crate::Handle::null`], [`fence`] **must**  be a valid [`Fence`] handle
/// - Both of [`fence`], and [`queue`] that are valid handles of non-ignored parameters  **must**
///   have been created, allocated, or retrieved from the same [`Device`]
///
///## Host Synchronization
/// - Host access to [`queue`] **must**  be externally synchronized
/// - Host access to [`fence`] **must**  be externally synchronized
///
///## Command Properties
///## Return Codes
/// * - `VK_SUCCESS`
/// * - `VK_ERROR_OUT_OF_HOST_MEMORY`  - `VK_ERROR_OUT_OF_DEVICE_MEMORY`  - `VK_ERROR_DEVICE_LOST`
///# Related
/// - [`khr_synchronization2`]
/// - [`crate::vulkan1_3`]
/// - [`Fence`]
/// - [`Queue`]
/// - [`SubmitInfo2`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "vkQueueSubmit2")]
pub type FNQueueSubmit2 = Option<
    for<'lt> unsafe extern "system" fn(
        queue: Queue,
        submit_count: u32,
        p_submits: *const SubmitInfo2<'lt>,
        fence: Fence,
    ) -> VulkanResultCodes,
>;
///[vkCmdSetCullMode](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetCullMode.html) - Set cull mode dynamically for a command buffer
///# C Specifications
///To [dynamically set](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipelines-dynamic-state) the cull mode, call:
///```c
///// Provided by VK_VERSION_1_3
///void vkCmdSetCullMode(
///    VkCommandBuffer                             commandBuffer,
///    VkCullModeFlags                             cullMode);
///```
///or the equivalent command
///```c
///// Provided by VK_EXT_extended_dynamic_state
///void vkCmdSetCullModeEXT(
///    VkCommandBuffer                             commandBuffer,
///    VkCullModeFlags                             cullMode);
///```
///# Parameters
/// - [`command_buffer`] is the command buffer into which the command will be recorded.
/// - [`cull_mode`] specifies the cull mode property to use for drawing.
///# Description
///This command sets the cull mode for subsequent drawing commands when the
///graphics pipeline is created with `VK_DYNAMIC_STATE_CULL_MODE` set in
///[`PipelineDynamicStateCreateInfo::dynamic_states`].
///Otherwise, this state is specified by the
///[`PipelineRasterizationStateCreateInfo`]::[`cull_mode`] value used to
///create the currently active pipeline.
///## Valid Usage (Implicit)
/// - [`command_buffer`] **must**  be a valid [`CommandBuffer`] handle
/// - [`cull_mode`] **must**  be a valid combination of [`CullModeFlagBits`] values
/// - [`command_buffer`] **must**  be in the [recording state]()
/// - The [`CommandPool`] that [`command_buffer`] was allocated from  **must**  support graphics
///   operations
///
///## Host Synchronization
/// - Host access to [`command_buffer`] **must**  be externally synchronized
/// - Host access to the [`CommandPool`] that [`command_buffer`] was allocated from  **must**  be
///   externally synchronized
///
///## Command Properties
///# Related
/// - [`ext_extended_dynamic_state`]
/// - [`crate::vulkan1_3`]
/// - [`CommandBuffer`]
/// - [`CullModeFlags`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "vkCmdSetCullMode")]
pub type FNCmdSetCullMode = Option<unsafe extern "system" fn(command_buffer: CommandBuffer, cull_mode: CullModeFlags)>;
///[vkCmdSetFrontFace](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetFrontFace.html) - Set front face orientation dynamically for a command buffer
///# C Specifications
///To [dynamically set](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipelines-dynamic-state) the front face orientation,
///call:
///```c
///// Provided by VK_VERSION_1_3
///void vkCmdSetFrontFace(
///    VkCommandBuffer                             commandBuffer,
///    VkFrontFace                                 frontFace);
///```
///or the equivalent command
///```c
///// Provided by VK_EXT_extended_dynamic_state
///void vkCmdSetFrontFaceEXT(
///    VkCommandBuffer                             commandBuffer,
///    VkFrontFace                                 frontFace);
///```
///# Parameters
/// - [`command_buffer`] is the command buffer into which the command will be recorded.
/// - [`front_face`] is a [`FrontFace`] value specifying the front-facing triangle orientation to be
///   used for culling.
///# Description
///This command sets the front face orientation for subsequent drawing commands
///when the graphics pipeline is created with `VK_DYNAMIC_STATE_FRONT_FACE`
///set in [`PipelineDynamicStateCreateInfo::dynamic_states`].
///Otherwise, this state is specified by the
///[`PipelineRasterizationStateCreateInfo`]::[`front_face`] value used to
///create the currently active pipeline.
///## Valid Usage (Implicit)
/// - [`command_buffer`] **must**  be a valid [`CommandBuffer`] handle
/// - [`front_face`] **must**  be a valid [`FrontFace`] value
/// - [`command_buffer`] **must**  be in the [recording state]()
/// - The [`CommandPool`] that [`command_buffer`] was allocated from  **must**  support graphics
///   operations
///
///## Host Synchronization
/// - Host access to [`command_buffer`] **must**  be externally synchronized
/// - Host access to the [`CommandPool`] that [`command_buffer`] was allocated from  **must**  be
///   externally synchronized
///
///## Command Properties
///# Related
/// - [`ext_extended_dynamic_state`]
/// - [`crate::vulkan1_3`]
/// - [`CommandBuffer`]
/// - [`FrontFace`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "vkCmdSetFrontFace")]
pub type FNCmdSetFrontFace = Option<unsafe extern "system" fn(command_buffer: CommandBuffer, front_face: FrontFace)>;
///[vkCmdSetPrimitiveTopology](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetPrimitiveTopology.html) - Set primitive topology state dynamically for a command buffer
///# C Specifications
///To [dynamically set](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipelines-dynamic-state) primitive topology, call:
///```c
///// Provided by VK_VERSION_1_3
///void vkCmdSetPrimitiveTopology(
///    VkCommandBuffer                             commandBuffer,
///    VkPrimitiveTopology                         primitiveTopology);
///```
///or the equivalent command
///```c
///// Provided by VK_EXT_extended_dynamic_state
///void vkCmdSetPrimitiveTopologyEXT(
///    VkCommandBuffer                             commandBuffer,
///    VkPrimitiveTopology                         primitiveTopology);
///```
///# Parameters
/// - [`command_buffer`] is the command buffer into which the command will be recorded.
/// - [`primitive_topology`] specifies the primitive topology to use for drawing.
///# Description
///This command sets the primitive topology for subsequent drawing commands
///when the graphics pipeline is created with
///`VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY` set in
///[`PipelineDynamicStateCreateInfo::dynamic_states`].
///Otherwise, this state is specified by the
///[`PipelineInputAssemblyStateCreateInfo::topology`] value used to
///create the currently active pipeline.
///## Valid Usage (Implicit)
/// - [`command_buffer`] **must**  be a valid [`CommandBuffer`] handle
/// - [`primitive_topology`] **must**  be a valid [`PrimitiveTopology`] value
/// - [`command_buffer`] **must**  be in the [recording state]()
/// - The [`CommandPool`] that [`command_buffer`] was allocated from  **must**  support graphics
///   operations
///
///## Host Synchronization
/// - Host access to [`command_buffer`] **must**  be externally synchronized
/// - Host access to the [`CommandPool`] that [`command_buffer`] was allocated from  **must**  be
///   externally synchronized
///
///## Command Properties
///# Related
/// - [`ext_extended_dynamic_state`]
/// - [`crate::vulkan1_3`]
/// - [`CommandBuffer`]
/// - [`PrimitiveTopology`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "vkCmdSetPrimitiveTopology")]
pub type FNCmdSetPrimitiveTopology =
    Option<unsafe extern "system" fn(command_buffer: CommandBuffer, primitive_topology: PrimitiveTopology)>;
///[vkCmdSetViewportWithCount](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetViewportWithCount.html) - Set the viewport count and viewports dynamically for a command buffer
///# C Specifications
///To [dynamically set](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipelines-dynamic-state) the viewport count and
///viewports, call:
///```c
///// Provided by VK_VERSION_1_3
///void vkCmdSetViewportWithCount(
///    VkCommandBuffer                             commandBuffer,
///    uint32_t                                    viewportCount,
///    const VkViewport*                           pViewports);
///```
///or the equivalent command
///```c
///// Provided by VK_EXT_extended_dynamic_state
///void vkCmdSetViewportWithCountEXT(
///    VkCommandBuffer                             commandBuffer,
///    uint32_t                                    viewportCount,
///    const VkViewport*                           pViewports);
///```
///# Parameters
/// - [`command_buffer`] is the command buffer into which the command will be recorded.
/// - [`viewport_count`] specifies the viewport count.
/// - [`p_viewports`] specifies the viewports to use for drawing.
///# Description
///This command sets the viewport count and viewports state for subsequent
///drawing commands when the graphics pipeline is created with
///`VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT` set in
///[`PipelineDynamicStateCreateInfo::dynamic_states`].
///Otherwise, this state is specified by the corresponding
///[`PipelineViewportStateCreateInfo`]::[`viewport_count`] and
///[`p_viewports`] values used to create the currently active pipeline.
///## Valid Usage
/// - [`viewport_count`] **must**  be between `1` and [`PhysicalDeviceLimits::max_viewports`],
///   inclusive
/// - If the [multiple viewports](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-multiViewport)
///   feature is not enabled, [`viewport_count`] **must**  be `1`
/// - [`command_buffer`] **must**  not have
///   [`CommandBufferInheritanceViewportScissorInfoNV::viewport_scissor2_d`] enabled
///
///## Valid Usage (Implicit)
/// - [`command_buffer`] **must**  be a valid [`CommandBuffer`] handle
/// - [`p_viewports`] **must**  be a valid pointer to an array of [`viewport_count`] valid
///   [`Viewport`] structures
/// - [`command_buffer`] **must**  be in the [recording state]()
/// - The [`CommandPool`] that [`command_buffer`] was allocated from  **must**  support graphics
///   operations
/// - [`viewport_count`] **must**  be greater than `0`
///
///## Host Synchronization
/// - Host access to [`command_buffer`] **must**  be externally synchronized
/// - Host access to the [`CommandPool`] that [`command_buffer`] was allocated from  **must**  be
///   externally synchronized
///
///## Command Properties
///# Related
/// - [`ext_extended_dynamic_state`]
/// - [`crate::vulkan1_3`]
/// - [`CommandBuffer`]
/// - [`Viewport`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "vkCmdSetViewportWithCount")]
pub type FNCmdSetViewportWithCount =
    Option<unsafe extern "system" fn(command_buffer: CommandBuffer, viewport_count: u32, p_viewports: *const Viewport)>;
///[vkCmdSetScissorWithCount](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetScissorWithCount.html) - Set the scissor count and scissor rectangular bounds dynamically for a command buffer
///# C Specifications
///To [dynamically set](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipelines-dynamic-state) the scissor count and
///scissor rectangular bounds, call:
///```c
///// Provided by VK_VERSION_1_3
///void vkCmdSetScissorWithCount(
///    VkCommandBuffer                             commandBuffer,
///    uint32_t                                    scissorCount,
///    const VkRect2D*                             pScissors);
///```
///or the equivalent command
///```c
///// Provided by VK_EXT_extended_dynamic_state
///void vkCmdSetScissorWithCountEXT(
///    VkCommandBuffer                             commandBuffer,
///    uint32_t                                    scissorCount,
///    const VkRect2D*                             pScissors);
///```
///# Parameters
/// - [`command_buffer`] is the command buffer into which the command will be recorded.
/// - [`scissor_count`] specifies the scissor count.
/// - [`p_scissors`] specifies the scissors to use for drawing.
///# Description
///This command sets the scissor count and scissor rectangular bounds state for
///subsequence drawing commands when the graphics pipeline is created with
///`VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT` set in
///[`PipelineDynamicStateCreateInfo::dynamic_states`].
///Otherwise, this state is specified by the corresponding
///[`PipelineViewportStateCreateInfo`]::[`scissor_count`] and
///[`p_scissors`] values used to create the currently active pipeline.
///## Valid Usage
/// - [`scissor_count`] **must**  be between `1` and [`PhysicalDeviceLimits::max_viewports`],
///   inclusive
/// - If the [multiple viewports](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-multiViewport)
///   feature is not enabled, [`scissor_count`] **must**  be `1`
/// - The `x` and `y` members of `offset` member of any element of [`p_scissors`] **must**  be
///   greater than or equal to `0`
/// - Evaluation of (`offset.x` +  `extent.width`) **must**  not cause a signed integer addition
///   overflow for any element of [`p_scissors`]
/// - Evaluation of (`offset.y` +  `extent.height`) **must**  not cause a signed integer addition
///   overflow for any element of [`p_scissors`]
/// - [`command_buffer`] **must**  not have
///   [`CommandBufferInheritanceViewportScissorInfoNV::viewport_scissor2_d`] enabled
///
///## Valid Usage (Implicit)
/// - [`command_buffer`] **must**  be a valid [`CommandBuffer`] handle
/// - [`p_scissors`] **must**  be a valid pointer to an array of [`scissor_count`][`Rect2D`]
///   structures
/// - [`command_buffer`] **must**  be in the [recording state]()
/// - The [`CommandPool`] that [`command_buffer`] was allocated from  **must**  support graphics
///   operations
/// - [`scissor_count`] **must**  be greater than `0`
///
///## Host Synchronization
/// - Host access to [`command_buffer`] **must**  be externally synchronized
/// - Host access to the [`CommandPool`] that [`command_buffer`] was allocated from  **must**  be
///   externally synchronized
///
///## Command Properties
///# Related
/// - [`ext_extended_dynamic_state`]
/// - [`crate::vulkan1_3`]
/// - [`CommandBuffer`]
/// - [`Rect2D`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "vkCmdSetScissorWithCount")]
pub type FNCmdSetScissorWithCount =
    Option<unsafe extern "system" fn(command_buffer: CommandBuffer, scissor_count: u32, p_scissors: *const Rect2D)>;
///[vkCmdBindVertexBuffers2](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBindVertexBuffers2.html) - Bind vertex buffers to a command buffer and dynamically set strides
///# C Specifications
///Alternatively, to bind vertex buffers, along with their sizes and strides,
///to a command buffer for use in subsequent drawing commands, call:
///```c
///// Provided by VK_VERSION_1_3
///void vkCmdBindVertexBuffers2(
///    VkCommandBuffer                             commandBuffer,
///    uint32_t                                    firstBinding,
///    uint32_t                                    bindingCount,
///    const VkBuffer*                             pBuffers,
///    const VkDeviceSize*                         pOffsets,
///    const VkDeviceSize*                         pSizes,
///    const VkDeviceSize*                         pStrides);
///```
///or the equivalent command
///```c
///// Provided by VK_EXT_extended_dynamic_state
///void vkCmdBindVertexBuffers2EXT(
///    VkCommandBuffer                             commandBuffer,
///    uint32_t                                    firstBinding,
///    uint32_t                                    bindingCount,
///    const VkBuffer*                             pBuffers,
///    const VkDeviceSize*                         pOffsets,
///    const VkDeviceSize*                         pSizes,
///    const VkDeviceSize*                         pStrides);
///```
///# Parameters
/// - [`command_buffer`] is the command buffer into which the command is recorded.
/// - [`first_binding`] is the index of the first vertex input binding whose state is updated by the
///   command.
/// - [`binding_count`] is the number of vertex input bindings whose state is updated by the
///   command.
/// - [`p_buffers`] is a pointer to an array of buffer handles.
/// - [`p_offsets`] is a pointer to an array of buffer offsets.
/// - [`p_sizes`] is `NULL` or a pointer to an array of the size in bytes of vertex data bound from
///   [`p_buffers`].
/// - [`p_strides`] is `NULL` or a pointer to an array of buffer strides.
///# Description
///The values taken from elements i of [`p_buffers`] and [`p_offsets`]
///replace the current state for the vertex input binding
///[`first_binding`] +  i, for i in [0,
///[`binding_count`]).
///The vertex input binding is updated to start at the offset indicated by
///[`p_offsets`][i] from the start of the buffer [`p_buffers`][i].
///If [`p_sizes`] is not `NULL` then [`p_sizes`][i] specifies the bound size
///of the vertex buffer starting from the corresponding elements of
///[`p_buffers`][i] plus [`p_offsets`][i].
///All vertex input attributes that use each of these bindings will use these
///updated addresses in their address calculations for subsequent drawing
///commands.
///If the [nullDescriptor](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-nullDescriptor) feature is enabled,
///elements of [`p_buffers`] **can**  be [`crate::Handle::null`], and  **can**  be used by
///the vertex shader.
///If a vertex input attribute is bound to a vertex input binding that is
///[`crate::Handle::null`], the values taken from memory are considered to be
///zero, and missing G, B, or A components are
///[filled with (0,0,1)](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#fxvertex-input-extraction).This command also [dynamically sets](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipelines-dynamic-state) the byte
///strides between consecutive elements within buffer [`p_buffers`][i] to the
///corresponding [`p_strides`][i] value when the graphics pipeline is created
///with `VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE` set in
///[`PipelineDynamicStateCreateInfo::dynamic_states`].
///Otherwise, strides are specified by the
///[`VertexInputBindingDescription::stride`] values used to create
///the currently active pipeline.If the bound pipeline state object was also created with the
///`VK_DYNAMIC_STATE_VERTEX_INPUT_EXT` dynamic state enabled then
///[`cmd_set_vertex_input_ext`] **can**  be used instead of
///[`cmd_bind_vertex_buffers2`] to set the stride.
///## Valid Usage
/// - [`first_binding`] **must**  be less than [`PhysicalDeviceLimits::max_vertex_input_bindings`]
/// - The sum of [`first_binding`] and [`binding_count`] **must**  be less than or equal to
///   [`PhysicalDeviceLimits::max_vertex_input_bindings`]
/// - All elements of [`p_offsets`] **must**  be less than the size of the corresponding element in
///   [`p_buffers`]
/// - If [`p_sizes`] is not `NULL`, all elements of [`p_offsets`] plus [`p_sizes`] **must**  be less
///   than or equal to the size of the corresponding element in [`p_buffers`]
/// - All elements of [`p_buffers`] **must**  have been created with the
///   `VK_BUFFER_USAGE_VERTEX_BUFFER_BIT` flag
/// - Each element of [`p_buffers`] that is non-sparse  **must**  be bound completely and
///   contiguously to a single [`DeviceMemory`] object
/// - If the [nullDescriptor](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-nullDescriptor)
///   feature is not enabled, all elements of [`p_buffers`] **must**  not be [`crate::Handle::null`]
/// - If an element of [`p_buffers`] is [`crate::Handle::null`], then the corresponding element of
///   [`p_offsets`] **must**  be zero
/// - If [`p_strides`] is not `NULL` each element of [`p_strides`] **must**  be less than or equal
///   to [`PhysicalDeviceLimits::max_vertex_input_binding_stride`]
/// - If [`p_strides`] is not `NULL` each element of [`p_strides`] **must**  be either 0 or greater
///   than or equal to the maximum extent of all vertex input attributes fetched from the
///   corresponding binding, where the extent is calculated as the
///   [`VertexInputAttributeDescription::offset`] plus [`VertexInputAttributeDescription::format`]
///   size
///
///## Valid Usage (Implicit)
/// - [`command_buffer`] **must**  be a valid [`CommandBuffer`] handle
/// - [`p_buffers`] **must**  be a valid pointer to an array of [`binding_count`] valid or
///   [`crate::Handle::null`][`Buffer`] handles
/// - [`p_offsets`] **must**  be a valid pointer to an array of [`binding_count`][`DeviceSize`]
///   values
/// - If [`p_sizes`] is not `NULL`, [`p_sizes`] **must**  be a valid pointer to an array of
///   [`binding_count`][`DeviceSize`] values
/// - If [`p_strides`] is not `NULL`, [`p_strides`] **must**  be a valid pointer to an array of
///   [`binding_count`][`DeviceSize`] values
/// - [`command_buffer`] **must**  be in the [recording state]()
/// - The [`CommandPool`] that [`command_buffer`] was allocated from  **must**  support graphics
///   operations
/// - If any of [`p_sizes`], or [`p_strides`] are not `NULL`, [`binding_count`] **must**  be greater
///   than `0`
/// - Both of [`command_buffer`], and the elements of [`p_buffers`] that are valid handles of
///   non-ignored parameters  **must**  have been created, allocated, or retrieved from the same
///   [`Device`]
///
///## Host Synchronization
/// - Host access to [`command_buffer`] **must**  be externally synchronized
/// - Host access to the [`CommandPool`] that [`command_buffer`] was allocated from  **must**  be
///   externally synchronized
///
///## Command Properties
///# Related
/// - [`ext_extended_dynamic_state`]
/// - [`crate::vulkan1_3`]
/// - [`Buffer`]
/// - [`CommandBuffer`]
/// - [`DeviceSize`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "vkCmdBindVertexBuffers2")]
pub type FNCmdBindVertexBuffers2 = Option<
    unsafe extern "system" fn(
        command_buffer: CommandBuffer,
        first_binding: u32,
        binding_count: u32,
        p_buffers: *const Buffer,
        p_offsets: *const DeviceSize,
        p_sizes: *const DeviceSize,
        p_strides: *const DeviceSize,
    ),
>;
///[vkCmdSetDepthTestEnable](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDepthTestEnable.html) - Set depth test enable dynamically for a command buffer
///# C Specifications
///To [dynamically enable or disable](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipelines-dynamic-state) the depth
///test, call:
///```c
///// Provided by VK_VERSION_1_3
///void vkCmdSetDepthTestEnable(
///    VkCommandBuffer                             commandBuffer,
///    VkBool32                                    depthTestEnable);
///```
///or the equivalent command
///```c
///// Provided by VK_EXT_extended_dynamic_state
///void vkCmdSetDepthTestEnableEXT(
///    VkCommandBuffer                             commandBuffer,
///    VkBool32                                    depthTestEnable);
///```
///# Parameters
/// - [`command_buffer`] is the command buffer into which the command will be recorded.
/// - [`depth_test_enable`] specifies if the depth test is enabled.
///# Description
///This command sets the depth test enable for subsequent drawing commands when
///the graphics pipeline is created with
///`VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE` set in
///[`PipelineDynamicStateCreateInfo::dynamic_states`].
///Otherwise, this state is specified by the
///[`PipelineDepthStencilStateCreateInfo`]::[`depth_test_enable`] value
///used to create the currently active pipeline.
///## Valid Usage (Implicit)
/// - [`command_buffer`] **must**  be a valid [`CommandBuffer`] handle
/// - [`command_buffer`] **must**  be in the [recording state]()
/// - The [`CommandPool`] that [`command_buffer`] was allocated from  **must**  support graphics
///   operations
///
///## Host Synchronization
/// - Host access to [`command_buffer`] **must**  be externally synchronized
/// - Host access to the [`CommandPool`] that [`command_buffer`] was allocated from  **must**  be
///   externally synchronized
///
///## Command Properties
///# Related
/// - [`ext_extended_dynamic_state`]
/// - [`crate::vulkan1_3`]
/// - [`Bool32`]
/// - [`CommandBuffer`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "vkCmdSetDepthTestEnable")]
pub type FNCmdSetDepthTestEnable =
    Option<unsafe extern "system" fn(command_buffer: CommandBuffer, depth_test_enable: Bool32)>;
///[vkCmdSetDepthWriteEnable](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDepthWriteEnable.html) - Set depth write enable dynamically for a command buffer
///# C Specifications
///To [dynamically set](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipelines-dynamic-state) the depth write enable,
///call:
///```c
///// Provided by VK_VERSION_1_3
///void vkCmdSetDepthWriteEnable(
///    VkCommandBuffer                             commandBuffer,
///    VkBool32                                    depthWriteEnable);
///```
///or the equivalent command
///```c
///// Provided by VK_EXT_extended_dynamic_state
///void vkCmdSetDepthWriteEnableEXT(
///    VkCommandBuffer                             commandBuffer,
///    VkBool32                                    depthWriteEnable);
///```
///# Parameters
/// - [`command_buffer`] is the command buffer into which the command will be recorded.
/// - [`depth_write_enable`] specifies if depth writes are enabled.
///# Description
///This command sets the depth write enable for subsequent drawing commands
///when the graphics pipeline is created with
///`VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE` set in
///[`PipelineDynamicStateCreateInfo::dynamic_states`].
///Otherwise, this state is specified by the
///[`PipelineDepthStencilStateCreateInfo`]::[`depth_write_enable`] value
///used to create the currently active pipeline.
///## Valid Usage (Implicit)
/// - [`command_buffer`] **must**  be a valid [`CommandBuffer`] handle
/// - [`command_buffer`] **must**  be in the [recording state]()
/// - The [`CommandPool`] that [`command_buffer`] was allocated from  **must**  support graphics
///   operations
///
///## Host Synchronization
/// - Host access to [`command_buffer`] **must**  be externally synchronized
/// - Host access to the [`CommandPool`] that [`command_buffer`] was allocated from  **must**  be
///   externally synchronized
///
///## Command Properties
///# Related
/// - [`ext_extended_dynamic_state`]
/// - [`crate::vulkan1_3`]
/// - [`Bool32`]
/// - [`CommandBuffer`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "vkCmdSetDepthWriteEnable")]
pub type FNCmdSetDepthWriteEnable =
    Option<unsafe extern "system" fn(command_buffer: CommandBuffer, depth_write_enable: Bool32)>;
///[vkCmdSetDepthCompareOp](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDepthCompareOp.html) - Set depth comparison operator dynamically for a command buffer
///# C Specifications
///To [dynamically set](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipelines-dynamic-state) the depth compare operator,
///call:
///```c
///// Provided by VK_VERSION_1_3
///void vkCmdSetDepthCompareOp(
///    VkCommandBuffer                             commandBuffer,
///    VkCompareOp                                 depthCompareOp);
///```
///or the equivalent command
///```c
///// Provided by VK_EXT_extended_dynamic_state
///void vkCmdSetDepthCompareOpEXT(
///    VkCommandBuffer                             commandBuffer,
///    VkCompareOp                                 depthCompareOp);
///```
///# Parameters
/// - [`command_buffer`] is the command buffer into which the command will be recorded.
/// - [`depth_compare_op`] specifies the depth comparison operator.
///# Description
///This command sets the depth comparison operator for subsequent drawing
///commands when the graphics pipeline is created with
///`VK_DYNAMIC_STATE_DEPTH_COMPARE_OP` set in
///[`PipelineDynamicStateCreateInfo::dynamic_states`].
///Otherwise, this state is specified by the
///[`PipelineDepthStencilStateCreateInfo`]::[`depth_compare_op`] value used
///to create the currently active pipeline.
///## Valid Usage (Implicit)
/// - [`command_buffer`] **must**  be a valid [`CommandBuffer`] handle
/// - [`depth_compare_op`] **must**  be a valid [`CompareOp`] value
/// - [`command_buffer`] **must**  be in the [recording state]()
/// - The [`CommandPool`] that [`command_buffer`] was allocated from  **must**  support graphics
///   operations
///
///## Host Synchronization
/// - Host access to [`command_buffer`] **must**  be externally synchronized
/// - Host access to the [`CommandPool`] that [`command_buffer`] was allocated from  **must**  be
///   externally synchronized
///
///## Command Properties
///# Related
/// - [`ext_extended_dynamic_state`]
/// - [`crate::vulkan1_3`]
/// - [`CommandBuffer`]
/// - [`CompareOp`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "vkCmdSetDepthCompareOp")]
pub type FNCmdSetDepthCompareOp =
    Option<unsafe extern "system" fn(command_buffer: CommandBuffer, depth_compare_op: CompareOp)>;
///[vkCmdSetDepthBoundsTestEnable](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDepthBoundsTestEnable.html) - Set depth bounds test enable dynamically for a command buffer
///# C Specifications
///To [dynamically enable or disable](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipelines-dynamic-state) the depth
///bounds test, call:
///```c
///// Provided by VK_VERSION_1_3
///void vkCmdSetDepthBoundsTestEnable(
///    VkCommandBuffer                             commandBuffer,
///    VkBool32                                    depthBoundsTestEnable);
///```
///or the equivalent command
///```c
///// Provided by VK_EXT_extended_dynamic_state
///void vkCmdSetDepthBoundsTestEnableEXT(
///    VkCommandBuffer                             commandBuffer,
///    VkBool32                                    depthBoundsTestEnable);
///```
///# Parameters
/// - [`command_buffer`] is the command buffer into which the command will be recorded.
/// - [`depth_bounds_test_enable`] specifies if the depth bounds test is enabled.
///# Description
///This command sets the depth bounds enable for subsequent drawing commands
///when the graphics pipeline is created with
///`VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE` set in
///[`PipelineDynamicStateCreateInfo::dynamic_states`].
///Otherwise, this state is specified by the
///[`PipelineDepthStencilStateCreateInfo`]::[`depth_bounds_test_enable`]
///value used to create the currently active pipeline.
///## Valid Usage (Implicit)
/// - [`command_buffer`] **must**  be a valid [`CommandBuffer`] handle
/// - [`command_buffer`] **must**  be in the [recording state]()
/// - The [`CommandPool`] that [`command_buffer`] was allocated from  **must**  support graphics
///   operations
///
///## Host Synchronization
/// - Host access to [`command_buffer`] **must**  be externally synchronized
/// - Host access to the [`CommandPool`] that [`command_buffer`] was allocated from  **must**  be
///   externally synchronized
///
///## Command Properties
///# Related
/// - [`ext_extended_dynamic_state`]
/// - [`crate::vulkan1_3`]
/// - [`Bool32`]
/// - [`CommandBuffer`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "vkCmdSetDepthBoundsTestEnable")]
pub type FNCmdSetDepthBoundsTestEnable =
    Option<unsafe extern "system" fn(command_buffer: CommandBuffer, depth_bounds_test_enable: Bool32)>;
///[vkCmdSetStencilTestEnable](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetStencilTestEnable.html) - Set stencil test enable dynamically for a command buffer
///# C Specifications
///To [dynamically enable or disable](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipelines-dynamic-state) the stencil
///test, call:
///```c
///// Provided by VK_VERSION_1_3
///void vkCmdSetStencilTestEnable(
///    VkCommandBuffer                             commandBuffer,
///    VkBool32                                    stencilTestEnable);
///```
///or the equivalent command
///```c
///// Provided by VK_EXT_extended_dynamic_state
///void vkCmdSetStencilTestEnableEXT(
///    VkCommandBuffer                             commandBuffer,
///    VkBool32                                    stencilTestEnable);
///```
///# Parameters
/// - [`command_buffer`] is the command buffer into which the command will be recorded.
/// - [`stencil_test_enable`] specifies if the stencil test is enabled.
///# Description
///This command sets the stencil test enable for subsequent drawing commands
///when the graphics pipeline is created with
///`VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE` set in
///[`PipelineDynamicStateCreateInfo::dynamic_states`].
///Otherwise, this state is specified by the
///[`PipelineDepthStencilStateCreateInfo`]::[`stencil_test_enable`] value
///used to create the currently active pipeline.
///## Valid Usage (Implicit)
/// - [`command_buffer`] **must**  be a valid [`CommandBuffer`] handle
/// - [`command_buffer`] **must**  be in the [recording state]()
/// - The [`CommandPool`] that [`command_buffer`] was allocated from  **must**  support graphics
///   operations
///
///## Host Synchronization
/// - Host access to [`command_buffer`] **must**  be externally synchronized
/// - Host access to the [`CommandPool`] that [`command_buffer`] was allocated from  **must**  be
///   externally synchronized
///
///## Command Properties
///# Related
/// - [`ext_extended_dynamic_state`]
/// - [`crate::vulkan1_3`]
/// - [`Bool32`]
/// - [`CommandBuffer`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "vkCmdSetStencilTestEnable")]
pub type FNCmdSetStencilTestEnable =
    Option<unsafe extern "system" fn(command_buffer: CommandBuffer, stencil_test_enable: Bool32)>;
///[vkCmdSetStencilOp](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetStencilOp.html) - Set stencil operation dynamically for a command buffer
///# C Specifications
///To [dynamically set](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipelines-dynamic-state) the stencil operation, call:
///```c
///// Provided by VK_VERSION_1_3
///void vkCmdSetStencilOp(
///    VkCommandBuffer                             commandBuffer,
///    VkStencilFaceFlags                          faceMask,
///    VkStencilOp                                 failOp,
///    VkStencilOp                                 passOp,
///    VkStencilOp                                 depthFailOp,
///    VkCompareOp                                 compareOp);
///```
///or the equivalent command
///```c
///// Provided by VK_EXT_extended_dynamic_state
///void vkCmdSetStencilOpEXT(
///    VkCommandBuffer                             commandBuffer,
///    VkStencilFaceFlags                          faceMask,
///    VkStencilOp                                 failOp,
///    VkStencilOp                                 passOp,
///    VkStencilOp                                 depthFailOp,
///    VkCompareOp                                 compareOp);
///```
///# Parameters
/// - [`command_buffer`] is the command buffer into which the command will be recorded.
/// - [`face_mask`] is a bitmask of [`StencilFaceFlagBits`] specifying the set of stencil state for
///   which to update the stencil operation.
/// - [`fail_op`] is a [`StencilOp`] value specifying the action performed on samples that fail the
///   stencil test.
/// - [`pass_op`] is a [`StencilOp`] value specifying the action performed on samples that pass both
///   the depth and stencil tests.
/// - [`depth_fail_op`] is a [`StencilOp`] value specifying the action performed on samples that
///   pass the stencil test and fail the depth test.
/// - [`compare_op`] is a [`CompareOp`] value specifying the comparison operator used in the stencil
///   test.
///# Description
///This command sets the stencil operation for subsequent drawing commands when
///the graphics pipeline is created with `VK_DYNAMIC_STATE_STENCIL_OP` set
///in [`PipelineDynamicStateCreateInfo::dynamic_states`].
///Otherwise, this state is specified by the corresponding
///[`PipelineDepthStencilStateCreateInfo`]::[`fail_op`], [`pass_op`],
///[`depth_fail_op`], and [`compare_op`] values used to create the currently
///active pipeline, for both front and back faces.
///## Valid Usage (Implicit)
/// - [`command_buffer`] **must**  be a valid [`CommandBuffer`] handle
/// - [`face_mask`] **must**  be a valid combination of [`StencilFaceFlagBits`] values
/// - [`face_mask`] **must**  not be `0`
/// - [`fail_op`] **must**  be a valid [`StencilOp`] value
/// - [`pass_op`] **must**  be a valid [`StencilOp`] value
/// - [`depth_fail_op`] **must**  be a valid [`StencilOp`] value
/// - [`compare_op`] **must**  be a valid [`CompareOp`] value
/// - [`command_buffer`] **must**  be in the [recording state]()
/// - The [`CommandPool`] that [`command_buffer`] was allocated from  **must**  support graphics
///   operations
///
///## Host Synchronization
/// - Host access to [`command_buffer`] **must**  be externally synchronized
/// - Host access to the [`CommandPool`] that [`command_buffer`] was allocated from  **must**  be
///   externally synchronized
///
///## Command Properties
///# Related
/// - [`ext_extended_dynamic_state`]
/// - [`crate::vulkan1_3`]
/// - [`CommandBuffer`]
/// - [`CompareOp`]
/// - [`StencilFaceFlags`]
/// - [`StencilOp`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "vkCmdSetStencilOp")]
pub type FNCmdSetStencilOp = Option<
    unsafe extern "system" fn(
        command_buffer: CommandBuffer,
        face_mask: StencilFaceFlags,
        fail_op: StencilOp,
        pass_op: StencilOp,
        depth_fail_op: StencilOp,
        compare_op: CompareOp,
    ),
>;
///[vkCmdSetRasterizerDiscardEnable](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetRasterizerDiscardEnable.html) - Control whether primitives are discarded before the rasterization stage dynamically for a command buffer
///# C Specifications
///To [dynamically enable](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipelines-dynamic-state) whether primitives are
///discarded before the rasterization stage, call:
///```c
///// Provided by VK_VERSION_1_3
///void vkCmdSetRasterizerDiscardEnable(
///    VkCommandBuffer                             commandBuffer,
///    VkBool32                                    rasterizerDiscardEnable);
///```
///or the equivalent command
///```c
///// Provided by VK_EXT_extended_dynamic_state2
///void vkCmdSetRasterizerDiscardEnableEXT(
///    VkCommandBuffer                             commandBuffer,
///    VkBool32                                    rasterizerDiscardEnable);
///```
///# Parameters
/// - [`command_buffer`] is the command buffer into which the command will be recorded.
/// - [`rasterizer_discard_enable`] controls whether primitives are discarded immediately before the
///   rasterization stage.
///# Description
///This command sets the discard enable for subsequent drawing commands when
///the graphics pipeline is created with
///`VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE` set in
///[`PipelineDynamicStateCreateInfo::dynamic_states`].
///Otherwise, this state is specified by the
///[`PipelineRasterizationStateCreateInfo`]::[`rasterizer_discard_enable`]
///value used to create the currently active pipeline.
///## Valid Usage (Implicit)
/// - [`command_buffer`] **must**  be a valid [`CommandBuffer`] handle
/// - [`command_buffer`] **must**  be in the [recording state]()
/// - The [`CommandPool`] that [`command_buffer`] was allocated from  **must**  support graphics
///   operations
///
///## Host Synchronization
/// - Host access to [`command_buffer`] **must**  be externally synchronized
/// - Host access to the [`CommandPool`] that [`command_buffer`] was allocated from  **must**  be
///   externally synchronized
///
///## Command Properties
///# Related
/// - [`ext_extended_dynamic_state2`]
/// - [`crate::vulkan1_3`]
/// - [`Bool32`]
/// - [`CommandBuffer`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "vkCmdSetRasterizerDiscardEnable")]
pub type FNCmdSetRasterizerDiscardEnable =
    Option<unsafe extern "system" fn(command_buffer: CommandBuffer, rasterizer_discard_enable: Bool32)>;
///[vkCmdSetDepthBiasEnable](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDepthBiasEnable.html) - Control whether to bias fragment depth values dynamically for a command buffer
///# C Specifications
///To [dynamically enable](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipelines-dynamic-state) whether to bias fragment
///depth values, call:
///```c
///// Provided by VK_VERSION_1_3
///void vkCmdSetDepthBiasEnable(
///    VkCommandBuffer                             commandBuffer,
///    VkBool32                                    depthBiasEnable);
///```
///or the equivalent command
///```c
///// Provided by VK_EXT_extended_dynamic_state2
///void vkCmdSetDepthBiasEnableEXT(
///    VkCommandBuffer                             commandBuffer,
///    VkBool32                                    depthBiasEnable);
///```
///# Parameters
/// - [`command_buffer`] is the command buffer into which the command will be recorded.
/// - [`depth_bias_enable`] controls whether to bias fragment depth values.
///# Description
///This command sets the depth bias enable for subsequent drawing commands when
///the graphics pipeline is created with
///`VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE` set in
///[`PipelineDynamicStateCreateInfo::dynamic_states`].
///Otherwise, this state is specified by the
///[`PipelineRasterizationStateCreateInfo`]::[`depth_bias_enable`] value
///used to create the currently active pipeline.
///## Valid Usage (Implicit)
/// - [`command_buffer`] **must**  be a valid [`CommandBuffer`] handle
/// - [`command_buffer`] **must**  be in the [recording state]()
/// - The [`CommandPool`] that [`command_buffer`] was allocated from  **must**  support graphics
///   operations
///
///## Host Synchronization
/// - Host access to [`command_buffer`] **must**  be externally synchronized
/// - Host access to the [`CommandPool`] that [`command_buffer`] was allocated from  **must**  be
///   externally synchronized
///
///## Command Properties
///# Related
/// - [`ext_extended_dynamic_state2`]
/// - [`crate::vulkan1_3`]
/// - [`Bool32`]
/// - [`CommandBuffer`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "vkCmdSetDepthBiasEnable")]
pub type FNCmdSetDepthBiasEnable =
    Option<unsafe extern "system" fn(command_buffer: CommandBuffer, depth_bias_enable: Bool32)>;
///[vkCmdSetPrimitiveRestartEnable](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetPrimitiveRestartEnable.html) - Set primitive assembly restart state dynamically for a command buffer
///# C Specifications
///To [dynamically control](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipelines-dynamic-state) whether a special vertex
///index value is treated as restarting the assembly of primitives, call:
///```c
///// Provided by VK_VERSION_1_3
///void vkCmdSetPrimitiveRestartEnable(
///    VkCommandBuffer                             commandBuffer,
///    VkBool32                                    primitiveRestartEnable);
///```
///or the equivalent command
///```c
///// Provided by VK_EXT_extended_dynamic_state2
///void vkCmdSetPrimitiveRestartEnableEXT(
///    VkCommandBuffer                             commandBuffer,
///    VkBool32                                    primitiveRestartEnable);
///```
///# Parameters
/// - [`command_buffer`] is the command buffer into which the command will be recorded.
/// - [`primitive_restart_enable`] controls whether a special vertex index value is treated as
///   restarting the assembly of primitives. It behaves in the same way as
///   [`PipelineInputAssemblyStateCreateInfo`]::[`primitive_restart_enable`]
///# Description
///This command sets the primitive restart enable for subsequent drawing
///commands when the graphics pipeline is created with
///`VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE` set in
///[`PipelineDynamicStateCreateInfo::dynamic_states`].
///Otherwise, this state is specified by the
///[`PipelineInputAssemblyStateCreateInfo`]::[`primitive_restart_enable`]
///value used to create the currently active pipeline.
///## Valid Usage (Implicit)
/// - [`command_buffer`] **must**  be a valid [`CommandBuffer`] handle
/// - [`command_buffer`] **must**  be in the [recording state]()
/// - The [`CommandPool`] that [`command_buffer`] was allocated from  **must**  support graphics
///   operations
///
///## Host Synchronization
/// - Host access to [`command_buffer`] **must**  be externally synchronized
/// - Host access to the [`CommandPool`] that [`command_buffer`] was allocated from  **must**  be
///   externally synchronized
///
///## Command Properties
///# Related
/// - [`ext_extended_dynamic_state2`]
/// - [`crate::vulkan1_3`]
/// - [`Bool32`]
/// - [`CommandBuffer`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "vkCmdSetPrimitiveRestartEnable")]
pub type FNCmdSetPrimitiveRestartEnable =
    Option<unsafe extern "system" fn(command_buffer: CommandBuffer, primitive_restart_enable: Bool32)>;
///[vkCmdCopyBuffer2](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCopyBuffer2.html) - Copy data between buffer regions
///# C Specifications
///To copy data between buffer objects, call:
///```c
///// Provided by VK_VERSION_1_3
///void vkCmdCopyBuffer2(
///    VkCommandBuffer                             commandBuffer,
///    const VkCopyBufferInfo2*                    pCopyBufferInfo);
///```
///or the equivalent command
///```c
///// Provided by VK_KHR_copy_commands2
///void vkCmdCopyBuffer2KHR(
///    VkCommandBuffer                             commandBuffer,
///    const VkCopyBufferInfo2*                    pCopyBufferInfo);
///```
///# Parameters
/// - [`command_buffer`] is the command buffer into which the command will be recorded.
/// - [`p_copy_buffer_info`] is a pointer to a [`CopyBufferInfo2`] structure describing the copy
///   parameters.
///# Description
///This command is functionally identical to [`cmd_copy_buffer`], but
///includes extensible sub-structures that include `sType` and `pNext`
///parameters, allowing them to be more easily extended.
///## Valid Usage
/// - If [`command_buffer`] is an unprotected command buffer and [`protectedNoFault`]() is not
///   supported, `srcBuffer` **must**  not be a protected buffer
/// - If [`command_buffer`] is an unprotected command buffer and [`protectedNoFault`]() is not
///   supported, `dstBuffer` **must**  not be a protected buffer
/// - If [`command_buffer`] is a protected command buffer and [`protectedNoFault`]() is not
///   supported, `dstBuffer` **must**  not be an unprotected buffer
///
///## Valid Usage (Implicit)
/// - [`command_buffer`] **must**  be a valid [`CommandBuffer`] handle
/// - [`p_copy_buffer_info`] **must**  be a valid pointer to a valid [`CopyBufferInfo2`] structure
/// - [`command_buffer`] **must**  be in the [recording state]()
/// - The [`CommandPool`] that [`command_buffer`] was allocated from  **must**  support transfer,
///   graphics, or compute operations
/// - This command  **must**  only be called outside of a render pass instance
///
///## Host Synchronization
/// - Host access to [`command_buffer`] **must**  be externally synchronized
/// - Host access to the [`CommandPool`] that [`command_buffer`] was allocated from  **must**  be
///   externally synchronized
///
///## Command Properties
///# Related
/// - [`khr_copy_commands2`]
/// - [`crate::vulkan1_3`]
/// - [`CommandBuffer`]
/// - [`CopyBufferInfo2`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "vkCmdCopyBuffer2")]
pub type FNCmdCopyBuffer2 = Option<
    for<'lt> unsafe extern "system" fn(command_buffer: CommandBuffer, p_copy_buffer_info: *const CopyBufferInfo2<'lt>),
>;
///[vkCmdCopyImage2](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCopyImage2.html) - Copy data between images
///# C Specifications
///To copy data between image objects, call:
///```c
///// Provided by VK_VERSION_1_3
///void vkCmdCopyImage2(
///    VkCommandBuffer                             commandBuffer,
///    const VkCopyImageInfo2*                     pCopyImageInfo);
///```
///or the equivalent command
///```c
///// Provided by VK_KHR_copy_commands2
///void vkCmdCopyImage2KHR(
///    VkCommandBuffer                             commandBuffer,
///    const VkCopyImageInfo2*                     pCopyImageInfo);
///```
///# Parameters
/// - [`command_buffer`] is the command buffer into which the command will be recorded.
/// - [`p_copy_image_info`] is a pointer to a [`CopyImageInfo2`] structure describing the copy
///   parameters.
///# Description
///This command is functionally identical to [`cmd_copy_image`], but includes
///extensible sub-structures that include `sType` and `pNext`
///parameters, allowing them to be more easily extended.
///## Valid Usage
/// - If [`command_buffer`] is an unprotected command buffer and [`protectedNoFault`]() is not
///   supported, `srcImage` **must**  not be a protected image
/// - If [`command_buffer`] is an unprotected command buffer and [`protectedNoFault`]() is not
///   supported, `dstImage` **must**  not be a protected image
/// - If [`command_buffer`] is a protected command buffer and [`protectedNoFault`]() is not
///   supported, `dstImage` **must**  not be an unprotected image
///
///## Valid Usage (Implicit)
/// - [`command_buffer`] **must**  be a valid [`CommandBuffer`] handle
/// - [`p_copy_image_info`] **must**  be a valid pointer to a valid [`CopyImageInfo2`] structure
/// - [`command_buffer`] **must**  be in the [recording state]()
/// - The [`CommandPool`] that [`command_buffer`] was allocated from  **must**  support transfer,
///   graphics, or compute operations
/// - This command  **must**  only be called outside of a render pass instance
///
///## Host Synchronization
/// - Host access to [`command_buffer`] **must**  be externally synchronized
/// - Host access to the [`CommandPool`] that [`command_buffer`] was allocated from  **must**  be
///   externally synchronized
///
///## Command Properties
///# Related
/// - [`khr_copy_commands2`]
/// - [`crate::vulkan1_3`]
/// - [`CommandBuffer`]
/// - [`CopyImageInfo2`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "vkCmdCopyImage2")]
pub type FNCmdCopyImage2 = Option<
    for<'lt> unsafe extern "system" fn(command_buffer: CommandBuffer, p_copy_image_info: *const CopyImageInfo2<'lt>),
>;
///[vkCmdBlitImage2](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBlitImage2.html) - Copy regions of an image, potentially performing format conversion,
///# C Specifications
///To copy regions of a source image into a destination image, potentially
///performing format conversion, arbitrary scaling, and filtering, call:
///```c
///// Provided by VK_VERSION_1_3
///void vkCmdBlitImage2(
///    VkCommandBuffer                             commandBuffer,
///    const VkBlitImageInfo2*                     pBlitImageInfo);
///```
///or the equivalent command
///```c
///// Provided by VK_KHR_copy_commands2
///void vkCmdBlitImage2KHR(
///    VkCommandBuffer                             commandBuffer,
///    const VkBlitImageInfo2*                     pBlitImageInfo);
///```
///# Parameters
/// - [`command_buffer`] is the command buffer into which the command will be recorded.
/// - [`p_blit_image_info`] is a pointer to a [`BlitImageInfo2`] structure describing the blit
///   parameters.
///# Description
///This command is functionally identical to [`cmd_blit_image`], but includes
///extensible sub-structures that include `sType` and `pNext`
///parameters, allowing them to be more easily extended.
///## Valid Usage
/// - If [`command_buffer`] is an unprotected command buffer and [`protectedNoFault`]() is not
///   supported, `srcImage` **must**  not be a protected image
/// - If [`command_buffer`] is an unprotected command buffer and [`protectedNoFault`]() is not
///   supported, `dstImage` **must**  not be a protected image
/// - If [`command_buffer`] is a protected command buffer and [`protectedNoFault`]() is not
///   supported, `dstImage` **must**  not be an unprotected image
///
///## Valid Usage (Implicit)
/// - [`command_buffer`] **must**  be a valid [`CommandBuffer`] handle
/// - [`p_blit_image_info`] **must**  be a valid pointer to a valid [`BlitImageInfo2`] structure
/// - [`command_buffer`] **must**  be in the [recording state]()
/// - The [`CommandPool`] that [`command_buffer`] was allocated from  **must**  support graphics
///   operations
/// - This command  **must**  only be called outside of a render pass instance
///
///## Host Synchronization
/// - Host access to [`command_buffer`] **must**  be externally synchronized
/// - Host access to the [`CommandPool`] that [`command_buffer`] was allocated from  **must**  be
///   externally synchronized
///
///## Command Properties
///# Related
/// - [`khr_copy_commands2`]
/// - [`crate::vulkan1_3`]
/// - [`BlitImageInfo2`]
/// - [`CommandBuffer`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "vkCmdBlitImage2")]
pub type FNCmdBlitImage2 = Option<
    for<'lt> unsafe extern "system" fn(command_buffer: CommandBuffer, p_blit_image_info: *const BlitImageInfo2<'lt>),
>;
///[vkCmdCopyBufferToImage2](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCopyBufferToImage2.html) - Copy data from a buffer into an image
///# C Specifications
///To copy data from a buffer object to an image object, call:
///```c
///// Provided by VK_VERSION_1_3
///void vkCmdCopyBufferToImage2(
///    VkCommandBuffer                             commandBuffer,
///    const VkCopyBufferToImageInfo2*             pCopyBufferToImageInfo);
///```
///or the equivalent command
///```c
///// Provided by VK_KHR_copy_commands2
///void vkCmdCopyBufferToImage2KHR(
///    VkCommandBuffer                             commandBuffer,
///    const VkCopyBufferToImageInfo2*             pCopyBufferToImageInfo);
///```
///# Parameters
/// - [`command_buffer`] is the command buffer into which the command will be recorded.
/// - [`p_copy_buffer_to_image_info`] is a pointer to a [`CopyBufferToImageInfo2`] structure
///   describing the copy parameters.
///# Description
///This command is functionally identical to [`cmd_copy_buffer_to_image`], but
///includes extensible sub-structures that include `sType` and `pNext`
///parameters, allowing them to be more easily extended.
///## Valid Usage
/// - If [`command_buffer`] is an unprotected command buffer and [`protectedNoFault`]() is not
///   supported, `srcBuffer` **must**  not be a protected buffer
/// - If [`command_buffer`] is an unprotected command buffer and [`protectedNoFault`]() is not
///   supported, `dstImage` **must**  not be a protected image
/// - If [`command_buffer`] is a protected command buffer and [`protectedNoFault`]() is not
///   supported, `dstImage` **must**  not be an unprotected image
///
///## Valid Usage (Implicit)
/// - [`command_buffer`] **must**  be a valid [`CommandBuffer`] handle
/// - [`p_copy_buffer_to_image_info`] **must**  be a valid pointer to a valid
///   [`CopyBufferToImageInfo2`] structure
/// - [`command_buffer`] **must**  be in the [recording state]()
/// - The [`CommandPool`] that [`command_buffer`] was allocated from  **must**  support transfer,
///   graphics, or compute operations
/// - This command  **must**  only be called outside of a render pass instance
///
///## Host Synchronization
/// - Host access to [`command_buffer`] **must**  be externally synchronized
/// - Host access to the [`CommandPool`] that [`command_buffer`] was allocated from  **must**  be
///   externally synchronized
///
///## Command Properties
///# Related
/// - [`khr_copy_commands2`]
/// - [`crate::vulkan1_3`]
/// - [`CommandBuffer`]
/// - [`CopyBufferToImageInfo2`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "vkCmdCopyBufferToImage2")]
pub type FNCmdCopyBufferToImage2 = Option<
    for<'lt> unsafe extern "system" fn(
        command_buffer: CommandBuffer,
        p_copy_buffer_to_image_info: *const CopyBufferToImageInfo2<'lt>,
    ),
>;
///[vkCmdCopyImageToBuffer2](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCopyImageToBuffer2.html) - Copy image data into a buffer
///# C Specifications
///To copy data from an image object to a buffer object, call:
///```c
///// Provided by VK_VERSION_1_3
///void vkCmdCopyImageToBuffer2(
///    VkCommandBuffer                             commandBuffer,
///    const VkCopyImageToBufferInfo2*             pCopyImageToBufferInfo);
///```
///or the equivalent command
///```c
///// Provided by VK_KHR_copy_commands2
///void vkCmdCopyImageToBuffer2KHR(
///    VkCommandBuffer                             commandBuffer,
///    const VkCopyImageToBufferInfo2*             pCopyImageToBufferInfo);
///```
///# Parameters
/// - [`command_buffer`] is the command buffer into which the command will be recorded.
/// - [`p_copy_image_to_buffer_info`] is a pointer to a [`CopyImageToBufferInfo2`] structure
///   describing the copy parameters.
///# Description
///This command is functionally identical to [`cmd_copy_image_to_buffer`], but
///includes extensible sub-structures that include `sType` and `pNext`
///parameters, allowing them to be more easily extended.
///## Valid Usage
/// - If [`command_buffer`] is an unprotected command buffer and [`protectedNoFault`]() is not
///   supported, `srcImage` **must**  not be a protected image
/// - If [`command_buffer`] is an unprotected command buffer and [`protectedNoFault`]() is not
///   supported, `dstBuffer` **must**  not be a protected buffer
/// - If [`command_buffer`] is a protected command buffer and [`protectedNoFault`]() is not
///   supported, `dstBuffer` **must**  not be an unprotected buffer
///
///## Valid Usage (Implicit)
/// - [`command_buffer`] **must**  be a valid [`CommandBuffer`] handle
/// - [`p_copy_image_to_buffer_info`] **must**  be a valid pointer to a valid
///   [`CopyImageToBufferInfo2`] structure
/// - [`command_buffer`] **must**  be in the [recording state]()
/// - The [`CommandPool`] that [`command_buffer`] was allocated from  **must**  support transfer,
///   graphics, or compute operations
/// - This command  **must**  only be called outside of a render pass instance
///
///## Host Synchronization
/// - Host access to [`command_buffer`] **must**  be externally synchronized
/// - Host access to the [`CommandPool`] that [`command_buffer`] was allocated from  **must**  be
///   externally synchronized
///
///## Command Properties
///# Related
/// - [`khr_copy_commands2`]
/// - [`crate::vulkan1_3`]
/// - [`CommandBuffer`]
/// - [`CopyImageToBufferInfo2`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "vkCmdCopyImageToBuffer2")]
pub type FNCmdCopyImageToBuffer2 = Option<
    for<'lt> unsafe extern "system" fn(
        command_buffer: CommandBuffer,
        p_copy_image_to_buffer_info: *const CopyImageToBufferInfo2<'lt>,
    ),
>;
///[vkCmdResolveImage2](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdResolveImage2.html) - Resolve regions of an image
///# C Specifications
///To resolve a multisample image to a non-multisample image, call:
///```c
///// Provided by VK_VERSION_1_3
///void vkCmdResolveImage2(
///    VkCommandBuffer                             commandBuffer,
///    const VkResolveImageInfo2*                  pResolveImageInfo);
///```
///or the equivalent command
///```c
///// Provided by VK_KHR_copy_commands2
///void vkCmdResolveImage2KHR(
///    VkCommandBuffer                             commandBuffer,
///    const VkResolveImageInfo2*                  pResolveImageInfo);
///```
///# Parameters
/// - [`command_buffer`] is the command buffer into which the command will be recorded.
/// - [`p_resolve_image_info`] is a pointer to a [`ResolveImageInfo2`] structure describing the
///   resolve parameters.
///# Description
///This command is functionally identical to [`cmd_resolve_image`], but
///includes extensible sub-structures that include `sType` and `pNext`
///parameters, allowing them to be more easily extended.
///## Valid Usage
/// - If [`command_buffer`] is an unprotected command buffer and [`protectedNoFault`]() is not
///   supported, `srcImage` **must**  not be a protected image
/// - If [`command_buffer`] is an unprotected command buffer and [`protectedNoFault`]() is not
///   supported, `dstImage` **must**  not be a protected image
/// - If [`command_buffer`] is a protected command buffer and [`protectedNoFault`]() is not
///   supported, `dstImage` **must**  not be an unprotected image
///
///## Valid Usage (Implicit)
/// - [`command_buffer`] **must**  be a valid [`CommandBuffer`] handle
/// - [`p_resolve_image_info`] **must**  be a valid pointer to a valid [`ResolveImageInfo2`]
///   structure
/// - [`command_buffer`] **must**  be in the [recording state]()
/// - The [`CommandPool`] that [`command_buffer`] was allocated from  **must**  support graphics
///   operations
/// - This command  **must**  only be called outside of a render pass instance
///
///## Host Synchronization
/// - Host access to [`command_buffer`] **must**  be externally synchronized
/// - Host access to the [`CommandPool`] that [`command_buffer`] was allocated from  **must**  be
///   externally synchronized
///
///## Command Properties
///# Related
/// - [`khr_copy_commands2`]
/// - [`crate::vulkan1_3`]
/// - [`CommandBuffer`]
/// - [`ResolveImageInfo2`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "vkCmdResolveImage2")]
pub type FNCmdResolveImage2 = Option<
    for<'lt> unsafe extern "system" fn(
        command_buffer: CommandBuffer,
        p_resolve_image_info: *const ResolveImageInfo2<'lt>,
    ),
>;
///[vkCmdSetEvent2](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetEvent2.html) - Set an event object to signaled state
///# C Specifications
///To signal an event from a device, call:
///```c
///// Provided by VK_VERSION_1_3
///void vkCmdSetEvent2(
///    VkCommandBuffer                             commandBuffer,
///    VkEvent                                     event,
///    const VkDependencyInfo*                     pDependencyInfo);
///```
///or the equivalent command
///```c
///// Provided by VK_KHR_synchronization2
///void vkCmdSetEvent2KHR(
///    VkCommandBuffer                             commandBuffer,
///    VkEvent                                     event,
///    const VkDependencyInfo*                     pDependencyInfo);
///```
///# Parameters
/// - [`command_buffer`] is the command buffer into which the command is recorded.
/// - [`event`] is the event that will be signaled.
/// - [`p_dependency_info`] is a pointer to a [`DependencyInfo`] structure defining the first scopes
///   of this operation.
///# Description
///When [`cmd_set_event2`] is submitted to a queue, it defines the first half
///of memory dependencies defined by [`p_dependency_info`], as well as an event
///signal operation which sets the event to the signaled state.
///A memory dependency is defined between the event signal operation and
///commands that occur earlier in submission order.The first [synchronization scope](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-dependencies-scopes) and
///[access scope](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-dependencies-access-scopes) are defined by
///the union of all the memory dependencies defined by [`p_dependency_info`],
///and are applied to all operations that occur earlier in
///[submission order](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-submission-order).
///[Queue family ownership transfers](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-queue-transfers) and
///[image layout transitions](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-image-layout-transitions)
///defined by [`p_dependency_info`] are also included in the first scopes.The second [synchronization scope](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-dependencies-scopes)
///includes only the event signal operation, and any
///[queue family ownership transfers](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-queue-transfers) and
///[image layout transitions](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-image-layout-transitions)
///defined by [`p_dependency_info`].The second [access scope](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-dependencies-access-scopes)
///includes only [queue family ownership
///transfers](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-queue-transfers) and [image layout
///transitions](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-image-layout-transitions).Future [`cmd_wait_events2`] commands rely on all values of each element in
///[`p_dependency_info`] matching exactly with those used to signal the
///corresponding event.
///[`cmd_wait_events`] **must**  not be used to wait on the result of a signal
///operation defined by [`cmd_set_event2`].If [`event`] is already in the signaled state when
/// [`cmd_set_event2`] is
///executed on the device, then [`cmd_set_event2`] has no effect, no event
///signal operation occurs, and no dependency is generated.
///## Valid Usage
/// - The [`synchronization2`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-synchronization2)
///   feature  **must**  be enabled
/// - The `dependencyFlags` member of [`p_dependency_info`] **must**  be `0`
/// - The current device mask of [`command_buffer`] **must**  include exactly one physical device
/// - The `srcStageMask` member of any element of the `pMemoryBarriers`, `pBufferMemoryBarriers`, or
///   `pImageMemoryBarriers` members of [`p_dependency_info`] **must**  only include pipeline stages
///   valid for the queue family that was used to create the command pool that [`command_buffer`]
///   was allocated from
/// - The `dstStageMask` member of any element of the `pMemoryBarriers`, `pBufferMemoryBarriers`, or
///   `pImageMemoryBarriers` members of [`p_dependency_info`] **must**  only include pipeline stages
///   valid for the queue family that was used to create the command pool that [`command_buffer`]
///   was allocated from
///
///## Valid Usage (Implicit)
/// - [`command_buffer`] **must**  be a valid [`CommandBuffer`] handle
/// - [`event`] **must**  be a valid [`Event`] handle
/// - [`p_dependency_info`] **must**  be a valid pointer to a valid [`DependencyInfo`] structure
/// - [`command_buffer`] **must**  be in the [recording state]()
/// - The [`CommandPool`] that [`command_buffer`] was allocated from  **must**  support graphics, or
///   compute operations
/// - This command  **must**  only be called outside of a render pass instance
/// - Both of [`command_buffer`], and [`event`] **must**  have been created, allocated, or retrieved
///   from the same [`Device`]
///
///## Host Synchronization
/// - Host access to [`command_buffer`] **must**  be externally synchronized
/// - Host access to the [`CommandPool`] that [`command_buffer`] was allocated from  **must**  be
///   externally synchronized
///
///## Command Properties
///# Related
/// - [`khr_synchronization2`]
/// - [`crate::vulkan1_3`]
/// - [`CommandBuffer`]
/// - [`DependencyInfo`]
/// - [`Event`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "vkCmdSetEvent2")]
pub type FNCmdSetEvent2 = Option<
    for<'lt> unsafe extern "system" fn(
        command_buffer: CommandBuffer,
        event: Event,
        p_dependency_info: *const DependencyInfo<'lt>,
    ),
>;
///[vkCmdResetEvent2](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdResetEvent2.html) - Reset an event object to non-signaled state
///# C Specifications
///To unsignal the event from a device, call:
///```c
///// Provided by VK_VERSION_1_3
///void vkCmdResetEvent2(
///    VkCommandBuffer                             commandBuffer,
///    VkEvent                                     event,
///    VkPipelineStageFlags2                       stageMask);
///```
///or the equivalent command
///```c
///// Provided by VK_KHR_synchronization2
///void vkCmdResetEvent2KHR(
///    VkCommandBuffer                             commandBuffer,
///    VkEvent                                     event,
///    VkPipelineStageFlags2                       stageMask);
///```
///# Parameters
/// - [`command_buffer`] is the command buffer into which the command is recorded.
/// - [`event`] is the event that will be unsignaled.
/// - [`stage_mask`] is a [`PipelineStageFlags2`] mask of pipeline stages used to determine the first [synchronization scope](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-dependencies-scopes).
///# Description
///When [`cmd_reset_event2`] is submitted to a queue, it defines an execution
///dependency on commands that were submitted before it, and defines an event
///unsignal operation which resets the event to the unsignaled state.The first [synchronization scope](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-dependencies-scopes)
///includes all commands that occur earlier in
///[submission order](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-submission-order).
///The synchronization scope is limited to operations by [`stage_mask`] or
///stages that are [logically earlier](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-pipeline-stages-order)
///than [`stage_mask`].The second [synchronization scope](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-dependencies-scopes)
///includes only the event unsignal operation.If [`event`] is already in the unsignaled state when
///[`cmd_reset_event2`] is executed on the device, then this command has no
///effect, no event unsignal operation occurs, and no execution dependency is
///generated.
///## Valid Usage
/// - If the [geometry shaders](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-geometryShader)
///   feature is not enabled, [`stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT`
/// - If the [tessellation shaders](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-tessellationShader)
///   feature is not enabled, [`stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT` or
///   `VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT`
/// - If the [conditional rendering](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-conditionalRendering)
///   feature is not enabled, [`stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT`
/// - If the [fragment density map](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-fragmentDensityMap)
///   feature is not enabled, [`stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT`
/// - If the [transform feedback](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-transformFeedback)
///   feature is not enabled, [`stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT`
/// - If the [mesh shaders](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-meshShader)
///   feature is not enabled, [`stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_NV`
/// - If the [task shaders](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-taskShader)
///   feature is not enabled, [`stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_NV`
/// - If the [shading rate image](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-shadingRateImage)
///   feature is not enabled, [`stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_2_SHADING_RATE_IMAGE_BIT_NV`
/// - If the [subpass shading](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-subpassShading)
///   feature is not enabled, [`stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI`
/// - If the [invocation mask image](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-invocationMask)
///   feature is not enabled, [`stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_2_INVOCATION_MASK_BIT_HUAWEI`
/// - The [`synchronization2`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-synchronization2)
///   feature  **must**  be enabled
/// - [`stage_mask`] **must**  not include `VK_PIPELINE_STAGE_2_HOST_BIT`
/// - There  **must**  be an execution dependency between [`cmd_reset_event2`] and the execution of
///   any [`cmd_wait_events`] that includes [`event`] in its `pEvents` parameter
/// - There  **must**  be an execution dependency between [`cmd_reset_event2`] and the execution of
///   any [`cmd_wait_events2`] that includes [`event`] in its `pEvents` parameter
/// - [`command_buffer`]s current device mask  **must**  include exactly one physical device
///
///## Valid Usage (Implicit)
/// - [`command_buffer`] **must**  be a valid [`CommandBuffer`] handle
/// - [`event`] **must**  be a valid [`Event`] handle
/// - [`stage_mask`] **must**  be a valid combination of [`PipelineStageFlagBits2`] values
/// - [`command_buffer`] **must**  be in the [recording state]()
/// - The [`CommandPool`] that [`command_buffer`] was allocated from  **must**  support graphics, or
///   compute operations
/// - This command  **must**  only be called outside of a render pass instance
/// - Both of [`command_buffer`], and [`event`] **must**  have been created, allocated, or retrieved
///   from the same [`Device`]
///
///## Host Synchronization
/// - Host access to [`command_buffer`] **must**  be externally synchronized
/// - Host access to the [`CommandPool`] that [`command_buffer`] was allocated from  **must**  be
///   externally synchronized
///
///## Command Properties
///# Related
/// - [`khr_synchronization2`]
/// - [`crate::vulkan1_3`]
/// - [`CommandBuffer`]
/// - [`Event`]
/// - [`PipelineStageFlags2`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "vkCmdResetEvent2")]
pub type FNCmdResetEvent2 =
    Option<unsafe extern "system" fn(command_buffer: CommandBuffer, event: Event, stage_mask: PipelineStageFlags2)>;
///[vkCmdWaitEvents2](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdWaitEvents2.html) - Wait for one or more events
///# C Specifications
///To wait for one or more events to enter the signaled state on a device,
///call:
///```c
///// Provided by VK_VERSION_1_3
///void vkCmdWaitEvents2(
///    VkCommandBuffer                             commandBuffer,
///    uint32_t                                    eventCount,
///    const VkEvent*                              pEvents,
///    const VkDependencyInfo*                     pDependencyInfos);
///```
///or the equivalent command
///```c
///// Provided by VK_KHR_synchronization2
///void vkCmdWaitEvents2KHR(
///    VkCommandBuffer                             commandBuffer,
///    uint32_t                                    eventCount,
///    const VkEvent*                              pEvents,
///    const VkDependencyInfo*                     pDependencyInfos);
///```
///# Parameters
/// - [`command_buffer`] is the command buffer into which the command is recorded.
/// - [`event_count`] is the length of the [`p_events`] array.
/// - [`p_events`] is a pointer to an array of [`event_count`] events to wait on.
/// - [`p_dependency_infos`] is a pointer to an array of [`event_count`][`DependencyInfo`] structures, defining the second [synchronization scope](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-dependencies-scopes).
///# Description
///When [`cmd_wait_events2`] is submitted to a queue, it inserts memory
///dependencies according to the elements of [`p_dependency_infos`] and each
///corresponding element of [`p_events`].
///[`cmd_wait_events2`] **must**  not be used to wait on event signal operations
///occurring on other queues, or signal operations executed by
///[`cmd_set_event`].The first [synchronization scope](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-dependencies-scopes) and
///[access scope](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-dependencies-access-scopes) of each memory
///dependency defined by any element i of [`p_dependency_infos`] are
///applied to operations that occurred earlier in
///[submission order](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-submission-order) than the last event
///signal operation on element i of [`p_events`].Signal operations for an event at index i are only
/// included if:
/// - The event was signaled by a [`cmd_set_event2`] command that occurred earlier in [submission order](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-submission-order)
///   with a `dependencyInfo` parameter exactly equal to the element of [`p_dependency_infos`] at
///   index i ; or
/// - The event was created without `VK_EVENT_CREATE_DEVICE_ONLY_BIT`, and the first [synchronization scope](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-dependencies-scopes) defined by the element of [`p_dependency_infos`] at index i only includes host operations (`VK_PIPELINE_STAGE_2_HOST_BIT`).
///The second [synchronization scope](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-dependencies-scopes)
///and [access scope](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-dependencies-access-scopes) of each
///memory dependency defined by any element i of [`p_dependency_infos`]
///are applied to operations that occurred later in
///[submission order](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-submission-order) than
///[`cmd_wait_events2`].
///## Valid Usage
/// - The [`synchronization2`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-synchronization2)
///   feature  **must**  be enabled
/// - Members of [`p_events`] **must**  not have been signaled by [`cmd_set_event`]
/// - For any element i of [`p_events`], if that event is signaled by [`cmd_set_event2`], that
///   commands `dependencyInfo` parameter  **must**  be exactly equal to the ith element of
///   [`p_dependency_infos`]
/// - For any element i of [`p_events`], if that event is signaled by [`set_event`], barriers in the
///   ith element of [`p_dependency_infos`] **must**  include only host operations in their first [synchronization
///   scope](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-dependencies-scopes)
/// - For any element i of [`p_events`], if barriers in the ith element of [`p_dependency_infos`]
///   include only host operations, the ith element of [`p_events`] **must**  be signaled before
///   [`cmd_wait_events2`] is executed
/// - For any element i of [`p_events`], if barriers in the ith element of [`p_dependency_infos`] do
///   not include host operations, the ith element of [`p_events`] **must**  be signaled by a corresponding
///   [`cmd_set_event2`] that occurred earlier in [submission order](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-submission-order)
/// - The `srcStageMask` member of any element of the `pMemoryBarriers`, `pBufferMemoryBarriers`, or
///   `pImageMemoryBarriers` members of [`p_dependency_infos`] **must**  either include only
///   pipeline stages valid for the queue family that was used to create the command pool that
///   [`command_buffer`] was allocated from, or include only `VK_PIPELINE_STAGE_2_HOST_BIT`
/// - The `dstStageMask` member of any element of the `pMemoryBarriers`, `pBufferMemoryBarriers`, or
///   `pImageMemoryBarriers` members of [`p_dependency_infos`] **must**  only include pipeline
///   stages valid for the queue family that was used to create the command pool that
///   [`command_buffer`] was allocated from
/// - The `dependencyFlags` member of any element of `pDependencyInfo` **must**  be `0`
/// - If [`p_events`] includes one or more events that will be signaled by [`set_event`] after
///   [`command_buffer`] has been submitted to a queue, then [`cmd_wait_events2`] **must**  not be
///   called inside a render pass instance
/// - [`command_buffer`]s current device mask  **must**  include exactly one physical device
///
///## Valid Usage (Implicit)
/// - [`command_buffer`] **must**  be a valid [`CommandBuffer`] handle
/// - [`p_events`] **must**  be a valid pointer to an array of [`event_count`] valid [`Event`]
///   handles
/// - [`p_dependency_infos`] **must**  be a valid pointer to an array of [`event_count`] valid
///   [`DependencyInfo`] structures
/// - [`command_buffer`] **must**  be in the [recording state]()
/// - The [`CommandPool`] that [`command_buffer`] was allocated from  **must**  support graphics, or
///   compute operations
/// - [`event_count`] **must**  be greater than `0`
/// - Both of [`command_buffer`], and the elements of [`p_events`] **must**  have been created,
///   allocated, or retrieved from the same [`Device`]
///
///## Host Synchronization
/// - Host access to [`command_buffer`] **must**  be externally synchronized
/// - Host access to the [`CommandPool`] that [`command_buffer`] was allocated from  **must**  be
///   externally synchronized
///
///## Command Properties
///# Related
/// - [`khr_synchronization2`]
/// - [`crate::vulkan1_3`]
/// - [`CommandBuffer`]
/// - [`DependencyInfo`]
/// - [`Event`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "vkCmdWaitEvents2")]
pub type FNCmdWaitEvents2 = Option<
    for<'lt> unsafe extern "system" fn(
        command_buffer: CommandBuffer,
        event_count: u32,
        p_events: *const Event,
        p_dependency_infos: *const DependencyInfo<'lt>,
    ),
>;
///[vkCmdPipelineBarrier2](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdPipelineBarrier2.html) - Insert a memory dependency
///# C Specifications
///To record a pipeline barrier, call:
///```c
///// Provided by VK_VERSION_1_3
///void vkCmdPipelineBarrier2(
///    VkCommandBuffer                             commandBuffer,
///    const VkDependencyInfo*                     pDependencyInfo);
///```
///or the equivalent command
///```c
///// Provided by VK_KHR_synchronization2
///void vkCmdPipelineBarrier2KHR(
///    VkCommandBuffer                             commandBuffer,
///    const VkDependencyInfo*                     pDependencyInfo);
///```
///# Parameters
/// - [`command_buffer`] is the command buffer into which the command is recorded.
/// - [`p_dependency_info`] is a pointer to a [`DependencyInfo`] structure defining the scopes of
///   this operation.
///# Description
///When [`cmd_pipeline_barrier2`] is submitted to a queue, it defines memory
///dependencies between commands that were submitted before it, and those
///submitted after it.The first [synchronization scope](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-dependencies-scopes) and
///[access scope](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-dependencies-access-scopes) of each memory
///dependency defined by [`p_dependency_info`] are applied to operations that
///occurred earlier in [submission order](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-submission-order).The second [synchronization scope](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-dependencies-scopes)
///and [access scope](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-dependencies-access-scopes) of each
///memory dependency defined by [`p_dependency_info`] are applied to operations
///that occurred later in [submission
///order](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-submission-order).If [`cmd_pipeline_barrier2`] is recorded within a render pass instance,
///the synchronization scopes are
///[limited to
///operations within the same subpass](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-pipeline-barriers-subpass-self-dependencies).
///## Valid Usage
/// - If [`cmd_pipeline_barrier2`] is called within a render pass instance, the render pass
///   **must**  have been created with at least one [`SubpassDependency`] instance in
///   [`RenderPassCreateInfo::dependencies`] that expresses a dependency from the current subpass to
///   itself, with [synchronization scopes]() and [access scopes]() that are all supersets of the
///   scopes defined in this command
/// - If [`cmd_pipeline_barrier2`] is called within a render pass instance, it  **must**  not
///   include any buffer memory barriers
/// - If [`cmd_pipeline_barrier2`] is called within a render pass instance, the `image` member of
///   any image memory barrier included in this command  **must**  be an attachment used in the
///   current subpass both as an input attachment, and as either a color or depth/stencil attachment
/// - If [`cmd_pipeline_barrier2`] is called within a render pass instance, the `oldLayout` and
///   `newLayout` members of any image memory barrier included in this command  **must**  be equal
/// - If [`cmd_pipeline_barrier2`] is called within a render pass instance, the
///   `srcQueueFamilyIndex` and `dstQueueFamilyIndex` members of any image memory barrier included
///   in this command  **must**  be equal
/// - If [`cmd_pipeline_barrier2`] is called outside of a render pass instance,
///   `VK_DEPENDENCY_VIEW_LOCAL_BIT` **must**  not be included in the dependency flags
/// - If [`cmd_pipeline_barrier2`] is called within a render pass instance, the render pass
///   **must**  not have been started with [`cmd_begin_rendering`]
/// - The [`synchronization2`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-synchronization2)
///   feature  **must**  be enabled
/// - The `srcStageMask` member of any element of the `pMemoryBarriers`, `pBufferMemoryBarriers`, or
///   `pImageMemoryBarriers` members of [`p_dependency_info`] **must**  only include pipeline stages
///   valid for the queue family that was used to create the command pool that [`command_buffer`]
///   was allocated from
/// - The `dstStageMask` member of any element of the `pMemoryBarriers`, `pBufferMemoryBarriers`, or
///   `pImageMemoryBarriers` members of [`p_dependency_info`] **must**  only include pipeline stages
///   valid for the queue family that was used to create the command pool that [`command_buffer`]
///   was allocated from
///
///## Valid Usage (Implicit)
/// - [`command_buffer`] **must**  be a valid [`CommandBuffer`] handle
/// - [`p_dependency_info`] **must**  be a valid pointer to a valid [`DependencyInfo`] structure
/// - [`command_buffer`] **must**  be in the [recording state]()
/// - The [`CommandPool`] that [`command_buffer`] was allocated from  **must**  support transfer,
///   graphics, or compute operations
///
///## Host Synchronization
/// - Host access to [`command_buffer`] **must**  be externally synchronized
/// - Host access to the [`CommandPool`] that [`command_buffer`] was allocated from  **must**  be
///   externally synchronized
///
///## Command Properties
///# Related
/// - [`khr_synchronization2`]
/// - [`crate::vulkan1_3`]
/// - [`CommandBuffer`]
/// - [`DependencyInfo`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "vkCmdPipelineBarrier2")]
pub type FNCmdPipelineBarrier2 = Option<
    for<'lt> unsafe extern "system" fn(command_buffer: CommandBuffer, p_dependency_info: *const DependencyInfo<'lt>),
>;
///[vkCmdWriteTimestamp2](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdWriteTimestamp2.html) - Write a device timestamp into a query object
///# C Specifications
///To request a timestamp, call:
///```c
///// Provided by VK_VERSION_1_3
///void vkCmdWriteTimestamp2(
///    VkCommandBuffer                             commandBuffer,
///    VkPipelineStageFlags2                       stage,
///    VkQueryPool                                 queryPool,
///    uint32_t                                    query);
///```
///or the equivalent command
///```c
///// Provided by VK_KHR_synchronization2
///void vkCmdWriteTimestamp2KHR(
///    VkCommandBuffer                             commandBuffer,
///    VkPipelineStageFlags2                       stage,
///    VkQueryPool                                 queryPool,
///    uint32_t                                    query);
///```
///# Parameters
/// - [`command_buffer`] is the command buffer into which the command will be recorded.
/// - [`stage`] specifies a stage of the pipeline.
/// - [`query_pool`] is the query pool that will manage the timestamp.
/// - [`query`] is the query within the query pool that will contain the timestamp.
///# Description
///When [`cmd_write_timestamp2`] is submitted to a queue, it defines an
///execution dependency on commands that were submitted before it, and writes a
///timestamp to a query pool.The first [synchronization scope](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-dependencies-scopes)
///includes all commands that occur earlier in
///[submission order](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-submission-order).
///The synchronization scope is limited to operations on the pipeline stage
///specified by [`stage`].The second [synchronization scope](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-dependencies-scopes)
///includes only the timestamp write operation.When the timestamp value is written, the
/// availability status of the query is
///set to available.Comparisons between timestamps are not meaningful if the timestamps are
///written by commands submitted to different queues.If [`cmd_write_timestamp2`] is called while
/// executing a render pass
///instance that has multiview enabled, the timestamp uses N consecutive
///query indices in the query pool (starting at [`query`]) where N is
///the number of bits set in the view mask of the subpass the command is
///executed in.
///The resulting query values are determined by an implementation-dependent
///choice of one of the following behaviors:
/// - The first query is a timestamp value and (if more than one bit is set in the view mask) zero
///   is written to the remaining queries. If two timestamps are written in the same subpass, the
///   sum of the execution time of all views between those commands is the difference between the
///   first query written by each command.
/// - All N queries are timestamp values. If two timestamps are written in the same subpass, the sum
///   of the execution time of all views between those commands is the sum of the difference between
///   corresponding queries written by each command. The difference between corresponding queries
///   **may**  be the execution time of a single view.
///In either case, the application  **can**  sum the differences between all N
///queries to determine the total execution time.
///## Valid Usage
/// - If the [geometry shaders](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-geometryShader)
///   feature is not enabled, [`stage`] **must**  not contain
///   `VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT`
/// - If the [tessellation shaders](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-tessellationShader)
///   feature is not enabled, [`stage`] **must**  not contain
///   `VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT` or
///   `VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT`
/// - If the [conditional rendering](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-conditionalRendering)
///   feature is not enabled, [`stage`] **must**  not contain
///   `VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT`
/// - If the [fragment density map](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-fragmentDensityMap)
///   feature is not enabled, [`stage`] **must**  not contain
///   `VK_PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT`
/// - If the [transform feedback](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-transformFeedback)
///   feature is not enabled, [`stage`] **must**  not contain
///   `VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT`
/// - If the [mesh shaders](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-meshShader)
///   feature is not enabled, [`stage`] **must**  not contain
///   `VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_NV`
/// - If the [task shaders](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-taskShader)
///   feature is not enabled, [`stage`] **must**  not contain
///   `VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_NV`
/// - If the [shading rate image](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-shadingRateImage)
///   feature is not enabled, [`stage`] **must**  not contain
///   `VK_PIPELINE_STAGE_2_SHADING_RATE_IMAGE_BIT_NV`
/// - If the [subpass shading](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-subpassShading)
///   feature is not enabled, [`stage`] **must**  not contain
///   `VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI`
/// - If the [invocation mask image](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-invocationMask)
///   feature is not enabled, [`stage`] **must**  not contain
///   `VK_PIPELINE_STAGE_2_INVOCATION_MASK_BIT_HUAWEI`
/// - The [`synchronization2`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-synchronization2)
///   feature  **must**  be enabled
/// - [`stage`] **must**  only include a single pipeline stage
/// - [`stage`] **must**  only include stages valid for the queue family that was used to create the
///   command pool that [`command_buffer`] was allocated from
/// - [`query_pool`] **must**  have been created with a `queryType` of `VK_QUERY_TYPE_TIMESTAMP`
/// - The query identified by [`query_pool`] and [`query`] **must**  be *unavailable*
/// - The command pools queue family  **must**  support a non-zero `timestampValidBits`
/// - [`query`] **must**  be less than the number of queries in [`query_pool`]
/// - All queries used by the command  **must**  be unavailable
/// - If [`cmd_write_timestamp2`] is called within a render pass instance, the sum of [`query`] and
///   the number of bits set in the current subpasss view mask  **must**  be less than or equal to
///   the number of queries in [`query_pool`]
///
///## Valid Usage (Implicit)
/// - [`command_buffer`] **must**  be a valid [`CommandBuffer`] handle
/// - [`stage`] **must**  be a valid combination of [`PipelineStageFlagBits2`] values
/// - [`query_pool`] **must**  be a valid [`QueryPool`] handle
/// - [`command_buffer`] **must**  be in the [recording state]()
/// - The [`CommandPool`] that [`command_buffer`] was allocated from  **must**  support transfer,
///   graphics, compute, decode, or encode operations
/// - Both of [`command_buffer`], and [`query_pool`] **must**  have been created, allocated, or
///   retrieved from the same [`Device`]
///
///## Host Synchronization
/// - Host access to [`command_buffer`] **must**  be externally synchronized
/// - Host access to the [`CommandPool`] that [`command_buffer`] was allocated from  **must**  be
///   externally synchronized
///
///## Command Properties
///# Related
/// - [`khr_synchronization2`]
/// - [`crate::vulkan1_3`]
/// - [`CommandBuffer`]
/// - [`PipelineStageFlags2`]
/// - [`QueryPool`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "vkCmdWriteTimestamp2")]
pub type FNCmdWriteTimestamp2 = Option<
    unsafe extern "system" fn(
        command_buffer: CommandBuffer,
        stage: PipelineStageFlags2,
        query_pool: QueryPool,
        query: u32,
    ),
>;
///[vkCmdBeginRendering](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBeginRendering.html) - Begin a dynamic render pass instance
///# C Specifications
///To begin a render pass instance, call:
///```c
///// Provided by VK_VERSION_1_3
///void vkCmdBeginRendering(
///    VkCommandBuffer                             commandBuffer,
///    const VkRenderingInfo*                      pRenderingInfo);
///```
///or the equivalent command
///```c
///// Provided by VK_KHR_dynamic_rendering
///void vkCmdBeginRenderingKHR(
///    VkCommandBuffer                             commandBuffer,
///    const VkRenderingInfo*                      pRenderingInfo);
///```
///# Parameters
/// - [`command_buffer`] is the command buffer in which to record the command.
/// - [`p_rendering_info`] is a pointer to a [`RenderingInfo`] structure specifying details of the
///   render pass instance to begin.
///# Description
///After beginning a render pass instance, the command buffer is ready to
///record [draw commands](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#drawing).If `pRenderingInfo->flags` includes `VK_RENDERING_RESUMING_BIT` then
///this render pass is resumed from a render pass instance that has been
///suspended earlier in [submission order](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-submission-order).
///## Valid Usage
/// - The [`dynamicRendering`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-dynamicRendering)
///   feature  **must**  be enabled
/// - If [`command_buffer`] is a secondary command buffer, `pRenderingInfo->flags` **must**  not
///   include `VK_RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT`
///
///## Valid Usage (Implicit)
/// - [`command_buffer`] **must**  be a valid [`CommandBuffer`] handle
/// - [`p_rendering_info`] **must**  be a valid pointer to a valid [`RenderingInfo`] structure
/// - [`command_buffer`] **must**  be in the [recording state]()
/// - The [`CommandPool`] that [`command_buffer`] was allocated from  **must**  support graphics
///   operations
/// - This command  **must**  only be called outside of a render pass instance
///
///## Host Synchronization
/// - Host access to [`command_buffer`] **must**  be externally synchronized
/// - Host access to the [`CommandPool`] that [`command_buffer`] was allocated from  **must**  be
///   externally synchronized
///
///## Command Properties
///# Related
/// - [`khr_dynamic_rendering`]
/// - [`crate::vulkan1_3`]
/// - [`CommandBuffer`]
/// - [`RenderingInfo`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "vkCmdBeginRendering")]
pub type FNCmdBeginRendering = Option<
    for<'lt> unsafe extern "system" fn(command_buffer: CommandBuffer, p_rendering_info: *const RenderingInfo<'lt>),
>;
///[vkCmdEndRendering](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdEndRendering.html) - End a dynamic render pass instance
///# C Specifications
///To end a render pass instance, call:
///```c
///// Provided by VK_VERSION_1_3
///void vkCmdEndRendering(
///    VkCommandBuffer                             commandBuffer);
///```
///or the equivalent command
///```c
///// Provided by VK_KHR_dynamic_rendering
///void vkCmdEndRenderingKHR(
///    VkCommandBuffer                             commandBuffer);
///```
///# Parameters
/// - [`command_buffer`] is the command buffer in which to record the command.
///# Description
///If the value of `pRenderingInfo->flags` used to begin this render pass
///instance included `VK_RENDERING_SUSPENDING_BIT`, then this render pass
///is suspended and will be resumed later in
///[submission order](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-submission-order).
///## Valid Usage
/// - The current render pass instance  **must**  have been begun with [`cmd_begin_rendering`]
/// - The current render pass instance  **must**  have been begun in [`command_buffer`]
///
///## Valid Usage (Implicit)
/// - [`command_buffer`] **must**  be a valid [`CommandBuffer`] handle
/// - [`command_buffer`] **must**  be in the [recording state]()
/// - The [`CommandPool`] that [`command_buffer`] was allocated from  **must**  support graphics
///   operations
/// - This command  **must**  only be called inside of a render pass instance
///
///## Host Synchronization
/// - Host access to [`command_buffer`] **must**  be externally synchronized
/// - Host access to the [`CommandPool`] that [`command_buffer`] was allocated from  **must**  be
///   externally synchronized
///
///## Command Properties
///# Related
/// - [`khr_dynamic_rendering`]
/// - [`crate::vulkan1_3`]
/// - [`CommandBuffer`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "vkCmdEndRendering")]
pub type FNCmdEndRendering = Option<unsafe extern "system" fn(command_buffer: CommandBuffer)>;
///[VkPipelineCreationFeedbackFlagBits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineCreationFeedbackFlagBits.html) - Bitmask specifying pipeline or pipeline stage creation feedback
///# C Specifications
///Possible values of the `flags` member of
///[`PipelineCreationFeedback`] are:
///```c
///// Provided by VK_VERSION_1_3
///typedef enum VkPipelineCreationFeedbackFlagBits {
///    VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT = 0x00000001,
///    VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT = 0x00000002,
///    VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT = 0x00000004,
///    VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT_EXT = VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT,
///    VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT_EXT =
/// VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT,
///    VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT_EXT =
/// VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT,
///} VkPipelineCreationFeedbackFlagBits;
///```
///or the equivalent
///```c
///// Provided by VK_EXT_pipeline_creation_feedback
///typedef VkPipelineCreationFeedbackFlagBits VkPipelineCreationFeedbackFlagBitsEXT;
///```
///# Description
/// - [`VALID`] indicates that the feedback information is valid.
/// - [`APPLICATION_PIPELINE_CACHE_HIT`] indicates that a readily usable pipeline or pipeline stage
///   was found in the `pipelineCache` specified by the application in the pipeline creation
///   command.An implementation  **should**  set the [`APPLICATION_PIPELINE_CACHE_HIT`] bit if it
///   was able to avoid the large majority of pipeline or pipeline stage creation work by using the
///   `pipelineCache` parameter of [`create_graphics_pipelines`],
///   [`create_ray_tracing_pipelines_khr`], [`create_ray_tracing_pipelines_nv`], or
///   [`create_compute_pipelines`]. When an implementation sets this bit for the entire pipeline, it
///   **may**  leave it unset for any stage.
/// - [`BASE_PIPELINE_ACCELERATION`] indicates that the base pipeline specified by the
///   `basePipelineHandle` or `basePipelineIndex` member of the `Vk*PipelineCreateInfo` structure
///   was used to accelerate the creation of the pipeline.An implementation  **should**  set the
///   [`BASE_PIPELINE_ACCELERATION`] bit if it was able to avoid a significant amount of work by
///   using the base pipeline.
///# Related
/// - [`ext_pipeline_creation_feedback`]
/// - [`crate::vulkan1_3`]
/// - [`PipelineCreationFeedback`]
/// - [`PipelineCreationFeedbackCreateInfo`]
/// - [`PipelineCreationFeedbackFlags`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkPipelineCreationFeedbackFlagBits")]
#[derive(Clone, Copy, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(transparent)]
pub struct PipelineCreationFeedbackFlagBits(u32);
impl const Default for PipelineCreationFeedbackFlagBits {
    fn default() -> Self {
        Self(0)
    }
}
impl PipelineCreationFeedbackFlagBits {
    ///[`VALID`] indicates that the
    ///feedback information is valid.
    pub const VALID: Self = Self(1);
    ///[`APPLICATION_PIPELINE_CACHE_HIT`]
    ///indicates that a readily usable pipeline or pipeline stage was found in
    ///the `pipelineCache` specified by the application in the pipeline
    ///creation command.An implementation  **should**  set the
    ///[`APPLICATION_PIPELINE_CACHE_HIT`] bit
    ///if it was able to avoid the large majority of pipeline or pipeline stage
    ///creation work by using the `pipelineCache` parameter of
    ///[`create_graphics_pipelines`],
    ///[`create_ray_tracing_pipelines_khr`],
    ///[`create_ray_tracing_pipelines_nv`],
    ///or [`create_compute_pipelines`].
    ///When an implementation sets this bit for the entire pipeline, it  **may**  leave
    ///it unset for any stage.
    pub const APPLICATION_PIPELINE_CACHE_HIT: Self = Self(2);
    ///[`BASE_PIPELINE_ACCELERATION`]
    ///indicates that the base pipeline specified by the
    ///`basePipelineHandle` or `basePipelineIndex` member of the
    ///`Vk*PipelineCreateInfo` structure was used to accelerate the
    ///creation of the pipeline.An implementation  **should**  set the
    ///[`BASE_PIPELINE_ACCELERATION`] bit if it
    ///was able to avoid a significant amount of work by using the base pipeline.
    pub const BASE_PIPELINE_ACCELERATION: Self = Self(4);
    ///Default empty value
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Gets the raw underlying value
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Gets a value from a raw underlying value, unchecked and therefore unsafe.
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
}
impl std::fmt::Debug for PipelineCreationFeedbackFlagBits {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(PipelineCreationFeedbackFlagBits);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == PipelineCreationFeedbackFlagBits::empty() {
                    f.write_str("empty")?;
                } else {
                    match self.0 {
                        PipelineCreationFeedbackFlagBits::VALID => f.write_str("VALID")?,
                        PipelineCreationFeedbackFlagBits::APPLICATION_PIPELINE_CACHE_HIT => {
                            f.write_str("APPLICATION_PIPELINE_CACHE_HIT")?
                        },
                        PipelineCreationFeedbackFlagBits::BASE_PIPELINE_ACCELERATION => {
                            f.write_str("BASE_PIPELINE_ACCELERATION")?
                        },
                        _ => f.write_str("invalid")?,
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(PipelineCreationFeedbackFlagBits))
            .field(&Flags(*self))
            .finish()
    }
}
///[VkToolPurposeFlagBits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkToolPurposeFlagBits.html) - Bitmask specifying the purposes of an active tool
///# C Specifications
///Bits which  **can**  be set in
///[`PhysicalDeviceToolProperties::purposes`], specifying the
///purposes of an active tool, are:
///```c
///// Provided by VK_VERSION_1_3
///typedef enum VkToolPurposeFlagBits {
///    VK_TOOL_PURPOSE_VALIDATION_BIT = 0x00000001,
///    VK_TOOL_PURPOSE_PROFILING_BIT = 0x00000002,
///    VK_TOOL_PURPOSE_TRACING_BIT = 0x00000004,
///    VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT = 0x00000008,
///    VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT = 0x00000010,
///  // Provided by VK_EXT_debug_report with VK_EXT_tooling_info, VK_EXT_debug_utils with
/// VK_EXT_tooling_info
///    VK_TOOL_PURPOSE_DEBUG_REPORTING_BIT_EXT = 0x00000020,
///  // Provided by VK_EXT_debug_marker with VK_EXT_tooling_info, VK_EXT_debug_utils with
/// VK_EXT_tooling_info
///    VK_TOOL_PURPOSE_DEBUG_MARKERS_BIT_EXT = 0x00000040,
///    VK_TOOL_PURPOSE_VALIDATION_BIT_EXT = VK_TOOL_PURPOSE_VALIDATION_BIT,
///    VK_TOOL_PURPOSE_PROFILING_BIT_EXT = VK_TOOL_PURPOSE_PROFILING_BIT,
///    VK_TOOL_PURPOSE_TRACING_BIT_EXT = VK_TOOL_PURPOSE_TRACING_BIT,
///    VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT_EXT = VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT,
///    VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT_EXT = VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT,
///} VkToolPurposeFlagBits;
///```
///or the equivalent
///```c
///// Provided by VK_EXT_tooling_info
///typedef VkToolPurposeFlagBits VkToolPurposeFlagBitsEXT;
///```
///# Description
/// - [`VALIDATION`] specifies that the tool provides validation of API usage.
/// - [`PROFILING`] specifies that the tool provides profiling of API usage.
/// - [`TRACING`] specifies that the tool is capturing data about the applications API usage,
///   including anything from simple logging to capturing data for later replay.
/// - [`ADDITIONAL_FEATURES`] specifies that the tool provides additional API features/extensions on
///   top of the underlying implementation.
/// - [`MODIFYING_FEATURES`] specifies that the tool modifies the API features/limits/extensions
///   presented to the application.
/// - [`DEBUG_REPORTING_EXT`] specifies that the tool reports additional information to the
///   application via callbacks specified by [`create_debug_report_callback_ext`] or
///   [`create_debug_utils_messenger_ext`]
/// - [`DEBUG_MARKERS_EXT`] specifies that the tool consumes [debug markers](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#debugging-debug-markers)
///   or [object debug annotation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#debugging-object-debug-annotation),
///   [queue labels](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#debugging-queue-labels),
///   or [command buffer labels](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#debugging-command-buffer-labels)
///# Related
/// - [`ext_tooling_info`]
/// - [`crate::vulkan1_3`]
/// - [`ToolPurposeFlags`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkToolPurposeFlagBits")]
#[derive(Clone, Copy, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(transparent)]
pub struct ToolPurposeFlagBits(u32);
impl const Default for ToolPurposeFlagBits {
    fn default() -> Self {
        Self(0)
    }
}
impl ToolPurposeFlagBits {
    ///[`VALIDATION`] specifies that the tool provides
    ///validation of API usage.
    pub const VALIDATION: Self = Self(1);
    ///[`PROFILING`] specifies that the tool provides
    ///profiling of API usage.
    pub const PROFILING: Self = Self(2);
    ///[`TRACING`] specifies that the tool is capturing
    ///data about the applications API usage, including anything from simple
    ///logging to capturing data for later replay.
    pub const TRACING: Self = Self(4);
    ///[`ADDITIONAL_FEATURES`] specifies that the tool
    ///provides additional API features/extensions on top of the underlying
    ///implementation.
    pub const ADDITIONAL_FEATURES: Self = Self(8);
    ///[`MODIFYING_FEATURES`] specifies that the tool
    ///modifies the API features/limits/extensions presented to the
    ///application.
    pub const MODIFYING_FEATURES: Self = Self(16);
    ///[`DEBUG_REPORTING_EXT`] specifies that the tool
    ///reports additional information to the application via callbacks
    ///specified by
    ///[`create_debug_report_callback_ext`]
    ///or
    ///[`create_debug_utils_messenger_ext`]
    ///
    ///Provided by [`crate::extensions::ext_tooling_info`]
    #[cfg(feature = "VK_EXT_tooling_info")]
    pub const DEBUG_REPORTING_EXT: Self = Self(32);
    ///[`DEBUG_MARKERS_EXT`] specifies that the tool
    ///consumes
    ///[debug markers](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#debugging-debug-markers)
    ///or
    ///[object debug annotation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#debugging-object-debug-annotation),
    ///[queue labels](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#debugging-queue-labels), or
    ///[command buffer labels](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#debugging-command-buffer-labels)
    ///
    ///Provided by [`crate::extensions::ext_tooling_info`]
    #[cfg(feature = "VK_EXT_tooling_info")]
    pub const DEBUG_MARKERS_EXT: Self = Self(64);
    ///Default empty value
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Gets the raw underlying value
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Gets a value from a raw underlying value, unchecked and therefore unsafe.
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
}
impl std::fmt::Debug for ToolPurposeFlagBits {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(ToolPurposeFlagBits);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == ToolPurposeFlagBits::empty() {
                    f.write_str("empty")?;
                } else {
                    match self.0 {
                        ToolPurposeFlagBits::VALIDATION => f.write_str("VALIDATION")?,
                        ToolPurposeFlagBits::PROFILING => f.write_str("PROFILING")?,
                        ToolPurposeFlagBits::TRACING => f.write_str("TRACING")?,
                        ToolPurposeFlagBits::ADDITIONAL_FEATURES => f.write_str("ADDITIONAL_FEATURES")?,
                        ToolPurposeFlagBits::MODIFYING_FEATURES => f.write_str("MODIFYING_FEATURES")?,
                        #[cfg(feature = "VK_EXT_tooling_info")]
                        ToolPurposeFlagBits::DEBUG_REPORTING_EXT => f.write_str("DEBUG_REPORTING_EXT")?,
                        #[cfg(feature = "VK_EXT_tooling_info")]
                        ToolPurposeFlagBits::DEBUG_MARKERS_EXT => f.write_str("DEBUG_MARKERS_EXT")?,
                        _ => f.write_str("invalid")?,
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(ToolPurposeFlagBits))
            .field(&Flags(*self))
            .finish()
    }
}
///[VkAccessFlagBits2](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAccessFlagBits2.html) - Access flags for VkAccessFlags2
///# C Specifications
///Bits which  **can**  be set in the `srcAccessMask` and `dstAccessMask`
///members of [`MemoryBarrier2KHR`], [`ImageMemoryBarrier2KHR`], and
///[`BufferMemoryBarrier2KHR`], specifying access behavior, are:
///```c
///// Provided by VK_VERSION_1_3
///// Flag bits for VkAccessFlagBits2
///typedef VkFlags64 VkAccessFlagBits2;
///static const VkAccessFlagBits2 VK_ACCESS_2_NONE = 0ULL;
///static const VkAccessFlagBits2 VK_ACCESS_2_NONE_KHR = 0ULL;
///static const VkAccessFlagBits2 VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT = 0x00000001ULL;
///static const VkAccessFlagBits2 VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT_KHR = 0x00000001ULL;
///static const VkAccessFlagBits2 VK_ACCESS_2_INDEX_READ_BIT = 0x00000002ULL;
///static const VkAccessFlagBits2 VK_ACCESS_2_INDEX_READ_BIT_KHR = 0x00000002ULL;
///static const VkAccessFlagBits2 VK_ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT = 0x00000004ULL;
///static const VkAccessFlagBits2 VK_ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT_KHR = 0x00000004ULL;
///static const VkAccessFlagBits2 VK_ACCESS_2_UNIFORM_READ_BIT = 0x00000008ULL;
///static const VkAccessFlagBits2 VK_ACCESS_2_UNIFORM_READ_BIT_KHR = 0x00000008ULL;
///static const VkAccessFlagBits2 VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT = 0x00000010ULL;
///static const VkAccessFlagBits2 VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT_KHR = 0x00000010ULL;
///static const VkAccessFlagBits2 VK_ACCESS_2_SHADER_READ_BIT = 0x00000020ULL;
///static const VkAccessFlagBits2 VK_ACCESS_2_SHADER_READ_BIT_KHR = 0x00000020ULL;
///static const VkAccessFlagBits2 VK_ACCESS_2_SHADER_WRITE_BIT = 0x00000040ULL;
///static const VkAccessFlagBits2 VK_ACCESS_2_SHADER_WRITE_BIT_KHR = 0x00000040ULL;
///static const VkAccessFlagBits2 VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT = 0x00000080ULL;
///static const VkAccessFlagBits2 VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT_KHR = 0x00000080ULL;
///static const VkAccessFlagBits2 VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT = 0x00000100ULL;
///static const VkAccessFlagBits2 VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT_KHR = 0x00000100ULL;
///static const VkAccessFlagBits2 VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT = 0x00000200ULL;
///static const VkAccessFlagBits2 VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT_KHR =
/// 0x00000200ULL;
///static const VkAccessFlagBits2 VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT = 0x00000400ULL;
///static const VkAccessFlagBits2 VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT_KHR =
/// 0x00000400ULL;
///static const VkAccessFlagBits2 VK_ACCESS_2_TRANSFER_READ_BIT = 0x00000800ULL;
///static const VkAccessFlagBits2 VK_ACCESS_2_TRANSFER_READ_BIT_KHR = 0x00000800ULL;
///static const VkAccessFlagBits2 VK_ACCESS_2_TRANSFER_WRITE_BIT = 0x00001000ULL;
///static const VkAccessFlagBits2 VK_ACCESS_2_TRANSFER_WRITE_BIT_KHR = 0x00001000ULL;
///static const VkAccessFlagBits2 VK_ACCESS_2_HOST_READ_BIT = 0x00002000ULL;
///static const VkAccessFlagBits2 VK_ACCESS_2_HOST_READ_BIT_KHR = 0x00002000ULL;
///static const VkAccessFlagBits2 VK_ACCESS_2_HOST_WRITE_BIT = 0x00004000ULL;
///static const VkAccessFlagBits2 VK_ACCESS_2_HOST_WRITE_BIT_KHR = 0x00004000ULL;
///static const VkAccessFlagBits2 VK_ACCESS_2_MEMORY_READ_BIT = 0x00008000ULL;
///static const VkAccessFlagBits2 VK_ACCESS_2_MEMORY_READ_BIT_KHR = 0x00008000ULL;
///static const VkAccessFlagBits2 VK_ACCESS_2_MEMORY_WRITE_BIT = 0x00010000ULL;
///static const VkAccessFlagBits2 VK_ACCESS_2_MEMORY_WRITE_BIT_KHR = 0x00010000ULL;
///static const VkAccessFlagBits2 VK_ACCESS_2_SHADER_SAMPLED_READ_BIT = 0x100000000ULL;
///static const VkAccessFlagBits2 VK_ACCESS_2_SHADER_SAMPLED_READ_BIT_KHR = 0x100000000ULL;
///static const VkAccessFlagBits2 VK_ACCESS_2_SHADER_STORAGE_READ_BIT = 0x200000000ULL;
///static const VkAccessFlagBits2 VK_ACCESS_2_SHADER_STORAGE_READ_BIT_KHR = 0x200000000ULL;
///static const VkAccessFlagBits2 VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT = 0x400000000ULL;
///static const VkAccessFlagBits2 VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT_KHR = 0x400000000ULL;
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///// Provided by VK_KHR_video_decode_queue
///static const VkAccessFlagBits2 VK_ACCESS_2_VIDEO_DECODE_READ_BIT_KHR = 0x800000000ULL;
///#endif
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///// Provided by VK_KHR_video_decode_queue
///static const VkAccessFlagBits2 VK_ACCESS_2_VIDEO_DECODE_WRITE_BIT_KHR = 0x1000000000ULL;
///#endif
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///// Provided by VK_KHR_video_encode_queue
///static const VkAccessFlagBits2 VK_ACCESS_2_VIDEO_ENCODE_READ_BIT_KHR = 0x2000000000ULL;
///#endif
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///// Provided by VK_KHR_video_encode_queue
///static const VkAccessFlagBits2 VK_ACCESS_2_VIDEO_ENCODE_WRITE_BIT_KHR = 0x4000000000ULL;
///#endif
///// Provided by VK_KHR_synchronization2 with VK_EXT_transform_feedback
///static const VkAccessFlagBits2 VK_ACCESS_2_TRANSFORM_FEEDBACK_WRITE_BIT_EXT = 0x02000000ULL;
///// Provided by VK_KHR_synchronization2 with VK_EXT_transform_feedback
///static const VkAccessFlagBits2 VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT =
/// 0x04000000ULL;
///// Provided by VK_KHR_synchronization2 with VK_EXT_transform_feedback
///static const VkAccessFlagBits2 VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT =
/// 0x08000000ULL;
///// Provided by VK_KHR_synchronization2 with VK_EXT_conditional_rendering
///static const VkAccessFlagBits2 VK_ACCESS_2_CONDITIONAL_RENDERING_READ_BIT_EXT = 0x00100000ULL;
///// Provided by VK_KHR_synchronization2 with VK_NV_device_generated_commands
///static const VkAccessFlagBits2 VK_ACCESS_2_COMMAND_PREPROCESS_READ_BIT_NV = 0x00020000ULL;
///// Provided by VK_KHR_synchronization2 with VK_NV_device_generated_commands
///static const VkAccessFlagBits2 VK_ACCESS_2_COMMAND_PREPROCESS_WRITE_BIT_NV = 0x00040000ULL;
///// Provided by VK_KHR_fragment_shading_rate with VK_KHR_synchronization2
///static const VkAccessFlagBits2 VK_ACCESS_2_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR =
/// 0x00800000ULL;
///// Provided by VK_KHR_synchronization2 with VK_NV_shading_rate_image
///static const VkAccessFlagBits2 VK_ACCESS_2_SHADING_RATE_IMAGE_READ_BIT_NV = 0x00800000ULL;
///// Provided by VK_KHR_acceleration_structure with VK_KHR_synchronization2
///static const VkAccessFlagBits2 VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_KHR = 0x00200000ULL;
///// Provided by VK_KHR_acceleration_structure with VK_KHR_synchronization2
///static const VkAccessFlagBits2 VK_ACCESS_2_ACCELERATION_STRUCTURE_WRITE_BIT_KHR = 0x00400000ULL;
///// Provided by VK_KHR_synchronization2 with VK_NV_ray_tracing
///static const VkAccessFlagBits2 VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_NV = 0x00200000ULL;
///// Provided by VK_KHR_synchronization2 with VK_NV_ray_tracing
///static const VkAccessFlagBits2 VK_ACCESS_2_ACCELERATION_STRUCTURE_WRITE_BIT_NV = 0x00400000ULL;
///// Provided by VK_KHR_synchronization2 with VK_EXT_fragment_density_map
///static const VkAccessFlagBits2 VK_ACCESS_2_FRAGMENT_DENSITY_MAP_READ_BIT_EXT = 0x01000000ULL;
///// Provided by VK_KHR_synchronization2 with VK_EXT_blend_operation_advanced
///static const VkAccessFlagBits2 VK_ACCESS_2_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT =
/// 0x00080000ULL;
///// Provided by VK_HUAWEI_invocation_mask
///static const VkAccessFlagBits2 VK_ACCESS_2_INVOCATION_MASK_READ_BIT_HUAWEI = 0x8000000000ULL;
///```
///or the equivalent
///```c
///// Provided by VK_KHR_synchronization2
///typedef VkAccessFlagBits2 VkAccessFlagBits2KHR;
///```
///# Description
/// - [`ACCESS2_NONE`] specifies no accesses.
/// - [`ACCESS2_MEMORY_READ`] specifies all read accesses. It is always valid in any access mask,
///   and is treated as equivalent to setting all `READ` access flags that are valid where it is
///   used.
/// - [`ACCESS2_MEMORY_WRITE`] specifies all write accesses. It is always valid in any access mask,
///   and is treated as equivalent to setting all `WRITE` access flags that are valid where it is
///   used.
/// - [`ACCESS2_INDIRECT_COMMAND_READ`] specifies read access to     command data read from indirect
///   buffers as part of an indirect build, trace,     drawing or dispatch command.     Such access
///   occurs in the `VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT`     pipeline stage.
/// - [`ACCESS2_INDEX_READ`] specifies read access to an index buffer as part of an indexed drawing
///   command, bound by [`cmd_bind_index_buffer`]. Such access occurs in the
///   `VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT` pipeline stage.
/// - [`ACCESS2_VERTEX_ATTRIBUTE_READ`] specifies read access to a vertex buffer as part of a
///   drawing command, bound by [`cmd_bind_vertex_buffers`]. Such access occurs in the
///   `VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT` pipeline stage.
/// - [`ACCESS2_UNIFORM_READ`] specifies read access to a [uniform buffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-uniformbuffer)
///   in any shader pipeline stage.
/// - [`ACCESS2_INPUT_ATTACHMENT_READ`] specifies read access to an [input attachment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass)
///   within a render pass during subpass shading or fragment shading. Such access occurs in the
///   `VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI` or `VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT`
///   pipeline stage.
/// - [`ACCESS2_SHADER_SAMPLED_READ`] specifies read access to a [uniform texel buffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-uniformtexelbuffer)
///   or [sampled image](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-sampledimage)
///   in any shader pipeline stage.
/// - [`ACCESS2_SHADER_STORAGE_READ`] specifies read access to a [storage buffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storagebuffer),
///   [physical storage buffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-physical-storage-buffer),
///   [storage texel buffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storagetexelbuffer),
///   or [storage image](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storageimage)
///   in any shader pipeline stage.
/// - [`ACCESS2_SHADER_READ`] specifies read access to a [shader binding table](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#shader-binding-table)
///   in any shader pipeline. In addition, it is equivalent to the logical OR of:  -
///   [`ACCESS2_UNIFORM_READ`]  - [`ACCESS2_SHADER_SAMPLED_READ`]  - [`ACCESS2_SHADER_STORAGE_READ`]
/// - [`ACCESS2_SHADER_STORAGE_WRITE`] specifies write access to a [storage buffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storagebuffer),
///   [physical storage buffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-physical-storage-buffer),
///   [storage texel buffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storagetexelbuffer),
///   or [storage image](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storageimage)
///   in any shader pipeline stage.
/// - [`ACCESS2_SHADER_WRITE`] is equivalent to [`ACCESS2_SHADER_STORAGE_WRITE`].
/// - [`ACCESS2_COLOR_ATTACHMENT_READ`] specifies read access to a [color attachment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass),
///   such as via [blending](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#framebuffer-blending),
///   [logic operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#framebuffer-logicop),
///   or via certain [subpass load operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-load-store-ops).
///   It does not include [advanced blend operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#framebuffer-blend-advanced).
///   Such access occurs in the `VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT` pipeline stage.
/// - [`ACCESS2_COLOR_ATTACHMENT_WRITE`] specifies write access to a [color, resolve, or depth/stencil resolve attachment](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#renderpass) during a [render pass](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass) or via certain [subpass load and store operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-load-store-ops). Such access occurs in the `VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT` pipeline stage.
/// - [`ACCESS2_DEPTH_STENCIL_ATTACHMENT_READ`] specifies read access to a [depth/stencil attachment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass),
///   via [depth or stencil operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fragops-ds-state)
///   or via certain [subpass load operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-load-store-ops).
///   Such access occurs in the `VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT` or
///   `VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT` pipeline stages.
/// - [`ACCESS2_DEPTH_STENCIL_ATTACHMENT_WRITE`] specifies write access to a [depth/stencil attachment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass),
///   via [depth or stencil operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fragops-ds-state)
///   or via certain [subpass load and store operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-load-store-ops).
///   Such access occurs in the `VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT` or
///   `VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT` pipeline stages.
/// - [`ACCESS2_TRANSFER_READ`] specifies read access to an image or buffer in a [copy](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#copies)
///   operation. Such access occurs in the `VK_PIPELINE_STAGE_2_COPY_BIT`,
///   `VK_PIPELINE_STAGE_2_BLIT_BIT`, or `VK_PIPELINE_STAGE_2_RESOLVE_BIT` pipeline stages.
/// - [`ACCESS2_TRANSFER_WRITE`] specifies write access to an image or buffer in a [clear](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#clears)
///   or [copy](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#copies)
///   operation. Such access occurs in the `VK_PIPELINE_STAGE_2_COPY_BIT`,
///   `VK_PIPELINE_STAGE_2_BLIT_BIT`, `VK_PIPELINE_STAGE_2_CLEAR_BIT`, or
///   `VK_PIPELINE_STAGE_2_RESOLVE_BIT` pipeline stages.
/// - [`ACCESS2_HOST_READ`] specifies read access by a host operation. Accesses of this type are not
///   performed through a resource, but directly on memory. Such access occurs in the
///   `VK_PIPELINE_STAGE_2_HOST_BIT` pipeline stage.
/// - [`ACCESS2_HOST_WRITE`] specifies write access by a host operation. Accesses of this type are
///   not performed through a resource, but directly on memory. Such access occurs in the
///   `VK_PIPELINE_STAGE_2_HOST_BIT` pipeline stage.
/// - [`ACCESS2_CONDITIONAL_RENDERING_READ_EXT`] specifies read access to a predicate as part of
///   conditional rendering. Such access occurs in the
///   `VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT` pipeline stage.
/// - [`ACCESS2_TRANSFORM_FEEDBACK_WRITE_EXT`] specifies write access to a transform feedback buffer
///   made when transform feedback is active. Such access occurs in the
///   `VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT` pipeline stage.
/// - [`ACCESS2_TRANSFORM_FEEDBACK_COUNTER_READ_EXT`] specifies read access to a transform feedback
///   counter buffer which is read when [`cmd_begin_transform_feedback_ext`] executes. Such access
///   occurs in the `VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT` pipeline stage.
/// - [`ACCESS2_TRANSFORM_FEEDBACK_COUNTER_WRITE_EXT`] specifies write access to a transform
///   feedback counter buffer which is written when [`cmd_end_transform_feedback_ext`] executes.
///   Such access occurs in the `VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT` pipeline stage.
/// - [`ACCESS2_COMMAND_PREPROCESS_READ_NV`] specifies reads from buffer inputs to
///   [`cmd_preprocess_generated_commands_nv`]. Such access occurs in the
///   `VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_NV` pipeline stage.
/// - [`ACCESS2_COMMAND_PREPROCESS_WRITE_NV`] specifies writes to the target command buffer
///   preprocess outputs. Such access occurs in the `VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_NV`
///   pipeline stage.
/// - [`ACCESS2_COLOR_ATTACHMENT_READ_NONCOHERENT_EXT`] specifies read access to [color attachments](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass),
///   including [advanced blend operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#framebuffer-blend-advanced).
///   Such access occurs in the `VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT` pipeline stage.
/// - [`ACCESS2_INVOCATION_MASK_READ_HUAWEI`] specifies read access to a invocation mask image in
///   the `VK_PIPELINE_STAGE_2_INVOCATION_MASK_BIT_HUAWEI` pipeline stage.
/// - [`ACCESS2_ACCELERATION_STRUCTURE_READ_KHR`] specifies read access to an acceleration structure
///   as part of a trace, build, or copy command, or to an [acceleration structure scratch buffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#acceleration-structure-scratch)
///   as part of a build command. Such access occurs in the
///   `VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR` pipeline stage or
///   `VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR` pipeline stage.
/// - [`ACCESS2_ACCELERATION_STRUCTURE_WRITE_KHR`] specifies write access to an acceleration structure or [acceleration structure scratch buffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#acceleration-structure-scratch) as part of a build or copy command. Such access occurs in the `VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR` pipeline stage.
/// - [`ACCESS2_FRAGMENT_DENSITY_MAP_READ_EXT`] specifies read access to a [fragment density map attachment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-fragmentdensitymapattachment)
///   during dynamic [fragment density map operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fragmentdensitymapops).
///   Such access occurs in the `VK_PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT` pipeline
///   stage.
/// - [`ACCESS2_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_KHR`] specifies read access to a fragment
///   shading rate attachment during rasterization. Such access occurs in the
///   `VK_PIPELINE_STAGE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR` pipeline stage.
/// - [`ACCESS2_SHADING_RATE_IMAGE_READ_NV`] specifies read access to a shading rate image during
///   rasterization. Such access occurs in the `VK_PIPELINE_STAGE_2_SHADING_RATE_IMAGE_BIT_NV`
///   pipeline stage. It is equivalent to [`ACCESS2_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_KHR`].
/// - [`ACCESS2_VIDEO_DECODE_READ_KHR`] specifies read access to an image or buffer resource as part
///   of a [video decode operation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-decode-operations).
///   Such access occurs in the `VK_PIPELINE_STAGE_2_VIDEO_DECODE_BIT_KHR` pipeline stage.
/// - [`ACCESS2_VIDEO_DECODE_WRITE_KHR`] specifies write access to an image or buffer resource as part of a [video decode operation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-decode-operations). Such access occurs in the `VK_PIPELINE_STAGE_2_VIDEO_DECODE_BIT_KHR` pipeline stage.
/// - [`ACCESS2_VIDEO_ENCODE_READ_KHR`] specifies read access to an image or buffer resource as part
///   of a [video encode operation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-encode-operations).
///   Such access occurs in the `VK_PIPELINE_STAGE_2_VIDEO_ENCODE_BIT_KHR` pipeline stage.
/// - [`ACCESS2_VIDEO_ENCODE_WRITE_KHR`] specifies write access to an image or buffer resource as part of a [video encode operation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-encode-operations). Such access occurs in the `VK_PIPELINE_STAGE_2_VIDEO_ENCODE_BIT_KHR` pipeline stage.
///# Related
/// - [`khr_synchronization2`]
/// - [`crate::vulkan1_3`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkAccessFlagBits2")]
#[derive(Clone, Copy, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(transparent)]
pub struct AccessFlagBits2(u64);
impl const Default for AccessFlagBits2 {
    fn default() -> Self {
        Self(0)
    }
}
impl AccessFlagBits2 {
    ///[`ACCESS2_NONE`] specifies no accesses.
    pub const ACCESS2_NONE: Self = Self(0);
    ///[`ACCESS2_INDIRECT_COMMAND_READ`] specifies read access to
    ///    command data read from indirect buffers as part of an indirect
    ///build,
    ///trace,
    ///    drawing or dispatch command.
    ///    Such access occurs in the `VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT`
    ///    pipeline stage.
    pub const ACCESS2_INDIRECT_COMMAND_READ: Self = Self(1);
    ///[`ACCESS2_INDEX_READ`] specifies read access to an index
    ///buffer as part of an indexed drawing command, bound by
    ///[`cmd_bind_index_buffer`].
    ///Such access occurs in the `VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT`
    ///pipeline stage.
    pub const ACCESS2_INDEX_READ: Self = Self(2);
    ///[`ACCESS2_VERTEX_ATTRIBUTE_READ`] specifies read access to a
    ///vertex buffer as part of a drawing command, bound by
    ///[`cmd_bind_vertex_buffers`].
    ///Such access occurs in the
    ///`VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT` pipeline stage.
    pub const ACCESS2_VERTEX_ATTRIBUTE_READ: Self = Self(4);
    ///[`ACCESS2_UNIFORM_READ`] specifies read access to a
    ///[uniform buffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-uniformbuffer) in any shader pipeline
    ///stage.
    pub const ACCESS2_UNIFORM_READ: Self = Self(8);
    ///[`ACCESS2_INPUT_ATTACHMENT_READ`] specifies read access to an
    ///[input attachment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass) within a render pass during
    ///subpass shading or
    ///fragment shading.
    ///Such access occurs in the
    ///`VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI` or
    ///`VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT` pipeline stage.
    pub const ACCESS2_INPUT_ATTACHMENT_READ: Self = Self(16);
    ///[`ACCESS2_SHADER_READ`]
    ///specifies read access to a [shader binding
    ///table](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#shader-binding-table) in any shader pipeline.
    ///In addition, it
    ///is equivalent to the logical OR of:
    /// - [`ACCESS2_UNIFORM_READ`]
    /// - [`ACCESS2_SHADER_SAMPLED_READ`]
    /// - [`ACCESS2_SHADER_STORAGE_READ`]
    pub const ACCESS2_SHADER_READ: Self = Self(32);
    ///[`ACCESS2_SHADER_WRITE`] is equivalent to
    ///[`ACCESS2_SHADER_STORAGE_WRITE`].
    pub const ACCESS2_SHADER_WRITE: Self = Self(64);
    ///[`ACCESS2_COLOR_ATTACHMENT_READ`] specifies read access to a
    ///[color attachment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass), such as via [blending](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#framebuffer-blending), [logic operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#framebuffer-logicop), or via certain
    ///[subpass load operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-load-store-ops).
    ///It does not include [advanced blend
    ///operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#framebuffer-blend-advanced).
    ///Such access occurs in the
    ///`VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT` pipeline stage.
    pub const ACCESS2_COLOR_ATTACHMENT_READ: Self = Self(128);
    ///[`ACCESS2_COLOR_ATTACHMENT_WRITE`] specifies write access to a
    ///[color, resolve, or depth/stencil resolve attachment](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#renderpass)
    ///during a [render pass](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass) or via certain
    ///[subpass load and store operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-load-store-ops).
    ///Such access occurs in the
    ///`VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT` pipeline stage.
    pub const ACCESS2_COLOR_ATTACHMENT_WRITE: Self = Self(256);
    ///[`ACCESS2_DEPTH_STENCIL_ATTACHMENT_READ`] specifies read
    ///access to a [depth/stencil attachment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass), via
    ///[depth or stencil operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fragops-ds-state) or via certain
    ///[subpass load operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-load-store-ops).
    ///Such access occurs in the
    ///`VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT` or
    ///`VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT` pipeline stages.
    pub const ACCESS2_DEPTH_STENCIL_ATTACHMENT_READ: Self = Self(512);
    ///[`ACCESS2_DEPTH_STENCIL_ATTACHMENT_WRITE`] specifies write
    ///access to a [depth/stencil attachment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass), via
    ///[depth or stencil operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fragops-ds-state) or via certain
    ///[subpass load and store operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-load-store-ops).
    ///Such access occurs in the
    ///`VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT` or
    ///`VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT` pipeline stages.
    pub const ACCESS2_DEPTH_STENCIL_ATTACHMENT_WRITE: Self = Self(1024);
    ///[`ACCESS2_TRANSFER_READ`] specifies read access to an image or
    ///buffer in a [copy](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#copies) operation.
    ///Such access occurs in the `VK_PIPELINE_STAGE_2_COPY_BIT`,
    ///`VK_PIPELINE_STAGE_2_BLIT_BIT`, or
    ///`VK_PIPELINE_STAGE_2_RESOLVE_BIT` pipeline stages.
    pub const ACCESS2_TRANSFER_READ: Self = Self(2048);
    ///[`ACCESS2_TRANSFER_WRITE`] specifies write access to an image
    ///or buffer in a [clear](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#clears) or [copy](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#copies) operation.
    ///Such access occurs in the `VK_PIPELINE_STAGE_2_COPY_BIT`,
    ///`VK_PIPELINE_STAGE_2_BLIT_BIT`, `VK_PIPELINE_STAGE_2_CLEAR_BIT`,
    ///or `VK_PIPELINE_STAGE_2_RESOLVE_BIT` pipeline stages.
    pub const ACCESS2_TRANSFER_WRITE: Self = Self(4096);
    ///[`ACCESS2_HOST_READ`] specifies read access by a host
    ///operation.
    ///Accesses of this type are not performed through a resource, but directly
    ///on memory.
    ///Such access occurs in the `VK_PIPELINE_STAGE_2_HOST_BIT` pipeline
    ///stage.
    pub const ACCESS2_HOST_READ: Self = Self(8192);
    ///[`ACCESS2_HOST_WRITE`] specifies write access by a host
    ///operation.
    ///Accesses of this type are not performed through a resource, but directly
    ///on memory.
    ///Such access occurs in the `VK_PIPELINE_STAGE_2_HOST_BIT` pipeline
    ///stage.
    pub const ACCESS2_HOST_WRITE: Self = Self(16384);
    ///[`ACCESS2_MEMORY_READ`] specifies all read accesses.
    ///It is always valid in any access mask, and is treated as equivalent to
    ///setting all `READ` access flags that are valid where it is used.
    pub const ACCESS2_MEMORY_READ: Self = Self(32768);
    ///[`ACCESS2_MEMORY_WRITE`] specifies all write accesses.
    ///It is always valid in any access mask, and is treated as equivalent to
    ///setting all `WRITE` access flags that are valid where it is used.
    pub const ACCESS2_MEMORY_WRITE: Self = Self(65536);
    ///[`ACCESS2_SHADER_SAMPLED_READ`] specifies read access to a
    ///[uniform texel buffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-uniformtexelbuffer) or
    ///[sampled image](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-sampledimage) in any shader pipeline
    ///stage.
    pub const ACCESS2_SHADER_SAMPLED_READ: Self = Self(4294967296);
    ///[`ACCESS2_SHADER_STORAGE_READ`] specifies read access to a
    ///[storage buffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storagebuffer),
    ///[physical storage buffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-physical-storage-buffer),
    ///[storage texel buffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storagetexelbuffer), or
    ///[storage image](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storageimage) in any shader pipeline
    ///stage.
    pub const ACCESS2_SHADER_STORAGE_READ: Self = Self(8589934592);
    ///[`ACCESS2_SHADER_STORAGE_WRITE`] specifies write access to a
    ///[storage buffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storagebuffer),
    ///[physical storage buffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-physical-storage-buffer),
    ///[storage texel buffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storagetexelbuffer), or
    ///[storage image](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storageimage) in any shader pipeline
    ///stage.
    pub const ACCESS2_SHADER_STORAGE_WRITE: Self = Self(17179869184);
    ///[`ACCESS2_VIDEO_DECODE_READ_KHR`] specifies read access to an
    ///image or buffer resource as part of a [video
    ///decode operation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-decode-operations).
    ///Such access occurs in the `VK_PIPELINE_STAGE_2_VIDEO_DECODE_BIT_KHR`
    ///pipeline stage.
    ///
    ///Provided by [`crate::extensions::khr_video_decode_queue`]
    #[cfg(feature = "VK_KHR_video_decode_queue")]
    pub const ACCESS2_VIDEO_DECODE_READ_KHR: Self = Self(34359738368);
    ///[`ACCESS2_VIDEO_DECODE_WRITE_KHR`] specifies write access to
    ///an image or buffer resource as part of a [video decode operation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-decode-operations).
    ///Such access occurs in the `VK_PIPELINE_STAGE_2_VIDEO_DECODE_BIT_KHR`
    ///pipeline stage.
    ///
    ///Provided by [`crate::extensions::khr_video_decode_queue`]
    #[cfg(feature = "VK_KHR_video_decode_queue")]
    pub const ACCESS2_VIDEO_DECODE_WRITE_KHR: Self = Self(68719476736);
    ///[`ACCESS2_VIDEO_ENCODE_READ_KHR`] specifies read access to an
    ///image or buffer resource as part of a [video
    ///encode operation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-encode-operations).
    ///Such access occurs in the `VK_PIPELINE_STAGE_2_VIDEO_ENCODE_BIT_KHR`
    ///pipeline stage.
    ///
    ///Provided by [`crate::extensions::khr_video_encode_queue`]
    #[cfg(feature = "VK_KHR_video_encode_queue")]
    pub const ACCESS2_VIDEO_ENCODE_READ_KHR: Self = Self(137438953472);
    ///[`ACCESS2_VIDEO_ENCODE_WRITE_KHR`] specifies write access to
    ///an image or buffer resource as part of a [video encode operation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-encode-operations).
    ///Such access occurs in the `VK_PIPELINE_STAGE_2_VIDEO_ENCODE_BIT_KHR`
    ///pipeline stage.
    ///
    ///Provided by [`crate::extensions::khr_video_encode_queue`]
    #[cfg(feature = "VK_KHR_video_encode_queue")]
    pub const ACCESS2_VIDEO_ENCODE_WRITE_KHR: Self = Self(274877906944);
    ///[`ACCESS2_TRANSFORM_FEEDBACK_WRITE_EXT`] specifies write
    ///access to a transform feedback buffer made when transform feedback is
    ///active.
    ///Such access occurs in the
    ///`VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT` pipeline stage.
    ///
    ///Provided by [`crate::extensions::khr_synchronization2`]
    #[cfg(feature = "VK_KHR_synchronization2")]
    pub const ACCESS2_TRANSFORM_FEEDBACK_WRITE_EXT: Self = Self(33554432);
    ///[`ACCESS2_TRANSFORM_FEEDBACK_COUNTER_READ_EXT`] specifies read
    ///access to a transform feedback counter buffer which is read when
    ///[`cmd_begin_transform_feedback_ext`] executes.
    ///Such access occurs in the
    ///`VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT` pipeline stage.
    ///
    ///Provided by [`crate::extensions::khr_synchronization2`]
    #[cfg(feature = "VK_KHR_synchronization2")]
    pub const ACCESS2_TRANSFORM_FEEDBACK_COUNTER_READ_EXT: Self = Self(67108864);
    ///[`ACCESS2_TRANSFORM_FEEDBACK_COUNTER_WRITE_EXT`] specifies
    ///write access to a transform feedback counter buffer which is written
    ///when [`cmd_end_transform_feedback_ext`] executes.
    ///Such access occurs in the
    ///`VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT` pipeline stage.
    ///
    ///Provided by [`crate::extensions::khr_synchronization2`]
    #[cfg(feature = "VK_KHR_synchronization2")]
    pub const ACCESS2_TRANSFORM_FEEDBACK_COUNTER_WRITE_EXT: Self = Self(134217728);
    ///[`ACCESS2_CONDITIONAL_RENDERING_READ_EXT`] specifies read
    ///access to a predicate as part of conditional rendering.
    ///Such access occurs in the
    ///`VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT` pipeline stage.
    ///
    ///Provided by [`crate::extensions::khr_synchronization2`]
    #[cfg(feature = "VK_KHR_synchronization2")]
    pub const ACCESS2_CONDITIONAL_RENDERING_READ_EXT: Self = Self(1048576);
    ///[`ACCESS2_COMMAND_PREPROCESS_READ_NV`] specifies reads from
    ///buffer inputs to [`cmd_preprocess_generated_commands_nv`].
    ///Such access occurs in the
    ///`VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_NV` pipeline stage.
    ///
    ///Provided by [`crate::extensions::khr_synchronization2`]
    #[cfg(feature = "VK_KHR_synchronization2")]
    pub const ACCESS2_COMMAND_PREPROCESS_READ_NV: Self = Self(131072);
    ///[`ACCESS2_COMMAND_PREPROCESS_WRITE_NV`] specifies writes to
    ///the target command buffer preprocess outputs.
    ///Such access occurs in the
    ///`VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_NV` pipeline stage.
    ///
    ///Provided by [`crate::extensions::khr_synchronization2`]
    #[cfg(feature = "VK_KHR_synchronization2")]
    pub const ACCESS2_COMMAND_PREPROCESS_WRITE_NV: Self = Self(262144);
    ///[`ACCESS2_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_KHR`]
    ///specifies read access to a fragment shading rate attachment during
    ///rasterization.
    ///Such access occurs in the
    ///`VK_PIPELINE_STAGE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR`
    ///pipeline stage.
    ///
    ///Provided by [`crate::extensions::khr_synchronization2`]
    #[cfg(feature = "VK_KHR_synchronization2")]
    pub const ACCESS2_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_KHR: Self = Self(8388608);
    ///[`ACCESS2_ACCELERATION_STRUCTURE_READ_KHR`] specifies read
    ///access to an acceleration structure as part of a trace, build, or copy
    ///command, or to an [acceleration
    ///structure scratch buffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#acceleration-structure-scratch) as part of a build command.
    ///Such access occurs in the
    ///`VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR` pipeline stage or
    ///`VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR` pipeline
    ///stage.
    ///
    ///Provided by [`crate::extensions::khr_synchronization2`]
    #[cfg(feature = "VK_KHR_synchronization2")]
    pub const ACCESS2_ACCELERATION_STRUCTURE_READ_KHR: Self = Self(2097152);
    ///[`ACCESS2_ACCELERATION_STRUCTURE_WRITE_KHR`] specifies write
    ///access to an acceleration structure or [acceleration structure scratch buffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#acceleration-structure-scratch) as part of a build or copy
    ///command.
    ///Such access occurs in the
    ///`VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR` pipeline
    ///stage.
    ///
    ///Provided by [`crate::extensions::khr_synchronization2`]
    #[cfg(feature = "VK_KHR_synchronization2")]
    pub const ACCESS2_ACCELERATION_STRUCTURE_WRITE_KHR: Self = Self(4194304);
    ///[`ACCESS2_FRAGMENT_DENSITY_MAP_READ_EXT`] specifies read
    ///access to a [fragment density
    ///map attachment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-fragmentdensitymapattachment) during dynamic [fragment
    ///density map operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fragmentdensitymapops).
    ///Such access occurs in the
    ///`VK_PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT` pipeline
    ///stage.
    ///
    ///Provided by [`crate::extensions::khr_synchronization2`]
    #[cfg(feature = "VK_KHR_synchronization2")]
    pub const ACCESS2_FRAGMENT_DENSITY_MAP_READ_EXT: Self = Self(16777216);
    ///[`ACCESS2_COLOR_ATTACHMENT_READ_NONCOHERENT_EXT`] specifies
    ///read access to [color attachments](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass), including
    ///[advanced blend operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#framebuffer-blend-advanced).
    ///Such access occurs in the
    ///`VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT` pipeline stage.
    ///
    ///Provided by [`crate::extensions::khr_synchronization2`]
    #[cfg(feature = "VK_KHR_synchronization2")]
    pub const ACCESS2_COLOR_ATTACHMENT_READ_NONCOHERENT_EXT: Self = Self(524288);
    ///[`ACCESS2_INVOCATION_MASK_READ_HUAWEI`] specifies read access
    ///to a invocation mask image in the
    ///`VK_PIPELINE_STAGE_2_INVOCATION_MASK_BIT_HUAWEI` pipeline stage.
    ///
    ///Provided by [`crate::extensions::huawei_invocation_mask`]
    #[cfg(feature = "VK_HUAWEI_invocation_mask")]
    pub const ACCESS2_INVOCATION_MASK_READ_HUAWEI: Self = Self(549755813888);
    ///Default empty value
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Gets the raw underlying value
    #[inline]
    pub const fn bits(&self) -> u64 {
        self.0
    }
    ///Gets a value from a raw underlying value, unchecked and therefore unsafe.
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u64) -> Self {
        Self(bits)
    }
}
impl std::fmt::Debug for AccessFlagBits2 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(AccessFlagBits2);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == AccessFlagBits2::empty() {
                    f.write_str("empty")?;
                } else {
                    match self.0 {
                        AccessFlagBits2::ACCESS2_NONE => f.write_str("ACCESS2_NONE")?,
                        AccessFlagBits2::ACCESS2_INDIRECT_COMMAND_READ => {
                            f.write_str("ACCESS2_INDIRECT_COMMAND_READ")?
                        },
                        AccessFlagBits2::ACCESS2_INDEX_READ => f.write_str("ACCESS2_INDEX_READ")?,
                        AccessFlagBits2::ACCESS2_VERTEX_ATTRIBUTE_READ => {
                            f.write_str("ACCESS2_VERTEX_ATTRIBUTE_READ")?
                        },
                        AccessFlagBits2::ACCESS2_UNIFORM_READ => f.write_str("ACCESS2_UNIFORM_READ")?,
                        AccessFlagBits2::ACCESS2_INPUT_ATTACHMENT_READ => {
                            f.write_str("ACCESS2_INPUT_ATTACHMENT_READ")?
                        },
                        AccessFlagBits2::ACCESS2_SHADER_READ => f.write_str("ACCESS2_SHADER_READ")?,
                        AccessFlagBits2::ACCESS2_SHADER_WRITE => f.write_str("ACCESS2_SHADER_WRITE")?,
                        AccessFlagBits2::ACCESS2_COLOR_ATTACHMENT_READ => {
                            f.write_str("ACCESS2_COLOR_ATTACHMENT_READ")?
                        },
                        AccessFlagBits2::ACCESS2_COLOR_ATTACHMENT_WRITE => {
                            f.write_str("ACCESS2_COLOR_ATTACHMENT_WRITE")?
                        },
                        AccessFlagBits2::ACCESS2_DEPTH_STENCIL_ATTACHMENT_READ => {
                            f.write_str("ACCESS2_DEPTH_STENCIL_ATTACHMENT_READ")?
                        },
                        AccessFlagBits2::ACCESS2_DEPTH_STENCIL_ATTACHMENT_WRITE => {
                            f.write_str("ACCESS2_DEPTH_STENCIL_ATTACHMENT_WRITE")?
                        },
                        AccessFlagBits2::ACCESS2_TRANSFER_READ => f.write_str("ACCESS2_TRANSFER_READ")?,
                        AccessFlagBits2::ACCESS2_TRANSFER_WRITE => f.write_str("ACCESS2_TRANSFER_WRITE")?,
                        AccessFlagBits2::ACCESS2_HOST_READ => f.write_str("ACCESS2_HOST_READ")?,
                        AccessFlagBits2::ACCESS2_HOST_WRITE => f.write_str("ACCESS2_HOST_WRITE")?,
                        AccessFlagBits2::ACCESS2_MEMORY_READ => f.write_str("ACCESS2_MEMORY_READ")?,
                        AccessFlagBits2::ACCESS2_MEMORY_WRITE => f.write_str("ACCESS2_MEMORY_WRITE")?,
                        AccessFlagBits2::ACCESS2_SHADER_SAMPLED_READ => f.write_str("ACCESS2_SHADER_SAMPLED_READ")?,
                        AccessFlagBits2::ACCESS2_SHADER_STORAGE_READ => f.write_str("ACCESS2_SHADER_STORAGE_READ")?,
                        AccessFlagBits2::ACCESS2_SHADER_STORAGE_WRITE => f.write_str("ACCESS2_SHADER_STORAGE_WRITE")?,
                        #[cfg(feature = "VK_KHR_video_decode_queue")]
                        AccessFlagBits2::ACCESS2_VIDEO_DECODE_READ_KHR => {
                            f.write_str("ACCESS2_VIDEO_DECODE_READ_KHR")?
                        },
                        #[cfg(feature = "VK_KHR_video_decode_queue")]
                        AccessFlagBits2::ACCESS2_VIDEO_DECODE_WRITE_KHR => {
                            f.write_str("ACCESS2_VIDEO_DECODE_WRITE_KHR")?
                        },
                        #[cfg(feature = "VK_KHR_video_encode_queue")]
                        AccessFlagBits2::ACCESS2_VIDEO_ENCODE_READ_KHR => {
                            f.write_str("ACCESS2_VIDEO_ENCODE_READ_KHR")?
                        },
                        #[cfg(feature = "VK_KHR_video_encode_queue")]
                        AccessFlagBits2::ACCESS2_VIDEO_ENCODE_WRITE_KHR => {
                            f.write_str("ACCESS2_VIDEO_ENCODE_WRITE_KHR")?
                        },
                        #[cfg(feature = "VK_KHR_synchronization2")]
                        AccessFlagBits2::ACCESS2_TRANSFORM_FEEDBACK_WRITE_EXT => {
                            f.write_str("ACCESS2_TRANSFORM_FEEDBACK_WRITE_EXT")?
                        },
                        #[cfg(feature = "VK_KHR_synchronization2")]
                        AccessFlagBits2::ACCESS2_TRANSFORM_FEEDBACK_COUNTER_READ_EXT => {
                            f.write_str("ACCESS2_TRANSFORM_FEEDBACK_COUNTER_READ_EXT")?
                        },
                        #[cfg(feature = "VK_KHR_synchronization2")]
                        AccessFlagBits2::ACCESS2_TRANSFORM_FEEDBACK_COUNTER_WRITE_EXT => {
                            f.write_str("ACCESS2_TRANSFORM_FEEDBACK_COUNTER_WRITE_EXT")?
                        },
                        #[cfg(feature = "VK_KHR_synchronization2")]
                        AccessFlagBits2::ACCESS2_CONDITIONAL_RENDERING_READ_EXT => {
                            f.write_str("ACCESS2_CONDITIONAL_RENDERING_READ_EXT")?
                        },
                        #[cfg(feature = "VK_KHR_synchronization2")]
                        AccessFlagBits2::ACCESS2_COMMAND_PREPROCESS_READ_NV => {
                            f.write_str("ACCESS2_COMMAND_PREPROCESS_READ_NV")?
                        },
                        #[cfg(feature = "VK_KHR_synchronization2")]
                        AccessFlagBits2::ACCESS2_COMMAND_PREPROCESS_WRITE_NV => {
                            f.write_str("ACCESS2_COMMAND_PREPROCESS_WRITE_NV")?
                        },
                        #[cfg(feature = "VK_KHR_synchronization2")]
                        AccessFlagBits2::ACCESS2_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_KHR => {
                            f.write_str("ACCESS2_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_KHR")?
                        },
                        #[cfg(feature = "VK_KHR_synchronization2")]
                        AccessFlagBits2::ACCESS2_ACCELERATION_STRUCTURE_READ_KHR => {
                            f.write_str("ACCESS2_ACCELERATION_STRUCTURE_READ_KHR")?
                        },
                        #[cfg(feature = "VK_KHR_synchronization2")]
                        AccessFlagBits2::ACCESS2_ACCELERATION_STRUCTURE_WRITE_KHR => {
                            f.write_str("ACCESS2_ACCELERATION_STRUCTURE_WRITE_KHR")?
                        },
                        #[cfg(feature = "VK_KHR_synchronization2")]
                        AccessFlagBits2::ACCESS2_FRAGMENT_DENSITY_MAP_READ_EXT => {
                            f.write_str("ACCESS2_FRAGMENT_DENSITY_MAP_READ_EXT")?
                        },
                        #[cfg(feature = "VK_KHR_synchronization2")]
                        AccessFlagBits2::ACCESS2_COLOR_ATTACHMENT_READ_NONCOHERENT_EXT => {
                            f.write_str("ACCESS2_COLOR_ATTACHMENT_READ_NONCOHERENT_EXT")?
                        },
                        #[cfg(feature = "VK_HUAWEI_invocation_mask")]
                        AccessFlagBits2::ACCESS2_INVOCATION_MASK_READ_HUAWEI => {
                            f.write_str("ACCESS2_INVOCATION_MASK_READ_HUAWEI")?
                        },
                        _ => f.write_str("invalid")?,
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(AccessFlagBits2)).field(&Flags(*self)).finish()
    }
}
///[VkPipelineStageFlagBits2](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineStageFlagBits2.html) - Pipeline stage flags for VkPipelineStageFlags2
///# C Specifications
///Bits which  **can**  be set in a [`PipelineStageFlags2`] mask, specifying
///stages of execution, are:
///```c
///// Provided by VK_VERSION_1_3
///// Flag bits for VkPipelineStageFlagBits2
///typedef VkFlags64 VkPipelineStageFlagBits2;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_NONE = 0ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_NONE_KHR = 0ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_TOP_OF_PIPE_BIT = 0x00000001ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_TOP_OF_PIPE_BIT_KHR = 0x00000001ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT = 0x00000002ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT_KHR = 0x00000002ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT = 0x00000004ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT_KHR = 0x00000004ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT = 0x00000008ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT_KHR = 0x00000008ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT =
/// 0x00000010ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT_KHR =
/// 0x00000010ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT =
/// 0x00000020ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT_KHR
/// = 0x00000020ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT = 0x00000040ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT_KHR =
/// 0x00000040ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT = 0x00000080ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT_KHR =
/// 0x00000080ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT =
/// 0x00000100ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT_KHR =
/// 0x00000100ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT =
/// 0x00000200ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT_KHR =
/// 0x00000200ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT =
/// 0x00000400ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT_KHR =
/// 0x00000400ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT = 0x00000800ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT_KHR =
/// 0x00000800ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT = 0x00001000ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT_KHR = 0x00001000ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_TRANSFER_BIT = 0x00001000ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_TRANSFER_BIT_KHR = 0x00001000ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_BOTTOM_OF_PIPE_BIT = 0x00002000ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_BOTTOM_OF_PIPE_BIT_KHR =
/// 0x00002000ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_HOST_BIT = 0x00004000ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_HOST_BIT_KHR = 0x00004000ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT = 0x00008000ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT_KHR = 0x00008000ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT = 0x00010000ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT_KHR = 0x00010000ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_COPY_BIT = 0x100000000ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_COPY_BIT_KHR = 0x100000000ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_RESOLVE_BIT = 0x200000000ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_RESOLVE_BIT_KHR = 0x200000000ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_BLIT_BIT = 0x400000000ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_BLIT_BIT_KHR = 0x400000000ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_CLEAR_BIT = 0x800000000ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_CLEAR_BIT_KHR = 0x800000000ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT = 0x1000000000ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT_KHR = 0x1000000000ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT =
/// 0x2000000000ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT_KHR =
/// 0x2000000000ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_PRE_RASTERIZATION_SHADERS_BIT =
/// 0x4000000000ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_PRE_RASTERIZATION_SHADERS_BIT_KHR =
/// 0x4000000000ULL;
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///// Provided by VK_KHR_video_decode_queue
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_VIDEO_DECODE_BIT_KHR = 0x04000000ULL;
///#endif
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///// Provided by VK_KHR_video_encode_queue
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_VIDEO_ENCODE_BIT_KHR = 0x08000000ULL;
///#endif
///// Provided by VK_KHR_synchronization2 with VK_EXT_transform_feedback
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT =
/// 0x01000000ULL;
///// Provided by VK_KHR_synchronization2 with VK_EXT_conditional_rendering
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT =
/// 0x00040000ULL;
///// Provided by VK_KHR_synchronization2 with VK_NV_device_generated_commands
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_NV =
/// 0x00020000ULL;
///// Provided by VK_KHR_fragment_shading_rate with VK_KHR_synchronization2
///static const VkPipelineStageFlagBits2
/// VK_PIPELINE_STAGE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = 0x00400000ULL;
///// Provided by VK_KHR_synchronization2 with VK_NV_shading_rate_image
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_SHADING_RATE_IMAGE_BIT_NV =
/// 0x00400000ULL;
///// Provided by VK_KHR_acceleration_structure with VK_KHR_synchronization2
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR =
/// 0x02000000ULL;
///// Provided by VK_KHR_ray_tracing_pipeline with VK_KHR_synchronization2
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR =
/// 0x00200000ULL;
///// Provided by VK_KHR_synchronization2 with VK_NV_ray_tracing
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_NV =
/// 0x00200000ULL;
///// Provided by VK_KHR_synchronization2 with VK_NV_ray_tracing
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_NV =
/// 0x02000000ULL;
///// Provided by VK_KHR_synchronization2 with VK_EXT_fragment_density_map
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT =
/// 0x00800000ULL;
///// Provided by VK_KHR_synchronization2 with VK_NV_mesh_shader
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_NV = 0x00080000ULL;
///// Provided by VK_KHR_synchronization2 with VK_NV_mesh_shader
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_NV = 0x00100000ULL;
///// Provided by VK_HUAWEI_subpass_shading
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI =
/// 0x8000000000ULL;
///// Provided by VK_HUAWEI_invocation_mask
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_INVOCATION_MASK_BIT_HUAWEI =
/// 0x10000000000ULL;
///```
///or the equivalent
///```c
///// Provided by VK_KHR_synchronization2
///typedef VkPipelineStageFlagBits2 VkPipelineStageFlagBits2KHR;
///```
///# Description
/// - [`PIPELINE_STAGE2_NONE`] specifies no stages of execution.
/// - [`PIPELINE_STAGE2_DRAW_INDIRECT`] specifies the stage of the pipeline where indirect command
///   parameters are consumed. This stage also includes reading commands written by
///   [`cmd_preprocess_generated_commands_nv`].
/// - [`PIPELINE_STAGE2_TASK_SHADER_NV`] specifies the task shader stage.
/// - [`PIPELINE_STAGE2_MESH_SHADER_NV`] specifies the mesh shader stage.
/// - [`PIPELINE_STAGE2_INDEX_INPUT`] specifies the stage of the pipeline where index buffers are
///   consumed.
/// - [`PIPELINE_STAGE2_VERTEX_ATTRIBUTE_INPUT`] specifies the stage of the pipeline where vertex
///   buffers are consumed.
/// - [`PIPELINE_STAGE2_VERTEX_INPUT`] is equivalent to the logical OR of:  -
///   [`PIPELINE_STAGE2_INDEX_INPUT`]  - [`PIPELINE_STAGE2_VERTEX_ATTRIBUTE_INPUT`]
/// - [`PIPELINE_STAGE2_VERTEX_SHADER`] specifies the vertex shader stage.
/// - [`PIPELINE_STAGE2_TESSELLATION_CONTROL_SHADER`] specifies the tessellation control shader
///   stage.
/// - [`PIPELINE_STAGE2_TESSELLATION_EVALUATION_SHADER`] specifies the tessellation evaluation
///   shader stage.
/// - [`PIPELINE_STAGE2_GEOMETRY_SHADER`] specifies the geometry shader stage.
/// - [`PIPELINE_STAGE2_PRE_RASTERIZATION_SHADERS`] is equivalent to specifying all supported [pre-rasterization shader stages](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-pre-rasterization):  - [`PIPELINE_STAGE2_VERTEX_SHADER`]  - [`PIPELINE_STAGE2_TESSELLATION_CONTROL_SHADER`]  - [`PIPELINE_STAGE2_TESSELLATION_EVALUATION_SHADER`]  - [`PIPELINE_STAGE2_GEOMETRY_SHADER`]  - [`PIPELINE_STAGE2_TASK_SHADER_NV`]  - [`PIPELINE_STAGE2_MESH_SHADER_NV`]
/// - [`PIPELINE_STAGE2_FRAGMENT_SHADER`] specifies the fragment shader stage.
/// - [`PIPELINE_STAGE2_EARLY_FRAGMENT_TESTS`] specifies the stage of the pipeline where early fragment tests (depth and stencil tests before fragment shading) are performed. This stage also includes [subpass load operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-load-store-ops) for framebuffer attachments with a depth/stencil format.
/// - [`PIPELINE_STAGE2_LATE_FRAGMENT_TESTS`] specifies the stage of the pipeline where late fragment tests (depth and stencil tests after fragment shading) are performed. This stage also includes [subpass store operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-load-store-ops) for framebuffer attachments with a depth/stencil format.
/// - [`PIPELINE_STAGE2_COLOR_ATTACHMENT_OUTPUT`] specifies the stage of the pipeline after blending
///   where the final color values are output from the pipeline. This stage also includes [subpass load
///   and store operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-load-store-ops)
///   and multisample resolve operations for framebuffer attachments with a color or depth/stencil
///   format.
/// - [`PIPELINE_STAGE2_COMPUTE_SHADER`] specifies the compute shader stage.
/// - [`PIPELINE_STAGE2_HOST`] specifies a pseudo-stage indicating execution on the host of
///   reads/writes of device memory. This stage is not invoked by any commands recorded in a command
///   buffer.
/// - [`PIPELINE_STAGE2_COPY`] specifies the execution of all [copy commands](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#copies),
///   including [`cmd_copy_query_pool_results`].
/// - [`PIPELINE_STAGE2_BLIT`] specifies the execution of [`cmd_blit_image`].
/// - [`PIPELINE_STAGE2_RESOLVE`] specifies the execution of [`cmd_resolve_image`].
/// - [`PIPELINE_STAGE2_CLEAR`] specifies the execution of [clear commands](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#clears),
///   with the exception of [`cmd_clear_attachments`].
/// - [`PIPELINE_STAGE2_ALL_TRANSFER`] is equivalent to specifying all of:  -
///   [`PIPELINE_STAGE2_COPY`]  - [`PIPELINE_STAGE2_BLIT`]  - [`PIPELINE_STAGE2_RESOLVE`]  -
///   [`PIPELINE_STAGE2_CLEAR`]
/// - [`PIPELINE_STAGE2_RAY_TRACING_SHADER_KHR`] specifies the execution of the ray tracing shader
///   stages.
/// - [`PIPELINE_STAGE2_ACCELERATION_STRUCTURE_BUILD_KHR`] specifies the execution of [acceleration structure commands](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#acceleration-structure).
/// - [`PIPELINE_STAGE2_ALL_GRAPHICS`] specifies the execution of all graphics pipeline stages, and
///   is equivalent to the logical OR of:  - [`PIPELINE_STAGE2_DRAW_INDIRECT`]  -
///   [`PIPELINE_STAGE2_TASK_SHADER_NV`]  - [`PIPELINE_STAGE2_MESH_SHADER_NV`]  -
///   [`PIPELINE_STAGE2_VERTEX_INPUT`]  - [`PIPELINE_STAGE2_VERTEX_SHADER`]  -
///   [`PIPELINE_STAGE2_TESSELLATION_CONTROL_SHADER`]  -
///   [`PIPELINE_STAGE2_TESSELLATION_EVALUATION_SHADER`]  - [`PIPELINE_STAGE2_GEOMETRY_SHADER`]  -
///   [`PIPELINE_STAGE2_FRAGMENT_SHADER`]  - [`PIPELINE_STAGE2_EARLY_FRAGMENT_TESTS`]  -
///   [`PIPELINE_STAGE2_LATE_FRAGMENT_TESTS`]  - [`PIPELINE_STAGE2_COLOR_ATTACHMENT_OUTPUT`]  -
///   [`PIPELINE_STAGE2_CONDITIONAL_RENDERING_EXT`]  - [`PIPELINE_STAGE2_TRANSFORM_FEEDBACK_EXT`]  -
///   [`PIPELINE_STAGE2_SHADING_RATE_IMAGE_NV`]  - [`PIPELINE_STAGE2_FRAGMENT_DENSITY_PROCESS_EXT`]
///   - [`PIPELINE_STAGE2_INVOCATION_MASK_HUAWEI`]
/// - [`PIPELINE_STAGE2_ALL_COMMANDS`] specifies all operations performed by all commands supported
///   on the queue it is used with.
/// - [`PIPELINE_STAGE2_CONDITIONAL_RENDERING_EXT`] specifies the stage of the pipeline where the
///   predicate of conditional rendering is consumed.
/// - [`PIPELINE_STAGE2_TRANSFORM_FEEDBACK_EXT`] specifies the stage of the pipeline where vertex
///   attribute output values are written to the transform feedback buffers.
/// - [`PIPELINE_STAGE2_COMMAND_PREPROCESS_NV`] specifies the stage of the pipeline where
///   device-side generation of commands via [`cmd_preprocess_generated_commands_nv`] is handled.
/// - [`PIPELINE_STAGE2_FRAGMENT_SHADING_RATE_ATTACHMENT_KHR`]     specifies the stage of the pipeline where the     [fragment shading rate     attachment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#primsrast-fragment-shading-rate-attachment) or     [shading rate image](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#primsrast-shading-rate-image)     is read to determine the fragment shading rate for portions of a     rasterized primitive.
/// - [`PIPELINE_STAGE2_FRAGMENT_DENSITY_PROCESS_EXT`] specifies the stage of the pipeline where the
///   fragment density map is read to [generate the fragment areas](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fragmentdensitymapops).
/// - [`PIPELINE_STAGE2_INVOCATION_MASK_HUAWEI`] specifies the stage of the pipeline where the
///   invocation mask image is read by the implementation to optimize the ray dispatch.
/// - [`PIPELINE_STAGE2_VIDEO_DECODE_KHR`] specifies the stage of the pipeline where [video decode operation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-decode-operations)
///   are performed.
/// - [`PIPELINE_STAGE2_VIDEO_ENCODE_KHR`] specifies the stage of the pipeline where [video encode operation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-encode-operations)
///   are performed.
/// - [`PIPELINE_STAGE2_SUBPASS_SHADING_HUAWEI`] specifies the subpass shading shader stage.
/// - [`PIPELINE_STAGE2_TOP_OF_PIPE`] is equivalent to [`PIPELINE_STAGE2_ALL_COMMANDS`] with
///   [`AccessFlags2`] set to `0` when specified in the second synchronization scope, but equivalent
///   to [`PIPELINE_STAGE2_NONE`] in the first scope.
/// - [`PIPELINE_STAGE2_BOTTOM_OF_PIPE`] is equivalent to [`PIPELINE_STAGE2_ALL_COMMANDS`] with
///   [`AccessFlags2`] set to `0` when specified in the first synchronization scope, but equivalent
///   to [`PIPELINE_STAGE2_NONE`] in the second scope.
///# Related
/// - [`khr_synchronization2`]
/// - [`crate::vulkan1_3`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkPipelineStageFlagBits2")]
#[derive(Clone, Copy, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(transparent)]
pub struct PipelineStageFlagBits2(u64);
impl const Default for PipelineStageFlagBits2 {
    fn default() -> Self {
        Self(0)
    }
}
impl PipelineStageFlagBits2 {
    ///[`PIPELINE_STAGE2_NONE`] specifies no stages of execution.
    pub const PIPELINE_STAGE2_NONE: Self = Self(0);
    ///[`PIPELINE_STAGE2_TOP_OF_PIPE`] is equivalent to
    ///[`PIPELINE_STAGE2_ALL_COMMANDS`] with [`AccessFlags2`] set
    ///to `0` when specified in the second synchronization scope, but
    ///equivalent to [`PIPELINE_STAGE2_NONE`] in the first scope.
    pub const PIPELINE_STAGE2_TOP_OF_PIPE: Self = Self(1);
    ///[`PIPELINE_STAGE2_DRAW_INDIRECT`] specifies the stage of the
    ///pipeline where indirect command parameters are consumed.
    ///This stage also includes reading commands written by
    ///[`cmd_preprocess_generated_commands_nv`].
    pub const PIPELINE_STAGE2_DRAW_INDIRECT: Self = Self(2);
    ///[`PIPELINE_STAGE2_VERTEX_INPUT`] is equivalent to the logical
    ///OR of:
    /// - [`PIPELINE_STAGE2_INDEX_INPUT`]
    /// - [`PIPELINE_STAGE2_VERTEX_ATTRIBUTE_INPUT`]
    pub const PIPELINE_STAGE2_VERTEX_INPUT: Self = Self(4);
    ///[`PIPELINE_STAGE2_VERTEX_SHADER`] specifies the vertex shader
    ///stage.
    pub const PIPELINE_STAGE2_VERTEX_SHADER: Self = Self(8);
    ///[`PIPELINE_STAGE2_TESSELLATION_CONTROL_SHADER`] specifies the
    ///tessellation control shader stage.
    pub const PIPELINE_STAGE2_TESSELLATION_CONTROL_SHADER: Self = Self(16);
    ///[`PIPELINE_STAGE2_TESSELLATION_EVALUATION_SHADER`] specifies
    ///the tessellation evaluation shader stage.
    pub const PIPELINE_STAGE2_TESSELLATION_EVALUATION_SHADER: Self = Self(32);
    ///[`PIPELINE_STAGE2_GEOMETRY_SHADER`] specifies the geometry
    ///shader stage.
    pub const PIPELINE_STAGE2_GEOMETRY_SHADER: Self = Self(64);
    ///[`PIPELINE_STAGE2_FRAGMENT_SHADER`] specifies the fragment
    ///shader stage.
    pub const PIPELINE_STAGE2_FRAGMENT_SHADER: Self = Self(128);
    ///[`PIPELINE_STAGE2_EARLY_FRAGMENT_TESTS`] specifies the stage
    ///of the pipeline where early fragment tests (depth and stencil tests
    ///before fragment shading) are performed.
    ///This stage also includes [subpass load
    ///operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-load-store-ops) for framebuffer attachments with a depth/stencil format.
    pub const PIPELINE_STAGE2_EARLY_FRAGMENT_TESTS: Self = Self(256);
    ///[`PIPELINE_STAGE2_LATE_FRAGMENT_TESTS`] specifies the stage of
    ///the pipeline where late fragment tests (depth and stencil tests after
    ///fragment shading) are performed.
    ///This stage also includes [subpass store
    ///operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-load-store-ops) for framebuffer attachments with a depth/stencil format.
    pub const PIPELINE_STAGE2_LATE_FRAGMENT_TESTS: Self = Self(512);
    ///[`PIPELINE_STAGE2_COLOR_ATTACHMENT_OUTPUT`] specifies the
    ///stage of the pipeline after blending where the final color values are
    ///output from the pipeline.
    ///This stage also includes [subpass load and
    ///store operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-load-store-ops) and multisample resolve operations for framebuffer
    ///attachments with a color
    ///or depth/stencil
    ///format.
    pub const PIPELINE_STAGE2_COLOR_ATTACHMENT_OUTPUT: Self = Self(1024);
    ///[`PIPELINE_STAGE2_COMPUTE_SHADER`] specifies the compute
    ///shader stage.
    pub const PIPELINE_STAGE2_COMPUTE_SHADER: Self = Self(2048);
    ///[`PIPELINE_STAGE2_ALL_TRANSFER`] is equivalent to specifying
    ///all of:
    /// - [`PIPELINE_STAGE2_COPY`]
    /// - [`PIPELINE_STAGE2_BLIT`]
    /// - [`PIPELINE_STAGE2_RESOLVE`]
    /// - [`PIPELINE_STAGE2_CLEAR`]
    pub const PIPELINE_STAGE2_ALL_TRANSFER: Self = Self(4096);
    ///[`PIPELINE_STAGE2_BOTTOM_OF_PIPE`] is equivalent to
    ///[`PIPELINE_STAGE2_ALL_COMMANDS`] with [`AccessFlags2`] set
    ///to `0` when specified in the first synchronization scope, but equivalent
    ///to [`PIPELINE_STAGE2_NONE`] in the second scope.
    pub const PIPELINE_STAGE2_BOTTOM_OF_PIPE: Self = Self(8192);
    ///[`PIPELINE_STAGE2_HOST`] specifies a pseudo-stage indicating
    ///execution on the host of reads/writes of device memory.
    ///This stage is not invoked by any commands recorded in a command buffer.
    pub const PIPELINE_STAGE2_HOST: Self = Self(16384);
    ///[`PIPELINE_STAGE2_ALL_GRAPHICS`] specifies the execution of
    ///all graphics pipeline stages, and is equivalent to the logical OR of:
    /// - [`PIPELINE_STAGE2_DRAW_INDIRECT`]
    /// - [`PIPELINE_STAGE2_TASK_SHADER_NV`]
    /// - [`PIPELINE_STAGE2_MESH_SHADER_NV`]
    /// - [`PIPELINE_STAGE2_VERTEX_INPUT`]
    /// - [`PIPELINE_STAGE2_VERTEX_SHADER`]
    /// - [`PIPELINE_STAGE2_TESSELLATION_CONTROL_SHADER`]
    /// - [`PIPELINE_STAGE2_TESSELLATION_EVALUATION_SHADER`]
    /// - [`PIPELINE_STAGE2_GEOMETRY_SHADER`]
    /// - [`PIPELINE_STAGE2_FRAGMENT_SHADER`]
    /// - [`PIPELINE_STAGE2_EARLY_FRAGMENT_TESTS`]
    /// - [`PIPELINE_STAGE2_LATE_FRAGMENT_TESTS`]
    /// - [`PIPELINE_STAGE2_COLOR_ATTACHMENT_OUTPUT`]
    /// - [`PIPELINE_STAGE2_CONDITIONAL_RENDERING_EXT`]
    /// - [`PIPELINE_STAGE2_TRANSFORM_FEEDBACK_EXT`]
    /// - [`PIPELINE_STAGE2_SHADING_RATE_IMAGE_NV`]
    /// - [`PIPELINE_STAGE2_FRAGMENT_DENSITY_PROCESS_EXT`]
    /// - [`PIPELINE_STAGE2_INVOCATION_MASK_HUAWEI`]
    pub const PIPELINE_STAGE2_ALL_GRAPHICS: Self = Self(32768);
    ///[`PIPELINE_STAGE2_ALL_COMMANDS`] specifies all operations
    ///performed by all commands supported on the queue it is used with.
    pub const PIPELINE_STAGE2_ALL_COMMANDS: Self = Self(65536);
    ///[`PIPELINE_STAGE2_COPY`] specifies the execution of all
    ///[copy commands](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#copies), including [`cmd_copy_query_pool_results`].
    pub const PIPELINE_STAGE2_COPY: Self = Self(4294967296);
    ///[`PIPELINE_STAGE2_RESOLVE`] specifies the execution of
    ///[`cmd_resolve_image`].
    pub const PIPELINE_STAGE2_RESOLVE: Self = Self(8589934592);
    ///[`PIPELINE_STAGE2_BLIT`] specifies the execution of
    ///[`cmd_blit_image`].
    pub const PIPELINE_STAGE2_BLIT: Self = Self(17179869184);
    ///[`PIPELINE_STAGE2_CLEAR`] specifies the execution of
    ///[clear commands](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#clears), with the exception of
    ///[`cmd_clear_attachments`].
    pub const PIPELINE_STAGE2_CLEAR: Self = Self(34359738368);
    ///[`PIPELINE_STAGE2_INDEX_INPUT`] specifies the stage of the
    ///pipeline where index buffers are consumed.
    pub const PIPELINE_STAGE2_INDEX_INPUT: Self = Self(68719476736);
    ///[`PIPELINE_STAGE2_VERTEX_ATTRIBUTE_INPUT`] specifies the stage
    ///of the pipeline where vertex buffers are consumed.
    pub const PIPELINE_STAGE2_VERTEX_ATTRIBUTE_INPUT: Self = Self(137438953472);
    ///[`PIPELINE_STAGE2_PRE_RASTERIZATION_SHADERS`] is equivalent to
    ///specifying all supported
    ///[pre-rasterization shader
    ///stages](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-pre-rasterization):
    /// - [`PIPELINE_STAGE2_VERTEX_SHADER`]
    /// - [`PIPELINE_STAGE2_TESSELLATION_CONTROL_SHADER`]
    /// - [`PIPELINE_STAGE2_TESSELLATION_EVALUATION_SHADER`]
    /// - [`PIPELINE_STAGE2_GEOMETRY_SHADER`]
    /// - [`PIPELINE_STAGE2_TASK_SHADER_NV`]
    /// - [`PIPELINE_STAGE2_MESH_SHADER_NV`]
    pub const PIPELINE_STAGE2_PRE_RASTERIZATION_SHADERS: Self = Self(274877906944);
    ///[`PIPELINE_STAGE2_VIDEO_DECODE_KHR`] specifies the stage of
    ///the pipeline where [video decode operation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-decode-operations)
    ///are performed.
    ///
    ///Provided by [`crate::extensions::khr_video_decode_queue`]
    #[cfg(feature = "VK_KHR_video_decode_queue")]
    pub const PIPELINE_STAGE2_VIDEO_DECODE_KHR: Self = Self(67108864);
    ///[`PIPELINE_STAGE2_VIDEO_ENCODE_KHR`] specifies the stage of
    ///the pipeline where [video encode operation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-encode-operations)
    ///are performed.
    ///
    ///Provided by [`crate::extensions::khr_video_encode_queue`]
    #[cfg(feature = "VK_KHR_video_encode_queue")]
    pub const PIPELINE_STAGE2_VIDEO_ENCODE_KHR: Self = Self(134217728);
    ///[`PIPELINE_STAGE2_TRANSFORM_FEEDBACK_EXT`]
    ///
    ///Provided by [`crate::extensions::khr_synchronization2`]
    #[cfg(feature = "VK_KHR_synchronization2")]
    pub const PIPELINE_STAGE2_TRANSFORM_FEEDBACK_EXT: Self = Self(16777216);
    ///[`PIPELINE_STAGE2_CONDITIONAL_RENDERING_EXT`]
    ///
    ///Provided by [`crate::extensions::khr_synchronization2`]
    #[cfg(feature = "VK_KHR_synchronization2")]
    pub const PIPELINE_STAGE2_CONDITIONAL_RENDERING_EXT: Self = Self(262144);
    ///[`PIPELINE_STAGE2_COMMAND_PREPROCESS_NV`] specifies the stage
    ///of the pipeline where device-side generation of commands via
    ///[`cmd_preprocess_generated_commands_nv`] is handled.
    ///
    ///Provided by [`crate::extensions::khr_synchronization2`]
    #[cfg(feature = "VK_KHR_synchronization2")]
    pub const PIPELINE_STAGE2_COMMAND_PREPROCESS_NV: Self = Self(131072);
    ///[`PIPELINE_STAGE2_FRAGMENT_SHADING_RATE_ATTACHMENT_KHR`]
    ///    specifies the stage of the pipeline where the
    ///    [fragment shading rate
    ///    attachment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#primsrast-fragment-shading-rate-attachment)
    ///or
    ///    [shading rate image](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#primsrast-shading-rate-image)
    ///    is read to determine the fragment shading rate for portions of a
    ///    rasterized primitive.
    ///
    ///Provided by [`crate::extensions::khr_synchronization2`]
    #[cfg(feature = "VK_KHR_synchronization2")]
    pub const PIPELINE_STAGE2_FRAGMENT_SHADING_RATE_ATTACHMENT_KHR: Self = Self(4194304);
    ///[`PIPELINE_STAGE2_ACCELERATION_STRUCTURE_BUILD_KHR`] specifies
    ///the execution of [acceleration structure
    ///commands](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#acceleration-structure).
    ///
    ///Provided by [`crate::extensions::khr_synchronization2`]
    #[cfg(feature = "VK_KHR_synchronization2")]
    pub const PIPELINE_STAGE2_ACCELERATION_STRUCTURE_BUILD_KHR: Self = Self(33554432);
    ///[`PIPELINE_STAGE2_RAY_TRACING_SHADER_KHR`] specifies the
    ///execution of the ray tracing shader stages.
    ///
    ///Provided by [`crate::extensions::khr_synchronization2`]
    #[cfg(feature = "VK_KHR_synchronization2")]
    pub const PIPELINE_STAGE2_RAY_TRACING_SHADER_KHR: Self = Self(2097152);
    ///[`PIPELINE_STAGE2_FRAGMENT_DENSITY_PROCESS_EXT`]
    ///
    ///Provided by [`crate::extensions::khr_synchronization2`]
    #[cfg(feature = "VK_KHR_synchronization2")]
    pub const PIPELINE_STAGE2_FRAGMENT_DENSITY_PROCESS_EXT: Self = Self(8388608);
    ///[`PIPELINE_STAGE2_TASK_SHADER_NV`] specifies the task shader
    ///stage.
    ///
    ///Provided by [`crate::extensions::khr_synchronization2`]
    #[cfg(feature = "VK_KHR_synchronization2")]
    pub const PIPELINE_STAGE2_TASK_SHADER_NV: Self = Self(524288);
    ///[`PIPELINE_STAGE2_MESH_SHADER_NV`] specifies the mesh shader
    ///stage.
    ///
    ///Provided by [`crate::extensions::khr_synchronization2`]
    #[cfg(feature = "VK_KHR_synchronization2")]
    pub const PIPELINE_STAGE2_MESH_SHADER_NV: Self = Self(1048576);
    ///[`PIPELINE_STAGE2_SUBPASS_SHADING_HUAWEI`] specifies the
    ///subpass shading shader stage.
    ///
    ///Provided by [`crate::extensions::huawei_subpass_shading`]
    #[cfg(feature = "VK_HUAWEI_subpass_shading")]
    pub const PIPELINE_STAGE2_SUBPASS_SHADING_HUAWEI: Self = Self(549755813888);
    ///[`PIPELINE_STAGE2_INVOCATION_MASK_HUAWEI`]
    ///
    ///Provided by [`crate::extensions::huawei_invocation_mask`]
    #[cfg(feature = "VK_HUAWEI_invocation_mask")]
    pub const PIPELINE_STAGE2_INVOCATION_MASK_HUAWEI: Self = Self(1099511627776);
    ///Default empty value
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Gets the raw underlying value
    #[inline]
    pub const fn bits(&self) -> u64 {
        self.0
    }
    ///Gets a value from a raw underlying value, unchecked and therefore unsafe.
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u64) -> Self {
        Self(bits)
    }
}
impl std::fmt::Debug for PipelineStageFlagBits2 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(PipelineStageFlagBits2);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == PipelineStageFlagBits2::empty() {
                    f.write_str("empty")?;
                } else {
                    match self.0 {
                        PipelineStageFlagBits2::PIPELINE_STAGE2_NONE => f.write_str("PIPELINE_STAGE2_NONE")?,
                        PipelineStageFlagBits2::PIPELINE_STAGE2_TOP_OF_PIPE => {
                            f.write_str("PIPELINE_STAGE2_TOP_OF_PIPE")?
                        },
                        PipelineStageFlagBits2::PIPELINE_STAGE2_DRAW_INDIRECT => {
                            f.write_str("PIPELINE_STAGE2_DRAW_INDIRECT")?
                        },
                        PipelineStageFlagBits2::PIPELINE_STAGE2_VERTEX_INPUT => {
                            f.write_str("PIPELINE_STAGE2_VERTEX_INPUT")?
                        },
                        PipelineStageFlagBits2::PIPELINE_STAGE2_VERTEX_SHADER => {
                            f.write_str("PIPELINE_STAGE2_VERTEX_SHADER")?
                        },
                        PipelineStageFlagBits2::PIPELINE_STAGE2_TESSELLATION_CONTROL_SHADER => {
                            f.write_str("PIPELINE_STAGE2_TESSELLATION_CONTROL_SHADER")?
                        },
                        PipelineStageFlagBits2::PIPELINE_STAGE2_TESSELLATION_EVALUATION_SHADER => {
                            f.write_str("PIPELINE_STAGE2_TESSELLATION_EVALUATION_SHADER")?
                        },
                        PipelineStageFlagBits2::PIPELINE_STAGE2_GEOMETRY_SHADER => {
                            f.write_str("PIPELINE_STAGE2_GEOMETRY_SHADER")?
                        },
                        PipelineStageFlagBits2::PIPELINE_STAGE2_FRAGMENT_SHADER => {
                            f.write_str("PIPELINE_STAGE2_FRAGMENT_SHADER")?
                        },
                        PipelineStageFlagBits2::PIPELINE_STAGE2_EARLY_FRAGMENT_TESTS => {
                            f.write_str("PIPELINE_STAGE2_EARLY_FRAGMENT_TESTS")?
                        },
                        PipelineStageFlagBits2::PIPELINE_STAGE2_LATE_FRAGMENT_TESTS => {
                            f.write_str("PIPELINE_STAGE2_LATE_FRAGMENT_TESTS")?
                        },
                        PipelineStageFlagBits2::PIPELINE_STAGE2_COLOR_ATTACHMENT_OUTPUT => {
                            f.write_str("PIPELINE_STAGE2_COLOR_ATTACHMENT_OUTPUT")?
                        },
                        PipelineStageFlagBits2::PIPELINE_STAGE2_COMPUTE_SHADER => {
                            f.write_str("PIPELINE_STAGE2_COMPUTE_SHADER")?
                        },
                        PipelineStageFlagBits2::PIPELINE_STAGE2_ALL_TRANSFER => {
                            f.write_str("PIPELINE_STAGE2_ALL_TRANSFER")?
                        },
                        PipelineStageFlagBits2::PIPELINE_STAGE2_BOTTOM_OF_PIPE => {
                            f.write_str("PIPELINE_STAGE2_BOTTOM_OF_PIPE")?
                        },
                        PipelineStageFlagBits2::PIPELINE_STAGE2_HOST => f.write_str("PIPELINE_STAGE2_HOST")?,
                        PipelineStageFlagBits2::PIPELINE_STAGE2_ALL_GRAPHICS => {
                            f.write_str("PIPELINE_STAGE2_ALL_GRAPHICS")?
                        },
                        PipelineStageFlagBits2::PIPELINE_STAGE2_ALL_COMMANDS => {
                            f.write_str("PIPELINE_STAGE2_ALL_COMMANDS")?
                        },
                        PipelineStageFlagBits2::PIPELINE_STAGE2_COPY => f.write_str("PIPELINE_STAGE2_COPY")?,
                        PipelineStageFlagBits2::PIPELINE_STAGE2_RESOLVE => f.write_str("PIPELINE_STAGE2_RESOLVE")?,
                        PipelineStageFlagBits2::PIPELINE_STAGE2_BLIT => f.write_str("PIPELINE_STAGE2_BLIT")?,
                        PipelineStageFlagBits2::PIPELINE_STAGE2_CLEAR => f.write_str("PIPELINE_STAGE2_CLEAR")?,
                        PipelineStageFlagBits2::PIPELINE_STAGE2_INDEX_INPUT => {
                            f.write_str("PIPELINE_STAGE2_INDEX_INPUT")?
                        },
                        PipelineStageFlagBits2::PIPELINE_STAGE2_VERTEX_ATTRIBUTE_INPUT => {
                            f.write_str("PIPELINE_STAGE2_VERTEX_ATTRIBUTE_INPUT")?
                        },
                        PipelineStageFlagBits2::PIPELINE_STAGE2_PRE_RASTERIZATION_SHADERS => {
                            f.write_str("PIPELINE_STAGE2_PRE_RASTERIZATION_SHADERS")?
                        },
                        #[cfg(feature = "VK_KHR_video_decode_queue")]
                        PipelineStageFlagBits2::PIPELINE_STAGE2_VIDEO_DECODE_KHR => {
                            f.write_str("PIPELINE_STAGE2_VIDEO_DECODE_KHR")?
                        },
                        #[cfg(feature = "VK_KHR_video_encode_queue")]
                        PipelineStageFlagBits2::PIPELINE_STAGE2_VIDEO_ENCODE_KHR => {
                            f.write_str("PIPELINE_STAGE2_VIDEO_ENCODE_KHR")?
                        },
                        #[cfg(feature = "VK_KHR_synchronization2")]
                        PipelineStageFlagBits2::PIPELINE_STAGE2_TRANSFORM_FEEDBACK_EXT => {
                            f.write_str("PIPELINE_STAGE2_TRANSFORM_FEEDBACK_EXT")?
                        },
                        #[cfg(feature = "VK_KHR_synchronization2")]
                        PipelineStageFlagBits2::PIPELINE_STAGE2_CONDITIONAL_RENDERING_EXT => {
                            f.write_str("PIPELINE_STAGE2_CONDITIONAL_RENDERING_EXT")?
                        },
                        #[cfg(feature = "VK_KHR_synchronization2")]
                        PipelineStageFlagBits2::PIPELINE_STAGE2_COMMAND_PREPROCESS_NV => {
                            f.write_str("PIPELINE_STAGE2_COMMAND_PREPROCESS_NV")?
                        },
                        #[cfg(feature = "VK_KHR_synchronization2")]
                        PipelineStageFlagBits2::PIPELINE_STAGE2_FRAGMENT_SHADING_RATE_ATTACHMENT_KHR => {
                            f.write_str("PIPELINE_STAGE2_FRAGMENT_SHADING_RATE_ATTACHMENT_KHR")?
                        },
                        #[cfg(feature = "VK_KHR_synchronization2")]
                        PipelineStageFlagBits2::PIPELINE_STAGE2_ACCELERATION_STRUCTURE_BUILD_KHR => {
                            f.write_str("PIPELINE_STAGE2_ACCELERATION_STRUCTURE_BUILD_KHR")?
                        },
                        #[cfg(feature = "VK_KHR_synchronization2")]
                        PipelineStageFlagBits2::PIPELINE_STAGE2_RAY_TRACING_SHADER_KHR => {
                            f.write_str("PIPELINE_STAGE2_RAY_TRACING_SHADER_KHR")?
                        },
                        #[cfg(feature = "VK_KHR_synchronization2")]
                        PipelineStageFlagBits2::PIPELINE_STAGE2_FRAGMENT_DENSITY_PROCESS_EXT => {
                            f.write_str("PIPELINE_STAGE2_FRAGMENT_DENSITY_PROCESS_EXT")?
                        },
                        #[cfg(feature = "VK_KHR_synchronization2")]
                        PipelineStageFlagBits2::PIPELINE_STAGE2_TASK_SHADER_NV => {
                            f.write_str("PIPELINE_STAGE2_TASK_SHADER_NV")?
                        },
                        #[cfg(feature = "VK_KHR_synchronization2")]
                        PipelineStageFlagBits2::PIPELINE_STAGE2_MESH_SHADER_NV => {
                            f.write_str("PIPELINE_STAGE2_MESH_SHADER_NV")?
                        },
                        #[cfg(feature = "VK_HUAWEI_subpass_shading")]
                        PipelineStageFlagBits2::PIPELINE_STAGE2_SUBPASS_SHADING_HUAWEI => {
                            f.write_str("PIPELINE_STAGE2_SUBPASS_SHADING_HUAWEI")?
                        },
                        #[cfg(feature = "VK_HUAWEI_invocation_mask")]
                        PipelineStageFlagBits2::PIPELINE_STAGE2_INVOCATION_MASK_HUAWEI => {
                            f.write_str("PIPELINE_STAGE2_INVOCATION_MASK_HUAWEI")?
                        },
                        _ => f.write_str("invalid")?,
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(PipelineStageFlagBits2))
            .field(&Flags(*self))
            .finish()
    }
}
///[VkSubmitFlagBits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSubmitFlagBits.html) - Bitmask specifying behavior of a submission
///# C Specifications
///Bits which  **can**  be set in [`SubmitInfo2::flags`], specifying
///submission behavior, are:
///```c
///// Provided by VK_VERSION_1_3
///typedef enum VkSubmitFlagBits {
///    VK_SUBMIT_PROTECTED_BIT = 0x00000001,
///    VK_SUBMIT_PROTECTED_BIT_KHR = VK_SUBMIT_PROTECTED_BIT,
///} VkSubmitFlagBits;
///```
///or the equivalent
///```c
///// Provided by VK_KHR_synchronization2
///typedef VkSubmitFlagBits VkSubmitFlagBitsKHR;
///```
///# Description
/// - [`PROTECTED`] specifies that this batch is a protected submission.
///# Related
/// - [`khr_synchronization2`]
/// - [`crate::vulkan1_3`]
/// - [`SubmitFlags`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkSubmitFlagBits")]
#[derive(Clone, Copy, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(transparent)]
pub struct SubmitFlagBits(u32);
impl const Default for SubmitFlagBits {
    fn default() -> Self {
        Self(0)
    }
}
impl SubmitFlagBits {
    ///[`PROTECTED`] specifies that this batch is a protected
    ///submission.
    pub const PROTECTED: Self = Self(1);
    ///Default empty value
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Gets the raw underlying value
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Gets a value from a raw underlying value, unchecked and therefore unsafe.
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
}
impl std::fmt::Debug for SubmitFlagBits {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(SubmitFlagBits);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == SubmitFlagBits::empty() {
                    f.write_str("empty")?;
                } else {
                    match self.0 {
                        SubmitFlagBits::PROTECTED => f.write_str("PROTECTED")?,
                        _ => f.write_str("invalid")?,
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(SubmitFlagBits)).field(&Flags(*self)).finish()
    }
}
///[VkFormatFeatureFlagBits2](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFormatFeatureFlagBits2.html) - Bitmask specifying features supported by a buffer
///# C Specifications
///Bits which  **can**  be set in the [`FormatProperties3`] features
///`linearTilingFeatures`, `optimalTilingFeatures`, and
///`bufferFeatures` are:
///```c
///// Provided by VK_VERSION_1_3
///// Flag bits for VkFormatFeatureFlagBits2
///typedef VkFlags64 VkFormatFeatureFlagBits2;
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_BIT = 0x00000001ULL;
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_BIT_KHR = 0x00000001ULL;
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_STORAGE_IMAGE_BIT = 0x00000002ULL;
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_STORAGE_IMAGE_BIT_KHR = 0x00000002ULL;
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_STORAGE_IMAGE_ATOMIC_BIT =
/// 0x00000004ULL;
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_STORAGE_IMAGE_ATOMIC_BIT_KHR =
/// 0x00000004ULL;
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_UNIFORM_TEXEL_BUFFER_BIT =
/// 0x00000008ULL;
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_UNIFORM_TEXEL_BUFFER_BIT_KHR =
/// 0x00000008ULL;
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_BIT =
/// 0x00000010ULL;
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_BIT_KHR =
/// 0x00000010ULL;
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_ATOMIC_BIT =
/// 0x00000020ULL;
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_ATOMIC_BIT_KHR =
/// 0x00000020ULL;
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_VERTEX_BUFFER_BIT = 0x00000040ULL;
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_VERTEX_BUFFER_BIT_KHR = 0x00000040ULL;
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BIT = 0x00000080ULL;
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BIT_KHR =
/// 0x00000080ULL;
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BLEND_BIT =
/// 0x00000100ULL;
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BLEND_BIT_KHR =
/// 0x00000100ULL;
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_DEPTH_STENCIL_ATTACHMENT_BIT =
/// 0x00000200ULL;
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_DEPTH_STENCIL_ATTACHMENT_BIT_KHR =
/// 0x00000200ULL;
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_BLIT_SRC_BIT = 0x00000400ULL;
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_BLIT_SRC_BIT_KHR = 0x00000400ULL;
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_BLIT_DST_BIT = 0x00000800ULL;
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_BLIT_DST_BIT_KHR = 0x00000800ULL;
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_LINEAR_BIT =
/// 0x00001000ULL;
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_LINEAR_BIT_KHR =
/// 0x00001000ULL;
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_CUBIC_BIT =
/// 0x00002000ULL;
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT =
/// 0x00002000ULL;
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_TRANSFER_SRC_BIT = 0x00004000ULL;
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_TRANSFER_SRC_BIT_KHR = 0x00004000ULL;
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_TRANSFER_DST_BIT = 0x00008000ULL;
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_TRANSFER_DST_BIT_KHR = 0x00008000ULL;
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_MINMAX_BIT =
/// 0x00010000ULL;
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_MINMAX_BIT_KHR =
/// 0x00010000ULL;
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_MIDPOINT_CHROMA_SAMPLES_BIT =
/// 0x00020000ULL;
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_MIDPOINT_CHROMA_SAMPLES_BIT_KHR =
/// 0x00020000ULL;
///static const VkFormatFeatureFlagBits2
/// VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT = 0x00040000ULL;
///static const VkFormatFeatureFlagBits2
/// VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR = 0x00040000ULL;
///static const VkFormatFeatureFlagBits2
/// VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT =
/// 0x00080000ULL;
///static const VkFormatFeatureFlagBits2
/// VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR =
/// 0x00080000ULL;
///static const VkFormatFeatureFlagBits2
/// VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT =
/// 0x00100000ULL;
///static const VkFormatFeatureFlagBits2
/// VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR =
/// 0x00100000ULL;
///static const VkFormatFeatureFlagBits2
/// VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT
/// = 0x00200000ULL;
///static const VkFormatFeatureFlagBits2
/// VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR
/// = 0x00200000ULL;
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_DISJOINT_BIT = 0x00400000ULL;
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_DISJOINT_BIT_KHR = 0x00400000ULL;
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_COSITED_CHROMA_SAMPLES_BIT =
/// 0x00800000ULL;
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_COSITED_CHROMA_SAMPLES_BIT_KHR =
/// 0x00800000ULL;
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT =
/// 0x80000000ULL;
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT_KHR =
/// 0x80000000ULL;
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT =
/// 0x100000000ULL;
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT_KHR =
/// 0x100000000ULL;
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT =
/// 0x200000000ULL;
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT_KHR
/// = 0x200000000ULL;
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///// Provided by VK_KHR_format_feature_flags2 with VK_KHR_video_decode_queue
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_VIDEO_DECODE_OUTPUT_BIT_KHR =
/// 0x02000000ULL;
///#endif
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///// Provided by VK_KHR_format_feature_flags2 with VK_KHR_video_decode_queue
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_VIDEO_DECODE_DPB_BIT_KHR =
/// 0x04000000ULL;
///#endif
///// Provided by VK_KHR_acceleration_structure with VK_KHR_format_feature_flags2
///static const VkFormatFeatureFlagBits2
/// VK_FORMAT_FEATURE_2_ACCELERATION_STRUCTURE_VERTEX_BUFFER_BIT_KHR = 0x20000000ULL;
///// Provided by VK_KHR_format_feature_flags2 with VK_EXT_fragment_density_map
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_FRAGMENT_DENSITY_MAP_BIT_EXT =
/// 0x01000000ULL;
///// Provided by VK_KHR_format_feature_flags2 with VK_KHR_fragment_shading_rate
///static const VkFormatFeatureFlagBits2
/// VK_FORMAT_FEATURE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = 0x40000000ULL;
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///// Provided by VK_KHR_format_feature_flags2 with VK_KHR_video_encode_queue
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_VIDEO_ENCODE_INPUT_BIT_KHR =
/// 0x08000000ULL;
///#endif
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///// Provided by VK_KHR_format_feature_flags2 with VK_KHR_video_encode_queue
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_VIDEO_ENCODE_DPB_BIT_KHR =
/// 0x10000000ULL;
///#endif
///// Provided by VK_KHR_format_feature_flags2 with VK_NV_linear_color_attachment
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_LINEAR_COLOR_ATTACHMENT_BIT_NV =
/// 0x4000000000ULL;
///```
///or the equivalent
///```c
///// Provided by VK_KHR_format_feature_flags2
///typedef VkFormatFeatureFlagBits2 VkFormatFeatureFlagBits2KHR;
///```
///# Description
///The following bits  **may**  be set in `linearTilingFeatures` and
///`optimalTilingFeatures`, specifying that the features are supported by
///[`Image`] or [`ImageView`]
///or [`SamplerYcbcrConversion`]
///created with the queried
///[`get_physical_device_format_properties2`]`::format`:
/// - [`FORMAT_FEATURE2_SAMPLED_IMAGE`] specifies that an image view  **can**  be [sampled from](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-sampledimage).
/// - [`FORMAT_FEATURE2_STORAGE_IMAGE`] specifies that an image view  **can**  be used as a [storage
///   image](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storageimage).
/// - [`FORMAT_FEATURE2_STORAGE_IMAGE_ATOMIC`] specifies that an image view  **can**  be used as
///   storage image that supports atomic operations.
/// - [`FORMAT_FEATURE2_COLOR_ATTACHMENT`] specifies that an image view  **can**  be used as a
///   framebuffer color attachment and as an input attachment.
/// - [`FORMAT_FEATURE2_COLOR_ATTACHMENT_BLEND`] specifies that an image view  **can**  be used as a
///   framebuffer color attachment that supports blending and as an input attachment.
/// - [`FORMAT_FEATURE2_DEPTH_STENCIL_ATTACHMENT`] specifies that an image view  **can**  be used as
///   a framebuffer depth/stencil attachment and as an input attachment.
/// - [`FORMAT_FEATURE2_BLIT_SRC`] specifies that an image  **can**  be     used as the `srcImage`
///   for [`cmd_blit_image2`] and     [`cmd_blit_image`].
/// - [`FORMAT_FEATURE2_BLIT_DST`] specifies that an image  **can**  be     used as the `dstImage`
///   for [`cmd_blit_image2`] and     [`cmd_blit_image`].
/// - [`FORMAT_FEATURE2_SAMPLED_IMAGE_FILTER_LINEAR`] specifies that     if
///   [`FORMAT_FEATURE2_SAMPLED_IMAGE`] is also set, an image     view  **can**  be used with a
///   sampler that has either of `magFilter` or     `minFilter` set to `VK_FILTER_LINEAR`, or
///   `mipmapMode` set     to `VK_SAMPLER_MIPMAP_MODE_LINEAR`.     If [`FORMAT_FEATURE2_BLIT_SRC`]
///   is also set, an image can be     used as the `srcImage` for [`cmd_blit_image2`] and
///   [`cmd_blit_image`] with a `filter` of `VK_FILTER_LINEAR`.     This bit  **must**  only be
///   exposed for formats that also support the     [`FORMAT_FEATURE2_SAMPLED_IMAGE`] or
///   [`FORMAT_FEATURE2_BLIT_SRC`].If the format being queried is a depth/stencil format, this bit
///   only specifies that the depth aspect (not the stencil aspect) of an image of this format
///   supports linear filtering. Where depth comparison is supported it  **may**  be linear filtered
///   whether this bit is present or not, but where this bit is not present the filtered value
///   **may**  be computed in an implementation-dependent manner which differs from the normal rules
///   of linear filtering. The resulting value  **must**  be in the range [0,1] and  **should**  be
///   proportional to, or a weighted average of, the number of comparison passes or failures.
/// - [`FORMAT_FEATURE2_TRANSFER_SRC`] specifies that an image  **can**  be used as a source image for [copy commands](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#copies).
/// - [`FORMAT_FEATURE2_TRANSFER_DST`] specifies that an image  **can**  be used as a destination image for [copy commands](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#copies) and [clear commands](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#clears).
/// - [`FORMAT_FEATURE2_SAMPLED_IMAGE_FILTER_MINMAX`] specifies [`Image`] **can**  be used as a
///   sampled image with a min or max [`SamplerReductionMode`]. This bit  **must**  only be exposed
///   for formats that also support the [`FORMAT_FEATURE2_SAMPLED_IMAGE`].
/// - [`FORMAT_FEATURE2_SAMPLED_IMAGE_FILTER_CUBIC`] specifies that [`Image`] **can**  be used with
///   a sampler that has either of `magFilter` or `minFilter` set to `VK_FILTER_CUBIC_EXT`, or be
///   the source image for a blit with `filter` set to `VK_FILTER_CUBIC_EXT`. This bit  **must**
///   only be exposed for formats that also support the [`FORMAT_FEATURE2_SAMPLED_IMAGE`]. If the
///   format being queried is a depth/stencil format, this only specifies that the depth aspect is
///   cubic filterable.
/// - [`FORMAT_FEATURE2_MIDPOINT_CHROMA_SAMPLES`] specifies that an application  **can**  define a [sampler YC<sub>B</sub>C<sub>R</sub> conversion](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#samplers-YCbCr-conversion) using this format as a source, and that an image of this format  **can**  be used with a [`SamplerYcbcrConversionCreateInfo`]`xChromaOffset` and/or `yChromaOffset` of `VK_CHROMA_LOCATION_MIDPOINT`. Otherwise both `xChromaOffset` and `yChromaOffset` **must**  be `VK_CHROMA_LOCATION_COSITED_EVEN`. If a format does not incorporate chroma downsampling (it is not a 422 or 420 format) but the implementation supports sampler YC<sub>B</sub>C<sub>R</sub> conversion for this format, the implementation  **must**  set [`FORMAT_FEATURE2_MIDPOINT_CHROMA_SAMPLES`].
/// - [`FORMAT_FEATURE2_COSITED_CHROMA_SAMPLES`] specifies that an application  **can**  define a [sampler YC<sub>B</sub>C<sub>R</sub> conversion](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#samplers-YCbCr-conversion) using this format as a source, and that an image of this format  **can**  be used with a [`SamplerYcbcrConversionCreateInfo`]`xChromaOffset` and/or `yChromaOffset` of `VK_CHROMA_LOCATION_COSITED_EVEN`. Otherwise both `xChromaOffset` and `yChromaOffset` **must**  be `VK_CHROMA_LOCATION_MIDPOINT`. If neither [`FORMAT_FEATURE2_COSITED_CHROMA_SAMPLES`] nor [`FORMAT_FEATURE2_MIDPOINT_CHROMA_SAMPLES`] is set, the application  **must**  not define a [sampler YC<sub>B</sub>C<sub>R</sub> conversion](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#samplers-YCbCr-conversion) using this format as a source.
/// - [`FORMAT_FEATURE2_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER`] specifies that an application
///   **can**  define a [sampler YC<sub>B</sub>C<sub>R</sub> conversion](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#samplers-YCbCr-conversion)
///   using this format as a source with `chromaFilter` set to `VK_FILTER_LINEAR`.
/// - [`FORMAT_FEATURE2_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER`] specifies
///   that the format can have different chroma, min, and mag filters.
/// - [`FORMAT_FEATURE2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT`] specifies that reconstruction is explicit, as described in [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#textures-chroma-reconstruction](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#textures-chroma-reconstruction). If this bit is not present, reconstruction is implicit by default.
/// - [`FORMAT_FEATURE2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE`]
///   specifies that reconstruction  **can**  be forcibly made explicit by setting
///   [`SamplerYcbcrConversionCreateInfo::force_explicit_reconstruction`] to [`TRUE`]. If the format
///   being queried supports
///   [`FORMAT_FEATURE2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT`] it  **must**
///   also support
///   [`FORMAT_FEATURE2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE`].
/// - [`FORMAT_FEATURE2_DISJOINT`] specifies that a multi-planar image  **can**  have the
///   `VK_IMAGE_CREATE_DISJOINT_BIT` set during image creation. An implementation  **must**  not set
///   [`FORMAT_FEATURE2_DISJOINT`] for *single-plane formats*.
/// - [`FORMAT_FEATURE2_FRAGMENT_DENSITY_MAP_EXT`] specifies that an image view  **can**  be used as
///   a [fragment density map attachment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-fragmentdensitymapattachment).
/// - [`FORMAT_FEATURE2_FRAGMENT_SHADING_RATE_ATTACHMENT_KHR`] specifies that an image view  **can**
///   be used as a [fragment shading rate attachment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#primsrast-fragment-shading-rate-attachment).
///   An implementation  **must**  not set this feature for formats with numeric type other than
///   `*UINT`, or set it as a buffer feature.
/// - [`FORMAT_FEATURE2_VIDEO_DECODE_OUTPUT_KHR`] specifies that an image view with this format  **can**  be used as an output for [video decode operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-decode-operations)
/// - [`FORMAT_FEATURE2_VIDEO_DECODE_DPB_KHR`] specifies that an image view with this format  **can**  be used as a DPB for [video decode operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-decode-operations)
/// - [`FORMAT_FEATURE2_VIDEO_ENCODE_INPUT_KHR`] specifies that an image view with this format  **can**  be used as an input to [video encode operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-encode-operations)
/// - [`FORMAT_FEATURE2_VIDEO_ENCODE_DPB_KHR`] specifies that an image view with this format  **can**  be used as a DPB for [video encode operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-encode-operations)
/// - [`FORMAT_FEATURE2_STORAGE_READ_WITHOUT_FORMAT`] specifies that image views created with this format  **can**  be used as [storage images](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storageimage) for read operations without specifying a format.
/// - [`FORMAT_FEATURE2_STORAGE_WRITE_WITHOUT_FORMAT`] specifies that image views created with this format  **can**  be used as [storage images](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storageimage) for write operations without specifying a format.
/// - [`FORMAT_FEATURE2_SAMPLED_IMAGE_DEPTH_COMPARISON`] specifies that image views created with
///   this format  **can**  be used for depth comparison performed by `OpImage*Dref*` instructions.
/// - [`FORMAT_FEATURE2_LINEAR_COLOR_ATTACHMENT_NV`] specifies that    the format is supported as a renderable [Linear Color    Attachment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#glossary).    This bit will be set for renderable color formats in the    `linearTilingFeatures`. This  **must**  not be set in the `optimalTilingFeatures` or `bufferFeatures` members.
///The following bits  **may**  be set in `bufferFeatures`, specifying that the
///features are supported by [`Buffer`] or [`BufferView`] created with the queried
///[`get_physical_device_format_properties2`]`::format`:
/// - [`FORMAT_FEATURE2_UNIFORM_TEXEL_BUFFER`] specifies that the format  **can**  be used to create
///   a buffer view that  **can**  be bound to a `VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER`
///   descriptor.
/// - [`FORMAT_FEATURE2_STORAGE_TEXEL_BUFFER`] specifies that the format  **can**  be used to create
///   a buffer view that  **can**  be bound to a `VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER`
///   descriptor.
/// - [`FORMAT_FEATURE2_STORAGE_TEXEL_BUFFER_ATOMIC`] specifies that atomic operations are supported
///   on `VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER` with this format.
/// - [`FORMAT_FEATURE2_VERTEX_BUFFER`] specifies that the format  **can**  be used as a vertex
///   attribute format ([`VertexInputAttributeDescription::format`]).
/// - [`FORMAT_FEATURE2_ACCELERATION_STRUCTURE_VERTEX_BUFFER_KHR`] specifies that the format  **can**  be used as the vertex format when creating an [acceleration structure](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#acceleration-structure) ([`AccelerationStructureGeometryTrianglesDataKHR::vertex_format`]). This format  **can**  also be used as the vertex format in host memory when doing [host acceleration structure](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#host-acceleration-structure) builds.
///# Related
/// - [`khr_format_feature_flags2`]
/// - [`crate::vulkan1_3`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkFormatFeatureFlagBits2")]
#[derive(Clone, Copy, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(transparent)]
pub struct FormatFeatureFlagBits2(u64);
impl const Default for FormatFeatureFlagBits2 {
    fn default() -> Self {
        Self(0)
    }
}
impl FormatFeatureFlagBits2 {
    ///[`FORMAT_FEATURE2_SAMPLED_IMAGE`] specifies that an image view
    /// **can**  be [sampled from](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-sampledimage).
    pub const FORMAT_FEATURE2_SAMPLED_IMAGE: Self = Self(1);
    ///[`FORMAT_FEATURE2_STORAGE_IMAGE`] specifies that an image view
    /// **can**  be used as a [storage image](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storageimage).
    pub const FORMAT_FEATURE2_STORAGE_IMAGE: Self = Self(2);
    ///[`FORMAT_FEATURE2_STORAGE_IMAGE_ATOMIC`] specifies that an
    ///image view  **can**  be used as storage image that supports atomic
    ///operations.
    pub const FORMAT_FEATURE2_STORAGE_IMAGE_ATOMIC: Self = Self(4);
    ///[`FORMAT_FEATURE2_UNIFORM_TEXEL_BUFFER`] specifies that the
    ///format  **can**  be used to create a buffer view that  **can**  be bound to a
    ///`VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER` descriptor.
    pub const FORMAT_FEATURE2_UNIFORM_TEXEL_BUFFER: Self = Self(8);
    ///[`FORMAT_FEATURE2_STORAGE_TEXEL_BUFFER`] specifies that the
    ///format  **can**  be used to create a buffer view that  **can**  be bound to a
    ///`VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER` descriptor.
    pub const FORMAT_FEATURE2_STORAGE_TEXEL_BUFFER: Self = Self(16);
    ///[`FORMAT_FEATURE2_STORAGE_TEXEL_BUFFER_ATOMIC`] specifies that
    ///atomic operations are supported on
    ///`VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER` with this format.
    pub const FORMAT_FEATURE2_STORAGE_TEXEL_BUFFER_ATOMIC: Self = Self(32);
    ///[`FORMAT_FEATURE2_VERTEX_BUFFER`] specifies that the format
    /// **can**  be used as a vertex attribute format
    ///([`VertexInputAttributeDescription`]::`format`).
    pub const FORMAT_FEATURE2_VERTEX_BUFFER: Self = Self(64);
    ///[`FORMAT_FEATURE2_COLOR_ATTACHMENT`] specifies that an image
    ///view  **can**  be used as a framebuffer color attachment and as an input
    ///attachment.
    pub const FORMAT_FEATURE2_COLOR_ATTACHMENT: Self = Self(128);
    ///[`FORMAT_FEATURE2_COLOR_ATTACHMENT_BLEND`] specifies that an
    ///image view  **can**  be used as a framebuffer color attachment that supports
    ///blending and as an input attachment.
    pub const FORMAT_FEATURE2_COLOR_ATTACHMENT_BLEND: Self = Self(256);
    ///[`FORMAT_FEATURE2_DEPTH_STENCIL_ATTACHMENT`] specifies that an
    ///image view  **can**  be used as a framebuffer depth/stencil attachment and as
    ///an input attachment.
    pub const FORMAT_FEATURE2_DEPTH_STENCIL_ATTACHMENT: Self = Self(512);
    ///[`FORMAT_FEATURE2_BLIT_SRC`] specifies that an image  **can**  be
    ///    used as the `srcImage` for
    ///[`cmd_blit_image2`] and
    ///    [`cmd_blit_image`].
    pub const FORMAT_FEATURE2_BLIT_SRC: Self = Self(1024);
    ///[`FORMAT_FEATURE2_BLIT_DST`] specifies that an image  **can**  be
    ///    used as the `dstImage` for
    ///[`cmd_blit_image2`] and
    ///    [`cmd_blit_image`].
    pub const FORMAT_FEATURE2_BLIT_DST: Self = Self(2048);
    ///[`FORMAT_FEATURE2_SAMPLED_IMAGE_FILTER_LINEAR`] specifies that
    ///    if [`FORMAT_FEATURE2_SAMPLED_IMAGE`] is also set, an image
    ///    view  **can**  be used with a sampler that has either of `magFilter` or
    ///    `minFilter` set to `VK_FILTER_LINEAR`, or `mipmapMode` set
    ///    to `VK_SAMPLER_MIPMAP_MODE_LINEAR`.
    ///    If [`FORMAT_FEATURE2_BLIT_SRC`] is also set, an image can be
    ///    used as the `srcImage` for
    ///[`cmd_blit_image2`] and
    ///    [`cmd_blit_image`] with a `filter` of `VK_FILTER_LINEAR`.
    ///    This bit  **must**  only be exposed for formats that also support the
    ///    [`FORMAT_FEATURE2_SAMPLED_IMAGE`] or
    ///    [`FORMAT_FEATURE2_BLIT_SRC`].If the format being queried is a depth/stencil format, this
    /// bit only specifies that the depth aspect (not the stencil aspect) of an image of this
    ///format supports linear filtering.
    ///Where depth comparison is supported it  **may**  be linear filtered whether this
    ///bit is present or not, but where this bit is not present the filtered value
    /// **may**  be computed in an implementation-dependent manner which differs from
    ///the normal rules of linear filtering.
    ///The resulting value  **must**  be in the range [0,1] and  **should**  be
    ///proportional to, or a weighted average of, the number of comparison passes
    ///or failures.
    pub const FORMAT_FEATURE2_SAMPLED_IMAGE_FILTER_LINEAR: Self = Self(4096);
    ///[`FORMAT_FEATURE2_SAMPLED_IMAGE_FILTER_CUBIC`] specifies that
    ///[`Image`] **can**  be used with a sampler that has either of
    ///`magFilter` or `minFilter` set to `VK_FILTER_CUBIC_EXT`, or
    ///be the source image for a blit with `filter` set to
    ///`VK_FILTER_CUBIC_EXT`.
    ///This bit  **must**  only be exposed for formats that also support the
    ///[`FORMAT_FEATURE2_SAMPLED_IMAGE`].
    ///If the format being queried is a depth/stencil format, this only
    ///specifies that the depth aspect is cubic filterable.
    pub const FORMAT_FEATURE2_SAMPLED_IMAGE_FILTER_CUBIC: Self = Self(8192);
    ///[`FORMAT_FEATURE2_TRANSFER_SRC`] specifies that an image  **can**
    ///be used as a source image for [copy commands](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#copies).
    pub const FORMAT_FEATURE2_TRANSFER_SRC: Self = Self(16384);
    ///[`FORMAT_FEATURE2_TRANSFER_DST`] specifies that an image  **can**
    ///be used as a destination image for [copy commands](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#copies) and
    ///[clear commands](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#clears).
    pub const FORMAT_FEATURE2_TRANSFER_DST: Self = Self(32768);
    ///[`FORMAT_FEATURE2_SAMPLED_IMAGE_FILTER_MINMAX`] specifies
    ///[`Image`] **can**  be used as a sampled image with a min or max
    ///[`SamplerReductionMode`].
    ///This bit  **must**  only be exposed for formats that also support the
    ///[`FORMAT_FEATURE2_SAMPLED_IMAGE`].
    pub const FORMAT_FEATURE2_SAMPLED_IMAGE_FILTER_MINMAX: Self = Self(65536);
    ///[`FORMAT_FEATURE2_MIDPOINT_CHROMA_SAMPLES`] specifies that an
    ///application  **can**  define a [sampler YC<sub>B</sub>C<sub>R</sub>
    ///conversion](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#samplers-YCbCr-conversion) using this format as a source, and that an image of this
    ///format  **can**  be used with a [`SamplerYcbcrConversionCreateInfo`]`xChromaOffset` and/or
    /// `yChromaOffset` of `VK_CHROMA_LOCATION_MIDPOINT`.
    ///Otherwise both `xChromaOffset` and `yChromaOffset` **must**  be
    ///`VK_CHROMA_LOCATION_COSITED_EVEN`.
    ///If a format does not incorporate chroma downsampling (it is not a
    ///422 or 420 format) but the implementation supports sampler
    ///YC<sub>B</sub>C<sub>R</sub> conversion for this format, the implementation  **must**  set
    ///[`FORMAT_FEATURE2_MIDPOINT_CHROMA_SAMPLES`].
    pub const FORMAT_FEATURE2_MIDPOINT_CHROMA_SAMPLES: Self = Self(131072);
    ///[`FORMAT_FEATURE2_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER`]
    ///specifies that an application  **can**  define a
    ///[sampler YC<sub>B</sub>C<sub>R</sub> conversion](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#samplers-YCbCr-conversion) using this
    ///format as a source with `chromaFilter` set to
    ///`VK_FILTER_LINEAR`.
    pub const FORMAT_FEATURE2_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER: Self = Self(262144);
    ///[`FORMAT_FEATURE2_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER`]
    ///specifies that the format can have different chroma, min, and mag
    ///filters.
    pub const FORMAT_FEATURE2_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER: Self = Self(524288);
    ///[`FORMAT_FEATURE2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT`]
    ///specifies that reconstruction is explicit, as described in
    ///[https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#textures-chroma-reconstruction](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#textures-chroma-reconstruction).
    ///If this bit is not present, reconstruction is implicit by default.
    pub const FORMAT_FEATURE2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT: Self = Self(1048576);
    ///[`FORMAT_FEATURE2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE`]
    ///specifies that reconstruction  **can**  be forcibly made explicit by setting
    ///[`SamplerYcbcrConversionCreateInfo`]::`forceExplicitReconstruction`
    ///to [`TRUE`].
    ///If the format being queried supports
    ///[`FORMAT_FEATURE2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT`]
    ///it  **must**  also support
    ///[`FORMAT_FEATURE2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE`].
    pub const FORMAT_FEATURE2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE: Self =
        Self(2097152);
    ///[`FORMAT_FEATURE2_DISJOINT`] specifies that a multi-planar
    ///image  **can**  have the `VK_IMAGE_CREATE_DISJOINT_BIT` set during image
    ///creation.
    ///An implementation  **must**  not set [`FORMAT_FEATURE2_DISJOINT`]
    ///for *single-plane formats*.
    pub const FORMAT_FEATURE2_DISJOINT: Self = Self(4194304);
    ///[`FORMAT_FEATURE2_COSITED_CHROMA_SAMPLES`] specifies that an
    ///application  **can**  define a [sampler YC<sub>B</sub>C<sub>R</sub>
    ///conversion](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#samplers-YCbCr-conversion) using this format as a source, and that an image of this
    ///format  **can**  be used with a [`SamplerYcbcrConversionCreateInfo`]`xChromaOffset` and/or
    /// `yChromaOffset` of `VK_CHROMA_LOCATION_COSITED_EVEN`.
    ///Otherwise both `xChromaOffset` and `yChromaOffset` **must**  be
    ///`VK_CHROMA_LOCATION_MIDPOINT`.
    ///If neither [`FORMAT_FEATURE2_COSITED_CHROMA_SAMPLES`] nor
    ///[`FORMAT_FEATURE2_MIDPOINT_CHROMA_SAMPLES`] is set, the
    ///application  **must**  not define a [sampler
    ///YC<sub>B</sub>C<sub>R</sub> conversion](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#samplers-YCbCr-conversion) using this format as a source.
    pub const FORMAT_FEATURE2_COSITED_CHROMA_SAMPLES: Self = Self(8388608);
    ///[`FORMAT_FEATURE2_STORAGE_READ_WITHOUT_FORMAT`] specifies that
    ///image views created with this format  **can**  be used as
    ///[storage images](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storageimage) for read operations
    ///without specifying a format.
    pub const FORMAT_FEATURE2_STORAGE_READ_WITHOUT_FORMAT: Self = Self(2147483648);
    ///[`FORMAT_FEATURE2_STORAGE_WRITE_WITHOUT_FORMAT`] specifies
    ///that image views created with this format  **can**  be used as
    ///[storage images](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storageimage) for write operations
    ///without specifying a format.
    pub const FORMAT_FEATURE2_STORAGE_WRITE_WITHOUT_FORMAT: Self = Self(4294967296);
    ///[`FORMAT_FEATURE2_SAMPLED_IMAGE_DEPTH_COMPARISON`] specifies
    ///that image views created with this format  **can**  be used for depth
    ///comparison performed by `OpImage*Dref*` instructions.
    pub const FORMAT_FEATURE2_SAMPLED_IMAGE_DEPTH_COMPARISON: Self = Self(8589934592);
    ///[`FORMAT_FEATURE2_VIDEO_DECODE_OUTPUT_KHR`] specifies that an
    ///image view with this format  **can**  be used as an output for
    ///[video decode operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-decode-operations)
    ///
    ///Provided by [`crate::extensions::khr_video_decode_queue`]
    #[cfg(feature = "VK_KHR_video_decode_queue")]
    pub const FORMAT_FEATURE2_VIDEO_DECODE_OUTPUT_KHR: Self = Self(33554432);
    ///[`FORMAT_FEATURE2_VIDEO_DECODE_DPB_KHR`] specifies that an
    ///image view with this format  **can**  be used as a DPB for
    ///[video decode operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-decode-operations)
    ///
    ///Provided by [`crate::extensions::khr_video_decode_queue`]
    #[cfg(feature = "VK_KHR_video_decode_queue")]
    pub const FORMAT_FEATURE2_VIDEO_DECODE_DPB_KHR: Self = Self(67108864);
    ///[`FORMAT_FEATURE2_ACCELERATION_STRUCTURE_VERTEX_BUFFER_KHR`]
    ///specifies that the format  **can**  be used as the vertex format when
    ///creating an [acceleration structure](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#acceleration-structure)
    ///([`AccelerationStructureGeometryTrianglesDataKHR`]::`vertexFormat`).
    ///This format  **can**  also be used as the vertex format in host memory when
    ///doing [host acceleration structure](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#host-acceleration-structure)
    ///builds.
    ///
    ///Provided by [`crate::extensions::khr_acceleration_structure`]
    #[cfg(feature = "VK_KHR_acceleration_structure")]
    pub const FORMAT_FEATURE2_ACCELERATION_STRUCTURE_VERTEX_BUFFER_KHR: Self = Self(536870912);
    ///[`FORMAT_FEATURE2_FRAGMENT_DENSITY_MAP_EXT`] specifies that an
    ///image view  **can**  be used as a
    ///[fragment density map
    ///attachment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-fragmentdensitymapattachment).
    ///
    ///Provided by [`crate::extensions::ext_fragment_density_map`]
    #[cfg(feature = "VK_EXT_fragment_density_map")]
    pub const FORMAT_FEATURE2_FRAGMENT_DENSITY_MAP_EXT: Self = Self(16777216);
    ///[`FORMAT_FEATURE2_FRAGMENT_SHADING_RATE_ATTACHMENT_KHR`]
    ///specifies that an image view  **can**  be used as a
    ///[fragment shading rate
    ///attachment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#primsrast-fragment-shading-rate-attachment).
    ///An implementation  **must**  not set this feature for formats with numeric
    ///type other than `*UINT`, or set it as a buffer feature.
    ///
    ///Provided by [`crate::extensions::khr_fragment_shading_rate`]
    #[cfg(feature = "VK_KHR_fragment_shading_rate")]
    pub const FORMAT_FEATURE2_FRAGMENT_SHADING_RATE_ATTACHMENT_KHR: Self = Self(1073741824);
    ///[`FORMAT_FEATURE2_VIDEO_ENCODE_INPUT_KHR`] specifies that an
    ///image view with this format  **can**  be used as an input to
    ///[video encode operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-encode-operations)
    ///
    ///Provided by [`crate::extensions::khr_video_encode_queue`]
    #[cfg(feature = "VK_KHR_video_encode_queue")]
    pub const FORMAT_FEATURE2_VIDEO_ENCODE_INPUT_KHR: Self = Self(134217728);
    ///[`FORMAT_FEATURE2_VIDEO_ENCODE_DPB_KHR`] specifies that an
    ///image view with this format  **can**  be used as a DPB for
    ///[video encode operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-encode-operations)
    ///
    ///Provided by [`crate::extensions::khr_video_encode_queue`]
    #[cfg(feature = "VK_KHR_video_encode_queue")]
    pub const FORMAT_FEATURE2_VIDEO_ENCODE_DPB_KHR: Self = Self(268435456);
    ///[`FORMAT_FEATURE2_LINEAR_COLOR_ATTACHMENT_NV`] specifies that
    ///   the format is supported as a renderable [Linear Color
    ///   Attachment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#glossary).
    ///   This bit will be set for renderable color formats in the
    ///   `linearTilingFeatures`.
    ///This  **must**  not be set in the `optimalTilingFeatures` or
    ///`bufferFeatures` members.
    ///
    ///Provided by [`crate::extensions::nv_linear_color_attachment`]
    #[cfg(feature = "VK_NV_linear_color_attachment")]
    pub const FORMAT_FEATURE2_LINEAR_COLOR_ATTACHMENT_NV: Self = Self(274877906944);
    ///Default empty value
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Gets the raw underlying value
    #[inline]
    pub const fn bits(&self) -> u64 {
        self.0
    }
    ///Gets a value from a raw underlying value, unchecked and therefore unsafe.
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u64) -> Self {
        Self(bits)
    }
}
impl std::fmt::Debug for FormatFeatureFlagBits2 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(FormatFeatureFlagBits2);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == FormatFeatureFlagBits2::empty() {
                    f.write_str("empty")?;
                } else {
                    match self . 0 { FormatFeatureFlagBits2 :: FORMAT_FEATURE2_SAMPLED_IMAGE => f . write_str ("FORMAT_FEATURE2_SAMPLED_IMAGE") ? , FormatFeatureFlagBits2 :: FORMAT_FEATURE2_STORAGE_IMAGE => f . write_str ("FORMAT_FEATURE2_STORAGE_IMAGE") ? , FormatFeatureFlagBits2 :: FORMAT_FEATURE2_STORAGE_IMAGE_ATOMIC => f . write_str ("FORMAT_FEATURE2_STORAGE_IMAGE_ATOMIC") ? , FormatFeatureFlagBits2 :: FORMAT_FEATURE2_UNIFORM_TEXEL_BUFFER => f . write_str ("FORMAT_FEATURE2_UNIFORM_TEXEL_BUFFER") ? , FormatFeatureFlagBits2 :: FORMAT_FEATURE2_STORAGE_TEXEL_BUFFER => f . write_str ("FORMAT_FEATURE2_STORAGE_TEXEL_BUFFER") ? , FormatFeatureFlagBits2 :: FORMAT_FEATURE2_STORAGE_TEXEL_BUFFER_ATOMIC => f . write_str ("FORMAT_FEATURE2_STORAGE_TEXEL_BUFFER_ATOMIC") ? , FormatFeatureFlagBits2 :: FORMAT_FEATURE2_VERTEX_BUFFER => f . write_str ("FORMAT_FEATURE2_VERTEX_BUFFER") ? , FormatFeatureFlagBits2 :: FORMAT_FEATURE2_COLOR_ATTACHMENT => f . write_str ("FORMAT_FEATURE2_COLOR_ATTACHMENT") ? , FormatFeatureFlagBits2 :: FORMAT_FEATURE2_COLOR_ATTACHMENT_BLEND => f . write_str ("FORMAT_FEATURE2_COLOR_ATTACHMENT_BLEND") ? , FormatFeatureFlagBits2 :: FORMAT_FEATURE2_DEPTH_STENCIL_ATTACHMENT => f . write_str ("FORMAT_FEATURE2_DEPTH_STENCIL_ATTACHMENT") ? , FormatFeatureFlagBits2 :: FORMAT_FEATURE2_BLIT_SRC => f . write_str ("FORMAT_FEATURE2_BLIT_SRC") ? , FormatFeatureFlagBits2 :: FORMAT_FEATURE2_BLIT_DST => f . write_str ("FORMAT_FEATURE2_BLIT_DST") ? , FormatFeatureFlagBits2 :: FORMAT_FEATURE2_SAMPLED_IMAGE_FILTER_LINEAR => f . write_str ("FORMAT_FEATURE2_SAMPLED_IMAGE_FILTER_LINEAR") ? , FormatFeatureFlagBits2 :: FORMAT_FEATURE2_SAMPLED_IMAGE_FILTER_CUBIC => f . write_str ("FORMAT_FEATURE2_SAMPLED_IMAGE_FILTER_CUBIC") ? , FormatFeatureFlagBits2 :: FORMAT_FEATURE2_TRANSFER_SRC => f . write_str ("FORMAT_FEATURE2_TRANSFER_SRC") ? , FormatFeatureFlagBits2 :: FORMAT_FEATURE2_TRANSFER_DST => f . write_str ("FORMAT_FEATURE2_TRANSFER_DST") ? , FormatFeatureFlagBits2 :: FORMAT_FEATURE2_SAMPLED_IMAGE_FILTER_MINMAX => f . write_str ("FORMAT_FEATURE2_SAMPLED_IMAGE_FILTER_MINMAX") ? , FormatFeatureFlagBits2 :: FORMAT_FEATURE2_MIDPOINT_CHROMA_SAMPLES => f . write_str ("FORMAT_FEATURE2_MIDPOINT_CHROMA_SAMPLES") ? , FormatFeatureFlagBits2 :: FORMAT_FEATURE2_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER => f . write_str ("FORMAT_FEATURE2_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER") ? , FormatFeatureFlagBits2 :: FORMAT_FEATURE2_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER => f . write_str ("FORMAT_FEATURE2_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER") ? , FormatFeatureFlagBits2 :: FORMAT_FEATURE2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT => f . write_str ("FORMAT_FEATURE2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT") ? , FormatFeatureFlagBits2 :: FORMAT_FEATURE2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE => f . write_str ("FORMAT_FEATURE2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE") ? , FormatFeatureFlagBits2 :: FORMAT_FEATURE2_DISJOINT => f . write_str ("FORMAT_FEATURE2_DISJOINT") ? , FormatFeatureFlagBits2 :: FORMAT_FEATURE2_COSITED_CHROMA_SAMPLES => f . write_str ("FORMAT_FEATURE2_COSITED_CHROMA_SAMPLES") ? , FormatFeatureFlagBits2 :: FORMAT_FEATURE2_STORAGE_READ_WITHOUT_FORMAT => f . write_str ("FORMAT_FEATURE2_STORAGE_READ_WITHOUT_FORMAT") ? , FormatFeatureFlagBits2 :: FORMAT_FEATURE2_STORAGE_WRITE_WITHOUT_FORMAT => f . write_str ("FORMAT_FEATURE2_STORAGE_WRITE_WITHOUT_FORMAT") ? , FormatFeatureFlagBits2 :: FORMAT_FEATURE2_SAMPLED_IMAGE_DEPTH_COMPARISON => f . write_str ("FORMAT_FEATURE2_SAMPLED_IMAGE_DEPTH_COMPARISON") ? , # [cfg (feature = "VK_KHR_video_decode_queue")] FormatFeatureFlagBits2 :: FORMAT_FEATURE2_VIDEO_DECODE_OUTPUT_KHR => f . write_str ("FORMAT_FEATURE2_VIDEO_DECODE_OUTPUT_KHR") ? , # [cfg (feature = "VK_KHR_video_decode_queue")] FormatFeatureFlagBits2 :: FORMAT_FEATURE2_VIDEO_DECODE_DPB_KHR => f . write_str ("FORMAT_FEATURE2_VIDEO_DECODE_DPB_KHR") ? , # [cfg (feature = "VK_KHR_acceleration_structure")] FormatFeatureFlagBits2 :: FORMAT_FEATURE2_ACCELERATION_STRUCTURE_VERTEX_BUFFER_KHR => f . write_str ("FORMAT_FEATURE2_ACCELERATION_STRUCTURE_VERTEX_BUFFER_KHR") ? , # [cfg (feature = "VK_EXT_fragment_density_map")] FormatFeatureFlagBits2 :: FORMAT_FEATURE2_FRAGMENT_DENSITY_MAP_EXT => f . write_str ("FORMAT_FEATURE2_FRAGMENT_DENSITY_MAP_EXT") ? , # [cfg (feature = "VK_KHR_fragment_shading_rate")] FormatFeatureFlagBits2 :: FORMAT_FEATURE2_FRAGMENT_SHADING_RATE_ATTACHMENT_KHR => f . write_str ("FORMAT_FEATURE2_FRAGMENT_SHADING_RATE_ATTACHMENT_KHR") ? , # [cfg (feature = "VK_KHR_video_encode_queue")] FormatFeatureFlagBits2 :: FORMAT_FEATURE2_VIDEO_ENCODE_INPUT_KHR => f . write_str ("FORMAT_FEATURE2_VIDEO_ENCODE_INPUT_KHR") ? , # [cfg (feature = "VK_KHR_video_encode_queue")] FormatFeatureFlagBits2 :: FORMAT_FEATURE2_VIDEO_ENCODE_DPB_KHR => f . write_str ("FORMAT_FEATURE2_VIDEO_ENCODE_DPB_KHR") ? , # [cfg (feature = "VK_NV_linear_color_attachment")] FormatFeatureFlagBits2 :: FORMAT_FEATURE2_LINEAR_COLOR_ATTACHMENT_NV => f . write_str ("FORMAT_FEATURE2_LINEAR_COLOR_ATTACHMENT_NV") ? , _ => f . write_str ("invalid") ? }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(FormatFeatureFlagBits2))
            .field(&Flags(*self))
            .finish()
    }
}
///[VkRenderingFlagBits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderingFlagBits.html) - Bitmask specifying additional properties of a dynamic render pass instance
///# C Specifications
///Bits which  **can**  be set in [`RenderingInfo::flags`] describing
///additional properties of the render pass are:
///```c
///// Provided by VK_VERSION_1_3
///typedef enum VkRenderingFlagBits {
///    VK_RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT = 0x00000001,
///    VK_RENDERING_SUSPENDING_BIT = 0x00000002,
///    VK_RENDERING_RESUMING_BIT = 0x00000004,
///    VK_RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT_KHR =
/// VK_RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT,
///    VK_RENDERING_SUSPENDING_BIT_KHR = VK_RENDERING_SUSPENDING_BIT,
///    VK_RENDERING_RESUMING_BIT_KHR = VK_RENDERING_RESUMING_BIT,
///} VkRenderingFlagBits;
///```
///or the equivalent
///```c
///// Provided by VK_KHR_dynamic_rendering
///typedef VkRenderingFlagBits VkRenderingFlagBitsKHR;
///```
///# Description
/// - [`CONTENTS_SECONDARY_COMMAND_BUFFERS`] specifies that draw calls for the render pass instance
///   will be recorded in secondary command buffers.
/// - [`RESUMING`] specifies that the render pass instance is resuming an earlier suspended render
///   pass instance.
/// - [`SUSPENDING`] specifies that the render pass instance will be suspended.
///The contents of `pRenderingInfo` **must**  match between suspended render
///pass instances and the render pass instances that resume them, other than
///the presence or absence of the [`RESUMING`],
///[`SUSPENDING`], and
///[`CONTENTS_SECONDARY_COMMAND_BUFFERS`] flags.
///No action or synchronization commands, or other render pass instances, are
///allowed between suspending and resuming render pass instances.
///# Related
/// - [`khr_dynamic_rendering`]
/// - [`crate::vulkan1_3`]
/// - [`RenderingFlags`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkRenderingFlagBits")]
#[derive(Clone, Copy, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(transparent)]
pub struct RenderingFlagBits(u32);
impl const Default for RenderingFlagBits {
    fn default() -> Self {
        Self(0)
    }
}
impl RenderingFlagBits {
    ///[`CONTENTS_SECONDARY_COMMAND_BUFFERS`] specifies that
    ///draw calls for the render pass instance will be recorded in secondary
    ///command buffers.
    pub const CONTENTS_SECONDARY_COMMAND_BUFFERS: Self = Self(1);
    ///[`SUSPENDING`] specifies that the render pass
    ///instance will be suspended.
    pub const SUSPENDING: Self = Self(2);
    ///[`RESUMING`] specifies that the render pass instance
    ///is resuming an earlier suspended render pass instance.
    pub const RESUMING: Self = Self(4);
    ///Default empty value
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Gets the raw underlying value
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Gets a value from a raw underlying value, unchecked and therefore unsafe.
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
}
impl std::fmt::Debug for RenderingFlagBits {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(RenderingFlagBits);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == RenderingFlagBits::empty() {
                    f.write_str("empty")?;
                } else {
                    match self.0 {
                        RenderingFlagBits::CONTENTS_SECONDARY_COMMAND_BUFFERS => {
                            f.write_str("CONTENTS_SECONDARY_COMMAND_BUFFERS")?
                        },
                        RenderingFlagBits::SUSPENDING => f.write_str("SUSPENDING")?,
                        RenderingFlagBits::RESUMING => f.write_str("RESUMING")?,
                        _ => f.write_str("invalid")?,
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(RenderingFlagBits))
            .field(&Flags(*self))
            .finish()
    }
}
///[VkPrivateDataSlotCreateFlags](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPrivateDataSlotCreateFlags.html) - Reserved for future use
///# C Specifications
///```c
///// Provided by VK_VERSION_1_3
///typedef VkFlags VkPrivateDataSlotCreateFlags;
///```
///or the equivalent
///```c
///// Provided by VK_EXT_private_data
///typedef VkPrivateDataSlotCreateFlags VkPrivateDataSlotCreateFlagsEXT;
///```
///# Related
/// - [`ext_private_data`]
/// - [`crate::vulkan1_3`]
/// - [`PrivateDataSlotCreateInfo`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Clone, Copy, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(transparent)]
pub struct PrivateDataSlotCreateFlags(u32);
impl const Default for PrivateDataSlotCreateFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl std::fmt::Debug for PrivateDataSlotCreateFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        f.debug_tuple(stringify!(PrivateDataSlotCreateFlags))
            .field(&self.0)
            .finish()
    }
}
///[VkPipelineCreationFeedbackFlagBits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineCreationFeedbackFlagBits.html) - Bitmask specifying pipeline or pipeline stage creation feedback
///# C Specifications
///Possible values of the `flags` member of
///[`PipelineCreationFeedback`] are:
///```c
///// Provided by VK_VERSION_1_3
///typedef enum VkPipelineCreationFeedbackFlagBits {
///    VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT = 0x00000001,
///    VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT = 0x00000002,
///    VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT = 0x00000004,
///    VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT_EXT = VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT,
///    VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT_EXT =
/// VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT,
///    VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT_EXT =
/// VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT,
///} VkPipelineCreationFeedbackFlagBits;
///```
///or the equivalent
///```c
///// Provided by VK_EXT_pipeline_creation_feedback
///typedef VkPipelineCreationFeedbackFlagBits VkPipelineCreationFeedbackFlagBitsEXT;
///```
///# Description
/// - [`VALID`] indicates that the feedback information is valid.
/// - [`APPLICATION_PIPELINE_CACHE_HIT`] indicates that a readily usable pipeline or pipeline stage
///   was found in the `pipelineCache` specified by the application in the pipeline creation
///   command.An implementation  **should**  set the [`APPLICATION_PIPELINE_CACHE_HIT`] bit if it
///   was able to avoid the large majority of pipeline or pipeline stage creation work by using the
///   `pipelineCache` parameter of [`create_graphics_pipelines`],
///   [`create_ray_tracing_pipelines_khr`], [`create_ray_tracing_pipelines_nv`], or
///   [`create_compute_pipelines`]. When an implementation sets this bit for the entire pipeline, it
///   **may**  leave it unset for any stage.
/// - [`BASE_PIPELINE_ACCELERATION`] indicates that the base pipeline specified by the
///   `basePipelineHandle` or `basePipelineIndex` member of the `Vk*PipelineCreateInfo` structure
///   was used to accelerate the creation of the pipeline.An implementation  **should**  set the
///   [`BASE_PIPELINE_ACCELERATION`] bit if it was able to avoid a significant amount of work by
///   using the base pipeline.
///# Related
/// - [`ext_pipeline_creation_feedback`]
/// - [`crate::vulkan1_3`]
/// - [`PipelineCreationFeedback`]
/// - [`PipelineCreationFeedbackCreateInfo`]
/// - [`PipelineCreationFeedbackFlags`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkPipelineCreationFeedbackFlags")]
#[derive(Clone, Copy, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(transparent)]
pub struct PipelineCreationFeedbackFlags(u32);
impl const Default for PipelineCreationFeedbackFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl From<PipelineCreationFeedbackFlagBits> for PipelineCreationFeedbackFlags {
    fn from(from: PipelineCreationFeedbackFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(from.bits()) }
    }
}
impl PipelineCreationFeedbackFlags {
    ///[`VALID`] indicates that the
    ///feedback information is valid.
    pub const VALID: Self = Self(1);
    ///[`APPLICATION_PIPELINE_CACHE_HIT`]
    ///indicates that a readily usable pipeline or pipeline stage was found in
    ///the `pipelineCache` specified by the application in the pipeline
    ///creation command.An implementation  **should**  set the
    ///[`APPLICATION_PIPELINE_CACHE_HIT`] bit
    ///if it was able to avoid the large majority of pipeline or pipeline stage
    ///creation work by using the `pipelineCache` parameter of
    ///[`create_graphics_pipelines`],
    ///[`create_ray_tracing_pipelines_khr`],
    ///[`create_ray_tracing_pipelines_nv`],
    ///or [`create_compute_pipelines`].
    ///When an implementation sets this bit for the entire pipeline, it  **may**  leave
    ///it unset for any stage.
    pub const APPLICATION_PIPELINE_CACHE_HIT: Self = Self(2);
    ///[`BASE_PIPELINE_ACCELERATION`]
    ///indicates that the base pipeline specified by the
    ///`basePipelineHandle` or `basePipelineIndex` member of the
    ///`Vk*PipelineCreateInfo` structure was used to accelerate the
    ///creation of the pipeline.An implementation  **should**  set the
    ///[`BASE_PIPELINE_ACCELERATION`] bit if it
    ///was able to avoid a significant amount of work by using the base pipeline.
    pub const BASE_PIPELINE_ACCELERATION: Self = Self(4);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    #[allow(unused_mut)]
    pub const fn all() -> Self {
        let mut all = Self::empty();
        {
            all |= Self::VALID;
        }
        {
            all |= Self::APPLICATION_PIPELINE_CACHE_HIT;
        }
        {
            all |= Self::BASE_PIPELINE_ACCELERATION;
        }
        all
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl const std::ops::BitOr for PipelineCreationFeedbackFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl const std::ops::BitOrAssign for PipelineCreationFeedbackFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl const std::ops::BitXor for PipelineCreationFeedbackFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl const std::ops::BitXorAssign for PipelineCreationFeedbackFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl const std::ops::BitAnd for PipelineCreationFeedbackFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl const std::ops::BitAndAssign for PipelineCreationFeedbackFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl const std::ops::Sub for PipelineCreationFeedbackFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl const std::ops::SubAssign for PipelineCreationFeedbackFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl const std::ops::Not for PipelineCreationFeedbackFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl Extend<PipelineCreationFeedbackFlags> for PipelineCreationFeedbackFlags {
    fn extend<T: IntoIterator<Item = PipelineCreationFeedbackFlags>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, i);
        }
    }
}
impl Extend<PipelineCreationFeedbackFlagBits> for PipelineCreationFeedbackFlags {
    fn extend<T: IntoIterator<Item = PipelineCreationFeedbackFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, <Self as From<PipelineCreationFeedbackFlagBits>>::from(i));
        }
    }
}
impl FromIterator<PipelineCreationFeedbackFlags> for PipelineCreationFeedbackFlags {
    fn from_iter<T: IntoIterator<Item = PipelineCreationFeedbackFlags>>(iterator: T) -> PipelineCreationFeedbackFlags {
        let mut out = Self::empty();
        <Self as Extend<PipelineCreationFeedbackFlags>>::extend(&mut out, iterator);
        out
    }
}
impl FromIterator<PipelineCreationFeedbackFlagBits> for PipelineCreationFeedbackFlags {
    fn from_iter<T: IntoIterator<Item = PipelineCreationFeedbackFlagBits>>(
        iterator: T,
    ) -> PipelineCreationFeedbackFlags {
        let mut out = Self::empty();
        <Self as Extend<PipelineCreationFeedbackFlagBits>>::extend(&mut out, iterator);
        out
    }
}
impl std::fmt::Debug for PipelineCreationFeedbackFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(PipelineCreationFeedbackFlags);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == PipelineCreationFeedbackFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(PipelineCreationFeedbackFlags::VALID) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(VALID))?;
                    }
                    if self
                        .0
                        .contains(PipelineCreationFeedbackFlags::APPLICATION_PIPELINE_CACHE_HIT)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(APPLICATION_PIPELINE_CACHE_HIT))?;
                    }
                    if self
                        .0
                        .contains(PipelineCreationFeedbackFlags::BASE_PIPELINE_ACCELERATION)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(BASE_PIPELINE_ACCELERATION))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(PipelineCreationFeedbackFlags))
            .field(&Flags(*self))
            .finish()
    }
}
///[VkAccessFlagBits2](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAccessFlagBits2.html) - Access flags for VkAccessFlags2
///# C Specifications
///Bits which  **can**  be set in the `srcAccessMask` and `dstAccessMask`
///members of [`MemoryBarrier2KHR`], [`ImageMemoryBarrier2KHR`], and
///[`BufferMemoryBarrier2KHR`], specifying access behavior, are:
///```c
///// Provided by VK_VERSION_1_3
///// Flag bits for VkAccessFlagBits2
///typedef VkFlags64 VkAccessFlagBits2;
///static const VkAccessFlagBits2 VK_ACCESS_2_NONE = 0ULL;
///static const VkAccessFlagBits2 VK_ACCESS_2_NONE_KHR = 0ULL;
///static const VkAccessFlagBits2 VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT = 0x00000001ULL;
///static const VkAccessFlagBits2 VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT_KHR = 0x00000001ULL;
///static const VkAccessFlagBits2 VK_ACCESS_2_INDEX_READ_BIT = 0x00000002ULL;
///static const VkAccessFlagBits2 VK_ACCESS_2_INDEX_READ_BIT_KHR = 0x00000002ULL;
///static const VkAccessFlagBits2 VK_ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT = 0x00000004ULL;
///static const VkAccessFlagBits2 VK_ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT_KHR = 0x00000004ULL;
///static const VkAccessFlagBits2 VK_ACCESS_2_UNIFORM_READ_BIT = 0x00000008ULL;
///static const VkAccessFlagBits2 VK_ACCESS_2_UNIFORM_READ_BIT_KHR = 0x00000008ULL;
///static const VkAccessFlagBits2 VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT = 0x00000010ULL;
///static const VkAccessFlagBits2 VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT_KHR = 0x00000010ULL;
///static const VkAccessFlagBits2 VK_ACCESS_2_SHADER_READ_BIT = 0x00000020ULL;
///static const VkAccessFlagBits2 VK_ACCESS_2_SHADER_READ_BIT_KHR = 0x00000020ULL;
///static const VkAccessFlagBits2 VK_ACCESS_2_SHADER_WRITE_BIT = 0x00000040ULL;
///static const VkAccessFlagBits2 VK_ACCESS_2_SHADER_WRITE_BIT_KHR = 0x00000040ULL;
///static const VkAccessFlagBits2 VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT = 0x00000080ULL;
///static const VkAccessFlagBits2 VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT_KHR = 0x00000080ULL;
///static const VkAccessFlagBits2 VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT = 0x00000100ULL;
///static const VkAccessFlagBits2 VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT_KHR = 0x00000100ULL;
///static const VkAccessFlagBits2 VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT = 0x00000200ULL;
///static const VkAccessFlagBits2 VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT_KHR =
/// 0x00000200ULL;
///static const VkAccessFlagBits2 VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT = 0x00000400ULL;
///static const VkAccessFlagBits2 VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT_KHR =
/// 0x00000400ULL;
///static const VkAccessFlagBits2 VK_ACCESS_2_TRANSFER_READ_BIT = 0x00000800ULL;
///static const VkAccessFlagBits2 VK_ACCESS_2_TRANSFER_READ_BIT_KHR = 0x00000800ULL;
///static const VkAccessFlagBits2 VK_ACCESS_2_TRANSFER_WRITE_BIT = 0x00001000ULL;
///static const VkAccessFlagBits2 VK_ACCESS_2_TRANSFER_WRITE_BIT_KHR = 0x00001000ULL;
///static const VkAccessFlagBits2 VK_ACCESS_2_HOST_READ_BIT = 0x00002000ULL;
///static const VkAccessFlagBits2 VK_ACCESS_2_HOST_READ_BIT_KHR = 0x00002000ULL;
///static const VkAccessFlagBits2 VK_ACCESS_2_HOST_WRITE_BIT = 0x00004000ULL;
///static const VkAccessFlagBits2 VK_ACCESS_2_HOST_WRITE_BIT_KHR = 0x00004000ULL;
///static const VkAccessFlagBits2 VK_ACCESS_2_MEMORY_READ_BIT = 0x00008000ULL;
///static const VkAccessFlagBits2 VK_ACCESS_2_MEMORY_READ_BIT_KHR = 0x00008000ULL;
///static const VkAccessFlagBits2 VK_ACCESS_2_MEMORY_WRITE_BIT = 0x00010000ULL;
///static const VkAccessFlagBits2 VK_ACCESS_2_MEMORY_WRITE_BIT_KHR = 0x00010000ULL;
///static const VkAccessFlagBits2 VK_ACCESS_2_SHADER_SAMPLED_READ_BIT = 0x100000000ULL;
///static const VkAccessFlagBits2 VK_ACCESS_2_SHADER_SAMPLED_READ_BIT_KHR = 0x100000000ULL;
///static const VkAccessFlagBits2 VK_ACCESS_2_SHADER_STORAGE_READ_BIT = 0x200000000ULL;
///static const VkAccessFlagBits2 VK_ACCESS_2_SHADER_STORAGE_READ_BIT_KHR = 0x200000000ULL;
///static const VkAccessFlagBits2 VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT = 0x400000000ULL;
///static const VkAccessFlagBits2 VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT_KHR = 0x400000000ULL;
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///// Provided by VK_KHR_video_decode_queue
///static const VkAccessFlagBits2 VK_ACCESS_2_VIDEO_DECODE_READ_BIT_KHR = 0x800000000ULL;
///#endif
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///// Provided by VK_KHR_video_decode_queue
///static const VkAccessFlagBits2 VK_ACCESS_2_VIDEO_DECODE_WRITE_BIT_KHR = 0x1000000000ULL;
///#endif
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///// Provided by VK_KHR_video_encode_queue
///static const VkAccessFlagBits2 VK_ACCESS_2_VIDEO_ENCODE_READ_BIT_KHR = 0x2000000000ULL;
///#endif
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///// Provided by VK_KHR_video_encode_queue
///static const VkAccessFlagBits2 VK_ACCESS_2_VIDEO_ENCODE_WRITE_BIT_KHR = 0x4000000000ULL;
///#endif
///// Provided by VK_KHR_synchronization2 with VK_EXT_transform_feedback
///static const VkAccessFlagBits2 VK_ACCESS_2_TRANSFORM_FEEDBACK_WRITE_BIT_EXT = 0x02000000ULL;
///// Provided by VK_KHR_synchronization2 with VK_EXT_transform_feedback
///static const VkAccessFlagBits2 VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT =
/// 0x04000000ULL;
///// Provided by VK_KHR_synchronization2 with VK_EXT_transform_feedback
///static const VkAccessFlagBits2 VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT =
/// 0x08000000ULL;
///// Provided by VK_KHR_synchronization2 with VK_EXT_conditional_rendering
///static const VkAccessFlagBits2 VK_ACCESS_2_CONDITIONAL_RENDERING_READ_BIT_EXT = 0x00100000ULL;
///// Provided by VK_KHR_synchronization2 with VK_NV_device_generated_commands
///static const VkAccessFlagBits2 VK_ACCESS_2_COMMAND_PREPROCESS_READ_BIT_NV = 0x00020000ULL;
///// Provided by VK_KHR_synchronization2 with VK_NV_device_generated_commands
///static const VkAccessFlagBits2 VK_ACCESS_2_COMMAND_PREPROCESS_WRITE_BIT_NV = 0x00040000ULL;
///// Provided by VK_KHR_fragment_shading_rate with VK_KHR_synchronization2
///static const VkAccessFlagBits2 VK_ACCESS_2_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR =
/// 0x00800000ULL;
///// Provided by VK_KHR_synchronization2 with VK_NV_shading_rate_image
///static const VkAccessFlagBits2 VK_ACCESS_2_SHADING_RATE_IMAGE_READ_BIT_NV = 0x00800000ULL;
///// Provided by VK_KHR_acceleration_structure with VK_KHR_synchronization2
///static const VkAccessFlagBits2 VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_KHR = 0x00200000ULL;
///// Provided by VK_KHR_acceleration_structure with VK_KHR_synchronization2
///static const VkAccessFlagBits2 VK_ACCESS_2_ACCELERATION_STRUCTURE_WRITE_BIT_KHR = 0x00400000ULL;
///// Provided by VK_KHR_synchronization2 with VK_NV_ray_tracing
///static const VkAccessFlagBits2 VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_NV = 0x00200000ULL;
///// Provided by VK_KHR_synchronization2 with VK_NV_ray_tracing
///static const VkAccessFlagBits2 VK_ACCESS_2_ACCELERATION_STRUCTURE_WRITE_BIT_NV = 0x00400000ULL;
///// Provided by VK_KHR_synchronization2 with VK_EXT_fragment_density_map
///static const VkAccessFlagBits2 VK_ACCESS_2_FRAGMENT_DENSITY_MAP_READ_BIT_EXT = 0x01000000ULL;
///// Provided by VK_KHR_synchronization2 with VK_EXT_blend_operation_advanced
///static const VkAccessFlagBits2 VK_ACCESS_2_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT =
/// 0x00080000ULL;
///// Provided by VK_HUAWEI_invocation_mask
///static const VkAccessFlagBits2 VK_ACCESS_2_INVOCATION_MASK_READ_BIT_HUAWEI = 0x8000000000ULL;
///```
///or the equivalent
///```c
///// Provided by VK_KHR_synchronization2
///typedef VkAccessFlagBits2 VkAccessFlagBits2KHR;
///```
///# Description
/// - [`ACCESS2_NONE`] specifies no accesses.
/// - [`ACCESS2_MEMORY_READ`] specifies all read accesses. It is always valid in any access mask,
///   and is treated as equivalent to setting all `READ` access flags that are valid where it is
///   used.
/// - [`ACCESS2_MEMORY_WRITE`] specifies all write accesses. It is always valid in any access mask,
///   and is treated as equivalent to setting all `WRITE` access flags that are valid where it is
///   used.
/// - [`ACCESS2_INDIRECT_COMMAND_READ`] specifies read access to     command data read from indirect
///   buffers as part of an indirect build, trace,     drawing or dispatch command.     Such access
///   occurs in the `VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT`     pipeline stage.
/// - [`ACCESS2_INDEX_READ`] specifies read access to an index buffer as part of an indexed drawing
///   command, bound by [`cmd_bind_index_buffer`]. Such access occurs in the
///   `VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT` pipeline stage.
/// - [`ACCESS2_VERTEX_ATTRIBUTE_READ`] specifies read access to a vertex buffer as part of a
///   drawing command, bound by [`cmd_bind_vertex_buffers`]. Such access occurs in the
///   `VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT` pipeline stage.
/// - [`ACCESS2_UNIFORM_READ`] specifies read access to a [uniform buffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-uniformbuffer)
///   in any shader pipeline stage.
/// - [`ACCESS2_INPUT_ATTACHMENT_READ`] specifies read access to an [input attachment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass)
///   within a render pass during subpass shading or fragment shading. Such access occurs in the
///   `VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI` or `VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT`
///   pipeline stage.
/// - [`ACCESS2_SHADER_SAMPLED_READ`] specifies read access to a [uniform texel buffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-uniformtexelbuffer)
///   or [sampled image](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-sampledimage)
///   in any shader pipeline stage.
/// - [`ACCESS2_SHADER_STORAGE_READ`] specifies read access to a [storage buffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storagebuffer),
///   [physical storage buffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-physical-storage-buffer),
///   [storage texel buffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storagetexelbuffer),
///   or [storage image](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storageimage)
///   in any shader pipeline stage.
/// - [`ACCESS2_SHADER_READ`] specifies read access to a [shader binding table](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#shader-binding-table)
///   in any shader pipeline. In addition, it is equivalent to the logical OR of:  -
///   [`ACCESS2_UNIFORM_READ`]  - [`ACCESS2_SHADER_SAMPLED_READ`]  - [`ACCESS2_SHADER_STORAGE_READ`]
/// - [`ACCESS2_SHADER_STORAGE_WRITE`] specifies write access to a [storage buffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storagebuffer),
///   [physical storage buffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-physical-storage-buffer),
///   [storage texel buffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storagetexelbuffer),
///   or [storage image](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storageimage)
///   in any shader pipeline stage.
/// - [`ACCESS2_SHADER_WRITE`] is equivalent to [`ACCESS2_SHADER_STORAGE_WRITE`].
/// - [`ACCESS2_COLOR_ATTACHMENT_READ`] specifies read access to a [color attachment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass),
///   such as via [blending](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#framebuffer-blending),
///   [logic operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#framebuffer-logicop),
///   or via certain [subpass load operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-load-store-ops).
///   It does not include [advanced blend operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#framebuffer-blend-advanced).
///   Such access occurs in the `VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT` pipeline stage.
/// - [`ACCESS2_COLOR_ATTACHMENT_WRITE`] specifies write access to a [color, resolve, or depth/stencil resolve attachment](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#renderpass) during a [render pass](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass) or via certain [subpass load and store operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-load-store-ops). Such access occurs in the `VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT` pipeline stage.
/// - [`ACCESS2_DEPTH_STENCIL_ATTACHMENT_READ`] specifies read access to a [depth/stencil attachment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass),
///   via [depth or stencil operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fragops-ds-state)
///   or via certain [subpass load operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-load-store-ops).
///   Such access occurs in the `VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT` or
///   `VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT` pipeline stages.
/// - [`ACCESS2_DEPTH_STENCIL_ATTACHMENT_WRITE`] specifies write access to a [depth/stencil attachment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass),
///   via [depth or stencil operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fragops-ds-state)
///   or via certain [subpass load and store operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-load-store-ops).
///   Such access occurs in the `VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT` or
///   `VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT` pipeline stages.
/// - [`ACCESS2_TRANSFER_READ`] specifies read access to an image or buffer in a [copy](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#copies)
///   operation. Such access occurs in the `VK_PIPELINE_STAGE_2_COPY_BIT`,
///   `VK_PIPELINE_STAGE_2_BLIT_BIT`, or `VK_PIPELINE_STAGE_2_RESOLVE_BIT` pipeline stages.
/// - [`ACCESS2_TRANSFER_WRITE`] specifies write access to an image or buffer in a [clear](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#clears)
///   or [copy](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#copies)
///   operation. Such access occurs in the `VK_PIPELINE_STAGE_2_COPY_BIT`,
///   `VK_PIPELINE_STAGE_2_BLIT_BIT`, `VK_PIPELINE_STAGE_2_CLEAR_BIT`, or
///   `VK_PIPELINE_STAGE_2_RESOLVE_BIT` pipeline stages.
/// - [`ACCESS2_HOST_READ`] specifies read access by a host operation. Accesses of this type are not
///   performed through a resource, but directly on memory. Such access occurs in the
///   `VK_PIPELINE_STAGE_2_HOST_BIT` pipeline stage.
/// - [`ACCESS2_HOST_WRITE`] specifies write access by a host operation. Accesses of this type are
///   not performed through a resource, but directly on memory. Such access occurs in the
///   `VK_PIPELINE_STAGE_2_HOST_BIT` pipeline stage.
/// - [`ACCESS2_CONDITIONAL_RENDERING_READ_EXT`] specifies read access to a predicate as part of
///   conditional rendering. Such access occurs in the
///   `VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT` pipeline stage.
/// - [`ACCESS2_TRANSFORM_FEEDBACK_WRITE_EXT`] specifies write access to a transform feedback buffer
///   made when transform feedback is active. Such access occurs in the
///   `VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT` pipeline stage.
/// - [`ACCESS2_TRANSFORM_FEEDBACK_COUNTER_READ_EXT`] specifies read access to a transform feedback
///   counter buffer which is read when [`cmd_begin_transform_feedback_ext`] executes. Such access
///   occurs in the `VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT` pipeline stage.
/// - [`ACCESS2_TRANSFORM_FEEDBACK_COUNTER_WRITE_EXT`] specifies write access to a transform
///   feedback counter buffer which is written when [`cmd_end_transform_feedback_ext`] executes.
///   Such access occurs in the `VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT` pipeline stage.
/// - [`ACCESS2_COMMAND_PREPROCESS_READ_NV`] specifies reads from buffer inputs to
///   [`cmd_preprocess_generated_commands_nv`]. Such access occurs in the
///   `VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_NV` pipeline stage.
/// - [`ACCESS2_COMMAND_PREPROCESS_WRITE_NV`] specifies writes to the target command buffer
///   preprocess outputs. Such access occurs in the `VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_NV`
///   pipeline stage.
/// - [`ACCESS2_COLOR_ATTACHMENT_READ_NONCOHERENT_EXT`] specifies read access to [color attachments](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass),
///   including [advanced blend operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#framebuffer-blend-advanced).
///   Such access occurs in the `VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT` pipeline stage.
/// - [`ACCESS2_INVOCATION_MASK_READ_HUAWEI`] specifies read access to a invocation mask image in
///   the `VK_PIPELINE_STAGE_2_INVOCATION_MASK_BIT_HUAWEI` pipeline stage.
/// - [`ACCESS2_ACCELERATION_STRUCTURE_READ_KHR`] specifies read access to an acceleration structure
///   as part of a trace, build, or copy command, or to an [acceleration structure scratch buffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#acceleration-structure-scratch)
///   as part of a build command. Such access occurs in the
///   `VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR` pipeline stage or
///   `VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR` pipeline stage.
/// - [`ACCESS2_ACCELERATION_STRUCTURE_WRITE_KHR`] specifies write access to an acceleration structure or [acceleration structure scratch buffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#acceleration-structure-scratch) as part of a build or copy command. Such access occurs in the `VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR` pipeline stage.
/// - [`ACCESS2_FRAGMENT_DENSITY_MAP_READ_EXT`] specifies read access to a [fragment density map attachment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-fragmentdensitymapattachment)
///   during dynamic [fragment density map operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fragmentdensitymapops).
///   Such access occurs in the `VK_PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT` pipeline
///   stage.
/// - [`ACCESS2_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_KHR`] specifies read access to a fragment
///   shading rate attachment during rasterization. Such access occurs in the
///   `VK_PIPELINE_STAGE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR` pipeline stage.
/// - [`ACCESS2_SHADING_RATE_IMAGE_READ_NV`] specifies read access to a shading rate image during
///   rasterization. Such access occurs in the `VK_PIPELINE_STAGE_2_SHADING_RATE_IMAGE_BIT_NV`
///   pipeline stage. It is equivalent to [`ACCESS2_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_KHR`].
/// - [`ACCESS2_VIDEO_DECODE_READ_KHR`] specifies read access to an image or buffer resource as part
///   of a [video decode operation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-decode-operations).
///   Such access occurs in the `VK_PIPELINE_STAGE_2_VIDEO_DECODE_BIT_KHR` pipeline stage.
/// - [`ACCESS2_VIDEO_DECODE_WRITE_KHR`] specifies write access to an image or buffer resource as part of a [video decode operation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-decode-operations). Such access occurs in the `VK_PIPELINE_STAGE_2_VIDEO_DECODE_BIT_KHR` pipeline stage.
/// - [`ACCESS2_VIDEO_ENCODE_READ_KHR`] specifies read access to an image or buffer resource as part
///   of a [video encode operation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-encode-operations).
///   Such access occurs in the `VK_PIPELINE_STAGE_2_VIDEO_ENCODE_BIT_KHR` pipeline stage.
/// - [`ACCESS2_VIDEO_ENCODE_WRITE_KHR`] specifies write access to an image or buffer resource as part of a [video encode operation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-encode-operations). Such access occurs in the `VK_PIPELINE_STAGE_2_VIDEO_ENCODE_BIT_KHR` pipeline stage.
///# Related
/// - [`khr_synchronization2`]
/// - [`crate::vulkan1_3`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkAccessFlags2")]
#[derive(Clone, Copy, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(transparent)]
pub struct AccessFlags2(u64);
impl const Default for AccessFlags2 {
    fn default() -> Self {
        Self(0)
    }
}
impl From<AccessFlagBits2> for AccessFlags2 {
    fn from(from: AccessFlagBits2) -> Self {
        unsafe { Self::from_bits_unchecked(from.bits()) }
    }
}
impl AccessFlags2 {
    ///[`ACCESS2_NONE`] specifies no accesses.
    pub const ACCESS2_NONE: Self = Self(0);
    ///[`ACCESS2_INDIRECT_COMMAND_READ`] specifies read access to
    ///    command data read from indirect buffers as part of an indirect
    ///build,
    ///trace,
    ///    drawing or dispatch command.
    ///    Such access occurs in the `VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT`
    ///    pipeline stage.
    pub const ACCESS2_INDIRECT_COMMAND_READ: Self = Self(1);
    ///[`ACCESS2_INDEX_READ`] specifies read access to an index
    ///buffer as part of an indexed drawing command, bound by
    ///[`cmd_bind_index_buffer`].
    ///Such access occurs in the `VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT`
    ///pipeline stage.
    pub const ACCESS2_INDEX_READ: Self = Self(2);
    ///[`ACCESS2_VERTEX_ATTRIBUTE_READ`] specifies read access to a
    ///vertex buffer as part of a drawing command, bound by
    ///[`cmd_bind_vertex_buffers`].
    ///Such access occurs in the
    ///`VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT` pipeline stage.
    pub const ACCESS2_VERTEX_ATTRIBUTE_READ: Self = Self(4);
    ///[`ACCESS2_UNIFORM_READ`] specifies read access to a
    ///[uniform buffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-uniformbuffer) in any shader pipeline
    ///stage.
    pub const ACCESS2_UNIFORM_READ: Self = Self(8);
    ///[`ACCESS2_INPUT_ATTACHMENT_READ`] specifies read access to an
    ///[input attachment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass) within a render pass during
    ///subpass shading or
    ///fragment shading.
    ///Such access occurs in the
    ///`VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI` or
    ///`VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT` pipeline stage.
    pub const ACCESS2_INPUT_ATTACHMENT_READ: Self = Self(16);
    ///[`ACCESS2_SHADER_READ`]
    ///specifies read access to a [shader binding
    ///table](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#shader-binding-table) in any shader pipeline.
    ///In addition, it
    ///is equivalent to the logical OR of:
    /// - [`ACCESS2_UNIFORM_READ`]
    /// - [`ACCESS2_SHADER_SAMPLED_READ`]
    /// - [`ACCESS2_SHADER_STORAGE_READ`]
    pub const ACCESS2_SHADER_READ: Self = Self(32);
    ///[`ACCESS2_SHADER_WRITE`] is equivalent to
    ///[`ACCESS2_SHADER_STORAGE_WRITE`].
    pub const ACCESS2_SHADER_WRITE: Self = Self(64);
    ///[`ACCESS2_COLOR_ATTACHMENT_READ`] specifies read access to a
    ///[color attachment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass), such as via [blending](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#framebuffer-blending), [logic operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#framebuffer-logicop), or via certain
    ///[subpass load operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-load-store-ops).
    ///It does not include [advanced blend
    ///operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#framebuffer-blend-advanced).
    ///Such access occurs in the
    ///`VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT` pipeline stage.
    pub const ACCESS2_COLOR_ATTACHMENT_READ: Self = Self(128);
    ///[`ACCESS2_COLOR_ATTACHMENT_WRITE`] specifies write access to a
    ///[color, resolve, or depth/stencil resolve attachment](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#renderpass)
    ///during a [render pass](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass) or via certain
    ///[subpass load and store operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-load-store-ops).
    ///Such access occurs in the
    ///`VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT` pipeline stage.
    pub const ACCESS2_COLOR_ATTACHMENT_WRITE: Self = Self(256);
    ///[`ACCESS2_DEPTH_STENCIL_ATTACHMENT_READ`] specifies read
    ///access to a [depth/stencil attachment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass), via
    ///[depth or stencil operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fragops-ds-state) or via certain
    ///[subpass load operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-load-store-ops).
    ///Such access occurs in the
    ///`VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT` or
    ///`VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT` pipeline stages.
    pub const ACCESS2_DEPTH_STENCIL_ATTACHMENT_READ: Self = Self(512);
    ///[`ACCESS2_DEPTH_STENCIL_ATTACHMENT_WRITE`] specifies write
    ///access to a [depth/stencil attachment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass), via
    ///[depth or stencil operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fragops-ds-state) or via certain
    ///[subpass load and store operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-load-store-ops).
    ///Such access occurs in the
    ///`VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT` or
    ///`VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT` pipeline stages.
    pub const ACCESS2_DEPTH_STENCIL_ATTACHMENT_WRITE: Self = Self(1024);
    ///[`ACCESS2_TRANSFER_READ`] specifies read access to an image or
    ///buffer in a [copy](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#copies) operation.
    ///Such access occurs in the `VK_PIPELINE_STAGE_2_COPY_BIT`,
    ///`VK_PIPELINE_STAGE_2_BLIT_BIT`, or
    ///`VK_PIPELINE_STAGE_2_RESOLVE_BIT` pipeline stages.
    pub const ACCESS2_TRANSFER_READ: Self = Self(2048);
    ///[`ACCESS2_TRANSFER_WRITE`] specifies write access to an image
    ///or buffer in a [clear](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#clears) or [copy](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#copies) operation.
    ///Such access occurs in the `VK_PIPELINE_STAGE_2_COPY_BIT`,
    ///`VK_PIPELINE_STAGE_2_BLIT_BIT`, `VK_PIPELINE_STAGE_2_CLEAR_BIT`,
    ///or `VK_PIPELINE_STAGE_2_RESOLVE_BIT` pipeline stages.
    pub const ACCESS2_TRANSFER_WRITE: Self = Self(4096);
    ///[`ACCESS2_HOST_READ`] specifies read access by a host
    ///operation.
    ///Accesses of this type are not performed through a resource, but directly
    ///on memory.
    ///Such access occurs in the `VK_PIPELINE_STAGE_2_HOST_BIT` pipeline
    ///stage.
    pub const ACCESS2_HOST_READ: Self = Self(8192);
    ///[`ACCESS2_HOST_WRITE`] specifies write access by a host
    ///operation.
    ///Accesses of this type are not performed through a resource, but directly
    ///on memory.
    ///Such access occurs in the `VK_PIPELINE_STAGE_2_HOST_BIT` pipeline
    ///stage.
    pub const ACCESS2_HOST_WRITE: Self = Self(16384);
    ///[`ACCESS2_MEMORY_READ`] specifies all read accesses.
    ///It is always valid in any access mask, and is treated as equivalent to
    ///setting all `READ` access flags that are valid where it is used.
    pub const ACCESS2_MEMORY_READ: Self = Self(32768);
    ///[`ACCESS2_MEMORY_WRITE`] specifies all write accesses.
    ///It is always valid in any access mask, and is treated as equivalent to
    ///setting all `WRITE` access flags that are valid where it is used.
    pub const ACCESS2_MEMORY_WRITE: Self = Self(65536);
    ///[`ACCESS2_SHADER_SAMPLED_READ`] specifies read access to a
    ///[uniform texel buffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-uniformtexelbuffer) or
    ///[sampled image](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-sampledimage) in any shader pipeline
    ///stage.
    pub const ACCESS2_SHADER_SAMPLED_READ: Self = Self(4294967296);
    ///[`ACCESS2_SHADER_STORAGE_READ`] specifies read access to a
    ///[storage buffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storagebuffer),
    ///[physical storage buffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-physical-storage-buffer),
    ///[storage texel buffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storagetexelbuffer), or
    ///[storage image](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storageimage) in any shader pipeline
    ///stage.
    pub const ACCESS2_SHADER_STORAGE_READ: Self = Self(8589934592);
    ///[`ACCESS2_SHADER_STORAGE_WRITE`] specifies write access to a
    ///[storage buffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storagebuffer),
    ///[physical storage buffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-physical-storage-buffer),
    ///[storage texel buffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storagetexelbuffer), or
    ///[storage image](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storageimage) in any shader pipeline
    ///stage.
    pub const ACCESS2_SHADER_STORAGE_WRITE: Self = Self(17179869184);
    ///[`ACCESS2_VIDEO_DECODE_READ_KHR`] specifies read access to an
    ///image or buffer resource as part of a [video
    ///decode operation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-decode-operations).
    ///Such access occurs in the `VK_PIPELINE_STAGE_2_VIDEO_DECODE_BIT_KHR`
    ///pipeline stage.
    ///
    ///Provided by [`crate::extensions::khr_video_decode_queue`]
    #[cfg(feature = "VK_KHR_video_decode_queue")]
    pub const ACCESS2_VIDEO_DECODE_READ_KHR: Self = Self(34359738368);
    ///[`ACCESS2_VIDEO_DECODE_WRITE_KHR`] specifies write access to
    ///an image or buffer resource as part of a [video decode operation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-decode-operations).
    ///Such access occurs in the `VK_PIPELINE_STAGE_2_VIDEO_DECODE_BIT_KHR`
    ///pipeline stage.
    ///
    ///Provided by [`crate::extensions::khr_video_decode_queue`]
    #[cfg(feature = "VK_KHR_video_decode_queue")]
    pub const ACCESS2_VIDEO_DECODE_WRITE_KHR: Self = Self(68719476736);
    ///[`ACCESS2_VIDEO_ENCODE_READ_KHR`] specifies read access to an
    ///image or buffer resource as part of a [video
    ///encode operation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-encode-operations).
    ///Such access occurs in the `VK_PIPELINE_STAGE_2_VIDEO_ENCODE_BIT_KHR`
    ///pipeline stage.
    ///
    ///Provided by [`crate::extensions::khr_video_encode_queue`]
    #[cfg(feature = "VK_KHR_video_encode_queue")]
    pub const ACCESS2_VIDEO_ENCODE_READ_KHR: Self = Self(137438953472);
    ///[`ACCESS2_VIDEO_ENCODE_WRITE_KHR`] specifies write access to
    ///an image or buffer resource as part of a [video encode operation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-encode-operations).
    ///Such access occurs in the `VK_PIPELINE_STAGE_2_VIDEO_ENCODE_BIT_KHR`
    ///pipeline stage.
    ///
    ///Provided by [`crate::extensions::khr_video_encode_queue`]
    #[cfg(feature = "VK_KHR_video_encode_queue")]
    pub const ACCESS2_VIDEO_ENCODE_WRITE_KHR: Self = Self(274877906944);
    ///[`ACCESS2_TRANSFORM_FEEDBACK_WRITE_EXT`] specifies write
    ///access to a transform feedback buffer made when transform feedback is
    ///active.
    ///Such access occurs in the
    ///`VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT` pipeline stage.
    ///
    ///Provided by [`crate::extensions::khr_synchronization2`]
    #[cfg(feature = "VK_KHR_synchronization2")]
    pub const ACCESS2_TRANSFORM_FEEDBACK_WRITE_EXT: Self = Self(33554432);
    ///[`ACCESS2_TRANSFORM_FEEDBACK_COUNTER_READ_EXT`] specifies read
    ///access to a transform feedback counter buffer which is read when
    ///[`cmd_begin_transform_feedback_ext`] executes.
    ///Such access occurs in the
    ///`VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT` pipeline stage.
    ///
    ///Provided by [`crate::extensions::khr_synchronization2`]
    #[cfg(feature = "VK_KHR_synchronization2")]
    pub const ACCESS2_TRANSFORM_FEEDBACK_COUNTER_READ_EXT: Self = Self(67108864);
    ///[`ACCESS2_TRANSFORM_FEEDBACK_COUNTER_WRITE_EXT`] specifies
    ///write access to a transform feedback counter buffer which is written
    ///when [`cmd_end_transform_feedback_ext`] executes.
    ///Such access occurs in the
    ///`VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT` pipeline stage.
    ///
    ///Provided by [`crate::extensions::khr_synchronization2`]
    #[cfg(feature = "VK_KHR_synchronization2")]
    pub const ACCESS2_TRANSFORM_FEEDBACK_COUNTER_WRITE_EXT: Self = Self(134217728);
    ///[`ACCESS2_CONDITIONAL_RENDERING_READ_EXT`] specifies read
    ///access to a predicate as part of conditional rendering.
    ///Such access occurs in the
    ///`VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT` pipeline stage.
    ///
    ///Provided by [`crate::extensions::khr_synchronization2`]
    #[cfg(feature = "VK_KHR_synchronization2")]
    pub const ACCESS2_CONDITIONAL_RENDERING_READ_EXT: Self = Self(1048576);
    ///[`ACCESS2_COMMAND_PREPROCESS_READ_NV`] specifies reads from
    ///buffer inputs to [`cmd_preprocess_generated_commands_nv`].
    ///Such access occurs in the
    ///`VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_NV` pipeline stage.
    ///
    ///Provided by [`crate::extensions::khr_synchronization2`]
    #[cfg(feature = "VK_KHR_synchronization2")]
    pub const ACCESS2_COMMAND_PREPROCESS_READ_NV: Self = Self(131072);
    ///[`ACCESS2_COMMAND_PREPROCESS_WRITE_NV`] specifies writes to
    ///the target command buffer preprocess outputs.
    ///Such access occurs in the
    ///`VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_NV` pipeline stage.
    ///
    ///Provided by [`crate::extensions::khr_synchronization2`]
    #[cfg(feature = "VK_KHR_synchronization2")]
    pub const ACCESS2_COMMAND_PREPROCESS_WRITE_NV: Self = Self(262144);
    ///[`ACCESS2_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_KHR`]
    ///specifies read access to a fragment shading rate attachment during
    ///rasterization.
    ///Such access occurs in the
    ///`VK_PIPELINE_STAGE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR`
    ///pipeline stage.
    ///
    ///Provided by [`crate::extensions::khr_synchronization2`]
    #[cfg(feature = "VK_KHR_synchronization2")]
    pub const ACCESS2_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_KHR: Self = Self(8388608);
    ///[`ACCESS2_ACCELERATION_STRUCTURE_READ_KHR`] specifies read
    ///access to an acceleration structure as part of a trace, build, or copy
    ///command, or to an [acceleration
    ///structure scratch buffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#acceleration-structure-scratch) as part of a build command.
    ///Such access occurs in the
    ///`VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR` pipeline stage or
    ///`VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR` pipeline
    ///stage.
    ///
    ///Provided by [`crate::extensions::khr_synchronization2`]
    #[cfg(feature = "VK_KHR_synchronization2")]
    pub const ACCESS2_ACCELERATION_STRUCTURE_READ_KHR: Self = Self(2097152);
    ///[`ACCESS2_ACCELERATION_STRUCTURE_WRITE_KHR`] specifies write
    ///access to an acceleration structure or [acceleration structure scratch buffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#acceleration-structure-scratch) as part of a build or copy
    ///command.
    ///Such access occurs in the
    ///`VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR` pipeline
    ///stage.
    ///
    ///Provided by [`crate::extensions::khr_synchronization2`]
    #[cfg(feature = "VK_KHR_synchronization2")]
    pub const ACCESS2_ACCELERATION_STRUCTURE_WRITE_KHR: Self = Self(4194304);
    ///[`ACCESS2_FRAGMENT_DENSITY_MAP_READ_EXT`] specifies read
    ///access to a [fragment density
    ///map attachment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-fragmentdensitymapattachment) during dynamic [fragment
    ///density map operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fragmentdensitymapops).
    ///Such access occurs in the
    ///`VK_PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT` pipeline
    ///stage.
    ///
    ///Provided by [`crate::extensions::khr_synchronization2`]
    #[cfg(feature = "VK_KHR_synchronization2")]
    pub const ACCESS2_FRAGMENT_DENSITY_MAP_READ_EXT: Self = Self(16777216);
    ///[`ACCESS2_COLOR_ATTACHMENT_READ_NONCOHERENT_EXT`] specifies
    ///read access to [color attachments](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass), including
    ///[advanced blend operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#framebuffer-blend-advanced).
    ///Such access occurs in the
    ///`VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT` pipeline stage.
    ///
    ///Provided by [`crate::extensions::khr_synchronization2`]
    #[cfg(feature = "VK_KHR_synchronization2")]
    pub const ACCESS2_COLOR_ATTACHMENT_READ_NONCOHERENT_EXT: Self = Self(524288);
    ///[`ACCESS2_INVOCATION_MASK_READ_HUAWEI`] specifies read access
    ///to a invocation mask image in the
    ///`VK_PIPELINE_STAGE_2_INVOCATION_MASK_BIT_HUAWEI` pipeline stage.
    ///
    ///Provided by [`crate::extensions::huawei_invocation_mask`]
    #[cfg(feature = "VK_HUAWEI_invocation_mask")]
    pub const ACCESS2_INVOCATION_MASK_READ_HUAWEI: Self = Self(549755813888);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    #[allow(unused_mut)]
    pub const fn all() -> Self {
        let mut all = Self::empty();
        {
            all |= Self::ACCESS2_NONE;
        }
        {
            all |= Self::ACCESS2_INDIRECT_COMMAND_READ;
        }
        {
            all |= Self::ACCESS2_INDEX_READ;
        }
        {
            all |= Self::ACCESS2_VERTEX_ATTRIBUTE_READ;
        }
        {
            all |= Self::ACCESS2_UNIFORM_READ;
        }
        {
            all |= Self::ACCESS2_INPUT_ATTACHMENT_READ;
        }
        {
            all |= Self::ACCESS2_SHADER_READ;
        }
        {
            all |= Self::ACCESS2_SHADER_WRITE;
        }
        {
            all |= Self::ACCESS2_COLOR_ATTACHMENT_READ;
        }
        {
            all |= Self::ACCESS2_COLOR_ATTACHMENT_WRITE;
        }
        {
            all |= Self::ACCESS2_DEPTH_STENCIL_ATTACHMENT_READ;
        }
        {
            all |= Self::ACCESS2_DEPTH_STENCIL_ATTACHMENT_WRITE;
        }
        {
            all |= Self::ACCESS2_TRANSFER_READ;
        }
        {
            all |= Self::ACCESS2_TRANSFER_WRITE;
        }
        {
            all |= Self::ACCESS2_HOST_READ;
        }
        {
            all |= Self::ACCESS2_HOST_WRITE;
        }
        {
            all |= Self::ACCESS2_MEMORY_READ;
        }
        {
            all |= Self::ACCESS2_MEMORY_WRITE;
        }
        {
            all |= Self::ACCESS2_SHADER_SAMPLED_READ;
        }
        {
            all |= Self::ACCESS2_SHADER_STORAGE_READ;
        }
        {
            all |= Self::ACCESS2_SHADER_STORAGE_WRITE;
        }
        #[cfg(feature = "VK_KHR_video_decode_queue")]
        {
            all |= Self::ACCESS2_VIDEO_DECODE_READ_KHR;
        }
        #[cfg(feature = "VK_KHR_video_decode_queue")]
        {
            all |= Self::ACCESS2_VIDEO_DECODE_WRITE_KHR;
        }
        #[cfg(feature = "VK_KHR_video_encode_queue")]
        {
            all |= Self::ACCESS2_VIDEO_ENCODE_READ_KHR;
        }
        #[cfg(feature = "VK_KHR_video_encode_queue")]
        {
            all |= Self::ACCESS2_VIDEO_ENCODE_WRITE_KHR;
        }
        #[cfg(feature = "VK_KHR_synchronization2")]
        {
            all |= Self::ACCESS2_TRANSFORM_FEEDBACK_WRITE_EXT;
        }
        #[cfg(feature = "VK_KHR_synchronization2")]
        {
            all |= Self::ACCESS2_TRANSFORM_FEEDBACK_COUNTER_READ_EXT;
        }
        #[cfg(feature = "VK_KHR_synchronization2")]
        {
            all |= Self::ACCESS2_TRANSFORM_FEEDBACK_COUNTER_WRITE_EXT;
        }
        #[cfg(feature = "VK_KHR_synchronization2")]
        {
            all |= Self::ACCESS2_CONDITIONAL_RENDERING_READ_EXT;
        }
        #[cfg(feature = "VK_KHR_synchronization2")]
        {
            all |= Self::ACCESS2_COMMAND_PREPROCESS_READ_NV;
        }
        #[cfg(feature = "VK_KHR_synchronization2")]
        {
            all |= Self::ACCESS2_COMMAND_PREPROCESS_WRITE_NV;
        }
        #[cfg(feature = "VK_KHR_synchronization2")]
        {
            all |= Self::ACCESS2_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_KHR;
        }
        #[cfg(feature = "VK_KHR_synchronization2")]
        {
            all |= Self::ACCESS2_ACCELERATION_STRUCTURE_READ_KHR;
        }
        #[cfg(feature = "VK_KHR_synchronization2")]
        {
            all |= Self::ACCESS2_ACCELERATION_STRUCTURE_WRITE_KHR;
        }
        #[cfg(feature = "VK_KHR_synchronization2")]
        {
            all |= Self::ACCESS2_FRAGMENT_DENSITY_MAP_READ_EXT;
        }
        #[cfg(feature = "VK_KHR_synchronization2")]
        {
            all |= Self::ACCESS2_COLOR_ATTACHMENT_READ_NONCOHERENT_EXT;
        }
        #[cfg(feature = "VK_HUAWEI_invocation_mask")]
        {
            all |= Self::ACCESS2_INVOCATION_MASK_READ_HUAWEI;
        }
        all
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u64 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u64) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u64) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u64) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl const std::ops::BitOr for AccessFlags2 {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl const std::ops::BitOrAssign for AccessFlags2 {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl const std::ops::BitXor for AccessFlags2 {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl const std::ops::BitXorAssign for AccessFlags2 {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl const std::ops::BitAnd for AccessFlags2 {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl const std::ops::BitAndAssign for AccessFlags2 {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl const std::ops::Sub for AccessFlags2 {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl const std::ops::SubAssign for AccessFlags2 {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl const std::ops::Not for AccessFlags2 {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl Extend<AccessFlags2> for AccessFlags2 {
    fn extend<T: IntoIterator<Item = AccessFlags2>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, i);
        }
    }
}
impl Extend<AccessFlagBits2> for AccessFlags2 {
    fn extend<T: IntoIterator<Item = AccessFlagBits2>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, <Self as From<AccessFlagBits2>>::from(i));
        }
    }
}
impl FromIterator<AccessFlags2> for AccessFlags2 {
    fn from_iter<T: IntoIterator<Item = AccessFlags2>>(iterator: T) -> AccessFlags2 {
        let mut out = Self::empty();
        <Self as Extend<AccessFlags2>>::extend(&mut out, iterator);
        out
    }
}
impl FromIterator<AccessFlagBits2> for AccessFlags2 {
    fn from_iter<T: IntoIterator<Item = AccessFlagBits2>>(iterator: T) -> AccessFlags2 {
        let mut out = Self::empty();
        <Self as Extend<AccessFlagBits2>>::extend(&mut out, iterator);
        out
    }
}
impl std::fmt::Debug for AccessFlags2 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(AccessFlags2);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == AccessFlags2::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(AccessFlags2::ACCESS2_NONE) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(ACCESS2_NONE))?;
                    }
                    if self.0.contains(AccessFlags2::ACCESS2_INDIRECT_COMMAND_READ) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(ACCESS2_INDIRECT_COMMAND_READ))?;
                    }
                    if self.0.contains(AccessFlags2::ACCESS2_INDEX_READ) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(ACCESS2_INDEX_READ))?;
                    }
                    if self.0.contains(AccessFlags2::ACCESS2_VERTEX_ATTRIBUTE_READ) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(ACCESS2_VERTEX_ATTRIBUTE_READ))?;
                    }
                    if self.0.contains(AccessFlags2::ACCESS2_UNIFORM_READ) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(ACCESS2_UNIFORM_READ))?;
                    }
                    if self.0.contains(AccessFlags2::ACCESS2_INPUT_ATTACHMENT_READ) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(ACCESS2_INPUT_ATTACHMENT_READ))?;
                    }
                    if self.0.contains(AccessFlags2::ACCESS2_SHADER_READ) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(ACCESS2_SHADER_READ))?;
                    }
                    if self.0.contains(AccessFlags2::ACCESS2_SHADER_WRITE) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(ACCESS2_SHADER_WRITE))?;
                    }
                    if self.0.contains(AccessFlags2::ACCESS2_COLOR_ATTACHMENT_READ) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(ACCESS2_COLOR_ATTACHMENT_READ))?;
                    }
                    if self.0.contains(AccessFlags2::ACCESS2_COLOR_ATTACHMENT_WRITE) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(ACCESS2_COLOR_ATTACHMENT_WRITE))?;
                    }
                    if self.0.contains(AccessFlags2::ACCESS2_DEPTH_STENCIL_ATTACHMENT_READ) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(ACCESS2_DEPTH_STENCIL_ATTACHMENT_READ))?;
                    }
                    if self.0.contains(AccessFlags2::ACCESS2_DEPTH_STENCIL_ATTACHMENT_WRITE) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(ACCESS2_DEPTH_STENCIL_ATTACHMENT_WRITE))?;
                    }
                    if self.0.contains(AccessFlags2::ACCESS2_TRANSFER_READ) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(ACCESS2_TRANSFER_READ))?;
                    }
                    if self.0.contains(AccessFlags2::ACCESS2_TRANSFER_WRITE) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(ACCESS2_TRANSFER_WRITE))?;
                    }
                    if self.0.contains(AccessFlags2::ACCESS2_HOST_READ) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(ACCESS2_HOST_READ))?;
                    }
                    if self.0.contains(AccessFlags2::ACCESS2_HOST_WRITE) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(ACCESS2_HOST_WRITE))?;
                    }
                    if self.0.contains(AccessFlags2::ACCESS2_MEMORY_READ) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(ACCESS2_MEMORY_READ))?;
                    }
                    if self.0.contains(AccessFlags2::ACCESS2_MEMORY_WRITE) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(ACCESS2_MEMORY_WRITE))?;
                    }
                    if self.0.contains(AccessFlags2::ACCESS2_SHADER_SAMPLED_READ) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(ACCESS2_SHADER_SAMPLED_READ))?;
                    }
                    if self.0.contains(AccessFlags2::ACCESS2_SHADER_STORAGE_READ) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(ACCESS2_SHADER_STORAGE_READ))?;
                    }
                    if self.0.contains(AccessFlags2::ACCESS2_SHADER_STORAGE_WRITE) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(ACCESS2_SHADER_STORAGE_WRITE))?;
                    }
                    #[cfg(feature = "VK_KHR_video_decode_queue")]
                    if self.0.contains(AccessFlags2::ACCESS2_VIDEO_DECODE_READ_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(ACCESS2_VIDEO_DECODE_READ_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_video_decode_queue")]
                    if self.0.contains(AccessFlags2::ACCESS2_VIDEO_DECODE_WRITE_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(ACCESS2_VIDEO_DECODE_WRITE_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_video_encode_queue")]
                    if self.0.contains(AccessFlags2::ACCESS2_VIDEO_ENCODE_READ_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(ACCESS2_VIDEO_ENCODE_READ_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_video_encode_queue")]
                    if self.0.contains(AccessFlags2::ACCESS2_VIDEO_ENCODE_WRITE_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(ACCESS2_VIDEO_ENCODE_WRITE_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_synchronization2")]
                    if self.0.contains(AccessFlags2::ACCESS2_TRANSFORM_FEEDBACK_WRITE_EXT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(ACCESS2_TRANSFORM_FEEDBACK_WRITE_EXT))?;
                    }
                    #[cfg(feature = "VK_KHR_synchronization2")]
                    if self
                        .0
                        .contains(AccessFlags2::ACCESS2_TRANSFORM_FEEDBACK_COUNTER_READ_EXT)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(ACCESS2_TRANSFORM_FEEDBACK_COUNTER_READ_EXT))?;
                    }
                    #[cfg(feature = "VK_KHR_synchronization2")]
                    if self
                        .0
                        .contains(AccessFlags2::ACCESS2_TRANSFORM_FEEDBACK_COUNTER_WRITE_EXT)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(ACCESS2_TRANSFORM_FEEDBACK_COUNTER_WRITE_EXT))?;
                    }
                    #[cfg(feature = "VK_KHR_synchronization2")]
                    if self.0.contains(AccessFlags2::ACCESS2_CONDITIONAL_RENDERING_READ_EXT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(ACCESS2_CONDITIONAL_RENDERING_READ_EXT))?;
                    }
                    #[cfg(feature = "VK_KHR_synchronization2")]
                    if self.0.contains(AccessFlags2::ACCESS2_COMMAND_PREPROCESS_READ_NV) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(ACCESS2_COMMAND_PREPROCESS_READ_NV))?;
                    }
                    #[cfg(feature = "VK_KHR_synchronization2")]
                    if self.0.contains(AccessFlags2::ACCESS2_COMMAND_PREPROCESS_WRITE_NV) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(ACCESS2_COMMAND_PREPROCESS_WRITE_NV))?;
                    }
                    #[cfg(feature = "VK_KHR_synchronization2")]
                    if self
                        .0
                        .contains(AccessFlags2::ACCESS2_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_KHR)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(ACCESS2_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_synchronization2")]
                    if self.0.contains(AccessFlags2::ACCESS2_ACCELERATION_STRUCTURE_READ_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(ACCESS2_ACCELERATION_STRUCTURE_READ_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_synchronization2")]
                    if self.0.contains(AccessFlags2::ACCESS2_ACCELERATION_STRUCTURE_WRITE_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(ACCESS2_ACCELERATION_STRUCTURE_WRITE_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_synchronization2")]
                    if self.0.contains(AccessFlags2::ACCESS2_FRAGMENT_DENSITY_MAP_READ_EXT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(ACCESS2_FRAGMENT_DENSITY_MAP_READ_EXT))?;
                    }
                    #[cfg(feature = "VK_KHR_synchronization2")]
                    if self
                        .0
                        .contains(AccessFlags2::ACCESS2_COLOR_ATTACHMENT_READ_NONCOHERENT_EXT)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(ACCESS2_COLOR_ATTACHMENT_READ_NONCOHERENT_EXT))?;
                    }
                    #[cfg(feature = "VK_HUAWEI_invocation_mask")]
                    if self.0.contains(AccessFlags2::ACCESS2_INVOCATION_MASK_READ_HUAWEI) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(ACCESS2_INVOCATION_MASK_READ_HUAWEI))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(AccessFlags2)).field(&Flags(*self)).finish()
    }
}
///[VkPipelineStageFlagBits2](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineStageFlagBits2.html) - Pipeline stage flags for VkPipelineStageFlags2
///# C Specifications
///Bits which  **can**  be set in a [`PipelineStageFlags2`] mask, specifying
///stages of execution, are:
///```c
///// Provided by VK_VERSION_1_3
///// Flag bits for VkPipelineStageFlagBits2
///typedef VkFlags64 VkPipelineStageFlagBits2;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_NONE = 0ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_NONE_KHR = 0ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_TOP_OF_PIPE_BIT = 0x00000001ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_TOP_OF_PIPE_BIT_KHR = 0x00000001ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT = 0x00000002ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT_KHR = 0x00000002ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT = 0x00000004ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT_KHR = 0x00000004ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT = 0x00000008ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT_KHR = 0x00000008ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT =
/// 0x00000010ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT_KHR =
/// 0x00000010ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT =
/// 0x00000020ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT_KHR
/// = 0x00000020ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT = 0x00000040ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT_KHR =
/// 0x00000040ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT = 0x00000080ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT_KHR =
/// 0x00000080ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT =
/// 0x00000100ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT_KHR =
/// 0x00000100ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT =
/// 0x00000200ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT_KHR =
/// 0x00000200ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT =
/// 0x00000400ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT_KHR =
/// 0x00000400ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT = 0x00000800ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT_KHR =
/// 0x00000800ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT = 0x00001000ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT_KHR = 0x00001000ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_TRANSFER_BIT = 0x00001000ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_TRANSFER_BIT_KHR = 0x00001000ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_BOTTOM_OF_PIPE_BIT = 0x00002000ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_BOTTOM_OF_PIPE_BIT_KHR =
/// 0x00002000ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_HOST_BIT = 0x00004000ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_HOST_BIT_KHR = 0x00004000ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT = 0x00008000ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT_KHR = 0x00008000ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT = 0x00010000ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT_KHR = 0x00010000ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_COPY_BIT = 0x100000000ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_COPY_BIT_KHR = 0x100000000ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_RESOLVE_BIT = 0x200000000ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_RESOLVE_BIT_KHR = 0x200000000ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_BLIT_BIT = 0x400000000ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_BLIT_BIT_KHR = 0x400000000ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_CLEAR_BIT = 0x800000000ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_CLEAR_BIT_KHR = 0x800000000ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT = 0x1000000000ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT_KHR = 0x1000000000ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT =
/// 0x2000000000ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT_KHR =
/// 0x2000000000ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_PRE_RASTERIZATION_SHADERS_BIT =
/// 0x4000000000ULL;
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_PRE_RASTERIZATION_SHADERS_BIT_KHR =
/// 0x4000000000ULL;
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///// Provided by VK_KHR_video_decode_queue
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_VIDEO_DECODE_BIT_KHR = 0x04000000ULL;
///#endif
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///// Provided by VK_KHR_video_encode_queue
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_VIDEO_ENCODE_BIT_KHR = 0x08000000ULL;
///#endif
///// Provided by VK_KHR_synchronization2 with VK_EXT_transform_feedback
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT =
/// 0x01000000ULL;
///// Provided by VK_KHR_synchronization2 with VK_EXT_conditional_rendering
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT =
/// 0x00040000ULL;
///// Provided by VK_KHR_synchronization2 with VK_NV_device_generated_commands
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_NV =
/// 0x00020000ULL;
///// Provided by VK_KHR_fragment_shading_rate with VK_KHR_synchronization2
///static const VkPipelineStageFlagBits2
/// VK_PIPELINE_STAGE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = 0x00400000ULL;
///// Provided by VK_KHR_synchronization2 with VK_NV_shading_rate_image
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_SHADING_RATE_IMAGE_BIT_NV =
/// 0x00400000ULL;
///// Provided by VK_KHR_acceleration_structure with VK_KHR_synchronization2
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR =
/// 0x02000000ULL;
///// Provided by VK_KHR_ray_tracing_pipeline with VK_KHR_synchronization2
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR =
/// 0x00200000ULL;
///// Provided by VK_KHR_synchronization2 with VK_NV_ray_tracing
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_NV =
/// 0x00200000ULL;
///// Provided by VK_KHR_synchronization2 with VK_NV_ray_tracing
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_NV =
/// 0x02000000ULL;
///// Provided by VK_KHR_synchronization2 with VK_EXT_fragment_density_map
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT =
/// 0x00800000ULL;
///// Provided by VK_KHR_synchronization2 with VK_NV_mesh_shader
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_NV = 0x00080000ULL;
///// Provided by VK_KHR_synchronization2 with VK_NV_mesh_shader
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_NV = 0x00100000ULL;
///// Provided by VK_HUAWEI_subpass_shading
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI =
/// 0x8000000000ULL;
///// Provided by VK_HUAWEI_invocation_mask
///static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_INVOCATION_MASK_BIT_HUAWEI =
/// 0x10000000000ULL;
///```
///or the equivalent
///```c
///// Provided by VK_KHR_synchronization2
///typedef VkPipelineStageFlagBits2 VkPipelineStageFlagBits2KHR;
///```
///# Description
/// - [`PIPELINE_STAGE2_NONE`] specifies no stages of execution.
/// - [`PIPELINE_STAGE2_DRAW_INDIRECT`] specifies the stage of the pipeline where indirect command
///   parameters are consumed. This stage also includes reading commands written by
///   [`cmd_preprocess_generated_commands_nv`].
/// - [`PIPELINE_STAGE2_TASK_SHADER_NV`] specifies the task shader stage.
/// - [`PIPELINE_STAGE2_MESH_SHADER_NV`] specifies the mesh shader stage.
/// - [`PIPELINE_STAGE2_INDEX_INPUT`] specifies the stage of the pipeline where index buffers are
///   consumed.
/// - [`PIPELINE_STAGE2_VERTEX_ATTRIBUTE_INPUT`] specifies the stage of the pipeline where vertex
///   buffers are consumed.
/// - [`PIPELINE_STAGE2_VERTEX_INPUT`] is equivalent to the logical OR of:  -
///   [`PIPELINE_STAGE2_INDEX_INPUT`]  - [`PIPELINE_STAGE2_VERTEX_ATTRIBUTE_INPUT`]
/// - [`PIPELINE_STAGE2_VERTEX_SHADER`] specifies the vertex shader stage.
/// - [`PIPELINE_STAGE2_TESSELLATION_CONTROL_SHADER`] specifies the tessellation control shader
///   stage.
/// - [`PIPELINE_STAGE2_TESSELLATION_EVALUATION_SHADER`] specifies the tessellation evaluation
///   shader stage.
/// - [`PIPELINE_STAGE2_GEOMETRY_SHADER`] specifies the geometry shader stage.
/// - [`PIPELINE_STAGE2_PRE_RASTERIZATION_SHADERS`] is equivalent to specifying all supported [pre-rasterization shader stages](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-pre-rasterization):  - [`PIPELINE_STAGE2_VERTEX_SHADER`]  - [`PIPELINE_STAGE2_TESSELLATION_CONTROL_SHADER`]  - [`PIPELINE_STAGE2_TESSELLATION_EVALUATION_SHADER`]  - [`PIPELINE_STAGE2_GEOMETRY_SHADER`]  - [`PIPELINE_STAGE2_TASK_SHADER_NV`]  - [`PIPELINE_STAGE2_MESH_SHADER_NV`]
/// - [`PIPELINE_STAGE2_FRAGMENT_SHADER`] specifies the fragment shader stage.
/// - [`PIPELINE_STAGE2_EARLY_FRAGMENT_TESTS`] specifies the stage of the pipeline where early fragment tests (depth and stencil tests before fragment shading) are performed. This stage also includes [subpass load operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-load-store-ops) for framebuffer attachments with a depth/stencil format.
/// - [`PIPELINE_STAGE2_LATE_FRAGMENT_TESTS`] specifies the stage of the pipeline where late fragment tests (depth and stencil tests after fragment shading) are performed. This stage also includes [subpass store operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-load-store-ops) for framebuffer attachments with a depth/stencil format.
/// - [`PIPELINE_STAGE2_COLOR_ATTACHMENT_OUTPUT`] specifies the stage of the pipeline after blending
///   where the final color values are output from the pipeline. This stage also includes [subpass load
///   and store operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-load-store-ops)
///   and multisample resolve operations for framebuffer attachments with a color or depth/stencil
///   format.
/// - [`PIPELINE_STAGE2_COMPUTE_SHADER`] specifies the compute shader stage.
/// - [`PIPELINE_STAGE2_HOST`] specifies a pseudo-stage indicating execution on the host of
///   reads/writes of device memory. This stage is not invoked by any commands recorded in a command
///   buffer.
/// - [`PIPELINE_STAGE2_COPY`] specifies the execution of all [copy commands](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#copies),
///   including [`cmd_copy_query_pool_results`].
/// - [`PIPELINE_STAGE2_BLIT`] specifies the execution of [`cmd_blit_image`].
/// - [`PIPELINE_STAGE2_RESOLVE`] specifies the execution of [`cmd_resolve_image`].
/// - [`PIPELINE_STAGE2_CLEAR`] specifies the execution of [clear commands](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#clears),
///   with the exception of [`cmd_clear_attachments`].
/// - [`PIPELINE_STAGE2_ALL_TRANSFER`] is equivalent to specifying all of:  -
///   [`PIPELINE_STAGE2_COPY`]  - [`PIPELINE_STAGE2_BLIT`]  - [`PIPELINE_STAGE2_RESOLVE`]  -
///   [`PIPELINE_STAGE2_CLEAR`]
/// - [`PIPELINE_STAGE2_RAY_TRACING_SHADER_KHR`] specifies the execution of the ray tracing shader
///   stages.
/// - [`PIPELINE_STAGE2_ACCELERATION_STRUCTURE_BUILD_KHR`] specifies the execution of [acceleration structure commands](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#acceleration-structure).
/// - [`PIPELINE_STAGE2_ALL_GRAPHICS`] specifies the execution of all graphics pipeline stages, and
///   is equivalent to the logical OR of:  - [`PIPELINE_STAGE2_DRAW_INDIRECT`]  -
///   [`PIPELINE_STAGE2_TASK_SHADER_NV`]  - [`PIPELINE_STAGE2_MESH_SHADER_NV`]  -
///   [`PIPELINE_STAGE2_VERTEX_INPUT`]  - [`PIPELINE_STAGE2_VERTEX_SHADER`]  -
///   [`PIPELINE_STAGE2_TESSELLATION_CONTROL_SHADER`]  -
///   [`PIPELINE_STAGE2_TESSELLATION_EVALUATION_SHADER`]  - [`PIPELINE_STAGE2_GEOMETRY_SHADER`]  -
///   [`PIPELINE_STAGE2_FRAGMENT_SHADER`]  - [`PIPELINE_STAGE2_EARLY_FRAGMENT_TESTS`]  -
///   [`PIPELINE_STAGE2_LATE_FRAGMENT_TESTS`]  - [`PIPELINE_STAGE2_COLOR_ATTACHMENT_OUTPUT`]  -
///   [`PIPELINE_STAGE2_CONDITIONAL_RENDERING_EXT`]  - [`PIPELINE_STAGE2_TRANSFORM_FEEDBACK_EXT`]  -
///   [`PIPELINE_STAGE2_SHADING_RATE_IMAGE_NV`]  - [`PIPELINE_STAGE2_FRAGMENT_DENSITY_PROCESS_EXT`]
///   - [`PIPELINE_STAGE2_INVOCATION_MASK_HUAWEI`]
/// - [`PIPELINE_STAGE2_ALL_COMMANDS`] specifies all operations performed by all commands supported
///   on the queue it is used with.
/// - [`PIPELINE_STAGE2_CONDITIONAL_RENDERING_EXT`] specifies the stage of the pipeline where the
///   predicate of conditional rendering is consumed.
/// - [`PIPELINE_STAGE2_TRANSFORM_FEEDBACK_EXT`] specifies the stage of the pipeline where vertex
///   attribute output values are written to the transform feedback buffers.
/// - [`PIPELINE_STAGE2_COMMAND_PREPROCESS_NV`] specifies the stage of the pipeline where
///   device-side generation of commands via [`cmd_preprocess_generated_commands_nv`] is handled.
/// - [`PIPELINE_STAGE2_FRAGMENT_SHADING_RATE_ATTACHMENT_KHR`]     specifies the stage of the pipeline where the     [fragment shading rate     attachment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#primsrast-fragment-shading-rate-attachment) or     [shading rate image](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#primsrast-shading-rate-image)     is read to determine the fragment shading rate for portions of a     rasterized primitive.
/// - [`PIPELINE_STAGE2_FRAGMENT_DENSITY_PROCESS_EXT`] specifies the stage of the pipeline where the
///   fragment density map is read to [generate the fragment areas](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fragmentdensitymapops).
/// - [`PIPELINE_STAGE2_INVOCATION_MASK_HUAWEI`] specifies the stage of the pipeline where the
///   invocation mask image is read by the implementation to optimize the ray dispatch.
/// - [`PIPELINE_STAGE2_VIDEO_DECODE_KHR`] specifies the stage of the pipeline where [video decode operation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-decode-operations)
///   are performed.
/// - [`PIPELINE_STAGE2_VIDEO_ENCODE_KHR`] specifies the stage of the pipeline where [video encode operation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-encode-operations)
///   are performed.
/// - [`PIPELINE_STAGE2_SUBPASS_SHADING_HUAWEI`] specifies the subpass shading shader stage.
/// - [`PIPELINE_STAGE2_TOP_OF_PIPE`] is equivalent to [`PIPELINE_STAGE2_ALL_COMMANDS`] with
///   [`AccessFlags2`] set to `0` when specified in the second synchronization scope, but equivalent
///   to [`PIPELINE_STAGE2_NONE`] in the first scope.
/// - [`PIPELINE_STAGE2_BOTTOM_OF_PIPE`] is equivalent to [`PIPELINE_STAGE2_ALL_COMMANDS`] with
///   [`AccessFlags2`] set to `0` when specified in the first synchronization scope, but equivalent
///   to [`PIPELINE_STAGE2_NONE`] in the second scope.
///# Related
/// - [`khr_synchronization2`]
/// - [`crate::vulkan1_3`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkPipelineStageFlags2")]
#[derive(Clone, Copy, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(transparent)]
pub struct PipelineStageFlags2(u64);
impl const Default for PipelineStageFlags2 {
    fn default() -> Self {
        Self(0)
    }
}
impl From<PipelineStageFlagBits2> for PipelineStageFlags2 {
    fn from(from: PipelineStageFlagBits2) -> Self {
        unsafe { Self::from_bits_unchecked(from.bits()) }
    }
}
impl PipelineStageFlags2 {
    ///[`PIPELINE_STAGE2_NONE`] specifies no stages of execution.
    pub const PIPELINE_STAGE2_NONE: Self = Self(0);
    ///[`PIPELINE_STAGE2_TOP_OF_PIPE`] is equivalent to
    ///[`PIPELINE_STAGE2_ALL_COMMANDS`] with [`AccessFlags2`] set
    ///to `0` when specified in the second synchronization scope, but
    ///equivalent to [`PIPELINE_STAGE2_NONE`] in the first scope.
    pub const PIPELINE_STAGE2_TOP_OF_PIPE: Self = Self(1);
    ///[`PIPELINE_STAGE2_DRAW_INDIRECT`] specifies the stage of the
    ///pipeline where indirect command parameters are consumed.
    ///This stage also includes reading commands written by
    ///[`cmd_preprocess_generated_commands_nv`].
    pub const PIPELINE_STAGE2_DRAW_INDIRECT: Self = Self(2);
    ///[`PIPELINE_STAGE2_VERTEX_INPUT`] is equivalent to the logical
    ///OR of:
    /// - [`PIPELINE_STAGE2_INDEX_INPUT`]
    /// - [`PIPELINE_STAGE2_VERTEX_ATTRIBUTE_INPUT`]
    pub const PIPELINE_STAGE2_VERTEX_INPUT: Self = Self(4);
    ///[`PIPELINE_STAGE2_VERTEX_SHADER`] specifies the vertex shader
    ///stage.
    pub const PIPELINE_STAGE2_VERTEX_SHADER: Self = Self(8);
    ///[`PIPELINE_STAGE2_TESSELLATION_CONTROL_SHADER`] specifies the
    ///tessellation control shader stage.
    pub const PIPELINE_STAGE2_TESSELLATION_CONTROL_SHADER: Self = Self(16);
    ///[`PIPELINE_STAGE2_TESSELLATION_EVALUATION_SHADER`] specifies
    ///the tessellation evaluation shader stage.
    pub const PIPELINE_STAGE2_TESSELLATION_EVALUATION_SHADER: Self = Self(32);
    ///[`PIPELINE_STAGE2_GEOMETRY_SHADER`] specifies the geometry
    ///shader stage.
    pub const PIPELINE_STAGE2_GEOMETRY_SHADER: Self = Self(64);
    ///[`PIPELINE_STAGE2_FRAGMENT_SHADER`] specifies the fragment
    ///shader stage.
    pub const PIPELINE_STAGE2_FRAGMENT_SHADER: Self = Self(128);
    ///[`PIPELINE_STAGE2_EARLY_FRAGMENT_TESTS`] specifies the stage
    ///of the pipeline where early fragment tests (depth and stencil tests
    ///before fragment shading) are performed.
    ///This stage also includes [subpass load
    ///operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-load-store-ops) for framebuffer attachments with a depth/stencil format.
    pub const PIPELINE_STAGE2_EARLY_FRAGMENT_TESTS: Self = Self(256);
    ///[`PIPELINE_STAGE2_LATE_FRAGMENT_TESTS`] specifies the stage of
    ///the pipeline where late fragment tests (depth and stencil tests after
    ///fragment shading) are performed.
    ///This stage also includes [subpass store
    ///operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-load-store-ops) for framebuffer attachments with a depth/stencil format.
    pub const PIPELINE_STAGE2_LATE_FRAGMENT_TESTS: Self = Self(512);
    ///[`PIPELINE_STAGE2_COLOR_ATTACHMENT_OUTPUT`] specifies the
    ///stage of the pipeline after blending where the final color values are
    ///output from the pipeline.
    ///This stage also includes [subpass load and
    ///store operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-load-store-ops) and multisample resolve operations for framebuffer
    ///attachments with a color
    ///or depth/stencil
    ///format.
    pub const PIPELINE_STAGE2_COLOR_ATTACHMENT_OUTPUT: Self = Self(1024);
    ///[`PIPELINE_STAGE2_COMPUTE_SHADER`] specifies the compute
    ///shader stage.
    pub const PIPELINE_STAGE2_COMPUTE_SHADER: Self = Self(2048);
    ///[`PIPELINE_STAGE2_ALL_TRANSFER`] is equivalent to specifying
    ///all of:
    /// - [`PIPELINE_STAGE2_COPY`]
    /// - [`PIPELINE_STAGE2_BLIT`]
    /// - [`PIPELINE_STAGE2_RESOLVE`]
    /// - [`PIPELINE_STAGE2_CLEAR`]
    pub const PIPELINE_STAGE2_ALL_TRANSFER: Self = Self(4096);
    ///[`PIPELINE_STAGE2_BOTTOM_OF_PIPE`] is equivalent to
    ///[`PIPELINE_STAGE2_ALL_COMMANDS`] with [`AccessFlags2`] set
    ///to `0` when specified in the first synchronization scope, but equivalent
    ///to [`PIPELINE_STAGE2_NONE`] in the second scope.
    pub const PIPELINE_STAGE2_BOTTOM_OF_PIPE: Self = Self(8192);
    ///[`PIPELINE_STAGE2_HOST`] specifies a pseudo-stage indicating
    ///execution on the host of reads/writes of device memory.
    ///This stage is not invoked by any commands recorded in a command buffer.
    pub const PIPELINE_STAGE2_HOST: Self = Self(16384);
    ///[`PIPELINE_STAGE2_ALL_GRAPHICS`] specifies the execution of
    ///all graphics pipeline stages, and is equivalent to the logical OR of:
    /// - [`PIPELINE_STAGE2_DRAW_INDIRECT`]
    /// - [`PIPELINE_STAGE2_TASK_SHADER_NV`]
    /// - [`PIPELINE_STAGE2_MESH_SHADER_NV`]
    /// - [`PIPELINE_STAGE2_VERTEX_INPUT`]
    /// - [`PIPELINE_STAGE2_VERTEX_SHADER`]
    /// - [`PIPELINE_STAGE2_TESSELLATION_CONTROL_SHADER`]
    /// - [`PIPELINE_STAGE2_TESSELLATION_EVALUATION_SHADER`]
    /// - [`PIPELINE_STAGE2_GEOMETRY_SHADER`]
    /// - [`PIPELINE_STAGE2_FRAGMENT_SHADER`]
    /// - [`PIPELINE_STAGE2_EARLY_FRAGMENT_TESTS`]
    /// - [`PIPELINE_STAGE2_LATE_FRAGMENT_TESTS`]
    /// - [`PIPELINE_STAGE2_COLOR_ATTACHMENT_OUTPUT`]
    /// - [`PIPELINE_STAGE2_CONDITIONAL_RENDERING_EXT`]
    /// - [`PIPELINE_STAGE2_TRANSFORM_FEEDBACK_EXT`]
    /// - [`PIPELINE_STAGE2_SHADING_RATE_IMAGE_NV`]
    /// - [`PIPELINE_STAGE2_FRAGMENT_DENSITY_PROCESS_EXT`]
    /// - [`PIPELINE_STAGE2_INVOCATION_MASK_HUAWEI`]
    pub const PIPELINE_STAGE2_ALL_GRAPHICS: Self = Self(32768);
    ///[`PIPELINE_STAGE2_ALL_COMMANDS`] specifies all operations
    ///performed by all commands supported on the queue it is used with.
    pub const PIPELINE_STAGE2_ALL_COMMANDS: Self = Self(65536);
    ///[`PIPELINE_STAGE2_COPY`] specifies the execution of all
    ///[copy commands](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#copies), including [`cmd_copy_query_pool_results`].
    pub const PIPELINE_STAGE2_COPY: Self = Self(4294967296);
    ///[`PIPELINE_STAGE2_RESOLVE`] specifies the execution of
    ///[`cmd_resolve_image`].
    pub const PIPELINE_STAGE2_RESOLVE: Self = Self(8589934592);
    ///[`PIPELINE_STAGE2_BLIT`] specifies the execution of
    ///[`cmd_blit_image`].
    pub const PIPELINE_STAGE2_BLIT: Self = Self(17179869184);
    ///[`PIPELINE_STAGE2_CLEAR`] specifies the execution of
    ///[clear commands](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#clears), with the exception of
    ///[`cmd_clear_attachments`].
    pub const PIPELINE_STAGE2_CLEAR: Self = Self(34359738368);
    ///[`PIPELINE_STAGE2_INDEX_INPUT`] specifies the stage of the
    ///pipeline where index buffers are consumed.
    pub const PIPELINE_STAGE2_INDEX_INPUT: Self = Self(68719476736);
    ///[`PIPELINE_STAGE2_VERTEX_ATTRIBUTE_INPUT`] specifies the stage
    ///of the pipeline where vertex buffers are consumed.
    pub const PIPELINE_STAGE2_VERTEX_ATTRIBUTE_INPUT: Self = Self(137438953472);
    ///[`PIPELINE_STAGE2_PRE_RASTERIZATION_SHADERS`] is equivalent to
    ///specifying all supported
    ///[pre-rasterization shader
    ///stages](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-pre-rasterization):
    /// - [`PIPELINE_STAGE2_VERTEX_SHADER`]
    /// - [`PIPELINE_STAGE2_TESSELLATION_CONTROL_SHADER`]
    /// - [`PIPELINE_STAGE2_TESSELLATION_EVALUATION_SHADER`]
    /// - [`PIPELINE_STAGE2_GEOMETRY_SHADER`]
    /// - [`PIPELINE_STAGE2_TASK_SHADER_NV`]
    /// - [`PIPELINE_STAGE2_MESH_SHADER_NV`]
    pub const PIPELINE_STAGE2_PRE_RASTERIZATION_SHADERS: Self = Self(274877906944);
    ///[`PIPELINE_STAGE2_VIDEO_DECODE_KHR`] specifies the stage of
    ///the pipeline where [video decode operation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-decode-operations)
    ///are performed.
    ///
    ///Provided by [`crate::extensions::khr_video_decode_queue`]
    #[cfg(feature = "VK_KHR_video_decode_queue")]
    pub const PIPELINE_STAGE2_VIDEO_DECODE_KHR: Self = Self(67108864);
    ///[`PIPELINE_STAGE2_VIDEO_ENCODE_KHR`] specifies the stage of
    ///the pipeline where [video encode operation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-encode-operations)
    ///are performed.
    ///
    ///Provided by [`crate::extensions::khr_video_encode_queue`]
    #[cfg(feature = "VK_KHR_video_encode_queue")]
    pub const PIPELINE_STAGE2_VIDEO_ENCODE_KHR: Self = Self(134217728);
    ///[`PIPELINE_STAGE2_TRANSFORM_FEEDBACK_EXT`]
    ///
    ///Provided by [`crate::extensions::khr_synchronization2`]
    #[cfg(feature = "VK_KHR_synchronization2")]
    pub const PIPELINE_STAGE2_TRANSFORM_FEEDBACK_EXT: Self = Self(16777216);
    ///[`PIPELINE_STAGE2_CONDITIONAL_RENDERING_EXT`]
    ///
    ///Provided by [`crate::extensions::khr_synchronization2`]
    #[cfg(feature = "VK_KHR_synchronization2")]
    pub const PIPELINE_STAGE2_CONDITIONAL_RENDERING_EXT: Self = Self(262144);
    ///[`PIPELINE_STAGE2_COMMAND_PREPROCESS_NV`] specifies the stage
    ///of the pipeline where device-side generation of commands via
    ///[`cmd_preprocess_generated_commands_nv`] is handled.
    ///
    ///Provided by [`crate::extensions::khr_synchronization2`]
    #[cfg(feature = "VK_KHR_synchronization2")]
    pub const PIPELINE_STAGE2_COMMAND_PREPROCESS_NV: Self = Self(131072);
    ///[`PIPELINE_STAGE2_FRAGMENT_SHADING_RATE_ATTACHMENT_KHR`]
    ///    specifies the stage of the pipeline where the
    ///    [fragment shading rate
    ///    attachment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#primsrast-fragment-shading-rate-attachment)
    ///or
    ///    [shading rate image](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#primsrast-shading-rate-image)
    ///    is read to determine the fragment shading rate for portions of a
    ///    rasterized primitive.
    ///
    ///Provided by [`crate::extensions::khr_synchronization2`]
    #[cfg(feature = "VK_KHR_synchronization2")]
    pub const PIPELINE_STAGE2_FRAGMENT_SHADING_RATE_ATTACHMENT_KHR: Self = Self(4194304);
    ///[`PIPELINE_STAGE2_ACCELERATION_STRUCTURE_BUILD_KHR`] specifies
    ///the execution of [acceleration structure
    ///commands](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#acceleration-structure).
    ///
    ///Provided by [`crate::extensions::khr_synchronization2`]
    #[cfg(feature = "VK_KHR_synchronization2")]
    pub const PIPELINE_STAGE2_ACCELERATION_STRUCTURE_BUILD_KHR: Self = Self(33554432);
    ///[`PIPELINE_STAGE2_RAY_TRACING_SHADER_KHR`] specifies the
    ///execution of the ray tracing shader stages.
    ///
    ///Provided by [`crate::extensions::khr_synchronization2`]
    #[cfg(feature = "VK_KHR_synchronization2")]
    pub const PIPELINE_STAGE2_RAY_TRACING_SHADER_KHR: Self = Self(2097152);
    ///[`PIPELINE_STAGE2_FRAGMENT_DENSITY_PROCESS_EXT`]
    ///
    ///Provided by [`crate::extensions::khr_synchronization2`]
    #[cfg(feature = "VK_KHR_synchronization2")]
    pub const PIPELINE_STAGE2_FRAGMENT_DENSITY_PROCESS_EXT: Self = Self(8388608);
    ///[`PIPELINE_STAGE2_TASK_SHADER_NV`] specifies the task shader
    ///stage.
    ///
    ///Provided by [`crate::extensions::khr_synchronization2`]
    #[cfg(feature = "VK_KHR_synchronization2")]
    pub const PIPELINE_STAGE2_TASK_SHADER_NV: Self = Self(524288);
    ///[`PIPELINE_STAGE2_MESH_SHADER_NV`] specifies the mesh shader
    ///stage.
    ///
    ///Provided by [`crate::extensions::khr_synchronization2`]
    #[cfg(feature = "VK_KHR_synchronization2")]
    pub const PIPELINE_STAGE2_MESH_SHADER_NV: Self = Self(1048576);
    ///[`PIPELINE_STAGE2_SUBPASS_SHADING_HUAWEI`] specifies the
    ///subpass shading shader stage.
    ///
    ///Provided by [`crate::extensions::huawei_subpass_shading`]
    #[cfg(feature = "VK_HUAWEI_subpass_shading")]
    pub const PIPELINE_STAGE2_SUBPASS_SHADING_HUAWEI: Self = Self(549755813888);
    ///[`PIPELINE_STAGE2_INVOCATION_MASK_HUAWEI`]
    ///
    ///Provided by [`crate::extensions::huawei_invocation_mask`]
    #[cfg(feature = "VK_HUAWEI_invocation_mask")]
    pub const PIPELINE_STAGE2_INVOCATION_MASK_HUAWEI: Self = Self(1099511627776);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    #[allow(unused_mut)]
    pub const fn all() -> Self {
        let mut all = Self::empty();
        {
            all |= Self::PIPELINE_STAGE2_NONE;
        }
        {
            all |= Self::PIPELINE_STAGE2_TOP_OF_PIPE;
        }
        {
            all |= Self::PIPELINE_STAGE2_DRAW_INDIRECT;
        }
        {
            all |= Self::PIPELINE_STAGE2_VERTEX_INPUT;
        }
        {
            all |= Self::PIPELINE_STAGE2_VERTEX_SHADER;
        }
        {
            all |= Self::PIPELINE_STAGE2_TESSELLATION_CONTROL_SHADER;
        }
        {
            all |= Self::PIPELINE_STAGE2_TESSELLATION_EVALUATION_SHADER;
        }
        {
            all |= Self::PIPELINE_STAGE2_GEOMETRY_SHADER;
        }
        {
            all |= Self::PIPELINE_STAGE2_FRAGMENT_SHADER;
        }
        {
            all |= Self::PIPELINE_STAGE2_EARLY_FRAGMENT_TESTS;
        }
        {
            all |= Self::PIPELINE_STAGE2_LATE_FRAGMENT_TESTS;
        }
        {
            all |= Self::PIPELINE_STAGE2_COLOR_ATTACHMENT_OUTPUT;
        }
        {
            all |= Self::PIPELINE_STAGE2_COMPUTE_SHADER;
        }
        {
            all |= Self::PIPELINE_STAGE2_ALL_TRANSFER;
        }
        {
            all |= Self::PIPELINE_STAGE2_BOTTOM_OF_PIPE;
        }
        {
            all |= Self::PIPELINE_STAGE2_HOST;
        }
        {
            all |= Self::PIPELINE_STAGE2_ALL_GRAPHICS;
        }
        {
            all |= Self::PIPELINE_STAGE2_ALL_COMMANDS;
        }
        {
            all |= Self::PIPELINE_STAGE2_COPY;
        }
        {
            all |= Self::PIPELINE_STAGE2_RESOLVE;
        }
        {
            all |= Self::PIPELINE_STAGE2_BLIT;
        }
        {
            all |= Self::PIPELINE_STAGE2_CLEAR;
        }
        {
            all |= Self::PIPELINE_STAGE2_INDEX_INPUT;
        }
        {
            all |= Self::PIPELINE_STAGE2_VERTEX_ATTRIBUTE_INPUT;
        }
        {
            all |= Self::PIPELINE_STAGE2_PRE_RASTERIZATION_SHADERS;
        }
        #[cfg(feature = "VK_KHR_video_decode_queue")]
        {
            all |= Self::PIPELINE_STAGE2_VIDEO_DECODE_KHR;
        }
        #[cfg(feature = "VK_KHR_video_encode_queue")]
        {
            all |= Self::PIPELINE_STAGE2_VIDEO_ENCODE_KHR;
        }
        #[cfg(feature = "VK_KHR_synchronization2")]
        {
            all |= Self::PIPELINE_STAGE2_TRANSFORM_FEEDBACK_EXT;
        }
        #[cfg(feature = "VK_KHR_synchronization2")]
        {
            all |= Self::PIPELINE_STAGE2_CONDITIONAL_RENDERING_EXT;
        }
        #[cfg(feature = "VK_KHR_synchronization2")]
        {
            all |= Self::PIPELINE_STAGE2_COMMAND_PREPROCESS_NV;
        }
        #[cfg(feature = "VK_KHR_synchronization2")]
        {
            all |= Self::PIPELINE_STAGE2_FRAGMENT_SHADING_RATE_ATTACHMENT_KHR;
        }
        #[cfg(feature = "VK_KHR_synchronization2")]
        {
            all |= Self::PIPELINE_STAGE2_ACCELERATION_STRUCTURE_BUILD_KHR;
        }
        #[cfg(feature = "VK_KHR_synchronization2")]
        {
            all |= Self::PIPELINE_STAGE2_RAY_TRACING_SHADER_KHR;
        }
        #[cfg(feature = "VK_KHR_synchronization2")]
        {
            all |= Self::PIPELINE_STAGE2_FRAGMENT_DENSITY_PROCESS_EXT;
        }
        #[cfg(feature = "VK_KHR_synchronization2")]
        {
            all |= Self::PIPELINE_STAGE2_TASK_SHADER_NV;
        }
        #[cfg(feature = "VK_KHR_synchronization2")]
        {
            all |= Self::PIPELINE_STAGE2_MESH_SHADER_NV;
        }
        #[cfg(feature = "VK_HUAWEI_subpass_shading")]
        {
            all |= Self::PIPELINE_STAGE2_SUBPASS_SHADING_HUAWEI;
        }
        #[cfg(feature = "VK_HUAWEI_invocation_mask")]
        {
            all |= Self::PIPELINE_STAGE2_INVOCATION_MASK_HUAWEI;
        }
        all
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u64 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u64) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u64) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u64) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl const std::ops::BitOr for PipelineStageFlags2 {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl const std::ops::BitOrAssign for PipelineStageFlags2 {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl const std::ops::BitXor for PipelineStageFlags2 {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl const std::ops::BitXorAssign for PipelineStageFlags2 {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl const std::ops::BitAnd for PipelineStageFlags2 {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl const std::ops::BitAndAssign for PipelineStageFlags2 {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl const std::ops::Sub for PipelineStageFlags2 {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl const std::ops::SubAssign for PipelineStageFlags2 {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl const std::ops::Not for PipelineStageFlags2 {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl Extend<PipelineStageFlags2> for PipelineStageFlags2 {
    fn extend<T: IntoIterator<Item = PipelineStageFlags2>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, i);
        }
    }
}
impl Extend<PipelineStageFlagBits2> for PipelineStageFlags2 {
    fn extend<T: IntoIterator<Item = PipelineStageFlagBits2>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, <Self as From<PipelineStageFlagBits2>>::from(i));
        }
    }
}
impl FromIterator<PipelineStageFlags2> for PipelineStageFlags2 {
    fn from_iter<T: IntoIterator<Item = PipelineStageFlags2>>(iterator: T) -> PipelineStageFlags2 {
        let mut out = Self::empty();
        <Self as Extend<PipelineStageFlags2>>::extend(&mut out, iterator);
        out
    }
}
impl FromIterator<PipelineStageFlagBits2> for PipelineStageFlags2 {
    fn from_iter<T: IntoIterator<Item = PipelineStageFlagBits2>>(iterator: T) -> PipelineStageFlags2 {
        let mut out = Self::empty();
        <Self as Extend<PipelineStageFlagBits2>>::extend(&mut out, iterator);
        out
    }
}
impl std::fmt::Debug for PipelineStageFlags2 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(PipelineStageFlags2);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == PipelineStageFlags2::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(PipelineStageFlags2::PIPELINE_STAGE2_NONE) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(PIPELINE_STAGE2_NONE))?;
                    }
                    if self.0.contains(PipelineStageFlags2::PIPELINE_STAGE2_TOP_OF_PIPE) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(PIPELINE_STAGE2_TOP_OF_PIPE))?;
                    }
                    if self.0.contains(PipelineStageFlags2::PIPELINE_STAGE2_DRAW_INDIRECT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(PIPELINE_STAGE2_DRAW_INDIRECT))?;
                    }
                    if self.0.contains(PipelineStageFlags2::PIPELINE_STAGE2_VERTEX_INPUT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(PIPELINE_STAGE2_VERTEX_INPUT))?;
                    }
                    if self.0.contains(PipelineStageFlags2::PIPELINE_STAGE2_VERTEX_SHADER) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(PIPELINE_STAGE2_VERTEX_SHADER))?;
                    }
                    if self
                        .0
                        .contains(PipelineStageFlags2::PIPELINE_STAGE2_TESSELLATION_CONTROL_SHADER)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(PIPELINE_STAGE2_TESSELLATION_CONTROL_SHADER))?;
                    }
                    if self
                        .0
                        .contains(PipelineStageFlags2::PIPELINE_STAGE2_TESSELLATION_EVALUATION_SHADER)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(PIPELINE_STAGE2_TESSELLATION_EVALUATION_SHADER))?;
                    }
                    if self.0.contains(PipelineStageFlags2::PIPELINE_STAGE2_GEOMETRY_SHADER) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(PIPELINE_STAGE2_GEOMETRY_SHADER))?;
                    }
                    if self.0.contains(PipelineStageFlags2::PIPELINE_STAGE2_FRAGMENT_SHADER) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(PIPELINE_STAGE2_FRAGMENT_SHADER))?;
                    }
                    if self
                        .0
                        .contains(PipelineStageFlags2::PIPELINE_STAGE2_EARLY_FRAGMENT_TESTS)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(PIPELINE_STAGE2_EARLY_FRAGMENT_TESTS))?;
                    }
                    if self
                        .0
                        .contains(PipelineStageFlags2::PIPELINE_STAGE2_LATE_FRAGMENT_TESTS)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(PIPELINE_STAGE2_LATE_FRAGMENT_TESTS))?;
                    }
                    if self
                        .0
                        .contains(PipelineStageFlags2::PIPELINE_STAGE2_COLOR_ATTACHMENT_OUTPUT)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(PIPELINE_STAGE2_COLOR_ATTACHMENT_OUTPUT))?;
                    }
                    if self.0.contains(PipelineStageFlags2::PIPELINE_STAGE2_COMPUTE_SHADER) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(PIPELINE_STAGE2_COMPUTE_SHADER))?;
                    }
                    if self.0.contains(PipelineStageFlags2::PIPELINE_STAGE2_ALL_TRANSFER) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(PIPELINE_STAGE2_ALL_TRANSFER))?;
                    }
                    if self.0.contains(PipelineStageFlags2::PIPELINE_STAGE2_BOTTOM_OF_PIPE) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(PIPELINE_STAGE2_BOTTOM_OF_PIPE))?;
                    }
                    if self.0.contains(PipelineStageFlags2::PIPELINE_STAGE2_HOST) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(PIPELINE_STAGE2_HOST))?;
                    }
                    if self.0.contains(PipelineStageFlags2::PIPELINE_STAGE2_ALL_GRAPHICS) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(PIPELINE_STAGE2_ALL_GRAPHICS))?;
                    }
                    if self.0.contains(PipelineStageFlags2::PIPELINE_STAGE2_ALL_COMMANDS) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(PIPELINE_STAGE2_ALL_COMMANDS))?;
                    }
                    if self.0.contains(PipelineStageFlags2::PIPELINE_STAGE2_COPY) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(PIPELINE_STAGE2_COPY))?;
                    }
                    if self.0.contains(PipelineStageFlags2::PIPELINE_STAGE2_RESOLVE) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(PIPELINE_STAGE2_RESOLVE))?;
                    }
                    if self.0.contains(PipelineStageFlags2::PIPELINE_STAGE2_BLIT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(PIPELINE_STAGE2_BLIT))?;
                    }
                    if self.0.contains(PipelineStageFlags2::PIPELINE_STAGE2_CLEAR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(PIPELINE_STAGE2_CLEAR))?;
                    }
                    if self.0.contains(PipelineStageFlags2::PIPELINE_STAGE2_INDEX_INPUT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(PIPELINE_STAGE2_INDEX_INPUT))?;
                    }
                    if self
                        .0
                        .contains(PipelineStageFlags2::PIPELINE_STAGE2_VERTEX_ATTRIBUTE_INPUT)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(PIPELINE_STAGE2_VERTEX_ATTRIBUTE_INPUT))?;
                    }
                    if self
                        .0
                        .contains(PipelineStageFlags2::PIPELINE_STAGE2_PRE_RASTERIZATION_SHADERS)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(PIPELINE_STAGE2_PRE_RASTERIZATION_SHADERS))?;
                    }
                    #[cfg(feature = "VK_KHR_video_decode_queue")]
                    if self.0.contains(PipelineStageFlags2::PIPELINE_STAGE2_VIDEO_DECODE_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(PIPELINE_STAGE2_VIDEO_DECODE_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_video_encode_queue")]
                    if self.0.contains(PipelineStageFlags2::PIPELINE_STAGE2_VIDEO_ENCODE_KHR) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(PIPELINE_STAGE2_VIDEO_ENCODE_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_synchronization2")]
                    if self
                        .0
                        .contains(PipelineStageFlags2::PIPELINE_STAGE2_TRANSFORM_FEEDBACK_EXT)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(PIPELINE_STAGE2_TRANSFORM_FEEDBACK_EXT))?;
                    }
                    #[cfg(feature = "VK_KHR_synchronization2")]
                    if self
                        .0
                        .contains(PipelineStageFlags2::PIPELINE_STAGE2_CONDITIONAL_RENDERING_EXT)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(PIPELINE_STAGE2_CONDITIONAL_RENDERING_EXT))?;
                    }
                    #[cfg(feature = "VK_KHR_synchronization2")]
                    if self
                        .0
                        .contains(PipelineStageFlags2::PIPELINE_STAGE2_COMMAND_PREPROCESS_NV)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(PIPELINE_STAGE2_COMMAND_PREPROCESS_NV))?;
                    }
                    #[cfg(feature = "VK_KHR_synchronization2")]
                    if self
                        .0
                        .contains(PipelineStageFlags2::PIPELINE_STAGE2_FRAGMENT_SHADING_RATE_ATTACHMENT_KHR)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(PIPELINE_STAGE2_FRAGMENT_SHADING_RATE_ATTACHMENT_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_synchronization2")]
                    if self
                        .0
                        .contains(PipelineStageFlags2::PIPELINE_STAGE2_ACCELERATION_STRUCTURE_BUILD_KHR)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(PIPELINE_STAGE2_ACCELERATION_STRUCTURE_BUILD_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_synchronization2")]
                    if self
                        .0
                        .contains(PipelineStageFlags2::PIPELINE_STAGE2_RAY_TRACING_SHADER_KHR)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(PIPELINE_STAGE2_RAY_TRACING_SHADER_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_synchronization2")]
                    if self
                        .0
                        .contains(PipelineStageFlags2::PIPELINE_STAGE2_FRAGMENT_DENSITY_PROCESS_EXT)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(PIPELINE_STAGE2_FRAGMENT_DENSITY_PROCESS_EXT))?;
                    }
                    #[cfg(feature = "VK_KHR_synchronization2")]
                    if self.0.contains(PipelineStageFlags2::PIPELINE_STAGE2_TASK_SHADER_NV) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(PIPELINE_STAGE2_TASK_SHADER_NV))?;
                    }
                    #[cfg(feature = "VK_KHR_synchronization2")]
                    if self.0.contains(PipelineStageFlags2::PIPELINE_STAGE2_MESH_SHADER_NV) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(PIPELINE_STAGE2_MESH_SHADER_NV))?;
                    }
                    #[cfg(feature = "VK_HUAWEI_subpass_shading")]
                    if self
                        .0
                        .contains(PipelineStageFlags2::PIPELINE_STAGE2_SUBPASS_SHADING_HUAWEI)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(PIPELINE_STAGE2_SUBPASS_SHADING_HUAWEI))?;
                    }
                    #[cfg(feature = "VK_HUAWEI_invocation_mask")]
                    if self
                        .0
                        .contains(PipelineStageFlags2::PIPELINE_STAGE2_INVOCATION_MASK_HUAWEI)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(PIPELINE_STAGE2_INVOCATION_MASK_HUAWEI))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(PipelineStageFlags2))
            .field(&Flags(*self))
            .finish()
    }
}
///[VkFormatFeatureFlagBits2](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFormatFeatureFlagBits2.html) - Bitmask specifying features supported by a buffer
///# C Specifications
///Bits which  **can**  be set in the [`FormatProperties3`] features
///`linearTilingFeatures`, `optimalTilingFeatures`, and
///`bufferFeatures` are:
///```c
///// Provided by VK_VERSION_1_3
///// Flag bits for VkFormatFeatureFlagBits2
///typedef VkFlags64 VkFormatFeatureFlagBits2;
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_BIT = 0x00000001ULL;
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_BIT_KHR = 0x00000001ULL;
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_STORAGE_IMAGE_BIT = 0x00000002ULL;
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_STORAGE_IMAGE_BIT_KHR = 0x00000002ULL;
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_STORAGE_IMAGE_ATOMIC_BIT =
/// 0x00000004ULL;
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_STORAGE_IMAGE_ATOMIC_BIT_KHR =
/// 0x00000004ULL;
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_UNIFORM_TEXEL_BUFFER_BIT =
/// 0x00000008ULL;
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_UNIFORM_TEXEL_BUFFER_BIT_KHR =
/// 0x00000008ULL;
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_BIT =
/// 0x00000010ULL;
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_BIT_KHR =
/// 0x00000010ULL;
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_ATOMIC_BIT =
/// 0x00000020ULL;
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_ATOMIC_BIT_KHR =
/// 0x00000020ULL;
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_VERTEX_BUFFER_BIT = 0x00000040ULL;
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_VERTEX_BUFFER_BIT_KHR = 0x00000040ULL;
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BIT = 0x00000080ULL;
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BIT_KHR =
/// 0x00000080ULL;
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BLEND_BIT =
/// 0x00000100ULL;
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BLEND_BIT_KHR =
/// 0x00000100ULL;
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_DEPTH_STENCIL_ATTACHMENT_BIT =
/// 0x00000200ULL;
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_DEPTH_STENCIL_ATTACHMENT_BIT_KHR =
/// 0x00000200ULL;
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_BLIT_SRC_BIT = 0x00000400ULL;
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_BLIT_SRC_BIT_KHR = 0x00000400ULL;
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_BLIT_DST_BIT = 0x00000800ULL;
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_BLIT_DST_BIT_KHR = 0x00000800ULL;
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_LINEAR_BIT =
/// 0x00001000ULL;
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_LINEAR_BIT_KHR =
/// 0x00001000ULL;
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_CUBIC_BIT =
/// 0x00002000ULL;
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT =
/// 0x00002000ULL;
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_TRANSFER_SRC_BIT = 0x00004000ULL;
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_TRANSFER_SRC_BIT_KHR = 0x00004000ULL;
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_TRANSFER_DST_BIT = 0x00008000ULL;
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_TRANSFER_DST_BIT_KHR = 0x00008000ULL;
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_MINMAX_BIT =
/// 0x00010000ULL;
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_MINMAX_BIT_KHR =
/// 0x00010000ULL;
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_MIDPOINT_CHROMA_SAMPLES_BIT =
/// 0x00020000ULL;
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_MIDPOINT_CHROMA_SAMPLES_BIT_KHR =
/// 0x00020000ULL;
///static const VkFormatFeatureFlagBits2
/// VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT = 0x00040000ULL;
///static const VkFormatFeatureFlagBits2
/// VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR = 0x00040000ULL;
///static const VkFormatFeatureFlagBits2
/// VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT =
/// 0x00080000ULL;
///static const VkFormatFeatureFlagBits2
/// VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR =
/// 0x00080000ULL;
///static const VkFormatFeatureFlagBits2
/// VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT =
/// 0x00100000ULL;
///static const VkFormatFeatureFlagBits2
/// VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR =
/// 0x00100000ULL;
///static const VkFormatFeatureFlagBits2
/// VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT
/// = 0x00200000ULL;
///static const VkFormatFeatureFlagBits2
/// VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR
/// = 0x00200000ULL;
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_DISJOINT_BIT = 0x00400000ULL;
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_DISJOINT_BIT_KHR = 0x00400000ULL;
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_COSITED_CHROMA_SAMPLES_BIT =
/// 0x00800000ULL;
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_COSITED_CHROMA_SAMPLES_BIT_KHR =
/// 0x00800000ULL;
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT =
/// 0x80000000ULL;
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT_KHR =
/// 0x80000000ULL;
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT =
/// 0x100000000ULL;
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT_KHR =
/// 0x100000000ULL;
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT =
/// 0x200000000ULL;
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT_KHR
/// = 0x200000000ULL;
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///// Provided by VK_KHR_format_feature_flags2 with VK_KHR_video_decode_queue
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_VIDEO_DECODE_OUTPUT_BIT_KHR =
/// 0x02000000ULL;
///#endif
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///// Provided by VK_KHR_format_feature_flags2 with VK_KHR_video_decode_queue
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_VIDEO_DECODE_DPB_BIT_KHR =
/// 0x04000000ULL;
///#endif
///// Provided by VK_KHR_acceleration_structure with VK_KHR_format_feature_flags2
///static const VkFormatFeatureFlagBits2
/// VK_FORMAT_FEATURE_2_ACCELERATION_STRUCTURE_VERTEX_BUFFER_BIT_KHR = 0x20000000ULL;
///// Provided by VK_KHR_format_feature_flags2 with VK_EXT_fragment_density_map
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_FRAGMENT_DENSITY_MAP_BIT_EXT =
/// 0x01000000ULL;
///// Provided by VK_KHR_format_feature_flags2 with VK_KHR_fragment_shading_rate
///static const VkFormatFeatureFlagBits2
/// VK_FORMAT_FEATURE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = 0x40000000ULL;
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///// Provided by VK_KHR_format_feature_flags2 with VK_KHR_video_encode_queue
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_VIDEO_ENCODE_INPUT_BIT_KHR =
/// 0x08000000ULL;
///#endif
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///// Provided by VK_KHR_format_feature_flags2 with VK_KHR_video_encode_queue
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_VIDEO_ENCODE_DPB_BIT_KHR =
/// 0x10000000ULL;
///#endif
///// Provided by VK_KHR_format_feature_flags2 with VK_NV_linear_color_attachment
///static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_LINEAR_COLOR_ATTACHMENT_BIT_NV =
/// 0x4000000000ULL;
///```
///or the equivalent
///```c
///// Provided by VK_KHR_format_feature_flags2
///typedef VkFormatFeatureFlagBits2 VkFormatFeatureFlagBits2KHR;
///```
///# Description
///The following bits  **may**  be set in `linearTilingFeatures` and
///`optimalTilingFeatures`, specifying that the features are supported by
///[`Image`] or [`ImageView`]
///or [`SamplerYcbcrConversion`]
///created with the queried
///[`get_physical_device_format_properties2`]`::format`:
/// - [`FORMAT_FEATURE2_SAMPLED_IMAGE`] specifies that an image view  **can**  be [sampled from](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-sampledimage).
/// - [`FORMAT_FEATURE2_STORAGE_IMAGE`] specifies that an image view  **can**  be used as a [storage
///   image](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storageimage).
/// - [`FORMAT_FEATURE2_STORAGE_IMAGE_ATOMIC`] specifies that an image view  **can**  be used as
///   storage image that supports atomic operations.
/// - [`FORMAT_FEATURE2_COLOR_ATTACHMENT`] specifies that an image view  **can**  be used as a
///   framebuffer color attachment and as an input attachment.
/// - [`FORMAT_FEATURE2_COLOR_ATTACHMENT_BLEND`] specifies that an image view  **can**  be used as a
///   framebuffer color attachment that supports blending and as an input attachment.
/// - [`FORMAT_FEATURE2_DEPTH_STENCIL_ATTACHMENT`] specifies that an image view  **can**  be used as
///   a framebuffer depth/stencil attachment and as an input attachment.
/// - [`FORMAT_FEATURE2_BLIT_SRC`] specifies that an image  **can**  be     used as the `srcImage`
///   for [`cmd_blit_image2`] and     [`cmd_blit_image`].
/// - [`FORMAT_FEATURE2_BLIT_DST`] specifies that an image  **can**  be     used as the `dstImage`
///   for [`cmd_blit_image2`] and     [`cmd_blit_image`].
/// - [`FORMAT_FEATURE2_SAMPLED_IMAGE_FILTER_LINEAR`] specifies that     if
///   [`FORMAT_FEATURE2_SAMPLED_IMAGE`] is also set, an image     view  **can**  be used with a
///   sampler that has either of `magFilter` or     `minFilter` set to `VK_FILTER_LINEAR`, or
///   `mipmapMode` set     to `VK_SAMPLER_MIPMAP_MODE_LINEAR`.     If [`FORMAT_FEATURE2_BLIT_SRC`]
///   is also set, an image can be     used as the `srcImage` for [`cmd_blit_image2`] and
///   [`cmd_blit_image`] with a `filter` of `VK_FILTER_LINEAR`.     This bit  **must**  only be
///   exposed for formats that also support the     [`FORMAT_FEATURE2_SAMPLED_IMAGE`] or
///   [`FORMAT_FEATURE2_BLIT_SRC`].If the format being queried is a depth/stencil format, this bit
///   only specifies that the depth aspect (not the stencil aspect) of an image of this format
///   supports linear filtering. Where depth comparison is supported it  **may**  be linear filtered
///   whether this bit is present or not, but where this bit is not present the filtered value
///   **may**  be computed in an implementation-dependent manner which differs from the normal rules
///   of linear filtering. The resulting value  **must**  be in the range [0,1] and  **should**  be
///   proportional to, or a weighted average of, the number of comparison passes or failures.
/// - [`FORMAT_FEATURE2_TRANSFER_SRC`] specifies that an image  **can**  be used as a source image for [copy commands](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#copies).
/// - [`FORMAT_FEATURE2_TRANSFER_DST`] specifies that an image  **can**  be used as a destination image for [copy commands](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#copies) and [clear commands](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#clears).
/// - [`FORMAT_FEATURE2_SAMPLED_IMAGE_FILTER_MINMAX`] specifies [`Image`] **can**  be used as a
///   sampled image with a min or max [`SamplerReductionMode`]. This bit  **must**  only be exposed
///   for formats that also support the [`FORMAT_FEATURE2_SAMPLED_IMAGE`].
/// - [`FORMAT_FEATURE2_SAMPLED_IMAGE_FILTER_CUBIC`] specifies that [`Image`] **can**  be used with
///   a sampler that has either of `magFilter` or `minFilter` set to `VK_FILTER_CUBIC_EXT`, or be
///   the source image for a blit with `filter` set to `VK_FILTER_CUBIC_EXT`. This bit  **must**
///   only be exposed for formats that also support the [`FORMAT_FEATURE2_SAMPLED_IMAGE`]. If the
///   format being queried is a depth/stencil format, this only specifies that the depth aspect is
///   cubic filterable.
/// - [`FORMAT_FEATURE2_MIDPOINT_CHROMA_SAMPLES`] specifies that an application  **can**  define a [sampler YC<sub>B</sub>C<sub>R</sub> conversion](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#samplers-YCbCr-conversion) using this format as a source, and that an image of this format  **can**  be used with a [`SamplerYcbcrConversionCreateInfo`]`xChromaOffset` and/or `yChromaOffset` of `VK_CHROMA_LOCATION_MIDPOINT`. Otherwise both `xChromaOffset` and `yChromaOffset` **must**  be `VK_CHROMA_LOCATION_COSITED_EVEN`. If a format does not incorporate chroma downsampling (it is not a 422 or 420 format) but the implementation supports sampler YC<sub>B</sub>C<sub>R</sub> conversion for this format, the implementation  **must**  set [`FORMAT_FEATURE2_MIDPOINT_CHROMA_SAMPLES`].
/// - [`FORMAT_FEATURE2_COSITED_CHROMA_SAMPLES`] specifies that an application  **can**  define a [sampler YC<sub>B</sub>C<sub>R</sub> conversion](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#samplers-YCbCr-conversion) using this format as a source, and that an image of this format  **can**  be used with a [`SamplerYcbcrConversionCreateInfo`]`xChromaOffset` and/or `yChromaOffset` of `VK_CHROMA_LOCATION_COSITED_EVEN`. Otherwise both `xChromaOffset` and `yChromaOffset` **must**  be `VK_CHROMA_LOCATION_MIDPOINT`. If neither [`FORMAT_FEATURE2_COSITED_CHROMA_SAMPLES`] nor [`FORMAT_FEATURE2_MIDPOINT_CHROMA_SAMPLES`] is set, the application  **must**  not define a [sampler YC<sub>B</sub>C<sub>R</sub> conversion](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#samplers-YCbCr-conversion) using this format as a source.
/// - [`FORMAT_FEATURE2_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER`] specifies that an application
///   **can**  define a [sampler YC<sub>B</sub>C<sub>R</sub> conversion](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#samplers-YCbCr-conversion)
///   using this format as a source with `chromaFilter` set to `VK_FILTER_LINEAR`.
/// - [`FORMAT_FEATURE2_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER`] specifies
///   that the format can have different chroma, min, and mag filters.
/// - [`FORMAT_FEATURE2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT`] specifies that reconstruction is explicit, as described in [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#textures-chroma-reconstruction](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#textures-chroma-reconstruction). If this bit is not present, reconstruction is implicit by default.
/// - [`FORMAT_FEATURE2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE`]
///   specifies that reconstruction  **can**  be forcibly made explicit by setting
///   [`SamplerYcbcrConversionCreateInfo::force_explicit_reconstruction`] to [`TRUE`]. If the format
///   being queried supports
///   [`FORMAT_FEATURE2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT`] it  **must**
///   also support
///   [`FORMAT_FEATURE2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE`].
/// - [`FORMAT_FEATURE2_DISJOINT`] specifies that a multi-planar image  **can**  have the
///   `VK_IMAGE_CREATE_DISJOINT_BIT` set during image creation. An implementation  **must**  not set
///   [`FORMAT_FEATURE2_DISJOINT`] for *single-plane formats*.
/// - [`FORMAT_FEATURE2_FRAGMENT_DENSITY_MAP_EXT`] specifies that an image view  **can**  be used as
///   a [fragment density map attachment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-fragmentdensitymapattachment).
/// - [`FORMAT_FEATURE2_FRAGMENT_SHADING_RATE_ATTACHMENT_KHR`] specifies that an image view  **can**
///   be used as a [fragment shading rate attachment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#primsrast-fragment-shading-rate-attachment).
///   An implementation  **must**  not set this feature for formats with numeric type other than
///   `*UINT`, or set it as a buffer feature.
/// - [`FORMAT_FEATURE2_VIDEO_DECODE_OUTPUT_KHR`] specifies that an image view with this format  **can**  be used as an output for [video decode operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-decode-operations)
/// - [`FORMAT_FEATURE2_VIDEO_DECODE_DPB_KHR`] specifies that an image view with this format  **can**  be used as a DPB for [video decode operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-decode-operations)
/// - [`FORMAT_FEATURE2_VIDEO_ENCODE_INPUT_KHR`] specifies that an image view with this format  **can**  be used as an input to [video encode operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-encode-operations)
/// - [`FORMAT_FEATURE2_VIDEO_ENCODE_DPB_KHR`] specifies that an image view with this format  **can**  be used as a DPB for [video encode operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-encode-operations)
/// - [`FORMAT_FEATURE2_STORAGE_READ_WITHOUT_FORMAT`] specifies that image views created with this format  **can**  be used as [storage images](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storageimage) for read operations without specifying a format.
/// - [`FORMAT_FEATURE2_STORAGE_WRITE_WITHOUT_FORMAT`] specifies that image views created with this format  **can**  be used as [storage images](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storageimage) for write operations without specifying a format.
/// - [`FORMAT_FEATURE2_SAMPLED_IMAGE_DEPTH_COMPARISON`] specifies that image views created with
///   this format  **can**  be used for depth comparison performed by `OpImage*Dref*` instructions.
/// - [`FORMAT_FEATURE2_LINEAR_COLOR_ATTACHMENT_NV`] specifies that    the format is supported as a renderable [Linear Color    Attachment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#glossary).    This bit will be set for renderable color formats in the    `linearTilingFeatures`. This  **must**  not be set in the `optimalTilingFeatures` or `bufferFeatures` members.
///The following bits  **may**  be set in `bufferFeatures`, specifying that the
///features are supported by [`Buffer`] or [`BufferView`] created with the queried
///[`get_physical_device_format_properties2`]`::format`:
/// - [`FORMAT_FEATURE2_UNIFORM_TEXEL_BUFFER`] specifies that the format  **can**  be used to create
///   a buffer view that  **can**  be bound to a `VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER`
///   descriptor.
/// - [`FORMAT_FEATURE2_STORAGE_TEXEL_BUFFER`] specifies that the format  **can**  be used to create
///   a buffer view that  **can**  be bound to a `VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER`
///   descriptor.
/// - [`FORMAT_FEATURE2_STORAGE_TEXEL_BUFFER_ATOMIC`] specifies that atomic operations are supported
///   on `VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER` with this format.
/// - [`FORMAT_FEATURE2_VERTEX_BUFFER`] specifies that the format  **can**  be used as a vertex
///   attribute format ([`VertexInputAttributeDescription::format`]).
/// - [`FORMAT_FEATURE2_ACCELERATION_STRUCTURE_VERTEX_BUFFER_KHR`] specifies that the format  **can**  be used as the vertex format when creating an [acceleration structure](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#acceleration-structure) ([`AccelerationStructureGeometryTrianglesDataKHR::vertex_format`]). This format  **can**  also be used as the vertex format in host memory when doing [host acceleration structure](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#host-acceleration-structure) builds.
///# Related
/// - [`khr_format_feature_flags2`]
/// - [`crate::vulkan1_3`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkFormatFeatureFlags2")]
#[derive(Clone, Copy, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(transparent)]
pub struct FormatFeatureFlags2(u64);
impl const Default for FormatFeatureFlags2 {
    fn default() -> Self {
        Self(0)
    }
}
impl From<FormatFeatureFlagBits2> for FormatFeatureFlags2 {
    fn from(from: FormatFeatureFlagBits2) -> Self {
        unsafe { Self::from_bits_unchecked(from.bits()) }
    }
}
impl FormatFeatureFlags2 {
    ///[`FORMAT_FEATURE2_SAMPLED_IMAGE`] specifies that an image view
    /// **can**  be [sampled from](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-sampledimage).
    pub const FORMAT_FEATURE2_SAMPLED_IMAGE: Self = Self(1);
    ///[`FORMAT_FEATURE2_STORAGE_IMAGE`] specifies that an image view
    /// **can**  be used as a [storage image](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storageimage).
    pub const FORMAT_FEATURE2_STORAGE_IMAGE: Self = Self(2);
    ///[`FORMAT_FEATURE2_STORAGE_IMAGE_ATOMIC`] specifies that an
    ///image view  **can**  be used as storage image that supports atomic
    ///operations.
    pub const FORMAT_FEATURE2_STORAGE_IMAGE_ATOMIC: Self = Self(4);
    ///[`FORMAT_FEATURE2_UNIFORM_TEXEL_BUFFER`] specifies that the
    ///format  **can**  be used to create a buffer view that  **can**  be bound to a
    ///`VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER` descriptor.
    pub const FORMAT_FEATURE2_UNIFORM_TEXEL_BUFFER: Self = Self(8);
    ///[`FORMAT_FEATURE2_STORAGE_TEXEL_BUFFER`] specifies that the
    ///format  **can**  be used to create a buffer view that  **can**  be bound to a
    ///`VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER` descriptor.
    pub const FORMAT_FEATURE2_STORAGE_TEXEL_BUFFER: Self = Self(16);
    ///[`FORMAT_FEATURE2_STORAGE_TEXEL_BUFFER_ATOMIC`] specifies that
    ///atomic operations are supported on
    ///`VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER` with this format.
    pub const FORMAT_FEATURE2_STORAGE_TEXEL_BUFFER_ATOMIC: Self = Self(32);
    ///[`FORMAT_FEATURE2_VERTEX_BUFFER`] specifies that the format
    /// **can**  be used as a vertex attribute format
    ///([`VertexInputAttributeDescription`]::`format`).
    pub const FORMAT_FEATURE2_VERTEX_BUFFER: Self = Self(64);
    ///[`FORMAT_FEATURE2_COLOR_ATTACHMENT`] specifies that an image
    ///view  **can**  be used as a framebuffer color attachment and as an input
    ///attachment.
    pub const FORMAT_FEATURE2_COLOR_ATTACHMENT: Self = Self(128);
    ///[`FORMAT_FEATURE2_COLOR_ATTACHMENT_BLEND`] specifies that an
    ///image view  **can**  be used as a framebuffer color attachment that supports
    ///blending and as an input attachment.
    pub const FORMAT_FEATURE2_COLOR_ATTACHMENT_BLEND: Self = Self(256);
    ///[`FORMAT_FEATURE2_DEPTH_STENCIL_ATTACHMENT`] specifies that an
    ///image view  **can**  be used as a framebuffer depth/stencil attachment and as
    ///an input attachment.
    pub const FORMAT_FEATURE2_DEPTH_STENCIL_ATTACHMENT: Self = Self(512);
    ///[`FORMAT_FEATURE2_BLIT_SRC`] specifies that an image  **can**  be
    ///    used as the `srcImage` for
    ///[`cmd_blit_image2`] and
    ///    [`cmd_blit_image`].
    pub const FORMAT_FEATURE2_BLIT_SRC: Self = Self(1024);
    ///[`FORMAT_FEATURE2_BLIT_DST`] specifies that an image  **can**  be
    ///    used as the `dstImage` for
    ///[`cmd_blit_image2`] and
    ///    [`cmd_blit_image`].
    pub const FORMAT_FEATURE2_BLIT_DST: Self = Self(2048);
    ///[`FORMAT_FEATURE2_SAMPLED_IMAGE_FILTER_LINEAR`] specifies that
    ///    if [`FORMAT_FEATURE2_SAMPLED_IMAGE`] is also set, an image
    ///    view  **can**  be used with a sampler that has either of `magFilter` or
    ///    `minFilter` set to `VK_FILTER_LINEAR`, or `mipmapMode` set
    ///    to `VK_SAMPLER_MIPMAP_MODE_LINEAR`.
    ///    If [`FORMAT_FEATURE2_BLIT_SRC`] is also set, an image can be
    ///    used as the `srcImage` for
    ///[`cmd_blit_image2`] and
    ///    [`cmd_blit_image`] with a `filter` of `VK_FILTER_LINEAR`.
    ///    This bit  **must**  only be exposed for formats that also support the
    ///    [`FORMAT_FEATURE2_SAMPLED_IMAGE`] or
    ///    [`FORMAT_FEATURE2_BLIT_SRC`].If the format being queried is a depth/stencil format, this
    /// bit only specifies that the depth aspect (not the stencil aspect) of an image of this
    ///format supports linear filtering.
    ///Where depth comparison is supported it  **may**  be linear filtered whether this
    ///bit is present or not, but where this bit is not present the filtered value
    /// **may**  be computed in an implementation-dependent manner which differs from
    ///the normal rules of linear filtering.
    ///The resulting value  **must**  be in the range [0,1] and  **should**  be
    ///proportional to, or a weighted average of, the number of comparison passes
    ///or failures.
    pub const FORMAT_FEATURE2_SAMPLED_IMAGE_FILTER_LINEAR: Self = Self(4096);
    ///[`FORMAT_FEATURE2_SAMPLED_IMAGE_FILTER_CUBIC`] specifies that
    ///[`Image`] **can**  be used with a sampler that has either of
    ///`magFilter` or `minFilter` set to `VK_FILTER_CUBIC_EXT`, or
    ///be the source image for a blit with `filter` set to
    ///`VK_FILTER_CUBIC_EXT`.
    ///This bit  **must**  only be exposed for formats that also support the
    ///[`FORMAT_FEATURE2_SAMPLED_IMAGE`].
    ///If the format being queried is a depth/stencil format, this only
    ///specifies that the depth aspect is cubic filterable.
    pub const FORMAT_FEATURE2_SAMPLED_IMAGE_FILTER_CUBIC: Self = Self(8192);
    ///[`FORMAT_FEATURE2_TRANSFER_SRC`] specifies that an image  **can**
    ///be used as a source image for [copy commands](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#copies).
    pub const FORMAT_FEATURE2_TRANSFER_SRC: Self = Self(16384);
    ///[`FORMAT_FEATURE2_TRANSFER_DST`] specifies that an image  **can**
    ///be used as a destination image for [copy commands](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#copies) and
    ///[clear commands](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#clears).
    pub const FORMAT_FEATURE2_TRANSFER_DST: Self = Self(32768);
    ///[`FORMAT_FEATURE2_SAMPLED_IMAGE_FILTER_MINMAX`] specifies
    ///[`Image`] **can**  be used as a sampled image with a min or max
    ///[`SamplerReductionMode`].
    ///This bit  **must**  only be exposed for formats that also support the
    ///[`FORMAT_FEATURE2_SAMPLED_IMAGE`].
    pub const FORMAT_FEATURE2_SAMPLED_IMAGE_FILTER_MINMAX: Self = Self(65536);
    ///[`FORMAT_FEATURE2_MIDPOINT_CHROMA_SAMPLES`] specifies that an
    ///application  **can**  define a [sampler YC<sub>B</sub>C<sub>R</sub>
    ///conversion](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#samplers-YCbCr-conversion) using this format as a source, and that an image of this
    ///format  **can**  be used with a [`SamplerYcbcrConversionCreateInfo`]`xChromaOffset` and/or
    /// `yChromaOffset` of `VK_CHROMA_LOCATION_MIDPOINT`.
    ///Otherwise both `xChromaOffset` and `yChromaOffset` **must**  be
    ///`VK_CHROMA_LOCATION_COSITED_EVEN`.
    ///If a format does not incorporate chroma downsampling (it is not a
    ///422 or 420 format) but the implementation supports sampler
    ///YC<sub>B</sub>C<sub>R</sub> conversion for this format, the implementation  **must**  set
    ///[`FORMAT_FEATURE2_MIDPOINT_CHROMA_SAMPLES`].
    pub const FORMAT_FEATURE2_MIDPOINT_CHROMA_SAMPLES: Self = Self(131072);
    ///[`FORMAT_FEATURE2_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER`]
    ///specifies that an application  **can**  define a
    ///[sampler YC<sub>B</sub>C<sub>R</sub> conversion](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#samplers-YCbCr-conversion) using this
    ///format as a source with `chromaFilter` set to
    ///`VK_FILTER_LINEAR`.
    pub const FORMAT_FEATURE2_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER: Self = Self(262144);
    ///[`FORMAT_FEATURE2_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER`]
    ///specifies that the format can have different chroma, min, and mag
    ///filters.
    pub const FORMAT_FEATURE2_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER: Self = Self(524288);
    ///[`FORMAT_FEATURE2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT`]
    ///specifies that reconstruction is explicit, as described in
    ///[https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#textures-chroma-reconstruction](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#textures-chroma-reconstruction).
    ///If this bit is not present, reconstruction is implicit by default.
    pub const FORMAT_FEATURE2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT: Self = Self(1048576);
    ///[`FORMAT_FEATURE2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE`]
    ///specifies that reconstruction  **can**  be forcibly made explicit by setting
    ///[`SamplerYcbcrConversionCreateInfo`]::`forceExplicitReconstruction`
    ///to [`TRUE`].
    ///If the format being queried supports
    ///[`FORMAT_FEATURE2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT`]
    ///it  **must**  also support
    ///[`FORMAT_FEATURE2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE`].
    pub const FORMAT_FEATURE2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE: Self =
        Self(2097152);
    ///[`FORMAT_FEATURE2_DISJOINT`] specifies that a multi-planar
    ///image  **can**  have the `VK_IMAGE_CREATE_DISJOINT_BIT` set during image
    ///creation.
    ///An implementation  **must**  not set [`FORMAT_FEATURE2_DISJOINT`]
    ///for *single-plane formats*.
    pub const FORMAT_FEATURE2_DISJOINT: Self = Self(4194304);
    ///[`FORMAT_FEATURE2_COSITED_CHROMA_SAMPLES`] specifies that an
    ///application  **can**  define a [sampler YC<sub>B</sub>C<sub>R</sub>
    ///conversion](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#samplers-YCbCr-conversion) using this format as a source, and that an image of this
    ///format  **can**  be used with a [`SamplerYcbcrConversionCreateInfo`]`xChromaOffset` and/or
    /// `yChromaOffset` of `VK_CHROMA_LOCATION_COSITED_EVEN`.
    ///Otherwise both `xChromaOffset` and `yChromaOffset` **must**  be
    ///`VK_CHROMA_LOCATION_MIDPOINT`.
    ///If neither [`FORMAT_FEATURE2_COSITED_CHROMA_SAMPLES`] nor
    ///[`FORMAT_FEATURE2_MIDPOINT_CHROMA_SAMPLES`] is set, the
    ///application  **must**  not define a [sampler
    ///YC<sub>B</sub>C<sub>R</sub> conversion](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#samplers-YCbCr-conversion) using this format as a source.
    pub const FORMAT_FEATURE2_COSITED_CHROMA_SAMPLES: Self = Self(8388608);
    ///[`FORMAT_FEATURE2_STORAGE_READ_WITHOUT_FORMAT`] specifies that
    ///image views created with this format  **can**  be used as
    ///[storage images](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storageimage) for read operations
    ///without specifying a format.
    pub const FORMAT_FEATURE2_STORAGE_READ_WITHOUT_FORMAT: Self = Self(2147483648);
    ///[`FORMAT_FEATURE2_STORAGE_WRITE_WITHOUT_FORMAT`] specifies
    ///that image views created with this format  **can**  be used as
    ///[storage images](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storageimage) for write operations
    ///without specifying a format.
    pub const FORMAT_FEATURE2_STORAGE_WRITE_WITHOUT_FORMAT: Self = Self(4294967296);
    ///[`FORMAT_FEATURE2_SAMPLED_IMAGE_DEPTH_COMPARISON`] specifies
    ///that image views created with this format  **can**  be used for depth
    ///comparison performed by `OpImage*Dref*` instructions.
    pub const FORMAT_FEATURE2_SAMPLED_IMAGE_DEPTH_COMPARISON: Self = Self(8589934592);
    ///[`FORMAT_FEATURE2_VIDEO_DECODE_OUTPUT_KHR`] specifies that an
    ///image view with this format  **can**  be used as an output for
    ///[video decode operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-decode-operations)
    ///
    ///Provided by [`crate::extensions::khr_video_decode_queue`]
    #[cfg(feature = "VK_KHR_video_decode_queue")]
    pub const FORMAT_FEATURE2_VIDEO_DECODE_OUTPUT_KHR: Self = Self(33554432);
    ///[`FORMAT_FEATURE2_VIDEO_DECODE_DPB_KHR`] specifies that an
    ///image view with this format  **can**  be used as a DPB for
    ///[video decode operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-decode-operations)
    ///
    ///Provided by [`crate::extensions::khr_video_decode_queue`]
    #[cfg(feature = "VK_KHR_video_decode_queue")]
    pub const FORMAT_FEATURE2_VIDEO_DECODE_DPB_KHR: Self = Self(67108864);
    ///[`FORMAT_FEATURE2_ACCELERATION_STRUCTURE_VERTEX_BUFFER_KHR`]
    ///specifies that the format  **can**  be used as the vertex format when
    ///creating an [acceleration structure](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#acceleration-structure)
    ///([`AccelerationStructureGeometryTrianglesDataKHR`]::`vertexFormat`).
    ///This format  **can**  also be used as the vertex format in host memory when
    ///doing [host acceleration structure](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#host-acceleration-structure)
    ///builds.
    ///
    ///Provided by [`crate::extensions::khr_acceleration_structure`]
    #[cfg(feature = "VK_KHR_acceleration_structure")]
    pub const FORMAT_FEATURE2_ACCELERATION_STRUCTURE_VERTEX_BUFFER_KHR: Self = Self(536870912);
    ///[`FORMAT_FEATURE2_FRAGMENT_DENSITY_MAP_EXT`] specifies that an
    ///image view  **can**  be used as a
    ///[fragment density map
    ///attachment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-fragmentdensitymapattachment).
    ///
    ///Provided by [`crate::extensions::ext_fragment_density_map`]
    #[cfg(feature = "VK_EXT_fragment_density_map")]
    pub const FORMAT_FEATURE2_FRAGMENT_DENSITY_MAP_EXT: Self = Self(16777216);
    ///[`FORMAT_FEATURE2_FRAGMENT_SHADING_RATE_ATTACHMENT_KHR`]
    ///specifies that an image view  **can**  be used as a
    ///[fragment shading rate
    ///attachment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#primsrast-fragment-shading-rate-attachment).
    ///An implementation  **must**  not set this feature for formats with numeric
    ///type other than `*UINT`, or set it as a buffer feature.
    ///
    ///Provided by [`crate::extensions::khr_fragment_shading_rate`]
    #[cfg(feature = "VK_KHR_fragment_shading_rate")]
    pub const FORMAT_FEATURE2_FRAGMENT_SHADING_RATE_ATTACHMENT_KHR: Self = Self(1073741824);
    ///[`FORMAT_FEATURE2_VIDEO_ENCODE_INPUT_KHR`] specifies that an
    ///image view with this format  **can**  be used as an input to
    ///[video encode operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-encode-operations)
    ///
    ///Provided by [`crate::extensions::khr_video_encode_queue`]
    #[cfg(feature = "VK_KHR_video_encode_queue")]
    pub const FORMAT_FEATURE2_VIDEO_ENCODE_INPUT_KHR: Self = Self(134217728);
    ///[`FORMAT_FEATURE2_VIDEO_ENCODE_DPB_KHR`] specifies that an
    ///image view with this format  **can**  be used as a DPB for
    ///[video encode operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-encode-operations)
    ///
    ///Provided by [`crate::extensions::khr_video_encode_queue`]
    #[cfg(feature = "VK_KHR_video_encode_queue")]
    pub const FORMAT_FEATURE2_VIDEO_ENCODE_DPB_KHR: Self = Self(268435456);
    ///[`FORMAT_FEATURE2_LINEAR_COLOR_ATTACHMENT_NV`] specifies that
    ///   the format is supported as a renderable [Linear Color
    ///   Attachment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#glossary).
    ///   This bit will be set for renderable color formats in the
    ///   `linearTilingFeatures`.
    ///This  **must**  not be set in the `optimalTilingFeatures` or
    ///`bufferFeatures` members.
    ///
    ///Provided by [`crate::extensions::nv_linear_color_attachment`]
    #[cfg(feature = "VK_NV_linear_color_attachment")]
    pub const FORMAT_FEATURE2_LINEAR_COLOR_ATTACHMENT_NV: Self = Self(274877906944);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    #[allow(unused_mut)]
    pub const fn all() -> Self {
        let mut all = Self::empty();
        {
            all |= Self::FORMAT_FEATURE2_SAMPLED_IMAGE;
        }
        {
            all |= Self::FORMAT_FEATURE2_STORAGE_IMAGE;
        }
        {
            all |= Self::FORMAT_FEATURE2_STORAGE_IMAGE_ATOMIC;
        }
        {
            all |= Self::FORMAT_FEATURE2_UNIFORM_TEXEL_BUFFER;
        }
        {
            all |= Self::FORMAT_FEATURE2_STORAGE_TEXEL_BUFFER;
        }
        {
            all |= Self::FORMAT_FEATURE2_STORAGE_TEXEL_BUFFER_ATOMIC;
        }
        {
            all |= Self::FORMAT_FEATURE2_VERTEX_BUFFER;
        }
        {
            all |= Self::FORMAT_FEATURE2_COLOR_ATTACHMENT;
        }
        {
            all |= Self::FORMAT_FEATURE2_COLOR_ATTACHMENT_BLEND;
        }
        {
            all |= Self::FORMAT_FEATURE2_DEPTH_STENCIL_ATTACHMENT;
        }
        {
            all |= Self::FORMAT_FEATURE2_BLIT_SRC;
        }
        {
            all |= Self::FORMAT_FEATURE2_BLIT_DST;
        }
        {
            all |= Self::FORMAT_FEATURE2_SAMPLED_IMAGE_FILTER_LINEAR;
        }
        {
            all |= Self::FORMAT_FEATURE2_SAMPLED_IMAGE_FILTER_CUBIC;
        }
        {
            all |= Self::FORMAT_FEATURE2_TRANSFER_SRC;
        }
        {
            all |= Self::FORMAT_FEATURE2_TRANSFER_DST;
        }
        {
            all |= Self::FORMAT_FEATURE2_SAMPLED_IMAGE_FILTER_MINMAX;
        }
        {
            all |= Self::FORMAT_FEATURE2_MIDPOINT_CHROMA_SAMPLES;
        }
        {
            all |= Self::FORMAT_FEATURE2_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER;
        }
        {
            all |= Self::FORMAT_FEATURE2_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER;
        }
        {
            all |= Self::FORMAT_FEATURE2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT;
        }
        {
            all |= Self::FORMAT_FEATURE2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE;
        }
        {
            all |= Self::FORMAT_FEATURE2_DISJOINT;
        }
        {
            all |= Self::FORMAT_FEATURE2_COSITED_CHROMA_SAMPLES;
        }
        {
            all |= Self::FORMAT_FEATURE2_STORAGE_READ_WITHOUT_FORMAT;
        }
        {
            all |= Self::FORMAT_FEATURE2_STORAGE_WRITE_WITHOUT_FORMAT;
        }
        {
            all |= Self::FORMAT_FEATURE2_SAMPLED_IMAGE_DEPTH_COMPARISON;
        }
        #[cfg(feature = "VK_KHR_video_decode_queue")]
        {
            all |= Self::FORMAT_FEATURE2_VIDEO_DECODE_OUTPUT_KHR;
        }
        #[cfg(feature = "VK_KHR_video_decode_queue")]
        {
            all |= Self::FORMAT_FEATURE2_VIDEO_DECODE_DPB_KHR;
        }
        #[cfg(feature = "VK_KHR_acceleration_structure")]
        {
            all |= Self::FORMAT_FEATURE2_ACCELERATION_STRUCTURE_VERTEX_BUFFER_KHR;
        }
        #[cfg(feature = "VK_EXT_fragment_density_map")]
        {
            all |= Self::FORMAT_FEATURE2_FRAGMENT_DENSITY_MAP_EXT;
        }
        #[cfg(feature = "VK_KHR_fragment_shading_rate")]
        {
            all |= Self::FORMAT_FEATURE2_FRAGMENT_SHADING_RATE_ATTACHMENT_KHR;
        }
        #[cfg(feature = "VK_KHR_video_encode_queue")]
        {
            all |= Self::FORMAT_FEATURE2_VIDEO_ENCODE_INPUT_KHR;
        }
        #[cfg(feature = "VK_KHR_video_encode_queue")]
        {
            all |= Self::FORMAT_FEATURE2_VIDEO_ENCODE_DPB_KHR;
        }
        #[cfg(feature = "VK_NV_linear_color_attachment")]
        {
            all |= Self::FORMAT_FEATURE2_LINEAR_COLOR_ATTACHMENT_NV;
        }
        all
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u64 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u64) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u64) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u64) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl const std::ops::BitOr for FormatFeatureFlags2 {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl const std::ops::BitOrAssign for FormatFeatureFlags2 {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl const std::ops::BitXor for FormatFeatureFlags2 {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl const std::ops::BitXorAssign for FormatFeatureFlags2 {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl const std::ops::BitAnd for FormatFeatureFlags2 {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl const std::ops::BitAndAssign for FormatFeatureFlags2 {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl const std::ops::Sub for FormatFeatureFlags2 {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl const std::ops::SubAssign for FormatFeatureFlags2 {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl const std::ops::Not for FormatFeatureFlags2 {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl Extend<FormatFeatureFlags2> for FormatFeatureFlags2 {
    fn extend<T: IntoIterator<Item = FormatFeatureFlags2>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, i);
        }
    }
}
impl Extend<FormatFeatureFlagBits2> for FormatFeatureFlags2 {
    fn extend<T: IntoIterator<Item = FormatFeatureFlagBits2>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, <Self as From<FormatFeatureFlagBits2>>::from(i));
        }
    }
}
impl FromIterator<FormatFeatureFlags2> for FormatFeatureFlags2 {
    fn from_iter<T: IntoIterator<Item = FormatFeatureFlags2>>(iterator: T) -> FormatFeatureFlags2 {
        let mut out = Self::empty();
        <Self as Extend<FormatFeatureFlags2>>::extend(&mut out, iterator);
        out
    }
}
impl FromIterator<FormatFeatureFlagBits2> for FormatFeatureFlags2 {
    fn from_iter<T: IntoIterator<Item = FormatFeatureFlagBits2>>(iterator: T) -> FormatFeatureFlags2 {
        let mut out = Self::empty();
        <Self as Extend<FormatFeatureFlagBits2>>::extend(&mut out, iterator);
        out
    }
}
impl std::fmt::Debug for FormatFeatureFlags2 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(FormatFeatureFlags2);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == FormatFeatureFlags2::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(FormatFeatureFlags2::FORMAT_FEATURE2_SAMPLED_IMAGE) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(FORMAT_FEATURE2_SAMPLED_IMAGE))?;
                    }
                    if self.0.contains(FormatFeatureFlags2::FORMAT_FEATURE2_STORAGE_IMAGE) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(FORMAT_FEATURE2_STORAGE_IMAGE))?;
                    }
                    if self
                        .0
                        .contains(FormatFeatureFlags2::FORMAT_FEATURE2_STORAGE_IMAGE_ATOMIC)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(FORMAT_FEATURE2_STORAGE_IMAGE_ATOMIC))?;
                    }
                    if self
                        .0
                        .contains(FormatFeatureFlags2::FORMAT_FEATURE2_UNIFORM_TEXEL_BUFFER)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(FORMAT_FEATURE2_UNIFORM_TEXEL_BUFFER))?;
                    }
                    if self
                        .0
                        .contains(FormatFeatureFlags2::FORMAT_FEATURE2_STORAGE_TEXEL_BUFFER)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(FORMAT_FEATURE2_STORAGE_TEXEL_BUFFER))?;
                    }
                    if self
                        .0
                        .contains(FormatFeatureFlags2::FORMAT_FEATURE2_STORAGE_TEXEL_BUFFER_ATOMIC)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(FORMAT_FEATURE2_STORAGE_TEXEL_BUFFER_ATOMIC))?;
                    }
                    if self.0.contains(FormatFeatureFlags2::FORMAT_FEATURE2_VERTEX_BUFFER) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(FORMAT_FEATURE2_VERTEX_BUFFER))?;
                    }
                    if self.0.contains(FormatFeatureFlags2::FORMAT_FEATURE2_COLOR_ATTACHMENT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(FORMAT_FEATURE2_COLOR_ATTACHMENT))?;
                    }
                    if self
                        .0
                        .contains(FormatFeatureFlags2::FORMAT_FEATURE2_COLOR_ATTACHMENT_BLEND)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(FORMAT_FEATURE2_COLOR_ATTACHMENT_BLEND))?;
                    }
                    if self
                        .0
                        .contains(FormatFeatureFlags2::FORMAT_FEATURE2_DEPTH_STENCIL_ATTACHMENT)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(FORMAT_FEATURE2_DEPTH_STENCIL_ATTACHMENT))?;
                    }
                    if self.0.contains(FormatFeatureFlags2::FORMAT_FEATURE2_BLIT_SRC) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(FORMAT_FEATURE2_BLIT_SRC))?;
                    }
                    if self.0.contains(FormatFeatureFlags2::FORMAT_FEATURE2_BLIT_DST) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(FORMAT_FEATURE2_BLIT_DST))?;
                    }
                    if self
                        .0
                        .contains(FormatFeatureFlags2::FORMAT_FEATURE2_SAMPLED_IMAGE_FILTER_LINEAR)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(FORMAT_FEATURE2_SAMPLED_IMAGE_FILTER_LINEAR))?;
                    }
                    if self
                        .0
                        .contains(FormatFeatureFlags2::FORMAT_FEATURE2_SAMPLED_IMAGE_FILTER_CUBIC)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(FORMAT_FEATURE2_SAMPLED_IMAGE_FILTER_CUBIC))?;
                    }
                    if self.0.contains(FormatFeatureFlags2::FORMAT_FEATURE2_TRANSFER_SRC) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(FORMAT_FEATURE2_TRANSFER_SRC))?;
                    }
                    if self.0.contains(FormatFeatureFlags2::FORMAT_FEATURE2_TRANSFER_DST) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(FORMAT_FEATURE2_TRANSFER_DST))?;
                    }
                    if self
                        .0
                        .contains(FormatFeatureFlags2::FORMAT_FEATURE2_SAMPLED_IMAGE_FILTER_MINMAX)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(FORMAT_FEATURE2_SAMPLED_IMAGE_FILTER_MINMAX))?;
                    }
                    if self
                        .0
                        .contains(FormatFeatureFlags2::FORMAT_FEATURE2_MIDPOINT_CHROMA_SAMPLES)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(FORMAT_FEATURE2_MIDPOINT_CHROMA_SAMPLES))?;
                    }
                    if self
                        .0
                        .contains(FormatFeatureFlags2::FORMAT_FEATURE2_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(FORMAT_FEATURE2_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER))?;
                    }
                    if self . 0 . contains (FormatFeatureFlags2 :: FORMAT_FEATURE2_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER) { if ! first { f . write_str (" | ") ? ; } first = false ; f . write_str (stringify ! (FORMAT_FEATURE2_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER)) ? ; }
                    if self . 0 . contains (FormatFeatureFlags2 :: FORMAT_FEATURE2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT) { if ! first { f . write_str (" | ") ? ; } first = false ; f . write_str (stringify ! (FORMAT_FEATURE2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT)) ? ; }
                    if self . 0 . contains (FormatFeatureFlags2 :: FORMAT_FEATURE2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE) { if ! first { f . write_str (" | ") ? ; } first = false ; f . write_str (stringify ! (FORMAT_FEATURE2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE)) ? ; }
                    if self.0.contains(FormatFeatureFlags2::FORMAT_FEATURE2_DISJOINT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(FORMAT_FEATURE2_DISJOINT))?;
                    }
                    if self
                        .0
                        .contains(FormatFeatureFlags2::FORMAT_FEATURE2_COSITED_CHROMA_SAMPLES)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(FORMAT_FEATURE2_COSITED_CHROMA_SAMPLES))?;
                    }
                    if self
                        .0
                        .contains(FormatFeatureFlags2::FORMAT_FEATURE2_STORAGE_READ_WITHOUT_FORMAT)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(FORMAT_FEATURE2_STORAGE_READ_WITHOUT_FORMAT))?;
                    }
                    if self
                        .0
                        .contains(FormatFeatureFlags2::FORMAT_FEATURE2_STORAGE_WRITE_WITHOUT_FORMAT)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(FORMAT_FEATURE2_STORAGE_WRITE_WITHOUT_FORMAT))?;
                    }
                    if self
                        .0
                        .contains(FormatFeatureFlags2::FORMAT_FEATURE2_SAMPLED_IMAGE_DEPTH_COMPARISON)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(FORMAT_FEATURE2_SAMPLED_IMAGE_DEPTH_COMPARISON))?;
                    }
                    #[cfg(feature = "VK_KHR_video_decode_queue")]
                    if self
                        .0
                        .contains(FormatFeatureFlags2::FORMAT_FEATURE2_VIDEO_DECODE_OUTPUT_KHR)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(FORMAT_FEATURE2_VIDEO_DECODE_OUTPUT_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_video_decode_queue")]
                    if self
                        .0
                        .contains(FormatFeatureFlags2::FORMAT_FEATURE2_VIDEO_DECODE_DPB_KHR)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(FORMAT_FEATURE2_VIDEO_DECODE_DPB_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_acceleration_structure")]
                    if self
                        .0
                        .contains(FormatFeatureFlags2::FORMAT_FEATURE2_ACCELERATION_STRUCTURE_VERTEX_BUFFER_KHR)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(FORMAT_FEATURE2_ACCELERATION_STRUCTURE_VERTEX_BUFFER_KHR))?;
                    }
                    #[cfg(feature = "VK_EXT_fragment_density_map")]
                    if self
                        .0
                        .contains(FormatFeatureFlags2::FORMAT_FEATURE2_FRAGMENT_DENSITY_MAP_EXT)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(FORMAT_FEATURE2_FRAGMENT_DENSITY_MAP_EXT))?;
                    }
                    #[cfg(feature = "VK_KHR_fragment_shading_rate")]
                    if self
                        .0
                        .contains(FormatFeatureFlags2::FORMAT_FEATURE2_FRAGMENT_SHADING_RATE_ATTACHMENT_KHR)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(FORMAT_FEATURE2_FRAGMENT_SHADING_RATE_ATTACHMENT_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_video_encode_queue")]
                    if self
                        .0
                        .contains(FormatFeatureFlags2::FORMAT_FEATURE2_VIDEO_ENCODE_INPUT_KHR)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(FORMAT_FEATURE2_VIDEO_ENCODE_INPUT_KHR))?;
                    }
                    #[cfg(feature = "VK_KHR_video_encode_queue")]
                    if self
                        .0
                        .contains(FormatFeatureFlags2::FORMAT_FEATURE2_VIDEO_ENCODE_DPB_KHR)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(FORMAT_FEATURE2_VIDEO_ENCODE_DPB_KHR))?;
                    }
                    #[cfg(feature = "VK_NV_linear_color_attachment")]
                    if self
                        .0
                        .contains(FormatFeatureFlags2::FORMAT_FEATURE2_LINEAR_COLOR_ATTACHMENT_NV)
                    {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(FORMAT_FEATURE2_LINEAR_COLOR_ATTACHMENT_NV))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(FormatFeatureFlags2))
            .field(&Flags(*self))
            .finish()
    }
}
///[VkRenderingFlagBits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderingFlagBits.html) - Bitmask specifying additional properties of a dynamic render pass instance
///# C Specifications
///Bits which  **can**  be set in [`RenderingInfo::flags`] describing
///additional properties of the render pass are:
///```c
///// Provided by VK_VERSION_1_3
///typedef enum VkRenderingFlagBits {
///    VK_RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT = 0x00000001,
///    VK_RENDERING_SUSPENDING_BIT = 0x00000002,
///    VK_RENDERING_RESUMING_BIT = 0x00000004,
///    VK_RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT_KHR =
/// VK_RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT,
///    VK_RENDERING_SUSPENDING_BIT_KHR = VK_RENDERING_SUSPENDING_BIT,
///    VK_RENDERING_RESUMING_BIT_KHR = VK_RENDERING_RESUMING_BIT,
///} VkRenderingFlagBits;
///```
///or the equivalent
///```c
///// Provided by VK_KHR_dynamic_rendering
///typedef VkRenderingFlagBits VkRenderingFlagBitsKHR;
///```
///# Description
/// - [`CONTENTS_SECONDARY_COMMAND_BUFFERS`] specifies that draw calls for the render pass instance
///   will be recorded in secondary command buffers.
/// - [`RESUMING`] specifies that the render pass instance is resuming an earlier suspended render
///   pass instance.
/// - [`SUSPENDING`] specifies that the render pass instance will be suspended.
///The contents of `pRenderingInfo` **must**  match between suspended render
///pass instances and the render pass instances that resume them, other than
///the presence or absence of the [`RESUMING`],
///[`SUSPENDING`], and
///[`CONTENTS_SECONDARY_COMMAND_BUFFERS`] flags.
///No action or synchronization commands, or other render pass instances, are
///allowed between suspending and resuming render pass instances.
///# Related
/// - [`khr_dynamic_rendering`]
/// - [`crate::vulkan1_3`]
/// - [`RenderingFlags`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkRenderingFlags")]
#[derive(Clone, Copy, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(transparent)]
pub struct RenderingFlags(u32);
impl const Default for RenderingFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl From<RenderingFlagBits> for RenderingFlags {
    fn from(from: RenderingFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(from.bits()) }
    }
}
impl RenderingFlags {
    ///[`CONTENTS_SECONDARY_COMMAND_BUFFERS`] specifies that
    ///draw calls for the render pass instance will be recorded in secondary
    ///command buffers.
    pub const CONTENTS_SECONDARY_COMMAND_BUFFERS: Self = Self(1);
    ///[`SUSPENDING`] specifies that the render pass
    ///instance will be suspended.
    pub const SUSPENDING: Self = Self(2);
    ///[`RESUMING`] specifies that the render pass instance
    ///is resuming an earlier suspended render pass instance.
    pub const RESUMING: Self = Self(4);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    #[allow(unused_mut)]
    pub const fn all() -> Self {
        let mut all = Self::empty();
        {
            all |= Self::CONTENTS_SECONDARY_COMMAND_BUFFERS;
        }
        {
            all |= Self::SUSPENDING;
        }
        {
            all |= Self::RESUMING;
        }
        all
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl const std::ops::BitOr for RenderingFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl const std::ops::BitOrAssign for RenderingFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl const std::ops::BitXor for RenderingFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl const std::ops::BitXorAssign for RenderingFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl const std::ops::BitAnd for RenderingFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl const std::ops::BitAndAssign for RenderingFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl const std::ops::Sub for RenderingFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl const std::ops::SubAssign for RenderingFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl const std::ops::Not for RenderingFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl Extend<RenderingFlags> for RenderingFlags {
    fn extend<T: IntoIterator<Item = RenderingFlags>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, i);
        }
    }
}
impl Extend<RenderingFlagBits> for RenderingFlags {
    fn extend<T: IntoIterator<Item = RenderingFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, <Self as From<RenderingFlagBits>>::from(i));
        }
    }
}
impl FromIterator<RenderingFlags> for RenderingFlags {
    fn from_iter<T: IntoIterator<Item = RenderingFlags>>(iterator: T) -> RenderingFlags {
        let mut out = Self::empty();
        <Self as Extend<RenderingFlags>>::extend(&mut out, iterator);
        out
    }
}
impl FromIterator<RenderingFlagBits> for RenderingFlags {
    fn from_iter<T: IntoIterator<Item = RenderingFlagBits>>(iterator: T) -> RenderingFlags {
        let mut out = Self::empty();
        <Self as Extend<RenderingFlagBits>>::extend(&mut out, iterator);
        out
    }
}
impl std::fmt::Debug for RenderingFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(RenderingFlags);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == RenderingFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(RenderingFlags::CONTENTS_SECONDARY_COMMAND_BUFFERS) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(CONTENTS_SECONDARY_COMMAND_BUFFERS))?;
                    }
                    if self.0.contains(RenderingFlags::SUSPENDING) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(SUSPENDING))?;
                    }
                    if self.0.contains(RenderingFlags::RESUMING) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(RESUMING))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(RenderingFlags)).field(&Flags(*self)).finish()
    }
}
///[VkToolPurposeFlagBits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkToolPurposeFlagBits.html) - Bitmask specifying the purposes of an active tool
///# C Specifications
///Bits which  **can**  be set in
///[`PhysicalDeviceToolProperties::purposes`], specifying the
///purposes of an active tool, are:
///```c
///// Provided by VK_VERSION_1_3
///typedef enum VkToolPurposeFlagBits {
///    VK_TOOL_PURPOSE_VALIDATION_BIT = 0x00000001,
///    VK_TOOL_PURPOSE_PROFILING_BIT = 0x00000002,
///    VK_TOOL_PURPOSE_TRACING_BIT = 0x00000004,
///    VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT = 0x00000008,
///    VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT = 0x00000010,
///  // Provided by VK_EXT_debug_report with VK_EXT_tooling_info, VK_EXT_debug_utils with
/// VK_EXT_tooling_info
///    VK_TOOL_PURPOSE_DEBUG_REPORTING_BIT_EXT = 0x00000020,
///  // Provided by VK_EXT_debug_marker with VK_EXT_tooling_info, VK_EXT_debug_utils with
/// VK_EXT_tooling_info
///    VK_TOOL_PURPOSE_DEBUG_MARKERS_BIT_EXT = 0x00000040,
///    VK_TOOL_PURPOSE_VALIDATION_BIT_EXT = VK_TOOL_PURPOSE_VALIDATION_BIT,
///    VK_TOOL_PURPOSE_PROFILING_BIT_EXT = VK_TOOL_PURPOSE_PROFILING_BIT,
///    VK_TOOL_PURPOSE_TRACING_BIT_EXT = VK_TOOL_PURPOSE_TRACING_BIT,
///    VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT_EXT = VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT,
///    VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT_EXT = VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT,
///} VkToolPurposeFlagBits;
///```
///or the equivalent
///```c
///// Provided by VK_EXT_tooling_info
///typedef VkToolPurposeFlagBits VkToolPurposeFlagBitsEXT;
///```
///# Description
/// - [`VALIDATION`] specifies that the tool provides validation of API usage.
/// - [`PROFILING`] specifies that the tool provides profiling of API usage.
/// - [`TRACING`] specifies that the tool is capturing data about the applications API usage,
///   including anything from simple logging to capturing data for later replay.
/// - [`ADDITIONAL_FEATURES`] specifies that the tool provides additional API features/extensions on
///   top of the underlying implementation.
/// - [`MODIFYING_FEATURES`] specifies that the tool modifies the API features/limits/extensions
///   presented to the application.
/// - [`DEBUG_REPORTING_EXT`] specifies that the tool reports additional information to the
///   application via callbacks specified by [`create_debug_report_callback_ext`] or
///   [`create_debug_utils_messenger_ext`]
/// - [`DEBUG_MARKERS_EXT`] specifies that the tool consumes [debug markers](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#debugging-debug-markers)
///   or [object debug annotation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#debugging-object-debug-annotation),
///   [queue labels](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#debugging-queue-labels),
///   or [command buffer labels](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#debugging-command-buffer-labels)
///# Related
/// - [`ext_tooling_info`]
/// - [`crate::vulkan1_3`]
/// - [`ToolPurposeFlags`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkToolPurposeFlags")]
#[derive(Clone, Copy, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(transparent)]
pub struct ToolPurposeFlags(u32);
impl const Default for ToolPurposeFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl From<ToolPurposeFlagBits> for ToolPurposeFlags {
    fn from(from: ToolPurposeFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(from.bits()) }
    }
}
impl ToolPurposeFlags {
    ///[`VALIDATION`] specifies that the tool provides
    ///validation of API usage.
    pub const VALIDATION: Self = Self(1);
    ///[`PROFILING`] specifies that the tool provides
    ///profiling of API usage.
    pub const PROFILING: Self = Self(2);
    ///[`TRACING`] specifies that the tool is capturing
    ///data about the applications API usage, including anything from simple
    ///logging to capturing data for later replay.
    pub const TRACING: Self = Self(4);
    ///[`ADDITIONAL_FEATURES`] specifies that the tool
    ///provides additional API features/extensions on top of the underlying
    ///implementation.
    pub const ADDITIONAL_FEATURES: Self = Self(8);
    ///[`MODIFYING_FEATURES`] specifies that the tool
    ///modifies the API features/limits/extensions presented to the
    ///application.
    pub const MODIFYING_FEATURES: Self = Self(16);
    ///[`DEBUG_REPORTING_EXT`] specifies that the tool
    ///reports additional information to the application via callbacks
    ///specified by
    ///[`create_debug_report_callback_ext`]
    ///or
    ///[`create_debug_utils_messenger_ext`]
    ///
    ///Provided by [`crate::extensions::ext_tooling_info`]
    #[cfg(feature = "VK_EXT_tooling_info")]
    pub const DEBUG_REPORTING_EXT: Self = Self(32);
    ///[`DEBUG_MARKERS_EXT`] specifies that the tool
    ///consumes
    ///[debug markers](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#debugging-debug-markers)
    ///or
    ///[object debug annotation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#debugging-object-debug-annotation),
    ///[queue labels](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#debugging-queue-labels), or
    ///[command buffer labels](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#debugging-command-buffer-labels)
    ///
    ///Provided by [`crate::extensions::ext_tooling_info`]
    #[cfg(feature = "VK_EXT_tooling_info")]
    pub const DEBUG_MARKERS_EXT: Self = Self(64);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    #[allow(unused_mut)]
    pub const fn all() -> Self {
        let mut all = Self::empty();
        {
            all |= Self::VALIDATION;
        }
        {
            all |= Self::PROFILING;
        }
        {
            all |= Self::TRACING;
        }
        {
            all |= Self::ADDITIONAL_FEATURES;
        }
        {
            all |= Self::MODIFYING_FEATURES;
        }
        #[cfg(feature = "VK_EXT_tooling_info")]
        {
            all |= Self::DEBUG_REPORTING_EXT;
        }
        #[cfg(feature = "VK_EXT_tooling_info")]
        {
            all |= Self::DEBUG_MARKERS_EXT;
        }
        all
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl const std::ops::BitOr for ToolPurposeFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl const std::ops::BitOrAssign for ToolPurposeFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl const std::ops::BitXor for ToolPurposeFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl const std::ops::BitXorAssign for ToolPurposeFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl const std::ops::BitAnd for ToolPurposeFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl const std::ops::BitAndAssign for ToolPurposeFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl const std::ops::Sub for ToolPurposeFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl const std::ops::SubAssign for ToolPurposeFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl const std::ops::Not for ToolPurposeFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl Extend<ToolPurposeFlags> for ToolPurposeFlags {
    fn extend<T: IntoIterator<Item = ToolPurposeFlags>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, i);
        }
    }
}
impl Extend<ToolPurposeFlagBits> for ToolPurposeFlags {
    fn extend<T: IntoIterator<Item = ToolPurposeFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, <Self as From<ToolPurposeFlagBits>>::from(i));
        }
    }
}
impl FromIterator<ToolPurposeFlags> for ToolPurposeFlags {
    fn from_iter<T: IntoIterator<Item = ToolPurposeFlags>>(iterator: T) -> ToolPurposeFlags {
        let mut out = Self::empty();
        <Self as Extend<ToolPurposeFlags>>::extend(&mut out, iterator);
        out
    }
}
impl FromIterator<ToolPurposeFlagBits> for ToolPurposeFlags {
    fn from_iter<T: IntoIterator<Item = ToolPurposeFlagBits>>(iterator: T) -> ToolPurposeFlags {
        let mut out = Self::empty();
        <Self as Extend<ToolPurposeFlagBits>>::extend(&mut out, iterator);
        out
    }
}
impl std::fmt::Debug for ToolPurposeFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(ToolPurposeFlags);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == ToolPurposeFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(ToolPurposeFlags::VALIDATION) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(VALIDATION))?;
                    }
                    if self.0.contains(ToolPurposeFlags::PROFILING) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(PROFILING))?;
                    }
                    if self.0.contains(ToolPurposeFlags::TRACING) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(TRACING))?;
                    }
                    if self.0.contains(ToolPurposeFlags::ADDITIONAL_FEATURES) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(ADDITIONAL_FEATURES))?;
                    }
                    if self.0.contains(ToolPurposeFlags::MODIFYING_FEATURES) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(MODIFYING_FEATURES))?;
                    }
                    #[cfg(feature = "VK_EXT_tooling_info")]
                    if self.0.contains(ToolPurposeFlags::DEBUG_REPORTING_EXT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(DEBUG_REPORTING_EXT))?;
                    }
                    #[cfg(feature = "VK_EXT_tooling_info")]
                    if self.0.contains(ToolPurposeFlags::DEBUG_MARKERS_EXT) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(DEBUG_MARKERS_EXT))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(ToolPurposeFlags))
            .field(&Flags(*self))
            .finish()
    }
}
///[VkSubmitFlagBits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSubmitFlagBits.html) - Bitmask specifying behavior of a submission
///# C Specifications
///Bits which  **can**  be set in [`SubmitInfo2::flags`], specifying
///submission behavior, are:
///```c
///// Provided by VK_VERSION_1_3
///typedef enum VkSubmitFlagBits {
///    VK_SUBMIT_PROTECTED_BIT = 0x00000001,
///    VK_SUBMIT_PROTECTED_BIT_KHR = VK_SUBMIT_PROTECTED_BIT,
///} VkSubmitFlagBits;
///```
///or the equivalent
///```c
///// Provided by VK_KHR_synchronization2
///typedef VkSubmitFlagBits VkSubmitFlagBitsKHR;
///```
///# Description
/// - [`PROTECTED`] specifies that this batch is a protected submission.
///# Related
/// - [`khr_synchronization2`]
/// - [`crate::vulkan1_3`]
/// - [`SubmitFlags`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkSubmitFlags")]
#[derive(Clone, Copy, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(transparent)]
pub struct SubmitFlags(u32);
impl const Default for SubmitFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl From<SubmitFlagBits> for SubmitFlags {
    fn from(from: SubmitFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(from.bits()) }
    }
}
impl SubmitFlags {
    ///[`PROTECTED`] specifies that this batch is a protected
    ///submission.
    pub const PROTECTED: Self = Self(1);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    #[allow(unused_mut)]
    pub const fn all() -> Self {
        let mut all = Self::empty();
        {
            all |= Self::PROTECTED;
        }
        all
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl const std::ops::BitOr for SubmitFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl const std::ops::BitOrAssign for SubmitFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl const std::ops::BitXor for SubmitFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl const std::ops::BitXorAssign for SubmitFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl const std::ops::BitAnd for SubmitFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl const std::ops::BitAndAssign for SubmitFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl const std::ops::Sub for SubmitFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl const std::ops::SubAssign for SubmitFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl const std::ops::Not for SubmitFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl Extend<SubmitFlags> for SubmitFlags {
    fn extend<T: IntoIterator<Item = SubmitFlags>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, i);
        }
    }
}
impl Extend<SubmitFlagBits> for SubmitFlags {
    fn extend<T: IntoIterator<Item = SubmitFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            Self::insert(self, <Self as From<SubmitFlagBits>>::from(i));
        }
    }
}
impl FromIterator<SubmitFlags> for SubmitFlags {
    fn from_iter<T: IntoIterator<Item = SubmitFlags>>(iterator: T) -> SubmitFlags {
        let mut out = Self::empty();
        <Self as Extend<SubmitFlags>>::extend(&mut out, iterator);
        out
    }
}
impl FromIterator<SubmitFlagBits> for SubmitFlags {
    fn from_iter<T: IntoIterator<Item = SubmitFlagBits>>(iterator: T) -> SubmitFlags {
        let mut out = Self::empty();
        <Self as Extend<SubmitFlagBits>>::extend(&mut out, iterator);
        out
    }
}
impl std::fmt::Debug for SubmitFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(SubmitFlags);
        impl std::fmt::Debug for Flags {
            #[allow(unused_assignments, unused_mut, unused_variables)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == SubmitFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(SubmitFlags::PROTECTED) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str(stringify!(PROTECTED))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(SubmitFlags)).field(&Flags(*self)).finish()
    }
}
///[VkDevicePrivateDataCreateInfo](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDevicePrivateDataCreateInfo.html) - Reserve private data slots
///# C Specifications
///To reserve private data storage slots, add a
///[`DevicePrivateDataCreateInfo`] structure to the [`p_next`] chain of
///the [`DeviceCreateInfo`] structure.
///Reserving slots in this manner is not strictly necessary, but doing so  **may**
///improve performance.
///```c
///// Provided by VK_VERSION_1_3
///typedef struct VkDevicePrivateDataCreateInfo {
///    VkStructureType    sType;
///    const void*        pNext;
///    uint32_t           privateDataSlotRequestCount;
///} VkDevicePrivateDataCreateInfo;
///```
///or the equivalent
///```c
///// Provided by VK_EXT_private_data
///typedef VkDevicePrivateDataCreateInfo VkDevicePrivateDataCreateInfoEXT;
///```
///# Members
/// - [`s_type`] is the type of this structure.
/// - [`p_next`] is `NULL` or a pointer to a structure extending this structure.
/// - [`private_data_slot_request_count`] is the amount of slots to reserve.
///# Description
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be `VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO`
///# Related
/// - [`ext_private_data`]
/// - [`crate::vulkan1_3`]
/// - [`StructureType`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkDevicePrivateDataCreateInfo")]
#[derive(Debug, Clone, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[repr(C)]
pub struct DevicePrivateDataCreateInfo<'lt> {
    ///Lifetime field
    pub _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] is the type of this structure.
    pub s_type: StructureType,
    ///[`p_next`] is `NULL` or a pointer to a structure extending this
    ///structure.
    pub p_next: *const BaseInStructure<'lt>,
    ///[`private_data_slot_request_count`] is the amount of slots to reserve.
    pub private_data_slot_request_count: u32,
}
impl<'lt> Default for DevicePrivateDataCreateInfo<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: StructureType::DEVICE_PRIVATE_DATA_CREATE_INFO,
            p_next: std::ptr::null(),
            private_data_slot_request_count: 0,
        }
    }
}
impl<'lt> DevicePrivateDataCreateInfo<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *const BaseInStructure<'lt> {
        self.p_next
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *const BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn with_p_next_raw(mut self, value: *const BaseInStructure<'lt>) -> Self {
        self.p_next = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseInStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::private_data_slot_request_count`]
    pub fn private_data_slot_request_count(&self) -> u32 {
        self.private_data_slot_request_count
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::private_data_slot_request_count`]
    pub fn private_data_slot_request_count_mut(&mut self) -> &mut u32 {
        &mut self.private_data_slot_request_count
    }
    ///Sets the value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the value of [`Self::private_data_slot_request_count`]
    pub fn set_private_data_slot_request_count(&mut self, value: u32) -> &mut Self {
        self.private_data_slot_request_count = value;
        self
    }
    ///Sets the value of [`Self::s_type`]
    pub fn with_s_type(mut self, value: crate::vulkan1_0::StructureType) -> Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn with_p_next(mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the value of [`Self::private_data_slot_request_count`]
    pub fn with_private_data_slot_request_count(mut self, value: u32) -> Self {
        self.private_data_slot_request_count = value;
        self
    }
}
///[VkPrivateDataSlotCreateInfo](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPrivateDataSlotCreateInfo.html) - Structure specifying the parameters of private data slot construction
///# C Specifications
///The [`PrivateDataSlotCreateInfo`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_3
///typedef struct VkPrivateDataSlotCreateInfo {
///    VkStructureType                 sType;
///    const void*                     pNext;
///    VkPrivateDataSlotCreateFlags    flags;
///} VkPrivateDataSlotCreateInfo;
///```
///or the equivalent
///```c
///// Provided by VK_EXT_private_data
///typedef VkPrivateDataSlotCreateInfo VkPrivateDataSlotCreateInfoEXT;
///```
///# Members
/// - [`s_type`] is the type of this structure.
/// - [`p_next`] is `NULL` or a pointer to a structure extending this structure.
/// - [`flags`] is reserved for future use.
///# Description
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be `VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO`
/// - [`p_next`] **must**  be `NULL`
/// - [`flags`] **must**  be `0`
///# Related
/// - [`ext_private_data`]
/// - [`crate::vulkan1_3`]
/// - [`PrivateDataSlotCreateFlags`]
/// - [`StructureType`]
/// - [`create_private_data_slot`]
/// - [`create_private_data_slot_ext`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkPrivateDataSlotCreateInfo")]
#[derive(Debug, Clone, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[repr(C)]
pub struct PrivateDataSlotCreateInfo<'lt> {
    ///Lifetime field
    pub _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] is the type of this structure.
    pub s_type: StructureType,
    ///[`p_next`] is `NULL` or a pointer to a structure extending this
    ///structure.
    pub p_next: *const BaseInStructure<'lt>,
    ///[`flags`] is reserved for future use.
    pub flags: PrivateDataSlotCreateFlags,
}
impl<'lt> Default for PrivateDataSlotCreateInfo<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: StructureType::PRIVATE_DATA_SLOT_CREATE_INFO,
            p_next: std::ptr::null(),
            flags: Default::default(),
        }
    }
}
impl<'lt> PrivateDataSlotCreateInfo<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *const BaseInStructure<'lt> {
        self.p_next
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *const BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn with_p_next_raw(mut self, value: *const BaseInStructure<'lt>) -> Self {
        self.p_next = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseInStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::flags`]
    pub fn flags(&self) -> PrivateDataSlotCreateFlags {
        self.flags
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::flags`]
    pub fn flags_mut(&mut self) -> &mut PrivateDataSlotCreateFlags {
        &mut self.flags
    }
    ///Sets the value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the value of [`Self::flags`]
    pub fn set_flags(&mut self, value: crate::vulkan1_3::PrivateDataSlotCreateFlags) -> &mut Self {
        self.flags = value;
        self
    }
    ///Sets the value of [`Self::s_type`]
    pub fn with_s_type(mut self, value: crate::vulkan1_0::StructureType) -> Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn with_p_next(mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the value of [`Self::flags`]
    pub fn with_flags(mut self, value: crate::vulkan1_3::PrivateDataSlotCreateFlags) -> Self {
        self.flags = value;
        self
    }
}
///[VkPhysicalDevicePrivateDataFeatures](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePrivateDataFeatures.html) - Structure specifying physical device support
///# C Specifications
///The [`PhysicalDevicePrivateDataFeatures`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_3
///typedef struct VkPhysicalDevicePrivateDataFeatures {
///    VkStructureType    sType;
///    void*              pNext;
///    VkBool32           privateData;
///} VkPhysicalDevicePrivateDataFeatures;
///```
///or the equivalent
///```c
///// Provided by VK_EXT_private_data
///typedef VkPhysicalDevicePrivateDataFeatures VkPhysicalDevicePrivateDataFeaturesEXT;
///```
///# Members
///This structure describes the following feature:
///# Description
/// - [`s_type`] is the type of this structure.
/// - [`p_next`] is `NULL` or a pointer to a structure extending this structure.
///
/// - [`private_data`] indicates whether the implementation supports private data. See [Private Data](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#private-data).
///If the [`PhysicalDevicePrivateDataFeatures`] structure is included in the [`p_next`] chain of
/// the
///[`PhysicalDeviceFeatures2`] structure passed to
///[`get_physical_device_features2`], it is filled in to indicate whether each
///corresponding feature is supported.
///[`PhysicalDevicePrivateDataFeatures`] **can**  also be used in the [`p_next`] chain of
///[`DeviceCreateInfo`] to selectively enable these features.
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be `VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES`
///# Related
/// - [`ext_private_data`]
/// - [`crate::vulkan1_3`]
/// - [`Bool32`]
/// - [`StructureType`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkPhysicalDevicePrivateDataFeatures")]
#[derive(Debug, Clone, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[repr(C)]
pub struct PhysicalDevicePrivateDataFeatures<'lt> {
    ///Lifetime field
    pub _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] is the type of this structure.
    pub s_type: StructureType,
    ///[`p_next`] is `NULL` or a pointer to a structure extending this
    ///structure.
    pub p_next: *mut BaseOutStructure<'lt>,
    ///[`private_data`] indicates
    ///whether the implementation supports private data.
    ///See [Private Data](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#private-data).
    pub private_data: Bool32,
}
impl<'lt> Default for PhysicalDevicePrivateDataFeatures<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: StructureType::PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES,
            p_next: std::ptr::null_mut(),
            private_data: 0,
        }
    }
}
impl<'lt> PhysicalDevicePrivateDataFeatures<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *mut BaseOutStructure<'lt> {
        self.p_next
    }
    ///Gets the raw value of [`Self::private_data`]
    pub fn private_data_raw(&self) -> Bool32 {
        self.private_data
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *mut BaseOutStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::private_data`]
    pub fn set_private_data_raw(&mut self, value: Bool32) -> &mut Self {
        self.private_data = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn with_p_next_raw(mut self, value: *mut BaseOutStructure<'lt>) -> Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::private_data`]
    pub fn with_private_data_raw(mut self, value: Bool32) -> Self {
        self.private_data = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseOutStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::private_data`]
    pub fn private_data(&self) -> bool {
        unsafe { std::mem::transmute(self.private_data as u8) }
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next_mut(&mut self) -> &mut BaseOutStructure<'lt> {
        &mut *self.p_next
    }
    ///Gets a mutable reference to the value of [`Self::private_data`]
    pub fn private_data_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.private_data as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.private_data as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Sets the value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt mut crate::vulkan1_0::BaseOutStructure<'lt>) -> &mut Self {
        self.p_next = value as *mut _;
        self
    }
    ///Sets the value of [`Self::private_data`]
    pub fn set_private_data(&mut self, value: bool) -> &mut Self {
        self.private_data = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::s_type`]
    pub fn with_s_type(mut self, value: crate::vulkan1_0::StructureType) -> Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn with_p_next(mut self, value: &'lt mut crate::vulkan1_0::BaseOutStructure<'lt>) -> Self {
        self.p_next = value as *mut _;
        self
    }
    ///Sets the value of [`Self::private_data`]
    pub fn with_private_data(mut self, value: bool) -> Self {
        self.private_data = value as u8 as u32;
        self
    }
}
///[VkDeviceBufferMemoryRequirements](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceBufferMemoryRequirements.html) - (None)
///# C Specifications
///The [`DeviceBufferMemoryRequirements`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_3
///typedef struct VkDeviceBufferMemoryRequirements {
///    VkStructureType              sType;
///    const void*                  pNext;
///    const VkBufferCreateInfo*    pCreateInfo;
///} VkDeviceBufferMemoryRequirements;
///```
///or the equivalent
///```c
///// Provided by VK_KHR_maintenance4
///typedef VkDeviceBufferMemoryRequirements VkDeviceBufferMemoryRequirementsKHR;
///```
///# Members
/// - [`s_type`] is the type of this structure.
/// - [`p_next`] is `NULL` or a pointer to a structure extending this structure.
/// - [`create_info`] is a pointer to a [`BufferCreateInfo`] structure containing parameters
///   affecting creation of the buffer to query.
///# Description
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be `VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS`
/// - [`p_next`] **must**  be `NULL`
/// - [`create_info`] **must**  be a valid pointer to a valid [`BufferCreateInfo`] structure
///# Related
/// - [`khr_maintenance4`]
/// - [`crate::vulkan1_3`]
/// - [`BufferCreateInfo`]
/// - [`StructureType`]
/// - [`get_device_buffer_memory_requirements`]
/// - [`get_device_buffer_memory_requirements_khr`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkDeviceBufferMemoryRequirements")]
#[derive(Debug, Clone, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[repr(C)]
pub struct DeviceBufferMemoryRequirements<'lt> {
    ///Lifetime field
    pub _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] is the type of this structure.
    pub s_type: StructureType,
    ///[`p_next`] is `NULL` or a pointer to a structure extending this
    ///structure.
    pub p_next: *const BaseInStructure<'lt>,
    ///[`create_info`] is a pointer to a [`BufferCreateInfo`] structure
    ///containing parameters affecting creation of the buffer to query.
    pub create_info: *const BufferCreateInfo<'lt>,
}
impl<'lt> Default for DeviceBufferMemoryRequirements<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: StructureType::DEVICE_BUFFER_MEMORY_REQUIREMENTS,
            p_next: std::ptr::null(),
            create_info: std::ptr::null(),
        }
    }
}
impl<'lt> DeviceBufferMemoryRequirements<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *const BaseInStructure<'lt> {
        self.p_next
    }
    ///Gets the raw value of [`Self::create_info`]
    pub fn create_info_raw(&self) -> *const BufferCreateInfo<'lt> {
        self.create_info
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *const BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::create_info`]
    pub fn set_create_info_raw(&mut self, value: *const BufferCreateInfo<'lt>) -> &mut Self {
        self.create_info = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn with_p_next_raw(mut self, value: *const BaseInStructure<'lt>) -> Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::create_info`]
    pub fn with_create_info_raw(mut self, value: *const BufferCreateInfo<'lt>) -> Self {
        self.create_info = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseInStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::create_info`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn create_info(&self) -> &BufferCreateInfo<'lt> {
        &*self.create_info
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Sets the value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the value of [`Self::create_info`]
    pub fn set_create_info(&mut self, value: &'lt crate::vulkan1_0::BufferCreateInfo<'lt>) -> &mut Self {
        self.create_info = value as *const _;
        self
    }
    ///Sets the value of [`Self::s_type`]
    pub fn with_s_type(mut self, value: crate::vulkan1_0::StructureType) -> Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn with_p_next(mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the value of [`Self::create_info`]
    pub fn with_create_info(mut self, value: &'lt crate::vulkan1_0::BufferCreateInfo<'lt>) -> Self {
        self.create_info = value as *const _;
        self
    }
}
///[VkDeviceImageMemoryRequirements](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceImageMemoryRequirements.html) - (None)
///# C Specifications
///The [`DeviceImageMemoryRequirements`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_3
///typedef struct VkDeviceImageMemoryRequirements {
///    VkStructureType             sType;
///    const void*                 pNext;
///    const VkImageCreateInfo*    pCreateInfo;
///    VkImageAspectFlagBits       planeAspect;
///} VkDeviceImageMemoryRequirements;
///```
///or the equivalent
///```c
///// Provided by VK_KHR_maintenance4
///typedef VkDeviceImageMemoryRequirements VkDeviceImageMemoryRequirementsKHR;
///```
///# Members
/// - [`s_type`] is the type of this structure.
/// - [`p_next`] is `NULL` or a pointer to a structure extending this structure.
/// - [`create_info`] is a pointer to a [`ImageCreateInfo`] structure containing parameters
///   affecting creation of the image to query.
/// - [`plane_aspect`] is a [`ImageAspectFlagBits`] value specifying the aspect corresponding to the
///   image plane to query. This parameter is ignored unless [`create_info`]`::tiling` is
///   `VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT`, or [`create_info`]`::flags` has
///   `VK_IMAGE_CREATE_DISJOINT_BIT` set.
///# Description
///## Valid Usage
/// - The [`create_info`]::[`p_next`] chain  **must**  not contain a [`ImageSwapchainCreateInfoKHR`]
///   structure
/// - If [`create_info`]`::format` specifies a *multi-planar* format and [`create_info`]`::flags`
///   has `VK_IMAGE_CREATE_DISJOINT_BIT` set then [`plane_aspect`] **must**  not be
///   `VK_IMAGE_ASPECT_NONE_KHR`
/// - If [`create_info`]`::flags` has `VK_IMAGE_CREATE_DISJOINT_BIT` set and if the
///   [`create_info`]`::tiling` is `VK_IMAGE_TILING_LINEAR` or `VK_IMAGE_TILING_OPTIMAL`, then
///   [`plane_aspect`] **must**  be a single valid *format plane* for the image (that is, for a
///   two-plane image [`plane_aspect`] **must**  be `VK_IMAGE_ASPECT_PLANE_0_BIT` or
///   `VK_IMAGE_ASPECT_PLANE_1_BIT`, and for a three-plane image [`plane_aspect`] **must**  be
///   `VK_IMAGE_ASPECT_PLANE_0_BIT`, `VK_IMAGE_ASPECT_PLANE_1_BIT` or `VK_IMAGE_ASPECT_PLANE_2_BIT`)
/// - If [`create_info`]`::tiling` is `VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT`, then
///   [`plane_aspect`] **must**  be a single valid *memory plane* for the image (that is,
///   `aspectMask` **must**  specify a plane index that is less than the
///   [`DrmFormatModifierPropertiesEXT::drm_format_modifier_plane_count`] associated with the
///   images `format` and [`ImageDrmFormatModifierPropertiesEXT::drm_format_modifier`])
///
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be `VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS`
/// - [`p_next`] **must**  be `NULL`
/// - [`create_info`] **must**  be a valid pointer to a valid [`ImageCreateInfo`] structure
/// - If [`plane_aspect`] is not `0`, [`plane_aspect`] **must**  be a valid [`ImageAspectFlagBits`]
///   value
///# Related
/// - [`khr_maintenance4`]
/// - [`crate::vulkan1_3`]
/// - [`ImageAspectFlagBits`]
/// - [`ImageCreateInfo`]
/// - [`StructureType`]
/// - [`get_device_image_memory_requirements`]
/// - [`get_device_image_memory_requirements_khr`]
/// - [`get_device_image_sparse_memory_requirements`]
/// - [`get_device_image_sparse_memory_requirements_khr`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkDeviceImageMemoryRequirements")]
#[derive(Debug, Clone, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[repr(C)]
pub struct DeviceImageMemoryRequirements<'lt> {
    ///Lifetime field
    pub _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] is the type of this structure.
    pub s_type: StructureType,
    ///[`p_next`] is `NULL` or a pointer to a structure extending this
    ///structure.
    pub p_next: *const BaseInStructure<'lt>,
    ///[`create_info`] is a pointer to a [`ImageCreateInfo`] structure
    ///containing parameters affecting creation of the image to query.
    pub create_info: *const ImageCreateInfo<'lt>,
    ///[`plane_aspect`] is a [`ImageAspectFlagBits`] value specifying the
    ///aspect corresponding to the image plane to query.
    ///This parameter is ignored unless
    ///[`create_info`]::`tiling` is
    ///`VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT`, or
    ///[`create_info`]::`flags` has `VK_IMAGE_CREATE_DISJOINT_BIT`
    ///set.
    pub plane_aspect: ImageAspectFlagBits,
}
impl<'lt> Default for DeviceImageMemoryRequirements<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: StructureType::DEVICE_IMAGE_MEMORY_REQUIREMENTS,
            p_next: std::ptr::null(),
            create_info: std::ptr::null(),
            plane_aspect: Default::default(),
        }
    }
}
impl<'lt> DeviceImageMemoryRequirements<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *const BaseInStructure<'lt> {
        self.p_next
    }
    ///Gets the raw value of [`Self::create_info`]
    pub fn create_info_raw(&self) -> *const ImageCreateInfo<'lt> {
        self.create_info
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *const BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::create_info`]
    pub fn set_create_info_raw(&mut self, value: *const ImageCreateInfo<'lt>) -> &mut Self {
        self.create_info = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn with_p_next_raw(mut self, value: *const BaseInStructure<'lt>) -> Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::create_info`]
    pub fn with_create_info_raw(mut self, value: *const ImageCreateInfo<'lt>) -> Self {
        self.create_info = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseInStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::create_info`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn create_info(&self) -> &ImageCreateInfo<'lt> {
        &*self.create_info
    }
    ///Gets the value of [`Self::plane_aspect`]
    pub fn plane_aspect(&self) -> ImageAspectFlagBits {
        self.plane_aspect
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::plane_aspect`]
    pub fn plane_aspect_mut(&mut self) -> &mut ImageAspectFlagBits {
        &mut self.plane_aspect
    }
    ///Sets the value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the value of [`Self::create_info`]
    pub fn set_create_info(&mut self, value: &'lt crate::vulkan1_0::ImageCreateInfo<'lt>) -> &mut Self {
        self.create_info = value as *const _;
        self
    }
    ///Sets the value of [`Self::plane_aspect`]
    pub fn set_plane_aspect(&mut self, value: crate::vulkan1_0::ImageAspectFlagBits) -> &mut Self {
        self.plane_aspect = value;
        self
    }
    ///Sets the value of [`Self::s_type`]
    pub fn with_s_type(mut self, value: crate::vulkan1_0::StructureType) -> Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn with_p_next(mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the value of [`Self::create_info`]
    pub fn with_create_info(mut self, value: &'lt crate::vulkan1_0::ImageCreateInfo<'lt>) -> Self {
        self.create_info = value as *const _;
        self
    }
    ///Sets the value of [`Self::plane_aspect`]
    pub fn with_plane_aspect(mut self, value: crate::vulkan1_0::ImageAspectFlagBits) -> Self {
        self.plane_aspect = value;
        self
    }
}
///[VkPhysicalDeviceInlineUniformBlockFeatures](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceInlineUniformBlockFeatures.html) - Structure describing inline uniform block features that can be supported by an implementation
///# C Specifications
///The [`PhysicalDeviceInlineUniformBlockFeatures`] structure is defined
///as:
///```c
///// Provided by VK_VERSION_1_3
///typedef struct VkPhysicalDeviceInlineUniformBlockFeatures {
///    VkStructureType    sType;
///    void*              pNext;
///    VkBool32           inlineUniformBlock;
///    VkBool32           descriptorBindingInlineUniformBlockUpdateAfterBind;
///} VkPhysicalDeviceInlineUniformBlockFeatures;
///```
///or the equivalent
///```c
///// Provided by VK_EXT_inline_uniform_block
///typedef VkPhysicalDeviceInlineUniformBlockFeatures
/// VkPhysicalDeviceInlineUniformBlockFeaturesEXT;
///```
///# Members
///This structure describes the following features:
///# Description
/// - [`s_type`] is the type of this structure.
/// - [`p_next`] is `NULL` or a pointer to a structure extending this structure.
///
/// - [`inline_uniform_block`] indicates whether the implementation supports inline uniform block
///   descriptors. If this feature is not enabled, `VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK`
///   **must**  not be used.
/// - [`descriptor_binding_inline_uniform_block_update_after_bind`] indicates whether the
///   implementation supports updating inline uniform block descriptors after a set is bound. If
///   this feature is not enabled, `VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT` **must**  not be
///   used with `VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK`.
///If the [`PhysicalDeviceInlineUniformBlockFeatures`] structure is included in the [`p_next`]
/// chain of the
///[`PhysicalDeviceFeatures2`] structure passed to
///[`get_physical_device_features2`], it is filled in to indicate whether each
///corresponding feature is supported.
///[`PhysicalDeviceInlineUniformBlockFeatures`] **can**  also be used in the [`p_next`] chain of
///[`DeviceCreateInfo`] to selectively enable these features.
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be `VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES`
///# Related
/// - [`ext_inline_uniform_block`]
/// - [`crate::vulkan1_3`]
/// - [`Bool32`]
/// - [`StructureType`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkPhysicalDeviceInlineUniformBlockFeatures")]
#[derive(Debug, Clone, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[repr(C)]
pub struct PhysicalDeviceInlineUniformBlockFeatures<'lt> {
    ///Lifetime field
    pub _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] is the type of this structure.
    pub s_type: StructureType,
    ///[`p_next`] is `NULL` or a pointer to a structure extending this
    ///structure.
    pub p_next: *mut BaseOutStructure<'lt>,
    ///[`inline_uniform_block`]
    ///indicates whether the implementation supports inline uniform block
    ///descriptors.
    ///If this feature is not enabled,
    ///`VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK` **must**  not be used.
    pub inline_uniform_block: Bool32,
    ///[`descriptor_binding_inline_uniform_block_update_after_bind`]
    ///indicates whether the implementation supports updating inline uniform
    ///block descriptors after a set is bound.
    ///If this feature is not enabled,
    ///`VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT` **must**  not be used with
    ///`VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK`.
    pub descriptor_binding_inline_uniform_block_update_after_bind: Bool32,
}
impl<'lt> Default for PhysicalDeviceInlineUniformBlockFeatures<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: StructureType::PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES,
            p_next: std::ptr::null_mut(),
            inline_uniform_block: 0,
            descriptor_binding_inline_uniform_block_update_after_bind: 0,
        }
    }
}
impl<'lt> PhysicalDeviceInlineUniformBlockFeatures<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *mut BaseOutStructure<'lt> {
        self.p_next
    }
    ///Gets the raw value of [`Self::inline_uniform_block`]
    pub fn inline_uniform_block_raw(&self) -> Bool32 {
        self.inline_uniform_block
    }
    ///Gets the raw value of [`Self::descriptor_binding_inline_uniform_block_update_after_bind`]
    pub fn descriptor_binding_inline_uniform_block_update_after_bind_raw(&self) -> Bool32 {
        self.descriptor_binding_inline_uniform_block_update_after_bind
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *mut BaseOutStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::inline_uniform_block`]
    pub fn set_inline_uniform_block_raw(&mut self, value: Bool32) -> &mut Self {
        self.inline_uniform_block = value;
        self
    }
    ///Sets the raw value of [`Self::descriptor_binding_inline_uniform_block_update_after_bind`]
    pub fn set_descriptor_binding_inline_uniform_block_update_after_bind_raw(&mut self, value: Bool32) -> &mut Self {
        self.descriptor_binding_inline_uniform_block_update_after_bind = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn with_p_next_raw(mut self, value: *mut BaseOutStructure<'lt>) -> Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::inline_uniform_block`]
    pub fn with_inline_uniform_block_raw(mut self, value: Bool32) -> Self {
        self.inline_uniform_block = value;
        self
    }
    ///Sets the raw value of [`Self::descriptor_binding_inline_uniform_block_update_after_bind`]
    pub fn with_descriptor_binding_inline_uniform_block_update_after_bind_raw(mut self, value: Bool32) -> Self {
        self.descriptor_binding_inline_uniform_block_update_after_bind = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseOutStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::inline_uniform_block`]
    pub fn inline_uniform_block(&self) -> bool {
        unsafe { std::mem::transmute(self.inline_uniform_block as u8) }
    }
    ///Gets the value of [`Self::descriptor_binding_inline_uniform_block_update_after_bind`]
    pub fn descriptor_binding_inline_uniform_block_update_after_bind(&self) -> bool {
        unsafe { std::mem::transmute(self.descriptor_binding_inline_uniform_block_update_after_bind as u8) }
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next_mut(&mut self) -> &mut BaseOutStructure<'lt> {
        &mut *self.p_next
    }
    ///Gets a mutable reference to the value of [`Self::inline_uniform_block`]
    pub fn inline_uniform_block_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.inline_uniform_block as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.inline_uniform_block as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of
    /// [`Self::descriptor_binding_inline_uniform_block_update_after_bind`]
    pub fn descriptor_binding_inline_uniform_block_update_after_bind_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.descriptor_binding_inline_uniform_block_update_after_bind as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.descriptor_binding_inline_uniform_block_update_after_bind as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Sets the value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt mut crate::vulkan1_0::BaseOutStructure<'lt>) -> &mut Self {
        self.p_next = value as *mut _;
        self
    }
    ///Sets the value of [`Self::inline_uniform_block`]
    pub fn set_inline_uniform_block(&mut self, value: bool) -> &mut Self {
        self.inline_uniform_block = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::descriptor_binding_inline_uniform_block_update_after_bind`]
    pub fn set_descriptor_binding_inline_uniform_block_update_after_bind(&mut self, value: bool) -> &mut Self {
        self.descriptor_binding_inline_uniform_block_update_after_bind = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::s_type`]
    pub fn with_s_type(mut self, value: crate::vulkan1_0::StructureType) -> Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn with_p_next(mut self, value: &'lt mut crate::vulkan1_0::BaseOutStructure<'lt>) -> Self {
        self.p_next = value as *mut _;
        self
    }
    ///Sets the value of [`Self::inline_uniform_block`]
    pub fn with_inline_uniform_block(mut self, value: bool) -> Self {
        self.inline_uniform_block = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::descriptor_binding_inline_uniform_block_update_after_bind`]
    pub fn with_descriptor_binding_inline_uniform_block_update_after_bind(mut self, value: bool) -> Self {
        self.descriptor_binding_inline_uniform_block_update_after_bind = value as u8 as u32;
        self
    }
}
///[VkPhysicalDeviceInlineUniformBlockProperties](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceInlineUniformBlockProperties.html) - Structure describing inline uniform block properties that can be supported by an implementation
///# C Specifications
///The [`PhysicalDeviceInlineUniformBlockProperties`] structure is defined
///as:
///```c
///// Provided by VK_VERSION_1_3
///typedef struct VkPhysicalDeviceInlineUniformBlockProperties {
///    VkStructureType    sType;
///    void*              pNext;
///    uint32_t           maxInlineUniformBlockSize;
///    uint32_t           maxPerStageDescriptorInlineUniformBlocks;
///    uint32_t           maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks;
///    uint32_t           maxDescriptorSetInlineUniformBlocks;
///    uint32_t           maxDescriptorSetUpdateAfterBindInlineUniformBlocks;
///} VkPhysicalDeviceInlineUniformBlockProperties;
///```
///or the equivalent
///```c
///// Provided by VK_EXT_inline_uniform_block
///typedef VkPhysicalDeviceInlineUniformBlockProperties
/// VkPhysicalDeviceInlineUniformBlockPropertiesEXT;
///```
///# Members
/// - [`s_type`] is the type of this structure.
/// - [`p_next`] is `NULL` or a pointer to a structure extending this structure.
///# Description
/// - [`max_inline_uniform_block_size`] is the maximum size in bytes of an [inline uniform block](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-inlineuniformblock)
///   binding.
/// - `maxPerStageDescriptorInlineUniformBlock` is the maximum number of inline uniform block
///   bindings that  **can**  be accessible to a single shader stage in a pipeline layout.
///   Descriptor bindings with a descriptor type of `VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK` count
///   against this limit. Only descriptor bindings in descriptor set layouts created without the
///   `VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT` bit set count against this limit.
/// - [`max_per_stage_descriptor_update_after_bind_inline_uniform_blocks`] is similar to
///   [`max_per_stage_descriptor_inline_uniform_blocks`] but counts descriptor bindings from
///   descriptor sets created with or without the
///   `VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT` bit set.
/// - [`max_descriptor_set_inline_uniform_blocks`] is the maximum number of inline uniform block
///   bindings that  **can**  be included in descriptor bindings in a pipeline layout across all
///   pipeline shader stages and descriptor set numbers. Descriptor bindings with a descriptor type
///   of `VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK` count against this limit. Only descriptor
///   bindings in descriptor set layouts created without the
///   `VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT` bit set count against this limit.
/// - [`max_descriptor_set_update_after_bind_inline_uniform_blocks`] is similar to
///   [`max_descriptor_set_inline_uniform_blocks`] but counts descriptor bindings from descriptor
///   sets created with or without the `VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT`
///   bit set.
///If the [`PhysicalDeviceInlineUniformBlockProperties`] structure is included in the [`p_next`]
/// chain of the
///[`PhysicalDeviceProperties2`] structure passed to
///[`get_physical_device_properties2`], it is filled in with each
///corresponding implementation-dependent property.
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be `VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES`
///# Related
/// - [`ext_inline_uniform_block`]
/// - [`crate::vulkan1_3`]
/// - [`StructureType`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkPhysicalDeviceInlineUniformBlockProperties")]
#[derive(Debug, Clone, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[repr(C)]
pub struct PhysicalDeviceInlineUniformBlockProperties<'lt> {
    ///Lifetime field
    pub _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] is the type of this structure.
    pub s_type: StructureType,
    ///[`p_next`] is `NULL` or a pointer to a structure extending this
    ///structure.
    pub p_next: *mut BaseOutStructure<'lt>,
    ///No documentation found
    pub max_inline_uniform_block_size: u32,
    ///No documentation found
    pub max_per_stage_descriptor_inline_uniform_blocks: u32,
    ///No documentation found
    pub max_per_stage_descriptor_update_after_bind_inline_uniform_blocks: u32,
    ///No documentation found
    pub max_descriptor_set_inline_uniform_blocks: u32,
    ///No documentation found
    pub max_descriptor_set_update_after_bind_inline_uniform_blocks: u32,
}
impl<'lt> Default for PhysicalDeviceInlineUniformBlockProperties<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: StructureType::PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES,
            p_next: std::ptr::null_mut(),
            max_inline_uniform_block_size: 0,
            max_per_stage_descriptor_inline_uniform_blocks: 0,
            max_per_stage_descriptor_update_after_bind_inline_uniform_blocks: 0,
            max_descriptor_set_inline_uniform_blocks: 0,
            max_descriptor_set_update_after_bind_inline_uniform_blocks: 0,
        }
    }
}
impl<'lt> PhysicalDeviceInlineUniformBlockProperties<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *mut BaseOutStructure<'lt> {
        self.p_next
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *mut BaseOutStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn with_p_next_raw(mut self, value: *mut BaseOutStructure<'lt>) -> Self {
        self.p_next = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseOutStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::max_inline_uniform_block_size`]
    pub fn max_inline_uniform_block_size(&self) -> u32 {
        self.max_inline_uniform_block_size
    }
    ///Gets the value of [`Self::max_per_stage_descriptor_inline_uniform_blocks`]
    pub fn max_per_stage_descriptor_inline_uniform_blocks(&self) -> u32 {
        self.max_per_stage_descriptor_inline_uniform_blocks
    }
    ///Gets the value of [`Self::max_per_stage_descriptor_update_after_bind_inline_uniform_blocks`]
    pub fn max_per_stage_descriptor_update_after_bind_inline_uniform_blocks(&self) -> u32 {
        self.max_per_stage_descriptor_update_after_bind_inline_uniform_blocks
    }
    ///Gets the value of [`Self::max_descriptor_set_inline_uniform_blocks`]
    pub fn max_descriptor_set_inline_uniform_blocks(&self) -> u32 {
        self.max_descriptor_set_inline_uniform_blocks
    }
    ///Gets the value of [`Self::max_descriptor_set_update_after_bind_inline_uniform_blocks`]
    pub fn max_descriptor_set_update_after_bind_inline_uniform_blocks(&self) -> u32 {
        self.max_descriptor_set_update_after_bind_inline_uniform_blocks
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next_mut(&mut self) -> &mut BaseOutStructure<'lt> {
        &mut *self.p_next
    }
    ///Gets a mutable reference to the value of [`Self::max_inline_uniform_block_size`]
    pub fn max_inline_uniform_block_size_mut(&mut self) -> &mut u32 {
        &mut self.max_inline_uniform_block_size
    }
    ///Gets a mutable reference to the value of
    /// [`Self::max_per_stage_descriptor_inline_uniform_blocks`]
    pub fn max_per_stage_descriptor_inline_uniform_blocks_mut(&mut self) -> &mut u32 {
        &mut self.max_per_stage_descriptor_inline_uniform_blocks
    }
    ///Gets a mutable reference to the value of
    /// [`Self::max_per_stage_descriptor_update_after_bind_inline_uniform_blocks`]
    pub fn max_per_stage_descriptor_update_after_bind_inline_uniform_blocks_mut(&mut self) -> &mut u32 {
        &mut self.max_per_stage_descriptor_update_after_bind_inline_uniform_blocks
    }
    ///Gets a mutable reference to the value of [`Self::max_descriptor_set_inline_uniform_blocks`]
    pub fn max_descriptor_set_inline_uniform_blocks_mut(&mut self) -> &mut u32 {
        &mut self.max_descriptor_set_inline_uniform_blocks
    }
    ///Gets a mutable reference to the value of
    /// [`Self::max_descriptor_set_update_after_bind_inline_uniform_blocks`]
    pub fn max_descriptor_set_update_after_bind_inline_uniform_blocks_mut(&mut self) -> &mut u32 {
        &mut self.max_descriptor_set_update_after_bind_inline_uniform_blocks
    }
    ///Sets the value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt mut crate::vulkan1_0::BaseOutStructure<'lt>) -> &mut Self {
        self.p_next = value as *mut _;
        self
    }
    ///Sets the value of [`Self::max_inline_uniform_block_size`]
    pub fn set_max_inline_uniform_block_size(&mut self, value: u32) -> &mut Self {
        self.max_inline_uniform_block_size = value;
        self
    }
    ///Sets the value of [`Self::max_per_stage_descriptor_inline_uniform_blocks`]
    pub fn set_max_per_stage_descriptor_inline_uniform_blocks(&mut self, value: u32) -> &mut Self {
        self.max_per_stage_descriptor_inline_uniform_blocks = value;
        self
    }
    ///Sets the value of [`Self::max_per_stage_descriptor_update_after_bind_inline_uniform_blocks`]
    pub fn set_max_per_stage_descriptor_update_after_bind_inline_uniform_blocks(&mut self, value: u32) -> &mut Self {
        self.max_per_stage_descriptor_update_after_bind_inline_uniform_blocks = value;
        self
    }
    ///Sets the value of [`Self::max_descriptor_set_inline_uniform_blocks`]
    pub fn set_max_descriptor_set_inline_uniform_blocks(&mut self, value: u32) -> &mut Self {
        self.max_descriptor_set_inline_uniform_blocks = value;
        self
    }
    ///Sets the value of [`Self::max_descriptor_set_update_after_bind_inline_uniform_blocks`]
    pub fn set_max_descriptor_set_update_after_bind_inline_uniform_blocks(&mut self, value: u32) -> &mut Self {
        self.max_descriptor_set_update_after_bind_inline_uniform_blocks = value;
        self
    }
    ///Sets the value of [`Self::s_type`]
    pub fn with_s_type(mut self, value: crate::vulkan1_0::StructureType) -> Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn with_p_next(mut self, value: &'lt mut crate::vulkan1_0::BaseOutStructure<'lt>) -> Self {
        self.p_next = value as *mut _;
        self
    }
    ///Sets the value of [`Self::max_inline_uniform_block_size`]
    pub fn with_max_inline_uniform_block_size(mut self, value: u32) -> Self {
        self.max_inline_uniform_block_size = value;
        self
    }
    ///Sets the value of [`Self::max_per_stage_descriptor_inline_uniform_blocks`]
    pub fn with_max_per_stage_descriptor_inline_uniform_blocks(mut self, value: u32) -> Self {
        self.max_per_stage_descriptor_inline_uniform_blocks = value;
        self
    }
    ///Sets the value of [`Self::max_per_stage_descriptor_update_after_bind_inline_uniform_blocks`]
    pub fn with_max_per_stage_descriptor_update_after_bind_inline_uniform_blocks(mut self, value: u32) -> Self {
        self.max_per_stage_descriptor_update_after_bind_inline_uniform_blocks = value;
        self
    }
    ///Sets the value of [`Self::max_descriptor_set_inline_uniform_blocks`]
    pub fn with_max_descriptor_set_inline_uniform_blocks(mut self, value: u32) -> Self {
        self.max_descriptor_set_inline_uniform_blocks = value;
        self
    }
    ///Sets the value of [`Self::max_descriptor_set_update_after_bind_inline_uniform_blocks`]
    pub fn with_max_descriptor_set_update_after_bind_inline_uniform_blocks(mut self, value: u32) -> Self {
        self.max_descriptor_set_update_after_bind_inline_uniform_blocks = value;
        self
    }
}
///[VkWriteDescriptorSetInlineUniformBlock](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkWriteDescriptorSetInlineUniformBlock.html) - Structure specifying inline uniform block data
///# C Specifications
///If the `descriptorType` member of [`WriteDescriptorSet`] is
///`VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK` then the data to write to the
///descriptor set is specified through a
///[`WriteDescriptorSetInlineUniformBlock`] structure included in the
///[`p_next`] chain of [`WriteDescriptorSet`].The [`WriteDescriptorSetInlineUniformBlock`]
/// structure is defined as:
///```c
///// Provided by VK_VERSION_1_3
///typedef struct VkWriteDescriptorSetInlineUniformBlock {
///    VkStructureType    sType;
///    const void*        pNext;
///    uint32_t           dataSize;
///    const void*        pData;
///} VkWriteDescriptorSetInlineUniformBlock;
///```
///or the equivalent
///```c
///// Provided by VK_EXT_inline_uniform_block
///typedef VkWriteDescriptorSetInlineUniformBlock VkWriteDescriptorSetInlineUniformBlockEXT;
///```
///# Members
/// - [`s_type`] is the type of this structure.
/// - [`p_next`] is `NULL` or a pointer to a structure extending this structure.
/// - [`data_size`] is the number of bytes of inline uniform block data pointed to by [`data`].
/// - [`data`] is a pointer to [`data_size`] number of bytes of data to write to the inline uniform
///   block.
///# Description
///## Valid Usage
/// - [`data_size`] **must**  be an integer multiple of `4`
///
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be `VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK`
/// - [`data`] **must**  be a valid pointer to an array of [`data_size`] bytes
/// - [`data_size`] **must**  be greater than `0`
///# Related
/// - [`ext_inline_uniform_block`]
/// - [`crate::vulkan1_3`]
/// - [`StructureType`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkWriteDescriptorSetInlineUniformBlock")]
#[derive(Debug, Clone, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[repr(C)]
pub struct WriteDescriptorSetInlineUniformBlock<'lt> {
    ///Lifetime field
    pub _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] is the type of this structure.
    pub s_type: StructureType,
    ///[`p_next`] is `NULL` or a pointer to a structure extending this
    ///structure.
    pub p_next: *const BaseInStructure<'lt>,
    ///[`data_size`] is the number of bytes of inline uniform block data
    ///pointed to by [`data`].
    pub data_size: u32,
    ///[`data`] is a pointer to [`data_size`] number of bytes of data to
    ///write to the inline uniform block.
    pub data: *const c_void,
}
impl<'lt> Default for WriteDescriptorSetInlineUniformBlock<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: StructureType::WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK,
            p_next: std::ptr::null(),
            data_size: 0,
            data: std::ptr::null(),
        }
    }
}
impl<'lt> WriteDescriptorSetInlineUniformBlock<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *const BaseInStructure<'lt> {
        self.p_next
    }
    ///Gets the raw value of [`Self::data`]
    pub fn data_raw(&self) -> *const c_void {
        self.data
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *const BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::data`]
    pub fn set_data_raw(&mut self, value: *const c_void) -> &mut Self {
        self.data = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn with_p_next_raw(mut self, value: *const BaseInStructure<'lt>) -> Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::data`]
    pub fn with_data_raw(mut self, value: *const c_void) -> Self {
        self.data = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseInStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::data_size`]
    pub fn data_size(&self) -> u32 {
        self.data_size
    }
    ///Gets the value of [`Self::data`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn data(&self) -> &[c_void] {
        std::slice::from_raw_parts(self.data, self.data_size as usize)
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::data_size`]
    pub fn data_size_mut(&mut self) -> &mut u32 {
        &mut self.data_size
    }
    ///Sets the value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the value of [`Self::data_size`]
    pub fn set_data_size(&mut self, value: u32) -> &mut Self {
        self.data_size = value;
        self
    }
    ///Sets the value of [`Self::data`]
    pub fn set_data(&mut self, value: &'lt [std::ffi::c_void]) -> &mut Self {
        let len_ = value.len() as u32;
        let len_ = len_;
        self.data = value.as_ptr();
        self.data_size = len_;
        self
    }
    ///Sets the value of [`Self::s_type`]
    pub fn with_s_type(mut self, value: crate::vulkan1_0::StructureType) -> Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn with_p_next(mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the value of [`Self::data_size`]
    pub fn with_data_size(mut self, value: u32) -> Self {
        self.data_size = value;
        self
    }
    ///Sets the value of [`Self::data`]
    pub fn with_data(mut self, value: &'lt [std::ffi::c_void]) -> Self {
        let len_ = value.len() as u32;
        let len_ = len_;
        self.data = value.as_ptr();
        self.data_size = len_;
        self
    }
}
///[VkDescriptorPoolInlineUniformBlockCreateInfo](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorPoolInlineUniformBlockCreateInfo.html) - Structure specifying the maximum number of inline uniform block bindings of a newly created descriptor pool
///# C Specifications
///In order to be able to allocate descriptor sets having
///[inline uniform block](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-inlineuniformblock) bindings the
///descriptor pool  **must**  be created with specifying the inline uniform block
///binding capacity of the descriptor pool, in addition to the total inline
///uniform data capacity in bytes which is specified through a
///[`DescriptorPoolSize`] structure with a `descriptorType` value of
///`VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK`.
///This  **can**  be done by adding a
///[`DescriptorPoolInlineUniformBlockCreateInfo`] structure to the
///[`p_next`] chain of [`DescriptorPoolCreateInfo`].The
/// [`DescriptorPoolInlineUniformBlockCreateInfo`] structure is defined
///as:
///```c
///// Provided by VK_VERSION_1_3
///typedef struct VkDescriptorPoolInlineUniformBlockCreateInfo {
///    VkStructureType    sType;
///    const void*        pNext;
///    uint32_t           maxInlineUniformBlockBindings;
///} VkDescriptorPoolInlineUniformBlockCreateInfo;
///```
///or the equivalent
///```c
///// Provided by VK_EXT_inline_uniform_block
///typedef VkDescriptorPoolInlineUniformBlockCreateInfo
/// VkDescriptorPoolInlineUniformBlockCreateInfoEXT;
///```
///# Members
/// - [`s_type`] is the type of this structure.
/// - [`p_next`] is `NULL` or a pointer to a structure extending this structure.
/// - [`max_inline_uniform_block_bindings`] is the number of inline uniform block bindings to
///   allocate.
///# Description
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be `VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO`
///# Related
/// - [`ext_inline_uniform_block`]
/// - [`crate::vulkan1_3`]
/// - [`StructureType`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkDescriptorPoolInlineUniformBlockCreateInfo")]
#[derive(Debug, Clone, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[repr(C)]
pub struct DescriptorPoolInlineUniformBlockCreateInfo<'lt> {
    ///Lifetime field
    pub _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] is the type of this structure.
    pub s_type: StructureType,
    ///[`p_next`] is `NULL` or a pointer to a structure extending this
    ///structure.
    pub p_next: *const BaseInStructure<'lt>,
    ///[`max_inline_uniform_block_bindings`] is the number of inline uniform
    ///block bindings to allocate.
    pub max_inline_uniform_block_bindings: u32,
}
impl<'lt> Default for DescriptorPoolInlineUniformBlockCreateInfo<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: StructureType::DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO,
            p_next: std::ptr::null(),
            max_inline_uniform_block_bindings: 0,
        }
    }
}
impl<'lt> DescriptorPoolInlineUniformBlockCreateInfo<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *const BaseInStructure<'lt> {
        self.p_next
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *const BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn with_p_next_raw(mut self, value: *const BaseInStructure<'lt>) -> Self {
        self.p_next = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseInStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::max_inline_uniform_block_bindings`]
    pub fn max_inline_uniform_block_bindings(&self) -> u32 {
        self.max_inline_uniform_block_bindings
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::max_inline_uniform_block_bindings`]
    pub fn max_inline_uniform_block_bindings_mut(&mut self) -> &mut u32 {
        &mut self.max_inline_uniform_block_bindings
    }
    ///Sets the value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the value of [`Self::max_inline_uniform_block_bindings`]
    pub fn set_max_inline_uniform_block_bindings(&mut self, value: u32) -> &mut Self {
        self.max_inline_uniform_block_bindings = value;
        self
    }
    ///Sets the value of [`Self::s_type`]
    pub fn with_s_type(mut self, value: crate::vulkan1_0::StructureType) -> Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn with_p_next(mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the value of [`Self::max_inline_uniform_block_bindings`]
    pub fn with_max_inline_uniform_block_bindings(mut self, value: u32) -> Self {
        self.max_inline_uniform_block_bindings = value;
        self
    }
}
///[VkPhysicalDeviceMaintenance4Features](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMaintenance4Features.html) - Structure describing whether the implementation supports maintenance4 functionality
///# C Specifications
///The [`PhysicalDeviceMaintenance4Features`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_3
///typedef struct VkPhysicalDeviceMaintenance4Features {
///    VkStructureType    sType;
///    void*              pNext;
///    VkBool32           maintenance4;
///} VkPhysicalDeviceMaintenance4Features;
///```
///or the equivalent
///```c
///// Provided by VK_KHR_maintenance4
///typedef VkPhysicalDeviceMaintenance4Features VkPhysicalDeviceMaintenance4FeaturesKHR;
///```
///# Members
///This structure describes the following features:
///# Description
/// - [`maintenance4`] indicates that the implementation supports the following:  - The application
///   **may**  destroy a [`PipelineLayout`] object immediately after using it to create another
///   object.  - `LocalSizeId` **can**  be used as an alternative to `LocalSize` to specify the
///   local workgroup size with specialization constants.  - Images created with identical creation
///   parameters will always have the same alignment requirements.  - The size memory requirement of
///   a buffer or image is never greater than that of another buffer or image created with a greater
///   or equal size.  - Push constants do not have to be initialized before they are dynamically
///   accessed.  - The interface matching rules allow a larger output vector to match with a smaller
///   input vector, with additional values being discarded.
///If the [`PhysicalDeviceMaintenance4Features`] structure is included in the [`p_next`] chain of
/// the
///[`PhysicalDeviceFeatures2`] structure passed to
///[`get_physical_device_features2`], it is filled in to indicate whether each
///corresponding feature is supported.
///[`PhysicalDeviceMaintenance4Features`] **can**  also be used in the [`p_next`] chain of
///[`DeviceCreateInfo`] to selectively enable these features.
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be `VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES`
///# Related
/// - [`khr_maintenance4`]
/// - [`crate::vulkan1_3`]
/// - [`Bool32`]
/// - [`StructureType`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkPhysicalDeviceMaintenance4Features")]
#[derive(Debug, Clone, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[repr(C)]
pub struct PhysicalDeviceMaintenance4Features<'lt> {
    ///Lifetime field
    pub _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] **must**  be `VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES`
    pub s_type: StructureType,
    ///No documentation found
    pub p_next: *mut BaseOutStructure<'lt>,
    ///[`maintenance4`] indicates
    ///that the implementation supports the following:
    /// - The application  **may**  destroy a [`PipelineLayout`] object immediately after using it
    ///   to create another object.
    /// - `LocalSizeId` **can**  be used as an alternative to `LocalSize` to specify the local
    ///   workgroup size with specialization constants.
    /// - Images created with identical creation parameters will always have the same alignment
    ///   requirements.
    /// - The size memory requirement of a buffer or image is never greater than that of another
    ///   buffer or image created with a greater or equal size.
    /// - Push constants do not have to be initialized before they are dynamically accessed.
    /// - The interface matching rules allow a larger output vector to match with a smaller input
    ///   vector, with additional values being discarded.
    pub maintenance4: Bool32,
}
impl<'lt> Default for PhysicalDeviceMaintenance4Features<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: StructureType::PHYSICAL_DEVICE_MAINTENANCE4_FEATURES,
            p_next: std::ptr::null_mut(),
            maintenance4: 0,
        }
    }
}
impl<'lt> PhysicalDeviceMaintenance4Features<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *mut BaseOutStructure<'lt> {
        self.p_next
    }
    ///Gets the raw value of [`Self::maintenance4`]
    pub fn maintenance4_raw(&self) -> Bool32 {
        self.maintenance4
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *mut BaseOutStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::maintenance4`]
    pub fn set_maintenance4_raw(&mut self, value: Bool32) -> &mut Self {
        self.maintenance4 = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn with_p_next_raw(mut self, value: *mut BaseOutStructure<'lt>) -> Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::maintenance4`]
    pub fn with_maintenance4_raw(mut self, value: Bool32) -> Self {
        self.maintenance4 = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseOutStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::maintenance4`]
    pub fn maintenance4(&self) -> bool {
        unsafe { std::mem::transmute(self.maintenance4 as u8) }
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next_mut(&mut self) -> &mut BaseOutStructure<'lt> {
        &mut *self.p_next
    }
    ///Gets a mutable reference to the value of [`Self::maintenance4`]
    pub fn maintenance4_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.maintenance4 as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.maintenance4 as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Sets the value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt mut crate::vulkan1_0::BaseOutStructure<'lt>) -> &mut Self {
        self.p_next = value as *mut _;
        self
    }
    ///Sets the value of [`Self::maintenance4`]
    pub fn set_maintenance4(&mut self, value: bool) -> &mut Self {
        self.maintenance4 = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::s_type`]
    pub fn with_s_type(mut self, value: crate::vulkan1_0::StructureType) -> Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn with_p_next(mut self, value: &'lt mut crate::vulkan1_0::BaseOutStructure<'lt>) -> Self {
        self.p_next = value as *mut _;
        self
    }
    ///Sets the value of [`Self::maintenance4`]
    pub fn with_maintenance4(mut self, value: bool) -> Self {
        self.maintenance4 = value as u8 as u32;
        self
    }
}
///[VkPhysicalDeviceMaintenance4Properties](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMaintenance4Properties.html) - Structure describing various implementation-defined properties introduced with VK_KHR_maintenance4
///# C Specifications
///The [`PhysicalDeviceMaintenance4Properties`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_3
///typedef struct VkPhysicalDeviceMaintenance4Properties {
///    VkStructureType    sType;
///    void*              pNext;
///    VkDeviceSize       maxBufferSize;
///} VkPhysicalDeviceMaintenance4Properties;
///```
///or the equivalent
///```c
///// Provided by VK_KHR_maintenance4
///typedef VkPhysicalDeviceMaintenance4Properties VkPhysicalDeviceMaintenance4PropertiesKHR;
///```
///# Members
/// - [`s_type`] is the type of this structure.
/// - [`p_next`] is `NULL` or a pointer to a structure extending this structure.
///# Description
/// - [`max_buffer_size`] is the maximum size [`Buffer`] that  **can**  be created.
///If the [`PhysicalDeviceMaintenance4Properties`] structure is included in the [`p_next`] chain of
/// the
///[`PhysicalDeviceProperties2`] structure passed to
///[`get_physical_device_properties2`], it is filled in with each
///corresponding implementation-dependent property.
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be `VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES`
///# Related
/// - [`khr_maintenance4`]
/// - [`crate::vulkan1_3`]
/// - [`DeviceSize`]
/// - [`StructureType`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkPhysicalDeviceMaintenance4Properties")]
#[derive(Debug, Clone, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[repr(C)]
pub struct PhysicalDeviceMaintenance4Properties<'lt> {
    ///Lifetime field
    pub _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] is the type of this structure.
    pub s_type: StructureType,
    ///[`p_next`] is `NULL` or a pointer to a structure extending this
    ///structure.
    pub p_next: *mut BaseOutStructure<'lt>,
    ///No documentation found
    pub max_buffer_size: DeviceSize,
}
impl<'lt> Default for PhysicalDeviceMaintenance4Properties<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: StructureType::PHYSICAL_DEVICE_MAINTENANCE4_PROPERTIES,
            p_next: std::ptr::null_mut(),
            max_buffer_size: Default::default(),
        }
    }
}
impl<'lt> PhysicalDeviceMaintenance4Properties<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *mut BaseOutStructure<'lt> {
        self.p_next
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *mut BaseOutStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn with_p_next_raw(mut self, value: *mut BaseOutStructure<'lt>) -> Self {
        self.p_next = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseOutStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::max_buffer_size`]
    pub fn max_buffer_size(&self) -> DeviceSize {
        self.max_buffer_size
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next_mut(&mut self) -> &mut BaseOutStructure<'lt> {
        &mut *self.p_next
    }
    ///Gets a mutable reference to the value of [`Self::max_buffer_size`]
    pub fn max_buffer_size_mut(&mut self) -> &mut DeviceSize {
        &mut self.max_buffer_size
    }
    ///Sets the value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt mut crate::vulkan1_0::BaseOutStructure<'lt>) -> &mut Self {
        self.p_next = value as *mut _;
        self
    }
    ///Sets the value of [`Self::max_buffer_size`]
    pub fn set_max_buffer_size(&mut self, value: crate::vulkan1_0::DeviceSize) -> &mut Self {
        self.max_buffer_size = value;
        self
    }
    ///Sets the value of [`Self::s_type`]
    pub fn with_s_type(mut self, value: crate::vulkan1_0::StructureType) -> Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn with_p_next(mut self, value: &'lt mut crate::vulkan1_0::BaseOutStructure<'lt>) -> Self {
        self.p_next = value as *mut _;
        self
    }
    ///Sets the value of [`Self::max_buffer_size`]
    pub fn with_max_buffer_size(mut self, value: crate::vulkan1_0::DeviceSize) -> Self {
        self.max_buffer_size = value;
        self
    }
}
///[VkPhysicalDeviceTextureCompressionASTCHDRFeatures](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceTextureCompressionASTCHDRFeatures.html) - Structure describing ASTC HDR features that can be supported by an implementation
///# C Specifications
///The [`PhysicalDeviceTextureCompressionAstchdrFeatures`] structure is
///defined as:
///```c
///// Provided by VK_VERSION_1_3
///typedef struct VkPhysicalDeviceTextureCompressionASTCHDRFeatures {
///    VkStructureType    sType;
///    void*              pNext;
///    VkBool32           textureCompressionASTC_HDR;
///} VkPhysicalDeviceTextureCompressionASTCHDRFeatures;
///```
///or the equivalent
///```c
///// Provided by VK_EXT_texture_compression_astc_hdr
///typedef VkPhysicalDeviceTextureCompressionASTCHDRFeatures
/// VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT;
///```
///# Members
///This structure describes the following feature:
///# Description
/// - [`s_type`] is the type of this structure.
/// - [`p_next`] is `NULL` or a pointer to a structure extending this structure.
///
/// - [`texture_compression_astc_hdr`] indicates whether all of the ASTC HDR compressed texture
///   formats are supported. If this feature is enabled, then the
///   `VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT`, `VK_FORMAT_FEATURE_BLIT_SRC_BIT` and
///   `VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT` features  **must**  be supported in
///   `optimalTilingFeatures` for the following formats:  - `VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK`  -
///   `VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK`  - `VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK`  -
///   `VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK`  - `VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK`  -
///   `VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK`  - `VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK`  -
///   `VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK`  - `VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK`  -
///   `VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK`  - `VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK`  -
///   `VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK`  - `VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK`  -
///   `VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK` To query for additional properties, or if the feature is
///   not enabled, [`get_physical_device_format_properties`] and
///   [`get_physical_device_image_format_properties`] **can**  be used to check for supported
///   properties of individual formats as normal.
///If the [`PhysicalDeviceTextureCompressionAstchdrFeatures`] structure is included in the
/// [`p_next`] chain of the
///[`PhysicalDeviceFeatures2`] structure passed to
///[`get_physical_device_features2`], it is filled in to indicate whether each
///corresponding feature is supported.
///[`PhysicalDeviceTextureCompressionAstchdrFeatures`] **can**  also be used in the [`p_next`]
/// chain of
///[`DeviceCreateInfo`] to selectively enable these features.
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be
///   `VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES`
///# Related
/// - [`ext_texture_compression_astc_hdr`]
/// - [`crate::vulkan1_3`]
/// - [`Bool32`]
/// - [`StructureType`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkPhysicalDeviceTextureCompressionASTCHDRFeatures")]
#[derive(Debug, Clone, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[repr(C)]
pub struct PhysicalDeviceTextureCompressionAstchdrFeatures<'lt> {
    ///Lifetime field
    pub _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] is the type of this structure.
    pub s_type: StructureType,
    ///[`p_next`] is `NULL` or a pointer to a structure extending this
    ///structure.
    pub p_next: *mut BaseOutStructure<'lt>,
    ///[`texture_compression_astc_hdr`] indicates whether all of the ASTC HDR
    ///compressed texture formats are supported.
    ///If this feature is enabled, then the
    ///`VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT`,
    ///`VK_FORMAT_FEATURE_BLIT_SRC_BIT` and
    ///`VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT` features  **must**
    ///be supported in `optimalTilingFeatures` for the following formats:
    /// - `VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK`
    /// - `VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK`
    /// - `VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK`
    /// - `VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK`
    /// - `VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK`
    /// - `VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK`
    /// - `VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK`
    /// - `VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK`
    /// - `VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK`
    /// - `VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK`
    /// - `VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK`
    /// - `VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK`
    /// - `VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK`
    /// - `VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK`
    ///To query for additional properties, or if the feature is not enabled,
    ///[`get_physical_device_format_properties`] and
    ///[`get_physical_device_image_format_properties`] **can**  be used to check for
    ///supported properties of individual formats as normal.
    pub texture_compression_astc_hdr: Bool32,
}
impl<'lt> Default for PhysicalDeviceTextureCompressionAstchdrFeatures<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: StructureType::PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES,
            p_next: std::ptr::null_mut(),
            texture_compression_astc_hdr: 0,
        }
    }
}
impl<'lt> PhysicalDeviceTextureCompressionAstchdrFeatures<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *mut BaseOutStructure<'lt> {
        self.p_next
    }
    ///Gets the raw value of [`Self::texture_compression_astc_hdr`]
    pub fn texture_compression_astc_hdr_raw(&self) -> Bool32 {
        self.texture_compression_astc_hdr
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *mut BaseOutStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::texture_compression_astc_hdr`]
    pub fn set_texture_compression_astc_hdr_raw(&mut self, value: Bool32) -> &mut Self {
        self.texture_compression_astc_hdr = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn with_p_next_raw(mut self, value: *mut BaseOutStructure<'lt>) -> Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::texture_compression_astc_hdr`]
    pub fn with_texture_compression_astc_hdr_raw(mut self, value: Bool32) -> Self {
        self.texture_compression_astc_hdr = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseOutStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::texture_compression_astc_hdr`]
    pub fn texture_compression_astc_hdr(&self) -> bool {
        unsafe { std::mem::transmute(self.texture_compression_astc_hdr as u8) }
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next_mut(&mut self) -> &mut BaseOutStructure<'lt> {
        &mut *self.p_next
    }
    ///Gets a mutable reference to the value of [`Self::texture_compression_astc_hdr`]
    pub fn texture_compression_astc_hdr_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.texture_compression_astc_hdr as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.texture_compression_astc_hdr as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Sets the value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt mut crate::vulkan1_0::BaseOutStructure<'lt>) -> &mut Self {
        self.p_next = value as *mut _;
        self
    }
    ///Sets the value of [`Self::texture_compression_astc_hdr`]
    pub fn set_texture_compression_astc_hdr(&mut self, value: bool) -> &mut Self {
        self.texture_compression_astc_hdr = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::s_type`]
    pub fn with_s_type(mut self, value: crate::vulkan1_0::StructureType) -> Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn with_p_next(mut self, value: &'lt mut crate::vulkan1_0::BaseOutStructure<'lt>) -> Self {
        self.p_next = value as *mut _;
        self
    }
    ///Sets the value of [`Self::texture_compression_astc_hdr`]
    pub fn with_texture_compression_astc_hdr(mut self, value: bool) -> Self {
        self.texture_compression_astc_hdr = value as u8 as u32;
        self
    }
}
///[VkPipelineCreationFeedback](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineCreationFeedback.html) - Feedback about the creation of a pipeline or pipeline stage
///# C Specifications
///The [`PipelineCreationFeedback`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_3
///typedef struct VkPipelineCreationFeedback {
///    VkPipelineCreationFeedbackFlags    flags;
///    uint64_t                           duration;
///} VkPipelineCreationFeedback;
///```
///or the equivalent
///```c
///// Provided by VK_EXT_pipeline_creation_feedback
///typedef VkPipelineCreationFeedback VkPipelineCreationFeedbackEXT;
///```
///# Members
/// - [`flags`] is a bitmask of [`PipelineCreationFeedbackFlagBits`] providing feedback about the
///   creation of a pipeline or of a pipeline stage.
/// - [`duration`] is the duration spent creating a pipeline or pipeline stage in nanoseconds.
///# Description
///If the `VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT` is not set in
///[`flags`], an implementation  **must**  not set any other bits in [`flags`],
///and the values of all other [`PipelineCreationFeedback`] data members
///are undefined.
///# Related
/// - [`ext_pipeline_creation_feedback`]
/// - [`crate::vulkan1_3`]
/// - [`PipelineCreationFeedbackCreateInfo`]
/// - [`PipelineCreationFeedbackFlagBits`]
/// - [`PipelineCreationFeedbackFlags`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkPipelineCreationFeedback")]
#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct PipelineCreationFeedback {
    ///[`flags`] is a bitmask of [`PipelineCreationFeedbackFlagBits`]
    ///providing feedback about the creation of a pipeline or of a pipeline
    ///stage.
    pub flags: PipelineCreationFeedbackFlags,
    ///[`duration`] is the duration spent creating a pipeline or pipeline
    ///stage in nanoseconds.
    pub duration: u64,
}
impl Default for PipelineCreationFeedback {
    fn default() -> Self {
        Self {
            flags: Default::default(),
            duration: 0,
        }
    }
}
impl PipelineCreationFeedback {
    ///Gets the value of [`Self::flags`]
    pub fn flags(&self) -> PipelineCreationFeedbackFlags {
        self.flags
    }
    ///Gets the value of [`Self::duration`]
    pub fn duration(&self) -> u64 {
        self.duration
    }
    ///Gets a mutable reference to the value of [`Self::flags`]
    pub fn flags_mut(&mut self) -> &mut PipelineCreationFeedbackFlags {
        &mut self.flags
    }
    ///Gets a mutable reference to the value of [`Self::duration`]
    pub fn duration_mut(&mut self) -> &mut u64 {
        &mut self.duration
    }
    ///Sets the value of [`Self::flags`]
    pub fn set_flags(&mut self, value: crate::vulkan1_3::PipelineCreationFeedbackFlags) -> &mut Self {
        self.flags = value;
        self
    }
    ///Sets the value of [`Self::duration`]
    pub fn set_duration(&mut self, value: u64) -> &mut Self {
        self.duration = value;
        self
    }
    ///Sets the value of [`Self::flags`]
    pub fn with_flags(mut self, value: crate::vulkan1_3::PipelineCreationFeedbackFlags) -> Self {
        self.flags = value;
        self
    }
    ///Sets the value of [`Self::duration`]
    pub fn with_duration(mut self, value: u64) -> Self {
        self.duration = value;
        self
    }
}
///[VkPipelineCreationFeedbackCreateInfo](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineCreationFeedbackCreateInfo.html) - Request for feedback about the creation of a pipeline
///# C Specifications
///Feedback about the creation of a particular pipeline object  **can**  be obtained
///by adding a [`PipelineCreationFeedbackCreateInfo`] structure to the
///[`p_next`] chain of [`GraphicsPipelineCreateInfo`],
///[`RayTracingPipelineCreateInfoKHR`],
///[`RayTracingPipelineCreateInfoNV`],
///or [`ComputePipelineCreateInfo`].
///The [`PipelineCreationFeedbackCreateInfo`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_3
///typedef struct VkPipelineCreationFeedbackCreateInfo {
///    VkStructureType                sType;
///    const void*                    pNext;
///    VkPipelineCreationFeedback*    pPipelineCreationFeedback;
///    uint32_t                       pipelineStageCreationFeedbackCount;
///    VkPipelineCreationFeedback*    pPipelineStageCreationFeedbacks;
///} VkPipelineCreationFeedbackCreateInfo;
///```
///or the equivalent
///```c
///// Provided by VK_EXT_pipeline_creation_feedback
///typedef VkPipelineCreationFeedbackCreateInfo VkPipelineCreationFeedbackCreateInfoEXT;
///```
///# Members
/// - [`s_type`] is the type of this structure.
/// - [`p_next`] is `NULL` or a pointer to a structure extending this structure.
/// - [`pipeline_creation_feedback`] is a pointer to a [`PipelineCreationFeedback`] structure.
/// - [`pipeline_stage_creation_feedback_count`] is the number of elements in
///   [`pipeline_stage_creation_feedbacks`].
/// - [`pipeline_stage_creation_feedbacks`] is a pointer to an array of
///   [`pipeline_stage_creation_feedback_count`][`PipelineCreationFeedback`] structures.
///# Description
///An implementation  **should**  write pipeline creation feedback to
///[`pipeline_creation_feedback`] and  **may**  write pipeline stage creation
///feedback to [`pipeline_stage_creation_feedbacks`].
///An implementation  **must**  set or clear the
///`VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT` in
///[`PipelineCreationFeedback::flags`] for
///[`pipeline_creation_feedback`] and every element of
///[`pipeline_stage_creation_feedbacks`].When chained to
///[`RayTracingPipelineCreateInfoKHR`],
///[`RayTracingPipelineCreateInfoNV`],
///or
///[`GraphicsPipelineCreateInfo`], the `i` element of
///[`pipeline_stage_creation_feedbacks`] corresponds to the `i` element of
///[`RayTracingPipelineCreateInfoKHR::stages`],
///[`RayTracingPipelineCreateInfoNV::stages`],
///or
///[`GraphicsPipelineCreateInfo::stages`].
///When chained to [`ComputePipelineCreateInfo`], the first element of
///[`pipeline_stage_creation_feedbacks`] corresponds to
///[`ComputePipelineCreateInfo::stage`].
///## Valid Usage
/// - When chained to [`GraphicsPipelineCreateInfo`],
///   [`PipelineCreationFeedback`]::[`pipeline_stage_creation_feedback_count`] **must**  equal
///   [`GraphicsPipelineCreateInfo::stage_count`]
/// - When chained to [`ComputePipelineCreateInfo`],
///   [`PipelineCreationFeedback`]::[`pipeline_stage_creation_feedback_count`] **must**  equal 1
/// - When chained to [`RayTracingPipelineCreateInfoKHR`],
///   [`PipelineCreationFeedback`]::[`pipeline_stage_creation_feedback_count`] **must**  equal
///   [`RayTracingPipelineCreateInfoKHR::stage_count`]
/// - When chained to [`RayTracingPipelineCreateInfoNV`],
///   [`PipelineCreationFeedback`]::[`pipeline_stage_creation_feedback_count`] **must**  equal
///   [`RayTracingPipelineCreateInfoNV::stage_count`]
///
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be `VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO`
/// - [`pipeline_creation_feedback`] **must**  be a valid pointer to a [`PipelineCreationFeedback`]
///   structure
/// - [`pipeline_stage_creation_feedbacks`] **must**  be a valid pointer to an array of
///   [`pipeline_stage_creation_feedback_count`][`PipelineCreationFeedback`] structures
/// - [`pipeline_stage_creation_feedback_count`] **must**  be greater than `0`
///# Related
/// - [`ext_pipeline_creation_feedback`]
/// - [`crate::vulkan1_3`]
/// - [`ComputePipelineCreateInfo`]
/// - [`GraphicsPipelineCreateInfo`]
/// - [`PipelineCreationFeedback`]
/// - [`RayTracingPipelineCreateInfoKHR`]
/// - [`RayTracingPipelineCreateInfoNV`]
/// - [`StructureType`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkPipelineCreationFeedbackCreateInfo")]
#[derive(Debug, Clone, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[repr(C)]
pub struct PipelineCreationFeedbackCreateInfo<'lt> {
    ///Lifetime field
    pub _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] is the type of this structure.
    pub s_type: StructureType,
    ///[`p_next`] is `NULL` or a pointer to a structure extending this
    ///structure.
    pub p_next: *const BaseInStructure<'lt>,
    ///[`pipeline_creation_feedback`] is a pointer to a
    ///[`PipelineCreationFeedback`] structure.
    pub pipeline_creation_feedback: *mut PipelineCreationFeedback,
    ///[`pipeline_stage_creation_feedback_count`] is the number of elements in
    ///[`pipeline_stage_creation_feedbacks`].
    pub pipeline_stage_creation_feedback_count: u32,
    ///[`pipeline_stage_creation_feedbacks`] is a pointer to an array of
    ///[`pipeline_stage_creation_feedback_count`][`PipelineCreationFeedback`] structures.
    pub pipeline_stage_creation_feedbacks: *mut PipelineCreationFeedback,
}
impl<'lt> Default for PipelineCreationFeedbackCreateInfo<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: StructureType::PIPELINE_CREATION_FEEDBACK_CREATE_INFO,
            p_next: std::ptr::null(),
            pipeline_creation_feedback: std::ptr::null_mut(),
            pipeline_stage_creation_feedback_count: 0,
            pipeline_stage_creation_feedbacks: std::ptr::null_mut(),
        }
    }
}
impl<'lt> PipelineCreationFeedbackCreateInfo<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *const BaseInStructure<'lt> {
        self.p_next
    }
    ///Gets the raw value of [`Self::pipeline_creation_feedback`]
    pub fn pipeline_creation_feedback_raw(&self) -> *mut PipelineCreationFeedback {
        self.pipeline_creation_feedback
    }
    ///Gets the raw value of [`Self::pipeline_stage_creation_feedbacks`]
    pub fn pipeline_stage_creation_feedbacks_raw(&self) -> *mut PipelineCreationFeedback {
        self.pipeline_stage_creation_feedbacks
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *const BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::pipeline_creation_feedback`]
    pub fn set_pipeline_creation_feedback_raw(&mut self, value: *mut PipelineCreationFeedback) -> &mut Self {
        self.pipeline_creation_feedback = value;
        self
    }
    ///Sets the raw value of [`Self::pipeline_stage_creation_feedbacks`]
    pub fn set_pipeline_stage_creation_feedbacks_raw(&mut self, value: *mut PipelineCreationFeedback) -> &mut Self {
        self.pipeline_stage_creation_feedbacks = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn with_p_next_raw(mut self, value: *const BaseInStructure<'lt>) -> Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::pipeline_creation_feedback`]
    pub fn with_pipeline_creation_feedback_raw(mut self, value: *mut PipelineCreationFeedback) -> Self {
        self.pipeline_creation_feedback = value;
        self
    }
    ///Sets the raw value of [`Self::pipeline_stage_creation_feedbacks`]
    pub fn with_pipeline_stage_creation_feedbacks_raw(mut self, value: *mut PipelineCreationFeedback) -> Self {
        self.pipeline_stage_creation_feedbacks = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseInStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::pipeline_creation_feedback`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn pipeline_creation_feedback(&self) -> &PipelineCreationFeedback {
        &*self.pipeline_creation_feedback
    }
    ///Gets the value of [`Self::pipeline_stage_creation_feedback_count`]
    pub fn pipeline_stage_creation_feedback_count(&self) -> u32 {
        self.pipeline_stage_creation_feedback_count
    }
    ///Gets the value of [`Self::pipeline_stage_creation_feedbacks`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn pipeline_stage_creation_feedbacks(&self) -> &[PipelineCreationFeedback] {
        std::slice::from_raw_parts(
            self.pipeline_stage_creation_feedbacks,
            self.pipeline_stage_creation_feedback_count as usize,
        )
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::pipeline_creation_feedback`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn pipeline_creation_feedback_mut(&mut self) -> &mut PipelineCreationFeedback {
        &mut *self.pipeline_creation_feedback
    }
    ///Gets a mutable reference to the value of [`Self::pipeline_stage_creation_feedback_count`]
    pub fn pipeline_stage_creation_feedback_count_mut(&mut self) -> &mut u32 {
        &mut self.pipeline_stage_creation_feedback_count
    }
    ///Gets a mutable reference to the value of [`Self::pipeline_stage_creation_feedbacks`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn pipeline_stage_creation_feedbacks_mut(&mut self) -> &mut [PipelineCreationFeedback] {
        std::slice::from_raw_parts_mut(
            self.pipeline_stage_creation_feedbacks,
            self.pipeline_stage_creation_feedback_count as usize,
        )
    }
    ///Sets the value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the value of [`Self::pipeline_creation_feedback`]
    pub fn set_pipeline_creation_feedback(
        &mut self,
        value: &'lt mut crate::vulkan1_3::PipelineCreationFeedback,
    ) -> &mut Self {
        self.pipeline_creation_feedback = value as *mut _;
        self
    }
    ///Sets the value of [`Self::pipeline_stage_creation_feedback_count`]
    pub fn set_pipeline_stage_creation_feedback_count(&mut self, value: u32) -> &mut Self {
        self.pipeline_stage_creation_feedback_count = value;
        self
    }
    ///Sets the value of [`Self::pipeline_stage_creation_feedbacks`]
    pub fn set_pipeline_stage_creation_feedbacks(
        &mut self,
        value: &'lt mut [crate::vulkan1_3::PipelineCreationFeedback],
    ) -> &mut Self {
        let len_ = value.len() as u32;
        let len_ = len_;
        self.pipeline_stage_creation_feedbacks = value.as_mut_ptr();
        self.pipeline_stage_creation_feedback_count = len_;
        self
    }
    ///Sets the value of [`Self::s_type`]
    pub fn with_s_type(mut self, value: crate::vulkan1_0::StructureType) -> Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn with_p_next(mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the value of [`Self::pipeline_creation_feedback`]
    pub fn with_pipeline_creation_feedback(
        mut self,
        value: &'lt mut crate::vulkan1_3::PipelineCreationFeedback,
    ) -> Self {
        self.pipeline_creation_feedback = value as *mut _;
        self
    }
    ///Sets the value of [`Self::pipeline_stage_creation_feedback_count`]
    pub fn with_pipeline_stage_creation_feedback_count(mut self, value: u32) -> Self {
        self.pipeline_stage_creation_feedback_count = value;
        self
    }
    ///Sets the value of [`Self::pipeline_stage_creation_feedbacks`]
    pub fn with_pipeline_stage_creation_feedbacks(
        mut self,
        value: &'lt mut [crate::vulkan1_3::PipelineCreationFeedback],
    ) -> Self {
        let len_ = value.len() as u32;
        let len_ = len_;
        self.pipeline_stage_creation_feedbacks = value.as_mut_ptr();
        self.pipeline_stage_creation_feedback_count = len_;
        self
    }
}
///[VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures.html) - Structure describing the shader demote to helper invocations features that can be supported by an implementation
///# C Specifications
///The [`PhysicalDeviceShaderDemoteToHelperInvocationFeatures`] structure
///is defined as:
///```c
///// Provided by VK_VERSION_1_3
///typedef struct VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures {
///    VkStructureType    sType;
///    void*              pNext;
///    VkBool32           shaderDemoteToHelperInvocation;
///} VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures;
///```
///or the equivalent
///```c
///// Provided by VK_EXT_shader_demote_to_helper_invocation
///typedef VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures
/// VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT;
///```
///# Members
///This structure describes the following feature:
///# Description
/// - [`s_type`] is the type of this structure.
/// - [`p_next`] is `NULL` or a pointer to a structure extending this structure.
///
/// - [`shader_demote_to_helper_invocation`] indicates whether the implementation supports the
///   SPIR-V `DemoteToHelperInvocationEXT` capability.
///If the [`PhysicalDeviceShaderDemoteToHelperInvocationFeatures`] structure is included in the
/// [`p_next`] chain of the
///[`PhysicalDeviceFeatures2`] structure passed to
///[`get_physical_device_features2`], it is filled in to indicate whether each
///corresponding feature is supported.
///[`PhysicalDeviceShaderDemoteToHelperInvocationFeatures`] **can**  also be used in the [`p_next`]
/// chain of
///[`DeviceCreateInfo`] to selectively enable these features.
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be
///   `VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES`
///# Related
/// - [`ext_shader_demote_to_helper_invocation`]
/// - [`crate::vulkan1_3`]
/// - [`Bool32`]
/// - [`StructureType`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures")]
#[derive(Debug, Clone, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[repr(C)]
pub struct PhysicalDeviceShaderDemoteToHelperInvocationFeatures<'lt> {
    ///Lifetime field
    pub _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] is the type of this structure.
    pub s_type: StructureType,
    ///[`p_next`] is `NULL` or a pointer to a structure extending this
    ///structure.
    pub p_next: *mut BaseOutStructure<'lt>,
    ///[`shader_demote_to_helper_invocation`] indicates whether the
    ///implementation supports the SPIR-V `DemoteToHelperInvocationEXT`
    ///capability.
    pub shader_demote_to_helper_invocation: Bool32,
}
impl<'lt> Default for PhysicalDeviceShaderDemoteToHelperInvocationFeatures<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: StructureType::PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES,
            p_next: std::ptr::null_mut(),
            shader_demote_to_helper_invocation: 0,
        }
    }
}
impl<'lt> PhysicalDeviceShaderDemoteToHelperInvocationFeatures<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *mut BaseOutStructure<'lt> {
        self.p_next
    }
    ///Gets the raw value of [`Self::shader_demote_to_helper_invocation`]
    pub fn shader_demote_to_helper_invocation_raw(&self) -> Bool32 {
        self.shader_demote_to_helper_invocation
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *mut BaseOutStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::shader_demote_to_helper_invocation`]
    pub fn set_shader_demote_to_helper_invocation_raw(&mut self, value: Bool32) -> &mut Self {
        self.shader_demote_to_helper_invocation = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn with_p_next_raw(mut self, value: *mut BaseOutStructure<'lt>) -> Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::shader_demote_to_helper_invocation`]
    pub fn with_shader_demote_to_helper_invocation_raw(mut self, value: Bool32) -> Self {
        self.shader_demote_to_helper_invocation = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseOutStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::shader_demote_to_helper_invocation`]
    pub fn shader_demote_to_helper_invocation(&self) -> bool {
        unsafe { std::mem::transmute(self.shader_demote_to_helper_invocation as u8) }
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next_mut(&mut self) -> &mut BaseOutStructure<'lt> {
        &mut *self.p_next
    }
    ///Gets a mutable reference to the value of [`Self::shader_demote_to_helper_invocation`]
    pub fn shader_demote_to_helper_invocation_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.shader_demote_to_helper_invocation as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.shader_demote_to_helper_invocation as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Sets the value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt mut crate::vulkan1_0::BaseOutStructure<'lt>) -> &mut Self {
        self.p_next = value as *mut _;
        self
    }
    ///Sets the value of [`Self::shader_demote_to_helper_invocation`]
    pub fn set_shader_demote_to_helper_invocation(&mut self, value: bool) -> &mut Self {
        self.shader_demote_to_helper_invocation = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::s_type`]
    pub fn with_s_type(mut self, value: crate::vulkan1_0::StructureType) -> Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn with_p_next(mut self, value: &'lt mut crate::vulkan1_0::BaseOutStructure<'lt>) -> Self {
        self.p_next = value as *mut _;
        self
    }
    ///Sets the value of [`Self::shader_demote_to_helper_invocation`]
    pub fn with_shader_demote_to_helper_invocation(mut self, value: bool) -> Self {
        self.shader_demote_to_helper_invocation = value as u8 as u32;
        self
    }
}
///[VkPhysicalDeviceTexelBufferAlignmentProperties](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceTexelBufferAlignmentProperties.html) - Structure describing the texel buffer alignment requirements supported by an implementation
///# C Specifications
///The [`PhysicalDeviceTexelBufferAlignmentProperties`] structure is
///defined as:
///```c
///// Provided by VK_VERSION_1_3
///typedef struct VkPhysicalDeviceTexelBufferAlignmentProperties {
///    VkStructureType    sType;
///    void*              pNext;
///    VkDeviceSize       storageTexelBufferOffsetAlignmentBytes;
///    VkBool32           storageTexelBufferOffsetSingleTexelAlignment;
///    VkDeviceSize       uniformTexelBufferOffsetAlignmentBytes;
///    VkBool32           uniformTexelBufferOffsetSingleTexelAlignment;
///} VkPhysicalDeviceTexelBufferAlignmentProperties;
///```
///or the equivalent
///```c
///// Provided by VK_EXT_texel_buffer_alignment
///typedef VkPhysicalDeviceTexelBufferAlignmentProperties
/// VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT;
///```
///# Members
/// - [`s_type`] is the type of this structure.
/// - [`p_next`] is `NULL` or a pointer to a structure extending this structure.
///# Description
/// - [`storage_texel_buffer_offset_alignment_bytes`] is a byte alignment that is sufficient for a
///   storage texel buffer of any format. The value  **must**  be a power of two.
/// - [`storage_texel_buffer_offset_single_texel_alignment`] indicates whether single texel
///   alignment is sufficient for a storage texel buffer of any format. The value  **must**  be a
///   power of two.
/// - [`uniform_texel_buffer_offset_alignment_bytes`] is a byte alignment that is sufficient for a
///   uniform texel buffer of any format. The value  **must**  be a power of two.
/// - [`uniform_texel_buffer_offset_single_texel_alignment`] indicates whether single texel
///   alignment is sufficient for a uniform texel buffer of any format. The value  **must**  be a
///   power of two.
///If the [`PhysicalDeviceTexelBufferAlignmentProperties`] structure is included in the [`p_next`]
/// chain of the
///[`PhysicalDeviceProperties2`] structure passed to
///[`get_physical_device_properties2`], it is filled in with each
///corresponding implementation-dependent property.If the single texel alignment property is
/// [`FALSE`], then the buffer
///views offset  **must**  be aligned to the corresponding byte alignment value.
///If the single texel alignment property is [`TRUE`], then the buffer
///views offset  **must**  be aligned to the lesser of the corresponding byte
///alignment value or the size of a single texel, based on
///[`BufferViewCreateInfo::format`].
///If the size of a single texel is a multiple of three bytes, then the size of
///a single component of the format is used instead.These limits  **must**  not advertise a larger
/// alignment than the
///[required](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#limits-required) maximum minimum value of
///[`PhysicalDeviceLimits::min_texel_buffer_offset_alignment`], for any
///format that supports use as a texel buffer.
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be `VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES`
///# Related
/// - [`ext_texel_buffer_alignment`]
/// - [`crate::vulkan1_3`]
/// - [`Bool32`]
/// - [`DeviceSize`]
/// - [`StructureType`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkPhysicalDeviceTexelBufferAlignmentProperties")]
#[derive(Debug, Clone, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[repr(C)]
pub struct PhysicalDeviceTexelBufferAlignmentProperties<'lt> {
    ///Lifetime field
    pub _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] is the type of this structure.
    pub s_type: StructureType,
    ///[`p_next`] is `NULL` or a pointer to a structure extending this
    ///structure.
    pub p_next: *mut BaseOutStructure<'lt>,
    ///No documentation found
    pub storage_texel_buffer_offset_alignment_bytes: DeviceSize,
    ///No documentation found
    pub storage_texel_buffer_offset_single_texel_alignment: Bool32,
    ///No documentation found
    pub uniform_texel_buffer_offset_alignment_bytes: DeviceSize,
    ///No documentation found
    pub uniform_texel_buffer_offset_single_texel_alignment: Bool32,
}
impl<'lt> Default for PhysicalDeviceTexelBufferAlignmentProperties<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: StructureType::PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES,
            p_next: std::ptr::null_mut(),
            storage_texel_buffer_offset_alignment_bytes: Default::default(),
            storage_texel_buffer_offset_single_texel_alignment: 0,
            uniform_texel_buffer_offset_alignment_bytes: Default::default(),
            uniform_texel_buffer_offset_single_texel_alignment: 0,
        }
    }
}
impl<'lt> PhysicalDeviceTexelBufferAlignmentProperties<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *mut BaseOutStructure<'lt> {
        self.p_next
    }
    ///Gets the raw value of [`Self::storage_texel_buffer_offset_single_texel_alignment`]
    pub fn storage_texel_buffer_offset_single_texel_alignment_raw(&self) -> Bool32 {
        self.storage_texel_buffer_offset_single_texel_alignment
    }
    ///Gets the raw value of [`Self::uniform_texel_buffer_offset_single_texel_alignment`]
    pub fn uniform_texel_buffer_offset_single_texel_alignment_raw(&self) -> Bool32 {
        self.uniform_texel_buffer_offset_single_texel_alignment
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *mut BaseOutStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::storage_texel_buffer_offset_single_texel_alignment`]
    pub fn set_storage_texel_buffer_offset_single_texel_alignment_raw(&mut self, value: Bool32) -> &mut Self {
        self.storage_texel_buffer_offset_single_texel_alignment = value;
        self
    }
    ///Sets the raw value of [`Self::uniform_texel_buffer_offset_single_texel_alignment`]
    pub fn set_uniform_texel_buffer_offset_single_texel_alignment_raw(&mut self, value: Bool32) -> &mut Self {
        self.uniform_texel_buffer_offset_single_texel_alignment = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn with_p_next_raw(mut self, value: *mut BaseOutStructure<'lt>) -> Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::storage_texel_buffer_offset_single_texel_alignment`]
    pub fn with_storage_texel_buffer_offset_single_texel_alignment_raw(mut self, value: Bool32) -> Self {
        self.storage_texel_buffer_offset_single_texel_alignment = value;
        self
    }
    ///Sets the raw value of [`Self::uniform_texel_buffer_offset_single_texel_alignment`]
    pub fn with_uniform_texel_buffer_offset_single_texel_alignment_raw(mut self, value: Bool32) -> Self {
        self.uniform_texel_buffer_offset_single_texel_alignment = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseOutStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::storage_texel_buffer_offset_alignment_bytes`]
    pub fn storage_texel_buffer_offset_alignment_bytes(&self) -> DeviceSize {
        self.storage_texel_buffer_offset_alignment_bytes
    }
    ///Gets the value of [`Self::storage_texel_buffer_offset_single_texel_alignment`]
    pub fn storage_texel_buffer_offset_single_texel_alignment(&self) -> bool {
        unsafe { std::mem::transmute(self.storage_texel_buffer_offset_single_texel_alignment as u8) }
    }
    ///Gets the value of [`Self::uniform_texel_buffer_offset_alignment_bytes`]
    pub fn uniform_texel_buffer_offset_alignment_bytes(&self) -> DeviceSize {
        self.uniform_texel_buffer_offset_alignment_bytes
    }
    ///Gets the value of [`Self::uniform_texel_buffer_offset_single_texel_alignment`]
    pub fn uniform_texel_buffer_offset_single_texel_alignment(&self) -> bool {
        unsafe { std::mem::transmute(self.uniform_texel_buffer_offset_single_texel_alignment as u8) }
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next_mut(&mut self) -> &mut BaseOutStructure<'lt> {
        &mut *self.p_next
    }
    ///Gets a mutable reference to the value of
    /// [`Self::storage_texel_buffer_offset_alignment_bytes`]
    pub fn storage_texel_buffer_offset_alignment_bytes_mut(&mut self) -> &mut DeviceSize {
        &mut self.storage_texel_buffer_offset_alignment_bytes
    }
    ///Gets a mutable reference to the value of
    /// [`Self::storage_texel_buffer_offset_single_texel_alignment`]
    pub fn storage_texel_buffer_offset_single_texel_alignment_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.storage_texel_buffer_offset_single_texel_alignment as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.storage_texel_buffer_offset_single_texel_alignment as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of
    /// [`Self::uniform_texel_buffer_offset_alignment_bytes`]
    pub fn uniform_texel_buffer_offset_alignment_bytes_mut(&mut self) -> &mut DeviceSize {
        &mut self.uniform_texel_buffer_offset_alignment_bytes
    }
    ///Gets a mutable reference to the value of
    /// [`Self::uniform_texel_buffer_offset_single_texel_alignment`]
    pub fn uniform_texel_buffer_offset_single_texel_alignment_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.uniform_texel_buffer_offset_single_texel_alignment as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.uniform_texel_buffer_offset_single_texel_alignment as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Sets the value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt mut crate::vulkan1_0::BaseOutStructure<'lt>) -> &mut Self {
        self.p_next = value as *mut _;
        self
    }
    ///Sets the value of [`Self::storage_texel_buffer_offset_alignment_bytes`]
    pub fn set_storage_texel_buffer_offset_alignment_bytes(
        &mut self,
        value: crate::vulkan1_0::DeviceSize,
    ) -> &mut Self {
        self.storage_texel_buffer_offset_alignment_bytes = value;
        self
    }
    ///Sets the value of [`Self::storage_texel_buffer_offset_single_texel_alignment`]
    pub fn set_storage_texel_buffer_offset_single_texel_alignment(&mut self, value: bool) -> &mut Self {
        self.storage_texel_buffer_offset_single_texel_alignment = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::uniform_texel_buffer_offset_alignment_bytes`]
    pub fn set_uniform_texel_buffer_offset_alignment_bytes(
        &mut self,
        value: crate::vulkan1_0::DeviceSize,
    ) -> &mut Self {
        self.uniform_texel_buffer_offset_alignment_bytes = value;
        self
    }
    ///Sets the value of [`Self::uniform_texel_buffer_offset_single_texel_alignment`]
    pub fn set_uniform_texel_buffer_offset_single_texel_alignment(&mut self, value: bool) -> &mut Self {
        self.uniform_texel_buffer_offset_single_texel_alignment = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::s_type`]
    pub fn with_s_type(mut self, value: crate::vulkan1_0::StructureType) -> Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn with_p_next(mut self, value: &'lt mut crate::vulkan1_0::BaseOutStructure<'lt>) -> Self {
        self.p_next = value as *mut _;
        self
    }
    ///Sets the value of [`Self::storage_texel_buffer_offset_alignment_bytes`]
    pub fn with_storage_texel_buffer_offset_alignment_bytes(mut self, value: crate::vulkan1_0::DeviceSize) -> Self {
        self.storage_texel_buffer_offset_alignment_bytes = value;
        self
    }
    ///Sets the value of [`Self::storage_texel_buffer_offset_single_texel_alignment`]
    pub fn with_storage_texel_buffer_offset_single_texel_alignment(mut self, value: bool) -> Self {
        self.storage_texel_buffer_offset_single_texel_alignment = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::uniform_texel_buffer_offset_alignment_bytes`]
    pub fn with_uniform_texel_buffer_offset_alignment_bytes(mut self, value: crate::vulkan1_0::DeviceSize) -> Self {
        self.uniform_texel_buffer_offset_alignment_bytes = value;
        self
    }
    ///Sets the value of [`Self::uniform_texel_buffer_offset_single_texel_alignment`]
    pub fn with_uniform_texel_buffer_offset_single_texel_alignment(mut self, value: bool) -> Self {
        self.uniform_texel_buffer_offset_single_texel_alignment = value as u8 as u32;
        self
    }
}
///[VkPhysicalDeviceSubgroupSizeControlFeatures](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceSubgroupSizeControlFeatures.html) - Structure describing the subgroup size control features that can be supported by an implementation
///# C Specifications
///The [`PhysicalDeviceSubgroupSizeControlFeatures`] structure is defined
///as:
///```c
///// Provided by VK_VERSION_1_3
///typedef struct VkPhysicalDeviceSubgroupSizeControlFeatures {
///    VkStructureType    sType;
///    void*              pNext;
///    VkBool32           subgroupSizeControl;
///    VkBool32           computeFullSubgroups;
///} VkPhysicalDeviceSubgroupSizeControlFeatures;
///```
///or the equivalent
///```c
///// Provided by VK_EXT_subgroup_size_control
///typedef VkPhysicalDeviceSubgroupSizeControlFeatures
/// VkPhysicalDeviceSubgroupSizeControlFeaturesEXT;
///```
///# Members
///This structure describes the following features:
///# Description
/// - [`s_type`] is the type of this structure.
/// - [`p_next`] is `NULL` or a pointer to a structure extending this structure.
///
/// - [`subgroup_size_control`] indicates whether the implementation supports controlling shader
///   subgroup sizes via the `VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT` flag
///   and the [`PipelineShaderStageRequiredSubgroupSizeCreateInfo`] structure.
/// - [`compute_full_subgroups`] indicates whether the implementation supports requiring full
///   subgroups in compute shaders via the
///   `VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT` flag.
///If the [`PhysicalDeviceSubgroupSizeControlFeatures`] structure is included in the [`p_next`]
/// chain of the
///[`PhysicalDeviceFeatures2`] structure passed to
///[`get_physical_device_features2`], it is filled in to indicate whether each
///corresponding feature is supported.
///[`PhysicalDeviceSubgroupSizeControlFeatures`] **can**  also be used in the [`p_next`] chain of
///[`DeviceCreateInfo`] to selectively enable these features.
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be `VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES`
///# Related
/// - [`ext_subgroup_size_control`]
/// - [`crate::vulkan1_3`]
/// - [`Bool32`]
/// - [`StructureType`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkPhysicalDeviceSubgroupSizeControlFeatures")]
#[derive(Debug, Clone, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[repr(C)]
pub struct PhysicalDeviceSubgroupSizeControlFeatures<'lt> {
    ///Lifetime field
    pub _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] is the type of this structure.
    pub s_type: StructureType,
    ///[`p_next`] is `NULL` or a pointer to a structure extending this
    ///structure.
    pub p_next: *mut BaseOutStructure<'lt>,
    ///[`subgroup_size_control`] indicates whether the implementation supports
    ///controlling shader subgroup sizes via the
    ///`VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT`
    ///flag and the [`PipelineShaderStageRequiredSubgroupSizeCreateInfo`]
    ///structure.
    pub subgroup_size_control: Bool32,
    ///[`compute_full_subgroups`] indicates whether the implementation supports
    ///requiring full subgroups in compute shaders via the
    ///`VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT` flag.
    pub compute_full_subgroups: Bool32,
}
impl<'lt> Default for PhysicalDeviceSubgroupSizeControlFeatures<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: StructureType::PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES,
            p_next: std::ptr::null_mut(),
            subgroup_size_control: 0,
            compute_full_subgroups: 0,
        }
    }
}
impl<'lt> PhysicalDeviceSubgroupSizeControlFeatures<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *mut BaseOutStructure<'lt> {
        self.p_next
    }
    ///Gets the raw value of [`Self::subgroup_size_control`]
    pub fn subgroup_size_control_raw(&self) -> Bool32 {
        self.subgroup_size_control
    }
    ///Gets the raw value of [`Self::compute_full_subgroups`]
    pub fn compute_full_subgroups_raw(&self) -> Bool32 {
        self.compute_full_subgroups
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *mut BaseOutStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::subgroup_size_control`]
    pub fn set_subgroup_size_control_raw(&mut self, value: Bool32) -> &mut Self {
        self.subgroup_size_control = value;
        self
    }
    ///Sets the raw value of [`Self::compute_full_subgroups`]
    pub fn set_compute_full_subgroups_raw(&mut self, value: Bool32) -> &mut Self {
        self.compute_full_subgroups = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn with_p_next_raw(mut self, value: *mut BaseOutStructure<'lt>) -> Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::subgroup_size_control`]
    pub fn with_subgroup_size_control_raw(mut self, value: Bool32) -> Self {
        self.subgroup_size_control = value;
        self
    }
    ///Sets the raw value of [`Self::compute_full_subgroups`]
    pub fn with_compute_full_subgroups_raw(mut self, value: Bool32) -> Self {
        self.compute_full_subgroups = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseOutStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::subgroup_size_control`]
    pub fn subgroup_size_control(&self) -> bool {
        unsafe { std::mem::transmute(self.subgroup_size_control as u8) }
    }
    ///Gets the value of [`Self::compute_full_subgroups`]
    pub fn compute_full_subgroups(&self) -> bool {
        unsafe { std::mem::transmute(self.compute_full_subgroups as u8) }
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next_mut(&mut self) -> &mut BaseOutStructure<'lt> {
        &mut *self.p_next
    }
    ///Gets a mutable reference to the value of [`Self::subgroup_size_control`]
    pub fn subgroup_size_control_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.subgroup_size_control as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.subgroup_size_control as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of [`Self::compute_full_subgroups`]
    pub fn compute_full_subgroups_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.compute_full_subgroups as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.compute_full_subgroups as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Sets the value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt mut crate::vulkan1_0::BaseOutStructure<'lt>) -> &mut Self {
        self.p_next = value as *mut _;
        self
    }
    ///Sets the value of [`Self::subgroup_size_control`]
    pub fn set_subgroup_size_control(&mut self, value: bool) -> &mut Self {
        self.subgroup_size_control = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::compute_full_subgroups`]
    pub fn set_compute_full_subgroups(&mut self, value: bool) -> &mut Self {
        self.compute_full_subgroups = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::s_type`]
    pub fn with_s_type(mut self, value: crate::vulkan1_0::StructureType) -> Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn with_p_next(mut self, value: &'lt mut crate::vulkan1_0::BaseOutStructure<'lt>) -> Self {
        self.p_next = value as *mut _;
        self
    }
    ///Sets the value of [`Self::subgroup_size_control`]
    pub fn with_subgroup_size_control(mut self, value: bool) -> Self {
        self.subgroup_size_control = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::compute_full_subgroups`]
    pub fn with_compute_full_subgroups(mut self, value: bool) -> Self {
        self.compute_full_subgroups = value as u8 as u32;
        self
    }
}
///[VkPhysicalDeviceSubgroupSizeControlProperties](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceSubgroupSizeControlProperties.html) - Structure describing the control subgroup size properties of an implementation
///# C Specifications
///The [`PhysicalDeviceSubgroupSizeControlProperties`] structure is defined
///as:
///```c
///// Provided by VK_VERSION_1_3
///typedef struct VkPhysicalDeviceSubgroupSizeControlProperties {
///    VkStructureType       sType;
///    void*                 pNext;
///    uint32_t              minSubgroupSize;
///    uint32_t              maxSubgroupSize;
///    uint32_t              maxComputeWorkgroupSubgroups;
///    VkShaderStageFlags    requiredSubgroupSizeStages;
///} VkPhysicalDeviceSubgroupSizeControlProperties;
///```
///or the equivalent
///```c
///// Provided by VK_EXT_subgroup_size_control
///typedef VkPhysicalDeviceSubgroupSizeControlProperties
/// VkPhysicalDeviceSubgroupSizeControlPropertiesEXT;
///```
///# Members
/// - [`s_type`] is the type of this structure.
/// - [`p_next`] is `NULL` or a pointer to a structure extending this structure.
///# Description
/// - [`min_subgroup_size`] is the minimum subgroup size supported by this device. [`min_subgroup_size`] is at least one if any of the physical devices queues support `VK_QUEUE_GRAPHICS_BIT` or `VK_QUEUE_COMPUTE_BIT`. [`min_subgroup_size`] is a power-of-two. [`min_subgroup_size`] is less than or equal to [`max_subgroup_size`]. [`min_subgroup_size`] is less than or equal to [subgroupSize](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#limits-subgroup-size).
/// - [`max_subgroup_size`] is the maximum subgroup size supported by this device. [`max_subgroup_size`] is at least one if any of the physical devices queues support `VK_QUEUE_GRAPHICS_BIT` or `VK_QUEUE_COMPUTE_BIT`. [`max_subgroup_size`] is a power-of-two. [`max_subgroup_size`] is greater than or equal to [`min_subgroup_size`]. [`max_subgroup_size`] is greater than or equal to [subgroupSize](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#limits-subgroup-size).
/// - [`max_compute_workgroup_subgroups`] is the maximum number of subgroups supported by the
///   implementation within a workgroup.
/// - [`required_subgroup_size_stages`] is a bitfield of what shader stages support having a
///   required subgroup size specified.
///If the [`PhysicalDeviceSubgroupSizeControlProperties`] structure is included in the [`p_next`]
/// chain of the
///[`PhysicalDeviceProperties2`] structure passed to
///[`get_physical_device_properties2`], it is filled in with each
///corresponding implementation-dependent property.If
/// [`PhysicalDeviceSubgroupProperties::supported_operations`]
///includes [`VK_SUBGROUP_FEATURE_QUAD_BIT`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-subgroup-quad),
///[`min_subgroup_size`] **must**  be greater than or equal to 4.
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be `VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES`
///# Related
/// - [`ext_subgroup_size_control`]
/// - [`crate::vulkan1_3`]
/// - [`ShaderStageFlags`]
/// - [`StructureType`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkPhysicalDeviceSubgroupSizeControlProperties")]
#[derive(Debug, Clone, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[repr(C)]
pub struct PhysicalDeviceSubgroupSizeControlProperties<'lt> {
    ///Lifetime field
    pub _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] is the type of this structure.
    pub s_type: StructureType,
    ///[`p_next`] is `NULL` or a pointer to a structure extending this
    ///structure.
    pub p_next: *mut BaseOutStructure<'lt>,
    ///No documentation found
    pub min_subgroup_size: u32,
    ///No documentation found
    pub max_subgroup_size: u32,
    ///No documentation found
    pub max_compute_workgroup_subgroups: u32,
    ///No documentation found
    pub required_subgroup_size_stages: ShaderStageFlags,
}
impl<'lt> Default for PhysicalDeviceSubgroupSizeControlProperties<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: StructureType::PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES,
            p_next: std::ptr::null_mut(),
            min_subgroup_size: 0,
            max_subgroup_size: 0,
            max_compute_workgroup_subgroups: 0,
            required_subgroup_size_stages: Default::default(),
        }
    }
}
impl<'lt> PhysicalDeviceSubgroupSizeControlProperties<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *mut BaseOutStructure<'lt> {
        self.p_next
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *mut BaseOutStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn with_p_next_raw(mut self, value: *mut BaseOutStructure<'lt>) -> Self {
        self.p_next = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseOutStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::min_subgroup_size`]
    pub fn min_subgroup_size(&self) -> u32 {
        self.min_subgroup_size
    }
    ///Gets the value of [`Self::max_subgroup_size`]
    pub fn max_subgroup_size(&self) -> u32 {
        self.max_subgroup_size
    }
    ///Gets the value of [`Self::max_compute_workgroup_subgroups`]
    pub fn max_compute_workgroup_subgroups(&self) -> u32 {
        self.max_compute_workgroup_subgroups
    }
    ///Gets the value of [`Self::required_subgroup_size_stages`]
    pub fn required_subgroup_size_stages(&self) -> ShaderStageFlags {
        self.required_subgroup_size_stages
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next_mut(&mut self) -> &mut BaseOutStructure<'lt> {
        &mut *self.p_next
    }
    ///Gets a mutable reference to the value of [`Self::min_subgroup_size`]
    pub fn min_subgroup_size_mut(&mut self) -> &mut u32 {
        &mut self.min_subgroup_size
    }
    ///Gets a mutable reference to the value of [`Self::max_subgroup_size`]
    pub fn max_subgroup_size_mut(&mut self) -> &mut u32 {
        &mut self.max_subgroup_size
    }
    ///Gets a mutable reference to the value of [`Self::max_compute_workgroup_subgroups`]
    pub fn max_compute_workgroup_subgroups_mut(&mut self) -> &mut u32 {
        &mut self.max_compute_workgroup_subgroups
    }
    ///Gets a mutable reference to the value of [`Self::required_subgroup_size_stages`]
    pub fn required_subgroup_size_stages_mut(&mut self) -> &mut ShaderStageFlags {
        &mut self.required_subgroup_size_stages
    }
    ///Sets the value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt mut crate::vulkan1_0::BaseOutStructure<'lt>) -> &mut Self {
        self.p_next = value as *mut _;
        self
    }
    ///Sets the value of [`Self::min_subgroup_size`]
    pub fn set_min_subgroup_size(&mut self, value: u32) -> &mut Self {
        self.min_subgroup_size = value;
        self
    }
    ///Sets the value of [`Self::max_subgroup_size`]
    pub fn set_max_subgroup_size(&mut self, value: u32) -> &mut Self {
        self.max_subgroup_size = value;
        self
    }
    ///Sets the value of [`Self::max_compute_workgroup_subgroups`]
    pub fn set_max_compute_workgroup_subgroups(&mut self, value: u32) -> &mut Self {
        self.max_compute_workgroup_subgroups = value;
        self
    }
    ///Sets the value of [`Self::required_subgroup_size_stages`]
    pub fn set_required_subgroup_size_stages(&mut self, value: crate::vulkan1_0::ShaderStageFlags) -> &mut Self {
        self.required_subgroup_size_stages = value;
        self
    }
    ///Sets the value of [`Self::s_type`]
    pub fn with_s_type(mut self, value: crate::vulkan1_0::StructureType) -> Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn with_p_next(mut self, value: &'lt mut crate::vulkan1_0::BaseOutStructure<'lt>) -> Self {
        self.p_next = value as *mut _;
        self
    }
    ///Sets the value of [`Self::min_subgroup_size`]
    pub fn with_min_subgroup_size(mut self, value: u32) -> Self {
        self.min_subgroup_size = value;
        self
    }
    ///Sets the value of [`Self::max_subgroup_size`]
    pub fn with_max_subgroup_size(mut self, value: u32) -> Self {
        self.max_subgroup_size = value;
        self
    }
    ///Sets the value of [`Self::max_compute_workgroup_subgroups`]
    pub fn with_max_compute_workgroup_subgroups(mut self, value: u32) -> Self {
        self.max_compute_workgroup_subgroups = value;
        self
    }
    ///Sets the value of [`Self::required_subgroup_size_stages`]
    pub fn with_required_subgroup_size_stages(mut self, value: crate::vulkan1_0::ShaderStageFlags) -> Self {
        self.required_subgroup_size_stages = value;
        self
    }
}
///[VkPipelineShaderStageRequiredSubgroupSizeCreateInfo](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineShaderStageRequiredSubgroupSizeCreateInfo.html) - Structure specifying the required subgroup size of a newly created pipeline shader stage
///# C Specifications
///The [`PipelineShaderStageRequiredSubgroupSizeCreateInfo`] structure is
///defined as:
///```c
///// Provided by VK_VERSION_1_3
///typedef struct VkPipelineShaderStageRequiredSubgroupSizeCreateInfo {
///    VkStructureType    sType;
///    void*              pNext;
///    uint32_t           requiredSubgroupSize;
///} VkPipelineShaderStageRequiredSubgroupSizeCreateInfo;
///```
///or the equivalent
///```c
///// Provided by VK_EXT_subgroup_size_control
///typedef VkPipelineShaderStageRequiredSubgroupSizeCreateInfo
/// VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT;
///```
///# Members
/// - [`s_type`] is the type of this structure.
/// - [`p_next`] is `NULL` or a pointer to a structure extending this structure.
/// - [`required_subgroup_size`] is an unsigned integer value specifying the required subgroup size
///   for the newly created pipeline shader stage.
///# Description
///If a [`PipelineShaderStageRequiredSubgroupSizeCreateInfo`] structure is
///included in the [`p_next`] chain of [`PipelineShaderStageCreateInfo`],
///it specifies that the pipeline shader stage being compiled has a required
///subgroup size.
///## Valid Usage
/// - [`required_subgroup_size`] **must**  be a power-of-two integer
/// - [`required_subgroup_size`] **must**  be greater or equal to [minSubgroupSize](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#limits-minSubgroupSize)
/// - [`required_subgroup_size`] **must**  be less than or equal to [maxSubgroupSize](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#limits-maxSubgroupSize)
///
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be
///   `VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO`
///# Related
/// - [`ext_subgroup_size_control`]
/// - [`crate::vulkan1_3`]
/// - [`StructureType`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkPipelineShaderStageRequiredSubgroupSizeCreateInfo")]
#[derive(Debug, Clone, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[repr(C)]
pub struct PipelineShaderStageRequiredSubgroupSizeCreateInfo<'lt> {
    ///Lifetime field
    pub _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] is the type of this structure.
    pub s_type: StructureType,
    ///[`p_next`] is `NULL` or a pointer to a structure extending this
    ///structure.
    pub p_next: *mut BaseOutStructure<'lt>,
    ///[`required_subgroup_size`] is an
    ///unsigned integer value specifying the required subgroup size for the
    ///newly created pipeline shader stage.
    pub required_subgroup_size: u32,
}
impl<'lt> Default for PipelineShaderStageRequiredSubgroupSizeCreateInfo<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: StructureType::PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO,
            p_next: std::ptr::null_mut(),
            required_subgroup_size: 0,
        }
    }
}
impl<'lt> PipelineShaderStageRequiredSubgroupSizeCreateInfo<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *mut BaseOutStructure<'lt> {
        self.p_next
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *mut BaseOutStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn with_p_next_raw(mut self, value: *mut BaseOutStructure<'lt>) -> Self {
        self.p_next = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseOutStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::required_subgroup_size`]
    pub fn required_subgroup_size(&self) -> u32 {
        self.required_subgroup_size
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next_mut(&mut self) -> &mut BaseOutStructure<'lt> {
        &mut *self.p_next
    }
    ///Gets a mutable reference to the value of [`Self::required_subgroup_size`]
    pub fn required_subgroup_size_mut(&mut self) -> &mut u32 {
        &mut self.required_subgroup_size
    }
    ///Sets the value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt mut crate::vulkan1_0::BaseOutStructure<'lt>) -> &mut Self {
        self.p_next = value as *mut _;
        self
    }
    ///Sets the value of [`Self::required_subgroup_size`]
    pub fn set_required_subgroup_size(&mut self, value: u32) -> &mut Self {
        self.required_subgroup_size = value;
        self
    }
    ///Sets the value of [`Self::s_type`]
    pub fn with_s_type(mut self, value: crate::vulkan1_0::StructureType) -> Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn with_p_next(mut self, value: &'lt mut crate::vulkan1_0::BaseOutStructure<'lt>) -> Self {
        self.p_next = value as *mut _;
        self
    }
    ///Sets the value of [`Self::required_subgroup_size`]
    pub fn with_required_subgroup_size(mut self, value: u32) -> Self {
        self.required_subgroup_size = value;
        self
    }
}
///[VkPhysicalDevicePipelineCreationCacheControlFeatures](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePipelineCreationCacheControlFeatures.html) - Structure describing whether pipeline cache control can be supported by an implementation
///# C Specifications
///The [`PhysicalDevicePipelineCreationCacheControlFeatures`] structure is
///defined as:
///```c
///// Provided by VK_VERSION_1_3
///typedef struct VkPhysicalDevicePipelineCreationCacheControlFeatures {
///    VkStructureType    sType;
///    void*              pNext;
///    VkBool32           pipelineCreationCacheControl;
///} VkPhysicalDevicePipelineCreationCacheControlFeatures;
///```
///or the equivalent
///```c
///// Provided by VK_EXT_pipeline_creation_cache_control
///typedef VkPhysicalDevicePipelineCreationCacheControlFeatures
/// VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT;
///```
///# Members
///This structure describes the following feature:
///# Description
/// - [`s_type`] is the type of this structure.
/// - [`p_next`] is `NULL` or a pointer to a structure extending this structure.
///
/// - [`pipeline_creation_cache_control`] indicates that the implementation supports:  - The
///   following  **can**  be used in `Vk*PipelineCreateInfo`::`flags`:   -
///   `VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT`   -
///   `VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT`   - The following  **can**  be used in
///   [`PipelineCacheCreateInfo::flags`]:   - `VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT`
///If the [`PhysicalDevicePipelineCreationCacheControlFeatures`] structure is included in the
/// [`p_next`] chain of the
///[`PhysicalDeviceFeatures2`] structure passed to
///[`get_physical_device_features2`], it is filled in to indicate whether each
///corresponding feature is supported.
///[`PhysicalDevicePipelineCreationCacheControlFeatures`] **can**  also be used in the [`p_next`]
/// chain of
///[`DeviceCreateInfo`] to selectively enable these features.
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be
///   `VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES`
///# Related
/// - [`ext_pipeline_creation_cache_control`]
/// - [`crate::vulkan1_3`]
/// - [`Bool32`]
/// - [`StructureType`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkPhysicalDevicePipelineCreationCacheControlFeatures")]
#[derive(Debug, Clone, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[repr(C)]
pub struct PhysicalDevicePipelineCreationCacheControlFeatures<'lt> {
    ///Lifetime field
    pub _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] is the type of this structure.
    pub s_type: StructureType,
    ///[`p_next`] is `NULL` or a pointer to a structure extending this
    ///structure.
    pub p_next: *mut BaseOutStructure<'lt>,
    ///[`pipeline_creation_cache_control`] indicates that the implementation
    ///supports:
    /// - The following  **can**  be used in `Vk*PipelineCreateInfo`::`flags`:   -
    ///   `VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT`   -
    ///   `VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT`
    /// - The following  **can**  be used in [`PipelineCacheCreateInfo`]::`flags`:   -
    ///   `VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT`
    pub pipeline_creation_cache_control: Bool32,
}
impl<'lt> Default for PhysicalDevicePipelineCreationCacheControlFeatures<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: StructureType::PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES,
            p_next: std::ptr::null_mut(),
            pipeline_creation_cache_control: 0,
        }
    }
}
impl<'lt> PhysicalDevicePipelineCreationCacheControlFeatures<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *mut BaseOutStructure<'lt> {
        self.p_next
    }
    ///Gets the raw value of [`Self::pipeline_creation_cache_control`]
    pub fn pipeline_creation_cache_control_raw(&self) -> Bool32 {
        self.pipeline_creation_cache_control
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *mut BaseOutStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::pipeline_creation_cache_control`]
    pub fn set_pipeline_creation_cache_control_raw(&mut self, value: Bool32) -> &mut Self {
        self.pipeline_creation_cache_control = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn with_p_next_raw(mut self, value: *mut BaseOutStructure<'lt>) -> Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::pipeline_creation_cache_control`]
    pub fn with_pipeline_creation_cache_control_raw(mut self, value: Bool32) -> Self {
        self.pipeline_creation_cache_control = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseOutStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::pipeline_creation_cache_control`]
    pub fn pipeline_creation_cache_control(&self) -> bool {
        unsafe { std::mem::transmute(self.pipeline_creation_cache_control as u8) }
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next_mut(&mut self) -> &mut BaseOutStructure<'lt> {
        &mut *self.p_next
    }
    ///Gets a mutable reference to the value of [`Self::pipeline_creation_cache_control`]
    pub fn pipeline_creation_cache_control_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.pipeline_creation_cache_control as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.pipeline_creation_cache_control as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Sets the value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt mut crate::vulkan1_0::BaseOutStructure<'lt>) -> &mut Self {
        self.p_next = value as *mut _;
        self
    }
    ///Sets the value of [`Self::pipeline_creation_cache_control`]
    pub fn set_pipeline_creation_cache_control(&mut self, value: bool) -> &mut Self {
        self.pipeline_creation_cache_control = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::s_type`]
    pub fn with_s_type(mut self, value: crate::vulkan1_0::StructureType) -> Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn with_p_next(mut self, value: &'lt mut crate::vulkan1_0::BaseOutStructure<'lt>) -> Self {
        self.p_next = value as *mut _;
        self
    }
    ///Sets the value of [`Self::pipeline_creation_cache_control`]
    pub fn with_pipeline_creation_cache_control(mut self, value: bool) -> Self {
        self.pipeline_creation_cache_control = value as u8 as u32;
        self
    }
}
///[VkPhysicalDeviceVulkan13Features](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan13Features.html) - Structure describing the Vulkan 1.3 features that can be supported by an implementation
///# C Specifications
///The [`PhysicalDeviceVulkan13Features`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_3
///typedef struct VkPhysicalDeviceVulkan13Features {
///    VkStructureType    sType;
///    void*              pNext;
///    VkBool32           robustImageAccess;
///    VkBool32           inlineUniformBlock;
///    VkBool32           descriptorBindingInlineUniformBlockUpdateAfterBind;
///    VkBool32           pipelineCreationCacheControl;
///    VkBool32           privateData;
///    VkBool32           shaderDemoteToHelperInvocation;
///    VkBool32           shaderTerminateInvocation;
///    VkBool32           subgroupSizeControl;
///    VkBool32           computeFullSubgroups;
///    VkBool32           synchronization2;
///    VkBool32           textureCompressionASTC_HDR;
///    VkBool32           shaderZeroInitializeWorkgroupMemory;
///    VkBool32           dynamicRendering;
///    VkBool32           shaderIntegerDotProduct;
///    VkBool32           maintenance4;
///} VkPhysicalDeviceVulkan13Features;
///```
///# Members
///This structure describes the following features:
///# Description
/// - [`s_type`] is the type of this structure.
/// - [`p_next`] is `NULL` or a pointer to a structure extending this structure.
///
/// - [`robust_image_access`] indicates whether image accesses are tightly bounds-checked against
///   the dimensions of the image view. [Invalid texels]() resulting from out of bounds image loads
///   will be replaced as described in [Texel Replacement](), with either (0,0,1) or (0,0,0) values
///   inserted for missing G, B, or A components based on the format.
/// - [`inline_uniform_block`] indicates whether the implementation supports inline uniform block
///   descriptors. If this feature is not enabled, `VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK`
///   **must**  not be used.
/// - [`descriptor_binding_inline_uniform_block_update_after_bind`] indicates whether the
///   implementation supports updating inline uniform block descriptors after a set is bound. If
///   this feature is not enabled, `VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT` **must**  not be
///   used with `VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK`.
/// - [`pipeline_creation_cache_control`] indicates that the implementation supports:  - The
///   following  **can**  be used in `Vk*PipelineCreateInfo`::`flags`:   -
///   `VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT`   -
///   `VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT`   - The following  **can**  be used in
///   [`PipelineCacheCreateInfo::flags`]:   - `VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT`
/// - [`private_data`] indicates whether the implementation supports private data. See [Private
///   Data]().
/// - [`shader_demote_to_helper_invocation`] indicates whether the implementation supports the
///   SPIR-V `DemoteToHelperInvocationEXT` capability.
/// - [`shader_terminate_invocation`] specifies whether the implementation supports SPIR-V modules
///   that use the `SPV_KHR_terminate_invocation` extension.
/// - [`subgroup_size_control`] indicates whether the implementation supports controlling shader
///   subgroup sizes via the `VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT` flag
///   and the [`PipelineShaderStageRequiredSubgroupSizeCreateInfo`] structure.
/// - [`compute_full_subgroups`] indicates whether the implementation supports requiring full
///   subgroups in compute shaders via the
///   `VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT` flag.
/// - [`synchronization2`] indicates whether the implementation supports the new set of
///   synchronization commands introduced in `[`khr_synchronization2`]`.
/// - [`texture_compression_astc_hdr`] indicates whether all of the ASTC HDR compressed texture
///   formats are supported. If this feature is enabled, then the
///   `VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT`, `VK_FORMAT_FEATURE_BLIT_SRC_BIT` and
///   `VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT` features  **must**  be supported in
///   `optimalTilingFeatures` for the following formats:  - `VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK`  -
///   `VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK`  - `VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK`  -
///   `VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK`  - `VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK`  -
///   `VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK`  - `VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK`  -
///   `VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK`  - `VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK`  -
///   `VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK`  - `VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK`  -
///   `VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK`  - `VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK`  -
///   `VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK` To query for additional properties, or if the feature is
///   not enabled, [`get_physical_device_format_properties`] and
///   [`get_physical_device_image_format_properties`] **can**  be used to check for supported
///   properties of individual formats as normal.
/// - [`shader_zero_initialize_workgroup_memory`] specifies whether the implementation supports
///   initializing a variable in Workgroup storage class.
/// - [`dynamic_rendering`] specifies that the implementation supports dynamic render pass instances
///   using the [`cmd_begin_rendering`] command.
/// - [`shader_integer_dot_product`] specifies whether shader modules  **can**  declare the
///   `DotProductInputAllKHR`, `DotProductInput4x8BitKHR`, `DotProductInput4x8BitPackedKHR` and
///   `DotProductKHR` capabilities.
/// - [`maintenance4`] indicates that the implementation supports the following:  - The application
///   **may**  destroy a [`PipelineLayout`] object immediately after using it to create another
///   object.  - `LocalSizeId` **can**  be used as an alternative to `LocalSize` to specify the
///   local workgroup size with specialization constants.  - Images created with identical creation
///   parameters will always have the same alignment requirements.  - The size memory requirement of
///   a buffer or image is never greater than that of another buffer or image created with a greater
///   or equal size.  - Push constants do not have to be initialized before they are dynamically
///   accessed.  - The interface matching rules allow a larger output vector to match with a smaller
///   input vector, with additional values being discarded.
///If the [`PhysicalDeviceVulkan13Features`] structure is included in the [`p_next`] chain of the
///[`PhysicalDeviceFeatures2`] structure passed to
///[`get_physical_device_features2`], it is filled in to indicate whether each
///corresponding feature is supported.
///[`PhysicalDeviceVulkan13Features`] **can**  also be used in the [`p_next`] chain of
///[`DeviceCreateInfo`] to selectively enable these features.
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be `VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES`
///# Related
/// - [`crate::vulkan1_3`]
/// - [`Bool32`]
/// - [`StructureType`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkPhysicalDeviceVulkan13Features")]
#[derive(Debug, Clone, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[repr(C)]
pub struct PhysicalDeviceVulkan13Features<'lt> {
    ///Lifetime field
    pub _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] is the type of this structure.
    pub s_type: StructureType,
    ///[`p_next`] is `NULL` or a pointer to a structure extending this
    ///structure.
    pub p_next: *mut BaseOutStructure<'lt>,
    ///[`robust_image_access`]
    ///indicates whether image accesses are tightly bounds-checked against the
    ///dimensions of the image view.
    ///[Invalid texels]() resulting from out of
    ///bounds image loads will be replaced as described in
    ///[Texel Replacement](), with either
    ///(0,0,1) or (0,0,0) values inserted for missing G, B, or A
    ///components based on the format.
    pub robust_image_access: Bool32,
    ///[`inline_uniform_block`]
    ///indicates whether the implementation supports inline uniform block
    ///descriptors.
    ///If this feature is not enabled,
    ///`VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK` **must**  not be used.
    pub inline_uniform_block: Bool32,
    ///[`descriptor_binding_inline_uniform_block_update_after_bind`]
    ///indicates whether the implementation supports updating inline uniform
    ///block descriptors after a set is bound.
    ///If this feature is not enabled,
    ///`VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT` **must**  not be used with
    ///`VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK`.
    pub descriptor_binding_inline_uniform_block_update_after_bind: Bool32,
    ///[`pipeline_creation_cache_control`] indicates that the implementation
    ///supports:
    /// - The following  **can**  be used in `Vk*PipelineCreateInfo`::`flags`:   -
    ///   `VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT`   -
    ///   `VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT`
    /// - The following  **can**  be used in [`PipelineCacheCreateInfo`]::`flags`:   -
    ///   `VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT`
    pub pipeline_creation_cache_control: Bool32,
    ///[`private_data`] indicates
    ///whether the implementation supports private data.
    ///See [Private Data]().
    pub private_data: Bool32,
    ///[`shader_demote_to_helper_invocation`] indicates whether the
    ///implementation supports the SPIR-V `DemoteToHelperInvocationEXT`
    ///capability.
    pub shader_demote_to_helper_invocation: Bool32,
    ///[`shader_terminate_invocation`] specifies whether the implementation
    ///supports SPIR-V modules that use the `SPV_KHR_terminate_invocation`
    ///extension.
    pub shader_terminate_invocation: Bool32,
    ///[`subgroup_size_control`] indicates whether the implementation supports
    ///controlling shader subgroup sizes via the
    ///`VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT`
    ///flag and the [`PipelineShaderStageRequiredSubgroupSizeCreateInfo`]
    ///structure.
    pub subgroup_size_control: Bool32,
    ///[`compute_full_subgroups`] indicates whether the implementation supports
    ///requiring full subgroups in compute shaders via the
    ///`VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT` flag.
    pub compute_full_subgroups: Bool32,
    ///[`synchronization2`]
    ///indicates whether the implementation supports the new set of
    ///synchronization commands introduced in `[`khr_synchronization2`]`.
    pub synchronization2: Bool32,
    ///[`texture_compression_astc_hdr`] indicates whether all of the ASTC HDR
    ///compressed texture formats are supported.
    ///If this feature is enabled, then the
    ///`VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT`,
    ///`VK_FORMAT_FEATURE_BLIT_SRC_BIT` and
    ///`VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT` features  **must**
    ///be supported in `optimalTilingFeatures` for the following formats:
    /// - `VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK`
    /// - `VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK`
    /// - `VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK`
    /// - `VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK`
    /// - `VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK`
    /// - `VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK`
    /// - `VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK`
    /// - `VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK`
    /// - `VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK`
    /// - `VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK`
    /// - `VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK`
    /// - `VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK`
    /// - `VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK`
    /// - `VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK`
    ///To query for additional properties, or if the feature is not enabled,
    ///[`get_physical_device_format_properties`] and
    ///[`get_physical_device_image_format_properties`] **can**  be used to check for
    ///supported properties of individual formats as normal.
    pub texture_compression_astc_hdr: Bool32,
    ///[`shader_zero_initialize_workgroup_memory`] specifies whether the
    ///implementation supports initializing a variable in Workgroup storage
    ///class.
    pub shader_zero_initialize_workgroup_memory: Bool32,
    ///[`dynamic_rendering`]
    ///specifies that the implementation supports dynamic render pass instances
    ///using the [`cmd_begin_rendering`] command.
    pub dynamic_rendering: Bool32,
    ///[`shader_integer_dot_product`] specifies whether shader modules  **can**
    ///declare the `DotProductInputAllKHR`, `DotProductInput4x8BitKHR`,
    ///`DotProductInput4x8BitPackedKHR` and `DotProductKHR` capabilities.
    pub shader_integer_dot_product: Bool32,
    ///[`maintenance4`] indicates
    ///that the implementation supports the following:
    /// - The application  **may**  destroy a [`PipelineLayout`] object immediately after using it
    ///   to create another object.
    /// - `LocalSizeId` **can**  be used as an alternative to `LocalSize` to specify the local
    ///   workgroup size with specialization constants.
    /// - Images created with identical creation parameters will always have the same alignment
    ///   requirements.
    /// - The size memory requirement of a buffer or image is never greater than that of another
    ///   buffer or image created with a greater or equal size.
    /// - Push constants do not have to be initialized before they are dynamically accessed.
    /// - The interface matching rules allow a larger output vector to match with a smaller input
    ///   vector, with additional values being discarded.
    pub maintenance4: Bool32,
}
impl<'lt> Default for PhysicalDeviceVulkan13Features<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: StructureType::PHYSICAL_DEVICE_VULKAN1_3_FEATURES,
            p_next: std::ptr::null_mut(),
            robust_image_access: 0,
            inline_uniform_block: 0,
            descriptor_binding_inline_uniform_block_update_after_bind: 0,
            pipeline_creation_cache_control: 0,
            private_data: 0,
            shader_demote_to_helper_invocation: 0,
            shader_terminate_invocation: 0,
            subgroup_size_control: 0,
            compute_full_subgroups: 0,
            synchronization2: 0,
            texture_compression_astc_hdr: 0,
            shader_zero_initialize_workgroup_memory: 0,
            dynamic_rendering: 0,
            shader_integer_dot_product: 0,
            maintenance4: 0,
        }
    }
}
impl<'lt> PhysicalDeviceVulkan13Features<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *mut BaseOutStructure<'lt> {
        self.p_next
    }
    ///Gets the raw value of [`Self::robust_image_access`]
    pub fn robust_image_access_raw(&self) -> Bool32 {
        self.robust_image_access
    }
    ///Gets the raw value of [`Self::inline_uniform_block`]
    pub fn inline_uniform_block_raw(&self) -> Bool32 {
        self.inline_uniform_block
    }
    ///Gets the raw value of [`Self::descriptor_binding_inline_uniform_block_update_after_bind`]
    pub fn descriptor_binding_inline_uniform_block_update_after_bind_raw(&self) -> Bool32 {
        self.descriptor_binding_inline_uniform_block_update_after_bind
    }
    ///Gets the raw value of [`Self::pipeline_creation_cache_control`]
    pub fn pipeline_creation_cache_control_raw(&self) -> Bool32 {
        self.pipeline_creation_cache_control
    }
    ///Gets the raw value of [`Self::private_data`]
    pub fn private_data_raw(&self) -> Bool32 {
        self.private_data
    }
    ///Gets the raw value of [`Self::shader_demote_to_helper_invocation`]
    pub fn shader_demote_to_helper_invocation_raw(&self) -> Bool32 {
        self.shader_demote_to_helper_invocation
    }
    ///Gets the raw value of [`Self::shader_terminate_invocation`]
    pub fn shader_terminate_invocation_raw(&self) -> Bool32 {
        self.shader_terminate_invocation
    }
    ///Gets the raw value of [`Self::subgroup_size_control`]
    pub fn subgroup_size_control_raw(&self) -> Bool32 {
        self.subgroup_size_control
    }
    ///Gets the raw value of [`Self::compute_full_subgroups`]
    pub fn compute_full_subgroups_raw(&self) -> Bool32 {
        self.compute_full_subgroups
    }
    ///Gets the raw value of [`Self::synchronization2`]
    pub fn synchronization2_raw(&self) -> Bool32 {
        self.synchronization2
    }
    ///Gets the raw value of [`Self::texture_compression_astc_hdr`]
    pub fn texture_compression_astc_hdr_raw(&self) -> Bool32 {
        self.texture_compression_astc_hdr
    }
    ///Gets the raw value of [`Self::shader_zero_initialize_workgroup_memory`]
    pub fn shader_zero_initialize_workgroup_memory_raw(&self) -> Bool32 {
        self.shader_zero_initialize_workgroup_memory
    }
    ///Gets the raw value of [`Self::dynamic_rendering`]
    pub fn dynamic_rendering_raw(&self) -> Bool32 {
        self.dynamic_rendering
    }
    ///Gets the raw value of [`Self::shader_integer_dot_product`]
    pub fn shader_integer_dot_product_raw(&self) -> Bool32 {
        self.shader_integer_dot_product
    }
    ///Gets the raw value of [`Self::maintenance4`]
    pub fn maintenance4_raw(&self) -> Bool32 {
        self.maintenance4
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *mut BaseOutStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::robust_image_access`]
    pub fn set_robust_image_access_raw(&mut self, value: Bool32) -> &mut Self {
        self.robust_image_access = value;
        self
    }
    ///Sets the raw value of [`Self::inline_uniform_block`]
    pub fn set_inline_uniform_block_raw(&mut self, value: Bool32) -> &mut Self {
        self.inline_uniform_block = value;
        self
    }
    ///Sets the raw value of [`Self::descriptor_binding_inline_uniform_block_update_after_bind`]
    pub fn set_descriptor_binding_inline_uniform_block_update_after_bind_raw(&mut self, value: Bool32) -> &mut Self {
        self.descriptor_binding_inline_uniform_block_update_after_bind = value;
        self
    }
    ///Sets the raw value of [`Self::pipeline_creation_cache_control`]
    pub fn set_pipeline_creation_cache_control_raw(&mut self, value: Bool32) -> &mut Self {
        self.pipeline_creation_cache_control = value;
        self
    }
    ///Sets the raw value of [`Self::private_data`]
    pub fn set_private_data_raw(&mut self, value: Bool32) -> &mut Self {
        self.private_data = value;
        self
    }
    ///Sets the raw value of [`Self::shader_demote_to_helper_invocation`]
    pub fn set_shader_demote_to_helper_invocation_raw(&mut self, value: Bool32) -> &mut Self {
        self.shader_demote_to_helper_invocation = value;
        self
    }
    ///Sets the raw value of [`Self::shader_terminate_invocation`]
    pub fn set_shader_terminate_invocation_raw(&mut self, value: Bool32) -> &mut Self {
        self.shader_terminate_invocation = value;
        self
    }
    ///Sets the raw value of [`Self::subgroup_size_control`]
    pub fn set_subgroup_size_control_raw(&mut self, value: Bool32) -> &mut Self {
        self.subgroup_size_control = value;
        self
    }
    ///Sets the raw value of [`Self::compute_full_subgroups`]
    pub fn set_compute_full_subgroups_raw(&mut self, value: Bool32) -> &mut Self {
        self.compute_full_subgroups = value;
        self
    }
    ///Sets the raw value of [`Self::synchronization2`]
    pub fn set_synchronization2_raw(&mut self, value: Bool32) -> &mut Self {
        self.synchronization2 = value;
        self
    }
    ///Sets the raw value of [`Self::texture_compression_astc_hdr`]
    pub fn set_texture_compression_astc_hdr_raw(&mut self, value: Bool32) -> &mut Self {
        self.texture_compression_astc_hdr = value;
        self
    }
    ///Sets the raw value of [`Self::shader_zero_initialize_workgroup_memory`]
    pub fn set_shader_zero_initialize_workgroup_memory_raw(&mut self, value: Bool32) -> &mut Self {
        self.shader_zero_initialize_workgroup_memory = value;
        self
    }
    ///Sets the raw value of [`Self::dynamic_rendering`]
    pub fn set_dynamic_rendering_raw(&mut self, value: Bool32) -> &mut Self {
        self.dynamic_rendering = value;
        self
    }
    ///Sets the raw value of [`Self::shader_integer_dot_product`]
    pub fn set_shader_integer_dot_product_raw(&mut self, value: Bool32) -> &mut Self {
        self.shader_integer_dot_product = value;
        self
    }
    ///Sets the raw value of [`Self::maintenance4`]
    pub fn set_maintenance4_raw(&mut self, value: Bool32) -> &mut Self {
        self.maintenance4 = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn with_p_next_raw(mut self, value: *mut BaseOutStructure<'lt>) -> Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::robust_image_access`]
    pub fn with_robust_image_access_raw(mut self, value: Bool32) -> Self {
        self.robust_image_access = value;
        self
    }
    ///Sets the raw value of [`Self::inline_uniform_block`]
    pub fn with_inline_uniform_block_raw(mut self, value: Bool32) -> Self {
        self.inline_uniform_block = value;
        self
    }
    ///Sets the raw value of [`Self::descriptor_binding_inline_uniform_block_update_after_bind`]
    pub fn with_descriptor_binding_inline_uniform_block_update_after_bind_raw(mut self, value: Bool32) -> Self {
        self.descriptor_binding_inline_uniform_block_update_after_bind = value;
        self
    }
    ///Sets the raw value of [`Self::pipeline_creation_cache_control`]
    pub fn with_pipeline_creation_cache_control_raw(mut self, value: Bool32) -> Self {
        self.pipeline_creation_cache_control = value;
        self
    }
    ///Sets the raw value of [`Self::private_data`]
    pub fn with_private_data_raw(mut self, value: Bool32) -> Self {
        self.private_data = value;
        self
    }
    ///Sets the raw value of [`Self::shader_demote_to_helper_invocation`]
    pub fn with_shader_demote_to_helper_invocation_raw(mut self, value: Bool32) -> Self {
        self.shader_demote_to_helper_invocation = value;
        self
    }
    ///Sets the raw value of [`Self::shader_terminate_invocation`]
    pub fn with_shader_terminate_invocation_raw(mut self, value: Bool32) -> Self {
        self.shader_terminate_invocation = value;
        self
    }
    ///Sets the raw value of [`Self::subgroup_size_control`]
    pub fn with_subgroup_size_control_raw(mut self, value: Bool32) -> Self {
        self.subgroup_size_control = value;
        self
    }
    ///Sets the raw value of [`Self::compute_full_subgroups`]
    pub fn with_compute_full_subgroups_raw(mut self, value: Bool32) -> Self {
        self.compute_full_subgroups = value;
        self
    }
    ///Sets the raw value of [`Self::synchronization2`]
    pub fn with_synchronization2_raw(mut self, value: Bool32) -> Self {
        self.synchronization2 = value;
        self
    }
    ///Sets the raw value of [`Self::texture_compression_astc_hdr`]
    pub fn with_texture_compression_astc_hdr_raw(mut self, value: Bool32) -> Self {
        self.texture_compression_astc_hdr = value;
        self
    }
    ///Sets the raw value of [`Self::shader_zero_initialize_workgroup_memory`]
    pub fn with_shader_zero_initialize_workgroup_memory_raw(mut self, value: Bool32) -> Self {
        self.shader_zero_initialize_workgroup_memory = value;
        self
    }
    ///Sets the raw value of [`Self::dynamic_rendering`]
    pub fn with_dynamic_rendering_raw(mut self, value: Bool32) -> Self {
        self.dynamic_rendering = value;
        self
    }
    ///Sets the raw value of [`Self::shader_integer_dot_product`]
    pub fn with_shader_integer_dot_product_raw(mut self, value: Bool32) -> Self {
        self.shader_integer_dot_product = value;
        self
    }
    ///Sets the raw value of [`Self::maintenance4`]
    pub fn with_maintenance4_raw(mut self, value: Bool32) -> Self {
        self.maintenance4 = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseOutStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::robust_image_access`]
    pub fn robust_image_access(&self) -> bool {
        unsafe { std::mem::transmute(self.robust_image_access as u8) }
    }
    ///Gets the value of [`Self::inline_uniform_block`]
    pub fn inline_uniform_block(&self) -> bool {
        unsafe { std::mem::transmute(self.inline_uniform_block as u8) }
    }
    ///Gets the value of [`Self::descriptor_binding_inline_uniform_block_update_after_bind`]
    pub fn descriptor_binding_inline_uniform_block_update_after_bind(&self) -> bool {
        unsafe { std::mem::transmute(self.descriptor_binding_inline_uniform_block_update_after_bind as u8) }
    }
    ///Gets the value of [`Self::pipeline_creation_cache_control`]
    pub fn pipeline_creation_cache_control(&self) -> bool {
        unsafe { std::mem::transmute(self.pipeline_creation_cache_control as u8) }
    }
    ///Gets the value of [`Self::private_data`]
    pub fn private_data(&self) -> bool {
        unsafe { std::mem::transmute(self.private_data as u8) }
    }
    ///Gets the value of [`Self::shader_demote_to_helper_invocation`]
    pub fn shader_demote_to_helper_invocation(&self) -> bool {
        unsafe { std::mem::transmute(self.shader_demote_to_helper_invocation as u8) }
    }
    ///Gets the value of [`Self::shader_terminate_invocation`]
    pub fn shader_terminate_invocation(&self) -> bool {
        unsafe { std::mem::transmute(self.shader_terminate_invocation as u8) }
    }
    ///Gets the value of [`Self::subgroup_size_control`]
    pub fn subgroup_size_control(&self) -> bool {
        unsafe { std::mem::transmute(self.subgroup_size_control as u8) }
    }
    ///Gets the value of [`Self::compute_full_subgroups`]
    pub fn compute_full_subgroups(&self) -> bool {
        unsafe { std::mem::transmute(self.compute_full_subgroups as u8) }
    }
    ///Gets the value of [`Self::synchronization2`]
    pub fn synchronization2(&self) -> bool {
        unsafe { std::mem::transmute(self.synchronization2 as u8) }
    }
    ///Gets the value of [`Self::texture_compression_astc_hdr`]
    pub fn texture_compression_astc_hdr(&self) -> bool {
        unsafe { std::mem::transmute(self.texture_compression_astc_hdr as u8) }
    }
    ///Gets the value of [`Self::shader_zero_initialize_workgroup_memory`]
    pub fn shader_zero_initialize_workgroup_memory(&self) -> bool {
        unsafe { std::mem::transmute(self.shader_zero_initialize_workgroup_memory as u8) }
    }
    ///Gets the value of [`Self::dynamic_rendering`]
    pub fn dynamic_rendering(&self) -> bool {
        unsafe { std::mem::transmute(self.dynamic_rendering as u8) }
    }
    ///Gets the value of [`Self::shader_integer_dot_product`]
    pub fn shader_integer_dot_product(&self) -> bool {
        unsafe { std::mem::transmute(self.shader_integer_dot_product as u8) }
    }
    ///Gets the value of [`Self::maintenance4`]
    pub fn maintenance4(&self) -> bool {
        unsafe { std::mem::transmute(self.maintenance4 as u8) }
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next_mut(&mut self) -> &mut BaseOutStructure<'lt> {
        &mut *self.p_next
    }
    ///Gets a mutable reference to the value of [`Self::robust_image_access`]
    pub fn robust_image_access_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.robust_image_access as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.robust_image_access as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of [`Self::inline_uniform_block`]
    pub fn inline_uniform_block_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.inline_uniform_block as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.inline_uniform_block as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of
    /// [`Self::descriptor_binding_inline_uniform_block_update_after_bind`]
    pub fn descriptor_binding_inline_uniform_block_update_after_bind_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.descriptor_binding_inline_uniform_block_update_after_bind as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.descriptor_binding_inline_uniform_block_update_after_bind as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of [`Self::pipeline_creation_cache_control`]
    pub fn pipeline_creation_cache_control_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.pipeline_creation_cache_control as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.pipeline_creation_cache_control as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of [`Self::private_data`]
    pub fn private_data_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.private_data as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.private_data as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of [`Self::shader_demote_to_helper_invocation`]
    pub fn shader_demote_to_helper_invocation_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.shader_demote_to_helper_invocation as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.shader_demote_to_helper_invocation as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of [`Self::shader_terminate_invocation`]
    pub fn shader_terminate_invocation_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.shader_terminate_invocation as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.shader_terminate_invocation as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of [`Self::subgroup_size_control`]
    pub fn subgroup_size_control_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.subgroup_size_control as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.subgroup_size_control as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of [`Self::compute_full_subgroups`]
    pub fn compute_full_subgroups_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.compute_full_subgroups as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.compute_full_subgroups as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of [`Self::synchronization2`]
    pub fn synchronization2_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.synchronization2 as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.synchronization2 as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of [`Self::texture_compression_astc_hdr`]
    pub fn texture_compression_astc_hdr_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.texture_compression_astc_hdr as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.texture_compression_astc_hdr as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of [`Self::shader_zero_initialize_workgroup_memory`]
    pub fn shader_zero_initialize_workgroup_memory_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.shader_zero_initialize_workgroup_memory as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.shader_zero_initialize_workgroup_memory as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of [`Self::dynamic_rendering`]
    pub fn dynamic_rendering_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.dynamic_rendering as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.dynamic_rendering as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of [`Self::shader_integer_dot_product`]
    pub fn shader_integer_dot_product_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.shader_integer_dot_product as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.shader_integer_dot_product as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of [`Self::maintenance4`]
    pub fn maintenance4_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.maintenance4 as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.maintenance4 as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Sets the value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt mut crate::vulkan1_0::BaseOutStructure<'lt>) -> &mut Self {
        self.p_next = value as *mut _;
        self
    }
    ///Sets the value of [`Self::robust_image_access`]
    pub fn set_robust_image_access(&mut self, value: bool) -> &mut Self {
        self.robust_image_access = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::inline_uniform_block`]
    pub fn set_inline_uniform_block(&mut self, value: bool) -> &mut Self {
        self.inline_uniform_block = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::descriptor_binding_inline_uniform_block_update_after_bind`]
    pub fn set_descriptor_binding_inline_uniform_block_update_after_bind(&mut self, value: bool) -> &mut Self {
        self.descriptor_binding_inline_uniform_block_update_after_bind = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::pipeline_creation_cache_control`]
    pub fn set_pipeline_creation_cache_control(&mut self, value: bool) -> &mut Self {
        self.pipeline_creation_cache_control = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::private_data`]
    pub fn set_private_data(&mut self, value: bool) -> &mut Self {
        self.private_data = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::shader_demote_to_helper_invocation`]
    pub fn set_shader_demote_to_helper_invocation(&mut self, value: bool) -> &mut Self {
        self.shader_demote_to_helper_invocation = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::shader_terminate_invocation`]
    pub fn set_shader_terminate_invocation(&mut self, value: bool) -> &mut Self {
        self.shader_terminate_invocation = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::subgroup_size_control`]
    pub fn set_subgroup_size_control(&mut self, value: bool) -> &mut Self {
        self.subgroup_size_control = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::compute_full_subgroups`]
    pub fn set_compute_full_subgroups(&mut self, value: bool) -> &mut Self {
        self.compute_full_subgroups = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::synchronization2`]
    pub fn set_synchronization2(&mut self, value: bool) -> &mut Self {
        self.synchronization2 = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::texture_compression_astc_hdr`]
    pub fn set_texture_compression_astc_hdr(&mut self, value: bool) -> &mut Self {
        self.texture_compression_astc_hdr = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::shader_zero_initialize_workgroup_memory`]
    pub fn set_shader_zero_initialize_workgroup_memory(&mut self, value: bool) -> &mut Self {
        self.shader_zero_initialize_workgroup_memory = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::dynamic_rendering`]
    pub fn set_dynamic_rendering(&mut self, value: bool) -> &mut Self {
        self.dynamic_rendering = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::shader_integer_dot_product`]
    pub fn set_shader_integer_dot_product(&mut self, value: bool) -> &mut Self {
        self.shader_integer_dot_product = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::maintenance4`]
    pub fn set_maintenance4(&mut self, value: bool) -> &mut Self {
        self.maintenance4 = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::s_type`]
    pub fn with_s_type(mut self, value: crate::vulkan1_0::StructureType) -> Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn with_p_next(mut self, value: &'lt mut crate::vulkan1_0::BaseOutStructure<'lt>) -> Self {
        self.p_next = value as *mut _;
        self
    }
    ///Sets the value of [`Self::robust_image_access`]
    pub fn with_robust_image_access(mut self, value: bool) -> Self {
        self.robust_image_access = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::inline_uniform_block`]
    pub fn with_inline_uniform_block(mut self, value: bool) -> Self {
        self.inline_uniform_block = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::descriptor_binding_inline_uniform_block_update_after_bind`]
    pub fn with_descriptor_binding_inline_uniform_block_update_after_bind(mut self, value: bool) -> Self {
        self.descriptor_binding_inline_uniform_block_update_after_bind = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::pipeline_creation_cache_control`]
    pub fn with_pipeline_creation_cache_control(mut self, value: bool) -> Self {
        self.pipeline_creation_cache_control = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::private_data`]
    pub fn with_private_data(mut self, value: bool) -> Self {
        self.private_data = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::shader_demote_to_helper_invocation`]
    pub fn with_shader_demote_to_helper_invocation(mut self, value: bool) -> Self {
        self.shader_demote_to_helper_invocation = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::shader_terminate_invocation`]
    pub fn with_shader_terminate_invocation(mut self, value: bool) -> Self {
        self.shader_terminate_invocation = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::subgroup_size_control`]
    pub fn with_subgroup_size_control(mut self, value: bool) -> Self {
        self.subgroup_size_control = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::compute_full_subgroups`]
    pub fn with_compute_full_subgroups(mut self, value: bool) -> Self {
        self.compute_full_subgroups = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::synchronization2`]
    pub fn with_synchronization2(mut self, value: bool) -> Self {
        self.synchronization2 = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::texture_compression_astc_hdr`]
    pub fn with_texture_compression_astc_hdr(mut self, value: bool) -> Self {
        self.texture_compression_astc_hdr = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::shader_zero_initialize_workgroup_memory`]
    pub fn with_shader_zero_initialize_workgroup_memory(mut self, value: bool) -> Self {
        self.shader_zero_initialize_workgroup_memory = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::dynamic_rendering`]
    pub fn with_dynamic_rendering(mut self, value: bool) -> Self {
        self.dynamic_rendering = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::shader_integer_dot_product`]
    pub fn with_shader_integer_dot_product(mut self, value: bool) -> Self {
        self.shader_integer_dot_product = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::maintenance4`]
    pub fn with_maintenance4(mut self, value: bool) -> Self {
        self.maintenance4 = value as u8 as u32;
        self
    }
}
///[VkPhysicalDeviceVulkan13Properties](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan13Properties.html) - Structure specifying physical device properties for functionality promoted to Vulkan 1.3
///# C Specifications
///The [`PhysicalDeviceVulkan13Properties`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_3
///typedef struct VkPhysicalDeviceVulkan13Properties {
///    VkStructureType       sType;
///    void*                 pNext;
///    uint32_t              minSubgroupSize;
///    uint32_t              maxSubgroupSize;
///    uint32_t              maxComputeWorkgroupSubgroups;
///    VkShaderStageFlags    requiredSubgroupSizeStages;
///    uint32_t              maxInlineUniformBlockSize;
///    uint32_t              maxPerStageDescriptorInlineUniformBlocks;
///    uint32_t              maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks;
///    uint32_t              maxDescriptorSetInlineUniformBlocks;
///    uint32_t              maxDescriptorSetUpdateAfterBindInlineUniformBlocks;
///    uint32_t              maxInlineUniformTotalSize;
///    VkBool32              integerDotProduct8BitUnsignedAccelerated;
///    VkBool32              integerDotProduct8BitSignedAccelerated;
///    VkBool32              integerDotProduct8BitMixedSignednessAccelerated;
///    VkBool32              integerDotProduct4x8BitPackedUnsignedAccelerated;
///    VkBool32              integerDotProduct4x8BitPackedSignedAccelerated;
///    VkBool32              integerDotProduct4x8BitPackedMixedSignednessAccelerated;
///    VkBool32              integerDotProduct16BitUnsignedAccelerated;
///    VkBool32              integerDotProduct16BitSignedAccelerated;
///    VkBool32              integerDotProduct16BitMixedSignednessAccelerated;
///    VkBool32              integerDotProduct32BitUnsignedAccelerated;
///    VkBool32              integerDotProduct32BitSignedAccelerated;
///    VkBool32              integerDotProduct32BitMixedSignednessAccelerated;
///    VkBool32              integerDotProduct64BitUnsignedAccelerated;
///    VkBool32              integerDotProduct64BitSignedAccelerated;
///    VkBool32              integerDotProduct64BitMixedSignednessAccelerated;
///    VkBool32              integerDotProductAccumulatingSaturating8BitUnsignedAccelerated;
///    VkBool32              integerDotProductAccumulatingSaturating8BitSignedAccelerated;
///    VkBool32              integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated;
///    VkBool32              integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated;
///    VkBool32              integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated;
///    VkBool32
/// integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated;
///    VkBool32              integerDotProductAccumulatingSaturating16BitUnsignedAccelerated;
///    VkBool32              integerDotProductAccumulatingSaturating16BitSignedAccelerated;
///    VkBool32              integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated;
///    VkBool32              integerDotProductAccumulatingSaturating32BitUnsignedAccelerated;
///    VkBool32              integerDotProductAccumulatingSaturating32BitSignedAccelerated;
///    VkBool32              integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated;
///    VkBool32              integerDotProductAccumulatingSaturating64BitUnsignedAccelerated;
///    VkBool32              integerDotProductAccumulatingSaturating64BitSignedAccelerated;
///    VkBool32              integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated;
///    VkDeviceSize          storageTexelBufferOffsetAlignmentBytes;
///    VkBool32              storageTexelBufferOffsetSingleTexelAlignment;
///    VkDeviceSize          uniformTexelBufferOffsetAlignmentBytes;
///    VkBool32              uniformTexelBufferOffsetSingleTexelAlignment;
///    VkDeviceSize          maxBufferSize;
///} VkPhysicalDeviceVulkan13Properties;
///```
///# Members
/// - [`s_type`] is the type of this structure.
/// - [`p_next`] is `NULL` or a pointer to a structure extending this structure.
///# Description
/// - [`min_subgroup_size`] is the minimum subgroup size supported by this device.
///   [`min_subgroup_size`] is at least one if any of the physical devices queues support
///   `VK_QUEUE_GRAPHICS_BIT` or `VK_QUEUE_COMPUTE_BIT`. [`min_subgroup_size`] is a power-of-two.
///   [`min_subgroup_size`] is less than or equal to [`max_subgroup_size`]. [`min_subgroup_size`] is
///   less than or equal to [subgroupSize]().
/// - [`max_subgroup_size`] is the maximum subgroup size supported by this device.
///   [`max_subgroup_size`] is at least one if any of the physical devices queues support
///   `VK_QUEUE_GRAPHICS_BIT` or `VK_QUEUE_COMPUTE_BIT`. [`max_subgroup_size`] is a power-of-two.
///   [`max_subgroup_size`] is greater than or equal to [`min_subgroup_size`]. [`max_subgroup_size`]
///   is greater than or equal to [subgroupSize]().
/// - [`max_compute_workgroup_subgroups`] is the maximum number of subgroups supported by the
///   implementation within a workgroup.
/// - [`required_subgroup_size_stages`] is a bitfield of what shader stages support having a
///   required subgroup size specified.
/// - [`max_inline_uniform_block_size`] is the maximum size in bytes of an [inline uniform block]()
///   binding.
/// - `maxPerStageDescriptorInlineUniformBlock` is the maximum number of inline uniform block
///   bindings that  **can**  be accessible to a single shader stage in a pipeline layout.
///   Descriptor bindings with a descriptor type of `VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK` count
///   against this limit. Only descriptor bindings in descriptor set layouts created without the
///   `VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT` bit set count against this limit.
/// - [`max_per_stage_descriptor_update_after_bind_inline_uniform_blocks`] is similar to
///   [`max_per_stage_descriptor_inline_uniform_blocks`] but counts descriptor bindings from
///   descriptor sets created with or without the
///   `VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT` bit set.
/// - [`max_descriptor_set_inline_uniform_blocks`] is the maximum number of inline uniform block
///   bindings that  **can**  be included in descriptor bindings in a pipeline layout across all
///   pipeline shader stages and descriptor set numbers. Descriptor bindings with a descriptor type
///   of `VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK` count against this limit. Only descriptor
///   bindings in descriptor set layouts created without the
///   `VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT` bit set count against this limit.
/// - [`max_descriptor_set_update_after_bind_inline_uniform_blocks`] is similar to
///   [`max_descriptor_set_inline_uniform_blocks`] but counts descriptor bindings from descriptor
///   sets created with or without the `VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT`
///   bit set.
/// - [`max_inline_uniform_total_size`] is the maximum total size in bytes of all inline uniform
///   block bindings, across all pipeline shader stages and descriptor set numbers, that  **can**
///   be included in a pipeline layout. Descriptor bindings with a descriptor type of
///   `VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK` count against this limit.
/// - [`integer_dot_product8_bit_unsigned_accelerated`] is a boolean that will be [`TRUE`] if the
///   support for 8-bit unsigned dot product operations using the `OpUDotKHR` SPIR-V instruction is
///   accelerated [as defined below]().
/// - [`integer_dot_product8_bit_signed_accelerated`] is a boolean that will be [`TRUE`] if the
///   support for 8-bit signed dot product operations using the `OpSDotKHR` SPIR-V instruction is
///   accelerated [as defined below]().
/// - [`integer_dot_product8_bit_mixed_signedness_accelerated`] is a boolean that will be [`TRUE`]
///   if the support for 8-bit mixed signedness dot product operations using the `OpSUDotKHR` SPIR-V
///   instruction is accelerated [as defined below]().
/// - [`integer_dot_product4x8_bit_packed_unsigned_accelerated`] is a boolean that will be [`TRUE`]
///   if the support for 8-bit unsigned dot product operations from operands packed into 32-bit
///   integers using the `OpUDotKHR` SPIR-V instruction is accelerated [as defined below]().
/// - [`integer_dot_product4x8_bit_packed_signed_accelerated`] is a boolean that will be [`TRUE`] if
///   the support for 8-bit signed dot product operations from operands packed into 32-bit integers
///   using the `OpSDotKHR` SPIR-V instruction is accelerated [as defined below]().
/// - [`integer_dot_product4x8_bit_packed_mixed_signedness_accelerated`] is a boolean that will be
///   [`TRUE`] if the support for 8-bit mixed signedness dot product operations from operands packed
///   into 32-bit integers using the `OpSUDotKHR` SPIR-V instruction is accelerated [as defined
///   below]().
/// - [`integer_dot_product16_bit_unsigned_accelerated`] is a boolean that will be [`TRUE`] if the
///   support for 16-bit unsigned dot product operations using the `OpUDotKHR` SPIR-V instruction is
///   accelerated [as defined below]().
/// - [`integer_dot_product16_bit_signed_accelerated`] is a boolean that will be [`TRUE`] if the
///   support for 16-bit signed dot product operations using the `OpSDotKHR` SPIR-V instruction is
///   accelerated [as defined below]().
/// - [`integer_dot_product16_bit_mixed_signedness_accelerated`] is a boolean that will be [`TRUE`]
///   if the support for 16-bit mixed signedness dot product operations using the `OpSUDotKHR`
///   SPIR-V instruction is accelerated [as defined below]().
/// - [`integer_dot_product32_bit_unsigned_accelerated`] is a boolean that will be [`TRUE`] if the
///   support for 32-bit unsigned dot product operations using the `OpUDotKHR` SPIR-V instruction is
///   accelerated [as defined below]().
/// - [`integer_dot_product32_bit_signed_accelerated`] is a boolean that will be [`TRUE`] if the
///   support for 32-bit signed dot product operations using the `OpSDotKHR` SPIR-V instruction is
///   accelerated [as defined below]().
/// - [`integer_dot_product32_bit_mixed_signedness_accelerated`] is a boolean that will be [`TRUE`]
///   if the support for 32-bit mixed signedness dot product operations using the `OpSUDotKHR`
///   SPIR-V instruction is accelerated [as defined below]().
/// - [`integer_dot_product64_bit_unsigned_accelerated`] is a boolean that will be [`TRUE`] if the
///   support for 64-bit unsigned dot product operations using the `OpUDotKHR` SPIR-V instruction is
///   accelerated [as defined below]().
/// - [`integer_dot_product64_bit_signed_accelerated`] is a boolean that will be [`TRUE`] if the
///   support for 64-bit signed dot product operations using the `OpSDotKHR` SPIR-V instruction is
///   accelerated [as defined below]().
/// - [`integer_dot_product64_bit_mixed_signedness_accelerated`] is a boolean that will be [`TRUE`]
///   if the support for 64-bit mixed signedness dot product operations using the `OpSUDotKHR`
///   SPIR-V instruction is accelerated [as defined below]().
/// - [`integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated`] is a boolean that
///   will be [`TRUE`] if the support for 8-bit unsigned accumulating saturating dot product
///   operations using the `OpUDotAccSatKHR` SPIR-V instruction is accelerated [as defined below]().
/// - [`integer_dot_product_accumulating_saturating8_bit_signed_accelerated`] is a boolean that will
///   be [`TRUE`] if the support for 8-bit signed accumulating saturating dot product operations
///   using the `OpSDotAccSatKHR` SPIR-V instruction is accelerated [as defined below]().
/// - [`integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated`] is a boolean
///   that will be [`TRUE`] if the support for 8-bit mixed signedness accumulating saturating dot
///   product operations using the `OpSUDotAccSatKHR` SPIR-V instruction is accelerated [as defined
///   below]().
/// - [`integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated`] is a
///   boolean that will be [`TRUE`] if the support for 8-bit unsigned accumulating saturating dot
///   product operations from operands packed into 32-bit integers using the `OpUDotAccSatKHR`
///   SPIR-V instruction is accelerated [as defined below]().
/// - [`integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated`] is a boolean
///   that will be [`TRUE`] if the support for 8-bit signed accumulating saturating dot product
///   operations from operands packed into 32-bit integers using the `OpSDotAccSatKHR` SPIR-V
///   instruction is accelerated [as defined below]().
/// - [`integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated`] is
///   a boolean that will be [`TRUE`] if the support for 8-bit mixed signedness accumulating
///   saturating dot product operations from operands packed into 32-bit integers using the
///   `OpSUDotAccSatKHR` SPIR-V instruction is accelerated [as defined below]().
/// - [`integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated`] is a boolean that
///   will be [`TRUE`] if the support for 16-bit unsigned accumulating saturating dot product
///   operations using the `OpUDotAccSatKHR` SPIR-V instruction is accelerated [as defined below]().
/// - [`integer_dot_product_accumulating_saturating16_bit_signed_accelerated`] is a boolean that
///   will be [`TRUE`] if the support for 16-bit signed accumulating saturating dot product
///   operations using the `OpSDotAccSatKHR` SPIR-V instruction is accelerated [as defined below]().
/// - [`integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated`] is a
///   boolean that will be [`TRUE`] if the support for 16-bit mixed signedness accumulating
///   saturating dot product operations using the `OpSUDotAccSatKHR` SPIR-V instruction is
///   accelerated [as defined below]().
/// - [`integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated`] is a boolean that
///   will be [`TRUE`] if the support for 32-bit unsigned accumulating saturating dot product
///   operations using the `OpUDotAccSatKHR` SPIR-V instruction is accelerated [as defined below]().
/// - [`integer_dot_product_accumulating_saturating32_bit_signed_accelerated`] is a boolean that
///   will be [`TRUE`] if the support for 32-bit signed accumulating saturating dot product
///   operations using the `OpSDotAccSatKHR` SPIR-V instruction is accelerated [as defined below]().
/// - [`integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated`] is a
///   boolean that will be [`TRUE`] if the support for 32-bit mixed signedness accumulating
///   saturating dot product operations using the `OpSUDotAccSatKHR` SPIR-V instruction is
///   accelerated [as defined below]().
/// - [`integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated`] is a boolean that
///   will be [`TRUE`] if the support for 64-bit unsigned accumulating saturating dot product
///   operations using the `OpUDotAccSatKHR` SPIR-V instruction is accelerated [as defined below]().
/// - [`integer_dot_product_accumulating_saturating64_bit_signed_accelerated`] is a boolean that
///   will be [`TRUE`] if the support for 64-bit signed accumulating saturating dot product
///   operations using the `OpSDotAccSatKHR` SPIR-V instruction is accelerated [as defined below]().
/// - [`integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated`] is a
///   boolean that will be [`TRUE`] if the support for 64-bit mixed signedness accumulating
///   saturating dot product operations using the `OpSUDotAccSatKHR` SPIR-V instruction is
///   accelerated [as defined below]().
/// - [`storage_texel_buffer_offset_alignment_bytes`] is a byte alignment that is sufficient for a
///   storage texel buffer of any format. The value  **must**  be a power of two.
/// - [`storage_texel_buffer_offset_single_texel_alignment`] indicates whether single texel
///   alignment is sufficient for a storage texel buffer of any format. The value  **must**  be a
///   power of two.
/// - [`uniform_texel_buffer_offset_alignment_bytes`] is a byte alignment that is sufficient for a
///   uniform texel buffer of any format. The value  **must**  be a power of two.
/// - [`uniform_texel_buffer_offset_single_texel_alignment`] indicates whether single texel
///   alignment is sufficient for a uniform texel buffer of any format. The value  **must**  be a
///   power of two.
/// - [`max_buffer_size`] is the maximum size [`Buffer`] that  **can**  be created.
///If the [`PhysicalDeviceVulkan13Properties`] structure is included in the [`p_next`] chain of the
///[`PhysicalDeviceProperties2`] structure passed to
///[`get_physical_device_properties2`], it is filled in with each
///corresponding implementation-dependent property.These properties correspond to Vulkan 1.3
/// functionality.The members of [`PhysicalDeviceVulkan13Properties`] **must**  have the same
///values as the corresponding members of
///[`PhysicalDeviceInlineUniformBlockProperties`] and
///[`PhysicalDeviceSubgroupSizeControlProperties`].
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be `VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES`
///# Related
/// - [`crate::vulkan1_3`]
/// - [`Bool32`]
/// - [`DeviceSize`]
/// - [`ShaderStageFlags`]
/// - [`StructureType`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkPhysicalDeviceVulkan13Properties")]
#[derive(Debug, Clone, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[repr(C)]
pub struct PhysicalDeviceVulkan13Properties<'lt> {
    ///Lifetime field
    pub _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] is the type of this structure.
    pub s_type: StructureType,
    ///[`p_next`] is `NULL` or a pointer to a structure extending this
    ///structure.
    pub p_next: *mut BaseOutStructure<'lt>,
    ///No documentation found
    pub min_subgroup_size: u32,
    ///No documentation found
    pub max_subgroup_size: u32,
    ///No documentation found
    pub max_compute_workgroup_subgroups: u32,
    ///No documentation found
    pub required_subgroup_size_stages: ShaderStageFlags,
    ///No documentation found
    pub max_inline_uniform_block_size: u32,
    ///No documentation found
    pub max_per_stage_descriptor_inline_uniform_blocks: u32,
    ///No documentation found
    pub max_per_stage_descriptor_update_after_bind_inline_uniform_blocks: u32,
    ///No documentation found
    pub max_descriptor_set_inline_uniform_blocks: u32,
    ///No documentation found
    pub max_descriptor_set_update_after_bind_inline_uniform_blocks: u32,
    ///No documentation found
    pub max_inline_uniform_total_size: u32,
    ///No documentation found
    pub integer_dot_product8_bit_unsigned_accelerated: Bool32,
    ///No documentation found
    pub integer_dot_product8_bit_signed_accelerated: Bool32,
    ///No documentation found
    pub integer_dot_product8_bit_mixed_signedness_accelerated: Bool32,
    ///No documentation found
    pub integer_dot_product4x8_bit_packed_unsigned_accelerated: Bool32,
    ///No documentation found
    pub integer_dot_product4x8_bit_packed_signed_accelerated: Bool32,
    ///No documentation found
    pub integer_dot_product4x8_bit_packed_mixed_signedness_accelerated: Bool32,
    ///No documentation found
    pub integer_dot_product16_bit_unsigned_accelerated: Bool32,
    ///No documentation found
    pub integer_dot_product16_bit_signed_accelerated: Bool32,
    ///No documentation found
    pub integer_dot_product16_bit_mixed_signedness_accelerated: Bool32,
    ///No documentation found
    pub integer_dot_product32_bit_unsigned_accelerated: Bool32,
    ///No documentation found
    pub integer_dot_product32_bit_signed_accelerated: Bool32,
    ///No documentation found
    pub integer_dot_product32_bit_mixed_signedness_accelerated: Bool32,
    ///No documentation found
    pub integer_dot_product64_bit_unsigned_accelerated: Bool32,
    ///No documentation found
    pub integer_dot_product64_bit_signed_accelerated: Bool32,
    ///No documentation found
    pub integer_dot_product64_bit_mixed_signedness_accelerated: Bool32,
    ///No documentation found
    pub integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated: Bool32,
    ///No documentation found
    pub integer_dot_product_accumulating_saturating8_bit_signed_accelerated: Bool32,
    ///No documentation found
    pub integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated: Bool32,
    ///No documentation found
    pub integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated: Bool32,
    ///No documentation found
    pub integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated: Bool32,
    ///No documentation found
    pub integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated: Bool32,
    ///No documentation found
    pub integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated: Bool32,
    ///No documentation found
    pub integer_dot_product_accumulating_saturating16_bit_signed_accelerated: Bool32,
    ///No documentation found
    pub integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated: Bool32,
    ///No documentation found
    pub integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated: Bool32,
    ///No documentation found
    pub integer_dot_product_accumulating_saturating32_bit_signed_accelerated: Bool32,
    ///No documentation found
    pub integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated: Bool32,
    ///No documentation found
    pub integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated: Bool32,
    ///No documentation found
    pub integer_dot_product_accumulating_saturating64_bit_signed_accelerated: Bool32,
    ///No documentation found
    pub integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated: Bool32,
    ///No documentation found
    pub storage_texel_buffer_offset_alignment_bytes: DeviceSize,
    ///No documentation found
    pub storage_texel_buffer_offset_single_texel_alignment: Bool32,
    ///No documentation found
    pub uniform_texel_buffer_offset_alignment_bytes: DeviceSize,
    ///No documentation found
    pub uniform_texel_buffer_offset_single_texel_alignment: Bool32,
    ///No documentation found
    pub max_buffer_size: DeviceSize,
}
impl<'lt> Default for PhysicalDeviceVulkan13Properties<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: StructureType::PHYSICAL_DEVICE_VULKAN1_3_PROPERTIES,
            p_next: std::ptr::null_mut(),
            min_subgroup_size: 0,
            max_subgroup_size: 0,
            max_compute_workgroup_subgroups: 0,
            required_subgroup_size_stages: Default::default(),
            max_inline_uniform_block_size: 0,
            max_per_stage_descriptor_inline_uniform_blocks: 0,
            max_per_stage_descriptor_update_after_bind_inline_uniform_blocks: 0,
            max_descriptor_set_inline_uniform_blocks: 0,
            max_descriptor_set_update_after_bind_inline_uniform_blocks: 0,
            max_inline_uniform_total_size: 0,
            integer_dot_product8_bit_unsigned_accelerated: 0,
            integer_dot_product8_bit_signed_accelerated: 0,
            integer_dot_product8_bit_mixed_signedness_accelerated: 0,
            integer_dot_product4x8_bit_packed_unsigned_accelerated: 0,
            integer_dot_product4x8_bit_packed_signed_accelerated: 0,
            integer_dot_product4x8_bit_packed_mixed_signedness_accelerated: 0,
            integer_dot_product16_bit_unsigned_accelerated: 0,
            integer_dot_product16_bit_signed_accelerated: 0,
            integer_dot_product16_bit_mixed_signedness_accelerated: 0,
            integer_dot_product32_bit_unsigned_accelerated: 0,
            integer_dot_product32_bit_signed_accelerated: 0,
            integer_dot_product32_bit_mixed_signedness_accelerated: 0,
            integer_dot_product64_bit_unsigned_accelerated: 0,
            integer_dot_product64_bit_signed_accelerated: 0,
            integer_dot_product64_bit_mixed_signedness_accelerated: 0,
            integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated: 0,
            integer_dot_product_accumulating_saturating8_bit_signed_accelerated: 0,
            integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated: 0,
            integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated: 0,
            integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated: 0,
            integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated: 0,
            integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated: 0,
            integer_dot_product_accumulating_saturating16_bit_signed_accelerated: 0,
            integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated: 0,
            integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated: 0,
            integer_dot_product_accumulating_saturating32_bit_signed_accelerated: 0,
            integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated: 0,
            integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated: 0,
            integer_dot_product_accumulating_saturating64_bit_signed_accelerated: 0,
            integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated: 0,
            storage_texel_buffer_offset_alignment_bytes: Default::default(),
            storage_texel_buffer_offset_single_texel_alignment: 0,
            uniform_texel_buffer_offset_alignment_bytes: Default::default(),
            uniform_texel_buffer_offset_single_texel_alignment: 0,
            max_buffer_size: Default::default(),
        }
    }
}
impl<'lt> PhysicalDeviceVulkan13Properties<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *mut BaseOutStructure<'lt> {
        self.p_next
    }
    ///Gets the raw value of [`Self::integer_dot_product8_bit_unsigned_accelerated`]
    pub fn integer_dot_product8_bit_unsigned_accelerated_raw(&self) -> Bool32 {
        self.integer_dot_product8_bit_unsigned_accelerated
    }
    ///Gets the raw value of [`Self::integer_dot_product8_bit_signed_accelerated`]
    pub fn integer_dot_product8_bit_signed_accelerated_raw(&self) -> Bool32 {
        self.integer_dot_product8_bit_signed_accelerated
    }
    ///Gets the raw value of [`Self::integer_dot_product8_bit_mixed_signedness_accelerated`]
    pub fn integer_dot_product8_bit_mixed_signedness_accelerated_raw(&self) -> Bool32 {
        self.integer_dot_product8_bit_mixed_signedness_accelerated
    }
    ///Gets the raw value of [`Self::integer_dot_product4x8_bit_packed_unsigned_accelerated`]
    pub fn integer_dot_product4x8_bit_packed_unsigned_accelerated_raw(&self) -> Bool32 {
        self.integer_dot_product4x8_bit_packed_unsigned_accelerated
    }
    ///Gets the raw value of [`Self::integer_dot_product4x8_bit_packed_signed_accelerated`]
    pub fn integer_dot_product4x8_bit_packed_signed_accelerated_raw(&self) -> Bool32 {
        self.integer_dot_product4x8_bit_packed_signed_accelerated
    }
    ///Gets the raw value of
    /// [`Self::integer_dot_product4x8_bit_packed_mixed_signedness_accelerated`]
    pub fn integer_dot_product4x8_bit_packed_mixed_signedness_accelerated_raw(&self) -> Bool32 {
        self.integer_dot_product4x8_bit_packed_mixed_signedness_accelerated
    }
    ///Gets the raw value of [`Self::integer_dot_product16_bit_unsigned_accelerated`]
    pub fn integer_dot_product16_bit_unsigned_accelerated_raw(&self) -> Bool32 {
        self.integer_dot_product16_bit_unsigned_accelerated
    }
    ///Gets the raw value of [`Self::integer_dot_product16_bit_signed_accelerated`]
    pub fn integer_dot_product16_bit_signed_accelerated_raw(&self) -> Bool32 {
        self.integer_dot_product16_bit_signed_accelerated
    }
    ///Gets the raw value of [`Self::integer_dot_product16_bit_mixed_signedness_accelerated`]
    pub fn integer_dot_product16_bit_mixed_signedness_accelerated_raw(&self) -> Bool32 {
        self.integer_dot_product16_bit_mixed_signedness_accelerated
    }
    ///Gets the raw value of [`Self::integer_dot_product32_bit_unsigned_accelerated`]
    pub fn integer_dot_product32_bit_unsigned_accelerated_raw(&self) -> Bool32 {
        self.integer_dot_product32_bit_unsigned_accelerated
    }
    ///Gets the raw value of [`Self::integer_dot_product32_bit_signed_accelerated`]
    pub fn integer_dot_product32_bit_signed_accelerated_raw(&self) -> Bool32 {
        self.integer_dot_product32_bit_signed_accelerated
    }
    ///Gets the raw value of [`Self::integer_dot_product32_bit_mixed_signedness_accelerated`]
    pub fn integer_dot_product32_bit_mixed_signedness_accelerated_raw(&self) -> Bool32 {
        self.integer_dot_product32_bit_mixed_signedness_accelerated
    }
    ///Gets the raw value of [`Self::integer_dot_product64_bit_unsigned_accelerated`]
    pub fn integer_dot_product64_bit_unsigned_accelerated_raw(&self) -> Bool32 {
        self.integer_dot_product64_bit_unsigned_accelerated
    }
    ///Gets the raw value of [`Self::integer_dot_product64_bit_signed_accelerated`]
    pub fn integer_dot_product64_bit_signed_accelerated_raw(&self) -> Bool32 {
        self.integer_dot_product64_bit_signed_accelerated
    }
    ///Gets the raw value of [`Self::integer_dot_product64_bit_mixed_signedness_accelerated`]
    pub fn integer_dot_product64_bit_mixed_signedness_accelerated_raw(&self) -> Bool32 {
        self.integer_dot_product64_bit_mixed_signedness_accelerated
    }
    ///Gets the raw value of
    /// [`Self::integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated`]
    pub fn integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated_raw(&self) -> Bool32 {
        self.integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated
    }
    ///Gets the raw value of
    /// [`Self::integer_dot_product_accumulating_saturating8_bit_signed_accelerated`]
    pub fn integer_dot_product_accumulating_saturating8_bit_signed_accelerated_raw(&self) -> Bool32 {
        self.integer_dot_product_accumulating_saturating8_bit_signed_accelerated
    }
    ///Gets the raw value of
    /// [`Self::integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated`]
    pub fn integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated_raw(&self) -> Bool32 {
        self.integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated
    }
    ///Gets the raw value of
    /// [`Self::integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated`]
    pub fn integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated_raw(&self) -> Bool32 {
        self.integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated
    }
    ///Gets the raw value of
    /// [`Self::integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated`]
    pub fn integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated_raw(&self) -> Bool32 {
        self.integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated
    }
    ///Gets the raw value of
    /// [`Self::integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated`]
    pub fn integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated_raw(&self) -> Bool32 {
        self.integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated
    }
    ///Gets the raw value of
    /// [`Self::integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated`]
    pub fn integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated_raw(&self) -> Bool32 {
        self.integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated
    }
    ///Gets the raw value of
    /// [`Self::integer_dot_product_accumulating_saturating16_bit_signed_accelerated`]
    pub fn integer_dot_product_accumulating_saturating16_bit_signed_accelerated_raw(&self) -> Bool32 {
        self.integer_dot_product_accumulating_saturating16_bit_signed_accelerated
    }
    ///Gets the raw value of
    /// [`Self::integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated`]
    pub fn integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated_raw(&self) -> Bool32 {
        self.integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated
    }
    ///Gets the raw value of
    /// [`Self::integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated`]
    pub fn integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated_raw(&self) -> Bool32 {
        self.integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated
    }
    ///Gets the raw value of
    /// [`Self::integer_dot_product_accumulating_saturating32_bit_signed_accelerated`]
    pub fn integer_dot_product_accumulating_saturating32_bit_signed_accelerated_raw(&self) -> Bool32 {
        self.integer_dot_product_accumulating_saturating32_bit_signed_accelerated
    }
    ///Gets the raw value of
    /// [`Self::integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated`]
    pub fn integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated_raw(&self) -> Bool32 {
        self.integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated
    }
    ///Gets the raw value of
    /// [`Self::integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated`]
    pub fn integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated_raw(&self) -> Bool32 {
        self.integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated
    }
    ///Gets the raw value of
    /// [`Self::integer_dot_product_accumulating_saturating64_bit_signed_accelerated`]
    pub fn integer_dot_product_accumulating_saturating64_bit_signed_accelerated_raw(&self) -> Bool32 {
        self.integer_dot_product_accumulating_saturating64_bit_signed_accelerated
    }
    ///Gets the raw value of
    /// [`Self::integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated`]
    pub fn integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated_raw(&self) -> Bool32 {
        self.integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated
    }
    ///Gets the raw value of [`Self::storage_texel_buffer_offset_single_texel_alignment`]
    pub fn storage_texel_buffer_offset_single_texel_alignment_raw(&self) -> Bool32 {
        self.storage_texel_buffer_offset_single_texel_alignment
    }
    ///Gets the raw value of [`Self::uniform_texel_buffer_offset_single_texel_alignment`]
    pub fn uniform_texel_buffer_offset_single_texel_alignment_raw(&self) -> Bool32 {
        self.uniform_texel_buffer_offset_single_texel_alignment
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *mut BaseOutStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::integer_dot_product8_bit_unsigned_accelerated`]
    pub fn set_integer_dot_product8_bit_unsigned_accelerated_raw(&mut self, value: Bool32) -> &mut Self {
        self.integer_dot_product8_bit_unsigned_accelerated = value;
        self
    }
    ///Sets the raw value of [`Self::integer_dot_product8_bit_signed_accelerated`]
    pub fn set_integer_dot_product8_bit_signed_accelerated_raw(&mut self, value: Bool32) -> &mut Self {
        self.integer_dot_product8_bit_signed_accelerated = value;
        self
    }
    ///Sets the raw value of [`Self::integer_dot_product8_bit_mixed_signedness_accelerated`]
    pub fn set_integer_dot_product8_bit_mixed_signedness_accelerated_raw(&mut self, value: Bool32) -> &mut Self {
        self.integer_dot_product8_bit_mixed_signedness_accelerated = value;
        self
    }
    ///Sets the raw value of [`Self::integer_dot_product4x8_bit_packed_unsigned_accelerated`]
    pub fn set_integer_dot_product4x8_bit_packed_unsigned_accelerated_raw(&mut self, value: Bool32) -> &mut Self {
        self.integer_dot_product4x8_bit_packed_unsigned_accelerated = value;
        self
    }
    ///Sets the raw value of [`Self::integer_dot_product4x8_bit_packed_signed_accelerated`]
    pub fn set_integer_dot_product4x8_bit_packed_signed_accelerated_raw(&mut self, value: Bool32) -> &mut Self {
        self.integer_dot_product4x8_bit_packed_signed_accelerated = value;
        self
    }
    ///Sets the raw value of
    /// [`Self::integer_dot_product4x8_bit_packed_mixed_signedness_accelerated`]
    pub fn set_integer_dot_product4x8_bit_packed_mixed_signedness_accelerated_raw(
        &mut self,
        value: Bool32,
    ) -> &mut Self {
        self.integer_dot_product4x8_bit_packed_mixed_signedness_accelerated = value;
        self
    }
    ///Sets the raw value of [`Self::integer_dot_product16_bit_unsigned_accelerated`]
    pub fn set_integer_dot_product16_bit_unsigned_accelerated_raw(&mut self, value: Bool32) -> &mut Self {
        self.integer_dot_product16_bit_unsigned_accelerated = value;
        self
    }
    ///Sets the raw value of [`Self::integer_dot_product16_bit_signed_accelerated`]
    pub fn set_integer_dot_product16_bit_signed_accelerated_raw(&mut self, value: Bool32) -> &mut Self {
        self.integer_dot_product16_bit_signed_accelerated = value;
        self
    }
    ///Sets the raw value of [`Self::integer_dot_product16_bit_mixed_signedness_accelerated`]
    pub fn set_integer_dot_product16_bit_mixed_signedness_accelerated_raw(&mut self, value: Bool32) -> &mut Self {
        self.integer_dot_product16_bit_mixed_signedness_accelerated = value;
        self
    }
    ///Sets the raw value of [`Self::integer_dot_product32_bit_unsigned_accelerated`]
    pub fn set_integer_dot_product32_bit_unsigned_accelerated_raw(&mut self, value: Bool32) -> &mut Self {
        self.integer_dot_product32_bit_unsigned_accelerated = value;
        self
    }
    ///Sets the raw value of [`Self::integer_dot_product32_bit_signed_accelerated`]
    pub fn set_integer_dot_product32_bit_signed_accelerated_raw(&mut self, value: Bool32) -> &mut Self {
        self.integer_dot_product32_bit_signed_accelerated = value;
        self
    }
    ///Sets the raw value of [`Self::integer_dot_product32_bit_mixed_signedness_accelerated`]
    pub fn set_integer_dot_product32_bit_mixed_signedness_accelerated_raw(&mut self, value: Bool32) -> &mut Self {
        self.integer_dot_product32_bit_mixed_signedness_accelerated = value;
        self
    }
    ///Sets the raw value of [`Self::integer_dot_product64_bit_unsigned_accelerated`]
    pub fn set_integer_dot_product64_bit_unsigned_accelerated_raw(&mut self, value: Bool32) -> &mut Self {
        self.integer_dot_product64_bit_unsigned_accelerated = value;
        self
    }
    ///Sets the raw value of [`Self::integer_dot_product64_bit_signed_accelerated`]
    pub fn set_integer_dot_product64_bit_signed_accelerated_raw(&mut self, value: Bool32) -> &mut Self {
        self.integer_dot_product64_bit_signed_accelerated = value;
        self
    }
    ///Sets the raw value of [`Self::integer_dot_product64_bit_mixed_signedness_accelerated`]
    pub fn set_integer_dot_product64_bit_mixed_signedness_accelerated_raw(&mut self, value: Bool32) -> &mut Self {
        self.integer_dot_product64_bit_mixed_signedness_accelerated = value;
        self
    }
    ///Sets the raw value of
    /// [`Self::integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated`]
    pub fn set_integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated_raw(
        &mut self,
        value: Bool32,
    ) -> &mut Self {
        self.integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated = value;
        self
    }
    ///Sets the raw value of
    /// [`Self::integer_dot_product_accumulating_saturating8_bit_signed_accelerated`]
    pub fn set_integer_dot_product_accumulating_saturating8_bit_signed_accelerated_raw(
        &mut self,
        value: Bool32,
    ) -> &mut Self {
        self.integer_dot_product_accumulating_saturating8_bit_signed_accelerated = value;
        self
    }
    ///Sets the raw value of
    /// [`Self::integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated`]
    pub fn set_integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated_raw(
        &mut self,
        value: Bool32,
    ) -> &mut Self {
        self.integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated = value;
        self
    }
    ///Sets the raw value of
    /// [`Self::integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated`]
    pub fn set_integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated_raw(
        &mut self,
        value: Bool32,
    ) -> &mut Self {
        self.integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated = value;
        self
    }
    ///Sets the raw value of
    /// [`Self::integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated`]
    pub fn set_integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated_raw(
        &mut self,
        value: Bool32,
    ) -> &mut Self {
        self.integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated = value;
        self
    }
    ///Sets the raw value of
    /// [`Self::integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated`]
    pub fn set_integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated_raw(
        &mut self,
        value: Bool32,
    ) -> &mut Self {
        self.integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated = value;
        self
    }
    ///Sets the raw value of
    /// [`Self::integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated`]
    pub fn set_integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated_raw(
        &mut self,
        value: Bool32,
    ) -> &mut Self {
        self.integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated = value;
        self
    }
    ///Sets the raw value of
    /// [`Self::integer_dot_product_accumulating_saturating16_bit_signed_accelerated`]
    pub fn set_integer_dot_product_accumulating_saturating16_bit_signed_accelerated_raw(
        &mut self,
        value: Bool32,
    ) -> &mut Self {
        self.integer_dot_product_accumulating_saturating16_bit_signed_accelerated = value;
        self
    }
    ///Sets the raw value of
    /// [`Self::integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated`]
    pub fn set_integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated_raw(
        &mut self,
        value: Bool32,
    ) -> &mut Self {
        self.integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated = value;
        self
    }
    ///Sets the raw value of
    /// [`Self::integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated`]
    pub fn set_integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated_raw(
        &mut self,
        value: Bool32,
    ) -> &mut Self {
        self.integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated = value;
        self
    }
    ///Sets the raw value of
    /// [`Self::integer_dot_product_accumulating_saturating32_bit_signed_accelerated`]
    pub fn set_integer_dot_product_accumulating_saturating32_bit_signed_accelerated_raw(
        &mut self,
        value: Bool32,
    ) -> &mut Self {
        self.integer_dot_product_accumulating_saturating32_bit_signed_accelerated = value;
        self
    }
    ///Sets the raw value of
    /// [`Self::integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated`]
    pub fn set_integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated_raw(
        &mut self,
        value: Bool32,
    ) -> &mut Self {
        self.integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated = value;
        self
    }
    ///Sets the raw value of
    /// [`Self::integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated`]
    pub fn set_integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated_raw(
        &mut self,
        value: Bool32,
    ) -> &mut Self {
        self.integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated = value;
        self
    }
    ///Sets the raw value of
    /// [`Self::integer_dot_product_accumulating_saturating64_bit_signed_accelerated`]
    pub fn set_integer_dot_product_accumulating_saturating64_bit_signed_accelerated_raw(
        &mut self,
        value: Bool32,
    ) -> &mut Self {
        self.integer_dot_product_accumulating_saturating64_bit_signed_accelerated = value;
        self
    }
    ///Sets the raw value of
    /// [`Self::integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated`]
    pub fn set_integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated_raw(
        &mut self,
        value: Bool32,
    ) -> &mut Self {
        self.integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated = value;
        self
    }
    ///Sets the raw value of [`Self::storage_texel_buffer_offset_single_texel_alignment`]
    pub fn set_storage_texel_buffer_offset_single_texel_alignment_raw(&mut self, value: Bool32) -> &mut Self {
        self.storage_texel_buffer_offset_single_texel_alignment = value;
        self
    }
    ///Sets the raw value of [`Self::uniform_texel_buffer_offset_single_texel_alignment`]
    pub fn set_uniform_texel_buffer_offset_single_texel_alignment_raw(&mut self, value: Bool32) -> &mut Self {
        self.uniform_texel_buffer_offset_single_texel_alignment = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn with_p_next_raw(mut self, value: *mut BaseOutStructure<'lt>) -> Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::integer_dot_product8_bit_unsigned_accelerated`]
    pub fn with_integer_dot_product8_bit_unsigned_accelerated_raw(mut self, value: Bool32) -> Self {
        self.integer_dot_product8_bit_unsigned_accelerated = value;
        self
    }
    ///Sets the raw value of [`Self::integer_dot_product8_bit_signed_accelerated`]
    pub fn with_integer_dot_product8_bit_signed_accelerated_raw(mut self, value: Bool32) -> Self {
        self.integer_dot_product8_bit_signed_accelerated = value;
        self
    }
    ///Sets the raw value of [`Self::integer_dot_product8_bit_mixed_signedness_accelerated`]
    pub fn with_integer_dot_product8_bit_mixed_signedness_accelerated_raw(mut self, value: Bool32) -> Self {
        self.integer_dot_product8_bit_mixed_signedness_accelerated = value;
        self
    }
    ///Sets the raw value of [`Self::integer_dot_product4x8_bit_packed_unsigned_accelerated`]
    pub fn with_integer_dot_product4x8_bit_packed_unsigned_accelerated_raw(mut self, value: Bool32) -> Self {
        self.integer_dot_product4x8_bit_packed_unsigned_accelerated = value;
        self
    }
    ///Sets the raw value of [`Self::integer_dot_product4x8_bit_packed_signed_accelerated`]
    pub fn with_integer_dot_product4x8_bit_packed_signed_accelerated_raw(mut self, value: Bool32) -> Self {
        self.integer_dot_product4x8_bit_packed_signed_accelerated = value;
        self
    }
    ///Sets the raw value of
    /// [`Self::integer_dot_product4x8_bit_packed_mixed_signedness_accelerated`]
    pub fn with_integer_dot_product4x8_bit_packed_mixed_signedness_accelerated_raw(mut self, value: Bool32) -> Self {
        self.integer_dot_product4x8_bit_packed_mixed_signedness_accelerated = value;
        self
    }
    ///Sets the raw value of [`Self::integer_dot_product16_bit_unsigned_accelerated`]
    pub fn with_integer_dot_product16_bit_unsigned_accelerated_raw(mut self, value: Bool32) -> Self {
        self.integer_dot_product16_bit_unsigned_accelerated = value;
        self
    }
    ///Sets the raw value of [`Self::integer_dot_product16_bit_signed_accelerated`]
    pub fn with_integer_dot_product16_bit_signed_accelerated_raw(mut self, value: Bool32) -> Self {
        self.integer_dot_product16_bit_signed_accelerated = value;
        self
    }
    ///Sets the raw value of [`Self::integer_dot_product16_bit_mixed_signedness_accelerated`]
    pub fn with_integer_dot_product16_bit_mixed_signedness_accelerated_raw(mut self, value: Bool32) -> Self {
        self.integer_dot_product16_bit_mixed_signedness_accelerated = value;
        self
    }
    ///Sets the raw value of [`Self::integer_dot_product32_bit_unsigned_accelerated`]
    pub fn with_integer_dot_product32_bit_unsigned_accelerated_raw(mut self, value: Bool32) -> Self {
        self.integer_dot_product32_bit_unsigned_accelerated = value;
        self
    }
    ///Sets the raw value of [`Self::integer_dot_product32_bit_signed_accelerated`]
    pub fn with_integer_dot_product32_bit_signed_accelerated_raw(mut self, value: Bool32) -> Self {
        self.integer_dot_product32_bit_signed_accelerated = value;
        self
    }
    ///Sets the raw value of [`Self::integer_dot_product32_bit_mixed_signedness_accelerated`]
    pub fn with_integer_dot_product32_bit_mixed_signedness_accelerated_raw(mut self, value: Bool32) -> Self {
        self.integer_dot_product32_bit_mixed_signedness_accelerated = value;
        self
    }
    ///Sets the raw value of [`Self::integer_dot_product64_bit_unsigned_accelerated`]
    pub fn with_integer_dot_product64_bit_unsigned_accelerated_raw(mut self, value: Bool32) -> Self {
        self.integer_dot_product64_bit_unsigned_accelerated = value;
        self
    }
    ///Sets the raw value of [`Self::integer_dot_product64_bit_signed_accelerated`]
    pub fn with_integer_dot_product64_bit_signed_accelerated_raw(mut self, value: Bool32) -> Self {
        self.integer_dot_product64_bit_signed_accelerated = value;
        self
    }
    ///Sets the raw value of [`Self::integer_dot_product64_bit_mixed_signedness_accelerated`]
    pub fn with_integer_dot_product64_bit_mixed_signedness_accelerated_raw(mut self, value: Bool32) -> Self {
        self.integer_dot_product64_bit_mixed_signedness_accelerated = value;
        self
    }
    ///Sets the raw value of
    /// [`Self::integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated`]
    pub fn with_integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated_raw(
        mut self,
        value: Bool32,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated = value;
        self
    }
    ///Sets the raw value of
    /// [`Self::integer_dot_product_accumulating_saturating8_bit_signed_accelerated`]
    pub fn with_integer_dot_product_accumulating_saturating8_bit_signed_accelerated_raw(
        mut self,
        value: Bool32,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating8_bit_signed_accelerated = value;
        self
    }
    ///Sets the raw value of
    /// [`Self::integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated`]
    pub fn with_integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated_raw(
        mut self,
        value: Bool32,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated = value;
        self
    }
    ///Sets the raw value of
    /// [`Self::integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated`]
    pub fn with_integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated_raw(
        mut self,
        value: Bool32,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated = value;
        self
    }
    ///Sets the raw value of
    /// [`Self::integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated`]
    pub fn with_integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated_raw(
        mut self,
        value: Bool32,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated = value;
        self
    }
    ///Sets the raw value of
    /// [`Self::integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated`]
    pub fn with_integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated_raw(
        mut self,
        value: Bool32,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated = value;
        self
    }
    ///Sets the raw value of
    /// [`Self::integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated`]
    pub fn with_integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated_raw(
        mut self,
        value: Bool32,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated = value;
        self
    }
    ///Sets the raw value of
    /// [`Self::integer_dot_product_accumulating_saturating16_bit_signed_accelerated`]
    pub fn with_integer_dot_product_accumulating_saturating16_bit_signed_accelerated_raw(
        mut self,
        value: Bool32,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating16_bit_signed_accelerated = value;
        self
    }
    ///Sets the raw value of
    /// [`Self::integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated`]
    pub fn with_integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated_raw(
        mut self,
        value: Bool32,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated = value;
        self
    }
    ///Sets the raw value of
    /// [`Self::integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated`]
    pub fn with_integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated_raw(
        mut self,
        value: Bool32,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated = value;
        self
    }
    ///Sets the raw value of
    /// [`Self::integer_dot_product_accumulating_saturating32_bit_signed_accelerated`]
    pub fn with_integer_dot_product_accumulating_saturating32_bit_signed_accelerated_raw(
        mut self,
        value: Bool32,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating32_bit_signed_accelerated = value;
        self
    }
    ///Sets the raw value of
    /// [`Self::integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated`]
    pub fn with_integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated_raw(
        mut self,
        value: Bool32,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated = value;
        self
    }
    ///Sets the raw value of
    /// [`Self::integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated`]
    pub fn with_integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated_raw(
        mut self,
        value: Bool32,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated = value;
        self
    }
    ///Sets the raw value of
    /// [`Self::integer_dot_product_accumulating_saturating64_bit_signed_accelerated`]
    pub fn with_integer_dot_product_accumulating_saturating64_bit_signed_accelerated_raw(
        mut self,
        value: Bool32,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating64_bit_signed_accelerated = value;
        self
    }
    ///Sets the raw value of
    /// [`Self::integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated`]
    pub fn with_integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated_raw(
        mut self,
        value: Bool32,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated = value;
        self
    }
    ///Sets the raw value of [`Self::storage_texel_buffer_offset_single_texel_alignment`]
    pub fn with_storage_texel_buffer_offset_single_texel_alignment_raw(mut self, value: Bool32) -> Self {
        self.storage_texel_buffer_offset_single_texel_alignment = value;
        self
    }
    ///Sets the raw value of [`Self::uniform_texel_buffer_offset_single_texel_alignment`]
    pub fn with_uniform_texel_buffer_offset_single_texel_alignment_raw(mut self, value: Bool32) -> Self {
        self.uniform_texel_buffer_offset_single_texel_alignment = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseOutStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::min_subgroup_size`]
    pub fn min_subgroup_size(&self) -> u32 {
        self.min_subgroup_size
    }
    ///Gets the value of [`Self::max_subgroup_size`]
    pub fn max_subgroup_size(&self) -> u32 {
        self.max_subgroup_size
    }
    ///Gets the value of [`Self::max_compute_workgroup_subgroups`]
    pub fn max_compute_workgroup_subgroups(&self) -> u32 {
        self.max_compute_workgroup_subgroups
    }
    ///Gets the value of [`Self::required_subgroup_size_stages`]
    pub fn required_subgroup_size_stages(&self) -> ShaderStageFlags {
        self.required_subgroup_size_stages
    }
    ///Gets the value of [`Self::max_inline_uniform_block_size`]
    pub fn max_inline_uniform_block_size(&self) -> u32 {
        self.max_inline_uniform_block_size
    }
    ///Gets the value of [`Self::max_per_stage_descriptor_inline_uniform_blocks`]
    pub fn max_per_stage_descriptor_inline_uniform_blocks(&self) -> u32 {
        self.max_per_stage_descriptor_inline_uniform_blocks
    }
    ///Gets the value of [`Self::max_per_stage_descriptor_update_after_bind_inline_uniform_blocks`]
    pub fn max_per_stage_descriptor_update_after_bind_inline_uniform_blocks(&self) -> u32 {
        self.max_per_stage_descriptor_update_after_bind_inline_uniform_blocks
    }
    ///Gets the value of [`Self::max_descriptor_set_inline_uniform_blocks`]
    pub fn max_descriptor_set_inline_uniform_blocks(&self) -> u32 {
        self.max_descriptor_set_inline_uniform_blocks
    }
    ///Gets the value of [`Self::max_descriptor_set_update_after_bind_inline_uniform_blocks`]
    pub fn max_descriptor_set_update_after_bind_inline_uniform_blocks(&self) -> u32 {
        self.max_descriptor_set_update_after_bind_inline_uniform_blocks
    }
    ///Gets the value of [`Self::max_inline_uniform_total_size`]
    pub fn max_inline_uniform_total_size(&self) -> u32 {
        self.max_inline_uniform_total_size
    }
    ///Gets the value of [`Self::integer_dot_product8_bit_unsigned_accelerated`]
    pub fn integer_dot_product8_bit_unsigned_accelerated(&self) -> bool {
        unsafe { std::mem::transmute(self.integer_dot_product8_bit_unsigned_accelerated as u8) }
    }
    ///Gets the value of [`Self::integer_dot_product8_bit_signed_accelerated`]
    pub fn integer_dot_product8_bit_signed_accelerated(&self) -> bool {
        unsafe { std::mem::transmute(self.integer_dot_product8_bit_signed_accelerated as u8) }
    }
    ///Gets the value of [`Self::integer_dot_product8_bit_mixed_signedness_accelerated`]
    pub fn integer_dot_product8_bit_mixed_signedness_accelerated(&self) -> bool {
        unsafe { std::mem::transmute(self.integer_dot_product8_bit_mixed_signedness_accelerated as u8) }
    }
    ///Gets the value of [`Self::integer_dot_product4x8_bit_packed_unsigned_accelerated`]
    pub fn integer_dot_product4x8_bit_packed_unsigned_accelerated(&self) -> bool {
        unsafe { std::mem::transmute(self.integer_dot_product4x8_bit_packed_unsigned_accelerated as u8) }
    }
    ///Gets the value of [`Self::integer_dot_product4x8_bit_packed_signed_accelerated`]
    pub fn integer_dot_product4x8_bit_packed_signed_accelerated(&self) -> bool {
        unsafe { std::mem::transmute(self.integer_dot_product4x8_bit_packed_signed_accelerated as u8) }
    }
    ///Gets the value of [`Self::integer_dot_product4x8_bit_packed_mixed_signedness_accelerated`]
    pub fn integer_dot_product4x8_bit_packed_mixed_signedness_accelerated(&self) -> bool {
        unsafe { std::mem::transmute(self.integer_dot_product4x8_bit_packed_mixed_signedness_accelerated as u8) }
    }
    ///Gets the value of [`Self::integer_dot_product16_bit_unsigned_accelerated`]
    pub fn integer_dot_product16_bit_unsigned_accelerated(&self) -> bool {
        unsafe { std::mem::transmute(self.integer_dot_product16_bit_unsigned_accelerated as u8) }
    }
    ///Gets the value of [`Self::integer_dot_product16_bit_signed_accelerated`]
    pub fn integer_dot_product16_bit_signed_accelerated(&self) -> bool {
        unsafe { std::mem::transmute(self.integer_dot_product16_bit_signed_accelerated as u8) }
    }
    ///Gets the value of [`Self::integer_dot_product16_bit_mixed_signedness_accelerated`]
    pub fn integer_dot_product16_bit_mixed_signedness_accelerated(&self) -> bool {
        unsafe { std::mem::transmute(self.integer_dot_product16_bit_mixed_signedness_accelerated as u8) }
    }
    ///Gets the value of [`Self::integer_dot_product32_bit_unsigned_accelerated`]
    pub fn integer_dot_product32_bit_unsigned_accelerated(&self) -> bool {
        unsafe { std::mem::transmute(self.integer_dot_product32_bit_unsigned_accelerated as u8) }
    }
    ///Gets the value of [`Self::integer_dot_product32_bit_signed_accelerated`]
    pub fn integer_dot_product32_bit_signed_accelerated(&self) -> bool {
        unsafe { std::mem::transmute(self.integer_dot_product32_bit_signed_accelerated as u8) }
    }
    ///Gets the value of [`Self::integer_dot_product32_bit_mixed_signedness_accelerated`]
    pub fn integer_dot_product32_bit_mixed_signedness_accelerated(&self) -> bool {
        unsafe { std::mem::transmute(self.integer_dot_product32_bit_mixed_signedness_accelerated as u8) }
    }
    ///Gets the value of [`Self::integer_dot_product64_bit_unsigned_accelerated`]
    pub fn integer_dot_product64_bit_unsigned_accelerated(&self) -> bool {
        unsafe { std::mem::transmute(self.integer_dot_product64_bit_unsigned_accelerated as u8) }
    }
    ///Gets the value of [`Self::integer_dot_product64_bit_signed_accelerated`]
    pub fn integer_dot_product64_bit_signed_accelerated(&self) -> bool {
        unsafe { std::mem::transmute(self.integer_dot_product64_bit_signed_accelerated as u8) }
    }
    ///Gets the value of [`Self::integer_dot_product64_bit_mixed_signedness_accelerated`]
    pub fn integer_dot_product64_bit_mixed_signedness_accelerated(&self) -> bool {
        unsafe { std::mem::transmute(self.integer_dot_product64_bit_mixed_signedness_accelerated as u8) }
    }
    ///Gets the value of
    /// [`Self::integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated`]
    pub fn integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated(&self) -> bool {
        unsafe { std::mem::transmute(self.integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated as u8) }
    }
    ///Gets the value of
    /// [`Self::integer_dot_product_accumulating_saturating8_bit_signed_accelerated`]
    pub fn integer_dot_product_accumulating_saturating8_bit_signed_accelerated(&self) -> bool {
        unsafe { std::mem::transmute(self.integer_dot_product_accumulating_saturating8_bit_signed_accelerated as u8) }
    }
    ///Gets the value of
    /// [`Self::integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated`]
    pub fn integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated(&self) -> bool {
        unsafe {
            std::mem::transmute(
                self.integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated as u8,
            )
        }
    }
    ///Gets the value of
    /// [`Self::integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated`]
    pub fn integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated(&self) -> bool {
        unsafe {
            std::mem::transmute(
                self.integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated as u8,
            )
        }
    }
    ///Gets the value of
    /// [`Self::integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated`]
    pub fn integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated(&self) -> bool {
        unsafe {
            std::mem::transmute(self.integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated as u8)
        }
    }
    ///Gets the value of
    /// [`Self::integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated`]
    pub fn integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated(&self) -> bool {
        unsafe {
            std::mem::transmute(
                self.integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated as u8,
            )
        }
    }
    ///Gets the value of
    /// [`Self::integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated`]
    pub fn integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated(&self) -> bool {
        unsafe {
            std::mem::transmute(self.integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated as u8)
        }
    }
    ///Gets the value of
    /// [`Self::integer_dot_product_accumulating_saturating16_bit_signed_accelerated`]
    pub fn integer_dot_product_accumulating_saturating16_bit_signed_accelerated(&self) -> bool {
        unsafe { std::mem::transmute(self.integer_dot_product_accumulating_saturating16_bit_signed_accelerated as u8) }
    }
    ///Gets the value of
    /// [`Self::integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated`]
    pub fn integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated(&self) -> bool {
        unsafe {
            std::mem::transmute(
                self.integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated as u8,
            )
        }
    }
    ///Gets the value of
    /// [`Self::integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated`]
    pub fn integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated(&self) -> bool {
        unsafe {
            std::mem::transmute(self.integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated as u8)
        }
    }
    ///Gets the value of
    /// [`Self::integer_dot_product_accumulating_saturating32_bit_signed_accelerated`]
    pub fn integer_dot_product_accumulating_saturating32_bit_signed_accelerated(&self) -> bool {
        unsafe { std::mem::transmute(self.integer_dot_product_accumulating_saturating32_bit_signed_accelerated as u8) }
    }
    ///Gets the value of
    /// [`Self::integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated`]
    pub fn integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated(&self) -> bool {
        unsafe {
            std::mem::transmute(
                self.integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated as u8,
            )
        }
    }
    ///Gets the value of
    /// [`Self::integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated`]
    pub fn integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated(&self) -> bool {
        unsafe {
            std::mem::transmute(self.integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated as u8)
        }
    }
    ///Gets the value of
    /// [`Self::integer_dot_product_accumulating_saturating64_bit_signed_accelerated`]
    pub fn integer_dot_product_accumulating_saturating64_bit_signed_accelerated(&self) -> bool {
        unsafe { std::mem::transmute(self.integer_dot_product_accumulating_saturating64_bit_signed_accelerated as u8) }
    }
    ///Gets the value of
    /// [`Self::integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated`]
    pub fn integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated(&self) -> bool {
        unsafe {
            std::mem::transmute(
                self.integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated as u8,
            )
        }
    }
    ///Gets the value of [`Self::storage_texel_buffer_offset_alignment_bytes`]
    pub fn storage_texel_buffer_offset_alignment_bytes(&self) -> DeviceSize {
        self.storage_texel_buffer_offset_alignment_bytes
    }
    ///Gets the value of [`Self::storage_texel_buffer_offset_single_texel_alignment`]
    pub fn storage_texel_buffer_offset_single_texel_alignment(&self) -> bool {
        unsafe { std::mem::transmute(self.storage_texel_buffer_offset_single_texel_alignment as u8) }
    }
    ///Gets the value of [`Self::uniform_texel_buffer_offset_alignment_bytes`]
    pub fn uniform_texel_buffer_offset_alignment_bytes(&self) -> DeviceSize {
        self.uniform_texel_buffer_offset_alignment_bytes
    }
    ///Gets the value of [`Self::uniform_texel_buffer_offset_single_texel_alignment`]
    pub fn uniform_texel_buffer_offset_single_texel_alignment(&self) -> bool {
        unsafe { std::mem::transmute(self.uniform_texel_buffer_offset_single_texel_alignment as u8) }
    }
    ///Gets the value of [`Self::max_buffer_size`]
    pub fn max_buffer_size(&self) -> DeviceSize {
        self.max_buffer_size
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next_mut(&mut self) -> &mut BaseOutStructure<'lt> {
        &mut *self.p_next
    }
    ///Gets a mutable reference to the value of [`Self::min_subgroup_size`]
    pub fn min_subgroup_size_mut(&mut self) -> &mut u32 {
        &mut self.min_subgroup_size
    }
    ///Gets a mutable reference to the value of [`Self::max_subgroup_size`]
    pub fn max_subgroup_size_mut(&mut self) -> &mut u32 {
        &mut self.max_subgroup_size
    }
    ///Gets a mutable reference to the value of [`Self::max_compute_workgroup_subgroups`]
    pub fn max_compute_workgroup_subgroups_mut(&mut self) -> &mut u32 {
        &mut self.max_compute_workgroup_subgroups
    }
    ///Gets a mutable reference to the value of [`Self::required_subgroup_size_stages`]
    pub fn required_subgroup_size_stages_mut(&mut self) -> &mut ShaderStageFlags {
        &mut self.required_subgroup_size_stages
    }
    ///Gets a mutable reference to the value of [`Self::max_inline_uniform_block_size`]
    pub fn max_inline_uniform_block_size_mut(&mut self) -> &mut u32 {
        &mut self.max_inline_uniform_block_size
    }
    ///Gets a mutable reference to the value of
    /// [`Self::max_per_stage_descriptor_inline_uniform_blocks`]
    pub fn max_per_stage_descriptor_inline_uniform_blocks_mut(&mut self) -> &mut u32 {
        &mut self.max_per_stage_descriptor_inline_uniform_blocks
    }
    ///Gets a mutable reference to the value of
    /// [`Self::max_per_stage_descriptor_update_after_bind_inline_uniform_blocks`]
    pub fn max_per_stage_descriptor_update_after_bind_inline_uniform_blocks_mut(&mut self) -> &mut u32 {
        &mut self.max_per_stage_descriptor_update_after_bind_inline_uniform_blocks
    }
    ///Gets a mutable reference to the value of [`Self::max_descriptor_set_inline_uniform_blocks`]
    pub fn max_descriptor_set_inline_uniform_blocks_mut(&mut self) -> &mut u32 {
        &mut self.max_descriptor_set_inline_uniform_blocks
    }
    ///Gets a mutable reference to the value of
    /// [`Self::max_descriptor_set_update_after_bind_inline_uniform_blocks`]
    pub fn max_descriptor_set_update_after_bind_inline_uniform_blocks_mut(&mut self) -> &mut u32 {
        &mut self.max_descriptor_set_update_after_bind_inline_uniform_blocks
    }
    ///Gets a mutable reference to the value of [`Self::max_inline_uniform_total_size`]
    pub fn max_inline_uniform_total_size_mut(&mut self) -> &mut u32 {
        &mut self.max_inline_uniform_total_size
    }
    ///Gets a mutable reference to the value of
    /// [`Self::integer_dot_product8_bit_unsigned_accelerated`]
    pub fn integer_dot_product8_bit_unsigned_accelerated_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.integer_dot_product8_bit_unsigned_accelerated as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.integer_dot_product8_bit_unsigned_accelerated as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of
    /// [`Self::integer_dot_product8_bit_signed_accelerated`]
    pub fn integer_dot_product8_bit_signed_accelerated_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.integer_dot_product8_bit_signed_accelerated as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.integer_dot_product8_bit_signed_accelerated as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of
    /// [`Self::integer_dot_product8_bit_mixed_signedness_accelerated`]
    pub fn integer_dot_product8_bit_mixed_signedness_accelerated_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.integer_dot_product8_bit_mixed_signedness_accelerated as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.integer_dot_product8_bit_mixed_signedness_accelerated as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of
    /// [`Self::integer_dot_product4x8_bit_packed_unsigned_accelerated`]
    pub fn integer_dot_product4x8_bit_packed_unsigned_accelerated_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.integer_dot_product4x8_bit_packed_unsigned_accelerated as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.integer_dot_product4x8_bit_packed_unsigned_accelerated as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of
    /// [`Self::integer_dot_product4x8_bit_packed_signed_accelerated`]
    pub fn integer_dot_product4x8_bit_packed_signed_accelerated_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.integer_dot_product4x8_bit_packed_signed_accelerated as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.integer_dot_product4x8_bit_packed_signed_accelerated as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of
    /// [`Self::integer_dot_product4x8_bit_packed_mixed_signedness_accelerated`]
    pub fn integer_dot_product4x8_bit_packed_mixed_signedness_accelerated_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.integer_dot_product4x8_bit_packed_mixed_signedness_accelerated as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.integer_dot_product4x8_bit_packed_mixed_signedness_accelerated as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of
    /// [`Self::integer_dot_product16_bit_unsigned_accelerated`]
    pub fn integer_dot_product16_bit_unsigned_accelerated_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.integer_dot_product16_bit_unsigned_accelerated as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.integer_dot_product16_bit_unsigned_accelerated as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of
    /// [`Self::integer_dot_product16_bit_signed_accelerated`]
    pub fn integer_dot_product16_bit_signed_accelerated_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.integer_dot_product16_bit_signed_accelerated as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.integer_dot_product16_bit_signed_accelerated as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of
    /// [`Self::integer_dot_product16_bit_mixed_signedness_accelerated`]
    pub fn integer_dot_product16_bit_mixed_signedness_accelerated_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.integer_dot_product16_bit_mixed_signedness_accelerated as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.integer_dot_product16_bit_mixed_signedness_accelerated as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of
    /// [`Self::integer_dot_product32_bit_unsigned_accelerated`]
    pub fn integer_dot_product32_bit_unsigned_accelerated_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.integer_dot_product32_bit_unsigned_accelerated as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.integer_dot_product32_bit_unsigned_accelerated as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of
    /// [`Self::integer_dot_product32_bit_signed_accelerated`]
    pub fn integer_dot_product32_bit_signed_accelerated_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.integer_dot_product32_bit_signed_accelerated as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.integer_dot_product32_bit_signed_accelerated as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of
    /// [`Self::integer_dot_product32_bit_mixed_signedness_accelerated`]
    pub fn integer_dot_product32_bit_mixed_signedness_accelerated_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.integer_dot_product32_bit_mixed_signedness_accelerated as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.integer_dot_product32_bit_mixed_signedness_accelerated as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of
    /// [`Self::integer_dot_product64_bit_unsigned_accelerated`]
    pub fn integer_dot_product64_bit_unsigned_accelerated_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.integer_dot_product64_bit_unsigned_accelerated as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.integer_dot_product64_bit_unsigned_accelerated as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of
    /// [`Self::integer_dot_product64_bit_signed_accelerated`]
    pub fn integer_dot_product64_bit_signed_accelerated_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.integer_dot_product64_bit_signed_accelerated as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.integer_dot_product64_bit_signed_accelerated as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of
    /// [`Self::integer_dot_product64_bit_mixed_signedness_accelerated`]
    pub fn integer_dot_product64_bit_mixed_signedness_accelerated_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.integer_dot_product64_bit_mixed_signedness_accelerated as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.integer_dot_product64_bit_mixed_signedness_accelerated as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of
    /// [`Self::integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated`]
    pub fn integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of
    /// [`Self::integer_dot_product_accumulating_saturating8_bit_signed_accelerated`]
    pub fn integer_dot_product_accumulating_saturating8_bit_signed_accelerated_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.integer_dot_product_accumulating_saturating8_bit_signed_accelerated as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.integer_dot_product_accumulating_saturating8_bit_signed_accelerated as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of
    /// [`Self::integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated`]
    pub fn integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated
                    as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated
                    as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of
    /// [`Self::integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated`]
    pub fn integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated
                    as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated
                    as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of
    /// [`Self::integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated`]
    pub fn integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of
    /// [`Self::integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated`]
    pub fn integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated_mut(
        &mut self,
    ) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated
                    as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated
                    as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of
    /// [`Self::integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated`]
    pub fn integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of
    /// [`Self::integer_dot_product_accumulating_saturating16_bit_signed_accelerated`]
    pub fn integer_dot_product_accumulating_saturating16_bit_signed_accelerated_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.integer_dot_product_accumulating_saturating16_bit_signed_accelerated as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.integer_dot_product_accumulating_saturating16_bit_signed_accelerated as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of
    /// [`Self::integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated`]
    pub fn integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated
                    as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated
                    as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of
    /// [`Self::integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated`]
    pub fn integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of
    /// [`Self::integer_dot_product_accumulating_saturating32_bit_signed_accelerated`]
    pub fn integer_dot_product_accumulating_saturating32_bit_signed_accelerated_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.integer_dot_product_accumulating_saturating32_bit_signed_accelerated as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.integer_dot_product_accumulating_saturating32_bit_signed_accelerated as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of
    /// [`Self::integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated`]
    pub fn integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated
                    as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated
                    as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of
    /// [`Self::integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated`]
    pub fn integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of
    /// [`Self::integer_dot_product_accumulating_saturating64_bit_signed_accelerated`]
    pub fn integer_dot_product_accumulating_saturating64_bit_signed_accelerated_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.integer_dot_product_accumulating_saturating64_bit_signed_accelerated as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.integer_dot_product_accumulating_saturating64_bit_signed_accelerated as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of
    /// [`Self::integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated`]
    pub fn integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated
                    as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated
                    as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of
    /// [`Self::storage_texel_buffer_offset_alignment_bytes`]
    pub fn storage_texel_buffer_offset_alignment_bytes_mut(&mut self) -> &mut DeviceSize {
        &mut self.storage_texel_buffer_offset_alignment_bytes
    }
    ///Gets a mutable reference to the value of
    /// [`Self::storage_texel_buffer_offset_single_texel_alignment`]
    pub fn storage_texel_buffer_offset_single_texel_alignment_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.storage_texel_buffer_offset_single_texel_alignment as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.storage_texel_buffer_offset_single_texel_alignment as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of
    /// [`Self::uniform_texel_buffer_offset_alignment_bytes`]
    pub fn uniform_texel_buffer_offset_alignment_bytes_mut(&mut self) -> &mut DeviceSize {
        &mut self.uniform_texel_buffer_offset_alignment_bytes
    }
    ///Gets a mutable reference to the value of
    /// [`Self::uniform_texel_buffer_offset_single_texel_alignment`]
    pub fn uniform_texel_buffer_offset_single_texel_alignment_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.uniform_texel_buffer_offset_single_texel_alignment as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.uniform_texel_buffer_offset_single_texel_alignment as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of [`Self::max_buffer_size`]
    pub fn max_buffer_size_mut(&mut self) -> &mut DeviceSize {
        &mut self.max_buffer_size
    }
    ///Sets the value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt mut crate::vulkan1_0::BaseOutStructure<'lt>) -> &mut Self {
        self.p_next = value as *mut _;
        self
    }
    ///Sets the value of [`Self::min_subgroup_size`]
    pub fn set_min_subgroup_size(&mut self, value: u32) -> &mut Self {
        self.min_subgroup_size = value;
        self
    }
    ///Sets the value of [`Self::max_subgroup_size`]
    pub fn set_max_subgroup_size(&mut self, value: u32) -> &mut Self {
        self.max_subgroup_size = value;
        self
    }
    ///Sets the value of [`Self::max_compute_workgroup_subgroups`]
    pub fn set_max_compute_workgroup_subgroups(&mut self, value: u32) -> &mut Self {
        self.max_compute_workgroup_subgroups = value;
        self
    }
    ///Sets the value of [`Self::required_subgroup_size_stages`]
    pub fn set_required_subgroup_size_stages(&mut self, value: crate::vulkan1_0::ShaderStageFlags) -> &mut Self {
        self.required_subgroup_size_stages = value;
        self
    }
    ///Sets the value of [`Self::max_inline_uniform_block_size`]
    pub fn set_max_inline_uniform_block_size(&mut self, value: u32) -> &mut Self {
        self.max_inline_uniform_block_size = value;
        self
    }
    ///Sets the value of [`Self::max_per_stage_descriptor_inline_uniform_blocks`]
    pub fn set_max_per_stage_descriptor_inline_uniform_blocks(&mut self, value: u32) -> &mut Self {
        self.max_per_stage_descriptor_inline_uniform_blocks = value;
        self
    }
    ///Sets the value of [`Self::max_per_stage_descriptor_update_after_bind_inline_uniform_blocks`]
    pub fn set_max_per_stage_descriptor_update_after_bind_inline_uniform_blocks(&mut self, value: u32) -> &mut Self {
        self.max_per_stage_descriptor_update_after_bind_inline_uniform_blocks = value;
        self
    }
    ///Sets the value of [`Self::max_descriptor_set_inline_uniform_blocks`]
    pub fn set_max_descriptor_set_inline_uniform_blocks(&mut self, value: u32) -> &mut Self {
        self.max_descriptor_set_inline_uniform_blocks = value;
        self
    }
    ///Sets the value of [`Self::max_descriptor_set_update_after_bind_inline_uniform_blocks`]
    pub fn set_max_descriptor_set_update_after_bind_inline_uniform_blocks(&mut self, value: u32) -> &mut Self {
        self.max_descriptor_set_update_after_bind_inline_uniform_blocks = value;
        self
    }
    ///Sets the value of [`Self::max_inline_uniform_total_size`]
    pub fn set_max_inline_uniform_total_size(&mut self, value: u32) -> &mut Self {
        self.max_inline_uniform_total_size = value;
        self
    }
    ///Sets the value of [`Self::integer_dot_product8_bit_unsigned_accelerated`]
    pub fn set_integer_dot_product8_bit_unsigned_accelerated(&mut self, value: bool) -> &mut Self {
        self.integer_dot_product8_bit_unsigned_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::integer_dot_product8_bit_signed_accelerated`]
    pub fn set_integer_dot_product8_bit_signed_accelerated(&mut self, value: bool) -> &mut Self {
        self.integer_dot_product8_bit_signed_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::integer_dot_product8_bit_mixed_signedness_accelerated`]
    pub fn set_integer_dot_product8_bit_mixed_signedness_accelerated(&mut self, value: bool) -> &mut Self {
        self.integer_dot_product8_bit_mixed_signedness_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::integer_dot_product4x8_bit_packed_unsigned_accelerated`]
    pub fn set_integer_dot_product4x8_bit_packed_unsigned_accelerated(&mut self, value: bool) -> &mut Self {
        self.integer_dot_product4x8_bit_packed_unsigned_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::integer_dot_product4x8_bit_packed_signed_accelerated`]
    pub fn set_integer_dot_product4x8_bit_packed_signed_accelerated(&mut self, value: bool) -> &mut Self {
        self.integer_dot_product4x8_bit_packed_signed_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::integer_dot_product4x8_bit_packed_mixed_signedness_accelerated`]
    pub fn set_integer_dot_product4x8_bit_packed_mixed_signedness_accelerated(&mut self, value: bool) -> &mut Self {
        self.integer_dot_product4x8_bit_packed_mixed_signedness_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::integer_dot_product16_bit_unsigned_accelerated`]
    pub fn set_integer_dot_product16_bit_unsigned_accelerated(&mut self, value: bool) -> &mut Self {
        self.integer_dot_product16_bit_unsigned_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::integer_dot_product16_bit_signed_accelerated`]
    pub fn set_integer_dot_product16_bit_signed_accelerated(&mut self, value: bool) -> &mut Self {
        self.integer_dot_product16_bit_signed_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::integer_dot_product16_bit_mixed_signedness_accelerated`]
    pub fn set_integer_dot_product16_bit_mixed_signedness_accelerated(&mut self, value: bool) -> &mut Self {
        self.integer_dot_product16_bit_mixed_signedness_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::integer_dot_product32_bit_unsigned_accelerated`]
    pub fn set_integer_dot_product32_bit_unsigned_accelerated(&mut self, value: bool) -> &mut Self {
        self.integer_dot_product32_bit_unsigned_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::integer_dot_product32_bit_signed_accelerated`]
    pub fn set_integer_dot_product32_bit_signed_accelerated(&mut self, value: bool) -> &mut Self {
        self.integer_dot_product32_bit_signed_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::integer_dot_product32_bit_mixed_signedness_accelerated`]
    pub fn set_integer_dot_product32_bit_mixed_signedness_accelerated(&mut self, value: bool) -> &mut Self {
        self.integer_dot_product32_bit_mixed_signedness_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::integer_dot_product64_bit_unsigned_accelerated`]
    pub fn set_integer_dot_product64_bit_unsigned_accelerated(&mut self, value: bool) -> &mut Self {
        self.integer_dot_product64_bit_unsigned_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::integer_dot_product64_bit_signed_accelerated`]
    pub fn set_integer_dot_product64_bit_signed_accelerated(&mut self, value: bool) -> &mut Self {
        self.integer_dot_product64_bit_signed_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::integer_dot_product64_bit_mixed_signedness_accelerated`]
    pub fn set_integer_dot_product64_bit_mixed_signedness_accelerated(&mut self, value: bool) -> &mut Self {
        self.integer_dot_product64_bit_mixed_signedness_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of
    /// [`Self::integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated`]
    pub fn set_integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated(
        &mut self,
        value: bool,
    ) -> &mut Self {
        self.integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of
    /// [`Self::integer_dot_product_accumulating_saturating8_bit_signed_accelerated`]
    pub fn set_integer_dot_product_accumulating_saturating8_bit_signed_accelerated(
        &mut self,
        value: bool,
    ) -> &mut Self {
        self.integer_dot_product_accumulating_saturating8_bit_signed_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of
    /// [`Self::integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated`]
    pub fn set_integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated(
        &mut self,
        value: bool,
    ) -> &mut Self {
        self.integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of
    /// [`Self::integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated`]
    pub fn set_integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated(
        &mut self,
        value: bool,
    ) -> &mut Self {
        self.integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of
    /// [`Self::integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated`]
    pub fn set_integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated(
        &mut self,
        value: bool,
    ) -> &mut Self {
        self.integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of
    /// [`Self::integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated`]
    pub fn set_integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated(
        &mut self,
        value: bool,
    ) -> &mut Self {
        self.integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated =
            value as u8 as u32;
        self
    }
    ///Sets the value of
    /// [`Self::integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated`]
    pub fn set_integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated(
        &mut self,
        value: bool,
    ) -> &mut Self {
        self.integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of
    /// [`Self::integer_dot_product_accumulating_saturating16_bit_signed_accelerated`]
    pub fn set_integer_dot_product_accumulating_saturating16_bit_signed_accelerated(
        &mut self,
        value: bool,
    ) -> &mut Self {
        self.integer_dot_product_accumulating_saturating16_bit_signed_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of
    /// [`Self::integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated`]
    pub fn set_integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated(
        &mut self,
        value: bool,
    ) -> &mut Self {
        self.integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of
    /// [`Self::integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated`]
    pub fn set_integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated(
        &mut self,
        value: bool,
    ) -> &mut Self {
        self.integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of
    /// [`Self::integer_dot_product_accumulating_saturating32_bit_signed_accelerated`]
    pub fn set_integer_dot_product_accumulating_saturating32_bit_signed_accelerated(
        &mut self,
        value: bool,
    ) -> &mut Self {
        self.integer_dot_product_accumulating_saturating32_bit_signed_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of
    /// [`Self::integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated`]
    pub fn set_integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated(
        &mut self,
        value: bool,
    ) -> &mut Self {
        self.integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of
    /// [`Self::integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated`]
    pub fn set_integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated(
        &mut self,
        value: bool,
    ) -> &mut Self {
        self.integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of
    /// [`Self::integer_dot_product_accumulating_saturating64_bit_signed_accelerated`]
    pub fn set_integer_dot_product_accumulating_saturating64_bit_signed_accelerated(
        &mut self,
        value: bool,
    ) -> &mut Self {
        self.integer_dot_product_accumulating_saturating64_bit_signed_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of
    /// [`Self::integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated`]
    pub fn set_integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated(
        &mut self,
        value: bool,
    ) -> &mut Self {
        self.integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::storage_texel_buffer_offset_alignment_bytes`]
    pub fn set_storage_texel_buffer_offset_alignment_bytes(
        &mut self,
        value: crate::vulkan1_0::DeviceSize,
    ) -> &mut Self {
        self.storage_texel_buffer_offset_alignment_bytes = value;
        self
    }
    ///Sets the value of [`Self::storage_texel_buffer_offset_single_texel_alignment`]
    pub fn set_storage_texel_buffer_offset_single_texel_alignment(&mut self, value: bool) -> &mut Self {
        self.storage_texel_buffer_offset_single_texel_alignment = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::uniform_texel_buffer_offset_alignment_bytes`]
    pub fn set_uniform_texel_buffer_offset_alignment_bytes(
        &mut self,
        value: crate::vulkan1_0::DeviceSize,
    ) -> &mut Self {
        self.uniform_texel_buffer_offset_alignment_bytes = value;
        self
    }
    ///Sets the value of [`Self::uniform_texel_buffer_offset_single_texel_alignment`]
    pub fn set_uniform_texel_buffer_offset_single_texel_alignment(&mut self, value: bool) -> &mut Self {
        self.uniform_texel_buffer_offset_single_texel_alignment = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::max_buffer_size`]
    pub fn set_max_buffer_size(&mut self, value: crate::vulkan1_0::DeviceSize) -> &mut Self {
        self.max_buffer_size = value;
        self
    }
    ///Sets the value of [`Self::s_type`]
    pub fn with_s_type(mut self, value: crate::vulkan1_0::StructureType) -> Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn with_p_next(mut self, value: &'lt mut crate::vulkan1_0::BaseOutStructure<'lt>) -> Self {
        self.p_next = value as *mut _;
        self
    }
    ///Sets the value of [`Self::min_subgroup_size`]
    pub fn with_min_subgroup_size(mut self, value: u32) -> Self {
        self.min_subgroup_size = value;
        self
    }
    ///Sets the value of [`Self::max_subgroup_size`]
    pub fn with_max_subgroup_size(mut self, value: u32) -> Self {
        self.max_subgroup_size = value;
        self
    }
    ///Sets the value of [`Self::max_compute_workgroup_subgroups`]
    pub fn with_max_compute_workgroup_subgroups(mut self, value: u32) -> Self {
        self.max_compute_workgroup_subgroups = value;
        self
    }
    ///Sets the value of [`Self::required_subgroup_size_stages`]
    pub fn with_required_subgroup_size_stages(mut self, value: crate::vulkan1_0::ShaderStageFlags) -> Self {
        self.required_subgroup_size_stages = value;
        self
    }
    ///Sets the value of [`Self::max_inline_uniform_block_size`]
    pub fn with_max_inline_uniform_block_size(mut self, value: u32) -> Self {
        self.max_inline_uniform_block_size = value;
        self
    }
    ///Sets the value of [`Self::max_per_stage_descriptor_inline_uniform_blocks`]
    pub fn with_max_per_stage_descriptor_inline_uniform_blocks(mut self, value: u32) -> Self {
        self.max_per_stage_descriptor_inline_uniform_blocks = value;
        self
    }
    ///Sets the value of [`Self::max_per_stage_descriptor_update_after_bind_inline_uniform_blocks`]
    pub fn with_max_per_stage_descriptor_update_after_bind_inline_uniform_blocks(mut self, value: u32) -> Self {
        self.max_per_stage_descriptor_update_after_bind_inline_uniform_blocks = value;
        self
    }
    ///Sets the value of [`Self::max_descriptor_set_inline_uniform_blocks`]
    pub fn with_max_descriptor_set_inline_uniform_blocks(mut self, value: u32) -> Self {
        self.max_descriptor_set_inline_uniform_blocks = value;
        self
    }
    ///Sets the value of [`Self::max_descriptor_set_update_after_bind_inline_uniform_blocks`]
    pub fn with_max_descriptor_set_update_after_bind_inline_uniform_blocks(mut self, value: u32) -> Self {
        self.max_descriptor_set_update_after_bind_inline_uniform_blocks = value;
        self
    }
    ///Sets the value of [`Self::max_inline_uniform_total_size`]
    pub fn with_max_inline_uniform_total_size(mut self, value: u32) -> Self {
        self.max_inline_uniform_total_size = value;
        self
    }
    ///Sets the value of [`Self::integer_dot_product8_bit_unsigned_accelerated`]
    pub fn with_integer_dot_product8_bit_unsigned_accelerated(mut self, value: bool) -> Self {
        self.integer_dot_product8_bit_unsigned_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::integer_dot_product8_bit_signed_accelerated`]
    pub fn with_integer_dot_product8_bit_signed_accelerated(mut self, value: bool) -> Self {
        self.integer_dot_product8_bit_signed_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::integer_dot_product8_bit_mixed_signedness_accelerated`]
    pub fn with_integer_dot_product8_bit_mixed_signedness_accelerated(mut self, value: bool) -> Self {
        self.integer_dot_product8_bit_mixed_signedness_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::integer_dot_product4x8_bit_packed_unsigned_accelerated`]
    pub fn with_integer_dot_product4x8_bit_packed_unsigned_accelerated(mut self, value: bool) -> Self {
        self.integer_dot_product4x8_bit_packed_unsigned_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::integer_dot_product4x8_bit_packed_signed_accelerated`]
    pub fn with_integer_dot_product4x8_bit_packed_signed_accelerated(mut self, value: bool) -> Self {
        self.integer_dot_product4x8_bit_packed_signed_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::integer_dot_product4x8_bit_packed_mixed_signedness_accelerated`]
    pub fn with_integer_dot_product4x8_bit_packed_mixed_signedness_accelerated(mut self, value: bool) -> Self {
        self.integer_dot_product4x8_bit_packed_mixed_signedness_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::integer_dot_product16_bit_unsigned_accelerated`]
    pub fn with_integer_dot_product16_bit_unsigned_accelerated(mut self, value: bool) -> Self {
        self.integer_dot_product16_bit_unsigned_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::integer_dot_product16_bit_signed_accelerated`]
    pub fn with_integer_dot_product16_bit_signed_accelerated(mut self, value: bool) -> Self {
        self.integer_dot_product16_bit_signed_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::integer_dot_product16_bit_mixed_signedness_accelerated`]
    pub fn with_integer_dot_product16_bit_mixed_signedness_accelerated(mut self, value: bool) -> Self {
        self.integer_dot_product16_bit_mixed_signedness_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::integer_dot_product32_bit_unsigned_accelerated`]
    pub fn with_integer_dot_product32_bit_unsigned_accelerated(mut self, value: bool) -> Self {
        self.integer_dot_product32_bit_unsigned_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::integer_dot_product32_bit_signed_accelerated`]
    pub fn with_integer_dot_product32_bit_signed_accelerated(mut self, value: bool) -> Self {
        self.integer_dot_product32_bit_signed_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::integer_dot_product32_bit_mixed_signedness_accelerated`]
    pub fn with_integer_dot_product32_bit_mixed_signedness_accelerated(mut self, value: bool) -> Self {
        self.integer_dot_product32_bit_mixed_signedness_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::integer_dot_product64_bit_unsigned_accelerated`]
    pub fn with_integer_dot_product64_bit_unsigned_accelerated(mut self, value: bool) -> Self {
        self.integer_dot_product64_bit_unsigned_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::integer_dot_product64_bit_signed_accelerated`]
    pub fn with_integer_dot_product64_bit_signed_accelerated(mut self, value: bool) -> Self {
        self.integer_dot_product64_bit_signed_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::integer_dot_product64_bit_mixed_signedness_accelerated`]
    pub fn with_integer_dot_product64_bit_mixed_signedness_accelerated(mut self, value: bool) -> Self {
        self.integer_dot_product64_bit_mixed_signedness_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of
    /// [`Self::integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated`]
    pub fn with_integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated(mut self, value: bool) -> Self {
        self.integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of
    /// [`Self::integer_dot_product_accumulating_saturating8_bit_signed_accelerated`]
    pub fn with_integer_dot_product_accumulating_saturating8_bit_signed_accelerated(mut self, value: bool) -> Self {
        self.integer_dot_product_accumulating_saturating8_bit_signed_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of
    /// [`Self::integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated`]
    pub fn with_integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated(
        mut self,
        value: bool,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of
    /// [`Self::integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated`]
    pub fn with_integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated(
        mut self,
        value: bool,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of
    /// [`Self::integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated`]
    pub fn with_integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated(
        mut self,
        value: bool,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of
    /// [`Self::integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated`]
    pub fn with_integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated(
        mut self,
        value: bool,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated =
            value as u8 as u32;
        self
    }
    ///Sets the value of
    /// [`Self::integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated`]
    pub fn with_integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated(mut self, value: bool) -> Self {
        self.integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of
    /// [`Self::integer_dot_product_accumulating_saturating16_bit_signed_accelerated`]
    pub fn with_integer_dot_product_accumulating_saturating16_bit_signed_accelerated(mut self, value: bool) -> Self {
        self.integer_dot_product_accumulating_saturating16_bit_signed_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of
    /// [`Self::integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated`]
    pub fn with_integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated(
        mut self,
        value: bool,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of
    /// [`Self::integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated`]
    pub fn with_integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated(mut self, value: bool) -> Self {
        self.integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of
    /// [`Self::integer_dot_product_accumulating_saturating32_bit_signed_accelerated`]
    pub fn with_integer_dot_product_accumulating_saturating32_bit_signed_accelerated(mut self, value: bool) -> Self {
        self.integer_dot_product_accumulating_saturating32_bit_signed_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of
    /// [`Self::integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated`]
    pub fn with_integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated(
        mut self,
        value: bool,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of
    /// [`Self::integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated`]
    pub fn with_integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated(mut self, value: bool) -> Self {
        self.integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of
    /// [`Self::integer_dot_product_accumulating_saturating64_bit_signed_accelerated`]
    pub fn with_integer_dot_product_accumulating_saturating64_bit_signed_accelerated(mut self, value: bool) -> Self {
        self.integer_dot_product_accumulating_saturating64_bit_signed_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of
    /// [`Self::integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated`]
    pub fn with_integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated(
        mut self,
        value: bool,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::storage_texel_buffer_offset_alignment_bytes`]
    pub fn with_storage_texel_buffer_offset_alignment_bytes(mut self, value: crate::vulkan1_0::DeviceSize) -> Self {
        self.storage_texel_buffer_offset_alignment_bytes = value;
        self
    }
    ///Sets the value of [`Self::storage_texel_buffer_offset_single_texel_alignment`]
    pub fn with_storage_texel_buffer_offset_single_texel_alignment(mut self, value: bool) -> Self {
        self.storage_texel_buffer_offset_single_texel_alignment = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::uniform_texel_buffer_offset_alignment_bytes`]
    pub fn with_uniform_texel_buffer_offset_alignment_bytes(mut self, value: crate::vulkan1_0::DeviceSize) -> Self {
        self.uniform_texel_buffer_offset_alignment_bytes = value;
        self
    }
    ///Sets the value of [`Self::uniform_texel_buffer_offset_single_texel_alignment`]
    pub fn with_uniform_texel_buffer_offset_single_texel_alignment(mut self, value: bool) -> Self {
        self.uniform_texel_buffer_offset_single_texel_alignment = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::max_buffer_size`]
    pub fn with_max_buffer_size(mut self, value: crate::vulkan1_0::DeviceSize) -> Self {
        self.max_buffer_size = value;
        self
    }
}
///[VkPhysicalDeviceToolProperties](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceToolProperties.html) - Structure providing information about an active tool
///# C Specifications
///The [`PhysicalDeviceToolProperties`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_3
///typedef struct VkPhysicalDeviceToolProperties {
///    VkStructureType       sType;
///    void*                 pNext;
///    char                  name[VK_MAX_EXTENSION_NAME_SIZE];
///    char                  version[VK_MAX_EXTENSION_NAME_SIZE];
///    VkToolPurposeFlags    purposes;
///    char                  description[VK_MAX_DESCRIPTION_SIZE];
///    char                  layer[VK_MAX_EXTENSION_NAME_SIZE];
///} VkPhysicalDeviceToolProperties;
///```
///or the equivalent
///```c
///// Provided by VK_EXT_tooling_info
///typedef VkPhysicalDeviceToolProperties VkPhysicalDeviceToolPropertiesEXT;
///```
///# Members
/// - [`s_type`] is the type of this structure.
/// - [`p_next`] is `NULL` or a pointer to a structure extending this structure.
/// - [`name`] is a null-terminated UTF-8 string containing the name of the tool.
/// - [`version`] is a null-terminated UTF-8 string containing the version of the tool.
/// - [`purposes`] is a bitmask of [`ToolPurposeFlagBits`] which is populated with purposes
///   supported by the tool.
/// - [`description`] is a null-terminated UTF-8 string containing a description of the tool.
/// - [`layer`] is a null-terminated UTF-8 string containing the name of the layer implementing the
///   tool, if the tool is implemented in a layer - otherwise it  **may**  be an empty string.
///# Description
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be `VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES`
/// - [`p_next`] **must**  be `NULL`
///# Related
/// - [`ext_tooling_info`]
/// - [`crate::vulkan1_3`]
/// - [`StructureType`]
/// - [`ToolPurposeFlags`]
/// - [`get_physical_device_tool_properties`]
/// - [`get_physical_device_tool_properties_ext`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkPhysicalDeviceToolProperties")]
#[derive(Debug, Clone, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[repr(C)]
pub struct PhysicalDeviceToolProperties<'lt> {
    ///Lifetime field
    pub _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] is the type of this structure.
    pub s_type: StructureType,
    ///[`p_next`] is `NULL` or a pointer to a structure extending this
    ///structure.
    pub p_next: *mut BaseOutStructure<'lt>,
    ///[`name`] is a null-terminated UTF-8 string containing the name of the
    ///tool.
    pub name: [c_char; MAX_EXTENSION_NAME_SIZE as usize],
    ///[`version`] is a null-terminated UTF-8 string containing the version
    ///of the tool.
    pub version: [c_char; MAX_EXTENSION_NAME_SIZE as usize],
    ///[`purposes`] is a bitmask of [`ToolPurposeFlagBits`] which is
    ///populated with purposes supported by the tool.
    pub purposes: ToolPurposeFlags,
    ///[`description`] is a null-terminated UTF-8 string containing a
    ///description of the tool.
    pub description: [c_char; MAX_DESCRIPTION_SIZE as usize],
    ///[`layer`] is a null-terminated UTF-8 string containing the name of the
    ///layer implementing the tool, if the tool is implemented in a layer -
    ///otherwise it  **may**  be an empty string.
    pub layer: [c_char; MAX_EXTENSION_NAME_SIZE as usize],
}
impl<'lt> Default for PhysicalDeviceToolProperties<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: StructureType::PHYSICAL_DEVICE_TOOL_PROPERTIES,
            p_next: std::ptr::null_mut(),
            name: [b'\0' as i8; MAX_EXTENSION_NAME_SIZE as usize],
            version: [b'\0' as i8; MAX_EXTENSION_NAME_SIZE as usize],
            purposes: Default::default(),
            description: [b'\0' as i8; MAX_DESCRIPTION_SIZE as usize],
            layer: [b'\0' as i8; MAX_EXTENSION_NAME_SIZE as usize],
        }
    }
}
impl<'lt> PhysicalDeviceToolProperties<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *mut BaseOutStructure<'lt> {
        self.p_next
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *mut BaseOutStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn with_p_next_raw(mut self, value: *mut BaseOutStructure<'lt>) -> Self {
        self.p_next = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseOutStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::name`]
    pub fn name(&self) -> &[c_char; MAX_EXTENSION_NAME_SIZE as usize] {
        &self.name
    }
    ///Gets the value of [`Self::version`]
    pub fn version(&self) -> &[c_char; MAX_EXTENSION_NAME_SIZE as usize] {
        &self.version
    }
    ///Gets the value of [`Self::purposes`]
    pub fn purposes(&self) -> ToolPurposeFlags {
        self.purposes
    }
    ///Gets the value of [`Self::description`]
    pub fn description(&self) -> &[c_char; MAX_DESCRIPTION_SIZE as usize] {
        &self.description
    }
    ///Gets the value of [`Self::layer`]
    pub fn layer(&self) -> &[c_char; MAX_EXTENSION_NAME_SIZE as usize] {
        &self.layer
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next_mut(&mut self) -> &mut BaseOutStructure<'lt> {
        &mut *self.p_next
    }
    ///Gets a mutable reference to the value of [`Self::name`]
    pub fn name_mut(&mut self) -> &mut [c_char; MAX_EXTENSION_NAME_SIZE as usize] {
        &mut self.name
    }
    ///Gets a mutable reference to the value of [`Self::version`]
    pub fn version_mut(&mut self) -> &mut [c_char; MAX_EXTENSION_NAME_SIZE as usize] {
        &mut self.version
    }
    ///Gets a mutable reference to the value of [`Self::purposes`]
    pub fn purposes_mut(&mut self) -> &mut ToolPurposeFlags {
        &mut self.purposes
    }
    ///Gets a mutable reference to the value of [`Self::description`]
    pub fn description_mut(&mut self) -> &mut [c_char; MAX_DESCRIPTION_SIZE as usize] {
        &mut self.description
    }
    ///Gets a mutable reference to the value of [`Self::layer`]
    pub fn layer_mut(&mut self) -> &mut [c_char; MAX_EXTENSION_NAME_SIZE as usize] {
        &mut self.layer
    }
    ///Sets the value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt mut crate::vulkan1_0::BaseOutStructure<'lt>) -> &mut Self {
        self.p_next = value as *mut _;
        self
    }
    ///Sets the value of [`Self::name`]
    pub fn set_name(
        &mut self,
        value: [std::os::raw::c_char; crate::core::MAX_EXTENSION_NAME_SIZE as usize],
    ) -> &mut Self {
        self.name = value;
        self
    }
    ///Sets the value of [`Self::version`]
    pub fn set_version(
        &mut self,
        value: [std::os::raw::c_char; crate::core::MAX_EXTENSION_NAME_SIZE as usize],
    ) -> &mut Self {
        self.version = value;
        self
    }
    ///Sets the value of [`Self::purposes`]
    pub fn set_purposes(&mut self, value: crate::vulkan1_3::ToolPurposeFlags) -> &mut Self {
        self.purposes = value;
        self
    }
    ///Sets the value of [`Self::description`]
    pub fn set_description(
        &mut self,
        value: [std::os::raw::c_char; crate::core::MAX_DESCRIPTION_SIZE as usize],
    ) -> &mut Self {
        self.description = value;
        self
    }
    ///Sets the value of [`Self::layer`]
    pub fn set_layer(
        &mut self,
        value: [std::os::raw::c_char; crate::core::MAX_EXTENSION_NAME_SIZE as usize],
    ) -> &mut Self {
        self.layer = value;
        self
    }
    ///Sets the value of [`Self::s_type`]
    pub fn with_s_type(mut self, value: crate::vulkan1_0::StructureType) -> Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn with_p_next(mut self, value: &'lt mut crate::vulkan1_0::BaseOutStructure<'lt>) -> Self {
        self.p_next = value as *mut _;
        self
    }
    ///Sets the value of [`Self::name`]
    pub fn with_name(mut self, value: [std::os::raw::c_char; crate::core::MAX_EXTENSION_NAME_SIZE as usize]) -> Self {
        self.name = value;
        self
    }
    ///Sets the value of [`Self::version`]
    pub fn with_version(
        mut self,
        value: [std::os::raw::c_char; crate::core::MAX_EXTENSION_NAME_SIZE as usize],
    ) -> Self {
        self.version = value;
        self
    }
    ///Sets the value of [`Self::purposes`]
    pub fn with_purposes(mut self, value: crate::vulkan1_3::ToolPurposeFlags) -> Self {
        self.purposes = value;
        self
    }
    ///Sets the value of [`Self::description`]
    pub fn with_description(
        mut self,
        value: [std::os::raw::c_char; crate::core::MAX_DESCRIPTION_SIZE as usize],
    ) -> Self {
        self.description = value;
        self
    }
    ///Sets the value of [`Self::layer`]
    pub fn with_layer(mut self, value: [std::os::raw::c_char; crate::core::MAX_EXTENSION_NAME_SIZE as usize]) -> Self {
        self.layer = value;
        self
    }
}
///[VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures.html) - Structure describing support for zero initialization of workgroup memory by an implementation
///# C Specifications
///The [`PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures`] structure is
///defined as:
///```c
///// Provided by VK_VERSION_1_3
///typedef struct VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures {
///    VkStructureType    sType;
///    void*              pNext;
///    VkBool32           shaderZeroInitializeWorkgroupMemory;
///} VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures;
///```
///or the equivalent
///```c
///// Provided by VK_KHR_zero_initialize_workgroup_memory
///typedef VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures
/// VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR;
///```
///# Members
///This structure describes the following feature:
///# Description
/// - [`s_type`] is the type of this structure.
/// - [`p_next`] is `NULL` or a pointer to a structure extending this structure.
///
/// - [`shader_zero_initialize_workgroup_memory`] specifies whether the implementation supports
///   initializing a variable in Workgroup storage class.
///If the [`PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures`] structure is included in the
/// [`p_next`] chain of the
///[`PhysicalDeviceFeatures2`] structure passed to
///[`get_physical_device_features2`], it is filled in to indicate whether each
///corresponding feature is supported.
///[`PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures`] **can**  also be used in the [`p_next`]
/// chain of
///[`DeviceCreateInfo`] to selectively enable these features.
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be
///   `VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES`
///# Related
/// - [`khr_zero_initialize_workgroup_memory`]
/// - [`crate::vulkan1_3`]
/// - [`Bool32`]
/// - [`StructureType`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures")]
#[derive(Debug, Clone, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[repr(C)]
pub struct PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures<'lt> {
    ///Lifetime field
    pub _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] is the type of this structure.
    pub s_type: StructureType,
    ///[`p_next`] is `NULL` or a pointer to a structure extending this
    ///structure.
    pub p_next: *mut BaseOutStructure<'lt>,
    ///[`shader_zero_initialize_workgroup_memory`] specifies whether the
    ///implementation supports initializing a variable in Workgroup storage
    ///class.
    pub shader_zero_initialize_workgroup_memory: Bool32,
}
impl<'lt> Default for PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: StructureType::PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES,
            p_next: std::ptr::null_mut(),
            shader_zero_initialize_workgroup_memory: 0,
        }
    }
}
impl<'lt> PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *mut BaseOutStructure<'lt> {
        self.p_next
    }
    ///Gets the raw value of [`Self::shader_zero_initialize_workgroup_memory`]
    pub fn shader_zero_initialize_workgroup_memory_raw(&self) -> Bool32 {
        self.shader_zero_initialize_workgroup_memory
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *mut BaseOutStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::shader_zero_initialize_workgroup_memory`]
    pub fn set_shader_zero_initialize_workgroup_memory_raw(&mut self, value: Bool32) -> &mut Self {
        self.shader_zero_initialize_workgroup_memory = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn with_p_next_raw(mut self, value: *mut BaseOutStructure<'lt>) -> Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::shader_zero_initialize_workgroup_memory`]
    pub fn with_shader_zero_initialize_workgroup_memory_raw(mut self, value: Bool32) -> Self {
        self.shader_zero_initialize_workgroup_memory = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseOutStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::shader_zero_initialize_workgroup_memory`]
    pub fn shader_zero_initialize_workgroup_memory(&self) -> bool {
        unsafe { std::mem::transmute(self.shader_zero_initialize_workgroup_memory as u8) }
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next_mut(&mut self) -> &mut BaseOutStructure<'lt> {
        &mut *self.p_next
    }
    ///Gets a mutable reference to the value of [`Self::shader_zero_initialize_workgroup_memory`]
    pub fn shader_zero_initialize_workgroup_memory_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.shader_zero_initialize_workgroup_memory as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.shader_zero_initialize_workgroup_memory as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Sets the value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt mut crate::vulkan1_0::BaseOutStructure<'lt>) -> &mut Self {
        self.p_next = value as *mut _;
        self
    }
    ///Sets the value of [`Self::shader_zero_initialize_workgroup_memory`]
    pub fn set_shader_zero_initialize_workgroup_memory(&mut self, value: bool) -> &mut Self {
        self.shader_zero_initialize_workgroup_memory = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::s_type`]
    pub fn with_s_type(mut self, value: crate::vulkan1_0::StructureType) -> Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn with_p_next(mut self, value: &'lt mut crate::vulkan1_0::BaseOutStructure<'lt>) -> Self {
        self.p_next = value as *mut _;
        self
    }
    ///Sets the value of [`Self::shader_zero_initialize_workgroup_memory`]
    pub fn with_shader_zero_initialize_workgroup_memory(mut self, value: bool) -> Self {
        self.shader_zero_initialize_workgroup_memory = value as u8 as u32;
        self
    }
}
///[VkPhysicalDeviceImageRobustnessFeatures](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceImageRobustnessFeatures.html) - Structure describing the out-of-bounds behavior for an implementation
///# C Specifications
///The [`PhysicalDeviceImageRobustnessFeatures`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_3
///typedef struct VkPhysicalDeviceImageRobustnessFeatures {
///    VkStructureType    sType;
///    void*              pNext;
///    VkBool32           robustImageAccess;
///} VkPhysicalDeviceImageRobustnessFeatures;
///```
///or the equivalent
///```c
///// Provided by VK_EXT_image_robustness
///typedef VkPhysicalDeviceImageRobustnessFeatures VkPhysicalDeviceImageRobustnessFeaturesEXT;
///```
///# Members
///This structure describes the following feature:
///# Description
/// - [`s_type`] is the type of this structure.
/// - [`p_next`] is `NULL` or a pointer to a structure extending this structure.
///
/// - [`robust_image_access`] indicates whether image accesses are tightly bounds-checked against the dimensions of the image view. [Invalid texels](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#textures-input-validation) resulting from out of bounds image loads will be replaced as described in [Texel Replacement](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#textures-texel-replacement), with either (0,0,1) or (0,0,0) values inserted for missing G, B, or A components based on the format.
///If the [`PhysicalDeviceImageRobustnessFeatures`] structure is included in the [`p_next`] chain
/// of the
///[`PhysicalDeviceFeatures2`] structure passed to
///[`get_physical_device_features2`], it is filled in to indicate whether each
///corresponding feature is supported.
///[`PhysicalDeviceImageRobustnessFeatures`] **can**  also be used in the [`p_next`] chain of
///[`DeviceCreateInfo`] to selectively enable these features.
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be `VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES`
///# Related
/// - [`ext_image_robustness`]
/// - [`crate::vulkan1_3`]
/// - [`Bool32`]
/// - [`StructureType`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkPhysicalDeviceImageRobustnessFeatures")]
#[derive(Debug, Clone, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[repr(C)]
pub struct PhysicalDeviceImageRobustnessFeatures<'lt> {
    ///Lifetime field
    pub _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] is the type of this structure.
    pub s_type: StructureType,
    ///[`p_next`] is `NULL` or a pointer to a structure extending this
    ///structure.
    pub p_next: *mut BaseOutStructure<'lt>,
    ///[`robust_image_access`]
    ///indicates whether image accesses are tightly bounds-checked against the
    ///dimensions of the image view.
    ///[Invalid texels](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#textures-input-validation) resulting from out of
    ///bounds image loads will be replaced as described in
    ///[Texel Replacement](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#textures-texel-replacement), with either
    ///(0,0,1) or (0,0,0) values inserted for missing G, B, or A
    ///components based on the format.
    pub robust_image_access: Bool32,
}
impl<'lt> Default for PhysicalDeviceImageRobustnessFeatures<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: StructureType::PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES,
            p_next: std::ptr::null_mut(),
            robust_image_access: 0,
        }
    }
}
impl<'lt> PhysicalDeviceImageRobustnessFeatures<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *mut BaseOutStructure<'lt> {
        self.p_next
    }
    ///Gets the raw value of [`Self::robust_image_access`]
    pub fn robust_image_access_raw(&self) -> Bool32 {
        self.robust_image_access
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *mut BaseOutStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::robust_image_access`]
    pub fn set_robust_image_access_raw(&mut self, value: Bool32) -> &mut Self {
        self.robust_image_access = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn with_p_next_raw(mut self, value: *mut BaseOutStructure<'lt>) -> Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::robust_image_access`]
    pub fn with_robust_image_access_raw(mut self, value: Bool32) -> Self {
        self.robust_image_access = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseOutStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::robust_image_access`]
    pub fn robust_image_access(&self) -> bool {
        unsafe { std::mem::transmute(self.robust_image_access as u8) }
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next_mut(&mut self) -> &mut BaseOutStructure<'lt> {
        &mut *self.p_next
    }
    ///Gets a mutable reference to the value of [`Self::robust_image_access`]
    pub fn robust_image_access_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.robust_image_access as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.robust_image_access as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Sets the value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt mut crate::vulkan1_0::BaseOutStructure<'lt>) -> &mut Self {
        self.p_next = value as *mut _;
        self
    }
    ///Sets the value of [`Self::robust_image_access`]
    pub fn set_robust_image_access(&mut self, value: bool) -> &mut Self {
        self.robust_image_access = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::s_type`]
    pub fn with_s_type(mut self, value: crate::vulkan1_0::StructureType) -> Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn with_p_next(mut self, value: &'lt mut crate::vulkan1_0::BaseOutStructure<'lt>) -> Self {
        self.p_next = value as *mut _;
        self
    }
    ///Sets the value of [`Self::robust_image_access`]
    pub fn with_robust_image_access(mut self, value: bool) -> Self {
        self.robust_image_access = value as u8 as u32;
        self
    }
}
///[VkBufferCopy2](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferCopy2.html) - Structure specifying a buffer copy operation
///# C Specifications
///The [`BufferCopy2`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_3
///typedef struct VkBufferCopy2 {
///    VkStructureType    sType;
///    const void*        pNext;
///    VkDeviceSize       srcOffset;
///    VkDeviceSize       dstOffset;
///    VkDeviceSize       size;
///} VkBufferCopy2;
///```
///or the equivalent
///```c
///// Provided by VK_KHR_copy_commands2
///typedef VkBufferCopy2 VkBufferCopy2KHR;
///```
///# Members
/// - [`s_type`] is the type of this structure.
/// - [`p_next`] is `NULL` or a pointer to a structure extending this structure.
/// - [`src_offset`] is the starting offset in bytes from the start of `srcBuffer`.
/// - [`dst_offset`] is the starting offset in bytes from the start of `dstBuffer`.
/// - [`size`] is the number of bytes to copy.
///# Description
///## Valid Usage
/// - The [`size`] **must**  be greater than `0`
///
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be `VK_STRUCTURE_TYPE_BUFFER_COPY_2`
/// - [`p_next`] **must**  be `NULL`
///# Related
/// - [`khr_copy_commands2`]
/// - [`crate::vulkan1_3`]
/// - [`CopyBufferInfo2`]
/// - [`DeviceSize`]
/// - [`StructureType`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkBufferCopy2")]
#[derive(Debug, Clone, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[repr(C)]
pub struct BufferCopy2<'lt> {
    ///Lifetime field
    pub _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] is the type of this structure.
    pub s_type: StructureType,
    ///[`p_next`] is `NULL` or a pointer to a structure extending this
    ///structure.
    pub p_next: *const BaseInStructure<'lt>,
    ///[`src_offset`] is the starting offset in bytes from the start of
    ///`srcBuffer`.
    pub src_offset: DeviceSize,
    ///[`dst_offset`] is the starting offset in bytes from the start of
    ///`dstBuffer`.
    pub dst_offset: DeviceSize,
    ///[`size`] is the number of bytes to copy.
    pub size: DeviceSize,
}
impl<'lt> Default for BufferCopy2<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: StructureType::BUFFER_COPY2,
            p_next: std::ptr::null(),
            src_offset: Default::default(),
            dst_offset: Default::default(),
            size: Default::default(),
        }
    }
}
impl<'lt> BufferCopy2<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *const BaseInStructure<'lt> {
        self.p_next
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *const BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn with_p_next_raw(mut self, value: *const BaseInStructure<'lt>) -> Self {
        self.p_next = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseInStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::src_offset`]
    pub fn src_offset(&self) -> DeviceSize {
        self.src_offset
    }
    ///Gets the value of [`Self::dst_offset`]
    pub fn dst_offset(&self) -> DeviceSize {
        self.dst_offset
    }
    ///Gets the value of [`Self::size`]
    pub fn size(&self) -> DeviceSize {
        self.size
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::src_offset`]
    pub fn src_offset_mut(&mut self) -> &mut DeviceSize {
        &mut self.src_offset
    }
    ///Gets a mutable reference to the value of [`Self::dst_offset`]
    pub fn dst_offset_mut(&mut self) -> &mut DeviceSize {
        &mut self.dst_offset
    }
    ///Gets a mutable reference to the value of [`Self::size`]
    pub fn size_mut(&mut self) -> &mut DeviceSize {
        &mut self.size
    }
    ///Sets the value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the value of [`Self::src_offset`]
    pub fn set_src_offset(&mut self, value: crate::vulkan1_0::DeviceSize) -> &mut Self {
        self.src_offset = value;
        self
    }
    ///Sets the value of [`Self::dst_offset`]
    pub fn set_dst_offset(&mut self, value: crate::vulkan1_0::DeviceSize) -> &mut Self {
        self.dst_offset = value;
        self
    }
    ///Sets the value of [`Self::size`]
    pub fn set_size(&mut self, value: crate::vulkan1_0::DeviceSize) -> &mut Self {
        self.size = value;
        self
    }
    ///Sets the value of [`Self::s_type`]
    pub fn with_s_type(mut self, value: crate::vulkan1_0::StructureType) -> Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn with_p_next(mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the value of [`Self::src_offset`]
    pub fn with_src_offset(mut self, value: crate::vulkan1_0::DeviceSize) -> Self {
        self.src_offset = value;
        self
    }
    ///Sets the value of [`Self::dst_offset`]
    pub fn with_dst_offset(mut self, value: crate::vulkan1_0::DeviceSize) -> Self {
        self.dst_offset = value;
        self
    }
    ///Sets the value of [`Self::size`]
    pub fn with_size(mut self, value: crate::vulkan1_0::DeviceSize) -> Self {
        self.size = value;
        self
    }
}
///[VkImageCopy2](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageCopy2.html) - Structure specifying an image copy operation
///# C Specifications
///The [`ImageCopy2`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_3
///typedef struct VkImageCopy2 {
///    VkStructureType             sType;
///    const void*                 pNext;
///    VkImageSubresourceLayers    srcSubresource;
///    VkOffset3D                  srcOffset;
///    VkImageSubresourceLayers    dstSubresource;
///    VkOffset3D                  dstOffset;
///    VkExtent3D                  extent;
///} VkImageCopy2;
///```
///or the equivalent
///```c
///// Provided by VK_KHR_copy_commands2
///typedef VkImageCopy2 VkImageCopy2KHR;
///```
///# Members
/// - [`s_type`] is the type of this structure.
/// - [`p_next`] is `NULL` or a pointer to a structure extending this structure.
/// - [`src_subresource`] and [`dst_subresource`] are [`ImageSubresourceLayers`] structures
///   specifying the image subresources of the images used for the source and destination image
///   data, respectively.
/// - [`src_offset`] and [`dst_offset`] select the initial `x`, `y`, and `z` offsets in texels of
///   the sub-regions of the source and destination image data.
/// - [`extent`] is the size in texels of the image to copy in `width`, `height` and `depth`.
///# Description
///## Valid Usage
/// - The number of slices of the [`extent`] (for 3D) or layers of the [`src_subresource`] (for
///   non-3D)  **must**  match the number of slices of the [`extent`] (for 3D) or layers of the
///   [`dst_subresource`] (for non-3D)
/// - `extent.width` **must**  not be 0
/// - `extent.height` **must**  not be 0
/// - `extent.depth` **must**  not be 0
///
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be `VK_STRUCTURE_TYPE_IMAGE_COPY_2`
/// - [`p_next`] **must**  be `NULL`
/// - [`src_subresource`] **must**  be a valid [`ImageSubresourceLayers`] structure
/// - [`dst_subresource`] **must**  be a valid [`ImageSubresourceLayers`] structure
///# Related
/// - [`khr_copy_commands2`]
/// - [`crate::vulkan1_3`]
/// - [`CopyImageInfo2`]
/// - [`Extent3D`]
/// - [`ImageSubresourceLayers`]
/// - [`Offset3D`]
/// - [`StructureType`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkImageCopy2")]
#[derive(Debug, Clone, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[repr(C)]
pub struct ImageCopy2<'lt> {
    ///Lifetime field
    pub _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] is the type of this structure.
    pub s_type: StructureType,
    ///[`p_next`] is `NULL` or a pointer to a structure extending this
    ///structure.
    pub p_next: *const BaseInStructure<'lt>,
    ///[`src_subresource`] and [`dst_subresource`] are
    ///[`ImageSubresourceLayers`] structures specifying the image
    ///subresources of the images used for the source and destination image
    ///data, respectively.
    pub src_subresource: ImageSubresourceLayers,
    ///[`src_offset`] and [`dst_offset`] select the initial `x`, `y`,
    ///and `z` offsets in texels of the sub-regions of the source and
    ///destination image data.
    pub src_offset: Offset3D,
    ///No documentation found
    pub dst_subresource: ImageSubresourceLayers,
    ///No documentation found
    pub dst_offset: Offset3D,
    ///[`extent`] is the size in texels of the image to copy in `width`,
    ///`height` and `depth`.
    pub extent: Extent3D,
}
impl<'lt> Default for ImageCopy2<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: StructureType::IMAGE_COPY2,
            p_next: std::ptr::null(),
            src_subresource: Default::default(),
            src_offset: Default::default(),
            dst_subresource: Default::default(),
            dst_offset: Default::default(),
            extent: Default::default(),
        }
    }
}
impl<'lt> ImageCopy2<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *const BaseInStructure<'lt> {
        self.p_next
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *const BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn with_p_next_raw(mut self, value: *const BaseInStructure<'lt>) -> Self {
        self.p_next = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseInStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::src_subresource`]
    pub fn src_subresource(&self) -> ImageSubresourceLayers {
        self.src_subresource
    }
    ///Gets the value of [`Self::src_offset`]
    pub fn src_offset(&self) -> Offset3D {
        self.src_offset
    }
    ///Gets the value of [`Self::dst_subresource`]
    pub fn dst_subresource(&self) -> ImageSubresourceLayers {
        self.dst_subresource
    }
    ///Gets the value of [`Self::dst_offset`]
    pub fn dst_offset(&self) -> Offset3D {
        self.dst_offset
    }
    ///Gets the value of [`Self::extent`]
    pub fn extent(&self) -> Extent3D {
        self.extent
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::src_subresource`]
    pub fn src_subresource_mut(&mut self) -> &mut ImageSubresourceLayers {
        &mut self.src_subresource
    }
    ///Gets a mutable reference to the value of [`Self::src_offset`]
    pub fn src_offset_mut(&mut self) -> &mut Offset3D {
        &mut self.src_offset
    }
    ///Gets a mutable reference to the value of [`Self::dst_subresource`]
    pub fn dst_subresource_mut(&mut self) -> &mut ImageSubresourceLayers {
        &mut self.dst_subresource
    }
    ///Gets a mutable reference to the value of [`Self::dst_offset`]
    pub fn dst_offset_mut(&mut self) -> &mut Offset3D {
        &mut self.dst_offset
    }
    ///Gets a mutable reference to the value of [`Self::extent`]
    pub fn extent_mut(&mut self) -> &mut Extent3D {
        &mut self.extent
    }
    ///Sets the value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the value of [`Self::src_subresource`]
    pub fn set_src_subresource(&mut self, value: crate::vulkan1_0::ImageSubresourceLayers) -> &mut Self {
        self.src_subresource = value;
        self
    }
    ///Sets the value of [`Self::src_offset`]
    pub fn set_src_offset(&mut self, value: crate::vulkan1_0::Offset3D) -> &mut Self {
        self.src_offset = value;
        self
    }
    ///Sets the value of [`Self::dst_subresource`]
    pub fn set_dst_subresource(&mut self, value: crate::vulkan1_0::ImageSubresourceLayers) -> &mut Self {
        self.dst_subresource = value;
        self
    }
    ///Sets the value of [`Self::dst_offset`]
    pub fn set_dst_offset(&mut self, value: crate::vulkan1_0::Offset3D) -> &mut Self {
        self.dst_offset = value;
        self
    }
    ///Sets the value of [`Self::extent`]
    pub fn set_extent(&mut self, value: crate::vulkan1_0::Extent3D) -> &mut Self {
        self.extent = value;
        self
    }
    ///Sets the value of [`Self::s_type`]
    pub fn with_s_type(mut self, value: crate::vulkan1_0::StructureType) -> Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn with_p_next(mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the value of [`Self::src_subresource`]
    pub fn with_src_subresource(mut self, value: crate::vulkan1_0::ImageSubresourceLayers) -> Self {
        self.src_subresource = value;
        self
    }
    ///Sets the value of [`Self::src_offset`]
    pub fn with_src_offset(mut self, value: crate::vulkan1_0::Offset3D) -> Self {
        self.src_offset = value;
        self
    }
    ///Sets the value of [`Self::dst_subresource`]
    pub fn with_dst_subresource(mut self, value: crate::vulkan1_0::ImageSubresourceLayers) -> Self {
        self.dst_subresource = value;
        self
    }
    ///Sets the value of [`Self::dst_offset`]
    pub fn with_dst_offset(mut self, value: crate::vulkan1_0::Offset3D) -> Self {
        self.dst_offset = value;
        self
    }
    ///Sets the value of [`Self::extent`]
    pub fn with_extent(mut self, value: crate::vulkan1_0::Extent3D) -> Self {
        self.extent = value;
        self
    }
}
///[VkImageBlit2](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageBlit2.html) - Structure specifying an image blit operation
///# C Specifications
///The [`ImageBlit2`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_3
///typedef struct VkImageBlit2 {
///    VkStructureType             sType;
///    const void*                 pNext;
///    VkImageSubresourceLayers    srcSubresource;
///    VkOffset3D                  srcOffsets[2];
///    VkImageSubresourceLayers    dstSubresource;
///    VkOffset3D                  dstOffsets[2];
///} VkImageBlit2;
///```
///or the equivalent
///```c
///// Provided by VK_KHR_copy_commands2
///typedef VkImageBlit2 VkImageBlit2KHR;
///```
///# Members
/// - [`s_type`] is the type of this structure.
/// - [`p_next`] is `NULL` or a pointer to a structure extending this structure.
/// - [`src_subresource`] is the subresource to blit from.
/// - [`src_offsets`] is a pointer to an array of two [`Offset3D`] structures specifying the bounds
///   of the source region within [`src_subresource`].
/// - [`dst_subresource`] is the subresource to blit into.
/// - [`dst_offsets`] is a pointer to an array of two [`Offset3D`] structures specifying the bounds
///   of the destination region within [`dst_subresource`].
///# Description
///For each element of the `pRegions` array, a blit operation is performed
///for the specified source and destination regions.
///## Valid Usage
/// - The `aspectMask` member of [`src_subresource`] and [`dst_subresource`] **must**  match
/// - The `layerCount` member of [`src_subresource`] and [`dst_subresource`] **must**  match
///
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be `VK_STRUCTURE_TYPE_IMAGE_BLIT_2`
/// - [`p_next`] **must**  be `NULL` or a pointer to a valid instance of
///   [`CopyCommandTransformInfoQCOM`]
/// - The [`s_type`] value of each struct in the [`p_next`] chain  **must**  be unique
/// - [`src_subresource`] **must**  be a valid [`ImageSubresourceLayers`] structure
/// - [`dst_subresource`] **must**  be a valid [`ImageSubresourceLayers`] structure
///# Related
/// - [`khr_copy_commands2`]
/// - [`crate::vulkan1_3`]
/// - [`BlitImageInfo2`]
/// - [`ImageSubresourceLayers`]
/// - [`Offset3D`]
/// - [`StructureType`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkImageBlit2")]
#[derive(Debug, Clone, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[repr(C)]
pub struct ImageBlit2<'lt> {
    ///Lifetime field
    pub _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] is the type of this structure.
    pub s_type: StructureType,
    ///[`p_next`] is `NULL` or a pointer to a structure extending this
    ///structure.
    pub p_next: *const BaseInStructure<'lt>,
    ///[`src_subresource`] is the subresource to blit from.
    pub src_subresource: ImageSubresourceLayers,
    ///[`src_offsets`] is a pointer to an array of two [`Offset3D`]
    ///structures specifying the bounds of the source region within
    ///[`src_subresource`].
    pub src_offsets: [Offset3D; 2 as usize],
    ///[`dst_subresource`] is the subresource to blit into.
    pub dst_subresource: ImageSubresourceLayers,
    ///[`dst_offsets`] is a pointer to an array of two [`Offset3D`]
    ///structures specifying the bounds of the destination region within
    ///[`dst_subresource`].
    pub dst_offsets: [Offset3D; 2 as usize],
}
impl<'lt> Default for ImageBlit2<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: StructureType::IMAGE_BLIT2,
            p_next: std::ptr::null(),
            src_subresource: Default::default(),
            src_offsets: [Default::default(); 2 as usize],
            dst_subresource: Default::default(),
            dst_offsets: [Default::default(); 2 as usize],
        }
    }
}
impl<'lt> ImageBlit2<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *const BaseInStructure<'lt> {
        self.p_next
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *const BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn with_p_next_raw(mut self, value: *const BaseInStructure<'lt>) -> Self {
        self.p_next = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseInStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::src_subresource`]
    pub fn src_subresource(&self) -> ImageSubresourceLayers {
        self.src_subresource
    }
    ///Gets the value of [`Self::src_offsets`]
    pub fn src_offsets(&self) -> &[Offset3D; 2 as usize] {
        &self.src_offsets
    }
    ///Gets the value of [`Self::dst_subresource`]
    pub fn dst_subresource(&self) -> ImageSubresourceLayers {
        self.dst_subresource
    }
    ///Gets the value of [`Self::dst_offsets`]
    pub fn dst_offsets(&self) -> &[Offset3D; 2 as usize] {
        &self.dst_offsets
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::src_subresource`]
    pub fn src_subresource_mut(&mut self) -> &mut ImageSubresourceLayers {
        &mut self.src_subresource
    }
    ///Gets a mutable reference to the value of [`Self::src_offsets`]
    pub fn src_offsets_mut(&mut self) -> &mut [Offset3D; 2 as usize] {
        &mut self.src_offsets
    }
    ///Gets a mutable reference to the value of [`Self::dst_subresource`]
    pub fn dst_subresource_mut(&mut self) -> &mut ImageSubresourceLayers {
        &mut self.dst_subresource
    }
    ///Gets a mutable reference to the value of [`Self::dst_offsets`]
    pub fn dst_offsets_mut(&mut self) -> &mut [Offset3D; 2 as usize] {
        &mut self.dst_offsets
    }
    ///Sets the value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the value of [`Self::src_subresource`]
    pub fn set_src_subresource(&mut self, value: crate::vulkan1_0::ImageSubresourceLayers) -> &mut Self {
        self.src_subresource = value;
        self
    }
    ///Sets the value of [`Self::src_offsets`]
    pub fn set_src_offsets(&mut self, value: [crate::vulkan1_0::Offset3D; 2 as usize]) -> &mut Self {
        self.src_offsets = value;
        self
    }
    ///Sets the value of [`Self::dst_subresource`]
    pub fn set_dst_subresource(&mut self, value: crate::vulkan1_0::ImageSubresourceLayers) -> &mut Self {
        self.dst_subresource = value;
        self
    }
    ///Sets the value of [`Self::dst_offsets`]
    pub fn set_dst_offsets(&mut self, value: [crate::vulkan1_0::Offset3D; 2 as usize]) -> &mut Self {
        self.dst_offsets = value;
        self
    }
    ///Sets the value of [`Self::s_type`]
    pub fn with_s_type(mut self, value: crate::vulkan1_0::StructureType) -> Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn with_p_next(mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the value of [`Self::src_subresource`]
    pub fn with_src_subresource(mut self, value: crate::vulkan1_0::ImageSubresourceLayers) -> Self {
        self.src_subresource = value;
        self
    }
    ///Sets the value of [`Self::src_offsets`]
    pub fn with_src_offsets(mut self, value: [crate::vulkan1_0::Offset3D; 2 as usize]) -> Self {
        self.src_offsets = value;
        self
    }
    ///Sets the value of [`Self::dst_subresource`]
    pub fn with_dst_subresource(mut self, value: crate::vulkan1_0::ImageSubresourceLayers) -> Self {
        self.dst_subresource = value;
        self
    }
    ///Sets the value of [`Self::dst_offsets`]
    pub fn with_dst_offsets(mut self, value: [crate::vulkan1_0::Offset3D; 2 as usize]) -> Self {
        self.dst_offsets = value;
        self
    }
}
#[cfg(feature = "VK_QCOM_rotated_copy_commands")]
unsafe impl<'this: 'extender + 'other, 'extender: 'other, 'other>
    crate::Chain<'other, CopyCommandTransformInfoQCOM<'extender>> for ImageBlit2<'this>
{
    type Out = ImageBlit2<'other>;
    #[must_use]
    #[inline]
    fn chain(mut self, new: &'other mut CopyCommandTransformInfoQCOM<'extender>) -> Self::Out {
        unsafe {
            crate::chaining::insert_ptr_in_chain(
                &mut self as *mut Self as *mut BaseOutStructure<'other>,
                new as *mut CopyCommandTransformInfoQCOM<'extender> as *mut BaseOutStructure<'other>,
            );
            std::mem::transmute(self)
        }
    }
}
///[VkBufferImageCopy2](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferImageCopy2.html) - Structure specifying a buffer image copy operation
///# C Specifications
///For both [`cmd_copy_buffer_to_image2`] and [`cmd_copy_image_to_buffer2`],
///each element of `pRegions` is a structure defined as:
///```c
///// Provided by VK_VERSION_1_3
///typedef struct VkBufferImageCopy2 {
///    VkStructureType             sType;
///    const void*                 pNext;
///    VkDeviceSize                bufferOffset;
///    uint32_t                    bufferRowLength;
///    uint32_t                    bufferImageHeight;
///    VkImageSubresourceLayers    imageSubresource;
///    VkOffset3D                  imageOffset;
///    VkExtent3D                  imageExtent;
///} VkBufferImageCopy2;
///```
///or the equivalent
///```c
///// Provided by VK_KHR_copy_commands2
///typedef VkBufferImageCopy2 VkBufferImageCopy2KHR;
///```
///# Members
/// - [`s_type`] is the type of this structure.
/// - [`p_next`] is `NULL` or a pointer to a structure extending this structure.
/// - [`buffer_offset`] is the offset in bytes from the start of the buffer object where the image
///   data is copied from or to.
/// - [`buffer_row_length`] and [`buffer_image_height`] specify in texels a subregion of a larger
///   two- or three-dimensional image in buffer memory, and control the addressing calculations. If
///   either of these values is zero, that aspect of the buffer memory is considered to be tightly
///   packed according to the [`image_extent`].
/// - [`image_subresource`] is a [`ImageSubresourceLayers`] used to specify the specific image
///   subresources of the image used for the source or destination image data.
/// - [`image_offset`] selects the initial `x`, `y`, `z` offsets in texels of the sub-region of the
///   source or destination image data.
/// - [`image_extent`] is the size in texels of the image to copy in `width`, `height` and `depth`.
///# Description
///This structure is functionally identical to [`BufferImageCopy`], but
///adds [`s_type`] and [`p_next`] parameters, allowing it to be more easily
///extended.
///## Valid Usage
/// - [`buffer_row_length`] **must**  be `0`, or greater than or equal to the `width` member of
///   [`image_extent`]
/// - [`buffer_image_height`] **must**  be `0`, or greater than or equal to the `height` member of
///   [`image_extent`]
/// - The `aspectMask` member of [`image_subresource`] **must**  only have a single bit set
/// - `imageExtent.width` **must**  not be 0
/// - `imageExtent.height` **must**  not be 0
/// - `imageExtent.depth` **must**  not be 0
///
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be `VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2`
/// - [`p_next`] **must**  be `NULL` or a pointer to a valid instance of
///   [`CopyCommandTransformInfoQCOM`]
/// - The [`s_type`] value of each struct in the [`p_next`] chain  **must**  be unique
/// - [`image_subresource`] **must**  be a valid [`ImageSubresourceLayers`] structure
///# Related
/// - [`khr_copy_commands2`]
/// - [`crate::vulkan1_3`]
/// - [`CopyBufferToImageInfo2`]
/// - [`CopyImageToBufferInfo2`]
/// - [`DeviceSize`]
/// - [`Extent3D`]
/// - [`ImageSubresourceLayers`]
/// - [`Offset3D`]
/// - [`StructureType`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkBufferImageCopy2")]
#[derive(Debug, Clone, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[repr(C)]
pub struct BufferImageCopy2<'lt> {
    ///Lifetime field
    pub _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] is the type of this structure.
    pub s_type: StructureType,
    ///[`p_next`] is `NULL` or a pointer to a structure extending this
    ///structure.
    pub p_next: *const BaseInStructure<'lt>,
    ///[`buffer_offset`] is the offset in bytes from the start of the buffer
    ///object where the image data is copied from or to.
    pub buffer_offset: DeviceSize,
    ///[`buffer_row_length`] and [`buffer_image_height`] specify in texels a
    ///subregion of a larger two- or three-dimensional image in buffer memory,
    ///and control the addressing calculations.
    ///If either of these values is zero, that aspect of the buffer memory is
    ///considered to be tightly packed according to the [`image_extent`].
    pub buffer_row_length: u32,
    ///No documentation found
    pub buffer_image_height: u32,
    ///[`image_subresource`] is a [`ImageSubresourceLayers`] used to
    ///specify the specific image subresources of the image used for the source
    ///or destination image data.
    pub image_subresource: ImageSubresourceLayers,
    ///[`image_offset`] selects the initial `x`, `y`, `z` offsets
    ///in texels of the sub-region of the source or destination image data.
    pub image_offset: Offset3D,
    ///[`image_extent`] is the size in texels of the image to copy in
    ///`width`, `height` and `depth`.
    pub image_extent: Extent3D,
}
impl<'lt> Default for BufferImageCopy2<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: StructureType::BUFFER_IMAGE_COPY2,
            p_next: std::ptr::null(),
            buffer_offset: Default::default(),
            buffer_row_length: 0,
            buffer_image_height: 0,
            image_subresource: Default::default(),
            image_offset: Default::default(),
            image_extent: Default::default(),
        }
    }
}
impl<'lt> BufferImageCopy2<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *const BaseInStructure<'lt> {
        self.p_next
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *const BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn with_p_next_raw(mut self, value: *const BaseInStructure<'lt>) -> Self {
        self.p_next = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseInStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::buffer_offset`]
    pub fn buffer_offset(&self) -> DeviceSize {
        self.buffer_offset
    }
    ///Gets the value of [`Self::buffer_row_length`]
    pub fn buffer_row_length(&self) -> u32 {
        self.buffer_row_length
    }
    ///Gets the value of [`Self::buffer_image_height`]
    pub fn buffer_image_height(&self) -> u32 {
        self.buffer_image_height
    }
    ///Gets the value of [`Self::image_subresource`]
    pub fn image_subresource(&self) -> ImageSubresourceLayers {
        self.image_subresource
    }
    ///Gets the value of [`Self::image_offset`]
    pub fn image_offset(&self) -> Offset3D {
        self.image_offset
    }
    ///Gets the value of [`Self::image_extent`]
    pub fn image_extent(&self) -> Extent3D {
        self.image_extent
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::buffer_offset`]
    pub fn buffer_offset_mut(&mut self) -> &mut DeviceSize {
        &mut self.buffer_offset
    }
    ///Gets a mutable reference to the value of [`Self::buffer_row_length`]
    pub fn buffer_row_length_mut(&mut self) -> &mut u32 {
        &mut self.buffer_row_length
    }
    ///Gets a mutable reference to the value of [`Self::buffer_image_height`]
    pub fn buffer_image_height_mut(&mut self) -> &mut u32 {
        &mut self.buffer_image_height
    }
    ///Gets a mutable reference to the value of [`Self::image_subresource`]
    pub fn image_subresource_mut(&mut self) -> &mut ImageSubresourceLayers {
        &mut self.image_subresource
    }
    ///Gets a mutable reference to the value of [`Self::image_offset`]
    pub fn image_offset_mut(&mut self) -> &mut Offset3D {
        &mut self.image_offset
    }
    ///Gets a mutable reference to the value of [`Self::image_extent`]
    pub fn image_extent_mut(&mut self) -> &mut Extent3D {
        &mut self.image_extent
    }
    ///Sets the value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the value of [`Self::buffer_offset`]
    pub fn set_buffer_offset(&mut self, value: crate::vulkan1_0::DeviceSize) -> &mut Self {
        self.buffer_offset = value;
        self
    }
    ///Sets the value of [`Self::buffer_row_length`]
    pub fn set_buffer_row_length(&mut self, value: u32) -> &mut Self {
        self.buffer_row_length = value;
        self
    }
    ///Sets the value of [`Self::buffer_image_height`]
    pub fn set_buffer_image_height(&mut self, value: u32) -> &mut Self {
        self.buffer_image_height = value;
        self
    }
    ///Sets the value of [`Self::image_subresource`]
    pub fn set_image_subresource(&mut self, value: crate::vulkan1_0::ImageSubresourceLayers) -> &mut Self {
        self.image_subresource = value;
        self
    }
    ///Sets the value of [`Self::image_offset`]
    pub fn set_image_offset(&mut self, value: crate::vulkan1_0::Offset3D) -> &mut Self {
        self.image_offset = value;
        self
    }
    ///Sets the value of [`Self::image_extent`]
    pub fn set_image_extent(&mut self, value: crate::vulkan1_0::Extent3D) -> &mut Self {
        self.image_extent = value;
        self
    }
    ///Sets the value of [`Self::s_type`]
    pub fn with_s_type(mut self, value: crate::vulkan1_0::StructureType) -> Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn with_p_next(mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the value of [`Self::buffer_offset`]
    pub fn with_buffer_offset(mut self, value: crate::vulkan1_0::DeviceSize) -> Self {
        self.buffer_offset = value;
        self
    }
    ///Sets the value of [`Self::buffer_row_length`]
    pub fn with_buffer_row_length(mut self, value: u32) -> Self {
        self.buffer_row_length = value;
        self
    }
    ///Sets the value of [`Self::buffer_image_height`]
    pub fn with_buffer_image_height(mut self, value: u32) -> Self {
        self.buffer_image_height = value;
        self
    }
    ///Sets the value of [`Self::image_subresource`]
    pub fn with_image_subresource(mut self, value: crate::vulkan1_0::ImageSubresourceLayers) -> Self {
        self.image_subresource = value;
        self
    }
    ///Sets the value of [`Self::image_offset`]
    pub fn with_image_offset(mut self, value: crate::vulkan1_0::Offset3D) -> Self {
        self.image_offset = value;
        self
    }
    ///Sets the value of [`Self::image_extent`]
    pub fn with_image_extent(mut self, value: crate::vulkan1_0::Extent3D) -> Self {
        self.image_extent = value;
        self
    }
}
#[cfg(feature = "VK_QCOM_rotated_copy_commands")]
unsafe impl<'this: 'extender + 'other, 'extender: 'other, 'other>
    crate::Chain<'other, CopyCommandTransformInfoQCOM<'extender>> for BufferImageCopy2<'this>
{
    type Out = BufferImageCopy2<'other>;
    #[must_use]
    #[inline]
    fn chain(mut self, new: &'other mut CopyCommandTransformInfoQCOM<'extender>) -> Self::Out {
        unsafe {
            crate::chaining::insert_ptr_in_chain(
                &mut self as *mut Self as *mut BaseOutStructure<'other>,
                new as *mut CopyCommandTransformInfoQCOM<'extender> as *mut BaseOutStructure<'other>,
            );
            std::mem::transmute(self)
        }
    }
}
///[VkImageResolve2](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageResolve2.html) - Structure specifying an image resolve operation
///# C Specifications
///The [`ImageResolve2`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_3
///typedef struct VkImageResolve2 {
///    VkStructureType             sType;
///    const void*                 pNext;
///    VkImageSubresourceLayers    srcSubresource;
///    VkOffset3D                  srcOffset;
///    VkImageSubresourceLayers    dstSubresource;
///    VkOffset3D                  dstOffset;
///    VkExtent3D                  extent;
///} VkImageResolve2;
///```
///or the equivalent
///```c
///// Provided by VK_KHR_copy_commands2
///typedef VkImageResolve2 VkImageResolve2KHR;
///```
///# Members
/// - [`s_type`] is the type of this structure.
/// - [`p_next`] is `NULL` or a pointer to a structure extending this structure.
/// - [`src_subresource`] and [`dst_subresource`] are [`ImageSubresourceLayers`] structures
///   specifying the image subresources of the images used for the source and destination image
///   data, respectively. Resolve of depth/stencil images is not supported.
/// - [`src_offset`] and [`dst_offset`] select the initial `x`, `y`, and `z` offsets in texels of
///   the sub-regions of the source and destination image data.
/// - [`extent`] is the size in texels of the source image to resolve in `width`, `height` and
///   `depth`.
///# Description
///## Valid Usage
/// - The `aspectMask` member of [`src_subresource`] and [`dst_subresource`] **must**  only contain
///   `VK_IMAGE_ASPECT_COLOR_BIT`
/// - The `layerCount` member of [`src_subresource`] and [`dst_subresource`] **must**  match
///
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be `VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2`
/// - [`p_next`] **must**  be `NULL`
/// - [`src_subresource`] **must**  be a valid [`ImageSubresourceLayers`] structure
/// - [`dst_subresource`] **must**  be a valid [`ImageSubresourceLayers`] structure
///# Related
/// - [`khr_copy_commands2`]
/// - [`crate::vulkan1_3`]
/// - [`Extent3D`]
/// - [`ImageSubresourceLayers`]
/// - [`Offset3D`]
/// - [`ResolveImageInfo2`]
/// - [`StructureType`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkImageResolve2")]
#[derive(Debug, Clone, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[repr(C)]
pub struct ImageResolve2<'lt> {
    ///Lifetime field
    pub _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] is the type of this structure.
    pub s_type: StructureType,
    ///[`p_next`] is `NULL` or a pointer to a structure extending this
    ///structure.
    pub p_next: *const BaseInStructure<'lt>,
    ///[`src_subresource`] and [`dst_subresource`] are
    ///[`ImageSubresourceLayers`] structures specifying the image
    ///subresources of the images used for the source and destination image
    ///data, respectively.
    ///Resolve of depth/stencil images is not supported.
    pub src_subresource: ImageSubresourceLayers,
    ///[`src_offset`] and [`dst_offset`] select the initial `x`, `y`,
    ///and `z` offsets in texels of the sub-regions of the source and
    ///destination image data.
    pub src_offset: Offset3D,
    ///No documentation found
    pub dst_subresource: ImageSubresourceLayers,
    ///No documentation found
    pub dst_offset: Offset3D,
    ///[`extent`] is the size in texels of the source image to resolve in
    ///`width`, `height` and `depth`.
    pub extent: Extent3D,
}
impl<'lt> Default for ImageResolve2<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: StructureType::IMAGE_RESOLVE2,
            p_next: std::ptr::null(),
            src_subresource: Default::default(),
            src_offset: Default::default(),
            dst_subresource: Default::default(),
            dst_offset: Default::default(),
            extent: Default::default(),
        }
    }
}
impl<'lt> ImageResolve2<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *const BaseInStructure<'lt> {
        self.p_next
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *const BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn with_p_next_raw(mut self, value: *const BaseInStructure<'lt>) -> Self {
        self.p_next = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseInStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::src_subresource`]
    pub fn src_subresource(&self) -> ImageSubresourceLayers {
        self.src_subresource
    }
    ///Gets the value of [`Self::src_offset`]
    pub fn src_offset(&self) -> Offset3D {
        self.src_offset
    }
    ///Gets the value of [`Self::dst_subresource`]
    pub fn dst_subresource(&self) -> ImageSubresourceLayers {
        self.dst_subresource
    }
    ///Gets the value of [`Self::dst_offset`]
    pub fn dst_offset(&self) -> Offset3D {
        self.dst_offset
    }
    ///Gets the value of [`Self::extent`]
    pub fn extent(&self) -> Extent3D {
        self.extent
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::src_subresource`]
    pub fn src_subresource_mut(&mut self) -> &mut ImageSubresourceLayers {
        &mut self.src_subresource
    }
    ///Gets a mutable reference to the value of [`Self::src_offset`]
    pub fn src_offset_mut(&mut self) -> &mut Offset3D {
        &mut self.src_offset
    }
    ///Gets a mutable reference to the value of [`Self::dst_subresource`]
    pub fn dst_subresource_mut(&mut self) -> &mut ImageSubresourceLayers {
        &mut self.dst_subresource
    }
    ///Gets a mutable reference to the value of [`Self::dst_offset`]
    pub fn dst_offset_mut(&mut self) -> &mut Offset3D {
        &mut self.dst_offset
    }
    ///Gets a mutable reference to the value of [`Self::extent`]
    pub fn extent_mut(&mut self) -> &mut Extent3D {
        &mut self.extent
    }
    ///Sets the value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the value of [`Self::src_subresource`]
    pub fn set_src_subresource(&mut self, value: crate::vulkan1_0::ImageSubresourceLayers) -> &mut Self {
        self.src_subresource = value;
        self
    }
    ///Sets the value of [`Self::src_offset`]
    pub fn set_src_offset(&mut self, value: crate::vulkan1_0::Offset3D) -> &mut Self {
        self.src_offset = value;
        self
    }
    ///Sets the value of [`Self::dst_subresource`]
    pub fn set_dst_subresource(&mut self, value: crate::vulkan1_0::ImageSubresourceLayers) -> &mut Self {
        self.dst_subresource = value;
        self
    }
    ///Sets the value of [`Self::dst_offset`]
    pub fn set_dst_offset(&mut self, value: crate::vulkan1_0::Offset3D) -> &mut Self {
        self.dst_offset = value;
        self
    }
    ///Sets the value of [`Self::extent`]
    pub fn set_extent(&mut self, value: crate::vulkan1_0::Extent3D) -> &mut Self {
        self.extent = value;
        self
    }
    ///Sets the value of [`Self::s_type`]
    pub fn with_s_type(mut self, value: crate::vulkan1_0::StructureType) -> Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn with_p_next(mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the value of [`Self::src_subresource`]
    pub fn with_src_subresource(mut self, value: crate::vulkan1_0::ImageSubresourceLayers) -> Self {
        self.src_subresource = value;
        self
    }
    ///Sets the value of [`Self::src_offset`]
    pub fn with_src_offset(mut self, value: crate::vulkan1_0::Offset3D) -> Self {
        self.src_offset = value;
        self
    }
    ///Sets the value of [`Self::dst_subresource`]
    pub fn with_dst_subresource(mut self, value: crate::vulkan1_0::ImageSubresourceLayers) -> Self {
        self.dst_subresource = value;
        self
    }
    ///Sets the value of [`Self::dst_offset`]
    pub fn with_dst_offset(mut self, value: crate::vulkan1_0::Offset3D) -> Self {
        self.dst_offset = value;
        self
    }
    ///Sets the value of [`Self::extent`]
    pub fn with_extent(mut self, value: crate::vulkan1_0::Extent3D) -> Self {
        self.extent = value;
        self
    }
}
///[VkCopyBufferInfo2](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCopyBufferInfo2.html) - Structure specifying parameters of a buffer copy command
///# C Specifications
///The [`CopyBufferInfo2`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_3
///typedef struct VkCopyBufferInfo2 {
///    VkStructureType         sType;
///    const void*             pNext;
///    VkBuffer                srcBuffer;
///    VkBuffer                dstBuffer;
///    uint32_t                regionCount;
///    const VkBufferCopy2*    pRegions;
///} VkCopyBufferInfo2;
///```
///or the equivalent
///```c
///// Provided by VK_KHR_copy_commands2
///typedef VkCopyBufferInfo2 VkCopyBufferInfo2KHR;
///```
///# Members
/// - [`s_type`] is the type of this structure.
/// - [`p_next`] is `NULL` or a pointer to a structure extending this structure.
/// - [`src_buffer`] is the source buffer.
/// - [`dst_buffer`] is the destination buffer.
/// - [`region_count`] is the number of regions to copy.
/// - [`regions`] is a pointer to an array of [`BufferCopy2`] structures specifying the regions to
///   copy.
///# Description
///Members defined by this structure with the same name as parameters in
///[`cmd_copy_buffer`] have the identical effect to those parameters; the
///child structure [`BufferCopy2`] is a variant of [`BufferCopy`] which
///includes [`s_type`] and [`p_next`] parameters, allowing it to be extended.
///## Valid Usage
/// - The `srcOffset` member of each element of [`regions`] **must**  be less than the size of
///   [`src_buffer`]
/// - The `dstOffset` member of each element of [`regions`] **must**  be less than the size of
///   [`dst_buffer`]
/// - The `size` member of each element of [`regions`] **must**  be less than or equal to the size
///   of [`src_buffer`] minus `srcOffset`
/// - The `size` member of each element of [`regions`] **must**  be less than or equal to the size
///   of [`dst_buffer`] minus `dstOffset`
/// - The union of the source regions, and the union of the destination regions, specified by the
///   elements of [`regions`],  **must**  not overlap in memory
/// - [`src_buffer`] **must**  have been created with `VK_BUFFER_USAGE_TRANSFER_SRC_BIT` usage flag
/// - If [`src_buffer`] is non-sparse then it  **must**  be bound completely and contiguously to a
///   single [`DeviceMemory`] object
/// - [`dst_buffer`] **must**  have been created with `VK_BUFFER_USAGE_TRANSFER_DST_BIT` usage flag
/// - If [`dst_buffer`] is non-sparse then it  **must**  be bound completely and contiguously to a
///   single [`DeviceMemory`] object
///
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be `VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2`
/// - [`p_next`] **must**  be `NULL`
/// - [`src_buffer`] **must**  be a valid [`Buffer`] handle
/// - [`dst_buffer`] **must**  be a valid [`Buffer`] handle
/// - [`regions`] **must**  be a valid pointer to an array of [`region_count`] valid [`BufferCopy2`]
///   structures
/// - [`region_count`] **must**  be greater than `0`
/// - Both of [`dst_buffer`], and [`src_buffer`] **must**  have been created, allocated, or
///   retrieved from the same [`Device`]
///# Related
/// - [`khr_copy_commands2`]
/// - [`crate::vulkan1_3`]
/// - [`Buffer`]
/// - [`BufferCopy2`]
/// - [`StructureType`]
/// - [`cmd_copy_buffer2`]
/// - [`cmd_copy_buffer2_khr`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkCopyBufferInfo2")]
#[derive(Debug, Clone, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[repr(C)]
pub struct CopyBufferInfo2<'lt> {
    ///Lifetime field
    pub _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] is the type of this structure.
    pub s_type: StructureType,
    ///[`p_next`] is `NULL` or a pointer to a structure extending this
    ///structure.
    pub p_next: *const BaseInStructure<'lt>,
    ///[`src_buffer`] is the source buffer.
    pub src_buffer: Buffer,
    ///[`dst_buffer`] is the destination buffer.
    pub dst_buffer: Buffer,
    ///[`region_count`] is the number of regions to copy.
    pub region_count: u32,
    ///[`regions`] is a pointer to an array of [`BufferCopy2`]
    ///structures specifying the regions to copy.
    pub regions: *const BufferCopy2<'lt>,
}
impl<'lt> Default for CopyBufferInfo2<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: StructureType::COPY_BUFFER_INFO2,
            p_next: std::ptr::null(),
            src_buffer: Default::default(),
            dst_buffer: Default::default(),
            region_count: 0,
            regions: std::ptr::null(),
        }
    }
}
impl<'lt> CopyBufferInfo2<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *const BaseInStructure<'lt> {
        self.p_next
    }
    ///Gets the raw value of [`Self::regions`]
    pub fn regions_raw(&self) -> *const BufferCopy2<'lt> {
        self.regions
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *const BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::regions`]
    pub fn set_regions_raw(&mut self, value: *const BufferCopy2<'lt>) -> &mut Self {
        self.regions = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn with_p_next_raw(mut self, value: *const BaseInStructure<'lt>) -> Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::regions`]
    pub fn with_regions_raw(mut self, value: *const BufferCopy2<'lt>) -> Self {
        self.regions = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseInStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::src_buffer`]
    pub fn src_buffer(&self) -> Buffer {
        self.src_buffer
    }
    ///Gets the value of [`Self::dst_buffer`]
    pub fn dst_buffer(&self) -> Buffer {
        self.dst_buffer
    }
    ///Gets the value of [`Self::region_count`]
    pub fn region_count(&self) -> u32 {
        self.region_count
    }
    ///Gets the value of [`Self::regions`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn regions(&self) -> &[BufferCopy2<'lt>] {
        std::slice::from_raw_parts(self.regions, self.region_count as usize)
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::src_buffer`]
    pub fn src_buffer_mut(&mut self) -> &mut Buffer {
        &mut self.src_buffer
    }
    ///Gets a mutable reference to the value of [`Self::dst_buffer`]
    pub fn dst_buffer_mut(&mut self) -> &mut Buffer {
        &mut self.dst_buffer
    }
    ///Gets a mutable reference to the value of [`Self::region_count`]
    pub fn region_count_mut(&mut self) -> &mut u32 {
        &mut self.region_count
    }
    ///Sets the value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the value of [`Self::src_buffer`]
    pub fn set_src_buffer(&mut self, value: crate::vulkan1_0::Buffer) -> &mut Self {
        self.src_buffer = value;
        self
    }
    ///Sets the value of [`Self::dst_buffer`]
    pub fn set_dst_buffer(&mut self, value: crate::vulkan1_0::Buffer) -> &mut Self {
        self.dst_buffer = value;
        self
    }
    ///Sets the value of [`Self::region_count`]
    pub fn set_region_count(&mut self, value: u32) -> &mut Self {
        self.region_count = value;
        self
    }
    ///Sets the value of [`Self::regions`]
    pub fn set_regions(&mut self, value: &'lt [crate::vulkan1_3::BufferCopy2<'lt>]) -> &mut Self {
        let len_ = value.len() as u32;
        let len_ = len_;
        self.regions = value.as_ptr();
        self.region_count = len_;
        self
    }
    ///Sets the value of [`Self::s_type`]
    pub fn with_s_type(mut self, value: crate::vulkan1_0::StructureType) -> Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn with_p_next(mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the value of [`Self::src_buffer`]
    pub fn with_src_buffer(mut self, value: crate::vulkan1_0::Buffer) -> Self {
        self.src_buffer = value;
        self
    }
    ///Sets the value of [`Self::dst_buffer`]
    pub fn with_dst_buffer(mut self, value: crate::vulkan1_0::Buffer) -> Self {
        self.dst_buffer = value;
        self
    }
    ///Sets the value of [`Self::region_count`]
    pub fn with_region_count(mut self, value: u32) -> Self {
        self.region_count = value;
        self
    }
    ///Sets the value of [`Self::regions`]
    pub fn with_regions(mut self, value: &'lt [crate::vulkan1_3::BufferCopy2<'lt>]) -> Self {
        let len_ = value.len() as u32;
        let len_ = len_;
        self.regions = value.as_ptr();
        self.region_count = len_;
        self
    }
}
///[VkCopyImageInfo2](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCopyImageInfo2.html) - Structure specifying parameters of an image copy command
///# C Specifications
///The [`CopyImageInfo2`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_3
///typedef struct VkCopyImageInfo2 {
///    VkStructureType        sType;
///    const void*            pNext;
///    VkImage                srcImage;
///    VkImageLayout          srcImageLayout;
///    VkImage                dstImage;
///    VkImageLayout          dstImageLayout;
///    uint32_t               regionCount;
///    const VkImageCopy2*    pRegions;
///} VkCopyImageInfo2;
///```
///or the equivalent
///```c
///// Provided by VK_KHR_copy_commands2
///typedef VkCopyImageInfo2 VkCopyImageInfo2KHR;
///```
///# Members
/// - [`s_type`] is the type of this structure.
/// - [`p_next`] is `NULL` or a pointer to a structure extending this structure.
/// - [`src_image`] is the source image.
/// - [`src_image_layout`] is the current layout of the source image subresource.
/// - [`dst_image`] is the destination image.
/// - [`dst_image_layout`] is the current layout of the destination image subresource.
/// - [`region_count`] is the number of regions to copy.
/// - [`regions`] is a pointer to an array of [`ImageCopy2`] structures specifying the regions to
///   copy.
///# Description
///## Valid Usage
/// - The union of all source regions, and the union of all destination regions, specified by the
///   elements of [`regions`],  **must**  not overlap in memory
/// - The [format features](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#resources-image-format-features)
///   of [`src_image`] **must**  contain `VK_FORMAT_FEATURE_TRANSFER_SRC_BIT`
/// - If [`src_image`] is non-sparse then the image or *disjoint* plane to be copied  **must**  be
///   bound completely and contiguously to a single [`DeviceMemory`] object
/// - [`src_image_layout`] **must**  specify the layout of the image subresources of [`src_image`]
///   specified in [`regions`] at the time this command is executed on a [`Device`]
/// - [`src_image_layout`] **must**  be `VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL`,
///   `VK_IMAGE_LAYOUT_GENERAL`, or `VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR`
/// - The [format features](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#resources-image-format-features)
///   of [`dst_image`] **must**  contain `VK_FORMAT_FEATURE_TRANSFER_DST_BIT`
/// - If [`dst_image`] is non-sparse then the image or *disjoint* plane that is the destination of
///   the copy  **must**  be bound completely and contiguously to a single [`DeviceMemory`] object
/// - [`dst_image_layout`] **must**  specify the layout of the image subresources of [`dst_image`]
///   specified in [`regions`] at the time this command is executed on a [`Device`]
/// - [`dst_image_layout`] **must**  be `VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL`,
///   `VK_IMAGE_LAYOUT_GENERAL`, or `VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR`
/// - If the [`Format`] of each of [`src_image`] and [`dst_image`] is not a [*multi-planar format*](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#formats-requiring-sampler-ycbcr-conversion),
///   the [`Format`] of each of [`src_image`] and [`dst_image`] **must**  be compatible, as defined [above](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#copies-images-format-compatibility)
/// -    In a copy to or from a plane of a [multi-planar image](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#formats-requiring-sampler-ycbcr-conversion), the [`Format`] of the image and plane  **must**  be compatible according to [the description of compatible planes](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#formats-compatible-planes) for the plane being copied
/// - The sample count of [`src_image`] and [`dst_image`] **must**  match
/// - The `srcSubresource.mipLevel` member of each element of [`regions`] **must**  be less than the
///   `mipLevels` specified in [`ImageCreateInfo`] when [`src_image`] was created
/// - The `dstSubresource.mipLevel` member of each element of [`regions`] **must**  be less than the
///   `mipLevels` specified in [`ImageCreateInfo`] when [`dst_image`] was created
/// - The `srcSubresource.baseArrayLayer` +  `srcSubresource.layerCount` of each element of
///   [`regions`] **must**  be less than or equal to the `arrayLayers` specified in
///   [`ImageCreateInfo`] when [`src_image`] was created
/// - The `dstSubresource.baseArrayLayer` +  `dstSubresource.layerCount` of each element of
///   [`regions`] **must**  be less than or equal to the `arrayLayers` specified in
///   [`ImageCreateInfo`] when [`dst_image`] was created
/// - The `srcOffset` and `extent` members of each element of [`regions`] **must**  respect the
///   image transfer granularity requirements of `commandBuffer`s command pools queue family, as
///   described in [`QueueFamilyProperties`]
/// - The `dstOffset` and `extent` members of each element of [`regions`] **must**  respect the
///   image transfer granularity requirements of `commandBuffer`s command pools queue family, as
///   described in [`QueueFamilyProperties`]
/// - [`dst_image`] and [`src_image`] **must**  not have been created with `flags` containing
///   `VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT`
/// - If neither [`src_image`] nor [`dst_image`] has a [multi-planar image format](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#formats-requiring-sampler-ycbcr-conversion)
///   then for each element of [`regions`], `srcSubresource.aspectMask` and
///   `dstSubresource.aspectMask` **must**  match
/// - If [`src_image`] has a [`Format`] with [two planes](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#formats-requiring-sampler-ycbcr-conversion)
///   then for each element of [`regions`], `srcSubresource.aspectMask` **must**  be
///   `VK_IMAGE_ASPECT_PLANE_0_BIT` or `VK_IMAGE_ASPECT_PLANE_1_BIT`
/// - If [`src_image`] has a [`Format`] with [three planes](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#formats-requiring-sampler-ycbcr-conversion)
///   then for each element of [`regions`], `srcSubresource.aspectMask` **must**  be
///   `VK_IMAGE_ASPECT_PLANE_0_BIT`, `VK_IMAGE_ASPECT_PLANE_1_BIT`, or `VK_IMAGE_ASPECT_PLANE_2_BIT`
/// - If [`dst_image`] has a [`Format`] with [two planes](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#formats-requiring-sampler-ycbcr-conversion)
///   then for each element of [`regions`], `dstSubresource.aspectMask` **must**  be
///   `VK_IMAGE_ASPECT_PLANE_0_BIT` or `VK_IMAGE_ASPECT_PLANE_1_BIT`
/// - If [`dst_image`] has a [`Format`] with [three planes](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#formats-requiring-sampler-ycbcr-conversion)
///   then for each element of [`regions`], `dstSubresource.aspectMask` **must**  be
///   `VK_IMAGE_ASPECT_PLANE_0_BIT`, `VK_IMAGE_ASPECT_PLANE_1_BIT`, or `VK_IMAGE_ASPECT_PLANE_2_BIT`
/// - If [`src_image`] has a [multi-planar image format](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#formats-requiring-sampler-ycbcr-conversion)
///   and the [`dst_image`] does not have a multi-planar image format, then for each element of
///   [`regions`], `dstSubresource.aspectMask` **must**  be `VK_IMAGE_ASPECT_COLOR_BIT`
/// - If [`dst_image`] has a [multi-planar image format](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#formats-requiring-sampler-ycbcr-conversion)
///   and the [`src_image`] does not have a multi-planar image format, then for each element of
///   [`regions`], `srcSubresource.aspectMask` **must**  be `VK_IMAGE_ASPECT_COLOR_BIT`
/// - If [`src_image`] is of type `VK_IMAGE_TYPE_3D`, then for each element of [`regions`],
///   `srcSubresource.baseArrayLayer` **must**  be `0` and `srcSubresource.layerCount` **must**  be
///   `1`
/// - If [`dst_image`] is of type `VK_IMAGE_TYPE_3D`, then for each element of [`regions`],
///   `dstSubresource.baseArrayLayer` **must**  be `0` and `dstSubresource.layerCount` **must**  be
///   `1`
/// - For each element of [`regions`], `srcSubresource.aspectMask` **must**  specify aspects present
///   in [`src_image`]
/// - For each element of [`regions`], `dstSubresource.aspectMask` **must**  specify aspects present
///   in [`dst_image`]
/// - For each element of [`regions`], `srcOffset.x` and (`extent.width` +  `srcOffset.x`) **must**
///   both be greater than or equal to `0` and less than or equal to the width of the specified
///   `srcSubresource` of [`src_image`]
/// - For each element of [`regions`], `srcOffset.y` and (`extent.height` +  `srcOffset.y`) **must**
///   both be greater than or equal to `0` and less than or equal to the height of the specified
///   `srcSubresource` of [`src_image`]
/// - If [`src_image`] is of type `VK_IMAGE_TYPE_1D`, then for each element of [`regions`],
///   `srcOffset.y` **must**  be `0` and `extent.height` **must**  be `1`
/// - For each element of [`regions`], `srcOffset.z` and (`extent.depth` +  `srcOffset.z`) **must**
///   both be greater than or equal to `0` and less than or equal to the depth of the specified
///   `srcSubresource` of [`src_image`]
/// - If [`src_image`] is of type `VK_IMAGE_TYPE_1D`, then for each element of [`regions`],
///   `srcOffset.z` **must**  be `0` and `extent.depth` **must**  be `1`
/// - If [`dst_image`] is of type `VK_IMAGE_TYPE_1D`, then for each element of [`regions`],
///   `dstOffset.z` **must**  be `0` and `extent.depth` **must**  be `1`
/// - If [`src_image`] is of type `VK_IMAGE_TYPE_2D`, then for each element of [`regions`],
///   `srcOffset.z` **must**  be `0`
/// - If [`dst_image`] is of type `VK_IMAGE_TYPE_2D`, then for each element of [`regions`],
///   `dstOffset.z` **must**  be `0`
/// - If [`src_image`] and [`dst_image`] are both of type `VK_IMAGE_TYPE_2D`, then for each element
///   of [`regions`], `extent.depth` **must**  be `1`
/// - If [`src_image`] is of type `VK_IMAGE_TYPE_2D`, and [`dst_image`] is of type
///   `VK_IMAGE_TYPE_3D`, then for each element of [`regions`], `extent.depth` **must**  equal
///   `srcSubresource.layerCount`
/// - If [`dst_image`] is of type `VK_IMAGE_TYPE_2D`, and [`src_image`] is of type
///   `VK_IMAGE_TYPE_3D`, then for each element of [`regions`], `extent.depth` **must**  equal
///   `dstSubresource.layerCount`
/// - For each element of [`regions`], `dstOffset.x` and (`extent.width` +  `dstOffset.x`) **must**
///   both be greater than or equal to `0` and less than or equal to the width of the specified
///   `dstSubresource` of [`dst_image`]
/// - For each element of [`regions`], `dstOffset.y` and (`extent.height` +  `dstOffset.y`) **must**
///   both be greater than or equal to `0` and less than or equal to the height of the specified
///   `dstSubresource` of [`dst_image`]
/// - If [`dst_image`] is of type `VK_IMAGE_TYPE_1D`, then for each element of [`regions`],
///   `dstOffset.y` **must**  be `0` and `extent.height` **must**  be `1`
/// - For each element of [`regions`], `dstOffset.z` and (`extent.depth` +  `dstOffset.z`) **must**
///   both be greater than or equal to `0` and less than or equal to the depth of the specified
///   `dstSubresource` of [`dst_image`]
/// - If [`src_image`] is a [blocked image](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#blocked-image),
///   then for each element of [`regions`], all members of `srcOffset` **must**  be a multiple of
///   the corresponding dimensions of the compressed texel block
/// - If [`src_image`] is a [blocked image](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#blocked-image),
///   then for each element of [`regions`], `extent.width` **must**  be a multiple of the compressed
///   texel block width or (`extent.width` +  `srcOffset.x`) **must**  equal the width of the
///   specified `srcSubresource` of [`src_image`]
/// - If [`src_image`] is a [blocked image](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#blocked-image),
///   then for each element of [`regions`], `extent.height` **must**  be a multiple of the
///   compressed texel block height or (`extent.height` +  `srcOffset.y`) **must**  equal the height
///   of the specified `srcSubresource` of [`src_image`]
/// - If [`src_image`] is a [blocked image](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#blocked-image),
///   then for each element of [`regions`], `extent.depth` **must**  be a multiple of the compressed
///   texel block depth or (`extent.depth` +  `srcOffset.z`) **must**  equal the depth of the
///   specified `srcSubresource` of [`src_image`]
/// - If [`dst_image`] is a [blocked image](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#blocked-image),
///   then for each element of [`regions`], all members of `dstOffset` **must**  be a multiple of
///   the corresponding dimensions of the compressed texel block
/// - If [`dst_image`] is a [blocked image](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#blocked-image),
///   then for each element of [`regions`], `extent.width` **must**  be a multiple of the compressed
///   texel block width or (`extent.width` +  `dstOffset.x`) **must**  equal the width of the
///   specified `dstSubresource` of [`dst_image`]
/// - If [`dst_image`] is a [blocked image](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#blocked-image),
///   then for each element of [`regions`], `extent.height` **must**  be a multiple of the
///   compressed texel block height or (`extent.height` +  `dstOffset.y`) **must**  equal the height
///   of the specified `dstSubresource` of [`dst_image`]
/// - If [`dst_image`] is a [blocked image](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#blocked-image),
///   then for each element of [`regions`], `extent.depth` **must**  be a multiple of the compressed
///   texel block depth or (`extent.depth` +  `dstOffset.z`) **must**  equal the depth of the
///   specified `dstSubresource` of [`dst_image`]
/// - If the `aspect` member of any element of `pRanges` includes any flag other than
///   `VK_IMAGE_ASPECT_STENCIL_BIT` or [`src_image`] was not created with [separate stencil
///   usage](), `VK_IMAGE_USAGE_TRANSFER_SRC_BIT` **must**  have been included in the
///   [`ImageCreateInfo::usage`] used to create [`src_image`]
/// - If the `aspect` member of any element of `pRanges` includes any flag other than
///   `VK_IMAGE_ASPECT_STENCIL_BIT` or [`dst_image`] was not created with [separate stencil
///   usage](), `VK_IMAGE_USAGE_TRANSFER_DST_BIT` **must**  have been included in the
///   [`ImageCreateInfo::usage`] used to create [`dst_image`]
/// - If the `aspect` member of any element of `pRanges` includes `VK_IMAGE_ASPECT_STENCIL_BIT`, and
///   [`src_image`] was created with [separate stencil usage](), `VK_IMAGE_USAGE_TRANSFER_SRC_BIT`
///   **must**  have been included in the [`ImageStencilUsageCreateInfo::stencil_usage`] used to
///   create [`src_image`]
/// - If the `aspect` member of any element of `pRanges` includes `VK_IMAGE_ASPECT_STENCIL_BIT`, and
///   [`dst_image`] was created with [separate stencil usage](), `VK_IMAGE_USAGE_TRANSFER_DST_BIT`
///   **must**  have been included in the [`ImageStencilUsageCreateInfo::stencil_usage`] used to
///   create [`dst_image`]
///
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be `VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2`
/// - [`p_next`] **must**  be `NULL`
/// - [`src_image`] **must**  be a valid [`Image`] handle
/// - [`src_image_layout`] **must**  be a valid [`ImageLayout`] value
/// - [`dst_image`] **must**  be a valid [`Image`] handle
/// - [`dst_image_layout`] **must**  be a valid [`ImageLayout`] value
/// - [`regions`] **must**  be a valid pointer to an array of [`region_count`] valid [`ImageCopy2`]
///   structures
/// - [`region_count`] **must**  be greater than `0`
/// - Both of [`dst_image`], and [`src_image`] **must**  have been created, allocated, or retrieved
///   from the same [`Device`]
///# Related
/// - [`khr_copy_commands2`]
/// - [`crate::vulkan1_3`]
/// - [`Image`]
/// - [`ImageCopy2`]
/// - [`ImageLayout`]
/// - [`StructureType`]
/// - [`cmd_copy_image2`]
/// - [`cmd_copy_image2_khr`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkCopyImageInfo2")]
#[derive(Debug, Clone, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[repr(C)]
pub struct CopyImageInfo2<'lt> {
    ///Lifetime field
    pub _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] is the type of this structure.
    pub s_type: StructureType,
    ///[`p_next`] is `NULL` or a pointer to a structure extending this
    ///structure.
    pub p_next: *const BaseInStructure<'lt>,
    ///[`src_image`] is the source image.
    pub src_image: Image,
    ///[`src_image_layout`] is the current layout of the source image
    ///subresource.
    pub src_image_layout: ImageLayout,
    ///[`dst_image`] is the destination image.
    pub dst_image: Image,
    ///[`dst_image_layout`] is the current layout of the destination image
    ///subresource.
    pub dst_image_layout: ImageLayout,
    ///[`region_count`] is the number of regions to copy.
    pub region_count: u32,
    ///[`regions`] is a pointer to an array of [`ImageCopy2`] structures
    ///specifying the regions to copy.
    pub regions: *const ImageCopy2<'lt>,
}
impl<'lt> Default for CopyImageInfo2<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: StructureType::COPY_IMAGE_INFO2,
            p_next: std::ptr::null(),
            src_image: Default::default(),
            src_image_layout: Default::default(),
            dst_image: Default::default(),
            dst_image_layout: Default::default(),
            region_count: 0,
            regions: std::ptr::null(),
        }
    }
}
impl<'lt> CopyImageInfo2<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *const BaseInStructure<'lt> {
        self.p_next
    }
    ///Gets the raw value of [`Self::regions`]
    pub fn regions_raw(&self) -> *const ImageCopy2<'lt> {
        self.regions
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *const BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::regions`]
    pub fn set_regions_raw(&mut self, value: *const ImageCopy2<'lt>) -> &mut Self {
        self.regions = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn with_p_next_raw(mut self, value: *const BaseInStructure<'lt>) -> Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::regions`]
    pub fn with_regions_raw(mut self, value: *const ImageCopy2<'lt>) -> Self {
        self.regions = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseInStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::src_image`]
    pub fn src_image(&self) -> Image {
        self.src_image
    }
    ///Gets the value of [`Self::src_image_layout`]
    pub fn src_image_layout(&self) -> ImageLayout {
        self.src_image_layout
    }
    ///Gets the value of [`Self::dst_image`]
    pub fn dst_image(&self) -> Image {
        self.dst_image
    }
    ///Gets the value of [`Self::dst_image_layout`]
    pub fn dst_image_layout(&self) -> ImageLayout {
        self.dst_image_layout
    }
    ///Gets the value of [`Self::region_count`]
    pub fn region_count(&self) -> u32 {
        self.region_count
    }
    ///Gets the value of [`Self::regions`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn regions(&self) -> &[ImageCopy2<'lt>] {
        std::slice::from_raw_parts(self.regions, self.region_count as usize)
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::src_image`]
    pub fn src_image_mut(&mut self) -> &mut Image {
        &mut self.src_image
    }
    ///Gets a mutable reference to the value of [`Self::src_image_layout`]
    pub fn src_image_layout_mut(&mut self) -> &mut ImageLayout {
        &mut self.src_image_layout
    }
    ///Gets a mutable reference to the value of [`Self::dst_image`]
    pub fn dst_image_mut(&mut self) -> &mut Image {
        &mut self.dst_image
    }
    ///Gets a mutable reference to the value of [`Self::dst_image_layout`]
    pub fn dst_image_layout_mut(&mut self) -> &mut ImageLayout {
        &mut self.dst_image_layout
    }
    ///Gets a mutable reference to the value of [`Self::region_count`]
    pub fn region_count_mut(&mut self) -> &mut u32 {
        &mut self.region_count
    }
    ///Sets the value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the value of [`Self::src_image`]
    pub fn set_src_image(&mut self, value: crate::vulkan1_0::Image) -> &mut Self {
        self.src_image = value;
        self
    }
    ///Sets the value of [`Self::src_image_layout`]
    pub fn set_src_image_layout(&mut self, value: crate::vulkan1_0::ImageLayout) -> &mut Self {
        self.src_image_layout = value;
        self
    }
    ///Sets the value of [`Self::dst_image`]
    pub fn set_dst_image(&mut self, value: crate::vulkan1_0::Image) -> &mut Self {
        self.dst_image = value;
        self
    }
    ///Sets the value of [`Self::dst_image_layout`]
    pub fn set_dst_image_layout(&mut self, value: crate::vulkan1_0::ImageLayout) -> &mut Self {
        self.dst_image_layout = value;
        self
    }
    ///Sets the value of [`Self::region_count`]
    pub fn set_region_count(&mut self, value: u32) -> &mut Self {
        self.region_count = value;
        self
    }
    ///Sets the value of [`Self::regions`]
    pub fn set_regions(&mut self, value: &'lt [crate::vulkan1_3::ImageCopy2<'lt>]) -> &mut Self {
        let len_ = value.len() as u32;
        let len_ = len_;
        self.regions = value.as_ptr();
        self.region_count = len_;
        self
    }
    ///Sets the value of [`Self::s_type`]
    pub fn with_s_type(mut self, value: crate::vulkan1_0::StructureType) -> Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn with_p_next(mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the value of [`Self::src_image`]
    pub fn with_src_image(mut self, value: crate::vulkan1_0::Image) -> Self {
        self.src_image = value;
        self
    }
    ///Sets the value of [`Self::src_image_layout`]
    pub fn with_src_image_layout(mut self, value: crate::vulkan1_0::ImageLayout) -> Self {
        self.src_image_layout = value;
        self
    }
    ///Sets the value of [`Self::dst_image`]
    pub fn with_dst_image(mut self, value: crate::vulkan1_0::Image) -> Self {
        self.dst_image = value;
        self
    }
    ///Sets the value of [`Self::dst_image_layout`]
    pub fn with_dst_image_layout(mut self, value: crate::vulkan1_0::ImageLayout) -> Self {
        self.dst_image_layout = value;
        self
    }
    ///Sets the value of [`Self::region_count`]
    pub fn with_region_count(mut self, value: u32) -> Self {
        self.region_count = value;
        self
    }
    ///Sets the value of [`Self::regions`]
    pub fn with_regions(mut self, value: &'lt [crate::vulkan1_3::ImageCopy2<'lt>]) -> Self {
        let len_ = value.len() as u32;
        let len_ = len_;
        self.regions = value.as_ptr();
        self.region_count = len_;
        self
    }
}
///[VkBlitImageInfo2](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBlitImageInfo2.html) - Structure specifying parameters of blit image command
///# C Specifications
///The [`BlitImageInfo2`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_3
///typedef struct VkBlitImageInfo2 {
///    VkStructureType        sType;
///    const void*            pNext;
///    VkImage                srcImage;
///    VkImageLayout          srcImageLayout;
///    VkImage                dstImage;
///    VkImageLayout          dstImageLayout;
///    uint32_t               regionCount;
///    const VkImageBlit2*    pRegions;
///    VkFilter               filter;
///} VkBlitImageInfo2;
///```
///or the equivalent
///```c
///// Provided by VK_KHR_copy_commands2
///typedef VkBlitImageInfo2 VkBlitImageInfo2KHR;
///```
///# Members
/// - [`s_type`] is the type of this structure.
/// - [`p_next`] is `NULL` or a pointer to a structure extending this structure.
/// - [`src_image`] is the source image.
/// - [`src_image_layout`] is the layout of the source image subresources for the blit.
/// - [`dst_image`] is the destination image.
/// - [`dst_image_layout`] is the layout of the destination image subresources for the blit.
/// - [`region_count`] is the number of regions to blit.
/// - [`regions`] is a pointer to an array of [`ImageBlit2`] structures specifying the regions to
///   blit.
/// - [`filter`] is a [`Filter`] specifying the filter to apply if the blits require scaling.
///# Description
///## Valid Usage
/// - The source region specified by each element of [`regions`] **must**  be a region that is
///   contained within [`src_image`]
/// - The destination region specified by each element of [`regions`] **must**  be a region that is
///   contained within [`dst_image`]
/// - The union of all destination regions, specified by the elements of [`regions`],  **must**  not
///   overlap in memory with any texel that  **may**  be sampled during the blit operation
/// - The [format features](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#resources-image-format-features)
///   of [`src_image`] **must**  contain `VK_FORMAT_FEATURE_BLIT_SRC_BIT`
/// - [`src_image`] **must**  not use a [format that requires a sampler YC<sub>B</sub>C<sub>R</sub>
///   conversion](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#formats-requiring-sampler-ycbcr-conversion)
/// - [`src_image`] **must**  have been created with `VK_IMAGE_USAGE_TRANSFER_SRC_BIT` usage flag
/// - If [`src_image`] is non-sparse then it  **must**  be bound completely and contiguously to a
///   single [`DeviceMemory`] object
/// - [`src_image_layout`] **must**  specify the layout of the image subresources of [`src_image`]
///   specified in [`regions`] at the time this command is executed on a [`Device`]
/// - [`src_image_layout`] **must**  be `VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR`,
///   `VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL` or `VK_IMAGE_LAYOUT_GENERAL`
/// - The [format features](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#resources-image-format-features)
///   of [`dst_image`] **must**  contain `VK_FORMAT_FEATURE_BLIT_DST_BIT`
/// - [`dst_image`] **must**  not use a [format that requires a sampler YC<sub>B</sub>C<sub>R</sub>
///   conversion](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#formats-requiring-sampler-ycbcr-conversion)
/// - [`dst_image`] **must**  have been created with `VK_IMAGE_USAGE_TRANSFER_DST_BIT` usage flag
/// - If [`dst_image`] is non-sparse then it  **must**  be bound completely and contiguously to a
///   single [`DeviceMemory`] object
/// - [`dst_image_layout`] **must**  specify the layout of the image subresources of [`dst_image`]
///   specified in [`regions`] at the time this command is executed on a [`Device`]
/// - [`dst_image_layout`] **must**  be `VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR`,
///   `VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL` or `VK_IMAGE_LAYOUT_GENERAL`
/// - If either of [`src_image`] or [`dst_image`] was created with a signed integer [`Format`], the
///   other  **must**  also have been created with a signed integer [`Format`]
/// - If either of [`src_image`] or [`dst_image`] was created with an unsigned integer [`Format`],
///   the other  **must**  also have been created with an unsigned integer [`Format`]
/// - If either of [`src_image`] or [`dst_image`] was created with a depth/stencil format, the other
///   **must**  have exactly the same format
/// - If [`src_image`] was created with a depth/stencil format, [`filter`] **must**  be
///   `VK_FILTER_NEAREST`
/// - [`src_image`] **must**  have been created with a `samples` value of `VK_SAMPLE_COUNT_1_BIT`
/// - [`dst_image`] **must**  have been created with a `samples` value of `VK_SAMPLE_COUNT_1_BIT`
/// - If [`filter`] is `VK_FILTER_LINEAR`, then the [format features](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#resources-image-format-features)
///   of [`src_image`] **must**  contain `VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT`
/// - If [`filter`] is `VK_FILTER_CUBIC_EXT`, then the [format features](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#resources-image-format-features)
///   of [`src_image`] **must**  contain `VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT`
/// - If [`filter`] is `VK_FILTER_CUBIC_EXT`, [`src_image`] **must**  be of type `VK_IMAGE_TYPE_2D`
/// - The `srcSubresource.mipLevel` member of each element of [`regions`] **must**  be less than the
///   `mipLevels` specified in [`ImageCreateInfo`] when [`src_image`] was created
/// - The `dstSubresource.mipLevel` member of each element of [`regions`] **must**  be less than the
///   `mipLevels` specified in [`ImageCreateInfo`] when [`dst_image`] was created
/// - The `srcSubresource.baseArrayLayer` +  `srcSubresource.layerCount` of each element of
///   [`regions`] **must**  be less than or equal to the `arrayLayers` specified in
///   [`ImageCreateInfo`] when [`src_image`] was created
/// - The `dstSubresource.baseArrayLayer` +  `dstSubresource.layerCount` of each element of
///   [`regions`] **must**  be less than or equal to the `arrayLayers` specified in
///   [`ImageCreateInfo`] when [`dst_image`] was created
/// - [`dst_image`] and [`src_image`] **must**  not have been created with `flags` containing
///   `VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT`
/// - If either [`src_image`] or [`dst_image`] is of type `VK_IMAGE_TYPE_3D`, then for each element
///   of [`regions`], `srcSubresource.baseArrayLayer` and `dstSubresource.baseArrayLayer` **must**
///   each be `0`, and `srcSubresource.layerCount` and `dstSubresource.layerCount` **must**  each be
///   `1`
/// - For each element of [`regions`], `srcSubresource.aspectMask` **must**  specify aspects present
///   in [`src_image`]
/// - For each element of [`regions`], `dstSubresource.aspectMask` **must**  specify aspects present
///   in [`dst_image`]
/// - For each element of [`regions`], `srcOffsets`[0].x and `srcOffsets`[1].x  **must**  both be
///   greater than or equal to `0` and less than or equal to the width of the specified
///   `srcSubresource` of [`src_image`]
/// - For each element of [`regions`], `srcOffsets`[0].y and `srcOffsets`[1].y  **must**  both be
///   greater than or equal to `0` and less than or equal to the height of the specified
///   `srcSubresource` of [`src_image`]
/// - If [`src_image`] is of type `VK_IMAGE_TYPE_1D`, then for each element of [`regions`],
///   `srcOffsets`[0].y  **must**  be `0` and `srcOffsets`[1].y  **must**  be `1`
/// - For each element of [`regions`], `srcOffsets`[0].z and `srcOffsets`[1].z  **must**  both be
///   greater than or equal to `0` and less than or equal to the depth of the specified
///   `srcSubresource` of [`src_image`]
/// - If [`src_image`] is of type `VK_IMAGE_TYPE_1D` or `VK_IMAGE_TYPE_2D`, then for each element of
///   [`regions`], `srcOffsets`[0].z  **must**  be `0` and `srcOffsets`[1].z  **must**  be `1`
/// - For each element of [`regions`], `dstOffsets`[0].x and `dstOffsets`[1].x  **must**  both be
///   greater than or equal to `0` and less than or equal to the width of the specified
///   `dstSubresource` of [`dst_image`]
/// - For each element of [`regions`], `dstOffsets`[0].y and `dstOffsets`[1].y  **must**  both be
///   greater than or equal to `0` and less than or equal to the height of the specified
///   `dstSubresource` of [`dst_image`]
/// - If [`dst_image`] is of type `VK_IMAGE_TYPE_1D`, then for each element of [`regions`],
///   `dstOffsets`[0].y  **must**  be `0` and `dstOffsets`[1].y  **must**  be `1`
/// - For each element of [`regions`], `dstOffsets`[0].z and `dstOffsets`[1].z  **must**  both be
///   greater than or equal to `0` and less than or equal to the depth of the specified
///   `dstSubresource` of [`dst_image`]
/// - If [`dst_image`] is of type `VK_IMAGE_TYPE_1D` or `VK_IMAGE_TYPE_2D`, then for each element of
///   [`regions`], `dstOffsets`[0].z  **must**  be `0` and `dstOffsets`[1].z  **must**  be `1`
/// - If any element of [`regions`] contains [`CopyCommandTransformInfoQCOM`] in its [`p_next`]
///   chain, then [`src_image`] and [`dst_image`] **must**  not be block-compressed images
/// - If any element of [`regions`] contains [`CopyCommandTransformInfoQCOM`] in its [`p_next`]
///   chain, then [`src_image`] **must**  be of type `VK_IMAGE_TYPE_2D`
/// -    If any element of [`regions`] contains [`CopyCommandTransformInfoQCOM`] in its [`p_next`] chain, then [`src_image`] **must**  not have a [multi-planar format](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#formats-requiring-sampler-ycbcr-conversion)
///
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be `VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2`
/// - [`p_next`] **must**  be `NULL`
/// - [`src_image`] **must**  be a valid [`Image`] handle
/// - [`src_image_layout`] **must**  be a valid [`ImageLayout`] value
/// - [`dst_image`] **must**  be a valid [`Image`] handle
/// - [`dst_image_layout`] **must**  be a valid [`ImageLayout`] value
/// - [`regions`] **must**  be a valid pointer to an array of [`region_count`] valid [`ImageBlit2`]
///   structures
/// - [`filter`] **must**  be a valid [`Filter`] value
/// - [`region_count`] **must**  be greater than `0`
/// - Both of [`dst_image`], and [`src_image`] **must**  have been created, allocated, or retrieved
///   from the same [`Device`]
///# Related
/// - [`khr_copy_commands2`]
/// - [`crate::vulkan1_3`]
/// - [`Filter`]
/// - [`Image`]
/// - [`ImageBlit2`]
/// - [`ImageLayout`]
/// - [`StructureType`]
/// - [`cmd_blit_image2`]
/// - [`cmd_blit_image2_khr`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkBlitImageInfo2")]
#[derive(Debug, Clone, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[repr(C)]
pub struct BlitImageInfo2<'lt> {
    ///Lifetime field
    pub _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] is the type of this structure.
    pub s_type: StructureType,
    ///[`p_next`] is `NULL` or a pointer to a structure extending this
    ///structure.
    pub p_next: *const BaseInStructure<'lt>,
    ///[`src_image`] is the source image.
    pub src_image: Image,
    ///[`src_image_layout`] is the layout of the source image subresources for
    ///the blit.
    pub src_image_layout: ImageLayout,
    ///[`dst_image`] is the destination image.
    pub dst_image: Image,
    ///[`dst_image_layout`] is the layout of the destination image subresources
    ///for the blit.
    pub dst_image_layout: ImageLayout,
    ///[`region_count`] is the number of regions to blit.
    pub region_count: u32,
    ///[`regions`] is a pointer to an array of [`ImageBlit2`] structures
    ///specifying the regions to blit.
    pub regions: *const ImageBlit2<'lt>,
    ///[`filter`] is a [`Filter`] specifying the filter to apply if the
    ///blits require scaling.
    pub filter: Filter,
}
impl<'lt> Default for BlitImageInfo2<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: StructureType::BLIT_IMAGE_INFO2,
            p_next: std::ptr::null(),
            src_image: Default::default(),
            src_image_layout: Default::default(),
            dst_image: Default::default(),
            dst_image_layout: Default::default(),
            region_count: 0,
            regions: std::ptr::null(),
            filter: Default::default(),
        }
    }
}
impl<'lt> BlitImageInfo2<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *const BaseInStructure<'lt> {
        self.p_next
    }
    ///Gets the raw value of [`Self::regions`]
    pub fn regions_raw(&self) -> *const ImageBlit2<'lt> {
        self.regions
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *const BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::regions`]
    pub fn set_regions_raw(&mut self, value: *const ImageBlit2<'lt>) -> &mut Self {
        self.regions = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn with_p_next_raw(mut self, value: *const BaseInStructure<'lt>) -> Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::regions`]
    pub fn with_regions_raw(mut self, value: *const ImageBlit2<'lt>) -> Self {
        self.regions = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseInStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::src_image`]
    pub fn src_image(&self) -> Image {
        self.src_image
    }
    ///Gets the value of [`Self::src_image_layout`]
    pub fn src_image_layout(&self) -> ImageLayout {
        self.src_image_layout
    }
    ///Gets the value of [`Self::dst_image`]
    pub fn dst_image(&self) -> Image {
        self.dst_image
    }
    ///Gets the value of [`Self::dst_image_layout`]
    pub fn dst_image_layout(&self) -> ImageLayout {
        self.dst_image_layout
    }
    ///Gets the value of [`Self::region_count`]
    pub fn region_count(&self) -> u32 {
        self.region_count
    }
    ///Gets the value of [`Self::regions`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn regions(&self) -> &[ImageBlit2<'lt>] {
        std::slice::from_raw_parts(self.regions, self.region_count as usize)
    }
    ///Gets the value of [`Self::filter`]
    pub fn filter(&self) -> Filter {
        self.filter
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::src_image`]
    pub fn src_image_mut(&mut self) -> &mut Image {
        &mut self.src_image
    }
    ///Gets a mutable reference to the value of [`Self::src_image_layout`]
    pub fn src_image_layout_mut(&mut self) -> &mut ImageLayout {
        &mut self.src_image_layout
    }
    ///Gets a mutable reference to the value of [`Self::dst_image`]
    pub fn dst_image_mut(&mut self) -> &mut Image {
        &mut self.dst_image
    }
    ///Gets a mutable reference to the value of [`Self::dst_image_layout`]
    pub fn dst_image_layout_mut(&mut self) -> &mut ImageLayout {
        &mut self.dst_image_layout
    }
    ///Gets a mutable reference to the value of [`Self::region_count`]
    pub fn region_count_mut(&mut self) -> &mut u32 {
        &mut self.region_count
    }
    ///Gets a mutable reference to the value of [`Self::filter`]
    pub fn filter_mut(&mut self) -> &mut Filter {
        &mut self.filter
    }
    ///Sets the value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the value of [`Self::src_image`]
    pub fn set_src_image(&mut self, value: crate::vulkan1_0::Image) -> &mut Self {
        self.src_image = value;
        self
    }
    ///Sets the value of [`Self::src_image_layout`]
    pub fn set_src_image_layout(&mut self, value: crate::vulkan1_0::ImageLayout) -> &mut Self {
        self.src_image_layout = value;
        self
    }
    ///Sets the value of [`Self::dst_image`]
    pub fn set_dst_image(&mut self, value: crate::vulkan1_0::Image) -> &mut Self {
        self.dst_image = value;
        self
    }
    ///Sets the value of [`Self::dst_image_layout`]
    pub fn set_dst_image_layout(&mut self, value: crate::vulkan1_0::ImageLayout) -> &mut Self {
        self.dst_image_layout = value;
        self
    }
    ///Sets the value of [`Self::region_count`]
    pub fn set_region_count(&mut self, value: u32) -> &mut Self {
        self.region_count = value;
        self
    }
    ///Sets the value of [`Self::regions`]
    pub fn set_regions(&mut self, value: &'lt [crate::vulkan1_3::ImageBlit2<'lt>]) -> &mut Self {
        let len_ = value.len() as u32;
        let len_ = len_;
        self.regions = value.as_ptr();
        self.region_count = len_;
        self
    }
    ///Sets the value of [`Self::filter`]
    pub fn set_filter(&mut self, value: crate::vulkan1_0::Filter) -> &mut Self {
        self.filter = value;
        self
    }
    ///Sets the value of [`Self::s_type`]
    pub fn with_s_type(mut self, value: crate::vulkan1_0::StructureType) -> Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn with_p_next(mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the value of [`Self::src_image`]
    pub fn with_src_image(mut self, value: crate::vulkan1_0::Image) -> Self {
        self.src_image = value;
        self
    }
    ///Sets the value of [`Self::src_image_layout`]
    pub fn with_src_image_layout(mut self, value: crate::vulkan1_0::ImageLayout) -> Self {
        self.src_image_layout = value;
        self
    }
    ///Sets the value of [`Self::dst_image`]
    pub fn with_dst_image(mut self, value: crate::vulkan1_0::Image) -> Self {
        self.dst_image = value;
        self
    }
    ///Sets the value of [`Self::dst_image_layout`]
    pub fn with_dst_image_layout(mut self, value: crate::vulkan1_0::ImageLayout) -> Self {
        self.dst_image_layout = value;
        self
    }
    ///Sets the value of [`Self::region_count`]
    pub fn with_region_count(mut self, value: u32) -> Self {
        self.region_count = value;
        self
    }
    ///Sets the value of [`Self::regions`]
    pub fn with_regions(mut self, value: &'lt [crate::vulkan1_3::ImageBlit2<'lt>]) -> Self {
        let len_ = value.len() as u32;
        let len_ = len_;
        self.regions = value.as_ptr();
        self.region_count = len_;
        self
    }
    ///Sets the value of [`Self::filter`]
    pub fn with_filter(mut self, value: crate::vulkan1_0::Filter) -> Self {
        self.filter = value;
        self
    }
}
///[VkCopyBufferToImageInfo2](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCopyBufferToImageInfo2.html) - Structure specifying parameters of a buffer to image copy command
///# C Specifications
///The [`CopyBufferToImageInfo2`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_3
///typedef struct VkCopyBufferToImageInfo2 {
///    VkStructureType              sType;
///    const void*                  pNext;
///    VkBuffer                     srcBuffer;
///    VkImage                      dstImage;
///    VkImageLayout                dstImageLayout;
///    uint32_t                     regionCount;
///    const VkBufferImageCopy2*    pRegions;
///} VkCopyBufferToImageInfo2;
///```
///or the equivalent
///```c
///// Provided by VK_KHR_copy_commands2
///typedef VkCopyBufferToImageInfo2 VkCopyBufferToImageInfo2KHR;
///```
///# Members
/// - [`s_type`] is the type of this structure.
/// - [`p_next`] is `NULL` or a pointer to a structure extending this structure.
/// - [`src_buffer`] is the source buffer.
/// - [`dst_image`] is the destination image.
/// - [`dst_image_layout`] is the layout of the destination image subresources for the copy.
/// - [`region_count`] is the number of regions to copy.
/// - [`regions`] is a pointer to an array of [`BufferImageCopy2`] structures specifying the regions
///   to copy.
///# Description
///## Valid Usage
/// - If the image region specified by each element of [`regions`] does not contain
///   [`CopyCommandTransformInfoQCOM`] in its [`p_next`] chain, it  **must**  be a region that is
///   contained within the specified `imageSubresource` of [`dst_image`]
/// -    If the image region specified by each element of [`regions`] contains [`CopyCommandTransformInfoQCOM`] in its [`p_next`] chain, the rotated destination region as described in [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#copies-buffers-images-rotation-addressing](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#copies-buffers-images-rotation-addressing) **must**  be contained within [`dst_image`]
/// -    If any element of [`regions`] contains [`CopyCommandTransformInfoQCOM`] in its [`p_next`] chain, then [`dst_image`] **must**  not be a [blocked image](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#blocked-image)
/// - If any element of [`regions`] contains [`CopyCommandTransformInfoQCOM`] in its [`p_next`]
///   chain, then [`dst_image`] **must**  be of type `VK_IMAGE_TYPE_2D`
/// -    If any element of [`regions`] contains [`CopyCommandTransformInfoQCOM`] in its [`p_next`] chain, then [`dst_image`] **must**  not have a [multi-planar format](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#formats-requiring-sampler-ycbcr-conversion)
///
/// -  [`src_buffer`] **must**  be large enough to contain all buffer locations that are accessed according to [Buffer and Image Addressing](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#copies-buffers-images-addressing), for each element of [`regions`]
/// - The union of all source regions, and the union of all destination regions, specified by the
///   elements of [`regions`],  **must**  not overlap in memory
/// - [`src_buffer`] **must**  have been created with `VK_BUFFER_USAGE_TRANSFER_SRC_BIT` usage flag
/// - The [format features](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#resources-image-format-features)
///   of [`dst_image`] **must**  contain `VK_FORMAT_FEATURE_TRANSFER_DST_BIT`
/// - If [`src_buffer`] is non-sparse then it  **must**  be bound completely and contiguously to a
///   single [`DeviceMemory`] object
/// - [`dst_image`] **must**  have been created with `VK_IMAGE_USAGE_TRANSFER_DST_BIT` usage flag
/// - If [`dst_image`] is non-sparse then it  **must**  be bound completely and contiguously to a
///   single [`DeviceMemory`] object
/// - [`dst_image`] **must**  have a sample count equal to `VK_SAMPLE_COUNT_1_BIT`
/// - [`dst_image_layout`] **must**  specify the layout of the image subresources of [`dst_image`]
///   specified in [`regions`] at the time this command is executed on a [`Device`]
/// - [`dst_image_layout`] **must**  be `VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL`,
///   `VK_IMAGE_LAYOUT_GENERAL`, or `VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR`
/// - The `imageSubresource.mipLevel` member of each element of [`regions`] **must**  be less than
///   the `mipLevels` specified in [`ImageCreateInfo`] when [`dst_image`] was created
/// - The `imageSubresource.baseArrayLayer` +  `imageSubresource.layerCount` of each element of
///   [`regions`] **must**  be less than or equal to the `arrayLayers` specified in
///   [`ImageCreateInfo`] when [`dst_image`] was created
/// - The `imageOffset` and `imageExtent` members of each element of [`regions`] **must**  respect
///   the image transfer granularity requirements of `commandBuffer`s command pools queue family,
///   as described in [`QueueFamilyProperties`]
/// - [`dst_image`] **must**  not have been created with `flags` containing
///   `VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT`
/// - If the queue family used to create the [`CommandPool`] which `commandBuffer` was allocated
///   from does not support `VK_QUEUE_GRAPHICS_BIT`, for each element of [`regions`], the
///   `aspectMask` member of `imageSubresource` **must**  not be `VK_IMAGE_ASPECT_DEPTH_BIT` or
///   `VK_IMAGE_ASPECT_STENCIL_BIT`
/// - For each element of [`regions`] not containing [`CopyCommandTransformInfoQCOM`] in its
///   [`p_next`] chain, `imageOffset.x` and (`imageExtent.width` +  `imageOffset.x`) **must**  both
///   be greater than or equal to `0` and less than or equal to the width of the specified
///   `imageSubresource` of [`dst_image`]
/// - For each element of [`regions`] not containing [`CopyCommandTransformInfoQCOM`] in its
///   [`p_next`] chain, `imageOffset.y` and (`imageExtent.height` +  `imageOffset.y`) **must**  both
///   be greater than or equal to `0` and less than or equal to the height of the specified
///   `imageSubresource` of [`dst_image`]
///
/// - If [`dst_image`] does not have either a depth/stencil or a [multi-planar format](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#formats-requiring-sampler-ycbcr-conversion),
///   then for each element of [`regions`], `bufferOffset` **must**  be a multiple of the formats
///   texel block size
/// -    If [`dst_image`] has a [multi-planar format](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#formats-requiring-sampler-ycbcr-conversion), then for each element of [`regions`], `bufferOffset` **must**  be a multiple of the element size of the compatible format for the format and the `aspectMask` of the `imageSubresource` as defined in [[formats-compatible-planes]](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#formats-compatible-planes)
/// - If [`dst_image`] is of type `VK_IMAGE_TYPE_1D`, then for each element of [`regions`],
///   `imageOffset.y` **must**  be `0` and `imageExtent.height` **must**  be `1`
/// - For each element of [`regions`], `imageOffset.z` and (`imageExtent.depth` +  `imageOffset.z`)
///   **must**  both be greater than or equal to `0` and less than or equal to the depth of the
///   specified `imageSubresource` of [`dst_image`]
/// - If [`dst_image`] is of type `VK_IMAGE_TYPE_1D` or `VK_IMAGE_TYPE_2D`, then for each element of
///   [`regions`], `imageOffset.z` **must**  be `0` and `imageExtent.depth` **must**  be `1`
/// - If [`dst_image`] is a [blocked image](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#blocked-image),
///   for each element of [`regions`], `bufferRowLength` **must**  be a multiple of the compressed
///   texel block width
/// - If [`dst_image`] is a [blocked image](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#blocked-image),
///   for each element of [`regions`], `bufferImageHeight` **must**  be a multiple of the compressed
///   texel block height
/// - If [`dst_image`] is a [blocked image](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#blocked-image),
///   for each element of [`regions`], all members of `imageOffset` **must**  be a multiple of the
///   corresponding dimensions of the compressed texel block
/// - If [`dst_image`] is a [blocked image](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#blocked-image),
///   for each element of [`regions`], `bufferOffset` **must**  be a multiple of the compressed
///   texel block size in bytes
/// - If [`dst_image`] is a [blocked image](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#blocked-image),
///   for each element of [`regions`], `imageExtent.width` **must**  be a multiple of the compressed
///   texel block width or (`imageExtent.width` +  `imageOffset.x`) **must**  equal the width of the
///   specified `imageSubresource` of [`dst_image`]
/// - If [`dst_image`] is a [blocked image](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#blocked-image),
///   for each element of [`regions`], `imageExtent.height` **must**  be a multiple of the
///   compressed texel block height or (`imageExtent.height` +  `imageOffset.y`) **must**  equal the
///   height of the specified `imageSubresource` of [`dst_image`]
/// - If [`dst_image`] is a [blocked image](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#blocked-image),
///   for each element of [`regions`], `imageExtent.depth` **must**  be a multiple of the compressed
///   texel block depth or (`imageExtent.depth` +  `imageOffset.z`) **must**  equal the depth of the
///   specified `imageSubresource` of [`dst_image`]
/// - For each element of [`regions`], `imageSubresource.aspectMask` **must**  specify aspects
///   present in [`dst_image`]
/// - If [`dst_image`] has a [multi-planar format](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#formats-requiring-sampler-ycbcr-conversion),
///   then for each element of [`regions`], `imageSubresource.aspectMask` **must**  be
///   `VK_IMAGE_ASPECT_PLANE_0_BIT`, `VK_IMAGE_ASPECT_PLANE_1_BIT`, or `VK_IMAGE_ASPECT_PLANE_2_BIT`
///   (with `VK_IMAGE_ASPECT_PLANE_2_BIT` valid only for image formats with three planes)
/// - If [`dst_image`] is of type `VK_IMAGE_TYPE_3D`, for each element of [`regions`],
///   `imageSubresource.baseArrayLayer` **must**  be `0` and `imageSubresource.layerCount` **must**
///   be `1`
/// - If [`dst_image`] is not a [blocked image](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#blocked-image),
///   for each element of [`regions`], `bufferRowLength` multiplied by the texel block size of
///   [`dst_image`] **must**  be less than or equal to 2<sup>31</sup>-1
/// - If [`dst_image`] is a [blocked image](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#blocked-image),
///   for each element of [`regions`], `bufferRowLength` divided by the compressed texel block width
///   and then multiplied by the texel block size of [`dst_image`] **must**  be less than or equal
///   to 2<sup>31</sup>-1
/// - If the queue family used to create the [`CommandPool`] which `commandBuffer` was allocated
///   from does not support `VK_QUEUE_GRAPHICS_BIT` or `VK_QUEUE_COMPUTE_BIT`, the `bufferOffset`
///   member of any element of [`regions`] **must**  be a multiple of `4`
/// - If [`dst_image`] has a depth/stencil format, the `bufferOffset` member of any element of
///   [`regions`] **must**  be a multiple of `4`
///
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be `VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2`
/// - [`p_next`] **must**  be `NULL`
/// - [`src_buffer`] **must**  be a valid [`Buffer`] handle
/// - [`dst_image`] **must**  be a valid [`Image`] handle
/// - [`dst_image_layout`] **must**  be a valid [`ImageLayout`] value
/// - [`regions`] **must**  be a valid pointer to an array of [`region_count`] valid
///   [`BufferImageCopy2`] structures
/// - [`region_count`] **must**  be greater than `0`
/// - Both of [`dst_image`], and [`src_buffer`] **must**  have been created, allocated, or retrieved
///   from the same [`Device`]
///# Related
/// - [`khr_copy_commands2`]
/// - [`crate::vulkan1_3`]
/// - [`Buffer`]
/// - [`BufferImageCopy2`]
/// - [`Image`]
/// - [`ImageLayout`]
/// - [`StructureType`]
/// - [`cmd_copy_buffer_to_image2`]
/// - [`cmd_copy_buffer_to_image2_khr`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkCopyBufferToImageInfo2")]
#[derive(Debug, Clone, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[repr(C)]
pub struct CopyBufferToImageInfo2<'lt> {
    ///Lifetime field
    pub _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] is the type of this structure.
    pub s_type: StructureType,
    ///[`p_next`] is `NULL` or a pointer to a structure extending this
    ///structure.
    pub p_next: *const BaseInStructure<'lt>,
    ///[`src_buffer`] is the source buffer.
    pub src_buffer: Buffer,
    ///[`dst_image`] is the destination image.
    pub dst_image: Image,
    ///[`dst_image_layout`] is the layout of the destination image subresources
    ///for the copy.
    pub dst_image_layout: ImageLayout,
    ///[`region_count`] is the number of regions to copy.
    pub region_count: u32,
    ///[`regions`] is a pointer to an array of [`BufferImageCopy2`]
    ///structures specifying the regions to copy.
    pub regions: *const BufferImageCopy2<'lt>,
}
impl<'lt> Default for CopyBufferToImageInfo2<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: StructureType::COPY_BUFFER_TO_IMAGE_INFO2,
            p_next: std::ptr::null(),
            src_buffer: Default::default(),
            dst_image: Default::default(),
            dst_image_layout: Default::default(),
            region_count: 0,
            regions: std::ptr::null(),
        }
    }
}
impl<'lt> CopyBufferToImageInfo2<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *const BaseInStructure<'lt> {
        self.p_next
    }
    ///Gets the raw value of [`Self::regions`]
    pub fn regions_raw(&self) -> *const BufferImageCopy2<'lt> {
        self.regions
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *const BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::regions`]
    pub fn set_regions_raw(&mut self, value: *const BufferImageCopy2<'lt>) -> &mut Self {
        self.regions = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn with_p_next_raw(mut self, value: *const BaseInStructure<'lt>) -> Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::regions`]
    pub fn with_regions_raw(mut self, value: *const BufferImageCopy2<'lt>) -> Self {
        self.regions = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseInStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::src_buffer`]
    pub fn src_buffer(&self) -> Buffer {
        self.src_buffer
    }
    ///Gets the value of [`Self::dst_image`]
    pub fn dst_image(&self) -> Image {
        self.dst_image
    }
    ///Gets the value of [`Self::dst_image_layout`]
    pub fn dst_image_layout(&self) -> ImageLayout {
        self.dst_image_layout
    }
    ///Gets the value of [`Self::region_count`]
    pub fn region_count(&self) -> u32 {
        self.region_count
    }
    ///Gets the value of [`Self::regions`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn regions(&self) -> &[BufferImageCopy2<'lt>] {
        std::slice::from_raw_parts(self.regions, self.region_count as usize)
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::src_buffer`]
    pub fn src_buffer_mut(&mut self) -> &mut Buffer {
        &mut self.src_buffer
    }
    ///Gets a mutable reference to the value of [`Self::dst_image`]
    pub fn dst_image_mut(&mut self) -> &mut Image {
        &mut self.dst_image
    }
    ///Gets a mutable reference to the value of [`Self::dst_image_layout`]
    pub fn dst_image_layout_mut(&mut self) -> &mut ImageLayout {
        &mut self.dst_image_layout
    }
    ///Gets a mutable reference to the value of [`Self::region_count`]
    pub fn region_count_mut(&mut self) -> &mut u32 {
        &mut self.region_count
    }
    ///Sets the value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the value of [`Self::src_buffer`]
    pub fn set_src_buffer(&mut self, value: crate::vulkan1_0::Buffer) -> &mut Self {
        self.src_buffer = value;
        self
    }
    ///Sets the value of [`Self::dst_image`]
    pub fn set_dst_image(&mut self, value: crate::vulkan1_0::Image) -> &mut Self {
        self.dst_image = value;
        self
    }
    ///Sets the value of [`Self::dst_image_layout`]
    pub fn set_dst_image_layout(&mut self, value: crate::vulkan1_0::ImageLayout) -> &mut Self {
        self.dst_image_layout = value;
        self
    }
    ///Sets the value of [`Self::region_count`]
    pub fn set_region_count(&mut self, value: u32) -> &mut Self {
        self.region_count = value;
        self
    }
    ///Sets the value of [`Self::regions`]
    pub fn set_regions(&mut self, value: &'lt [crate::vulkan1_3::BufferImageCopy2<'lt>]) -> &mut Self {
        let len_ = value.len() as u32;
        let len_ = len_;
        self.regions = value.as_ptr();
        self.region_count = len_;
        self
    }
    ///Sets the value of [`Self::s_type`]
    pub fn with_s_type(mut self, value: crate::vulkan1_0::StructureType) -> Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn with_p_next(mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the value of [`Self::src_buffer`]
    pub fn with_src_buffer(mut self, value: crate::vulkan1_0::Buffer) -> Self {
        self.src_buffer = value;
        self
    }
    ///Sets the value of [`Self::dst_image`]
    pub fn with_dst_image(mut self, value: crate::vulkan1_0::Image) -> Self {
        self.dst_image = value;
        self
    }
    ///Sets the value of [`Self::dst_image_layout`]
    pub fn with_dst_image_layout(mut self, value: crate::vulkan1_0::ImageLayout) -> Self {
        self.dst_image_layout = value;
        self
    }
    ///Sets the value of [`Self::region_count`]
    pub fn with_region_count(mut self, value: u32) -> Self {
        self.region_count = value;
        self
    }
    ///Sets the value of [`Self::regions`]
    pub fn with_regions(mut self, value: &'lt [crate::vulkan1_3::BufferImageCopy2<'lt>]) -> Self {
        let len_ = value.len() as u32;
        let len_ = len_;
        self.regions = value.as_ptr();
        self.region_count = len_;
        self
    }
}
///[VkCopyImageToBufferInfo2](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCopyImageToBufferInfo2.html) - Structure specifying parameters of an image to buffer copy command
///# C Specifications
///The [`CopyImageToBufferInfo2`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_3
///typedef struct VkCopyImageToBufferInfo2 {
///    VkStructureType              sType;
///    const void*                  pNext;
///    VkImage                      srcImage;
///    VkImageLayout                srcImageLayout;
///    VkBuffer                     dstBuffer;
///    uint32_t                     regionCount;
///    const VkBufferImageCopy2*    pRegions;
///} VkCopyImageToBufferInfo2;
///```
///or the equivalent
///```c
///// Provided by VK_KHR_copy_commands2
///typedef VkCopyImageToBufferInfo2 VkCopyImageToBufferInfo2KHR;
///```
///# Members
/// - [`s_type`] is the type of this structure.
/// - [`p_next`] is `NULL` or a pointer to a structure extending this structure.
/// - [`src_image`] is the source image.
/// - [`src_image_layout`] is the layout of the source image subresources for the copy.
/// - [`dst_buffer`] is the destination buffer.
/// - [`region_count`] is the number of regions to copy.
/// - [`regions`] is a pointer to an array of [`BufferImageCopy2`] structures specifying the regions
///   to copy.
///# Description
///## Valid Usage
/// - If the image region specified by each element of [`regions`] does not contain
///   [`CopyCommandTransformInfoQCOM`] in its [`p_next`] chain, it  **must**  be contained within
///   the specified `imageSubresource` of [`src_image`]
/// -    If the image region specified by each element of [`regions`] contains [`CopyCommandTransformInfoQCOM`] in its [`p_next`] chain, the rotated source region as described in [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#copies-buffers-images-rotation-addressing](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#copies-buffers-images-rotation-addressing) **must**  be contained within [`src_image`]
/// -    If any element of [`regions`] contains [`CopyCommandTransformInfoQCOM`] in its [`p_next`] chain, then [`src_image`] **must**  not be a [blocked image](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#blocked-image)
/// - If any element of [`regions`] contains [`CopyCommandTransformInfoQCOM`] in its [`p_next`]
///   chain, then [`src_image`] **must**  be of type `VK_IMAGE_TYPE_2D`
/// -    If any element of [`regions`] contains [`CopyCommandTransformInfoQCOM`] in its [`p_next`] chain, then [`src_image`] **must**  not have a [multi-planar format](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#formats-requiring-sampler-ycbcr-conversion)
///
/// -  [`dst_buffer`] **must**  be large enough to contain all buffer locations that are accessed according to [Buffer and Image Addressing](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#copies-buffers-images-addressing), for each element of [`regions`]
/// - The union of all source regions, and the union of all destination regions, specified by the
///   elements of [`regions`],  **must**  not overlap in memory
/// - [`src_image`] **must**  have been created with `VK_IMAGE_USAGE_TRANSFER_SRC_BIT` usage flag
/// - The [format features](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#resources-image-format-features)
///   of [`src_image`] **must**  contain `VK_FORMAT_FEATURE_TRANSFER_SRC_BIT`
/// - If [`src_image`] is non-sparse then it  **must**  be bound completely and contiguously to a
///   single [`DeviceMemory`] object
/// - [`dst_buffer`] **must**  have been created with `VK_BUFFER_USAGE_TRANSFER_DST_BIT` usage flag
/// - If [`dst_buffer`] is non-sparse then it  **must**  be bound completely and contiguously to a
///   single [`DeviceMemory`] object
/// - [`src_image`] **must**  have a sample count equal to `VK_SAMPLE_COUNT_1_BIT`
/// - [`src_image_layout`] **must**  specify the layout of the image subresources of [`src_image`]
///   specified in [`regions`] at the time this command is executed on a [`Device`]
/// - [`src_image_layout`] **must**  be `VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL`,
///   `VK_IMAGE_LAYOUT_GENERAL`, or `VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR`
/// - The `imageSubresource.mipLevel` member of each element of [`regions`] **must**  be less than
///   the `mipLevels` specified in [`ImageCreateInfo`] when [`src_image`] was created
/// - The `imageSubresource.baseArrayLayer` +  `imageSubresource.layerCount` of each element of
///   [`regions`] **must**  be less than or equal to the `arrayLayers` specified in
///   [`ImageCreateInfo`] when [`src_image`] was created
/// - The `imageOffset` and `imageExtent` members of each element of [`regions`] **must**  respect
///   the image transfer granularity requirements of `commandBuffer`s command pools queue family,
///   as described in [`QueueFamilyProperties`]
/// - [`src_image`] **must**  not have been created with `flags` containing
///   `VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT`
/// - For each element of [`regions`] not containing [`CopyCommandTransformInfoQCOM`] in its
///   [`p_next`] chain, `imageOffset.x` and (`imageExtent.width` +  `imageOffset.x`) **must**  both
///   be greater than or equal to `0` and less than or equal to the width of the specified
///   `imageSubresource` of [`src_image`]
/// - For each element of [`regions`] not containing [`CopyCommandTransformInfoQCOM`] in its
///   [`p_next`] chain, `imageOffset.y` and (`imageExtent.height` +  `imageOffset.y`) **must**  both
///   be greater than or equal to `0` and less than or equal to the height of the specified
///   `imageSubresource` of [`src_image`]
///
/// - If {imageparam} does not have either a depth/stencil or a [multi-planar format](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#formats-requiring-sampler-ycbcr-conversion),
///   then for each element of [`regions`], `bufferOffset` **must**  be a multiple of the formats
///   texel block size
/// -    If {imageparam} has a [multi-planar format](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#formats-requiring-sampler-ycbcr-conversion), then for each element of [`regions`], `bufferOffset` **must**  be a multiple of the element size of the compatible format for the format and the `aspectMask` of the `imageSubresource` as defined in [[formats-compatible-planes]](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#formats-compatible-planes)
/// - If {imageparam} is of type `VK_IMAGE_TYPE_1D`, then for each element of [`regions`],
///   `imageOffset.y` **must**  be `0` and `imageExtent.height` **must**  be `1`
/// - For each element of [`regions`], `imageOffset.z` and (`imageExtent.depth` +  `imageOffset.z`)
///   **must**  both be greater than or equal to `0` and less than or equal to the depth of the
///   specified `imageSubresource` of {imageparam}
/// - If {imageparam} is of type `VK_IMAGE_TYPE_1D` or `VK_IMAGE_TYPE_2D`, then for each element of
///   [`regions`], `imageOffset.z` **must**  be `0` and `imageExtent.depth` **must**  be `1`
/// - If {imageparam} is a [blocked image](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#blocked-image),
///   for each element of [`regions`], `bufferRowLength` **must**  be a multiple of the compressed
///   texel block width
/// - If {imageparam} is a [blocked image](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#blocked-image),
///   for each element of [`regions`], `bufferImageHeight` **must**  be a multiple of the compressed
///   texel block height
/// - If {imageparam} is a [blocked image](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#blocked-image),
///   for each element of [`regions`], all members of `imageOffset` **must**  be a multiple of the
///   corresponding dimensions of the compressed texel block
/// - If {imageparam} is a [blocked image](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#blocked-image),
///   for each element of [`regions`], `bufferOffset` **must**  be a multiple of the compressed
///   texel block size in bytes
/// - If {imageparam} is a [blocked image](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#blocked-image),
///   for each element of [`regions`], `imageExtent.width` **must**  be a multiple of the compressed
///   texel block width or (`imageExtent.width` +  `imageOffset.x`) **must**  equal the width of the
///   specified `imageSubresource` of {imageparam}
/// - If {imageparam} is a [blocked image](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#blocked-image),
///   for each element of [`regions`], `imageExtent.height` **must**  be a multiple of the
///   compressed texel block height or (`imageExtent.height` +  `imageOffset.y`) **must**  equal the
///   height of the specified `imageSubresource` of {imageparam}
/// - If {imageparam} is a [blocked image](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#blocked-image),
///   for each element of [`regions`], `imageExtent.depth` **must**  be a multiple of the compressed
///   texel block depth or (`imageExtent.depth` +  `imageOffset.z`) **must**  equal the depth of the
///   specified `imageSubresource` of {imageparam}
/// - For each element of [`regions`], `imageSubresource.aspectMask` **must**  specify aspects
///   present in {imageparam}
/// - If {imageparam} has a [multi-planar format](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#formats-requiring-sampler-ycbcr-conversion),
///   then for each element of [`regions`], `imageSubresource.aspectMask` **must**  be
///   `VK_IMAGE_ASPECT_PLANE_0_BIT`, `VK_IMAGE_ASPECT_PLANE_1_BIT`, or `VK_IMAGE_ASPECT_PLANE_2_BIT`
///   (with `VK_IMAGE_ASPECT_PLANE_2_BIT` valid only for image formats with three planes)
/// - If {imageparam} is of type `VK_IMAGE_TYPE_3D`, for each element of [`regions`],
///   `imageSubresource.baseArrayLayer` **must**  be `0` and `imageSubresource.layerCount` **must**
///   be `1`
/// - If {imageparam} is not a [blocked image](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#blocked-image),
///   for each element of [`regions`], `bufferRowLength` multiplied by the texel block size of
///   {imageparam}  **must**  be less than or equal to 2<sup>31</sup>-1
/// - If {imageparam} is a [blocked image](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#blocked-image),
///   for each element of [`regions`], `bufferRowLength` divided by the compressed texel block width
///   and then multiplied by the texel block size of {imageparam}  **must**  be less than or equal
///   to 2<sup>31</sup>-1
/// - If the queue family used to create the [`CommandPool`] which `commandBuffer` was allocated
///   from does not support `VK_QUEUE_GRAPHICS_BIT` or `VK_QUEUE_COMPUTE_BIT`, the `bufferOffset`
///   member of any element of [`regions`] **must**  be a multiple of `4`
/// - If {imageparam} has a depth/stencil format, the `bufferOffset` member of any element of
///   [`regions`] **must**  be a multiple of `4`
///
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be `VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2`
/// - [`p_next`] **must**  be `NULL`
/// - [`src_image`] **must**  be a valid [`Image`] handle
/// - [`src_image_layout`] **must**  be a valid [`ImageLayout`] value
/// - [`dst_buffer`] **must**  be a valid [`Buffer`] handle
/// - [`regions`] **must**  be a valid pointer to an array of [`region_count`] valid
///   [`BufferImageCopy2`] structures
/// - [`region_count`] **must**  be greater than `0`
/// - Both of [`dst_buffer`], and [`src_image`] **must**  have been created, allocated, or retrieved
///   from the same [`Device`]
///# Related
/// - [`khr_copy_commands2`]
/// - [`crate::vulkan1_3`]
/// - [`Buffer`]
/// - [`BufferImageCopy2`]
/// - [`Image`]
/// - [`ImageLayout`]
/// - [`StructureType`]
/// - [`cmd_copy_image_to_buffer2`]
/// - [`cmd_copy_image_to_buffer2_khr`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkCopyImageToBufferInfo2")]
#[derive(Debug, Clone, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[repr(C)]
pub struct CopyImageToBufferInfo2<'lt> {
    ///Lifetime field
    pub _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] is the type of this structure.
    pub s_type: StructureType,
    ///[`p_next`] is `NULL` or a pointer to a structure extending this
    ///structure.
    pub p_next: *const BaseInStructure<'lt>,
    ///[`src_image`] is the source image.
    pub src_image: Image,
    ///[`src_image_layout`] is the layout of the source image subresources for
    ///the copy.
    pub src_image_layout: ImageLayout,
    ///[`dst_buffer`] is the destination buffer.
    pub dst_buffer: Buffer,
    ///[`region_count`] is the number of regions to copy.
    pub region_count: u32,
    ///[`regions`] is a pointer to an array of [`BufferImageCopy2`]
    ///structures specifying the regions to copy.
    pub regions: *const BufferImageCopy2<'lt>,
}
impl<'lt> Default for CopyImageToBufferInfo2<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: StructureType::COPY_IMAGE_TO_BUFFER_INFO2,
            p_next: std::ptr::null(),
            src_image: Default::default(),
            src_image_layout: Default::default(),
            dst_buffer: Default::default(),
            region_count: 0,
            regions: std::ptr::null(),
        }
    }
}
impl<'lt> CopyImageToBufferInfo2<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *const BaseInStructure<'lt> {
        self.p_next
    }
    ///Gets the raw value of [`Self::regions`]
    pub fn regions_raw(&self) -> *const BufferImageCopy2<'lt> {
        self.regions
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *const BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::regions`]
    pub fn set_regions_raw(&mut self, value: *const BufferImageCopy2<'lt>) -> &mut Self {
        self.regions = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn with_p_next_raw(mut self, value: *const BaseInStructure<'lt>) -> Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::regions`]
    pub fn with_regions_raw(mut self, value: *const BufferImageCopy2<'lt>) -> Self {
        self.regions = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseInStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::src_image`]
    pub fn src_image(&self) -> Image {
        self.src_image
    }
    ///Gets the value of [`Self::src_image_layout`]
    pub fn src_image_layout(&self) -> ImageLayout {
        self.src_image_layout
    }
    ///Gets the value of [`Self::dst_buffer`]
    pub fn dst_buffer(&self) -> Buffer {
        self.dst_buffer
    }
    ///Gets the value of [`Self::region_count`]
    pub fn region_count(&self) -> u32 {
        self.region_count
    }
    ///Gets the value of [`Self::regions`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn regions(&self) -> &[BufferImageCopy2<'lt>] {
        std::slice::from_raw_parts(self.regions, self.region_count as usize)
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::src_image`]
    pub fn src_image_mut(&mut self) -> &mut Image {
        &mut self.src_image
    }
    ///Gets a mutable reference to the value of [`Self::src_image_layout`]
    pub fn src_image_layout_mut(&mut self) -> &mut ImageLayout {
        &mut self.src_image_layout
    }
    ///Gets a mutable reference to the value of [`Self::dst_buffer`]
    pub fn dst_buffer_mut(&mut self) -> &mut Buffer {
        &mut self.dst_buffer
    }
    ///Gets a mutable reference to the value of [`Self::region_count`]
    pub fn region_count_mut(&mut self) -> &mut u32 {
        &mut self.region_count
    }
    ///Sets the value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the value of [`Self::src_image`]
    pub fn set_src_image(&mut self, value: crate::vulkan1_0::Image) -> &mut Self {
        self.src_image = value;
        self
    }
    ///Sets the value of [`Self::src_image_layout`]
    pub fn set_src_image_layout(&mut self, value: crate::vulkan1_0::ImageLayout) -> &mut Self {
        self.src_image_layout = value;
        self
    }
    ///Sets the value of [`Self::dst_buffer`]
    pub fn set_dst_buffer(&mut self, value: crate::vulkan1_0::Buffer) -> &mut Self {
        self.dst_buffer = value;
        self
    }
    ///Sets the value of [`Self::region_count`]
    pub fn set_region_count(&mut self, value: u32) -> &mut Self {
        self.region_count = value;
        self
    }
    ///Sets the value of [`Self::regions`]
    pub fn set_regions(&mut self, value: &'lt [crate::vulkan1_3::BufferImageCopy2<'lt>]) -> &mut Self {
        let len_ = value.len() as u32;
        let len_ = len_;
        self.regions = value.as_ptr();
        self.region_count = len_;
        self
    }
    ///Sets the value of [`Self::s_type`]
    pub fn with_s_type(mut self, value: crate::vulkan1_0::StructureType) -> Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn with_p_next(mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the value of [`Self::src_image`]
    pub fn with_src_image(mut self, value: crate::vulkan1_0::Image) -> Self {
        self.src_image = value;
        self
    }
    ///Sets the value of [`Self::src_image_layout`]
    pub fn with_src_image_layout(mut self, value: crate::vulkan1_0::ImageLayout) -> Self {
        self.src_image_layout = value;
        self
    }
    ///Sets the value of [`Self::dst_buffer`]
    pub fn with_dst_buffer(mut self, value: crate::vulkan1_0::Buffer) -> Self {
        self.dst_buffer = value;
        self
    }
    ///Sets the value of [`Self::region_count`]
    pub fn with_region_count(mut self, value: u32) -> Self {
        self.region_count = value;
        self
    }
    ///Sets the value of [`Self::regions`]
    pub fn with_regions(mut self, value: &'lt [crate::vulkan1_3::BufferImageCopy2<'lt>]) -> Self {
        let len_ = value.len() as u32;
        let len_ = len_;
        self.regions = value.as_ptr();
        self.region_count = len_;
        self
    }
}
///[VkResolveImageInfo2](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkResolveImageInfo2.html) - Structure specifying parameters of resolve image command
///# C Specifications
///The [`ResolveImageInfo2`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_3
///typedef struct VkResolveImageInfo2 {
///    VkStructureType           sType;
///    const void*               pNext;
///    VkImage                   srcImage;
///    VkImageLayout             srcImageLayout;
///    VkImage                   dstImage;
///    VkImageLayout             dstImageLayout;
///    uint32_t                  regionCount;
///    const VkImageResolve2*    pRegions;
///} VkResolveImageInfo2;
///```
///or the equivalent
///```c
///// Provided by VK_KHR_copy_commands2
///typedef VkResolveImageInfo2 VkResolveImageInfo2KHR;
///```
///# Members
/// - [`s_type`] is the type of this structure.
/// - [`p_next`] is `NULL` or a pointer to a structure extending this structure.
/// - [`src_image`] is the source image.
/// - [`src_image_layout`] is the layout of the source image subresources for the resolve.
/// - [`dst_image`] is the destination image.
/// - [`dst_image_layout`] is the layout of the destination image subresources for the resolve.
/// - [`region_count`] is the number of regions to resolve.
/// - [`regions`] is a pointer to an array of [`ImageResolve2`] structures specifying the regions to
///   resolve.
///# Description
///## Valid Usage
/// - The union of all source regions, and the union of all destination regions, specified by the
///   elements of [`regions`],  **must**  not overlap in memory
/// - If [`src_image`] is non-sparse then it  **must**  be bound completely and contiguously to a
///   single [`DeviceMemory`] object
/// - [`src_image`] **must**  have a sample count equal to any valid sample count value other than
///   `VK_SAMPLE_COUNT_1_BIT`
/// - If [`dst_image`] is non-sparse then it  **must**  be bound completely and contiguously to a
///   single [`DeviceMemory`] object
/// - [`dst_image`] **must**  have a sample count equal to `VK_SAMPLE_COUNT_1_BIT`
/// - [`src_image_layout`] **must**  specify the layout of the image subresources of [`src_image`]
///   specified in [`regions`] at the time this command is executed on a [`Device`]
/// - [`src_image_layout`] **must**  be `VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR`,
///   `VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL` or `VK_IMAGE_LAYOUT_GENERAL`
/// - [`dst_image_layout`] **must**  specify the layout of the image subresources of [`dst_image`]
///   specified in [`regions`] at the time this command is executed on a [`Device`]
/// - [`dst_image_layout`] **must**  be `VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR`,
///   `VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL` or `VK_IMAGE_LAYOUT_GENERAL`
/// - The [format features](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#resources-image-format-features)
///   of [`dst_image`] **must**  contain `VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT`
/// -    If the [`linearColorAttachment`]() feature is enabled and the image is created with `VK_IMAGE_TILING_LINEAR`, the [format features](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#resources-image-format-features) of [`dst_image`] **must**  contain `VK_FORMAT_FEATURE_2_LINEAR_COLOR_ATTACHMENT_BIT_NV`
/// - [`src_image`] and [`dst_image`] **must**  have been created with the same image format
/// - The `srcSubresource.mipLevel` member of each element of [`regions`] **must**  be less than the
///   `mipLevels` specified in [`ImageCreateInfo`] when [`src_image`] was created
/// - The `dstSubresource.mipLevel` member of each element of [`regions`] **must**  be less than the
///   `mipLevels` specified in [`ImageCreateInfo`] when [`dst_image`] was created
/// - The `srcSubresource.baseArrayLayer` +  `srcSubresource.layerCount` of each element of
///   [`regions`] **must**  be less than or equal to the `arrayLayers` specified in
///   [`ImageCreateInfo`] when [`src_image`] was created
/// - The `dstSubresource.baseArrayLayer` +  `dstSubresource.layerCount` of each element of
///   [`regions`] **must**  be less than or equal to the `arrayLayers` specified in
///   [`ImageCreateInfo`] when [`dst_image`] was created
/// - [`dst_image`] and [`src_image`] **must**  not have been created with `flags` containing
///   `VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT`
/// - If either [`src_image`] or [`dst_image`] are of type `VK_IMAGE_TYPE_3D`, then for each element
///   of [`regions`], `srcSubresource.baseArrayLayer` **must**  be `0` and
///   `srcSubresource.layerCount` **must**  be `1`
/// - If either [`src_image`] or [`dst_image`] are of type `VK_IMAGE_TYPE_3D`, then for each element
///   of [`regions`], `dstSubresource.baseArrayLayer` **must**  be `0` and
///   `dstSubresource.layerCount` **must**  be `1`
/// - For each element of [`regions`], `srcOffset.x` and (`extent.width` +  `srcOffset.x`) **must**
///   both be greater than or equal to `0` and less than or equal to the width of the specified
///   `srcSubresource` of [`src_image`]
/// - For each element of [`regions`], `srcOffset.y` and (`extent.height` +  `srcOffset.y`) **must**
///   both be greater than or equal to `0` and less than or equal to the height of the specified
///   `srcSubresource` of [`src_image`]
/// - If [`src_image`] is of type `VK_IMAGE_TYPE_1D`, then for each element of [`regions`],
///   `srcOffset.y` **must**  be `0` and `extent.height` **must**  be `1`
/// - For each element of [`regions`], `srcOffset.z` and (`extent.depth` +  `srcOffset.z`) **must**
///   both be greater than or equal to `0` and less than or equal to the depth of the specified
///   `srcSubresource` of [`src_image`]
/// - If [`src_image`] is of type `VK_IMAGE_TYPE_1D` or `VK_IMAGE_TYPE_2D`, then for each element of
///   [`regions`], `srcOffset.z` **must**  be `0` and `extent.depth` **must**  be `1`
/// - For each element of [`regions`], `dstOffset.x` and (`extent.width` +  `dstOffset.x`) **must**
///   both be greater than or equal to `0` and less than or equal to the width of the specified
///   `dstSubresource` of [`dst_image`]
/// - For each element of [`regions`], `dstOffset.y` and (`extent.height` +  `dstOffset.y`) **must**
///   both be greater than or equal to `0` and less than or equal to the height of the specified
///   `dstSubresource` of [`dst_image`]
/// - If [`dst_image`] is of type `VK_IMAGE_TYPE_1D`, then for each element of [`regions`],
///   `dstOffset.y` **must**  be `0` and `extent.height` **must**  be `1`
/// - For each element of [`regions`], `dstOffset.z` and (`extent.depth` +  `dstOffset.z`) **must**
///   both be greater than or equal to `0` and less than or equal to the depth of the specified
///   `dstSubresource` of [`dst_image`]
/// - If [`dst_image`] is of type `VK_IMAGE_TYPE_1D` or `VK_IMAGE_TYPE_2D`, then for each element of
///   [`regions`], `dstOffset.z` **must**  be `0` and `extent.depth` **must**  be `1`
///
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be `VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2`
/// - [`p_next`] **must**  be `NULL`
/// - [`src_image`] **must**  be a valid [`Image`] handle
/// - [`src_image_layout`] **must**  be a valid [`ImageLayout`] value
/// - [`dst_image`] **must**  be a valid [`Image`] handle
/// - [`dst_image_layout`] **must**  be a valid [`ImageLayout`] value
/// - [`regions`] **must**  be a valid pointer to an array of [`region_count`] valid
///   [`ImageResolve2`] structures
/// - [`region_count`] **must**  be greater than `0`
/// - Both of [`dst_image`], and [`src_image`] **must**  have been created, allocated, or retrieved
///   from the same [`Device`]
///# Related
/// - [`khr_copy_commands2`]
/// - [`crate::vulkan1_3`]
/// - [`Image`]
/// - [`ImageLayout`]
/// - [`ImageResolve2`]
/// - [`StructureType`]
/// - [`cmd_resolve_image2`]
/// - [`cmd_resolve_image2_khr`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkResolveImageInfo2")]
#[derive(Debug, Clone, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[repr(C)]
pub struct ResolveImageInfo2<'lt> {
    ///Lifetime field
    pub _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] is the type of this structure.
    pub s_type: StructureType,
    ///[`p_next`] is `NULL` or a pointer to a structure extending this
    ///structure.
    pub p_next: *const BaseInStructure<'lt>,
    ///[`src_image`] is the source image.
    pub src_image: Image,
    ///[`src_image_layout`] is the layout of the source image subresources for
    ///the resolve.
    pub src_image_layout: ImageLayout,
    ///[`dst_image`] is the destination image.
    pub dst_image: Image,
    ///[`dst_image_layout`] is the layout of the destination image subresources
    ///for the resolve.
    pub dst_image_layout: ImageLayout,
    ///[`region_count`] is the number of regions to resolve.
    pub region_count: u32,
    ///[`regions`] is a pointer to an array of [`ImageResolve2`]
    ///structures specifying the regions to resolve.
    pub regions: *const ImageResolve2<'lt>,
}
impl<'lt> Default for ResolveImageInfo2<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: StructureType::RESOLVE_IMAGE_INFO2,
            p_next: std::ptr::null(),
            src_image: Default::default(),
            src_image_layout: Default::default(),
            dst_image: Default::default(),
            dst_image_layout: Default::default(),
            region_count: 0,
            regions: std::ptr::null(),
        }
    }
}
impl<'lt> ResolveImageInfo2<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *const BaseInStructure<'lt> {
        self.p_next
    }
    ///Gets the raw value of [`Self::regions`]
    pub fn regions_raw(&self) -> *const ImageResolve2<'lt> {
        self.regions
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *const BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::regions`]
    pub fn set_regions_raw(&mut self, value: *const ImageResolve2<'lt>) -> &mut Self {
        self.regions = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn with_p_next_raw(mut self, value: *const BaseInStructure<'lt>) -> Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::regions`]
    pub fn with_regions_raw(mut self, value: *const ImageResolve2<'lt>) -> Self {
        self.regions = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseInStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::src_image`]
    pub fn src_image(&self) -> Image {
        self.src_image
    }
    ///Gets the value of [`Self::src_image_layout`]
    pub fn src_image_layout(&self) -> ImageLayout {
        self.src_image_layout
    }
    ///Gets the value of [`Self::dst_image`]
    pub fn dst_image(&self) -> Image {
        self.dst_image
    }
    ///Gets the value of [`Self::dst_image_layout`]
    pub fn dst_image_layout(&self) -> ImageLayout {
        self.dst_image_layout
    }
    ///Gets the value of [`Self::region_count`]
    pub fn region_count(&self) -> u32 {
        self.region_count
    }
    ///Gets the value of [`Self::regions`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn regions(&self) -> &[ImageResolve2<'lt>] {
        std::slice::from_raw_parts(self.regions, self.region_count as usize)
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::src_image`]
    pub fn src_image_mut(&mut self) -> &mut Image {
        &mut self.src_image
    }
    ///Gets a mutable reference to the value of [`Self::src_image_layout`]
    pub fn src_image_layout_mut(&mut self) -> &mut ImageLayout {
        &mut self.src_image_layout
    }
    ///Gets a mutable reference to the value of [`Self::dst_image`]
    pub fn dst_image_mut(&mut self) -> &mut Image {
        &mut self.dst_image
    }
    ///Gets a mutable reference to the value of [`Self::dst_image_layout`]
    pub fn dst_image_layout_mut(&mut self) -> &mut ImageLayout {
        &mut self.dst_image_layout
    }
    ///Gets a mutable reference to the value of [`Self::region_count`]
    pub fn region_count_mut(&mut self) -> &mut u32 {
        &mut self.region_count
    }
    ///Sets the value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the value of [`Self::src_image`]
    pub fn set_src_image(&mut self, value: crate::vulkan1_0::Image) -> &mut Self {
        self.src_image = value;
        self
    }
    ///Sets the value of [`Self::src_image_layout`]
    pub fn set_src_image_layout(&mut self, value: crate::vulkan1_0::ImageLayout) -> &mut Self {
        self.src_image_layout = value;
        self
    }
    ///Sets the value of [`Self::dst_image`]
    pub fn set_dst_image(&mut self, value: crate::vulkan1_0::Image) -> &mut Self {
        self.dst_image = value;
        self
    }
    ///Sets the value of [`Self::dst_image_layout`]
    pub fn set_dst_image_layout(&mut self, value: crate::vulkan1_0::ImageLayout) -> &mut Self {
        self.dst_image_layout = value;
        self
    }
    ///Sets the value of [`Self::region_count`]
    pub fn set_region_count(&mut self, value: u32) -> &mut Self {
        self.region_count = value;
        self
    }
    ///Sets the value of [`Self::regions`]
    pub fn set_regions(&mut self, value: &'lt [crate::vulkan1_3::ImageResolve2<'lt>]) -> &mut Self {
        let len_ = value.len() as u32;
        let len_ = len_;
        self.regions = value.as_ptr();
        self.region_count = len_;
        self
    }
    ///Sets the value of [`Self::s_type`]
    pub fn with_s_type(mut self, value: crate::vulkan1_0::StructureType) -> Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn with_p_next(mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the value of [`Self::src_image`]
    pub fn with_src_image(mut self, value: crate::vulkan1_0::Image) -> Self {
        self.src_image = value;
        self
    }
    ///Sets the value of [`Self::src_image_layout`]
    pub fn with_src_image_layout(mut self, value: crate::vulkan1_0::ImageLayout) -> Self {
        self.src_image_layout = value;
        self
    }
    ///Sets the value of [`Self::dst_image`]
    pub fn with_dst_image(mut self, value: crate::vulkan1_0::Image) -> Self {
        self.dst_image = value;
        self
    }
    ///Sets the value of [`Self::dst_image_layout`]
    pub fn with_dst_image_layout(mut self, value: crate::vulkan1_0::ImageLayout) -> Self {
        self.dst_image_layout = value;
        self
    }
    ///Sets the value of [`Self::region_count`]
    pub fn with_region_count(mut self, value: u32) -> Self {
        self.region_count = value;
        self
    }
    ///Sets the value of [`Self::regions`]
    pub fn with_regions(mut self, value: &'lt [crate::vulkan1_3::ImageResolve2<'lt>]) -> Self {
        let len_ = value.len() as u32;
        let len_ = len_;
        self.regions = value.as_ptr();
        self.region_count = len_;
        self
    }
}
///[VkPhysicalDeviceShaderTerminateInvocationFeatures](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderTerminateInvocationFeatures.html) - Structure describing support for the SPIR-V code:SPV_KHR_terminate_invocation extension
///# C Specifications
///The [`PhysicalDeviceShaderTerminateInvocationFeatures`] structure is
///defined as:
///```c
///// Provided by VK_VERSION_1_3
///typedef struct VkPhysicalDeviceShaderTerminateInvocationFeatures {
///    VkStructureType    sType;
///    void*              pNext;
///    VkBool32           shaderTerminateInvocation;
///} VkPhysicalDeviceShaderTerminateInvocationFeatures;
///```
///or the equivalent
///```c
///// Provided by VK_KHR_shader_terminate_invocation
///typedef VkPhysicalDeviceShaderTerminateInvocationFeatures
/// VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR;
///```
///# Members
///This structure describes the following feature:
///# Description
/// - [`s_type`] is the type of this structure.
/// - [`p_next`] is `NULL` or a pointer to a structure extending this structure.
///
/// - [`shader_terminate_invocation`] specifies whether the implementation supports SPIR-V modules
///   that use the `SPV_KHR_terminate_invocation` extension.
///If the [`PhysicalDeviceShaderTerminateInvocationFeatures`] structure is included in the
/// [`p_next`] chain of the
///[`PhysicalDeviceFeatures2`] structure passed to
///[`get_physical_device_features2`], it is filled in to indicate whether each
///corresponding feature is supported.
///[`PhysicalDeviceShaderTerminateInvocationFeatures`] **can**  also be used in the [`p_next`]
/// chain of
///[`DeviceCreateInfo`] to selectively enable these features.
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be
///   `VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES`
///# Related
/// - [`khr_shader_terminate_invocation`]
/// - [`crate::vulkan1_3`]
/// - [`Bool32`]
/// - [`StructureType`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkPhysicalDeviceShaderTerminateInvocationFeatures")]
#[derive(Debug, Clone, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[repr(C)]
pub struct PhysicalDeviceShaderTerminateInvocationFeatures<'lt> {
    ///Lifetime field
    pub _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] is the type of this structure.
    pub s_type: StructureType,
    ///[`p_next`] is `NULL` or a pointer to a structure extending this
    ///structure.
    pub p_next: *mut BaseOutStructure<'lt>,
    ///[`shader_terminate_invocation`] specifies whether the implementation
    ///supports SPIR-V modules that use the `SPV_KHR_terminate_invocation`
    ///extension.
    pub shader_terminate_invocation: Bool32,
}
impl<'lt> Default for PhysicalDeviceShaderTerminateInvocationFeatures<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: StructureType::PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES,
            p_next: std::ptr::null_mut(),
            shader_terminate_invocation: 0,
        }
    }
}
impl<'lt> PhysicalDeviceShaderTerminateInvocationFeatures<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *mut BaseOutStructure<'lt> {
        self.p_next
    }
    ///Gets the raw value of [`Self::shader_terminate_invocation`]
    pub fn shader_terminate_invocation_raw(&self) -> Bool32 {
        self.shader_terminate_invocation
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *mut BaseOutStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::shader_terminate_invocation`]
    pub fn set_shader_terminate_invocation_raw(&mut self, value: Bool32) -> &mut Self {
        self.shader_terminate_invocation = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn with_p_next_raw(mut self, value: *mut BaseOutStructure<'lt>) -> Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::shader_terminate_invocation`]
    pub fn with_shader_terminate_invocation_raw(mut self, value: Bool32) -> Self {
        self.shader_terminate_invocation = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseOutStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::shader_terminate_invocation`]
    pub fn shader_terminate_invocation(&self) -> bool {
        unsafe { std::mem::transmute(self.shader_terminate_invocation as u8) }
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next_mut(&mut self) -> &mut BaseOutStructure<'lt> {
        &mut *self.p_next
    }
    ///Gets a mutable reference to the value of [`Self::shader_terminate_invocation`]
    pub fn shader_terminate_invocation_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.shader_terminate_invocation as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.shader_terminate_invocation as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Sets the value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt mut crate::vulkan1_0::BaseOutStructure<'lt>) -> &mut Self {
        self.p_next = value as *mut _;
        self
    }
    ///Sets the value of [`Self::shader_terminate_invocation`]
    pub fn set_shader_terminate_invocation(&mut self, value: bool) -> &mut Self {
        self.shader_terminate_invocation = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::s_type`]
    pub fn with_s_type(mut self, value: crate::vulkan1_0::StructureType) -> Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn with_p_next(mut self, value: &'lt mut crate::vulkan1_0::BaseOutStructure<'lt>) -> Self {
        self.p_next = value as *mut _;
        self
    }
    ///Sets the value of [`Self::shader_terminate_invocation`]
    pub fn with_shader_terminate_invocation(mut self, value: bool) -> Self {
        self.shader_terminate_invocation = value as u8 as u32;
        self
    }
}
///[VkMemoryBarrier2](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryBarrier2.html) - Structure specifying a global memory barrier
///# C Specifications
///The [`MemoryBarrier2`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_3
///typedef struct VkMemoryBarrier2 {
///    VkStructureType          sType;
///    const void*              pNext;
///    VkPipelineStageFlags2    srcStageMask;
///    VkAccessFlags2           srcAccessMask;
///    VkPipelineStageFlags2    dstStageMask;
///    VkAccessFlags2           dstAccessMask;
///} VkMemoryBarrier2;
///```
///or the equivalent
///```c
///// Provided by VK_KHR_synchronization2
///typedef VkMemoryBarrier2 VkMemoryBarrier2KHR;
///```
///# Members
/// - [`s_type`] is the type of this structure.
/// - [`p_next`] is `NULL` or a pointer to a structure extending this structure.
/// - [`src_stage_mask`] is a [`PipelineStageFlags2`] mask of pipeline stages to be included in the [first synchronization scope](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-dependencies-scopes).
/// - [`src_access_mask`] is a [`AccessFlags2`] mask of access flags to be included in the [first access scope](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-dependencies-access-scopes).
/// - [`dst_stage_mask`] is a [`PipelineStageFlags2`] mask of pipeline stages to be included in the [second synchronization scope](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-dependencies-scopes).
/// - [`dst_access_mask`] is a [`AccessFlags2`] mask of access flags to be included in the [second access scope](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-dependencies-access-scopes).
///# Description
///This structure defines a [memory
///dependency](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-dependencies-memory) affecting all device memory.The first [synchronization scope](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-dependencies-scopes) and
///[access scope](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-dependencies-access-scopes) described by
///this structure include only operations and memory accesses specified by
///[`src_stage_mask`] and [`src_access_mask`].The second [synchronization scope](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-dependencies-scopes)
///and [access scope](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-dependencies-access-scopes) described
///by this structure include only operations and memory accesses specified by
///[`dst_stage_mask`] and [`dst_access_mask`].
///## Valid Usage
/// - If the [geometry shaders](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-geometryShader)
///   feature is not enabled, [`src_stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT`
/// - If the [tessellation shaders](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-tessellationShader)
///   feature is not enabled, [`src_stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT` or
///   `VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT`
/// - If the [conditional rendering](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-conditionalRendering)
///   feature is not enabled, [`src_stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT`
/// - If the [fragment density map](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-fragmentDensityMap)
///   feature is not enabled, [`src_stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT`
/// - If the [transform feedback](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-transformFeedback)
///   feature is not enabled, [`src_stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT`
/// - If the [mesh shaders](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-meshShader)
///   feature is not enabled, [`src_stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_NV`
/// - If the [task shaders](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-taskShader)
///   feature is not enabled, [`src_stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_NV`
/// - If the [shading rate image](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-shadingRateImage)
///   feature is not enabled, [`src_stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_2_SHADING_RATE_IMAGE_BIT_NV`
/// - If the [subpass shading](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-subpassShading)
///   feature is not enabled, [`src_stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI`
/// - If the [invocation mask image](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-invocationMask)
///   feature is not enabled, [`src_stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_2_INVOCATION_MASK_BIT_HUAWEI`
/// - If [`src_access_mask`] includes `VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT`, [`src_stage_mask`]
///   **must**  include `VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT`,
///   `VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR`,
///   `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, or `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`src_access_mask`] includes `VK_ACCESS_2_INDEX_READ_BIT`, [`src_stage_mask`] **must**
///   include `VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT`, `VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT`,
///   `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, or `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`src_access_mask`] includes `VK_ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT`, [`src_stage_mask`]
///   **must**  include `VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT`,
///   `VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT`, `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, or
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`src_access_mask`] includes `VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT`, [`src_stage_mask`]
///   **must**  include `VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT`,
///   `VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI`, `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, or
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`src_access_mask`] includes `VK_ACCESS_2_UNIFORM_READ_BIT`, [`src_stage_mask`] **must**
///   include `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`, or one
///   of the `VK_PIPELINE_STAGE_*_SHADER_BIT` stages
/// - If [`src_access_mask`] includes `VK_ACCESS_2_SHADER_SAMPLED_READ_BIT`, [`src_stage_mask`]
///   **must**  include `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`,
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`, or one of the `VK_PIPELINE_STAGE_*_SHADER_BIT` stages
/// - If [`src_access_mask`] includes `VK_ACCESS_2_SHADER_STORAGE_READ_BIT`, [`src_stage_mask`]
///   **must**  include `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`,
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`, or one of the `VK_PIPELINE_STAGE_*_SHADER_BIT` stages
/// - If [`src_access_mask`] includes `VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT`, [`src_stage_mask`]
///   **must**  include `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`,
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`, or one of the `VK_PIPELINE_STAGE_*_SHADER_BIT` stages
/// - If [`src_access_mask`] includes `VK_ACCESS_2_SHADER_READ_BIT`, [`src_stage_mask`] **must**
///   include `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`,
///   `VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR`, or one of the
///   `VK_PIPELINE_STAGE_*_SHADER_BIT` stages
/// - If [`src_access_mask`] includes `VK_ACCESS_2_SHADER_WRITE_BIT`, [`src_stage_mask`] **must**
///   include `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`, or one
///   of the `VK_PIPELINE_STAGE_*_SHADER_BIT` stages
/// - If [`src_access_mask`] includes `VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT`, [`src_stage_mask`]
///   **must**  include
///   `VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT``VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, or
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`src_access_mask`] includes `VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT`, [`src_stage_mask`]
///   **must**  include
///   `VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT``VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, or
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`src_access_mask`] includes `VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT`,
///   [`src_stage_mask`] **must**  include `VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT`,
///   `VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT`, `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, or
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`src_access_mask`] includes `VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT`,
///   [`src_stage_mask`] **must**  include `VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT`,
///   `VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT`, `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, or
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`src_access_mask`] includes `VK_ACCESS_2_TRANSFER_READ_BIT`, [`src_stage_mask`] **must**
///   include `VK_PIPELINE_STAGE_2_COPY_BIT`, `VK_PIPELINE_STAGE_2_BLIT_BIT`,
///   `VK_PIPELINE_STAGE_2_RESOLVE_BIT`, `VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT`,
///   `VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR`, or
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`src_access_mask`] includes `VK_ACCESS_2_TRANSFER_WRITE_BIT`, [`src_stage_mask`] **must**
///   include `VK_PIPELINE_STAGE_2_COPY_BIT`, `VK_PIPELINE_STAGE_2_BLIT_BIT`,
///   `VK_PIPELINE_STAGE_2_RESOLVE_BIT`, `VK_PIPELINE_STAGE_2_CLEAR_BIT`,
///   `VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT`,
///   `VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR`, or
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`src_access_mask`] includes `VK_ACCESS_2_HOST_READ_BIT`, [`src_stage_mask`] **must**
///   include `VK_PIPELINE_STAGE_2_HOST_BIT`
/// - If [`src_access_mask`] includes `VK_ACCESS_2_HOST_WRITE_BIT`, [`src_stage_mask`] **must**
///   include `VK_PIPELINE_STAGE_2_HOST_BIT`
/// - If [`src_access_mask`] includes `VK_ACCESS_2_CONDITIONAL_RENDERING_READ_BIT_EXT`,
///   [`src_stage_mask`] **must**  include `VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT`,
///   `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, or `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`src_access_mask`] includes `VK_ACCESS_2_FRAGMENT_DENSITY_MAP_READ_BIT_EXT`,
///   [`src_stage_mask`] **must**  include `VK_PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT`,
///   `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, or `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`src_access_mask`] includes `VK_ACCESS_2_TRANSFORM_FEEDBACK_WRITE_BIT_EXT`,
///   [`src_stage_mask`] **must**  include `VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT`,
///   `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, or `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`src_access_mask`] includes `VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT`,
///   [`src_stage_mask`] **must**  include `VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT`,
///   `VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT`, `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, or
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`src_access_mask`] includes `VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT`,
///   [`src_stage_mask`] **must**  include `VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT`,
///   `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, or `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`src_access_mask`] includes `VK_ACCESS_2_SHADING_RATE_IMAGE_READ_BIT_NV`,
///   [`src_stage_mask`] **must**  include `VK_PIPELINE_STAGE_2_SHADING_RATE_IMAGE_BIT_NV`,
///   `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, or `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`src_access_mask`] includes `VK_ACCESS_2_INVOCATION_MASK_READ_BIT_HUAWEI`,
///   [`src_stage_mask`] **must**  include `VK_PIPELINE_STAGE_2_INVOCATION_MASK_BIT_HUAWEI`
/// - If [`src_access_mask`] includes `VK_ACCESS_2_COMMAND_PREPROCESS_READ_BIT_NV`,
///   [`src_stage_mask`] **must**  include `VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_NV` or
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`src_access_mask`] includes `VK_ACCESS_2_COMMAND_PREPROCESS_WRITE_BIT_NV`,
///   [`src_stage_mask`] **must**  include `VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_NV` or
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`src_access_mask`] includes `VK_ACCESS_2_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT`,
///   [`src_stage_mask`] **must**  include
///   `VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT``VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, or
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`src_access_mask`] includes `VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_KHR`,
///   [`src_stage_mask`] **must**  include
///   `VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR`,
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`, or one of the `VK_PIPELINE_STAGE_*_SHADER_BIT` stages
/// - If [`src_access_mask`] includes `VK_ACCESS_2_ACCELERATION_STRUCTURE_WRITE_BIT_KHR`,
///   [`src_stage_mask`] **must**  include
///   `VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR` or
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`rayQuery`](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-rayQuery)
///   is not enabled and [`src_access_mask`] includes
///   `VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_KHR`, [`src_stage_mask`] **must**  not include
///   any of the `VK_PIPELINE_STAGE_*_SHADER_BIT` stages except
///   `VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR`
/// - If [`src_access_mask`] includes `VK_ACCESS_2_VIDEO_DECODE_READ_BIT_KHR`, [`src_stage_mask`]
///   **must**  include `VK_PIPELINE_STAGE_2_VIDEO_DECODE_BIT_KHR`
/// - If [`src_access_mask`] includes `VK_ACCESS_2_VIDEO_DECODE_WRITE_BIT_KHR`, [`src_stage_mask`]
///   **must**  include `VK_PIPELINE_STAGE_2_VIDEO_DECODE_BIT_KHR`
/// - If [`src_access_mask`] includes `VK_ACCESS_2_VIDEO_ENCODE_READ_BIT_KHR`, [`src_stage_mask`]
///   **must**  include `VK_PIPELINE_STAGE_2_VIDEO_ENCODE_BIT_KHR`
/// - If [`src_access_mask`] includes `VK_ACCESS_2_VIDEO_ENCODE_WRITE_BIT_KHR`, [`src_stage_mask`]
///   **must**  include `VK_PIPELINE_STAGE_2_VIDEO_ENCODE_BIT_KHR`
///
/// - If the [geometry shaders](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-geometryShader)
///   feature is not enabled, [`dst_stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT`
/// - If the [tessellation shaders](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-tessellationShader)
///   feature is not enabled, [`dst_stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT` or
///   `VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT`
/// - If the [conditional rendering](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-conditionalRendering)
///   feature is not enabled, [`dst_stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT`
/// - If the [fragment density map](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-fragmentDensityMap)
///   feature is not enabled, [`dst_stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT`
/// - If the [transform feedback](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-transformFeedback)
///   feature is not enabled, [`dst_stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT`
/// - If the [mesh shaders](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-meshShader)
///   feature is not enabled, [`dst_stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_NV`
/// - If the [task shaders](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-taskShader)
///   feature is not enabled, [`dst_stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_NV`
/// - If the [shading rate image](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-shadingRateImage)
///   feature is not enabled, [`dst_stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_2_SHADING_RATE_IMAGE_BIT_NV`
/// - If the [subpass shading](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-subpassShading)
///   feature is not enabled, [`dst_stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI`
/// - If the [invocation mask image](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-invocationMask)
///   feature is not enabled, [`dst_stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_2_INVOCATION_MASK_BIT_HUAWEI`
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT`, [`dst_stage_mask`]
///   **must**  include `VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT`,
///   `VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR`,
///   `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, or `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_INDEX_READ_BIT`, [`dst_stage_mask`] **must**
///   include `VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT`, `VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT`,
///   `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, or `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT`, [`dst_stage_mask`]
///   **must**  include `VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT`,
///   `VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT`, `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, or
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT`, [`dst_stage_mask`]
///   **must**  include `VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT`,
///   `VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI`, `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, or
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_UNIFORM_READ_BIT`, [`dst_stage_mask`] **must**
///   include `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`, or one
///   of the `VK_PIPELINE_STAGE_*_SHADER_BIT` stages
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_SHADER_SAMPLED_READ_BIT`, [`dst_stage_mask`]
///   **must**  include `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`,
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`, or one of the `VK_PIPELINE_STAGE_*_SHADER_BIT` stages
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_SHADER_STORAGE_READ_BIT`, [`dst_stage_mask`]
///   **must**  include `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`,
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`, or one of the `VK_PIPELINE_STAGE_*_SHADER_BIT` stages
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT`, [`dst_stage_mask`]
///   **must**  include `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`,
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`, or one of the `VK_PIPELINE_STAGE_*_SHADER_BIT` stages
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_SHADER_READ_BIT`, [`dst_stage_mask`] **must**
///   include `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`,
///   `VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR`, or one of the
///   `VK_PIPELINE_STAGE_*_SHADER_BIT` stages
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_SHADER_WRITE_BIT`, [`dst_stage_mask`] **must**
///   include `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`, or one
///   of the `VK_PIPELINE_STAGE_*_SHADER_BIT` stages
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT`, [`dst_stage_mask`]
///   **must**  include
///   `VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT``VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, or
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT`, [`dst_stage_mask`]
///   **must**  include
///   `VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT``VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, or
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT`,
///   [`dst_stage_mask`] **must**  include `VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT`,
///   `VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT`, `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, or
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT`,
///   [`dst_stage_mask`] **must**  include `VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT`,
///   `VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT`, `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, or
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_TRANSFER_READ_BIT`, [`dst_stage_mask`] **must**
///   include `VK_PIPELINE_STAGE_2_COPY_BIT`, `VK_PIPELINE_STAGE_2_BLIT_BIT`,
///   `VK_PIPELINE_STAGE_2_RESOLVE_BIT`, `VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT`,
///   `VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR`, or
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_TRANSFER_WRITE_BIT`, [`dst_stage_mask`] **must**
///   include `VK_PIPELINE_STAGE_2_COPY_BIT`, `VK_PIPELINE_STAGE_2_BLIT_BIT`,
///   `VK_PIPELINE_STAGE_2_RESOLVE_BIT`, `VK_PIPELINE_STAGE_2_CLEAR_BIT`,
///   `VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT`,
///   `VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR`, or
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_HOST_READ_BIT`, [`dst_stage_mask`] **must**
///   include `VK_PIPELINE_STAGE_2_HOST_BIT`
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_HOST_WRITE_BIT`, [`dst_stage_mask`] **must**
///   include `VK_PIPELINE_STAGE_2_HOST_BIT`
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_CONDITIONAL_RENDERING_READ_BIT_EXT`,
///   [`dst_stage_mask`] **must**  include `VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT`,
///   `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, or `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_FRAGMENT_DENSITY_MAP_READ_BIT_EXT`,
///   [`dst_stage_mask`] **must**  include `VK_PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT`,
///   `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, or `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_TRANSFORM_FEEDBACK_WRITE_BIT_EXT`,
///   [`dst_stage_mask`] **must**  include `VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT`,
///   `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, or `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT`,
///   [`dst_stage_mask`] **must**  include `VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT`,
///   `VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT`, `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, or
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT`,
///   [`dst_stage_mask`] **must**  include `VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT`,
///   `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, or `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_SHADING_RATE_IMAGE_READ_BIT_NV`,
///   [`dst_stage_mask`] **must**  include `VK_PIPELINE_STAGE_2_SHADING_RATE_IMAGE_BIT_NV`,
///   `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, or `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_INVOCATION_MASK_READ_BIT_HUAWEI`,
///   [`dst_stage_mask`] **must**  include `VK_PIPELINE_STAGE_2_INVOCATION_MASK_BIT_HUAWEI`
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_COMMAND_PREPROCESS_READ_BIT_NV`,
///   [`dst_stage_mask`] **must**  include `VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_NV` or
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_COMMAND_PREPROCESS_WRITE_BIT_NV`,
///   [`dst_stage_mask`] **must**  include `VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_NV` or
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT`,
///   [`dst_stage_mask`] **must**  include
///   `VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT``VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, or
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_KHR`,
///   [`dst_stage_mask`] **must**  include
///   `VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR`,
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`, or one of the `VK_PIPELINE_STAGE_*_SHADER_BIT` stages
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_ACCELERATION_STRUCTURE_WRITE_BIT_KHR`,
///   [`dst_stage_mask`] **must**  include
///   `VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR` or
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`rayQuery`](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-rayQuery)
///   is not enabled and [`dst_access_mask`] includes
///   `VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_KHR`, [`dst_stage_mask`] **must**  not include
///   any of the `VK_PIPELINE_STAGE_*_SHADER_BIT` stages except
///   `VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR`
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_VIDEO_DECODE_READ_BIT_KHR`, [`dst_stage_mask`]
///   **must**  include `VK_PIPELINE_STAGE_2_VIDEO_DECODE_BIT_KHR`
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_VIDEO_DECODE_WRITE_BIT_KHR`, [`dst_stage_mask`]
///   **must**  include `VK_PIPELINE_STAGE_2_VIDEO_DECODE_BIT_KHR`
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_VIDEO_ENCODE_READ_BIT_KHR`, [`dst_stage_mask`]
///   **must**  include `VK_PIPELINE_STAGE_2_VIDEO_ENCODE_BIT_KHR`
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_VIDEO_ENCODE_WRITE_BIT_KHR`, [`dst_stage_mask`]
///   **must**  include `VK_PIPELINE_STAGE_2_VIDEO_ENCODE_BIT_KHR`
///
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be `VK_STRUCTURE_TYPE_MEMORY_BARRIER_2`
/// - [`src_stage_mask`] **must**  be a valid combination of [`PipelineStageFlagBits2`] values
/// - [`src_access_mask`] **must**  be a valid combination of [`AccessFlagBits2`] values
/// - [`dst_stage_mask`] **must**  be a valid combination of [`PipelineStageFlagBits2`] values
/// - [`dst_access_mask`] **must**  be a valid combination of [`AccessFlagBits2`] values
///# Related
/// - [`khr_synchronization2`]
/// - [`crate::vulkan1_3`]
/// - [`AccessFlags2`]
/// - [`DependencyInfo`]
/// - [`PipelineStageFlags2`]
/// - [`StructureType`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkMemoryBarrier2")]
#[derive(Debug, Clone, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[repr(C)]
pub struct MemoryBarrier2<'lt> {
    ///Lifetime field
    pub _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] is the type of this structure.
    pub s_type: StructureType,
    ///[`p_next`] is `NULL` or a pointer to a structure extending this
    ///structure.
    pub p_next: *const BaseInStructure<'lt>,
    ///[`src_stage_mask`] is a [`PipelineStageFlags2`] mask of pipeline
    ///stages to be included in the [first synchronization scope](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-dependencies-scopes).
    pub src_stage_mask: PipelineStageFlags2,
    ///[`src_access_mask`] is a [`AccessFlags2`] mask of access flags to be
    ///included in the [first
    ///access scope](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-dependencies-access-scopes).
    pub src_access_mask: AccessFlags2,
    ///[`dst_stage_mask`] is a [`PipelineStageFlags2`] mask of pipeline
    ///stages to be included in the [second synchronization scope](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-dependencies-scopes).
    pub dst_stage_mask: PipelineStageFlags2,
    ///[`dst_access_mask`] is a [`AccessFlags2`] mask of access flags to be
    ///included in the [second
    ///access scope](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-dependencies-access-scopes).
    pub dst_access_mask: AccessFlags2,
}
impl<'lt> Default for MemoryBarrier2<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: StructureType::MEMORY_BARRIER2,
            p_next: std::ptr::null(),
            src_stage_mask: Default::default(),
            src_access_mask: Default::default(),
            dst_stage_mask: Default::default(),
            dst_access_mask: Default::default(),
        }
    }
}
impl<'lt> MemoryBarrier2<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *const BaseInStructure<'lt> {
        self.p_next
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *const BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn with_p_next_raw(mut self, value: *const BaseInStructure<'lt>) -> Self {
        self.p_next = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseInStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::src_stage_mask`]
    pub fn src_stage_mask(&self) -> PipelineStageFlags2 {
        self.src_stage_mask
    }
    ///Gets the value of [`Self::src_access_mask`]
    pub fn src_access_mask(&self) -> AccessFlags2 {
        self.src_access_mask
    }
    ///Gets the value of [`Self::dst_stage_mask`]
    pub fn dst_stage_mask(&self) -> PipelineStageFlags2 {
        self.dst_stage_mask
    }
    ///Gets the value of [`Self::dst_access_mask`]
    pub fn dst_access_mask(&self) -> AccessFlags2 {
        self.dst_access_mask
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::src_stage_mask`]
    pub fn src_stage_mask_mut(&mut self) -> &mut PipelineStageFlags2 {
        &mut self.src_stage_mask
    }
    ///Gets a mutable reference to the value of [`Self::src_access_mask`]
    pub fn src_access_mask_mut(&mut self) -> &mut AccessFlags2 {
        &mut self.src_access_mask
    }
    ///Gets a mutable reference to the value of [`Self::dst_stage_mask`]
    pub fn dst_stage_mask_mut(&mut self) -> &mut PipelineStageFlags2 {
        &mut self.dst_stage_mask
    }
    ///Gets a mutable reference to the value of [`Self::dst_access_mask`]
    pub fn dst_access_mask_mut(&mut self) -> &mut AccessFlags2 {
        &mut self.dst_access_mask
    }
    ///Sets the value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the value of [`Self::src_stage_mask`]
    pub fn set_src_stage_mask(&mut self, value: crate::vulkan1_3::PipelineStageFlags2) -> &mut Self {
        self.src_stage_mask = value;
        self
    }
    ///Sets the value of [`Self::src_access_mask`]
    pub fn set_src_access_mask(&mut self, value: crate::vulkan1_3::AccessFlags2) -> &mut Self {
        self.src_access_mask = value;
        self
    }
    ///Sets the value of [`Self::dst_stage_mask`]
    pub fn set_dst_stage_mask(&mut self, value: crate::vulkan1_3::PipelineStageFlags2) -> &mut Self {
        self.dst_stage_mask = value;
        self
    }
    ///Sets the value of [`Self::dst_access_mask`]
    pub fn set_dst_access_mask(&mut self, value: crate::vulkan1_3::AccessFlags2) -> &mut Self {
        self.dst_access_mask = value;
        self
    }
    ///Sets the value of [`Self::s_type`]
    pub fn with_s_type(mut self, value: crate::vulkan1_0::StructureType) -> Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn with_p_next(mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the value of [`Self::src_stage_mask`]
    pub fn with_src_stage_mask(mut self, value: crate::vulkan1_3::PipelineStageFlags2) -> Self {
        self.src_stage_mask = value;
        self
    }
    ///Sets the value of [`Self::src_access_mask`]
    pub fn with_src_access_mask(mut self, value: crate::vulkan1_3::AccessFlags2) -> Self {
        self.src_access_mask = value;
        self
    }
    ///Sets the value of [`Self::dst_stage_mask`]
    pub fn with_dst_stage_mask(mut self, value: crate::vulkan1_3::PipelineStageFlags2) -> Self {
        self.dst_stage_mask = value;
        self
    }
    ///Sets the value of [`Self::dst_access_mask`]
    pub fn with_dst_access_mask(mut self, value: crate::vulkan1_3::AccessFlags2) -> Self {
        self.dst_access_mask = value;
        self
    }
}
///[VkImageMemoryBarrier2](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageMemoryBarrier2.html) - Structure specifying an image memory barrier
///# C Specifications
///The [`ImageMemoryBarrier2`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_3
///typedef struct VkImageMemoryBarrier2 {
///    VkStructureType            sType;
///    const void*                pNext;
///    VkPipelineStageFlags2      srcStageMask;
///    VkAccessFlags2             srcAccessMask;
///    VkPipelineStageFlags2      dstStageMask;
///    VkAccessFlags2             dstAccessMask;
///    VkImageLayout              oldLayout;
///    VkImageLayout              newLayout;
///    uint32_t                   srcQueueFamilyIndex;
///    uint32_t                   dstQueueFamilyIndex;
///    VkImage                    image;
///    VkImageSubresourceRange    subresourceRange;
///} VkImageMemoryBarrier2;
///```
///or the equivalent
///```c
///// Provided by VK_KHR_synchronization2
///typedef VkImageMemoryBarrier2 VkImageMemoryBarrier2KHR;
///```
///# Members
/// - [`s_type`] is the type of this structure.
/// - [`p_next`] is `NULL` or a pointer to a structure extending this structure.
/// - [`src_stage_mask`] is a [`PipelineStageFlags2`] mask of pipeline stages to be included in the [first synchronization scope](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-dependencies-scopes).
/// - [`src_access_mask`] is a [`AccessFlags2`] mask of access flags to be included in the [first access scope](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-dependencies-access-scopes).
/// - [`dst_stage_mask`] is a [`PipelineStageFlags2`] mask of pipeline stages to be included in the [second synchronization scope](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-dependencies-scopes).
/// - [`dst_access_mask`] is a [`AccessFlags2`] mask of access flags to be included in the [second access scope](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-dependencies-access-scopes).
/// - [`old_layout`] is the old layout in an [image layout transition](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-image-layout-transitions).
/// - [`new_layout`] is the new layout in an [image layout transition](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-image-layout-transitions).
/// - [`src_queue_family_index`] is the source queue family for a [queue family ownership transfer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-queue-transfers).
/// - [`dst_queue_family_index`] is the destination queue family for a [queue family ownership transfer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-queue-transfers).
/// - [`image`] is a handle to the image affected by this barrier.
/// - [`subresource_range`] describes the [image subresource range](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#resources-image-views)
///   within [`image`] that is affected by this barrier.
///# Description
///This structure defines a [memory
///dependency](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-dependencies-memory) limited to an image subresource range, and  **can**  define a
///[queue family transfer operation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-queue-transfers) and
///[image layout transition](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-image-layout-transitions) for
///that subresource range.The first [synchronization scope](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-dependencies-scopes) and
///[access scope](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-dependencies-access-scopes) described by
///this structure include only operations and memory accesses specified by
///[`src_stage_mask`] and [`src_access_mask`].The second [synchronization scope](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-dependencies-scopes)
///and [access scope](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-dependencies-access-scopes) described
///by this structure include only operations and memory accesses specified by
///[`dst_stage_mask`] and [`dst_access_mask`].Both [access scopes](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-dependencies-access-scopes) are
///limited to only memory accesses to [`image`] in the subresource range
///defined by [`subresource_range`].If [`image`] was created with `VK_SHARING_MODE_EXCLUSIVE`, and
///[`src_queue_family_index`] is not equal to [`dst_queue_family_index`], this
///memory barrier defines a [queue family
///transfer operation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-queue-transfers).
///When executed on a queue in the family identified by
///[`src_queue_family_index`], this barrier defines a
///[queue family release operation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-queue-transfers-release)
///for the specified image subresource range, and the second synchronization
///and access scopes do not synchronize operations on that queue.
///When executed on a queue in the family identified by
///[`dst_queue_family_index`], this barrier defines a
///[queue family acquire operation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-queue-transfers-acquire)
///for the specified image subresource range, and the first synchronization and
///access scopes do not synchronize operations on that queue.A [queue family transfer operation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-queue-transfers) is
///also defined if the values are not equal, and either is one of the special
///queue family values reserved for external memory ownership transfers, as
///described in [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-queue-transfers](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-queue-transfers).
///A [queue family release
///operation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-queue-transfers-release) is defined when [`dst_queue_family_index`] is one of those
///values, and a [queue family
///acquire operation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-queue-transfers-acquire) is defined when [`src_queue_family_index`] is one of
///those values.If [`old_layout`] is not equal to [`new_layout`], then the memory barrier
///defines an [image layout
///transition](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-image-layout-transitions) for the specified image subresource range.
///If this memory barrier defines a [queue
///family transfer operation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-queue-transfers), the layout transition is only executed once
///between the queues.If [`image`] has a multi-planar format and the image is *disjoint*, then
///including `VK_IMAGE_ASPECT_COLOR_BIT` in the `aspectMask` member of
///[`subresource_range`] is equivalent to including
///`VK_IMAGE_ASPECT_PLANE_0_BIT`, `VK_IMAGE_ASPECT_PLANE_1_BIT`, and
///(for three-plane formats only) `VK_IMAGE_ASPECT_PLANE_2_BIT`.
///## Valid Usage
/// - If the [geometry shaders](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-geometryShader)
///   feature is not enabled, [`src_stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT`
/// - If the [tessellation shaders](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-tessellationShader)
///   feature is not enabled, [`src_stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT` or
///   `VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT`
/// - If the [conditional rendering](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-conditionalRendering)
///   feature is not enabled, [`src_stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT`
/// - If the [fragment density map](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-fragmentDensityMap)
///   feature is not enabled, [`src_stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT`
/// - If the [transform feedback](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-transformFeedback)
///   feature is not enabled, [`src_stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT`
/// - If the [mesh shaders](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-meshShader)
///   feature is not enabled, [`src_stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_NV`
/// - If the [task shaders](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-taskShader)
///   feature is not enabled, [`src_stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_NV`
/// - If the [shading rate image](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-shadingRateImage)
///   feature is not enabled, [`src_stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_2_SHADING_RATE_IMAGE_BIT_NV`
/// - If the [subpass shading](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-subpassShading)
///   feature is not enabled, [`src_stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI`
/// - If the [invocation mask image](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-invocationMask)
///   feature is not enabled, [`src_stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_2_INVOCATION_MASK_BIT_HUAWEI`
/// - If [`src_access_mask`] includes `VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT`, [`src_stage_mask`]
///   **must**  include `VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT`,
///   `VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR`,
///   `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, or `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`src_access_mask`] includes `VK_ACCESS_2_INDEX_READ_BIT`, [`src_stage_mask`] **must**
///   include `VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT`, `VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT`,
///   `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, or `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`src_access_mask`] includes `VK_ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT`, [`src_stage_mask`]
///   **must**  include `VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT`,
///   `VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT`, `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, or
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`src_access_mask`] includes `VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT`, [`src_stage_mask`]
///   **must**  include `VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT`,
///   `VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI`, `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, or
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`src_access_mask`] includes `VK_ACCESS_2_UNIFORM_READ_BIT`, [`src_stage_mask`] **must**
///   include `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`, or one
///   of the `VK_PIPELINE_STAGE_*_SHADER_BIT` stages
/// - If [`src_access_mask`] includes `VK_ACCESS_2_SHADER_SAMPLED_READ_BIT`, [`src_stage_mask`]
///   **must**  include `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`,
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`, or one of the `VK_PIPELINE_STAGE_*_SHADER_BIT` stages
/// - If [`src_access_mask`] includes `VK_ACCESS_2_SHADER_STORAGE_READ_BIT`, [`src_stage_mask`]
///   **must**  include `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`,
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`, or one of the `VK_PIPELINE_STAGE_*_SHADER_BIT` stages
/// - If [`src_access_mask`] includes `VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT`, [`src_stage_mask`]
///   **must**  include `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`,
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`, or one of the `VK_PIPELINE_STAGE_*_SHADER_BIT` stages
/// - If [`src_access_mask`] includes `VK_ACCESS_2_SHADER_READ_BIT`, [`src_stage_mask`] **must**
///   include `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`,
///   `VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR`, or one of the
///   `VK_PIPELINE_STAGE_*_SHADER_BIT` stages
/// - If [`src_access_mask`] includes `VK_ACCESS_2_SHADER_WRITE_BIT`, [`src_stage_mask`] **must**
///   include `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`, or one
///   of the `VK_PIPELINE_STAGE_*_SHADER_BIT` stages
/// - If [`src_access_mask`] includes `VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT`, [`src_stage_mask`]
///   **must**  include
///   `VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT``VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, or
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`src_access_mask`] includes `VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT`, [`src_stage_mask`]
///   **must**  include
///   `VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT``VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, or
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`src_access_mask`] includes `VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT`,
///   [`src_stage_mask`] **must**  include `VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT`,
///   `VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT`, `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, or
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`src_access_mask`] includes `VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT`,
///   [`src_stage_mask`] **must**  include `VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT`,
///   `VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT`, `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, or
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`src_access_mask`] includes `VK_ACCESS_2_TRANSFER_READ_BIT`, [`src_stage_mask`] **must**
///   include `VK_PIPELINE_STAGE_2_COPY_BIT`, `VK_PIPELINE_STAGE_2_BLIT_BIT`,
///   `VK_PIPELINE_STAGE_2_RESOLVE_BIT`, `VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT`,
///   `VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR`, or
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`src_access_mask`] includes `VK_ACCESS_2_TRANSFER_WRITE_BIT`, [`src_stage_mask`] **must**
///   include `VK_PIPELINE_STAGE_2_COPY_BIT`, `VK_PIPELINE_STAGE_2_BLIT_BIT`,
///   `VK_PIPELINE_STAGE_2_RESOLVE_BIT`, `VK_PIPELINE_STAGE_2_CLEAR_BIT`,
///   `VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT`,
///   `VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR`, or
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`src_access_mask`] includes `VK_ACCESS_2_HOST_READ_BIT`, [`src_stage_mask`] **must**
///   include `VK_PIPELINE_STAGE_2_HOST_BIT`
/// - If [`src_access_mask`] includes `VK_ACCESS_2_HOST_WRITE_BIT`, [`src_stage_mask`] **must**
///   include `VK_PIPELINE_STAGE_2_HOST_BIT`
/// - If [`src_access_mask`] includes `VK_ACCESS_2_CONDITIONAL_RENDERING_READ_BIT_EXT`,
///   [`src_stage_mask`] **must**  include `VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT`,
///   `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, or `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`src_access_mask`] includes `VK_ACCESS_2_FRAGMENT_DENSITY_MAP_READ_BIT_EXT`,
///   [`src_stage_mask`] **must**  include `VK_PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT`,
///   `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, or `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`src_access_mask`] includes `VK_ACCESS_2_TRANSFORM_FEEDBACK_WRITE_BIT_EXT`,
///   [`src_stage_mask`] **must**  include `VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT`,
///   `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, or `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`src_access_mask`] includes `VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT`,
///   [`src_stage_mask`] **must**  include `VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT`,
///   `VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT`, `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, or
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`src_access_mask`] includes `VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT`,
///   [`src_stage_mask`] **must**  include `VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT`,
///   `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, or `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`src_access_mask`] includes `VK_ACCESS_2_SHADING_RATE_IMAGE_READ_BIT_NV`,
///   [`src_stage_mask`] **must**  include `VK_PIPELINE_STAGE_2_SHADING_RATE_IMAGE_BIT_NV`,
///   `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, or `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`src_access_mask`] includes `VK_ACCESS_2_INVOCATION_MASK_READ_BIT_HUAWEI`,
///   [`src_stage_mask`] **must**  include `VK_PIPELINE_STAGE_2_INVOCATION_MASK_BIT_HUAWEI`
/// - If [`src_access_mask`] includes `VK_ACCESS_2_COMMAND_PREPROCESS_READ_BIT_NV`,
///   [`src_stage_mask`] **must**  include `VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_NV` or
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`src_access_mask`] includes `VK_ACCESS_2_COMMAND_PREPROCESS_WRITE_BIT_NV`,
///   [`src_stage_mask`] **must**  include `VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_NV` or
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`src_access_mask`] includes `VK_ACCESS_2_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT`,
///   [`src_stage_mask`] **must**  include
///   `VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT``VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, or
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`src_access_mask`] includes `VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_KHR`,
///   [`src_stage_mask`] **must**  include
///   `VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR`,
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`, or one of the `VK_PIPELINE_STAGE_*_SHADER_BIT` stages
/// - If [`src_access_mask`] includes `VK_ACCESS_2_ACCELERATION_STRUCTURE_WRITE_BIT_KHR`,
///   [`src_stage_mask`] **must**  include
///   `VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR` or
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`rayQuery`](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-rayQuery)
///   is not enabled and [`src_access_mask`] includes
///   `VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_KHR`, [`src_stage_mask`] **must**  not include
///   any of the `VK_PIPELINE_STAGE_*_SHADER_BIT` stages except
///   `VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR`
/// - If [`src_access_mask`] includes `VK_ACCESS_2_VIDEO_DECODE_READ_BIT_KHR`, [`src_stage_mask`]
///   **must**  include `VK_PIPELINE_STAGE_2_VIDEO_DECODE_BIT_KHR`
/// - If [`src_access_mask`] includes `VK_ACCESS_2_VIDEO_DECODE_WRITE_BIT_KHR`, [`src_stage_mask`]
///   **must**  include `VK_PIPELINE_STAGE_2_VIDEO_DECODE_BIT_KHR`
/// - If [`src_access_mask`] includes `VK_ACCESS_2_VIDEO_ENCODE_READ_BIT_KHR`, [`src_stage_mask`]
///   **must**  include `VK_PIPELINE_STAGE_2_VIDEO_ENCODE_BIT_KHR`
/// - If [`src_access_mask`] includes `VK_ACCESS_2_VIDEO_ENCODE_WRITE_BIT_KHR`, [`src_stage_mask`]
///   **must**  include `VK_PIPELINE_STAGE_2_VIDEO_ENCODE_BIT_KHR`
///
/// - If the [geometry shaders](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-geometryShader)
///   feature is not enabled, [`dst_stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT`
/// - If the [tessellation shaders](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-tessellationShader)
///   feature is not enabled, [`dst_stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT` or
///   `VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT`
/// - If the [conditional rendering](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-conditionalRendering)
///   feature is not enabled, [`dst_stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT`
/// - If the [fragment density map](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-fragmentDensityMap)
///   feature is not enabled, [`dst_stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT`
/// - If the [transform feedback](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-transformFeedback)
///   feature is not enabled, [`dst_stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT`
/// - If the [mesh shaders](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-meshShader)
///   feature is not enabled, [`dst_stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_NV`
/// - If the [task shaders](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-taskShader)
///   feature is not enabled, [`dst_stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_NV`
/// - If the [shading rate image](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-shadingRateImage)
///   feature is not enabled, [`dst_stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_2_SHADING_RATE_IMAGE_BIT_NV`
/// - If the [subpass shading](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-subpassShading)
///   feature is not enabled, [`dst_stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI`
/// - If the [invocation mask image](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-invocationMask)
///   feature is not enabled, [`dst_stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_2_INVOCATION_MASK_BIT_HUAWEI`
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT`, [`dst_stage_mask`]
///   **must**  include `VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT`,
///   `VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR`,
///   `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, or `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_INDEX_READ_BIT`, [`dst_stage_mask`] **must**
///   include `VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT`, `VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT`,
///   `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, or `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT`, [`dst_stage_mask`]
///   **must**  include `VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT`,
///   `VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT`, `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, or
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT`, [`dst_stage_mask`]
///   **must**  include `VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT`,
///   `VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI`, `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, or
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_UNIFORM_READ_BIT`, [`dst_stage_mask`] **must**
///   include `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`, or one
///   of the `VK_PIPELINE_STAGE_*_SHADER_BIT` stages
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_SHADER_SAMPLED_READ_BIT`, [`dst_stage_mask`]
///   **must**  include `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`,
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`, or one of the `VK_PIPELINE_STAGE_*_SHADER_BIT` stages
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_SHADER_STORAGE_READ_BIT`, [`dst_stage_mask`]
///   **must**  include `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`,
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`, or one of the `VK_PIPELINE_STAGE_*_SHADER_BIT` stages
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT`, [`dst_stage_mask`]
///   **must**  include `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`,
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`, or one of the `VK_PIPELINE_STAGE_*_SHADER_BIT` stages
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_SHADER_READ_BIT`, [`dst_stage_mask`] **must**
///   include `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`,
///   `VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR`, or one of the
///   `VK_PIPELINE_STAGE_*_SHADER_BIT` stages
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_SHADER_WRITE_BIT`, [`dst_stage_mask`] **must**
///   include `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`, or one
///   of the `VK_PIPELINE_STAGE_*_SHADER_BIT` stages
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT`, [`dst_stage_mask`]
///   **must**  include
///   `VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT``VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, or
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT`, [`dst_stage_mask`]
///   **must**  include
///   `VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT``VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, or
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT`,
///   [`dst_stage_mask`] **must**  include `VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT`,
///   `VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT`, `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, or
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT`,
///   [`dst_stage_mask`] **must**  include `VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT`,
///   `VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT`, `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, or
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_TRANSFER_READ_BIT`, [`dst_stage_mask`] **must**
///   include `VK_PIPELINE_STAGE_2_COPY_BIT`, `VK_PIPELINE_STAGE_2_BLIT_BIT`,
///   `VK_PIPELINE_STAGE_2_RESOLVE_BIT`, `VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT`,
///   `VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR`, or
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_TRANSFER_WRITE_BIT`, [`dst_stage_mask`] **must**
///   include `VK_PIPELINE_STAGE_2_COPY_BIT`, `VK_PIPELINE_STAGE_2_BLIT_BIT`,
///   `VK_PIPELINE_STAGE_2_RESOLVE_BIT`, `VK_PIPELINE_STAGE_2_CLEAR_BIT`,
///   `VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT`,
///   `VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR`, or
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_HOST_READ_BIT`, [`dst_stage_mask`] **must**
///   include `VK_PIPELINE_STAGE_2_HOST_BIT`
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_HOST_WRITE_BIT`, [`dst_stage_mask`] **must**
///   include `VK_PIPELINE_STAGE_2_HOST_BIT`
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_CONDITIONAL_RENDERING_READ_BIT_EXT`,
///   [`dst_stage_mask`] **must**  include `VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT`,
///   `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, or `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_FRAGMENT_DENSITY_MAP_READ_BIT_EXT`,
///   [`dst_stage_mask`] **must**  include `VK_PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT`,
///   `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, or `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_TRANSFORM_FEEDBACK_WRITE_BIT_EXT`,
///   [`dst_stage_mask`] **must**  include `VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT`,
///   `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, or `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT`,
///   [`dst_stage_mask`] **must**  include `VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT`,
///   `VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT`, `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, or
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT`,
///   [`dst_stage_mask`] **must**  include `VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT`,
///   `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, or `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_SHADING_RATE_IMAGE_READ_BIT_NV`,
///   [`dst_stage_mask`] **must**  include `VK_PIPELINE_STAGE_2_SHADING_RATE_IMAGE_BIT_NV`,
///   `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, or `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_INVOCATION_MASK_READ_BIT_HUAWEI`,
///   [`dst_stage_mask`] **must**  include `VK_PIPELINE_STAGE_2_INVOCATION_MASK_BIT_HUAWEI`
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_COMMAND_PREPROCESS_READ_BIT_NV`,
///   [`dst_stage_mask`] **must**  include `VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_NV` or
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_COMMAND_PREPROCESS_WRITE_BIT_NV`,
///   [`dst_stage_mask`] **must**  include `VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_NV` or
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT`,
///   [`dst_stage_mask`] **must**  include
///   `VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT``VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, or
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_KHR`,
///   [`dst_stage_mask`] **must**  include
///   `VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR`,
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`, or one of the `VK_PIPELINE_STAGE_*_SHADER_BIT` stages
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_ACCELERATION_STRUCTURE_WRITE_BIT_KHR`,
///   [`dst_stage_mask`] **must**  include
///   `VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR` or
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`rayQuery`](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-rayQuery)
///   is not enabled and [`dst_access_mask`] includes
///   `VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_KHR`, [`dst_stage_mask`] **must**  not include
///   any of the `VK_PIPELINE_STAGE_*_SHADER_BIT` stages except
///   `VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR`
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_VIDEO_DECODE_READ_BIT_KHR`, [`dst_stage_mask`]
///   **must**  include `VK_PIPELINE_STAGE_2_VIDEO_DECODE_BIT_KHR`
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_VIDEO_DECODE_WRITE_BIT_KHR`, [`dst_stage_mask`]
///   **must**  include `VK_PIPELINE_STAGE_2_VIDEO_DECODE_BIT_KHR`
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_VIDEO_ENCODE_READ_BIT_KHR`, [`dst_stage_mask`]
///   **must**  include `VK_PIPELINE_STAGE_2_VIDEO_ENCODE_BIT_KHR`
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_VIDEO_ENCODE_WRITE_BIT_KHR`, [`dst_stage_mask`]
///   **must**  include `VK_PIPELINE_STAGE_2_VIDEO_ENCODE_BIT_KHR`
///
/// - `subresourceRange.baseMipLevel` **must**  be less than the `mipLevels` specified in
///   [`ImageCreateInfo`] when [`image`] was created
/// - If `subresourceRange.levelCount` is not [`REMAINING_MIP_LEVELS`],
///   `subresourceRange.baseMipLevel` +  `subresourceRange.levelCount` **must**  be less than or
///   equal to the `mipLevels` specified in [`ImageCreateInfo`] when [`image`] was created
/// - `subresourceRange.baseArrayLayer` **must**  be less than the `arrayLayers` specified in
///   [`ImageCreateInfo`] when [`image`] was created
/// - If `subresourceRange.layerCount` is not [`REMAINING_ARRAY_LAYERS`],
///   `subresourceRange.baseArrayLayer` +  `subresourceRange.layerCount` **must**  be less than or
///   equal to the `arrayLayers` specified in [`ImageCreateInfo`] when [`image`] was created
/// - If [`image`] is non-sparse then it  **must**  be bound completely and contiguously to a single
///   [`DeviceMemory`] object
/// - If [`src_queue_family_index`] and [`dst_queue_family_index`] define a [queue family ownership transfer](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#synchronization-queue-transfers)
///   or [`old_layout`] and [`new_layout`] define an [image layout transition](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#synchronization-image-layout-transitions),
///   and [`old_layout`] or [`new_layout`] is `VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL` then
///   [`image`] **must**  have been created with `VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT`
/// - If [`src_queue_family_index`] and [`dst_queue_family_index`] define a [queue family ownership transfer](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#synchronization-queue-transfers)
///   or [`old_layout`] and [`new_layout`] define an [image layout transition](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#synchronization-image-layout-transitions),
///   and [`old_layout`] or [`new_layout`] is `VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL`
///   then [`image`] **must**  have been created with `VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT`
/// - If [`src_queue_family_index`] and [`dst_queue_family_index`] define a [queue family ownership transfer](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#synchronization-queue-transfers)
///   or [`old_layout`] and [`new_layout`] define an [image layout transition](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#synchronization-image-layout-transitions),
///   and [`old_layout`] or [`new_layout`] is `VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL` then
///   [`image`] **must**  have been created with `VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT`
/// - If [`src_queue_family_index`] and [`dst_queue_family_index`] define a [queue family ownership transfer](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#synchronization-queue-transfers)
///   or [`old_layout`] and [`new_layout`] define an [image layout transition](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#synchronization-image-layout-transitions),
///   and [`old_layout`] or [`new_layout`] is `VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL` then
///   [`image`] **must**  have been created with `VK_IMAGE_USAGE_SAMPLED_BIT` or
///   `VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT`
/// - If [`src_queue_family_index`] and [`dst_queue_family_index`] define a [queue family ownership transfer](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#synchronization-queue-transfers)
///   or [`old_layout`] and [`new_layout`] define an [image layout transition](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#synchronization-image-layout-transitions),
///   and [`old_layout`] or [`new_layout`] is `VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL` then [`image`]
///   **must**  have been created with `VK_IMAGE_USAGE_TRANSFER_SRC_BIT`
/// - If [`src_queue_family_index`] and [`dst_queue_family_index`] define a [queue family ownership transfer](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#synchronization-queue-transfers)
///   or [`old_layout`] and [`new_layout`] define an [image layout transition](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#synchronization-image-layout-transitions),
///   and [`old_layout`] or [`new_layout`] is `VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL` then [`image`]
///   **must**  have been created with `VK_IMAGE_USAGE_TRANSFER_DST_BIT`
/// - If [`src_queue_family_index`] and [`dst_queue_family_index`] define a [queue family ownership transfer](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#synchronization-queue-transfers)
///   or [`old_layout`] and [`new_layout`] define an [image layout transition](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#synchronization-image-layout-transitions),
///   [`old_layout`] **must**  be `VK_IMAGE_LAYOUT_UNDEFINED` or the current layout of the image
///   subresources affected by the barrier
/// - If [`src_queue_family_index`] and [`dst_queue_family_index`] define a [queue family ownership transfer](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#synchronization-queue-transfers)
///   or [`old_layout`] and [`new_layout`] define an [image layout transition](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#synchronization-image-layout-transitions),
///   [`new_layout`] **must**  not be `VK_IMAGE_LAYOUT_UNDEFINED` or
///   `VK_IMAGE_LAYOUT_PREINITIALIZED`
/// - If [`src_queue_family_index`] and [`dst_queue_family_index`] define a [queue family ownership transfer](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#synchronization-queue-transfers)
///   or [`old_layout`] and [`new_layout`] define an [image layout transition](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#synchronization-image-layout-transitions),
///   and [`old_layout`] or [`new_layout`] is
///   `VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL` then [`image`] **must**  have
///   been created with `VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT`
/// - If [`src_queue_family_index`] and [`dst_queue_family_index`] define a [queue family ownership transfer](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#synchronization-queue-transfers)
///   or [`old_layout`] and [`new_layout`] define an [image layout transition](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#synchronization-image-layout-transitions),
///   and [`old_layout`] or [`new_layout`] is
///   `VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL` then [`image`] **must**  have
///   been created with `VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT`
/// - If [`src_queue_family_index`] and [`dst_queue_family_index`] define a [queue family ownership transfer](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#synchronization-queue-transfers)
///   or [`old_layout`] and [`new_layout`] define an [image layout transition](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#synchronization-image-layout-transitions),
///   and [`old_layout`] or [`new_layout`] is `VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL` then
///   [`image`] **must**  have been created with at least one of
///   `VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT`, `VK_IMAGE_USAGE_SAMPLED_BIT`, or
///   `VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT`
/// - If [`src_queue_family_index`] and [`dst_queue_family_index`] define a [queue family ownership transfer](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#synchronization-queue-transfers)
///   or [`old_layout`] and [`new_layout`] define an [image layout transition](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#synchronization-image-layout-transitions),
///   and [`old_layout`] or [`new_layout`] is `VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL` then
///   [`image`] **must**  have been created with `VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT` set
/// - If [`src_queue_family_index`] and [`dst_queue_family_index`] define a [queue family ownership transfer](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#synchronization-queue-transfers)
///   or [`old_layout`] and [`new_layout`] define an [image layout transition](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#synchronization-image-layout-transitions),
///   and [`old_layout`] or [`new_layout`] is `VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL` then
///   [`image`] **must**  have been created with at least one of
///   `VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT`, `VK_IMAGE_USAGE_SAMPLED_BIT`, or
///   `VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT`
/// - If [`src_queue_family_index`] and [`dst_queue_family_index`] define a [queue family ownership transfer](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#synchronization-queue-transfers)
///   or [`old_layout`] and [`new_layout`] define an [image layout transition](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#synchronization-image-layout-transitions),
///   and [`old_layout`] or [`new_layout`] is `VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL` then
///   [`image`] **must**  have been created with `VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT` set
/// - If [`src_queue_family_index`] and [`dst_queue_family_index`] define a [queue family ownership transfer](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#synchronization-queue-transfers)
///   or [`old_layout`] and [`new_layout`] define an [image layout transition](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#synchronization-image-layout-transitions),
///   and [`old_layout`] or [`new_layout`] is `VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL`, [`image`]
///   **must**  have been created with `VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT` or
///   `VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT`
/// - If [`src_queue_family_index`] and [`dst_queue_family_index`] define a [queue family ownership transfer](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#synchronization-queue-transfers)
///   or [`old_layout`] and [`new_layout`] define an [image layout transition](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#synchronization-image-layout-transitions),
///   and [`old_layout`] or [`new_layout`] is `VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL`, [`image`]
///   **must**  have been created with at least one of
///   `VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT`, `VK_IMAGE_USAGE_SAMPLED_BIT`, or
///   `VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT`
/// - If [`src_queue_family_index`] and [`dst_queue_family_index`] define a [queue family ownership transfer](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#synchronization-queue-transfers)
///   or [`old_layout`] and [`new_layout`] define an [image layout transition](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#synchronization-image-layout-transitions),
///   and [`old_layout`] or [`new_layout`] is
///   `VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR` then [`image`] **must**  have
///   been created with `VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR` set
/// - If [`image`] has a single-plane color format or is not *disjoint*, then the `aspectMask`
///   member of [`subresource_range`] **must**  be `VK_IMAGE_ASPECT_COLOR_BIT`
/// - If [`image`] has a multi-planar format and the image is *disjoint*, then the `aspectMask`
///   member of [`subresource_range`] **must**  include either at least one of
///   `VK_IMAGE_ASPECT_PLANE_0_BIT`, `VK_IMAGE_ASPECT_PLANE_1_BIT`, and
///   `VK_IMAGE_ASPECT_PLANE_2_BIT`; or  **must**  include `VK_IMAGE_ASPECT_COLOR_BIT`
/// - If [`image`] has a multi-planar format with only two planes, then the `aspectMask` member of
///   [`subresource_range`] **must**  not include `VK_IMAGE_ASPECT_PLANE_2_BIT`
/// - If [`image`] has a depth/stencil format with both depth and stencil and the [separateDepthStencilLayouts](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-separateDepthStencilLayouts)
///   feature is enabled, then the `aspectMask` member of [`subresource_range`] **must**  include
///   either or both `VK_IMAGE_ASPECT_DEPTH_BIT` and `VK_IMAGE_ASPECT_STENCIL_BIT`
/// - If [`image`] has a depth/stencil format with both depth and stencil and the [separateDepthStencilLayouts](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-separateDepthStencilLayouts)
///   feature is not enabled, then the `aspectMask` member of [`subresource_range`] **must**
///   include both `VK_IMAGE_ASPECT_DEPTH_BIT` and `VK_IMAGE_ASPECT_STENCIL_BIT`
/// -    If [`src_queue_family_index`] is not equal to [`dst_queue_family_index`], at least one  **must**  not be a special queue family reserved for external memory ownership transfers, as described in [[synchronization-queue-transfers]](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#synchronization-queue-transfers)
/// - If [`image`] was created with a sharing mode of `VK_SHARING_MODE_CONCURRENT`,
///   [`src_queue_family_index`] and [`dst_queue_family_index`] are not equal, and one of
///   [`src_queue_family_index`] and [`dst_queue_family_index`] is one of the special queue family
///   values reserved for external memory transfers, the other  **must**  be
///   [`QUEUE_FAMILY_IGNORED`]
/// -    If [`image`] was created with a sharing mode of `VK_SHARING_MODE_EXCLUSIVE`, and [`src_queue_family_index`] and [`dst_queue_family_index`] are not equal, [`src_queue_family_index`] and [`dst_queue_family_index`] **must**  both be valid queue families, or one of the special queue family values reserved for external memory transfers, as described in [[synchronization-queue-transfers]](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#synchronization-queue-transfers)
/// - If either [`src_stage_mask`] or [`dst_stage_mask`] includes `VK_PIPELINE_STAGE_2_HOST_BIT`,
///   [`src_queue_family_index`] and [`dst_queue_family_index`] **must**  be equal
/// -    If [`src_stage_mask`] includes `VK_PIPELINE_STAGE_2_HOST_BIT`, and [`src_queue_family_index`] and [`dst_queue_family_index`] define a [queue family ownership transfer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-queue-transfers) or [`old_layout`] and [`new_layout`] define an [image layout transition](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-image-layout-transitions), [`old_layout`] **must**  be one of `VK_IMAGE_LAYOUT_PREINITIALIZED`, `VK_IMAGE_LAYOUT_UNDEFINED`, or `VK_IMAGE_LAYOUT_GENERAL`
///
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be `VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2`
/// - [`p_next`] **must**  be `NULL` or a pointer to a valid instance of [`SampleLocationsInfoEXT`]
/// - The [`s_type`] value of each struct in the [`p_next`] chain  **must**  be unique
/// - [`src_stage_mask`] **must**  be a valid combination of [`PipelineStageFlagBits2`] values
/// - [`src_access_mask`] **must**  be a valid combination of [`AccessFlagBits2`] values
/// - [`dst_stage_mask`] **must**  be a valid combination of [`PipelineStageFlagBits2`] values
/// - [`dst_access_mask`] **must**  be a valid combination of [`AccessFlagBits2`] values
/// - [`old_layout`] **must**  be a valid [`ImageLayout`] value
/// - [`new_layout`] **must**  be a valid [`ImageLayout`] value
/// - [`image`] **must**  be a valid [`Image`] handle
/// - [`subresource_range`] **must**  be a valid [`ImageSubresourceRange`] structure
///# Related
/// - [`khr_synchronization2`]
/// - [`crate::vulkan1_3`]
/// - [`AccessFlags2`]
/// - [`DependencyInfo`]
/// - [`Image`]
/// - [`ImageLayout`]
/// - [`ImageSubresourceRange`]
/// - [`PipelineStageFlags2`]
/// - [`StructureType`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkImageMemoryBarrier2")]
#[derive(Debug, Clone, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[repr(C)]
pub struct ImageMemoryBarrier2<'lt> {
    ///Lifetime field
    pub _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] is the type of this structure.
    pub s_type: StructureType,
    ///[`p_next`] is `NULL` or a pointer to a structure extending this
    ///structure.
    pub p_next: *const BaseInStructure<'lt>,
    ///[`src_stage_mask`] is a [`PipelineStageFlags2`] mask of pipeline
    ///stages to be included in the [first synchronization scope](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-dependencies-scopes).
    pub src_stage_mask: PipelineStageFlags2,
    ///[`src_access_mask`] is a [`AccessFlags2`] mask of access flags to be
    ///included in the [first
    ///access scope](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-dependencies-access-scopes).
    pub src_access_mask: AccessFlags2,
    ///[`dst_stage_mask`] is a [`PipelineStageFlags2`] mask of pipeline
    ///stages to be included in the [second synchronization scope](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-dependencies-scopes).
    pub dst_stage_mask: PipelineStageFlags2,
    ///[`dst_access_mask`] is a [`AccessFlags2`] mask of access flags to be
    ///included in the [second
    ///access scope](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-dependencies-access-scopes).
    pub dst_access_mask: AccessFlags2,
    ///[`old_layout`] is the old layout in an
    ///[image layout transition](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-image-layout-transitions).
    pub old_layout: ImageLayout,
    ///[`new_layout`] is the new layout in an
    ///[image layout transition](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-image-layout-transitions).
    pub new_layout: ImageLayout,
    ///[`src_queue_family_index`] is the source queue family for a
    ///[queue family ownership transfer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-queue-transfers).
    pub src_queue_family_index: u32,
    ///[`dst_queue_family_index`] is the destination queue family for a
    ///[queue family ownership transfer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-queue-transfers).
    pub dst_queue_family_index: u32,
    ///[`image`] is a handle to the image affected by this barrier.
    pub image: Image,
    ///[`subresource_range`] describes the [image
    ///subresource range](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#resources-image-views) within [`image`] that is affected by this barrier.
    pub subresource_range: ImageSubresourceRange,
}
impl<'lt> Default for ImageMemoryBarrier2<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: StructureType::IMAGE_MEMORY_BARRIER2,
            p_next: std::ptr::null(),
            src_stage_mask: Default::default(),
            src_access_mask: Default::default(),
            dst_stage_mask: Default::default(),
            dst_access_mask: Default::default(),
            old_layout: Default::default(),
            new_layout: Default::default(),
            src_queue_family_index: 0,
            dst_queue_family_index: 0,
            image: Default::default(),
            subresource_range: Default::default(),
        }
    }
}
impl<'lt> ImageMemoryBarrier2<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *const BaseInStructure<'lt> {
        self.p_next
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *const BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn with_p_next_raw(mut self, value: *const BaseInStructure<'lt>) -> Self {
        self.p_next = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseInStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::src_stage_mask`]
    pub fn src_stage_mask(&self) -> PipelineStageFlags2 {
        self.src_stage_mask
    }
    ///Gets the value of [`Self::src_access_mask`]
    pub fn src_access_mask(&self) -> AccessFlags2 {
        self.src_access_mask
    }
    ///Gets the value of [`Self::dst_stage_mask`]
    pub fn dst_stage_mask(&self) -> PipelineStageFlags2 {
        self.dst_stage_mask
    }
    ///Gets the value of [`Self::dst_access_mask`]
    pub fn dst_access_mask(&self) -> AccessFlags2 {
        self.dst_access_mask
    }
    ///Gets the value of [`Self::old_layout`]
    pub fn old_layout(&self) -> ImageLayout {
        self.old_layout
    }
    ///Gets the value of [`Self::new_layout`]
    pub fn new_layout(&self) -> ImageLayout {
        self.new_layout
    }
    ///Gets the value of [`Self::src_queue_family_index`]
    pub fn src_queue_family_index(&self) -> u32 {
        self.src_queue_family_index
    }
    ///Gets the value of [`Self::dst_queue_family_index`]
    pub fn dst_queue_family_index(&self) -> u32 {
        self.dst_queue_family_index
    }
    ///Gets the value of [`Self::image`]
    pub fn image(&self) -> Image {
        self.image
    }
    ///Gets the value of [`Self::subresource_range`]
    pub fn subresource_range(&self) -> ImageSubresourceRange {
        self.subresource_range
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::src_stage_mask`]
    pub fn src_stage_mask_mut(&mut self) -> &mut PipelineStageFlags2 {
        &mut self.src_stage_mask
    }
    ///Gets a mutable reference to the value of [`Self::src_access_mask`]
    pub fn src_access_mask_mut(&mut self) -> &mut AccessFlags2 {
        &mut self.src_access_mask
    }
    ///Gets a mutable reference to the value of [`Self::dst_stage_mask`]
    pub fn dst_stage_mask_mut(&mut self) -> &mut PipelineStageFlags2 {
        &mut self.dst_stage_mask
    }
    ///Gets a mutable reference to the value of [`Self::dst_access_mask`]
    pub fn dst_access_mask_mut(&mut self) -> &mut AccessFlags2 {
        &mut self.dst_access_mask
    }
    ///Gets a mutable reference to the value of [`Self::old_layout`]
    pub fn old_layout_mut(&mut self) -> &mut ImageLayout {
        &mut self.old_layout
    }
    ///Gets a mutable reference to the value of [`Self::new_layout`]
    pub fn new_layout_mut(&mut self) -> &mut ImageLayout {
        &mut self.new_layout
    }
    ///Gets a mutable reference to the value of [`Self::src_queue_family_index`]
    pub fn src_queue_family_index_mut(&mut self) -> &mut u32 {
        &mut self.src_queue_family_index
    }
    ///Gets a mutable reference to the value of [`Self::dst_queue_family_index`]
    pub fn dst_queue_family_index_mut(&mut self) -> &mut u32 {
        &mut self.dst_queue_family_index
    }
    ///Gets a mutable reference to the value of [`Self::image`]
    pub fn image_mut(&mut self) -> &mut Image {
        &mut self.image
    }
    ///Gets a mutable reference to the value of [`Self::subresource_range`]
    pub fn subresource_range_mut(&mut self) -> &mut ImageSubresourceRange {
        &mut self.subresource_range
    }
    ///Sets the value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the value of [`Self::src_stage_mask`]
    pub fn set_src_stage_mask(&mut self, value: crate::vulkan1_3::PipelineStageFlags2) -> &mut Self {
        self.src_stage_mask = value;
        self
    }
    ///Sets the value of [`Self::src_access_mask`]
    pub fn set_src_access_mask(&mut self, value: crate::vulkan1_3::AccessFlags2) -> &mut Self {
        self.src_access_mask = value;
        self
    }
    ///Sets the value of [`Self::dst_stage_mask`]
    pub fn set_dst_stage_mask(&mut self, value: crate::vulkan1_3::PipelineStageFlags2) -> &mut Self {
        self.dst_stage_mask = value;
        self
    }
    ///Sets the value of [`Self::dst_access_mask`]
    pub fn set_dst_access_mask(&mut self, value: crate::vulkan1_3::AccessFlags2) -> &mut Self {
        self.dst_access_mask = value;
        self
    }
    ///Sets the value of [`Self::old_layout`]
    pub fn set_old_layout(&mut self, value: crate::vulkan1_0::ImageLayout) -> &mut Self {
        self.old_layout = value;
        self
    }
    ///Sets the value of [`Self::new_layout`]
    pub fn set_new_layout(&mut self, value: crate::vulkan1_0::ImageLayout) -> &mut Self {
        self.new_layout = value;
        self
    }
    ///Sets the value of [`Self::src_queue_family_index`]
    pub fn set_src_queue_family_index(&mut self, value: u32) -> &mut Self {
        self.src_queue_family_index = value;
        self
    }
    ///Sets the value of [`Self::dst_queue_family_index`]
    pub fn set_dst_queue_family_index(&mut self, value: u32) -> &mut Self {
        self.dst_queue_family_index = value;
        self
    }
    ///Sets the value of [`Self::image`]
    pub fn set_image(&mut self, value: crate::vulkan1_0::Image) -> &mut Self {
        self.image = value;
        self
    }
    ///Sets the value of [`Self::subresource_range`]
    pub fn set_subresource_range(&mut self, value: crate::vulkan1_0::ImageSubresourceRange) -> &mut Self {
        self.subresource_range = value;
        self
    }
    ///Sets the value of [`Self::s_type`]
    pub fn with_s_type(mut self, value: crate::vulkan1_0::StructureType) -> Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn with_p_next(mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the value of [`Self::src_stage_mask`]
    pub fn with_src_stage_mask(mut self, value: crate::vulkan1_3::PipelineStageFlags2) -> Self {
        self.src_stage_mask = value;
        self
    }
    ///Sets the value of [`Self::src_access_mask`]
    pub fn with_src_access_mask(mut self, value: crate::vulkan1_3::AccessFlags2) -> Self {
        self.src_access_mask = value;
        self
    }
    ///Sets the value of [`Self::dst_stage_mask`]
    pub fn with_dst_stage_mask(mut self, value: crate::vulkan1_3::PipelineStageFlags2) -> Self {
        self.dst_stage_mask = value;
        self
    }
    ///Sets the value of [`Self::dst_access_mask`]
    pub fn with_dst_access_mask(mut self, value: crate::vulkan1_3::AccessFlags2) -> Self {
        self.dst_access_mask = value;
        self
    }
    ///Sets the value of [`Self::old_layout`]
    pub fn with_old_layout(mut self, value: crate::vulkan1_0::ImageLayout) -> Self {
        self.old_layout = value;
        self
    }
    ///Sets the value of [`Self::new_layout`]
    pub fn with_new_layout(mut self, value: crate::vulkan1_0::ImageLayout) -> Self {
        self.new_layout = value;
        self
    }
    ///Sets the value of [`Self::src_queue_family_index`]
    pub fn with_src_queue_family_index(mut self, value: u32) -> Self {
        self.src_queue_family_index = value;
        self
    }
    ///Sets the value of [`Self::dst_queue_family_index`]
    pub fn with_dst_queue_family_index(mut self, value: u32) -> Self {
        self.dst_queue_family_index = value;
        self
    }
    ///Sets the value of [`Self::image`]
    pub fn with_image(mut self, value: crate::vulkan1_0::Image) -> Self {
        self.image = value;
        self
    }
    ///Sets the value of [`Self::subresource_range`]
    pub fn with_subresource_range(mut self, value: crate::vulkan1_0::ImageSubresourceRange) -> Self {
        self.subresource_range = value;
        self
    }
}
#[cfg(feature = "VK_EXT_sample_locations")]
unsafe impl<'this: 'extender + 'other, 'extender: 'other, 'other>
    crate::Chain<'other, SampleLocationsInfoEXT<'extender>> for ImageMemoryBarrier2<'this>
{
    type Out = ImageMemoryBarrier2<'other>;
    #[must_use]
    #[inline]
    fn chain(mut self, new: &'other mut SampleLocationsInfoEXT<'extender>) -> Self::Out {
        unsafe {
            crate::chaining::insert_ptr_in_chain(
                &mut self as *mut Self as *mut BaseOutStructure<'other>,
                new as *mut SampleLocationsInfoEXT<'extender> as *mut BaseOutStructure<'other>,
            );
            std::mem::transmute(self)
        }
    }
}
///[VkBufferMemoryBarrier2](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferMemoryBarrier2.html) - Structure specifying a buffer memory barrier
///# C Specifications
///The [`BufferMemoryBarrier2`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_3
///typedef struct VkBufferMemoryBarrier2 {
///    VkStructureType          sType;
///    const void*              pNext;
///    VkPipelineStageFlags2    srcStageMask;
///    VkAccessFlags2           srcAccessMask;
///    VkPipelineStageFlags2    dstStageMask;
///    VkAccessFlags2           dstAccessMask;
///    uint32_t                 srcQueueFamilyIndex;
///    uint32_t                 dstQueueFamilyIndex;
///    VkBuffer                 buffer;
///    VkDeviceSize             offset;
///    VkDeviceSize             size;
///} VkBufferMemoryBarrier2;
///```
///or the equivalent
///```c
///// Provided by VK_KHR_synchronization2
///typedef VkBufferMemoryBarrier2 VkBufferMemoryBarrier2KHR;
///```
///# Members
/// - [`s_type`] is the type of this structure.
/// - [`p_next`] is `NULL` or a pointer to a structure extending this structure.
/// - [`src_stage_mask`] is a [`PipelineStageFlags2`] mask of pipeline stages to be included in the [first synchronization scope](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-dependencies-scopes).
/// - [`src_access_mask`] is a [`AccessFlags2`] mask of access flags to be included in the [first access scope](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-dependencies-access-scopes).
/// - [`dst_stage_mask`] is a [`PipelineStageFlags2`] mask of pipeline stages to be included in the [second synchronization scope](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-dependencies-scopes).
/// - [`dst_access_mask`] is a [`AccessFlags2`] mask of access flags to be included in the [second access scope](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-dependencies-access-scopes).
/// - [`src_queue_family_index`] is the source queue family for a [queue family ownership transfer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-queue-transfers).
/// - [`dst_queue_family_index`] is the destination queue family for a [queue family ownership transfer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-queue-transfers).
/// - [`buffer`] is a handle to the buffer whose backing memory is affected by the barrier.
/// - [`offset`] is an offset in bytes into the backing memory for [`buffer`]; this is relative to
///   the base offset as bound to the buffer (see [`bind_buffer_memory`]).
/// - [`size`] is a size in bytes of the affected area of backing memory for [`buffer`], or
///   [`WHOLE_SIZE`] to use the range from [`offset`] to the end of the buffer.
///# Description
///This structure defines a [memory
///dependency](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-dependencies-memory) limited to a range of a buffer, and  **can**  define a
///[queue family transfer operation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-queue-transfers) for
///that range.The first [synchronization scope](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-dependencies-scopes) and
///[access scope](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-dependencies-access-scopes) described by
///this structure include only operations and memory accesses specified by
///[`src_stage_mask`] and [`src_access_mask`].The second [synchronization scope](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-dependencies-scopes)
///and [access scope](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-dependencies-access-scopes) described
///by this structure include only operations and memory accesses specified by
///[`dst_stage_mask`] and [`dst_access_mask`].Both [access scopes](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-dependencies-access-scopes) are
///limited to only memory accesses to [`buffer`] in the range defined by
///[`offset`] and [`size`].If [`buffer`] was created with `VK_SHARING_MODE_EXCLUSIVE`, and
///[`src_queue_family_index`] is not equal to [`dst_queue_family_index`], this
///memory barrier defines a [queue family
///transfer operation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-queue-transfers).
///When executed on a queue in the family identified by
///[`src_queue_family_index`], this barrier defines a
///[queue family release operation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-queue-transfers-release)
///for the specified buffer range, and the second synchronization and access
///scopes do not synchronize operations on that queue.
///When executed on a queue in the family identified by
///[`dst_queue_family_index`], this barrier defines a
///[queue family acquire operation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-queue-transfers-acquire)
///for the specified buffer range, and the first synchronization and access
///scopes do not synchronize operations on that queue.A [queue family transfer operation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-queue-transfers) is
///also defined if the values are not equal, and either is one of the special
///queue family values reserved for external memory ownership transfers, as
///described in [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-queue-transfers](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-queue-transfers).
///A [queue family release
///operation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-queue-transfers-release) is defined when [`dst_queue_family_index`] is one of those
///values, and a [queue family
///acquire operation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-queue-transfers-acquire) is defined when [`src_queue_family_index`] is one of
///those values.
///## Valid Usage
/// - If the [geometry shaders](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-geometryShader)
///   feature is not enabled, [`src_stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT`
/// - If the [tessellation shaders](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-tessellationShader)
///   feature is not enabled, [`src_stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT` or
///   `VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT`
/// - If the [conditional rendering](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-conditionalRendering)
///   feature is not enabled, [`src_stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT`
/// - If the [fragment density map](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-fragmentDensityMap)
///   feature is not enabled, [`src_stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT`
/// - If the [transform feedback](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-transformFeedback)
///   feature is not enabled, [`src_stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT`
/// - If the [mesh shaders](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-meshShader)
///   feature is not enabled, [`src_stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_NV`
/// - If the [task shaders](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-taskShader)
///   feature is not enabled, [`src_stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_NV`
/// - If the [shading rate image](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-shadingRateImage)
///   feature is not enabled, [`src_stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_2_SHADING_RATE_IMAGE_BIT_NV`
/// - If the [subpass shading](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-subpassShading)
///   feature is not enabled, [`src_stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI`
/// - If the [invocation mask image](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-invocationMask)
///   feature is not enabled, [`src_stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_2_INVOCATION_MASK_BIT_HUAWEI`
/// - If [`src_access_mask`] includes `VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT`, [`src_stage_mask`]
///   **must**  include `VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT`,
///   `VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR`,
///   `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, or `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`src_access_mask`] includes `VK_ACCESS_2_INDEX_READ_BIT`, [`src_stage_mask`] **must**
///   include `VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT`, `VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT`,
///   `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, or `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`src_access_mask`] includes `VK_ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT`, [`src_stage_mask`]
///   **must**  include `VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT`,
///   `VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT`, `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, or
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`src_access_mask`] includes `VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT`, [`src_stage_mask`]
///   **must**  include `VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT`,
///   `VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI`, `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, or
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`src_access_mask`] includes `VK_ACCESS_2_UNIFORM_READ_BIT`, [`src_stage_mask`] **must**
///   include `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`, or one
///   of the `VK_PIPELINE_STAGE_*_SHADER_BIT` stages
/// - If [`src_access_mask`] includes `VK_ACCESS_2_SHADER_SAMPLED_READ_BIT`, [`src_stage_mask`]
///   **must**  include `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`,
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`, or one of the `VK_PIPELINE_STAGE_*_SHADER_BIT` stages
/// - If [`src_access_mask`] includes `VK_ACCESS_2_SHADER_STORAGE_READ_BIT`, [`src_stage_mask`]
///   **must**  include `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`,
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`, or one of the `VK_PIPELINE_STAGE_*_SHADER_BIT` stages
/// - If [`src_access_mask`] includes `VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT`, [`src_stage_mask`]
///   **must**  include `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`,
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`, or one of the `VK_PIPELINE_STAGE_*_SHADER_BIT` stages
/// - If [`src_access_mask`] includes `VK_ACCESS_2_SHADER_READ_BIT`, [`src_stage_mask`] **must**
///   include `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`,
///   `VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR`, or one of the
///   `VK_PIPELINE_STAGE_*_SHADER_BIT` stages
/// - If [`src_access_mask`] includes `VK_ACCESS_2_SHADER_WRITE_BIT`, [`src_stage_mask`] **must**
///   include `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`, or one
///   of the `VK_PIPELINE_STAGE_*_SHADER_BIT` stages
/// - If [`src_access_mask`] includes `VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT`, [`src_stage_mask`]
///   **must**  include
///   `VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT``VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, or
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`src_access_mask`] includes `VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT`, [`src_stage_mask`]
///   **must**  include
///   `VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT``VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, or
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`src_access_mask`] includes `VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT`,
///   [`src_stage_mask`] **must**  include `VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT`,
///   `VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT`, `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, or
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`src_access_mask`] includes `VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT`,
///   [`src_stage_mask`] **must**  include `VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT`,
///   `VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT`, `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, or
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`src_access_mask`] includes `VK_ACCESS_2_TRANSFER_READ_BIT`, [`src_stage_mask`] **must**
///   include `VK_PIPELINE_STAGE_2_COPY_BIT`, `VK_PIPELINE_STAGE_2_BLIT_BIT`,
///   `VK_PIPELINE_STAGE_2_RESOLVE_BIT`, `VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT`,
///   `VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR`, or
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`src_access_mask`] includes `VK_ACCESS_2_TRANSFER_WRITE_BIT`, [`src_stage_mask`] **must**
///   include `VK_PIPELINE_STAGE_2_COPY_BIT`, `VK_PIPELINE_STAGE_2_BLIT_BIT`,
///   `VK_PIPELINE_STAGE_2_RESOLVE_BIT`, `VK_PIPELINE_STAGE_2_CLEAR_BIT`,
///   `VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT`,
///   `VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR`, or
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`src_access_mask`] includes `VK_ACCESS_2_HOST_READ_BIT`, [`src_stage_mask`] **must**
///   include `VK_PIPELINE_STAGE_2_HOST_BIT`
/// - If [`src_access_mask`] includes `VK_ACCESS_2_HOST_WRITE_BIT`, [`src_stage_mask`] **must**
///   include `VK_PIPELINE_STAGE_2_HOST_BIT`
/// - If [`src_access_mask`] includes `VK_ACCESS_2_CONDITIONAL_RENDERING_READ_BIT_EXT`,
///   [`src_stage_mask`] **must**  include `VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT`,
///   `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, or `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`src_access_mask`] includes `VK_ACCESS_2_FRAGMENT_DENSITY_MAP_READ_BIT_EXT`,
///   [`src_stage_mask`] **must**  include `VK_PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT`,
///   `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, or `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`src_access_mask`] includes `VK_ACCESS_2_TRANSFORM_FEEDBACK_WRITE_BIT_EXT`,
///   [`src_stage_mask`] **must**  include `VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT`,
///   `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, or `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`src_access_mask`] includes `VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT`,
///   [`src_stage_mask`] **must**  include `VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT`,
///   `VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT`, `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, or
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`src_access_mask`] includes `VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT`,
///   [`src_stage_mask`] **must**  include `VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT`,
///   `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, or `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`src_access_mask`] includes `VK_ACCESS_2_SHADING_RATE_IMAGE_READ_BIT_NV`,
///   [`src_stage_mask`] **must**  include `VK_PIPELINE_STAGE_2_SHADING_RATE_IMAGE_BIT_NV`,
///   `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, or `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`src_access_mask`] includes `VK_ACCESS_2_INVOCATION_MASK_READ_BIT_HUAWEI`,
///   [`src_stage_mask`] **must**  include `VK_PIPELINE_STAGE_2_INVOCATION_MASK_BIT_HUAWEI`
/// - If [`src_access_mask`] includes `VK_ACCESS_2_COMMAND_PREPROCESS_READ_BIT_NV`,
///   [`src_stage_mask`] **must**  include `VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_NV` or
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`src_access_mask`] includes `VK_ACCESS_2_COMMAND_PREPROCESS_WRITE_BIT_NV`,
///   [`src_stage_mask`] **must**  include `VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_NV` or
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`src_access_mask`] includes `VK_ACCESS_2_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT`,
///   [`src_stage_mask`] **must**  include
///   `VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT``VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, or
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`src_access_mask`] includes `VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_KHR`,
///   [`src_stage_mask`] **must**  include
///   `VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR`,
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`, or one of the `VK_PIPELINE_STAGE_*_SHADER_BIT` stages
/// - If [`src_access_mask`] includes `VK_ACCESS_2_ACCELERATION_STRUCTURE_WRITE_BIT_KHR`,
///   [`src_stage_mask`] **must**  include
///   `VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR` or
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`rayQuery`](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-rayQuery)
///   is not enabled and [`src_access_mask`] includes
///   `VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_KHR`, [`src_stage_mask`] **must**  not include
///   any of the `VK_PIPELINE_STAGE_*_SHADER_BIT` stages except
///   `VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR`
/// - If [`src_access_mask`] includes `VK_ACCESS_2_VIDEO_DECODE_READ_BIT_KHR`, [`src_stage_mask`]
///   **must**  include `VK_PIPELINE_STAGE_2_VIDEO_DECODE_BIT_KHR`
/// - If [`src_access_mask`] includes `VK_ACCESS_2_VIDEO_DECODE_WRITE_BIT_KHR`, [`src_stage_mask`]
///   **must**  include `VK_PIPELINE_STAGE_2_VIDEO_DECODE_BIT_KHR`
/// - If [`src_access_mask`] includes `VK_ACCESS_2_VIDEO_ENCODE_READ_BIT_KHR`, [`src_stage_mask`]
///   **must**  include `VK_PIPELINE_STAGE_2_VIDEO_ENCODE_BIT_KHR`
/// - If [`src_access_mask`] includes `VK_ACCESS_2_VIDEO_ENCODE_WRITE_BIT_KHR`, [`src_stage_mask`]
///   **must**  include `VK_PIPELINE_STAGE_2_VIDEO_ENCODE_BIT_KHR`
///
/// - If the [geometry shaders](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-geometryShader)
///   feature is not enabled, [`dst_stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT`
/// - If the [tessellation shaders](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-tessellationShader)
///   feature is not enabled, [`dst_stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT` or
///   `VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT`
/// - If the [conditional rendering](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-conditionalRendering)
///   feature is not enabled, [`dst_stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT`
/// - If the [fragment density map](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-fragmentDensityMap)
///   feature is not enabled, [`dst_stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT`
/// - If the [transform feedback](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-transformFeedback)
///   feature is not enabled, [`dst_stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT`
/// - If the [mesh shaders](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-meshShader)
///   feature is not enabled, [`dst_stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_NV`
/// - If the [task shaders](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-taskShader)
///   feature is not enabled, [`dst_stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_NV`
/// - If the [shading rate image](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-shadingRateImage)
///   feature is not enabled, [`dst_stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_2_SHADING_RATE_IMAGE_BIT_NV`
/// - If the [subpass shading](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-subpassShading)
///   feature is not enabled, [`dst_stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI`
/// - If the [invocation mask image](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-invocationMask)
///   feature is not enabled, [`dst_stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_2_INVOCATION_MASK_BIT_HUAWEI`
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT`, [`dst_stage_mask`]
///   **must**  include `VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT`,
///   `VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR`,
///   `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, or `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_INDEX_READ_BIT`, [`dst_stage_mask`] **must**
///   include `VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT`, `VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT`,
///   `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, or `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT`, [`dst_stage_mask`]
///   **must**  include `VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT`,
///   `VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT`, `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, or
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT`, [`dst_stage_mask`]
///   **must**  include `VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT`,
///   `VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI`, `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, or
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_UNIFORM_READ_BIT`, [`dst_stage_mask`] **must**
///   include `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`, or one
///   of the `VK_PIPELINE_STAGE_*_SHADER_BIT` stages
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_SHADER_SAMPLED_READ_BIT`, [`dst_stage_mask`]
///   **must**  include `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`,
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`, or one of the `VK_PIPELINE_STAGE_*_SHADER_BIT` stages
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_SHADER_STORAGE_READ_BIT`, [`dst_stage_mask`]
///   **must**  include `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`,
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`, or one of the `VK_PIPELINE_STAGE_*_SHADER_BIT` stages
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT`, [`dst_stage_mask`]
///   **must**  include `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`,
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`, or one of the `VK_PIPELINE_STAGE_*_SHADER_BIT` stages
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_SHADER_READ_BIT`, [`dst_stage_mask`] **must**
///   include `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`,
///   `VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR`, or one of the
///   `VK_PIPELINE_STAGE_*_SHADER_BIT` stages
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_SHADER_WRITE_BIT`, [`dst_stage_mask`] **must**
///   include `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`, or one
///   of the `VK_PIPELINE_STAGE_*_SHADER_BIT` stages
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT`, [`dst_stage_mask`]
///   **must**  include
///   `VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT``VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, or
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT`, [`dst_stage_mask`]
///   **must**  include
///   `VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT``VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, or
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT`,
///   [`dst_stage_mask`] **must**  include `VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT`,
///   `VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT`, `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, or
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT`,
///   [`dst_stage_mask`] **must**  include `VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT`,
///   `VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT`, `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, or
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_TRANSFER_READ_BIT`, [`dst_stage_mask`] **must**
///   include `VK_PIPELINE_STAGE_2_COPY_BIT`, `VK_PIPELINE_STAGE_2_BLIT_BIT`,
///   `VK_PIPELINE_STAGE_2_RESOLVE_BIT`, `VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT`,
///   `VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR`, or
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_TRANSFER_WRITE_BIT`, [`dst_stage_mask`] **must**
///   include `VK_PIPELINE_STAGE_2_COPY_BIT`, `VK_PIPELINE_STAGE_2_BLIT_BIT`,
///   `VK_PIPELINE_STAGE_2_RESOLVE_BIT`, `VK_PIPELINE_STAGE_2_CLEAR_BIT`,
///   `VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT`,
///   `VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR`, or
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_HOST_READ_BIT`, [`dst_stage_mask`] **must**
///   include `VK_PIPELINE_STAGE_2_HOST_BIT`
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_HOST_WRITE_BIT`, [`dst_stage_mask`] **must**
///   include `VK_PIPELINE_STAGE_2_HOST_BIT`
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_CONDITIONAL_RENDERING_READ_BIT_EXT`,
///   [`dst_stage_mask`] **must**  include `VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT`,
///   `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, or `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_FRAGMENT_DENSITY_MAP_READ_BIT_EXT`,
///   [`dst_stage_mask`] **must**  include `VK_PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT`,
///   `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, or `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_TRANSFORM_FEEDBACK_WRITE_BIT_EXT`,
///   [`dst_stage_mask`] **must**  include `VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT`,
///   `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, or `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT`,
///   [`dst_stage_mask`] **must**  include `VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT`,
///   `VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT`, `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, or
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT`,
///   [`dst_stage_mask`] **must**  include `VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT`,
///   `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, or `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_SHADING_RATE_IMAGE_READ_BIT_NV`,
///   [`dst_stage_mask`] **must**  include `VK_PIPELINE_STAGE_2_SHADING_RATE_IMAGE_BIT_NV`,
///   `VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, or `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_INVOCATION_MASK_READ_BIT_HUAWEI`,
///   [`dst_stage_mask`] **must**  include `VK_PIPELINE_STAGE_2_INVOCATION_MASK_BIT_HUAWEI`
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_COMMAND_PREPROCESS_READ_BIT_NV`,
///   [`dst_stage_mask`] **must**  include `VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_NV` or
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_COMMAND_PREPROCESS_WRITE_BIT_NV`,
///   [`dst_stage_mask`] **must**  include `VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_NV` or
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT`,
///   [`dst_stage_mask`] **must**  include
///   `VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT``VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT`, or
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_KHR`,
///   [`dst_stage_mask`] **must**  include
///   `VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR`,
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`, or one of the `VK_PIPELINE_STAGE_*_SHADER_BIT` stages
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_ACCELERATION_STRUCTURE_WRITE_BIT_KHR`,
///   [`dst_stage_mask`] **must**  include
///   `VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR` or
///   `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT`
/// - If [`rayQuery`](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-rayQuery)
///   is not enabled and [`dst_access_mask`] includes
///   `VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_KHR`, [`dst_stage_mask`] **must**  not include
///   any of the `VK_PIPELINE_STAGE_*_SHADER_BIT` stages except
///   `VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR`
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_VIDEO_DECODE_READ_BIT_KHR`, [`dst_stage_mask`]
///   **must**  include `VK_PIPELINE_STAGE_2_VIDEO_DECODE_BIT_KHR`
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_VIDEO_DECODE_WRITE_BIT_KHR`, [`dst_stage_mask`]
///   **must**  include `VK_PIPELINE_STAGE_2_VIDEO_DECODE_BIT_KHR`
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_VIDEO_ENCODE_READ_BIT_KHR`, [`dst_stage_mask`]
///   **must**  include `VK_PIPELINE_STAGE_2_VIDEO_ENCODE_BIT_KHR`
/// - If [`dst_access_mask`] includes `VK_ACCESS_2_VIDEO_ENCODE_WRITE_BIT_KHR`, [`dst_stage_mask`]
///   **must**  include `VK_PIPELINE_STAGE_2_VIDEO_ENCODE_BIT_KHR`
///
/// - [`offset`] **must**  be less than the size of [`buffer`]
/// - If [`size`] is not equal to [`WHOLE_SIZE`], [`size`] **must**  be greater than `0`
/// - If [`size`] is not equal to [`WHOLE_SIZE`], [`size`] **must**  be less than or equal to than
///   the size of [`buffer`] minus [`offset`]
/// - If [`buffer`] is non-sparse then it  **must**  be bound completely and contiguously to a
///   single [`DeviceMemory`] object
/// -    If [`src_queue_family_index`] is not equal to [`dst_queue_family_index`], at least one  **must**  not be a special queue family reserved for external memory ownership transfers, as described in [[synchronization-queue-transfers]](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#synchronization-queue-transfers)
/// - If [`buffer`] was created with a sharing mode of `VK_SHARING_MODE_CONCURRENT`,
///   [`src_queue_family_index`] and [`dst_queue_family_index`] are not equal, and one of
///   [`src_queue_family_index`] and [`dst_queue_family_index`] is one of the special queue family
///   values reserved for external memory transfers, the other  **must**  be
///   [`QUEUE_FAMILY_IGNORED`]
/// -    If [`buffer`] was created with a sharing mode of `VK_SHARING_MODE_EXCLUSIVE`, and [`src_queue_family_index`] and [`dst_queue_family_index`] are not equal, [`src_queue_family_index`] and [`dst_queue_family_index`] **must**  both be valid queue families, or one of the special queue family values reserved for external memory transfers, as described in [[synchronization-queue-transfers]](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#synchronization-queue-transfers)
/// - If either [`src_stage_mask`] or [`dst_stage_mask`] includes `VK_PIPELINE_STAGE_2_HOST_BIT`,
///   [`src_queue_family_index`] and [`dst_queue_family_index`] **must**  be equal
///
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be `VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2`
/// - [`p_next`] **must**  be `NULL`
/// - [`src_stage_mask`] **must**  be a valid combination of [`PipelineStageFlagBits2`] values
/// - [`src_access_mask`] **must**  be a valid combination of [`AccessFlagBits2`] values
/// - [`dst_stage_mask`] **must**  be a valid combination of [`PipelineStageFlagBits2`] values
/// - [`dst_access_mask`] **must**  be a valid combination of [`AccessFlagBits2`] values
/// - [`buffer`] **must**  be a valid [`Buffer`] handle
///# Related
/// - [`khr_synchronization2`]
/// - [`crate::vulkan1_3`]
/// - [`AccessFlags2`]
/// - [`Buffer`]
/// - [`DependencyInfo`]
/// - [`DeviceSize`]
/// - [`PipelineStageFlags2`]
/// - [`StructureType`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkBufferMemoryBarrier2")]
#[derive(Debug, Clone, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[repr(C)]
pub struct BufferMemoryBarrier2<'lt> {
    ///Lifetime field
    pub _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] is the type of this structure.
    pub s_type: StructureType,
    ///[`p_next`] is `NULL` or a pointer to a structure extending this
    ///structure.
    pub p_next: *const BaseInStructure<'lt>,
    ///[`src_stage_mask`] is a [`PipelineStageFlags2`] mask of pipeline
    ///stages to be included in the [first synchronization scope](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-dependencies-scopes).
    pub src_stage_mask: PipelineStageFlags2,
    ///[`src_access_mask`] is a [`AccessFlags2`] mask of access flags to be
    ///included in the [first
    ///access scope](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-dependencies-access-scopes).
    pub src_access_mask: AccessFlags2,
    ///[`dst_stage_mask`] is a [`PipelineStageFlags2`] mask of pipeline
    ///stages to be included in the [second synchronization scope](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-dependencies-scopes).
    pub dst_stage_mask: PipelineStageFlags2,
    ///[`dst_access_mask`] is a [`AccessFlags2`] mask of access flags to be
    ///included in the [second
    ///access scope](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-dependencies-access-scopes).
    pub dst_access_mask: AccessFlags2,
    ///[`src_queue_family_index`] is the source queue family for a
    ///[queue family ownership transfer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-queue-transfers).
    pub src_queue_family_index: u32,
    ///[`dst_queue_family_index`] is the destination queue family for a
    ///[queue family ownership transfer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-queue-transfers).
    pub dst_queue_family_index: u32,
    ///[`buffer`] is a handle to the buffer whose backing memory is affected
    ///by the barrier.
    pub buffer: Buffer,
    ///[`offset`] is an offset in bytes into the backing memory for
    ///[`buffer`]; this is relative to the base offset as bound to the buffer
    ///(see [`bind_buffer_memory`]).
    pub offset: DeviceSize,
    ///[`size`] is a size in bytes of the affected area of backing memory for
    ///[`buffer`], or [`WHOLE_SIZE`] to use the range from [`offset`]
    ///to the end of the buffer.
    pub size: DeviceSize,
}
impl<'lt> Default for BufferMemoryBarrier2<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: StructureType::BUFFER_MEMORY_BARRIER2,
            p_next: std::ptr::null(),
            src_stage_mask: Default::default(),
            src_access_mask: Default::default(),
            dst_stage_mask: Default::default(),
            dst_access_mask: Default::default(),
            src_queue_family_index: 0,
            dst_queue_family_index: 0,
            buffer: Default::default(),
            offset: Default::default(),
            size: Default::default(),
        }
    }
}
impl<'lt> BufferMemoryBarrier2<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *const BaseInStructure<'lt> {
        self.p_next
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *const BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn with_p_next_raw(mut self, value: *const BaseInStructure<'lt>) -> Self {
        self.p_next = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseInStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::src_stage_mask`]
    pub fn src_stage_mask(&self) -> PipelineStageFlags2 {
        self.src_stage_mask
    }
    ///Gets the value of [`Self::src_access_mask`]
    pub fn src_access_mask(&self) -> AccessFlags2 {
        self.src_access_mask
    }
    ///Gets the value of [`Self::dst_stage_mask`]
    pub fn dst_stage_mask(&self) -> PipelineStageFlags2 {
        self.dst_stage_mask
    }
    ///Gets the value of [`Self::dst_access_mask`]
    pub fn dst_access_mask(&self) -> AccessFlags2 {
        self.dst_access_mask
    }
    ///Gets the value of [`Self::src_queue_family_index`]
    pub fn src_queue_family_index(&self) -> u32 {
        self.src_queue_family_index
    }
    ///Gets the value of [`Self::dst_queue_family_index`]
    pub fn dst_queue_family_index(&self) -> u32 {
        self.dst_queue_family_index
    }
    ///Gets the value of [`Self::buffer`]
    pub fn buffer(&self) -> Buffer {
        self.buffer
    }
    ///Gets the value of [`Self::offset`]
    pub fn offset(&self) -> DeviceSize {
        self.offset
    }
    ///Gets the value of [`Self::size`]
    pub fn size(&self) -> DeviceSize {
        self.size
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::src_stage_mask`]
    pub fn src_stage_mask_mut(&mut self) -> &mut PipelineStageFlags2 {
        &mut self.src_stage_mask
    }
    ///Gets a mutable reference to the value of [`Self::src_access_mask`]
    pub fn src_access_mask_mut(&mut self) -> &mut AccessFlags2 {
        &mut self.src_access_mask
    }
    ///Gets a mutable reference to the value of [`Self::dst_stage_mask`]
    pub fn dst_stage_mask_mut(&mut self) -> &mut PipelineStageFlags2 {
        &mut self.dst_stage_mask
    }
    ///Gets a mutable reference to the value of [`Self::dst_access_mask`]
    pub fn dst_access_mask_mut(&mut self) -> &mut AccessFlags2 {
        &mut self.dst_access_mask
    }
    ///Gets a mutable reference to the value of [`Self::src_queue_family_index`]
    pub fn src_queue_family_index_mut(&mut self) -> &mut u32 {
        &mut self.src_queue_family_index
    }
    ///Gets a mutable reference to the value of [`Self::dst_queue_family_index`]
    pub fn dst_queue_family_index_mut(&mut self) -> &mut u32 {
        &mut self.dst_queue_family_index
    }
    ///Gets a mutable reference to the value of [`Self::buffer`]
    pub fn buffer_mut(&mut self) -> &mut Buffer {
        &mut self.buffer
    }
    ///Gets a mutable reference to the value of [`Self::offset`]
    pub fn offset_mut(&mut self) -> &mut DeviceSize {
        &mut self.offset
    }
    ///Gets a mutable reference to the value of [`Self::size`]
    pub fn size_mut(&mut self) -> &mut DeviceSize {
        &mut self.size
    }
    ///Sets the value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the value of [`Self::src_stage_mask`]
    pub fn set_src_stage_mask(&mut self, value: crate::vulkan1_3::PipelineStageFlags2) -> &mut Self {
        self.src_stage_mask = value;
        self
    }
    ///Sets the value of [`Self::src_access_mask`]
    pub fn set_src_access_mask(&mut self, value: crate::vulkan1_3::AccessFlags2) -> &mut Self {
        self.src_access_mask = value;
        self
    }
    ///Sets the value of [`Self::dst_stage_mask`]
    pub fn set_dst_stage_mask(&mut self, value: crate::vulkan1_3::PipelineStageFlags2) -> &mut Self {
        self.dst_stage_mask = value;
        self
    }
    ///Sets the value of [`Self::dst_access_mask`]
    pub fn set_dst_access_mask(&mut self, value: crate::vulkan1_3::AccessFlags2) -> &mut Self {
        self.dst_access_mask = value;
        self
    }
    ///Sets the value of [`Self::src_queue_family_index`]
    pub fn set_src_queue_family_index(&mut self, value: u32) -> &mut Self {
        self.src_queue_family_index = value;
        self
    }
    ///Sets the value of [`Self::dst_queue_family_index`]
    pub fn set_dst_queue_family_index(&mut self, value: u32) -> &mut Self {
        self.dst_queue_family_index = value;
        self
    }
    ///Sets the value of [`Self::buffer`]
    pub fn set_buffer(&mut self, value: crate::vulkan1_0::Buffer) -> &mut Self {
        self.buffer = value;
        self
    }
    ///Sets the value of [`Self::offset`]
    pub fn set_offset(&mut self, value: crate::vulkan1_0::DeviceSize) -> &mut Self {
        self.offset = value;
        self
    }
    ///Sets the value of [`Self::size`]
    pub fn set_size(&mut self, value: crate::vulkan1_0::DeviceSize) -> &mut Self {
        self.size = value;
        self
    }
    ///Sets the value of [`Self::s_type`]
    pub fn with_s_type(mut self, value: crate::vulkan1_0::StructureType) -> Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn with_p_next(mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the value of [`Self::src_stage_mask`]
    pub fn with_src_stage_mask(mut self, value: crate::vulkan1_3::PipelineStageFlags2) -> Self {
        self.src_stage_mask = value;
        self
    }
    ///Sets the value of [`Self::src_access_mask`]
    pub fn with_src_access_mask(mut self, value: crate::vulkan1_3::AccessFlags2) -> Self {
        self.src_access_mask = value;
        self
    }
    ///Sets the value of [`Self::dst_stage_mask`]
    pub fn with_dst_stage_mask(mut self, value: crate::vulkan1_3::PipelineStageFlags2) -> Self {
        self.dst_stage_mask = value;
        self
    }
    ///Sets the value of [`Self::dst_access_mask`]
    pub fn with_dst_access_mask(mut self, value: crate::vulkan1_3::AccessFlags2) -> Self {
        self.dst_access_mask = value;
        self
    }
    ///Sets the value of [`Self::src_queue_family_index`]
    pub fn with_src_queue_family_index(mut self, value: u32) -> Self {
        self.src_queue_family_index = value;
        self
    }
    ///Sets the value of [`Self::dst_queue_family_index`]
    pub fn with_dst_queue_family_index(mut self, value: u32) -> Self {
        self.dst_queue_family_index = value;
        self
    }
    ///Sets the value of [`Self::buffer`]
    pub fn with_buffer(mut self, value: crate::vulkan1_0::Buffer) -> Self {
        self.buffer = value;
        self
    }
    ///Sets the value of [`Self::offset`]
    pub fn with_offset(mut self, value: crate::vulkan1_0::DeviceSize) -> Self {
        self.offset = value;
        self
    }
    ///Sets the value of [`Self::size`]
    pub fn with_size(mut self, value: crate::vulkan1_0::DeviceSize) -> Self {
        self.size = value;
        self
    }
}
///[VkDependencyInfo](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDependencyInfo.html) - Structure specifying dependency information for a synchronization command
///# C Specifications
///The [`DependencyInfo`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_3
///typedef struct VkDependencyInfo {
///    VkStructureType                  sType;
///    const void*                      pNext;
///    VkDependencyFlags                dependencyFlags;
///    uint32_t                         memoryBarrierCount;
///    const VkMemoryBarrier2*          pMemoryBarriers;
///    uint32_t                         bufferMemoryBarrierCount;
///    const VkBufferMemoryBarrier2*    pBufferMemoryBarriers;
///    uint32_t                         imageMemoryBarrierCount;
///    const VkImageMemoryBarrier2*     pImageMemoryBarriers;
///} VkDependencyInfo;
///```
///or the equivalent
///```c
///// Provided by VK_KHR_synchronization2
///typedef VkDependencyInfo VkDependencyInfoKHR;
///```
///# Members
/// - [`s_type`] is the type of this structure.
/// - [`p_next`] is `NULL` or a pointer to a structure extending this structure.
/// - [`dependency_flags`] is a bitmask of [`DependencyFlagBits`] specifying how execution and
///   memory dependencies are formed.
/// - [`memory_barrier_count`] is the length of the [`memory_barriers`] array.
/// - [`memory_barriers`] is a pointer to an array of [`MemoryBarrier2`] structures defining memory
///   dependencies between any memory accesses.
/// - [`buffer_memory_barrier_count`] is the length of the [`buffer_memory_barriers`] array.
/// - [`buffer_memory_barriers`] is a pointer to an array of [`BufferMemoryBarrier2`] structures
///   defining memory dependencies between buffer ranges.
/// - [`image_memory_barrier_count`] is the length of the [`image_memory_barriers`] array.
/// - [`image_memory_barriers`] is a pointer to an array of [`ImageMemoryBarrier2`] structures
///   defining memory dependencies between image subresources.
///# Description
///This structure defines a set of [memory dependencies](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-dependencies-memory), as well as [queue
///family transfer operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-queue-transfers) and [image layout transitions](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-image-layout-transitions).Each member of [`memory_barriers`], [`buffer_memory_barriers`], and
///[`image_memory_barriers`] defines a separate
///[memory dependency](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-dependencies-memory).
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be `VK_STRUCTURE_TYPE_DEPENDENCY_INFO`
/// - [`p_next`] **must**  be `NULL`
/// - [`dependency_flags`] **must**  be a valid combination of [`DependencyFlagBits`] values
/// - If [`memory_barrier_count`] is not `0`, [`memory_barriers`] **must**  be a valid pointer to an
///   array of [`memory_barrier_count`] valid [`MemoryBarrier2`] structures
/// - If [`buffer_memory_barrier_count`] is not `0`, [`buffer_memory_barriers`] **must**  be a valid
///   pointer to an array of [`buffer_memory_barrier_count`] valid [`BufferMemoryBarrier2`]
///   structures
/// - If [`image_memory_barrier_count`] is not `0`, [`image_memory_barriers`] **must**  be a valid
///   pointer to an array of [`image_memory_barrier_count`] valid [`ImageMemoryBarrier2`] structures
///# Related
/// - [`khr_synchronization2`]
/// - [`crate::vulkan1_3`]
/// - [`BufferMemoryBarrier2`]
/// - [`DependencyFlags`]
/// - [`ImageMemoryBarrier2`]
/// - [`MemoryBarrier2`]
/// - [`StructureType`]
/// - [`cmd_pipeline_barrier2`]
/// - [`cmd_pipeline_barrier2_khr`]
/// - [`cmd_set_event2`]
/// - [`cmd_set_event2_khr`]
/// - [`cmd_wait_events2`]
/// - [`cmd_wait_events2_khr`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkDependencyInfo")]
#[derive(Debug, Clone, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[repr(C)]
pub struct DependencyInfo<'lt> {
    ///Lifetime field
    pub _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] is the type of this structure.
    pub s_type: StructureType,
    ///[`p_next`] is `NULL` or a pointer to a structure extending this
    ///structure.
    pub p_next: *const BaseInStructure<'lt>,
    ///[`dependency_flags`] is a bitmask of [`DependencyFlagBits`]
    ///specifying how execution and memory dependencies are formed.
    pub dependency_flags: DependencyFlags,
    ///[`memory_barrier_count`] is the length of the [`memory_barriers`]
    ///array.
    pub memory_barrier_count: u32,
    ///[`memory_barriers`] is a pointer to an array of [`MemoryBarrier2`]
    ///structures defining memory dependencies between any memory accesses.
    pub memory_barriers: *const MemoryBarrier2<'lt>,
    ///[`buffer_memory_barrier_count`] is the length of the
    ///[`buffer_memory_barriers`] array.
    pub buffer_memory_barrier_count: u32,
    ///[`buffer_memory_barriers`] is a pointer to an array of
    ///[`BufferMemoryBarrier2`] structures defining memory dependencies
    ///between buffer ranges.
    pub buffer_memory_barriers: *const BufferMemoryBarrier2<'lt>,
    ///[`image_memory_barrier_count`] is the length of the
    ///[`image_memory_barriers`] array.
    pub image_memory_barrier_count: u32,
    ///[`image_memory_barriers`] is a pointer to an array of
    ///[`ImageMemoryBarrier2`] structures defining memory dependencies
    ///between image subresources.
    pub image_memory_barriers: *const ImageMemoryBarrier2<'lt>,
}
impl<'lt> Default for DependencyInfo<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: StructureType::DEPENDENCY_INFO,
            p_next: std::ptr::null(),
            dependency_flags: Default::default(),
            memory_barrier_count: 0,
            memory_barriers: std::ptr::null(),
            buffer_memory_barrier_count: 0,
            buffer_memory_barriers: std::ptr::null(),
            image_memory_barrier_count: 0,
            image_memory_barriers: std::ptr::null(),
        }
    }
}
impl<'lt> DependencyInfo<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *const BaseInStructure<'lt> {
        self.p_next
    }
    ///Gets the raw value of [`Self::memory_barriers`]
    pub fn memory_barriers_raw(&self) -> *const MemoryBarrier2<'lt> {
        self.memory_barriers
    }
    ///Gets the raw value of [`Self::buffer_memory_barriers`]
    pub fn buffer_memory_barriers_raw(&self) -> *const BufferMemoryBarrier2<'lt> {
        self.buffer_memory_barriers
    }
    ///Gets the raw value of [`Self::image_memory_barriers`]
    pub fn image_memory_barriers_raw(&self) -> *const ImageMemoryBarrier2<'lt> {
        self.image_memory_barriers
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *const BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::memory_barriers`]
    pub fn set_memory_barriers_raw(&mut self, value: *const MemoryBarrier2<'lt>) -> &mut Self {
        self.memory_barriers = value;
        self
    }
    ///Sets the raw value of [`Self::buffer_memory_barriers`]
    pub fn set_buffer_memory_barriers_raw(&mut self, value: *const BufferMemoryBarrier2<'lt>) -> &mut Self {
        self.buffer_memory_barriers = value;
        self
    }
    ///Sets the raw value of [`Self::image_memory_barriers`]
    pub fn set_image_memory_barriers_raw(&mut self, value: *const ImageMemoryBarrier2<'lt>) -> &mut Self {
        self.image_memory_barriers = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn with_p_next_raw(mut self, value: *const BaseInStructure<'lt>) -> Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::memory_barriers`]
    pub fn with_memory_barriers_raw(mut self, value: *const MemoryBarrier2<'lt>) -> Self {
        self.memory_barriers = value;
        self
    }
    ///Sets the raw value of [`Self::buffer_memory_barriers`]
    pub fn with_buffer_memory_barriers_raw(mut self, value: *const BufferMemoryBarrier2<'lt>) -> Self {
        self.buffer_memory_barriers = value;
        self
    }
    ///Sets the raw value of [`Self::image_memory_barriers`]
    pub fn with_image_memory_barriers_raw(mut self, value: *const ImageMemoryBarrier2<'lt>) -> Self {
        self.image_memory_barriers = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseInStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::dependency_flags`]
    pub fn dependency_flags(&self) -> DependencyFlags {
        self.dependency_flags
    }
    ///Gets the value of [`Self::memory_barrier_count`]
    pub fn memory_barrier_count(&self) -> u32 {
        self.memory_barrier_count
    }
    ///Gets the value of [`Self::memory_barriers`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn memory_barriers(&self) -> &[MemoryBarrier2<'lt>] {
        std::slice::from_raw_parts(self.memory_barriers, self.memory_barrier_count as usize)
    }
    ///Gets the value of [`Self::buffer_memory_barrier_count`]
    pub fn buffer_memory_barrier_count(&self) -> u32 {
        self.buffer_memory_barrier_count
    }
    ///Gets the value of [`Self::buffer_memory_barriers`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn buffer_memory_barriers(&self) -> &[BufferMemoryBarrier2<'lt>] {
        std::slice::from_raw_parts(self.buffer_memory_barriers, self.buffer_memory_barrier_count as usize)
    }
    ///Gets the value of [`Self::image_memory_barrier_count`]
    pub fn image_memory_barrier_count(&self) -> u32 {
        self.image_memory_barrier_count
    }
    ///Gets the value of [`Self::image_memory_barriers`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn image_memory_barriers(&self) -> &[ImageMemoryBarrier2<'lt>] {
        std::slice::from_raw_parts(self.image_memory_barriers, self.image_memory_barrier_count as usize)
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::dependency_flags`]
    pub fn dependency_flags_mut(&mut self) -> &mut DependencyFlags {
        &mut self.dependency_flags
    }
    ///Gets a mutable reference to the value of [`Self::memory_barrier_count`]
    pub fn memory_barrier_count_mut(&mut self) -> &mut u32 {
        &mut self.memory_barrier_count
    }
    ///Gets a mutable reference to the value of [`Self::buffer_memory_barrier_count`]
    pub fn buffer_memory_barrier_count_mut(&mut self) -> &mut u32 {
        &mut self.buffer_memory_barrier_count
    }
    ///Gets a mutable reference to the value of [`Self::image_memory_barrier_count`]
    pub fn image_memory_barrier_count_mut(&mut self) -> &mut u32 {
        &mut self.image_memory_barrier_count
    }
    ///Sets the value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the value of [`Self::dependency_flags`]
    pub fn set_dependency_flags(&mut self, value: crate::vulkan1_0::DependencyFlags) -> &mut Self {
        self.dependency_flags = value;
        self
    }
    ///Sets the value of [`Self::memory_barrier_count`]
    pub fn set_memory_barrier_count(&mut self, value: u32) -> &mut Self {
        self.memory_barrier_count = value;
        self
    }
    ///Sets the value of [`Self::memory_barriers`]
    pub fn set_memory_barriers(&mut self, value: &'lt [crate::vulkan1_3::MemoryBarrier2<'lt>]) -> &mut Self {
        let len_ = value.len() as u32;
        let len_ = len_;
        self.memory_barriers = value.as_ptr();
        self.memory_barrier_count = len_;
        self
    }
    ///Sets the value of [`Self::buffer_memory_barrier_count`]
    pub fn set_buffer_memory_barrier_count(&mut self, value: u32) -> &mut Self {
        self.buffer_memory_barrier_count = value;
        self
    }
    ///Sets the value of [`Self::buffer_memory_barriers`]
    pub fn set_buffer_memory_barriers(
        &mut self,
        value: &'lt [crate::vulkan1_3::BufferMemoryBarrier2<'lt>],
    ) -> &mut Self {
        let len_ = value.len() as u32;
        let len_ = len_;
        self.buffer_memory_barriers = value.as_ptr();
        self.buffer_memory_barrier_count = len_;
        self
    }
    ///Sets the value of [`Self::image_memory_barrier_count`]
    pub fn set_image_memory_barrier_count(&mut self, value: u32) -> &mut Self {
        self.image_memory_barrier_count = value;
        self
    }
    ///Sets the value of [`Self::image_memory_barriers`]
    pub fn set_image_memory_barriers(&mut self, value: &'lt [crate::vulkan1_3::ImageMemoryBarrier2<'lt>]) -> &mut Self {
        let len_ = value.len() as u32;
        let len_ = len_;
        self.image_memory_barriers = value.as_ptr();
        self.image_memory_barrier_count = len_;
        self
    }
    ///Sets the value of [`Self::s_type`]
    pub fn with_s_type(mut self, value: crate::vulkan1_0::StructureType) -> Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn with_p_next(mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the value of [`Self::dependency_flags`]
    pub fn with_dependency_flags(mut self, value: crate::vulkan1_0::DependencyFlags) -> Self {
        self.dependency_flags = value;
        self
    }
    ///Sets the value of [`Self::memory_barrier_count`]
    pub fn with_memory_barrier_count(mut self, value: u32) -> Self {
        self.memory_barrier_count = value;
        self
    }
    ///Sets the value of [`Self::memory_barriers`]
    pub fn with_memory_barriers(mut self, value: &'lt [crate::vulkan1_3::MemoryBarrier2<'lt>]) -> Self {
        let len_ = value.len() as u32;
        let len_ = len_;
        self.memory_barriers = value.as_ptr();
        self.memory_barrier_count = len_;
        self
    }
    ///Sets the value of [`Self::buffer_memory_barrier_count`]
    pub fn with_buffer_memory_barrier_count(mut self, value: u32) -> Self {
        self.buffer_memory_barrier_count = value;
        self
    }
    ///Sets the value of [`Self::buffer_memory_barriers`]
    pub fn with_buffer_memory_barriers(mut self, value: &'lt [crate::vulkan1_3::BufferMemoryBarrier2<'lt>]) -> Self {
        let len_ = value.len() as u32;
        let len_ = len_;
        self.buffer_memory_barriers = value.as_ptr();
        self.buffer_memory_barrier_count = len_;
        self
    }
    ///Sets the value of [`Self::image_memory_barrier_count`]
    pub fn with_image_memory_barrier_count(mut self, value: u32) -> Self {
        self.image_memory_barrier_count = value;
        self
    }
    ///Sets the value of [`Self::image_memory_barriers`]
    pub fn with_image_memory_barriers(mut self, value: &'lt [crate::vulkan1_3::ImageMemoryBarrier2<'lt>]) -> Self {
        let len_ = value.len() as u32;
        let len_ = len_;
        self.image_memory_barriers = value.as_ptr();
        self.image_memory_barrier_count = len_;
        self
    }
}
///[VkSemaphoreSubmitInfo](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSemaphoreSubmitInfo.html) - Structure specifying a semaphore signal or wait operation
///# C Specifications
///The [`SemaphoreSubmitInfo`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_3
///typedef struct VkSemaphoreSubmitInfo {
///    VkStructureType          sType;
///    const void*              pNext;
///    VkSemaphore              semaphore;
///    uint64_t                 value;
///    VkPipelineStageFlags2    stageMask;
///    uint32_t                 deviceIndex;
///} VkSemaphoreSubmitInfo;
///```
///or the equivalent
///```c
///// Provided by VK_KHR_synchronization2
///typedef VkSemaphoreSubmitInfo VkSemaphoreSubmitInfoKHR;
///```
///# Members
/// - [`s_type`] is the type of this structure.
/// - [`p_next`] is `NULL` or a pointer to a structure extending this structure.
/// - [`semaphore`] is a [`Semaphore`] affected by this operation.
/// - [`value`] is either the value used to signal [`semaphore`] or the value waited on by
///   [`semaphore`], if [`semaphore`] is a timeline semaphore. Otherwise it is ignored.
/// - [`stage_mask`] is a [`PipelineStageFlags2`] mask of pipeline stages which limit the first synchronization scope of a semaphore signal operation, or second synchronization scope of a semaphore wait operation as described in the [semaphore wait operation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-semaphores-waiting) and [semaphore signal operation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-semaphores-signaling) sections of [the synchronization chapter](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization).
/// - [`device_index`] is the index of the device within a device group that executes the semaphore
///   wait or signal operation.
///# Description
///Whether this structure defines a semaphore wait or signal operation is
///defined by how it is used.
///## Valid Usage
/// - If the [geometry shaders](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-geometryShader)
///   feature is not enabled, [`stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT`
/// - If the [tessellation shaders](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-tessellationShader)
///   feature is not enabled, [`stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT` or
///   `VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT`
/// - If the [conditional rendering](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-conditionalRendering)
///   feature is not enabled, [`stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT`
/// - If the [fragment density map](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-fragmentDensityMap)
///   feature is not enabled, [`stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT`
/// - If the [transform feedback](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-transformFeedback)
///   feature is not enabled, [`stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT`
/// - If the [mesh shaders](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-meshShader)
///   feature is not enabled, [`stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_NV`
/// - If the [task shaders](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-taskShader)
///   feature is not enabled, [`stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_NV`
/// - If the [shading rate image](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-shadingRateImage)
///   feature is not enabled, [`stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_2_SHADING_RATE_IMAGE_BIT_NV`
/// - If the [subpass shading](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-subpassShading)
///   feature is not enabled, [`stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI`
/// - If the [invocation mask image](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-invocationMask)
///   feature is not enabled, [`stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_2_INVOCATION_MASK_BIT_HUAWEI`
/// - If the `device` that [`semaphore`] was created on is not a device group, [`device_index`]
///   **must**  be `0`
/// - If the `device` that [`semaphore`] was created on is a device group, [`device_index`] **must**
///   be a valid device index
///
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be `VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO`
/// - [`p_next`] **must**  be `NULL`
/// - [`semaphore`] **must**  be a valid [`Semaphore`] handle
/// - [`stage_mask`] **must**  be a valid combination of [`PipelineStageFlagBits2`] values
///# Related
/// - [`khr_synchronization2`]
/// - [`crate::vulkan1_3`]
/// - [`PipelineStageFlags2`]
/// - [`Semaphore`]
/// - [`StructureType`]
/// - [`SubmitInfo2`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkSemaphoreSubmitInfo")]
#[derive(Debug, Clone, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[repr(C)]
pub struct SemaphoreSubmitInfo<'lt> {
    ///Lifetime field
    pub _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] is the type of this structure.
    pub s_type: StructureType,
    ///[`p_next`] is `NULL` or a pointer to a structure extending this
    ///structure.
    pub p_next: *const BaseInStructure<'lt>,
    ///[`semaphore`] is a [`Semaphore`] affected by this operation.
    pub semaphore: Semaphore,
    ///[`value`] is
    ///either the value used to signal [`semaphore`] or the value waited on
    ///by [`semaphore`], if [`semaphore`] is a timeline semaphore.
    ///Otherwise it is
    ///ignored.
    pub value: u64,
    ///[`stage_mask`] is a [`PipelineStageFlags2`] mask of pipeline stages
    ///which limit the first synchronization scope of a semaphore signal
    ///operation, or second synchronization scope of a semaphore wait operation
    ///as described in the [semaphore wait
    ///operation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-semaphores-waiting) and [semaphore signal
    ///operation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-semaphores-signaling) sections of [the synchronization
    ///chapter](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization).
    pub stage_mask: PipelineStageFlags2,
    ///[`device_index`] is the index of the device within a device group that
    ///executes the semaphore wait or signal operation.
    pub device_index: u32,
}
impl<'lt> Default for SemaphoreSubmitInfo<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: StructureType::SEMAPHORE_SUBMIT_INFO,
            p_next: std::ptr::null(),
            semaphore: Default::default(),
            value: 0,
            stage_mask: Default::default(),
            device_index: 0,
        }
    }
}
impl<'lt> SemaphoreSubmitInfo<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *const BaseInStructure<'lt> {
        self.p_next
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *const BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn with_p_next_raw(mut self, value: *const BaseInStructure<'lt>) -> Self {
        self.p_next = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseInStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::semaphore`]
    pub fn semaphore(&self) -> Semaphore {
        self.semaphore
    }
    ///Gets the value of [`Self::value`]
    pub fn value(&self) -> u64 {
        self.value
    }
    ///Gets the value of [`Self::stage_mask`]
    pub fn stage_mask(&self) -> PipelineStageFlags2 {
        self.stage_mask
    }
    ///Gets the value of [`Self::device_index`]
    pub fn device_index(&self) -> u32 {
        self.device_index
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::semaphore`]
    pub fn semaphore_mut(&mut self) -> &mut Semaphore {
        &mut self.semaphore
    }
    ///Gets a mutable reference to the value of [`Self::value`]
    pub fn value_mut(&mut self) -> &mut u64 {
        &mut self.value
    }
    ///Gets a mutable reference to the value of [`Self::stage_mask`]
    pub fn stage_mask_mut(&mut self) -> &mut PipelineStageFlags2 {
        &mut self.stage_mask
    }
    ///Gets a mutable reference to the value of [`Self::device_index`]
    pub fn device_index_mut(&mut self) -> &mut u32 {
        &mut self.device_index
    }
    ///Sets the value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the value of [`Self::semaphore`]
    pub fn set_semaphore(&mut self, value: crate::vulkan1_0::Semaphore) -> &mut Self {
        self.semaphore = value;
        self
    }
    ///Sets the value of [`Self::value`]
    pub fn set_value(&mut self, value: u64) -> &mut Self {
        self.value = value;
        self
    }
    ///Sets the value of [`Self::stage_mask`]
    pub fn set_stage_mask(&mut self, value: crate::vulkan1_3::PipelineStageFlags2) -> &mut Self {
        self.stage_mask = value;
        self
    }
    ///Sets the value of [`Self::device_index`]
    pub fn set_device_index(&mut self, value: u32) -> &mut Self {
        self.device_index = value;
        self
    }
    ///Sets the value of [`Self::s_type`]
    pub fn with_s_type(mut self, value: crate::vulkan1_0::StructureType) -> Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn with_p_next(mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the value of [`Self::semaphore`]
    pub fn with_semaphore(mut self, value: crate::vulkan1_0::Semaphore) -> Self {
        self.semaphore = value;
        self
    }
    ///Sets the value of [`Self::value`]
    pub fn with_value(mut self, value: u64) -> Self {
        self.value = value;
        self
    }
    ///Sets the value of [`Self::stage_mask`]
    pub fn with_stage_mask(mut self, value: crate::vulkan1_3::PipelineStageFlags2) -> Self {
        self.stage_mask = value;
        self
    }
    ///Sets the value of [`Self::device_index`]
    pub fn with_device_index(mut self, value: u32) -> Self {
        self.device_index = value;
        self
    }
}
///[VkCommandBufferSubmitInfo](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandBufferSubmitInfo.html) - Structure specifying a command buffer submission
///# C Specifications
///The [`CommandBufferSubmitInfo`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_3
///typedef struct VkCommandBufferSubmitInfo {
///    VkStructureType    sType;
///    const void*        pNext;
///    VkCommandBuffer    commandBuffer;
///    uint32_t           deviceMask;
///} VkCommandBufferSubmitInfo;
///```
///or the equivalent
///```c
///// Provided by VK_KHR_synchronization2
///typedef VkCommandBufferSubmitInfo VkCommandBufferSubmitInfoKHR;
///```
///# Members
/// - [`s_type`] is the type of this structure.
/// - [`p_next`] is `NULL` or a pointer to a structure extending this structure.
/// - [`command_buffer`] is a [`CommandBuffer`] to be submitted for execution.
/// - [`device_mask`] is a bitmask indicating which devices in a device group execute the command
///   buffer. A [`device_mask`] of `0` is equivalent to setting all bits corresponding to valid
///   devices in the group to `1`.
///# Description
///## Valid Usage
/// - [`command_buffer`] **must**  not have been allocated with `VK_COMMAND_BUFFER_LEVEL_SECONDARY`
/// - If [`device_mask`] is not `0`, it  **must**  be a valid device mask
///
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be `VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO`
/// - [`p_next`] **must**  be `NULL`
/// - [`command_buffer`] **must**  be a valid [`CommandBuffer`] handle
///# Related
/// - [`khr_synchronization2`]
/// - [`crate::vulkan1_3`]
/// - [`CommandBuffer`]
/// - [`StructureType`]
/// - [`SubmitInfo2`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkCommandBufferSubmitInfo")]
#[derive(Debug, Clone, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[repr(C)]
pub struct CommandBufferSubmitInfo<'lt> {
    ///Lifetime field
    pub _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] is the type of this structure.
    pub s_type: StructureType,
    ///[`p_next`] is `NULL` or a pointer to a structure extending this
    ///structure.
    pub p_next: *const BaseInStructure<'lt>,
    ///[`command_buffer`] is a [`CommandBuffer`] to be submitted for
    ///execution.
    pub command_buffer: CommandBuffer,
    ///[`device_mask`] is a bitmask indicating which devices in a device group
    ///execute the command buffer.
    ///A [`device_mask`] of `0` is equivalent to setting all bits
    ///corresponding to valid devices in the group to `1`.
    pub device_mask: u32,
}
impl<'lt> Default for CommandBufferSubmitInfo<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: StructureType::COMMAND_BUFFER_SUBMIT_INFO,
            p_next: std::ptr::null(),
            command_buffer: Default::default(),
            device_mask: 0,
        }
    }
}
impl<'lt> CommandBufferSubmitInfo<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *const BaseInStructure<'lt> {
        self.p_next
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *const BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn with_p_next_raw(mut self, value: *const BaseInStructure<'lt>) -> Self {
        self.p_next = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseInStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::command_buffer`]
    pub fn command_buffer(&self) -> CommandBuffer {
        self.command_buffer
    }
    ///Gets the value of [`Self::device_mask`]
    pub fn device_mask(&self) -> u32 {
        self.device_mask
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::command_buffer`]
    pub fn command_buffer_mut(&mut self) -> &mut CommandBuffer {
        &mut self.command_buffer
    }
    ///Gets a mutable reference to the value of [`Self::device_mask`]
    pub fn device_mask_mut(&mut self) -> &mut u32 {
        &mut self.device_mask
    }
    ///Sets the value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the value of [`Self::command_buffer`]
    pub fn set_command_buffer(&mut self, value: crate::vulkan1_0::CommandBuffer) -> &mut Self {
        self.command_buffer = value;
        self
    }
    ///Sets the value of [`Self::device_mask`]
    pub fn set_device_mask(&mut self, value: u32) -> &mut Self {
        self.device_mask = value;
        self
    }
    ///Sets the value of [`Self::s_type`]
    pub fn with_s_type(mut self, value: crate::vulkan1_0::StructureType) -> Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn with_p_next(mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the value of [`Self::command_buffer`]
    pub fn with_command_buffer(mut self, value: crate::vulkan1_0::CommandBuffer) -> Self {
        self.command_buffer = value;
        self
    }
    ///Sets the value of [`Self::device_mask`]
    pub fn with_device_mask(mut self, value: u32) -> Self {
        self.device_mask = value;
        self
    }
}
///[VkSubmitInfo2](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSubmitInfo2.html) - Structure specifying a queue submit operation
///# C Specifications
///The [`SubmitInfo2`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_3
///typedef struct VkSubmitInfo2 {
///    VkStructureType                     sType;
///    const void*                         pNext;
///    VkSubmitFlags                       flags;
///    uint32_t                            waitSemaphoreInfoCount;
///    const VkSemaphoreSubmitInfo*        pWaitSemaphoreInfos;
///    uint32_t                            commandBufferInfoCount;
///    const VkCommandBufferSubmitInfo*    pCommandBufferInfos;
///    uint32_t                            signalSemaphoreInfoCount;
///    const VkSemaphoreSubmitInfo*        pSignalSemaphoreInfos;
///} VkSubmitInfo2;
///```
///or the equivalent
///```c
///// Provided by VK_KHR_synchronization2
///typedef VkSubmitInfo2 VkSubmitInfo2KHR;
///```
///# Members
/// - [`s_type`] is the type of this structure.
/// - [`p_next`] is `NULL` or a pointer to a structure extending this structure.
/// - [`flags`] is a bitmask of [`SubmitFlagBits`].
/// - [`wait_semaphore_info_count`] is the number of elements in [`wait_semaphore_infos`].
/// - [`wait_semaphore_infos`] is a pointer to an array of [`SemaphoreSubmitInfo`] structures defining [semaphore wait operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-semaphores-waiting).
/// - [`command_buffer_info_count`] is the number of elements in [`command_buffer_infos`] and the
///   number of command buffers to execute in the batch.
/// - [`command_buffer_infos`] is a pointer to an array of [`CommandBufferSubmitInfo`] structures
///   describing command buffers to execute in the batch.
/// - [`signal_semaphore_info_count`] is the number of elements in [`signal_semaphore_infos`].
/// - [`signal_semaphore_infos`] is a pointer to an array of [`SemaphoreSubmitInfo`] describing [semaphore signal operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-semaphores-signaling).
///# Description
///## Valid Usage
/// - If the same semaphore is used as the `semaphore` member of both an element of
///   [`signal_semaphore_infos`] and [`wait_semaphore_infos`], and that semaphore is a timeline
///   semaphore, the `value` member of the [`signal_semaphore_infos`] element  **must**  be greater
///   than the `value` member of the [`wait_semaphore_infos`] element
/// -    If the `semaphore` member of any element of [`signal_semaphore_infos`] is a timeline semaphore, the `value` member of that element  **must**  have a value greater than the current value of the semaphore when the [semaphore signal operation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-semaphores-signaling) is executed
/// -    If the `semaphore` member of any element of [`signal_semaphore_infos`] is a timeline semaphore, the `value` member of that element  **must**  have a value which does not differ from the current value of the semaphore or the value of any outstanding semaphore wait or signal operation on that semaphore by more than [`maxTimelineSemaphoreValueDifference`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#limits-maxTimelineSemaphoreValueDifference)
/// -    If the `semaphore` member of any element of [`wait_semaphore_infos`] is a timeline semaphore, the `value` member of that element  **must**  have a value which does not differ from the current value of the semaphore or the value of any outstanding semaphore wait or signal operation on that semaphore by more than [`maxTimelineSemaphoreValueDifference`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#limits-maxTimelineSemaphoreValueDifference)
/// - If [`flags`] includes `VK_SUBMIT_PROTECTED_BIT`, all elements of `pCommandBuffers` **must**
///   be protected command buffers
/// - If [`flags`] does not include `VK_SUBMIT_PROTECTED_BIT`, each element of `pCommandBuffers`
///   **must**  not be a protected command buffer
/// -    If any `commandBuffer` member of an element of [`command_buffer_infos`] contains any [resumed render pass instances](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-suspension), they  **must**  be suspended by a render pass instance earlier in submission order within [`command_buffer_infos`]
/// -    If any `commandBuffer` member of an element of [`command_buffer_infos`] contains any [suspended render pass instances](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-suspension), they  **must**  be resumed by a render pass instance later in submission order within [`command_buffer_infos`]
/// -    If any `commandBuffer` member of an element of [`command_buffer_infos`] contains any [suspended render pass instances](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-suspension), there  **must**  be no action or synchronization commands between that render pass instance and the render pass instance that resumes it
/// -    If any `commandBuffer` member of an element of [`command_buffer_infos`] contains any [suspended render pass instances](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-suspension), there  **must**  be no render pass instances between that render pass instance and the render pass instance that resumes it
/// -    If the [`variableSampleLocations`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#limits-variableSampleLocations) limit is not supported, and any `commandBuffer` member of an element of [`command_buffer_infos`] contains any [suspended render pass instances](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-suspension), where a graphics pipeline has been bound, any pipelines bound in the render pass instance that resumes it, or any subsequent render pass instances that resume from that one and so on,  **must**  use the same sample locations
///
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be `VK_STRUCTURE_TYPE_SUBMIT_INFO_2`
/// - Each [`p_next`] member of any structure (including this one) in the [`p_next`] chain  **must**
///   be either `NULL` or a pointer to a valid instance of [`PerformanceQuerySubmitInfoKHR`],
///   [`Win32KeyedMutexAcquireReleaseInfoKHR`], or [`Win32KeyedMutexAcquireReleaseInfoNV`]
/// - The [`s_type`] value of each struct in the [`p_next`] chain  **must**  be unique
/// - [`flags`] **must**  be a valid combination of [`SubmitFlagBits`] values
/// - If [`wait_semaphore_info_count`] is not `0`, [`wait_semaphore_infos`] **must**  be a valid
///   pointer to an array of [`wait_semaphore_info_count`] valid [`SemaphoreSubmitInfo`] structures
/// - If [`command_buffer_info_count`] is not `0`, [`command_buffer_infos`] **must**  be a valid
///   pointer to an array of [`command_buffer_info_count`] valid [`CommandBufferSubmitInfo`]
///   structures
/// - If [`signal_semaphore_info_count`] is not `0`, [`signal_semaphore_infos`] **must**  be a valid
///   pointer to an array of [`signal_semaphore_info_count`] valid [`SemaphoreSubmitInfo`]
///   structures
///# Related
/// - [`khr_synchronization2`]
/// - [`crate::vulkan1_3`]
/// - [`CommandBufferSubmitInfo`]
/// - [`SemaphoreSubmitInfo`]
/// - [`StructureType`]
/// - [`SubmitFlags`]
/// - [`queue_submit2`]
/// - [`queue_submit2_khr`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkSubmitInfo2")]
#[derive(Debug, Clone, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[repr(C)]
pub struct SubmitInfo2<'lt> {
    ///Lifetime field
    pub _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] is the type of this structure.
    pub s_type: StructureType,
    ///[`p_next`] is `NULL` or a pointer to a structure extending this
    ///structure.
    pub p_next: *const BaseInStructure<'lt>,
    ///[`flags`] is a bitmask of [`SubmitFlagBits`].
    pub flags: SubmitFlags,
    ///[`wait_semaphore_info_count`] is the number of elements in
    ///[`wait_semaphore_infos`].
    pub wait_semaphore_info_count: u32,
    ///[`wait_semaphore_infos`] is a pointer to an array of
    ///[`SemaphoreSubmitInfo`] structures defining
    ///[semaphore wait operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-semaphores-waiting).
    pub wait_semaphore_infos: *const SemaphoreSubmitInfo<'lt>,
    ///[`command_buffer_info_count`] is the number of elements in
    ///[`command_buffer_infos`] and the number of command buffers to execute
    ///in the batch.
    pub command_buffer_info_count: u32,
    ///[`command_buffer_infos`] is a pointer to an array of
    ///[`CommandBufferSubmitInfo`] structures describing command buffers to
    ///execute in the batch.
    pub command_buffer_infos: *const CommandBufferSubmitInfo<'lt>,
    ///[`signal_semaphore_info_count`] is the number of elements in
    ///[`signal_semaphore_infos`].
    pub signal_semaphore_info_count: u32,
    ///[`signal_semaphore_infos`] is a pointer to an array of
    ///[`SemaphoreSubmitInfo`] describing
    ///[semaphore signal operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-semaphores-signaling).
    pub signal_semaphore_infos: *const SemaphoreSubmitInfo<'lt>,
}
impl<'lt> Default for SubmitInfo2<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: StructureType::SUBMIT_INFO2,
            p_next: std::ptr::null(),
            flags: Default::default(),
            wait_semaphore_info_count: 0,
            wait_semaphore_infos: std::ptr::null(),
            command_buffer_info_count: 0,
            command_buffer_infos: std::ptr::null(),
            signal_semaphore_info_count: 0,
            signal_semaphore_infos: std::ptr::null(),
        }
    }
}
impl<'lt> SubmitInfo2<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *const BaseInStructure<'lt> {
        self.p_next
    }
    ///Gets the raw value of [`Self::wait_semaphore_infos`]
    pub fn wait_semaphore_infos_raw(&self) -> *const SemaphoreSubmitInfo<'lt> {
        self.wait_semaphore_infos
    }
    ///Gets the raw value of [`Self::command_buffer_infos`]
    pub fn command_buffer_infos_raw(&self) -> *const CommandBufferSubmitInfo<'lt> {
        self.command_buffer_infos
    }
    ///Gets the raw value of [`Self::signal_semaphore_infos`]
    pub fn signal_semaphore_infos_raw(&self) -> *const SemaphoreSubmitInfo<'lt> {
        self.signal_semaphore_infos
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *const BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::wait_semaphore_infos`]
    pub fn set_wait_semaphore_infos_raw(&mut self, value: *const SemaphoreSubmitInfo<'lt>) -> &mut Self {
        self.wait_semaphore_infos = value;
        self
    }
    ///Sets the raw value of [`Self::command_buffer_infos`]
    pub fn set_command_buffer_infos_raw(&mut self, value: *const CommandBufferSubmitInfo<'lt>) -> &mut Self {
        self.command_buffer_infos = value;
        self
    }
    ///Sets the raw value of [`Self::signal_semaphore_infos`]
    pub fn set_signal_semaphore_infos_raw(&mut self, value: *const SemaphoreSubmitInfo<'lt>) -> &mut Self {
        self.signal_semaphore_infos = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn with_p_next_raw(mut self, value: *const BaseInStructure<'lt>) -> Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::wait_semaphore_infos`]
    pub fn with_wait_semaphore_infos_raw(mut self, value: *const SemaphoreSubmitInfo<'lt>) -> Self {
        self.wait_semaphore_infos = value;
        self
    }
    ///Sets the raw value of [`Self::command_buffer_infos`]
    pub fn with_command_buffer_infos_raw(mut self, value: *const CommandBufferSubmitInfo<'lt>) -> Self {
        self.command_buffer_infos = value;
        self
    }
    ///Sets the raw value of [`Self::signal_semaphore_infos`]
    pub fn with_signal_semaphore_infos_raw(mut self, value: *const SemaphoreSubmitInfo<'lt>) -> Self {
        self.signal_semaphore_infos = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseInStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::flags`]
    pub fn flags(&self) -> SubmitFlags {
        self.flags
    }
    ///Gets the value of [`Self::wait_semaphore_info_count`]
    pub fn wait_semaphore_info_count(&self) -> u32 {
        self.wait_semaphore_info_count
    }
    ///Gets the value of [`Self::wait_semaphore_infos`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn wait_semaphore_infos(&self) -> &[SemaphoreSubmitInfo<'lt>] {
        std::slice::from_raw_parts(self.wait_semaphore_infos, self.wait_semaphore_info_count as usize)
    }
    ///Gets the value of [`Self::command_buffer_info_count`]
    pub fn command_buffer_info_count(&self) -> u32 {
        self.command_buffer_info_count
    }
    ///Gets the value of [`Self::command_buffer_infos`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn command_buffer_infos(&self) -> &[CommandBufferSubmitInfo<'lt>] {
        std::slice::from_raw_parts(self.command_buffer_infos, self.command_buffer_info_count as usize)
    }
    ///Gets the value of [`Self::signal_semaphore_info_count`]
    pub fn signal_semaphore_info_count(&self) -> u32 {
        self.signal_semaphore_info_count
    }
    ///Gets the value of [`Self::signal_semaphore_infos`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn signal_semaphore_infos(&self) -> &[SemaphoreSubmitInfo<'lt>] {
        std::slice::from_raw_parts(self.signal_semaphore_infos, self.signal_semaphore_info_count as usize)
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::flags`]
    pub fn flags_mut(&mut self) -> &mut SubmitFlags {
        &mut self.flags
    }
    ///Gets a mutable reference to the value of [`Self::wait_semaphore_info_count`]
    pub fn wait_semaphore_info_count_mut(&mut self) -> &mut u32 {
        &mut self.wait_semaphore_info_count
    }
    ///Gets a mutable reference to the value of [`Self::command_buffer_info_count`]
    pub fn command_buffer_info_count_mut(&mut self) -> &mut u32 {
        &mut self.command_buffer_info_count
    }
    ///Gets a mutable reference to the value of [`Self::signal_semaphore_info_count`]
    pub fn signal_semaphore_info_count_mut(&mut self) -> &mut u32 {
        &mut self.signal_semaphore_info_count
    }
    ///Sets the value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the value of [`Self::flags`]
    pub fn set_flags(&mut self, value: crate::vulkan1_3::SubmitFlags) -> &mut Self {
        self.flags = value;
        self
    }
    ///Sets the value of [`Self::wait_semaphore_info_count`]
    pub fn set_wait_semaphore_info_count(&mut self, value: u32) -> &mut Self {
        self.wait_semaphore_info_count = value;
        self
    }
    ///Sets the value of [`Self::wait_semaphore_infos`]
    pub fn set_wait_semaphore_infos(&mut self, value: &'lt [crate::vulkan1_3::SemaphoreSubmitInfo<'lt>]) -> &mut Self {
        let len_ = value.len() as u32;
        let len_ = len_;
        self.wait_semaphore_infos = value.as_ptr();
        self.wait_semaphore_info_count = len_;
        self
    }
    ///Sets the value of [`Self::command_buffer_info_count`]
    pub fn set_command_buffer_info_count(&mut self, value: u32) -> &mut Self {
        self.command_buffer_info_count = value;
        self
    }
    ///Sets the value of [`Self::command_buffer_infos`]
    pub fn set_command_buffer_infos(
        &mut self,
        value: &'lt [crate::vulkan1_3::CommandBufferSubmitInfo<'lt>],
    ) -> &mut Self {
        let len_ = value.len() as u32;
        let len_ = len_;
        self.command_buffer_infos = value.as_ptr();
        self.command_buffer_info_count = len_;
        self
    }
    ///Sets the value of [`Self::signal_semaphore_info_count`]
    pub fn set_signal_semaphore_info_count(&mut self, value: u32) -> &mut Self {
        self.signal_semaphore_info_count = value;
        self
    }
    ///Sets the value of [`Self::signal_semaphore_infos`]
    pub fn set_signal_semaphore_infos(
        &mut self,
        value: &'lt [crate::vulkan1_3::SemaphoreSubmitInfo<'lt>],
    ) -> &mut Self {
        let len_ = value.len() as u32;
        let len_ = len_;
        self.signal_semaphore_infos = value.as_ptr();
        self.signal_semaphore_info_count = len_;
        self
    }
    ///Sets the value of [`Self::s_type`]
    pub fn with_s_type(mut self, value: crate::vulkan1_0::StructureType) -> Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn with_p_next(mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the value of [`Self::flags`]
    pub fn with_flags(mut self, value: crate::vulkan1_3::SubmitFlags) -> Self {
        self.flags = value;
        self
    }
    ///Sets the value of [`Self::wait_semaphore_info_count`]
    pub fn with_wait_semaphore_info_count(mut self, value: u32) -> Self {
        self.wait_semaphore_info_count = value;
        self
    }
    ///Sets the value of [`Self::wait_semaphore_infos`]
    pub fn with_wait_semaphore_infos(mut self, value: &'lt [crate::vulkan1_3::SemaphoreSubmitInfo<'lt>]) -> Self {
        let len_ = value.len() as u32;
        let len_ = len_;
        self.wait_semaphore_infos = value.as_ptr();
        self.wait_semaphore_info_count = len_;
        self
    }
    ///Sets the value of [`Self::command_buffer_info_count`]
    pub fn with_command_buffer_info_count(mut self, value: u32) -> Self {
        self.command_buffer_info_count = value;
        self
    }
    ///Sets the value of [`Self::command_buffer_infos`]
    pub fn with_command_buffer_infos(mut self, value: &'lt [crate::vulkan1_3::CommandBufferSubmitInfo<'lt>]) -> Self {
        let len_ = value.len() as u32;
        let len_ = len_;
        self.command_buffer_infos = value.as_ptr();
        self.command_buffer_info_count = len_;
        self
    }
    ///Sets the value of [`Self::signal_semaphore_info_count`]
    pub fn with_signal_semaphore_info_count(mut self, value: u32) -> Self {
        self.signal_semaphore_info_count = value;
        self
    }
    ///Sets the value of [`Self::signal_semaphore_infos`]
    pub fn with_signal_semaphore_infos(mut self, value: &'lt [crate::vulkan1_3::SemaphoreSubmitInfo<'lt>]) -> Self {
        let len_ = value.len() as u32;
        let len_ = len_;
        self.signal_semaphore_infos = value.as_ptr();
        self.signal_semaphore_info_count = len_;
        self
    }
}
#[cfg(any(feature = "VK_NV_win32_keyed_mutex", feature = "VK_KHR_win32_keyed_mutex"))]
unsafe impl<'this: 'extender + 'other, 'extender: 'other, 'other>
    crate::Chain<'other, Win32KeyedMutexAcquireReleaseInfoNV<'extender>> for SubmitInfo2<'this>
{
    type Out = SubmitInfo2<'other>;
    #[must_use]
    #[inline]
    fn chain(mut self, new: &'other mut Win32KeyedMutexAcquireReleaseInfoNV<'extender>) -> Self::Out {
        unsafe {
            crate::chaining::insert_ptr_in_chain(
                &mut self as *mut Self as *mut BaseOutStructure<'other>,
                new as *mut Win32KeyedMutexAcquireReleaseInfoNV<'extender> as *mut BaseOutStructure<'other>,
            );
            std::mem::transmute(self)
        }
    }
}
#[cfg(feature = "VK_KHR_win32_keyed_mutex")]
unsafe impl<'this: 'extender + 'other, 'extender: 'other, 'other>
    crate::Chain<'other, Win32KeyedMutexAcquireReleaseInfoKHR<'extender>> for SubmitInfo2<'this>
{
    type Out = SubmitInfo2<'other>;
    #[must_use]
    #[inline]
    fn chain(mut self, new: &'other mut Win32KeyedMutexAcquireReleaseInfoKHR<'extender>) -> Self::Out {
        unsafe {
            crate::chaining::insert_ptr_in_chain(
                &mut self as *mut Self as *mut BaseOutStructure<'other>,
                new as *mut Win32KeyedMutexAcquireReleaseInfoKHR<'extender> as *mut BaseOutStructure<'other>,
            );
            std::mem::transmute(self)
        }
    }
}
#[cfg(feature = "VK_KHR_performance_query")]
unsafe impl<'this: 'extender + 'other, 'extender: 'other, 'other>
    crate::Chain<'other, PerformanceQuerySubmitInfoKHR<'extender>> for SubmitInfo2<'this>
{
    type Out = SubmitInfo2<'other>;
    #[must_use]
    #[inline]
    fn chain(mut self, new: &'other mut PerformanceQuerySubmitInfoKHR<'extender>) -> Self::Out {
        unsafe {
            crate::chaining::insert_ptr_in_chain(
                &mut self as *mut Self as *mut BaseOutStructure<'other>,
                new as *mut PerformanceQuerySubmitInfoKHR<'extender> as *mut BaseOutStructure<'other>,
            );
            std::mem::transmute(self)
        }
    }
}
///[VkPhysicalDeviceSynchronization2Features](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceSynchronization2Features.html) - Structure describing whether the implementation supports v2 synchronization commands
///# C Specifications
///The [`PhysicalDeviceSynchronization2Features`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_3
///typedef struct VkPhysicalDeviceSynchronization2Features {
///    VkStructureType    sType;
///    void*              pNext;
///    VkBool32           synchronization2;
///} VkPhysicalDeviceSynchronization2Features;
///```
///or the equivalent
///```c
///// Provided by VK_KHR_synchronization2
///typedef VkPhysicalDeviceSynchronization2Features VkPhysicalDeviceSynchronization2FeaturesKHR;
///```
///# Members
///This structure describes the following feature:
///# Description
/// - [`s_type`] is the type of this structure.
/// - [`p_next`] is `NULL` or a pointer to a structure extending this structure.
///
/// - [`synchronization2`] indicates whether the implementation supports the new set of
///   synchronization commands introduced in `[`khr_synchronization2`]`.
///If the [`PhysicalDeviceSynchronization2Features`] structure is included in the [`p_next`] chain
/// of the
///[`PhysicalDeviceFeatures2`] structure passed to
///[`get_physical_device_features2`], it is filled in to indicate whether each
///corresponding feature is supported.
///[`PhysicalDeviceSynchronization2Features`] **can**  also be used in the [`p_next`] chain of
///[`DeviceCreateInfo`] to selectively enable these features.
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be `VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES`
///# Related
/// - [`khr_synchronization2`]
/// - [`crate::vulkan1_3`]
/// - [`Bool32`]
/// - [`StructureType`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkPhysicalDeviceSynchronization2Features")]
#[derive(Debug, Clone, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[repr(C)]
pub struct PhysicalDeviceSynchronization2Features<'lt> {
    ///Lifetime field
    pub _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] is the type of this structure.
    pub s_type: StructureType,
    ///[`p_next`] is `NULL` or a pointer to a structure extending this
    ///structure.
    pub p_next: *mut BaseOutStructure<'lt>,
    ///[`synchronization2`]
    ///indicates whether the implementation supports the new set of
    ///synchronization commands introduced in `[`khr_synchronization2`]`.
    pub synchronization2: Bool32,
}
impl<'lt> Default for PhysicalDeviceSynchronization2Features<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: StructureType::PHYSICAL_DEVICE_SYNCHRONIZATION2_FEATURES,
            p_next: std::ptr::null_mut(),
            synchronization2: 0,
        }
    }
}
impl<'lt> PhysicalDeviceSynchronization2Features<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *mut BaseOutStructure<'lt> {
        self.p_next
    }
    ///Gets the raw value of [`Self::synchronization2`]
    pub fn synchronization2_raw(&self) -> Bool32 {
        self.synchronization2
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *mut BaseOutStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::synchronization2`]
    pub fn set_synchronization2_raw(&mut self, value: Bool32) -> &mut Self {
        self.synchronization2 = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn with_p_next_raw(mut self, value: *mut BaseOutStructure<'lt>) -> Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::synchronization2`]
    pub fn with_synchronization2_raw(mut self, value: Bool32) -> Self {
        self.synchronization2 = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseOutStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::synchronization2`]
    pub fn synchronization2(&self) -> bool {
        unsafe { std::mem::transmute(self.synchronization2 as u8) }
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next_mut(&mut self) -> &mut BaseOutStructure<'lt> {
        &mut *self.p_next
    }
    ///Gets a mutable reference to the value of [`Self::synchronization2`]
    pub fn synchronization2_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.synchronization2 as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.synchronization2 as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Sets the value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt mut crate::vulkan1_0::BaseOutStructure<'lt>) -> &mut Self {
        self.p_next = value as *mut _;
        self
    }
    ///Sets the value of [`Self::synchronization2`]
    pub fn set_synchronization2(&mut self, value: bool) -> &mut Self {
        self.synchronization2 = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::s_type`]
    pub fn with_s_type(mut self, value: crate::vulkan1_0::StructureType) -> Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn with_p_next(mut self, value: &'lt mut crate::vulkan1_0::BaseOutStructure<'lt>) -> Self {
        self.p_next = value as *mut _;
        self
    }
    ///Sets the value of [`Self::synchronization2`]
    pub fn with_synchronization2(mut self, value: bool) -> Self {
        self.synchronization2 = value as u8 as u32;
        self
    }
}
///[VkPhysicalDeviceShaderIntegerDotProductFeatures](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderIntegerDotProductFeatures.html) - Structure describing integer dot product features that can be supported by an implementation
///# C Specifications
///The [`PhysicalDeviceShaderIntegerDotProductFeatures`] structure is
///defined as:
///```c
///// Provided by VK_VERSION_1_3
///typedef struct VkPhysicalDeviceShaderIntegerDotProductFeatures {
///    VkStructureType    sType;
///    void*              pNext;
///    VkBool32           shaderIntegerDotProduct;
///} VkPhysicalDeviceShaderIntegerDotProductFeatures;
///```
///or the equivalent
///```c
///// Provided by VK_KHR_shader_integer_dot_product
///typedef VkPhysicalDeviceShaderIntegerDotProductFeatures
/// VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR;
///```
///# Members
///The members of the [`PhysicalDeviceShaderIntegerDotProductFeatures`]
///structure describe the following features:
///# Description
/// - [`s_type`] is the type of this structure.
/// - [`p_next`] is `NULL` or a pointer to a structure extending this structure.
///
/// - [`shader_integer_dot_product`] specifies whether shader modules  **can**  declare the
///   `DotProductInputAllKHR`, `DotProductInput4x8BitKHR`, `DotProductInput4x8BitPackedKHR` and
///   `DotProductKHR` capabilities.
///If the [`PhysicalDeviceShaderIntegerDotProductFeatures`] structure is included in the [`p_next`]
/// chain of the
///[`PhysicalDeviceFeatures2`] structure passed to
///[`get_physical_device_features2`], it is filled in to indicate whether each
///corresponding feature is supported.
///[`PhysicalDeviceShaderIntegerDotProductFeatures`] **can**  also be used in the [`p_next`] chain
/// of
///[`DeviceCreateInfo`] to selectively enable these features.
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be
///   `VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES`
///# Related
/// - [`khr_shader_integer_dot_product`]
/// - [`crate::vulkan1_3`]
/// - [`Bool32`]
/// - [`StructureType`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkPhysicalDeviceShaderIntegerDotProductFeatures")]
#[derive(Debug, Clone, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[repr(C)]
pub struct PhysicalDeviceShaderIntegerDotProductFeatures<'lt> {
    ///Lifetime field
    pub _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] is the type of this structure.
    pub s_type: StructureType,
    ///[`p_next`] is `NULL` or a pointer to a structure extending this
    ///structure.
    pub p_next: *mut BaseOutStructure<'lt>,
    ///[`shader_integer_dot_product`] specifies whether shader modules  **can**
    ///declare the `DotProductInputAllKHR`, `DotProductInput4x8BitKHR`,
    ///`DotProductInput4x8BitPackedKHR` and `DotProductKHR` capabilities.
    pub shader_integer_dot_product: Bool32,
}
impl<'lt> Default for PhysicalDeviceShaderIntegerDotProductFeatures<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: StructureType::PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES,
            p_next: std::ptr::null_mut(),
            shader_integer_dot_product: 0,
        }
    }
}
impl<'lt> PhysicalDeviceShaderIntegerDotProductFeatures<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *mut BaseOutStructure<'lt> {
        self.p_next
    }
    ///Gets the raw value of [`Self::shader_integer_dot_product`]
    pub fn shader_integer_dot_product_raw(&self) -> Bool32 {
        self.shader_integer_dot_product
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *mut BaseOutStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::shader_integer_dot_product`]
    pub fn set_shader_integer_dot_product_raw(&mut self, value: Bool32) -> &mut Self {
        self.shader_integer_dot_product = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn with_p_next_raw(mut self, value: *mut BaseOutStructure<'lt>) -> Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::shader_integer_dot_product`]
    pub fn with_shader_integer_dot_product_raw(mut self, value: Bool32) -> Self {
        self.shader_integer_dot_product = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseOutStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::shader_integer_dot_product`]
    pub fn shader_integer_dot_product(&self) -> bool {
        unsafe { std::mem::transmute(self.shader_integer_dot_product as u8) }
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next_mut(&mut self) -> &mut BaseOutStructure<'lt> {
        &mut *self.p_next
    }
    ///Gets a mutable reference to the value of [`Self::shader_integer_dot_product`]
    pub fn shader_integer_dot_product_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.shader_integer_dot_product as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.shader_integer_dot_product as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Sets the value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt mut crate::vulkan1_0::BaseOutStructure<'lt>) -> &mut Self {
        self.p_next = value as *mut _;
        self
    }
    ///Sets the value of [`Self::shader_integer_dot_product`]
    pub fn set_shader_integer_dot_product(&mut self, value: bool) -> &mut Self {
        self.shader_integer_dot_product = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::s_type`]
    pub fn with_s_type(mut self, value: crate::vulkan1_0::StructureType) -> Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn with_p_next(mut self, value: &'lt mut crate::vulkan1_0::BaseOutStructure<'lt>) -> Self {
        self.p_next = value as *mut _;
        self
    }
    ///Sets the value of [`Self::shader_integer_dot_product`]
    pub fn with_shader_integer_dot_product(mut self, value: bool) -> Self {
        self.shader_integer_dot_product = value as u8 as u32;
        self
    }
}
///[VkPhysicalDeviceShaderIntegerDotProductProperties](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderIntegerDotProductProperties.html) - Structure containing information about integer dot product support for a physical device
///# C Specifications
///The [`PhysicalDeviceShaderIntegerDotProductProperties`] structure is
///defined as:
///```c
///// Provided by VK_VERSION_1_3
///typedef struct VkPhysicalDeviceShaderIntegerDotProductProperties {
///    VkStructureType    sType;
///    void*              pNext;
///    VkBool32           integerDotProduct8BitUnsignedAccelerated;
///    VkBool32           integerDotProduct8BitSignedAccelerated;
///    VkBool32           integerDotProduct8BitMixedSignednessAccelerated;
///    VkBool32           integerDotProduct4x8BitPackedUnsignedAccelerated;
///    VkBool32           integerDotProduct4x8BitPackedSignedAccelerated;
///    VkBool32           integerDotProduct4x8BitPackedMixedSignednessAccelerated;
///    VkBool32           integerDotProduct16BitUnsignedAccelerated;
///    VkBool32           integerDotProduct16BitSignedAccelerated;
///    VkBool32           integerDotProduct16BitMixedSignednessAccelerated;
///    VkBool32           integerDotProduct32BitUnsignedAccelerated;
///    VkBool32           integerDotProduct32BitSignedAccelerated;
///    VkBool32           integerDotProduct32BitMixedSignednessAccelerated;
///    VkBool32           integerDotProduct64BitUnsignedAccelerated;
///    VkBool32           integerDotProduct64BitSignedAccelerated;
///    VkBool32           integerDotProduct64BitMixedSignednessAccelerated;
///    VkBool32           integerDotProductAccumulatingSaturating8BitUnsignedAccelerated;
///    VkBool32           integerDotProductAccumulatingSaturating8BitSignedAccelerated;
///    VkBool32           integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated;
///    VkBool32           integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated;
///    VkBool32           integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated;
///    VkBool32
/// integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated;
///    VkBool32           integerDotProductAccumulatingSaturating16BitUnsignedAccelerated;
///    VkBool32           integerDotProductAccumulatingSaturating16BitSignedAccelerated;
///    VkBool32           integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated;
///    VkBool32           integerDotProductAccumulatingSaturating32BitUnsignedAccelerated;
///    VkBool32           integerDotProductAccumulatingSaturating32BitSignedAccelerated;
///    VkBool32           integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated;
///    VkBool32           integerDotProductAccumulatingSaturating64BitUnsignedAccelerated;
///    VkBool32           integerDotProductAccumulatingSaturating64BitSignedAccelerated;
///    VkBool32           integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated;
///} VkPhysicalDeviceShaderIntegerDotProductProperties;
///```
///or the equivalent
///```c
///// Provided by VK_KHR_shader_integer_dot_product
///typedef VkPhysicalDeviceShaderIntegerDotProductProperties
/// VkPhysicalDeviceShaderIntegerDotProductPropertiesKHR;
///```
///# Members
/// - [`s_type`] is the type of this structure.
/// - [`p_next`] is `NULL` or a pointer to a structure extending this structure.
///# Description
/// - [`integer_dot_product8_bit_unsigned_accelerated`] is a boolean that will be [`TRUE`] if the support for 8-bit unsigned dot product operations using the `OpUDotKHR` SPIR-V instruction is accelerated [as defined below](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#devsandqueues-integer-dot-product-accelerated).
/// - [`integer_dot_product8_bit_signed_accelerated`] is a boolean that will be [`TRUE`] if the support for 8-bit signed dot product operations using the `OpSDotKHR` SPIR-V instruction is accelerated [as defined below](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#devsandqueues-integer-dot-product-accelerated).
/// - [`integer_dot_product8_bit_mixed_signedness_accelerated`] is a boolean that will be [`TRUE`] if the support for 8-bit mixed signedness dot product operations using the `OpSUDotKHR` SPIR-V instruction is accelerated [as defined below](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#devsandqueues-integer-dot-product-accelerated).
/// - [`integer_dot_product4x8_bit_packed_unsigned_accelerated`] is a boolean that will be [`TRUE`] if the support for 8-bit unsigned dot product operations from operands packed into 32-bit integers using the `OpUDotKHR` SPIR-V instruction is accelerated [as defined below](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#devsandqueues-integer-dot-product-accelerated).
/// - [`integer_dot_product4x8_bit_packed_signed_accelerated`] is a boolean that will be [`TRUE`] if
///   the support for 8-bit signed dot product operations from operands packed into 32-bit integers using
///   the `OpSDotKHR` SPIR-V instruction is accelerated [as defined below](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#devsandqueues-integer-dot-product-accelerated).
/// - [`integer_dot_product4x8_bit_packed_mixed_signedness_accelerated`] is a boolean that will be [`TRUE`] if the support for 8-bit mixed signedness dot product operations from operands packed into 32-bit integers using the `OpSUDotKHR` SPIR-V instruction is accelerated [as defined below](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#devsandqueues-integer-dot-product-accelerated).
/// - [`integer_dot_product16_bit_unsigned_accelerated`] is a boolean that will be [`TRUE`] if the support for 16-bit unsigned dot product operations using the `OpUDotKHR` SPIR-V instruction is accelerated [as defined below](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#devsandqueues-integer-dot-product-accelerated).
/// - [`integer_dot_product16_bit_signed_accelerated`] is a boolean that will be [`TRUE`] if the support for 16-bit signed dot product operations using the `OpSDotKHR` SPIR-V instruction is accelerated [as defined below](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#devsandqueues-integer-dot-product-accelerated).
/// - [`integer_dot_product16_bit_mixed_signedness_accelerated`] is a boolean that will be [`TRUE`] if the support for 16-bit mixed signedness dot product operations using the `OpSUDotKHR` SPIR-V instruction is accelerated [as defined below](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#devsandqueues-integer-dot-product-accelerated).
/// - [`integer_dot_product32_bit_unsigned_accelerated`] is a boolean that will be [`TRUE`] if the support for 32-bit unsigned dot product operations using the `OpUDotKHR` SPIR-V instruction is accelerated [as defined below](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#devsandqueues-integer-dot-product-accelerated).
/// - [`integer_dot_product32_bit_signed_accelerated`] is a boolean that will be [`TRUE`] if the support for 32-bit signed dot product operations using the `OpSDotKHR` SPIR-V instruction is accelerated [as defined below](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#devsandqueues-integer-dot-product-accelerated).
/// - [`integer_dot_product32_bit_mixed_signedness_accelerated`] is a boolean that will be [`TRUE`] if the support for 32-bit mixed signedness dot product operations using the `OpSUDotKHR` SPIR-V instruction is accelerated [as defined below](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#devsandqueues-integer-dot-product-accelerated).
/// - [`integer_dot_product64_bit_unsigned_accelerated`] is a boolean that will be [`TRUE`] if the support for 64-bit unsigned dot product operations using the `OpUDotKHR` SPIR-V instruction is accelerated [as defined below](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#devsandqueues-integer-dot-product-accelerated).
/// - [`integer_dot_product64_bit_signed_accelerated`] is a boolean that will be [`TRUE`] if the support for 64-bit signed dot product operations using the `OpSDotKHR` SPIR-V instruction is accelerated [as defined below](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#devsandqueues-integer-dot-product-accelerated).
/// - [`integer_dot_product64_bit_mixed_signedness_accelerated`] is a boolean that will be [`TRUE`] if the support for 64-bit mixed signedness dot product operations using the `OpSUDotKHR` SPIR-V instruction is accelerated [as defined below](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#devsandqueues-integer-dot-product-accelerated).
/// - [`integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated`] is a boolean that will be [`TRUE`] if the support for 8-bit unsigned accumulating saturating dot product operations using the `OpUDotAccSatKHR` SPIR-V instruction is accelerated [as defined below](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#devsandqueues-integer-dot-product-accelerated).
/// - [`integer_dot_product_accumulating_saturating8_bit_signed_accelerated`] is a boolean that will
///   be [`TRUE`] if the support for 8-bit signed accumulating saturating dot product operations using
///   the `OpSDotAccSatKHR` SPIR-V instruction is accelerated [as defined below](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#devsandqueues-integer-dot-product-accelerated).
/// - [`integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated`] is a boolean
///   that will be [`TRUE`] if the support for 8-bit mixed signedness accumulating saturating dot product
///   operations using the `OpSUDotAccSatKHR` SPIR-V instruction is accelerated [as defined below](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#devsandqueues-integer-dot-product-accelerated).
/// - [`integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated`] is a boolean that will be [`TRUE`] if the support for 8-bit unsigned accumulating saturating dot product operations from operands packed into 32-bit integers using the `OpUDotAccSatKHR` SPIR-V instruction is accelerated [as defined below](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#devsandqueues-integer-dot-product-accelerated).
/// - [`integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated`] is a boolean that will be [`TRUE`] if the support for 8-bit signed accumulating saturating dot product operations from operands packed into 32-bit integers using the `OpSDotAccSatKHR` SPIR-V instruction is accelerated [as defined below](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#devsandqueues-integer-dot-product-accelerated).
/// - [`integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated`] is a boolean that will be [`TRUE`] if the support for 8-bit mixed signedness accumulating saturating dot product operations from operands packed into 32-bit integers using the `OpSUDotAccSatKHR` SPIR-V instruction is accelerated [as defined below](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#devsandqueues-integer-dot-product-accelerated).
/// - [`integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated`] is a boolean that will be [`TRUE`] if the support for 16-bit unsigned accumulating saturating dot product operations using the `OpUDotAccSatKHR` SPIR-V instruction is accelerated [as defined below](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#devsandqueues-integer-dot-product-accelerated).
/// - [`integer_dot_product_accumulating_saturating16_bit_signed_accelerated`] is a boolean that will be [`TRUE`] if the support for 16-bit signed accumulating saturating dot product operations using the `OpSDotAccSatKHR` SPIR-V instruction is accelerated [as defined below](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#devsandqueues-integer-dot-product-accelerated).
/// - [`integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated`] is a boolean that will be [`TRUE`] if the support for 16-bit mixed signedness accumulating saturating dot product operations using the `OpSUDotAccSatKHR` SPIR-V instruction is accelerated [as defined below](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#devsandqueues-integer-dot-product-accelerated).
/// - [`integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated`] is a boolean that will be [`TRUE`] if the support for 32-bit unsigned accumulating saturating dot product operations using the `OpUDotAccSatKHR` SPIR-V instruction is accelerated [as defined below](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#devsandqueues-integer-dot-product-accelerated).
/// - [`integer_dot_product_accumulating_saturating32_bit_signed_accelerated`] is a boolean that will be [`TRUE`] if the support for 32-bit signed accumulating saturating dot product operations using the `OpSDotAccSatKHR` SPIR-V instruction is accelerated [as defined below](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#devsandqueues-integer-dot-product-accelerated).
/// - [`integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated`] is a boolean that will be [`TRUE`] if the support for 32-bit mixed signedness accumulating saturating dot product operations using the `OpSUDotAccSatKHR` SPIR-V instruction is accelerated [as defined below](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#devsandqueues-integer-dot-product-accelerated).
/// - [`integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated`] is a boolean that will be [`TRUE`] if the support for 64-bit unsigned accumulating saturating dot product operations using the `OpUDotAccSatKHR` SPIR-V instruction is accelerated [as defined below](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#devsandqueues-integer-dot-product-accelerated).
/// - [`integer_dot_product_accumulating_saturating64_bit_signed_accelerated`] is a boolean that will be [`TRUE`] if the support for 64-bit signed accumulating saturating dot product operations using the `OpSDotAccSatKHR` SPIR-V instruction is accelerated [as defined below](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#devsandqueues-integer-dot-product-accelerated).
/// - [`integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated`] is a boolean that will be [`TRUE`] if the support for 64-bit mixed signedness accumulating saturating dot product operations using the `OpSUDotAccSatKHR` SPIR-V instruction is accelerated [as defined below](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#devsandqueues-integer-dot-product-accelerated).
///If the [`PhysicalDeviceShaderIntegerDotProductProperties`] structure is included in the
/// [`p_next`] chain of the
///[`PhysicalDeviceProperties2`] structure passed to
///[`get_physical_device_properties2`], it is filled in with each
///corresponding implementation-dependent property.These are properties of the integer dot product
/// acceleration information of
///a physical device.
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be
///   `VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES`
///# Related
/// - [`khr_shader_integer_dot_product`]
/// - [`crate::vulkan1_3`]
/// - [`Bool32`]
/// - [`StructureType`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkPhysicalDeviceShaderIntegerDotProductProperties")]
#[derive(Debug, Clone, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[repr(C)]
pub struct PhysicalDeviceShaderIntegerDotProductProperties<'lt> {
    ///Lifetime field
    pub _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] is the type of this structure.
    pub s_type: StructureType,
    ///[`p_next`] is `NULL` or a pointer to a structure extending this
    ///structure.
    pub p_next: *mut BaseOutStructure<'lt>,
    ///No documentation found
    pub integer_dot_product8_bit_unsigned_accelerated: Bool32,
    ///No documentation found
    pub integer_dot_product8_bit_signed_accelerated: Bool32,
    ///No documentation found
    pub integer_dot_product8_bit_mixed_signedness_accelerated: Bool32,
    ///No documentation found
    pub integer_dot_product4x8_bit_packed_unsigned_accelerated: Bool32,
    ///No documentation found
    pub integer_dot_product4x8_bit_packed_signed_accelerated: Bool32,
    ///No documentation found
    pub integer_dot_product4x8_bit_packed_mixed_signedness_accelerated: Bool32,
    ///No documentation found
    pub integer_dot_product16_bit_unsigned_accelerated: Bool32,
    ///No documentation found
    pub integer_dot_product16_bit_signed_accelerated: Bool32,
    ///No documentation found
    pub integer_dot_product16_bit_mixed_signedness_accelerated: Bool32,
    ///No documentation found
    pub integer_dot_product32_bit_unsigned_accelerated: Bool32,
    ///No documentation found
    pub integer_dot_product32_bit_signed_accelerated: Bool32,
    ///No documentation found
    pub integer_dot_product32_bit_mixed_signedness_accelerated: Bool32,
    ///No documentation found
    pub integer_dot_product64_bit_unsigned_accelerated: Bool32,
    ///No documentation found
    pub integer_dot_product64_bit_signed_accelerated: Bool32,
    ///No documentation found
    pub integer_dot_product64_bit_mixed_signedness_accelerated: Bool32,
    ///No documentation found
    pub integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated: Bool32,
    ///No documentation found
    pub integer_dot_product_accumulating_saturating8_bit_signed_accelerated: Bool32,
    ///No documentation found
    pub integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated: Bool32,
    ///No documentation found
    pub integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated: Bool32,
    ///No documentation found
    pub integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated: Bool32,
    ///No documentation found
    pub integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated: Bool32,
    ///No documentation found
    pub integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated: Bool32,
    ///No documentation found
    pub integer_dot_product_accumulating_saturating16_bit_signed_accelerated: Bool32,
    ///No documentation found
    pub integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated: Bool32,
    ///No documentation found
    pub integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated: Bool32,
    ///No documentation found
    pub integer_dot_product_accumulating_saturating32_bit_signed_accelerated: Bool32,
    ///No documentation found
    pub integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated: Bool32,
    ///No documentation found
    pub integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated: Bool32,
    ///No documentation found
    pub integer_dot_product_accumulating_saturating64_bit_signed_accelerated: Bool32,
    ///No documentation found
    pub integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated: Bool32,
}
impl<'lt> Default for PhysicalDeviceShaderIntegerDotProductProperties<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: StructureType::PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES,
            p_next: std::ptr::null_mut(),
            integer_dot_product8_bit_unsigned_accelerated: 0,
            integer_dot_product8_bit_signed_accelerated: 0,
            integer_dot_product8_bit_mixed_signedness_accelerated: 0,
            integer_dot_product4x8_bit_packed_unsigned_accelerated: 0,
            integer_dot_product4x8_bit_packed_signed_accelerated: 0,
            integer_dot_product4x8_bit_packed_mixed_signedness_accelerated: 0,
            integer_dot_product16_bit_unsigned_accelerated: 0,
            integer_dot_product16_bit_signed_accelerated: 0,
            integer_dot_product16_bit_mixed_signedness_accelerated: 0,
            integer_dot_product32_bit_unsigned_accelerated: 0,
            integer_dot_product32_bit_signed_accelerated: 0,
            integer_dot_product32_bit_mixed_signedness_accelerated: 0,
            integer_dot_product64_bit_unsigned_accelerated: 0,
            integer_dot_product64_bit_signed_accelerated: 0,
            integer_dot_product64_bit_mixed_signedness_accelerated: 0,
            integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated: 0,
            integer_dot_product_accumulating_saturating8_bit_signed_accelerated: 0,
            integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated: 0,
            integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated: 0,
            integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated: 0,
            integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated: 0,
            integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated: 0,
            integer_dot_product_accumulating_saturating16_bit_signed_accelerated: 0,
            integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated: 0,
            integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated: 0,
            integer_dot_product_accumulating_saturating32_bit_signed_accelerated: 0,
            integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated: 0,
            integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated: 0,
            integer_dot_product_accumulating_saturating64_bit_signed_accelerated: 0,
            integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated: 0,
        }
    }
}
impl<'lt> PhysicalDeviceShaderIntegerDotProductProperties<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *mut BaseOutStructure<'lt> {
        self.p_next
    }
    ///Gets the raw value of [`Self::integer_dot_product8_bit_unsigned_accelerated`]
    pub fn integer_dot_product8_bit_unsigned_accelerated_raw(&self) -> Bool32 {
        self.integer_dot_product8_bit_unsigned_accelerated
    }
    ///Gets the raw value of [`Self::integer_dot_product8_bit_signed_accelerated`]
    pub fn integer_dot_product8_bit_signed_accelerated_raw(&self) -> Bool32 {
        self.integer_dot_product8_bit_signed_accelerated
    }
    ///Gets the raw value of [`Self::integer_dot_product8_bit_mixed_signedness_accelerated`]
    pub fn integer_dot_product8_bit_mixed_signedness_accelerated_raw(&self) -> Bool32 {
        self.integer_dot_product8_bit_mixed_signedness_accelerated
    }
    ///Gets the raw value of [`Self::integer_dot_product4x8_bit_packed_unsigned_accelerated`]
    pub fn integer_dot_product4x8_bit_packed_unsigned_accelerated_raw(&self) -> Bool32 {
        self.integer_dot_product4x8_bit_packed_unsigned_accelerated
    }
    ///Gets the raw value of [`Self::integer_dot_product4x8_bit_packed_signed_accelerated`]
    pub fn integer_dot_product4x8_bit_packed_signed_accelerated_raw(&self) -> Bool32 {
        self.integer_dot_product4x8_bit_packed_signed_accelerated
    }
    ///Gets the raw value of
    /// [`Self::integer_dot_product4x8_bit_packed_mixed_signedness_accelerated`]
    pub fn integer_dot_product4x8_bit_packed_mixed_signedness_accelerated_raw(&self) -> Bool32 {
        self.integer_dot_product4x8_bit_packed_mixed_signedness_accelerated
    }
    ///Gets the raw value of [`Self::integer_dot_product16_bit_unsigned_accelerated`]
    pub fn integer_dot_product16_bit_unsigned_accelerated_raw(&self) -> Bool32 {
        self.integer_dot_product16_bit_unsigned_accelerated
    }
    ///Gets the raw value of [`Self::integer_dot_product16_bit_signed_accelerated`]
    pub fn integer_dot_product16_bit_signed_accelerated_raw(&self) -> Bool32 {
        self.integer_dot_product16_bit_signed_accelerated
    }
    ///Gets the raw value of [`Self::integer_dot_product16_bit_mixed_signedness_accelerated`]
    pub fn integer_dot_product16_bit_mixed_signedness_accelerated_raw(&self) -> Bool32 {
        self.integer_dot_product16_bit_mixed_signedness_accelerated
    }
    ///Gets the raw value of [`Self::integer_dot_product32_bit_unsigned_accelerated`]
    pub fn integer_dot_product32_bit_unsigned_accelerated_raw(&self) -> Bool32 {
        self.integer_dot_product32_bit_unsigned_accelerated
    }
    ///Gets the raw value of [`Self::integer_dot_product32_bit_signed_accelerated`]
    pub fn integer_dot_product32_bit_signed_accelerated_raw(&self) -> Bool32 {
        self.integer_dot_product32_bit_signed_accelerated
    }
    ///Gets the raw value of [`Self::integer_dot_product32_bit_mixed_signedness_accelerated`]
    pub fn integer_dot_product32_bit_mixed_signedness_accelerated_raw(&self) -> Bool32 {
        self.integer_dot_product32_bit_mixed_signedness_accelerated
    }
    ///Gets the raw value of [`Self::integer_dot_product64_bit_unsigned_accelerated`]
    pub fn integer_dot_product64_bit_unsigned_accelerated_raw(&self) -> Bool32 {
        self.integer_dot_product64_bit_unsigned_accelerated
    }
    ///Gets the raw value of [`Self::integer_dot_product64_bit_signed_accelerated`]
    pub fn integer_dot_product64_bit_signed_accelerated_raw(&self) -> Bool32 {
        self.integer_dot_product64_bit_signed_accelerated
    }
    ///Gets the raw value of [`Self::integer_dot_product64_bit_mixed_signedness_accelerated`]
    pub fn integer_dot_product64_bit_mixed_signedness_accelerated_raw(&self) -> Bool32 {
        self.integer_dot_product64_bit_mixed_signedness_accelerated
    }
    ///Gets the raw value of
    /// [`Self::integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated`]
    pub fn integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated_raw(&self) -> Bool32 {
        self.integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated
    }
    ///Gets the raw value of
    /// [`Self::integer_dot_product_accumulating_saturating8_bit_signed_accelerated`]
    pub fn integer_dot_product_accumulating_saturating8_bit_signed_accelerated_raw(&self) -> Bool32 {
        self.integer_dot_product_accumulating_saturating8_bit_signed_accelerated
    }
    ///Gets the raw value of
    /// [`Self::integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated`]
    pub fn integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated_raw(&self) -> Bool32 {
        self.integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated
    }
    ///Gets the raw value of
    /// [`Self::integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated`]
    pub fn integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated_raw(&self) -> Bool32 {
        self.integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated
    }
    ///Gets the raw value of
    /// [`Self::integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated`]
    pub fn integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated_raw(&self) -> Bool32 {
        self.integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated
    }
    ///Gets the raw value of
    /// [`Self::integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated`]
    pub fn integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated_raw(&self) -> Bool32 {
        self.integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated
    }
    ///Gets the raw value of
    /// [`Self::integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated`]
    pub fn integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated_raw(&self) -> Bool32 {
        self.integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated
    }
    ///Gets the raw value of
    /// [`Self::integer_dot_product_accumulating_saturating16_bit_signed_accelerated`]
    pub fn integer_dot_product_accumulating_saturating16_bit_signed_accelerated_raw(&self) -> Bool32 {
        self.integer_dot_product_accumulating_saturating16_bit_signed_accelerated
    }
    ///Gets the raw value of
    /// [`Self::integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated`]
    pub fn integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated_raw(&self) -> Bool32 {
        self.integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated
    }
    ///Gets the raw value of
    /// [`Self::integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated`]
    pub fn integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated_raw(&self) -> Bool32 {
        self.integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated
    }
    ///Gets the raw value of
    /// [`Self::integer_dot_product_accumulating_saturating32_bit_signed_accelerated`]
    pub fn integer_dot_product_accumulating_saturating32_bit_signed_accelerated_raw(&self) -> Bool32 {
        self.integer_dot_product_accumulating_saturating32_bit_signed_accelerated
    }
    ///Gets the raw value of
    /// [`Self::integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated`]
    pub fn integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated_raw(&self) -> Bool32 {
        self.integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated
    }
    ///Gets the raw value of
    /// [`Self::integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated`]
    pub fn integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated_raw(&self) -> Bool32 {
        self.integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated
    }
    ///Gets the raw value of
    /// [`Self::integer_dot_product_accumulating_saturating64_bit_signed_accelerated`]
    pub fn integer_dot_product_accumulating_saturating64_bit_signed_accelerated_raw(&self) -> Bool32 {
        self.integer_dot_product_accumulating_saturating64_bit_signed_accelerated
    }
    ///Gets the raw value of
    /// [`Self::integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated`]
    pub fn integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated_raw(&self) -> Bool32 {
        self.integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *mut BaseOutStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::integer_dot_product8_bit_unsigned_accelerated`]
    pub fn set_integer_dot_product8_bit_unsigned_accelerated_raw(&mut self, value: Bool32) -> &mut Self {
        self.integer_dot_product8_bit_unsigned_accelerated = value;
        self
    }
    ///Sets the raw value of [`Self::integer_dot_product8_bit_signed_accelerated`]
    pub fn set_integer_dot_product8_bit_signed_accelerated_raw(&mut self, value: Bool32) -> &mut Self {
        self.integer_dot_product8_bit_signed_accelerated = value;
        self
    }
    ///Sets the raw value of [`Self::integer_dot_product8_bit_mixed_signedness_accelerated`]
    pub fn set_integer_dot_product8_bit_mixed_signedness_accelerated_raw(&mut self, value: Bool32) -> &mut Self {
        self.integer_dot_product8_bit_mixed_signedness_accelerated = value;
        self
    }
    ///Sets the raw value of [`Self::integer_dot_product4x8_bit_packed_unsigned_accelerated`]
    pub fn set_integer_dot_product4x8_bit_packed_unsigned_accelerated_raw(&mut self, value: Bool32) -> &mut Self {
        self.integer_dot_product4x8_bit_packed_unsigned_accelerated = value;
        self
    }
    ///Sets the raw value of [`Self::integer_dot_product4x8_bit_packed_signed_accelerated`]
    pub fn set_integer_dot_product4x8_bit_packed_signed_accelerated_raw(&mut self, value: Bool32) -> &mut Self {
        self.integer_dot_product4x8_bit_packed_signed_accelerated = value;
        self
    }
    ///Sets the raw value of
    /// [`Self::integer_dot_product4x8_bit_packed_mixed_signedness_accelerated`]
    pub fn set_integer_dot_product4x8_bit_packed_mixed_signedness_accelerated_raw(
        &mut self,
        value: Bool32,
    ) -> &mut Self {
        self.integer_dot_product4x8_bit_packed_mixed_signedness_accelerated = value;
        self
    }
    ///Sets the raw value of [`Self::integer_dot_product16_bit_unsigned_accelerated`]
    pub fn set_integer_dot_product16_bit_unsigned_accelerated_raw(&mut self, value: Bool32) -> &mut Self {
        self.integer_dot_product16_bit_unsigned_accelerated = value;
        self
    }
    ///Sets the raw value of [`Self::integer_dot_product16_bit_signed_accelerated`]
    pub fn set_integer_dot_product16_bit_signed_accelerated_raw(&mut self, value: Bool32) -> &mut Self {
        self.integer_dot_product16_bit_signed_accelerated = value;
        self
    }
    ///Sets the raw value of [`Self::integer_dot_product16_bit_mixed_signedness_accelerated`]
    pub fn set_integer_dot_product16_bit_mixed_signedness_accelerated_raw(&mut self, value: Bool32) -> &mut Self {
        self.integer_dot_product16_bit_mixed_signedness_accelerated = value;
        self
    }
    ///Sets the raw value of [`Self::integer_dot_product32_bit_unsigned_accelerated`]
    pub fn set_integer_dot_product32_bit_unsigned_accelerated_raw(&mut self, value: Bool32) -> &mut Self {
        self.integer_dot_product32_bit_unsigned_accelerated = value;
        self
    }
    ///Sets the raw value of [`Self::integer_dot_product32_bit_signed_accelerated`]
    pub fn set_integer_dot_product32_bit_signed_accelerated_raw(&mut self, value: Bool32) -> &mut Self {
        self.integer_dot_product32_bit_signed_accelerated = value;
        self
    }
    ///Sets the raw value of [`Self::integer_dot_product32_bit_mixed_signedness_accelerated`]
    pub fn set_integer_dot_product32_bit_mixed_signedness_accelerated_raw(&mut self, value: Bool32) -> &mut Self {
        self.integer_dot_product32_bit_mixed_signedness_accelerated = value;
        self
    }
    ///Sets the raw value of [`Self::integer_dot_product64_bit_unsigned_accelerated`]
    pub fn set_integer_dot_product64_bit_unsigned_accelerated_raw(&mut self, value: Bool32) -> &mut Self {
        self.integer_dot_product64_bit_unsigned_accelerated = value;
        self
    }
    ///Sets the raw value of [`Self::integer_dot_product64_bit_signed_accelerated`]
    pub fn set_integer_dot_product64_bit_signed_accelerated_raw(&mut self, value: Bool32) -> &mut Self {
        self.integer_dot_product64_bit_signed_accelerated = value;
        self
    }
    ///Sets the raw value of [`Self::integer_dot_product64_bit_mixed_signedness_accelerated`]
    pub fn set_integer_dot_product64_bit_mixed_signedness_accelerated_raw(&mut self, value: Bool32) -> &mut Self {
        self.integer_dot_product64_bit_mixed_signedness_accelerated = value;
        self
    }
    ///Sets the raw value of
    /// [`Self::integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated`]
    pub fn set_integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated_raw(
        &mut self,
        value: Bool32,
    ) -> &mut Self {
        self.integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated = value;
        self
    }
    ///Sets the raw value of
    /// [`Self::integer_dot_product_accumulating_saturating8_bit_signed_accelerated`]
    pub fn set_integer_dot_product_accumulating_saturating8_bit_signed_accelerated_raw(
        &mut self,
        value: Bool32,
    ) -> &mut Self {
        self.integer_dot_product_accumulating_saturating8_bit_signed_accelerated = value;
        self
    }
    ///Sets the raw value of
    /// [`Self::integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated`]
    pub fn set_integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated_raw(
        &mut self,
        value: Bool32,
    ) -> &mut Self {
        self.integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated = value;
        self
    }
    ///Sets the raw value of
    /// [`Self::integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated`]
    pub fn set_integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated_raw(
        &mut self,
        value: Bool32,
    ) -> &mut Self {
        self.integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated = value;
        self
    }
    ///Sets the raw value of
    /// [`Self::integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated`]
    pub fn set_integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated_raw(
        &mut self,
        value: Bool32,
    ) -> &mut Self {
        self.integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated = value;
        self
    }
    ///Sets the raw value of
    /// [`Self::integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated`]
    pub fn set_integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated_raw(
        &mut self,
        value: Bool32,
    ) -> &mut Self {
        self.integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated = value;
        self
    }
    ///Sets the raw value of
    /// [`Self::integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated`]
    pub fn set_integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated_raw(
        &mut self,
        value: Bool32,
    ) -> &mut Self {
        self.integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated = value;
        self
    }
    ///Sets the raw value of
    /// [`Self::integer_dot_product_accumulating_saturating16_bit_signed_accelerated`]
    pub fn set_integer_dot_product_accumulating_saturating16_bit_signed_accelerated_raw(
        &mut self,
        value: Bool32,
    ) -> &mut Self {
        self.integer_dot_product_accumulating_saturating16_bit_signed_accelerated = value;
        self
    }
    ///Sets the raw value of
    /// [`Self::integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated`]
    pub fn set_integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated_raw(
        &mut self,
        value: Bool32,
    ) -> &mut Self {
        self.integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated = value;
        self
    }
    ///Sets the raw value of
    /// [`Self::integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated`]
    pub fn set_integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated_raw(
        &mut self,
        value: Bool32,
    ) -> &mut Self {
        self.integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated = value;
        self
    }
    ///Sets the raw value of
    /// [`Self::integer_dot_product_accumulating_saturating32_bit_signed_accelerated`]
    pub fn set_integer_dot_product_accumulating_saturating32_bit_signed_accelerated_raw(
        &mut self,
        value: Bool32,
    ) -> &mut Self {
        self.integer_dot_product_accumulating_saturating32_bit_signed_accelerated = value;
        self
    }
    ///Sets the raw value of
    /// [`Self::integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated`]
    pub fn set_integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated_raw(
        &mut self,
        value: Bool32,
    ) -> &mut Self {
        self.integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated = value;
        self
    }
    ///Sets the raw value of
    /// [`Self::integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated`]
    pub fn set_integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated_raw(
        &mut self,
        value: Bool32,
    ) -> &mut Self {
        self.integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated = value;
        self
    }
    ///Sets the raw value of
    /// [`Self::integer_dot_product_accumulating_saturating64_bit_signed_accelerated`]
    pub fn set_integer_dot_product_accumulating_saturating64_bit_signed_accelerated_raw(
        &mut self,
        value: Bool32,
    ) -> &mut Self {
        self.integer_dot_product_accumulating_saturating64_bit_signed_accelerated = value;
        self
    }
    ///Sets the raw value of
    /// [`Self::integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated`]
    pub fn set_integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated_raw(
        &mut self,
        value: Bool32,
    ) -> &mut Self {
        self.integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn with_p_next_raw(mut self, value: *mut BaseOutStructure<'lt>) -> Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::integer_dot_product8_bit_unsigned_accelerated`]
    pub fn with_integer_dot_product8_bit_unsigned_accelerated_raw(mut self, value: Bool32) -> Self {
        self.integer_dot_product8_bit_unsigned_accelerated = value;
        self
    }
    ///Sets the raw value of [`Self::integer_dot_product8_bit_signed_accelerated`]
    pub fn with_integer_dot_product8_bit_signed_accelerated_raw(mut self, value: Bool32) -> Self {
        self.integer_dot_product8_bit_signed_accelerated = value;
        self
    }
    ///Sets the raw value of [`Self::integer_dot_product8_bit_mixed_signedness_accelerated`]
    pub fn with_integer_dot_product8_bit_mixed_signedness_accelerated_raw(mut self, value: Bool32) -> Self {
        self.integer_dot_product8_bit_mixed_signedness_accelerated = value;
        self
    }
    ///Sets the raw value of [`Self::integer_dot_product4x8_bit_packed_unsigned_accelerated`]
    pub fn with_integer_dot_product4x8_bit_packed_unsigned_accelerated_raw(mut self, value: Bool32) -> Self {
        self.integer_dot_product4x8_bit_packed_unsigned_accelerated = value;
        self
    }
    ///Sets the raw value of [`Self::integer_dot_product4x8_bit_packed_signed_accelerated`]
    pub fn with_integer_dot_product4x8_bit_packed_signed_accelerated_raw(mut self, value: Bool32) -> Self {
        self.integer_dot_product4x8_bit_packed_signed_accelerated = value;
        self
    }
    ///Sets the raw value of
    /// [`Self::integer_dot_product4x8_bit_packed_mixed_signedness_accelerated`]
    pub fn with_integer_dot_product4x8_bit_packed_mixed_signedness_accelerated_raw(mut self, value: Bool32) -> Self {
        self.integer_dot_product4x8_bit_packed_mixed_signedness_accelerated = value;
        self
    }
    ///Sets the raw value of [`Self::integer_dot_product16_bit_unsigned_accelerated`]
    pub fn with_integer_dot_product16_bit_unsigned_accelerated_raw(mut self, value: Bool32) -> Self {
        self.integer_dot_product16_bit_unsigned_accelerated = value;
        self
    }
    ///Sets the raw value of [`Self::integer_dot_product16_bit_signed_accelerated`]
    pub fn with_integer_dot_product16_bit_signed_accelerated_raw(mut self, value: Bool32) -> Self {
        self.integer_dot_product16_bit_signed_accelerated = value;
        self
    }
    ///Sets the raw value of [`Self::integer_dot_product16_bit_mixed_signedness_accelerated`]
    pub fn with_integer_dot_product16_bit_mixed_signedness_accelerated_raw(mut self, value: Bool32) -> Self {
        self.integer_dot_product16_bit_mixed_signedness_accelerated = value;
        self
    }
    ///Sets the raw value of [`Self::integer_dot_product32_bit_unsigned_accelerated`]
    pub fn with_integer_dot_product32_bit_unsigned_accelerated_raw(mut self, value: Bool32) -> Self {
        self.integer_dot_product32_bit_unsigned_accelerated = value;
        self
    }
    ///Sets the raw value of [`Self::integer_dot_product32_bit_signed_accelerated`]
    pub fn with_integer_dot_product32_bit_signed_accelerated_raw(mut self, value: Bool32) -> Self {
        self.integer_dot_product32_bit_signed_accelerated = value;
        self
    }
    ///Sets the raw value of [`Self::integer_dot_product32_bit_mixed_signedness_accelerated`]
    pub fn with_integer_dot_product32_bit_mixed_signedness_accelerated_raw(mut self, value: Bool32) -> Self {
        self.integer_dot_product32_bit_mixed_signedness_accelerated = value;
        self
    }
    ///Sets the raw value of [`Self::integer_dot_product64_bit_unsigned_accelerated`]
    pub fn with_integer_dot_product64_bit_unsigned_accelerated_raw(mut self, value: Bool32) -> Self {
        self.integer_dot_product64_bit_unsigned_accelerated = value;
        self
    }
    ///Sets the raw value of [`Self::integer_dot_product64_bit_signed_accelerated`]
    pub fn with_integer_dot_product64_bit_signed_accelerated_raw(mut self, value: Bool32) -> Self {
        self.integer_dot_product64_bit_signed_accelerated = value;
        self
    }
    ///Sets the raw value of [`Self::integer_dot_product64_bit_mixed_signedness_accelerated`]
    pub fn with_integer_dot_product64_bit_mixed_signedness_accelerated_raw(mut self, value: Bool32) -> Self {
        self.integer_dot_product64_bit_mixed_signedness_accelerated = value;
        self
    }
    ///Sets the raw value of
    /// [`Self::integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated`]
    pub fn with_integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated_raw(
        mut self,
        value: Bool32,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated = value;
        self
    }
    ///Sets the raw value of
    /// [`Self::integer_dot_product_accumulating_saturating8_bit_signed_accelerated`]
    pub fn with_integer_dot_product_accumulating_saturating8_bit_signed_accelerated_raw(
        mut self,
        value: Bool32,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating8_bit_signed_accelerated = value;
        self
    }
    ///Sets the raw value of
    /// [`Self::integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated`]
    pub fn with_integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated_raw(
        mut self,
        value: Bool32,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated = value;
        self
    }
    ///Sets the raw value of
    /// [`Self::integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated`]
    pub fn with_integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated_raw(
        mut self,
        value: Bool32,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated = value;
        self
    }
    ///Sets the raw value of
    /// [`Self::integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated`]
    pub fn with_integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated_raw(
        mut self,
        value: Bool32,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated = value;
        self
    }
    ///Sets the raw value of
    /// [`Self::integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated`]
    pub fn with_integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated_raw(
        mut self,
        value: Bool32,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated = value;
        self
    }
    ///Sets the raw value of
    /// [`Self::integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated`]
    pub fn with_integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated_raw(
        mut self,
        value: Bool32,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated = value;
        self
    }
    ///Sets the raw value of
    /// [`Self::integer_dot_product_accumulating_saturating16_bit_signed_accelerated`]
    pub fn with_integer_dot_product_accumulating_saturating16_bit_signed_accelerated_raw(
        mut self,
        value: Bool32,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating16_bit_signed_accelerated = value;
        self
    }
    ///Sets the raw value of
    /// [`Self::integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated`]
    pub fn with_integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated_raw(
        mut self,
        value: Bool32,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated = value;
        self
    }
    ///Sets the raw value of
    /// [`Self::integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated`]
    pub fn with_integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated_raw(
        mut self,
        value: Bool32,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated = value;
        self
    }
    ///Sets the raw value of
    /// [`Self::integer_dot_product_accumulating_saturating32_bit_signed_accelerated`]
    pub fn with_integer_dot_product_accumulating_saturating32_bit_signed_accelerated_raw(
        mut self,
        value: Bool32,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating32_bit_signed_accelerated = value;
        self
    }
    ///Sets the raw value of
    /// [`Self::integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated`]
    pub fn with_integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated_raw(
        mut self,
        value: Bool32,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated = value;
        self
    }
    ///Sets the raw value of
    /// [`Self::integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated`]
    pub fn with_integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated_raw(
        mut self,
        value: Bool32,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated = value;
        self
    }
    ///Sets the raw value of
    /// [`Self::integer_dot_product_accumulating_saturating64_bit_signed_accelerated`]
    pub fn with_integer_dot_product_accumulating_saturating64_bit_signed_accelerated_raw(
        mut self,
        value: Bool32,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating64_bit_signed_accelerated = value;
        self
    }
    ///Sets the raw value of
    /// [`Self::integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated`]
    pub fn with_integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated_raw(
        mut self,
        value: Bool32,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseOutStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::integer_dot_product8_bit_unsigned_accelerated`]
    pub fn integer_dot_product8_bit_unsigned_accelerated(&self) -> bool {
        unsafe { std::mem::transmute(self.integer_dot_product8_bit_unsigned_accelerated as u8) }
    }
    ///Gets the value of [`Self::integer_dot_product8_bit_signed_accelerated`]
    pub fn integer_dot_product8_bit_signed_accelerated(&self) -> bool {
        unsafe { std::mem::transmute(self.integer_dot_product8_bit_signed_accelerated as u8) }
    }
    ///Gets the value of [`Self::integer_dot_product8_bit_mixed_signedness_accelerated`]
    pub fn integer_dot_product8_bit_mixed_signedness_accelerated(&self) -> bool {
        unsafe { std::mem::transmute(self.integer_dot_product8_bit_mixed_signedness_accelerated as u8) }
    }
    ///Gets the value of [`Self::integer_dot_product4x8_bit_packed_unsigned_accelerated`]
    pub fn integer_dot_product4x8_bit_packed_unsigned_accelerated(&self) -> bool {
        unsafe { std::mem::transmute(self.integer_dot_product4x8_bit_packed_unsigned_accelerated as u8) }
    }
    ///Gets the value of [`Self::integer_dot_product4x8_bit_packed_signed_accelerated`]
    pub fn integer_dot_product4x8_bit_packed_signed_accelerated(&self) -> bool {
        unsafe { std::mem::transmute(self.integer_dot_product4x8_bit_packed_signed_accelerated as u8) }
    }
    ///Gets the value of [`Self::integer_dot_product4x8_bit_packed_mixed_signedness_accelerated`]
    pub fn integer_dot_product4x8_bit_packed_mixed_signedness_accelerated(&self) -> bool {
        unsafe { std::mem::transmute(self.integer_dot_product4x8_bit_packed_mixed_signedness_accelerated as u8) }
    }
    ///Gets the value of [`Self::integer_dot_product16_bit_unsigned_accelerated`]
    pub fn integer_dot_product16_bit_unsigned_accelerated(&self) -> bool {
        unsafe { std::mem::transmute(self.integer_dot_product16_bit_unsigned_accelerated as u8) }
    }
    ///Gets the value of [`Self::integer_dot_product16_bit_signed_accelerated`]
    pub fn integer_dot_product16_bit_signed_accelerated(&self) -> bool {
        unsafe { std::mem::transmute(self.integer_dot_product16_bit_signed_accelerated as u8) }
    }
    ///Gets the value of [`Self::integer_dot_product16_bit_mixed_signedness_accelerated`]
    pub fn integer_dot_product16_bit_mixed_signedness_accelerated(&self) -> bool {
        unsafe { std::mem::transmute(self.integer_dot_product16_bit_mixed_signedness_accelerated as u8) }
    }
    ///Gets the value of [`Self::integer_dot_product32_bit_unsigned_accelerated`]
    pub fn integer_dot_product32_bit_unsigned_accelerated(&self) -> bool {
        unsafe { std::mem::transmute(self.integer_dot_product32_bit_unsigned_accelerated as u8) }
    }
    ///Gets the value of [`Self::integer_dot_product32_bit_signed_accelerated`]
    pub fn integer_dot_product32_bit_signed_accelerated(&self) -> bool {
        unsafe { std::mem::transmute(self.integer_dot_product32_bit_signed_accelerated as u8) }
    }
    ///Gets the value of [`Self::integer_dot_product32_bit_mixed_signedness_accelerated`]
    pub fn integer_dot_product32_bit_mixed_signedness_accelerated(&self) -> bool {
        unsafe { std::mem::transmute(self.integer_dot_product32_bit_mixed_signedness_accelerated as u8) }
    }
    ///Gets the value of [`Self::integer_dot_product64_bit_unsigned_accelerated`]
    pub fn integer_dot_product64_bit_unsigned_accelerated(&self) -> bool {
        unsafe { std::mem::transmute(self.integer_dot_product64_bit_unsigned_accelerated as u8) }
    }
    ///Gets the value of [`Self::integer_dot_product64_bit_signed_accelerated`]
    pub fn integer_dot_product64_bit_signed_accelerated(&self) -> bool {
        unsafe { std::mem::transmute(self.integer_dot_product64_bit_signed_accelerated as u8) }
    }
    ///Gets the value of [`Self::integer_dot_product64_bit_mixed_signedness_accelerated`]
    pub fn integer_dot_product64_bit_mixed_signedness_accelerated(&self) -> bool {
        unsafe { std::mem::transmute(self.integer_dot_product64_bit_mixed_signedness_accelerated as u8) }
    }
    ///Gets the value of
    /// [`Self::integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated`]
    pub fn integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated(&self) -> bool {
        unsafe { std::mem::transmute(self.integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated as u8) }
    }
    ///Gets the value of
    /// [`Self::integer_dot_product_accumulating_saturating8_bit_signed_accelerated`]
    pub fn integer_dot_product_accumulating_saturating8_bit_signed_accelerated(&self) -> bool {
        unsafe { std::mem::transmute(self.integer_dot_product_accumulating_saturating8_bit_signed_accelerated as u8) }
    }
    ///Gets the value of
    /// [`Self::integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated`]
    pub fn integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated(&self) -> bool {
        unsafe {
            std::mem::transmute(
                self.integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated as u8,
            )
        }
    }
    ///Gets the value of
    /// [`Self::integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated`]
    pub fn integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated(&self) -> bool {
        unsafe {
            std::mem::transmute(
                self.integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated as u8,
            )
        }
    }
    ///Gets the value of
    /// [`Self::integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated`]
    pub fn integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated(&self) -> bool {
        unsafe {
            std::mem::transmute(self.integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated as u8)
        }
    }
    ///Gets the value of
    /// [`Self::integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated`]
    pub fn integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated(&self) -> bool {
        unsafe {
            std::mem::transmute(
                self.integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated as u8,
            )
        }
    }
    ///Gets the value of
    /// [`Self::integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated`]
    pub fn integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated(&self) -> bool {
        unsafe {
            std::mem::transmute(self.integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated as u8)
        }
    }
    ///Gets the value of
    /// [`Self::integer_dot_product_accumulating_saturating16_bit_signed_accelerated`]
    pub fn integer_dot_product_accumulating_saturating16_bit_signed_accelerated(&self) -> bool {
        unsafe { std::mem::transmute(self.integer_dot_product_accumulating_saturating16_bit_signed_accelerated as u8) }
    }
    ///Gets the value of
    /// [`Self::integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated`]
    pub fn integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated(&self) -> bool {
        unsafe {
            std::mem::transmute(
                self.integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated as u8,
            )
        }
    }
    ///Gets the value of
    /// [`Self::integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated`]
    pub fn integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated(&self) -> bool {
        unsafe {
            std::mem::transmute(self.integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated as u8)
        }
    }
    ///Gets the value of
    /// [`Self::integer_dot_product_accumulating_saturating32_bit_signed_accelerated`]
    pub fn integer_dot_product_accumulating_saturating32_bit_signed_accelerated(&self) -> bool {
        unsafe { std::mem::transmute(self.integer_dot_product_accumulating_saturating32_bit_signed_accelerated as u8) }
    }
    ///Gets the value of
    /// [`Self::integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated`]
    pub fn integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated(&self) -> bool {
        unsafe {
            std::mem::transmute(
                self.integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated as u8,
            )
        }
    }
    ///Gets the value of
    /// [`Self::integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated`]
    pub fn integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated(&self) -> bool {
        unsafe {
            std::mem::transmute(self.integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated as u8)
        }
    }
    ///Gets the value of
    /// [`Self::integer_dot_product_accumulating_saturating64_bit_signed_accelerated`]
    pub fn integer_dot_product_accumulating_saturating64_bit_signed_accelerated(&self) -> bool {
        unsafe { std::mem::transmute(self.integer_dot_product_accumulating_saturating64_bit_signed_accelerated as u8) }
    }
    ///Gets the value of
    /// [`Self::integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated`]
    pub fn integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated(&self) -> bool {
        unsafe {
            std::mem::transmute(
                self.integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated as u8,
            )
        }
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next_mut(&mut self) -> &mut BaseOutStructure<'lt> {
        &mut *self.p_next
    }
    ///Gets a mutable reference to the value of
    /// [`Self::integer_dot_product8_bit_unsigned_accelerated`]
    pub fn integer_dot_product8_bit_unsigned_accelerated_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.integer_dot_product8_bit_unsigned_accelerated as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.integer_dot_product8_bit_unsigned_accelerated as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of
    /// [`Self::integer_dot_product8_bit_signed_accelerated`]
    pub fn integer_dot_product8_bit_signed_accelerated_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.integer_dot_product8_bit_signed_accelerated as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.integer_dot_product8_bit_signed_accelerated as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of
    /// [`Self::integer_dot_product8_bit_mixed_signedness_accelerated`]
    pub fn integer_dot_product8_bit_mixed_signedness_accelerated_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.integer_dot_product8_bit_mixed_signedness_accelerated as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.integer_dot_product8_bit_mixed_signedness_accelerated as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of
    /// [`Self::integer_dot_product4x8_bit_packed_unsigned_accelerated`]
    pub fn integer_dot_product4x8_bit_packed_unsigned_accelerated_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.integer_dot_product4x8_bit_packed_unsigned_accelerated as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.integer_dot_product4x8_bit_packed_unsigned_accelerated as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of
    /// [`Self::integer_dot_product4x8_bit_packed_signed_accelerated`]
    pub fn integer_dot_product4x8_bit_packed_signed_accelerated_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.integer_dot_product4x8_bit_packed_signed_accelerated as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.integer_dot_product4x8_bit_packed_signed_accelerated as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of
    /// [`Self::integer_dot_product4x8_bit_packed_mixed_signedness_accelerated`]
    pub fn integer_dot_product4x8_bit_packed_mixed_signedness_accelerated_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.integer_dot_product4x8_bit_packed_mixed_signedness_accelerated as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.integer_dot_product4x8_bit_packed_mixed_signedness_accelerated as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of
    /// [`Self::integer_dot_product16_bit_unsigned_accelerated`]
    pub fn integer_dot_product16_bit_unsigned_accelerated_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.integer_dot_product16_bit_unsigned_accelerated as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.integer_dot_product16_bit_unsigned_accelerated as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of
    /// [`Self::integer_dot_product16_bit_signed_accelerated`]
    pub fn integer_dot_product16_bit_signed_accelerated_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.integer_dot_product16_bit_signed_accelerated as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.integer_dot_product16_bit_signed_accelerated as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of
    /// [`Self::integer_dot_product16_bit_mixed_signedness_accelerated`]
    pub fn integer_dot_product16_bit_mixed_signedness_accelerated_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.integer_dot_product16_bit_mixed_signedness_accelerated as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.integer_dot_product16_bit_mixed_signedness_accelerated as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of
    /// [`Self::integer_dot_product32_bit_unsigned_accelerated`]
    pub fn integer_dot_product32_bit_unsigned_accelerated_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.integer_dot_product32_bit_unsigned_accelerated as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.integer_dot_product32_bit_unsigned_accelerated as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of
    /// [`Self::integer_dot_product32_bit_signed_accelerated`]
    pub fn integer_dot_product32_bit_signed_accelerated_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.integer_dot_product32_bit_signed_accelerated as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.integer_dot_product32_bit_signed_accelerated as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of
    /// [`Self::integer_dot_product32_bit_mixed_signedness_accelerated`]
    pub fn integer_dot_product32_bit_mixed_signedness_accelerated_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.integer_dot_product32_bit_mixed_signedness_accelerated as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.integer_dot_product32_bit_mixed_signedness_accelerated as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of
    /// [`Self::integer_dot_product64_bit_unsigned_accelerated`]
    pub fn integer_dot_product64_bit_unsigned_accelerated_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.integer_dot_product64_bit_unsigned_accelerated as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.integer_dot_product64_bit_unsigned_accelerated as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of
    /// [`Self::integer_dot_product64_bit_signed_accelerated`]
    pub fn integer_dot_product64_bit_signed_accelerated_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.integer_dot_product64_bit_signed_accelerated as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.integer_dot_product64_bit_signed_accelerated as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of
    /// [`Self::integer_dot_product64_bit_mixed_signedness_accelerated`]
    pub fn integer_dot_product64_bit_mixed_signedness_accelerated_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.integer_dot_product64_bit_mixed_signedness_accelerated as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.integer_dot_product64_bit_mixed_signedness_accelerated as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of
    /// [`Self::integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated`]
    pub fn integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of
    /// [`Self::integer_dot_product_accumulating_saturating8_bit_signed_accelerated`]
    pub fn integer_dot_product_accumulating_saturating8_bit_signed_accelerated_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.integer_dot_product_accumulating_saturating8_bit_signed_accelerated as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.integer_dot_product_accumulating_saturating8_bit_signed_accelerated as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of
    /// [`Self::integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated`]
    pub fn integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated
                    as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated
                    as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of
    /// [`Self::integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated`]
    pub fn integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated
                    as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated
                    as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of
    /// [`Self::integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated`]
    pub fn integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of
    /// [`Self::integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated`]
    pub fn integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated_mut(
        &mut self,
    ) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated
                    as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated
                    as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of
    /// [`Self::integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated`]
    pub fn integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of
    /// [`Self::integer_dot_product_accumulating_saturating16_bit_signed_accelerated`]
    pub fn integer_dot_product_accumulating_saturating16_bit_signed_accelerated_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.integer_dot_product_accumulating_saturating16_bit_signed_accelerated as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.integer_dot_product_accumulating_saturating16_bit_signed_accelerated as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of
    /// [`Self::integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated`]
    pub fn integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated
                    as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated
                    as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of
    /// [`Self::integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated`]
    pub fn integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of
    /// [`Self::integer_dot_product_accumulating_saturating32_bit_signed_accelerated`]
    pub fn integer_dot_product_accumulating_saturating32_bit_signed_accelerated_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.integer_dot_product_accumulating_saturating32_bit_signed_accelerated as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.integer_dot_product_accumulating_saturating32_bit_signed_accelerated as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of
    /// [`Self::integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated`]
    pub fn integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated
                    as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated
                    as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of
    /// [`Self::integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated`]
    pub fn integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of
    /// [`Self::integer_dot_product_accumulating_saturating64_bit_signed_accelerated`]
    pub fn integer_dot_product_accumulating_saturating64_bit_signed_accelerated_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.integer_dot_product_accumulating_saturating64_bit_signed_accelerated as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.integer_dot_product_accumulating_saturating64_bit_signed_accelerated as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of
    /// [`Self::integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated`]
    pub fn integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated
                    as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated
                    as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Sets the value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt mut crate::vulkan1_0::BaseOutStructure<'lt>) -> &mut Self {
        self.p_next = value as *mut _;
        self
    }
    ///Sets the value of [`Self::integer_dot_product8_bit_unsigned_accelerated`]
    pub fn set_integer_dot_product8_bit_unsigned_accelerated(&mut self, value: bool) -> &mut Self {
        self.integer_dot_product8_bit_unsigned_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::integer_dot_product8_bit_signed_accelerated`]
    pub fn set_integer_dot_product8_bit_signed_accelerated(&mut self, value: bool) -> &mut Self {
        self.integer_dot_product8_bit_signed_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::integer_dot_product8_bit_mixed_signedness_accelerated`]
    pub fn set_integer_dot_product8_bit_mixed_signedness_accelerated(&mut self, value: bool) -> &mut Self {
        self.integer_dot_product8_bit_mixed_signedness_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::integer_dot_product4x8_bit_packed_unsigned_accelerated`]
    pub fn set_integer_dot_product4x8_bit_packed_unsigned_accelerated(&mut self, value: bool) -> &mut Self {
        self.integer_dot_product4x8_bit_packed_unsigned_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::integer_dot_product4x8_bit_packed_signed_accelerated`]
    pub fn set_integer_dot_product4x8_bit_packed_signed_accelerated(&mut self, value: bool) -> &mut Self {
        self.integer_dot_product4x8_bit_packed_signed_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::integer_dot_product4x8_bit_packed_mixed_signedness_accelerated`]
    pub fn set_integer_dot_product4x8_bit_packed_mixed_signedness_accelerated(&mut self, value: bool) -> &mut Self {
        self.integer_dot_product4x8_bit_packed_mixed_signedness_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::integer_dot_product16_bit_unsigned_accelerated`]
    pub fn set_integer_dot_product16_bit_unsigned_accelerated(&mut self, value: bool) -> &mut Self {
        self.integer_dot_product16_bit_unsigned_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::integer_dot_product16_bit_signed_accelerated`]
    pub fn set_integer_dot_product16_bit_signed_accelerated(&mut self, value: bool) -> &mut Self {
        self.integer_dot_product16_bit_signed_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::integer_dot_product16_bit_mixed_signedness_accelerated`]
    pub fn set_integer_dot_product16_bit_mixed_signedness_accelerated(&mut self, value: bool) -> &mut Self {
        self.integer_dot_product16_bit_mixed_signedness_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::integer_dot_product32_bit_unsigned_accelerated`]
    pub fn set_integer_dot_product32_bit_unsigned_accelerated(&mut self, value: bool) -> &mut Self {
        self.integer_dot_product32_bit_unsigned_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::integer_dot_product32_bit_signed_accelerated`]
    pub fn set_integer_dot_product32_bit_signed_accelerated(&mut self, value: bool) -> &mut Self {
        self.integer_dot_product32_bit_signed_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::integer_dot_product32_bit_mixed_signedness_accelerated`]
    pub fn set_integer_dot_product32_bit_mixed_signedness_accelerated(&mut self, value: bool) -> &mut Self {
        self.integer_dot_product32_bit_mixed_signedness_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::integer_dot_product64_bit_unsigned_accelerated`]
    pub fn set_integer_dot_product64_bit_unsigned_accelerated(&mut self, value: bool) -> &mut Self {
        self.integer_dot_product64_bit_unsigned_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::integer_dot_product64_bit_signed_accelerated`]
    pub fn set_integer_dot_product64_bit_signed_accelerated(&mut self, value: bool) -> &mut Self {
        self.integer_dot_product64_bit_signed_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::integer_dot_product64_bit_mixed_signedness_accelerated`]
    pub fn set_integer_dot_product64_bit_mixed_signedness_accelerated(&mut self, value: bool) -> &mut Self {
        self.integer_dot_product64_bit_mixed_signedness_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of
    /// [`Self::integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated`]
    pub fn set_integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated(
        &mut self,
        value: bool,
    ) -> &mut Self {
        self.integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of
    /// [`Self::integer_dot_product_accumulating_saturating8_bit_signed_accelerated`]
    pub fn set_integer_dot_product_accumulating_saturating8_bit_signed_accelerated(
        &mut self,
        value: bool,
    ) -> &mut Self {
        self.integer_dot_product_accumulating_saturating8_bit_signed_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of
    /// [`Self::integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated`]
    pub fn set_integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated(
        &mut self,
        value: bool,
    ) -> &mut Self {
        self.integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of
    /// [`Self::integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated`]
    pub fn set_integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated(
        &mut self,
        value: bool,
    ) -> &mut Self {
        self.integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of
    /// [`Self::integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated`]
    pub fn set_integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated(
        &mut self,
        value: bool,
    ) -> &mut Self {
        self.integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of
    /// [`Self::integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated`]
    pub fn set_integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated(
        &mut self,
        value: bool,
    ) -> &mut Self {
        self.integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated =
            value as u8 as u32;
        self
    }
    ///Sets the value of
    /// [`Self::integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated`]
    pub fn set_integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated(
        &mut self,
        value: bool,
    ) -> &mut Self {
        self.integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of
    /// [`Self::integer_dot_product_accumulating_saturating16_bit_signed_accelerated`]
    pub fn set_integer_dot_product_accumulating_saturating16_bit_signed_accelerated(
        &mut self,
        value: bool,
    ) -> &mut Self {
        self.integer_dot_product_accumulating_saturating16_bit_signed_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of
    /// [`Self::integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated`]
    pub fn set_integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated(
        &mut self,
        value: bool,
    ) -> &mut Self {
        self.integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of
    /// [`Self::integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated`]
    pub fn set_integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated(
        &mut self,
        value: bool,
    ) -> &mut Self {
        self.integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of
    /// [`Self::integer_dot_product_accumulating_saturating32_bit_signed_accelerated`]
    pub fn set_integer_dot_product_accumulating_saturating32_bit_signed_accelerated(
        &mut self,
        value: bool,
    ) -> &mut Self {
        self.integer_dot_product_accumulating_saturating32_bit_signed_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of
    /// [`Self::integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated`]
    pub fn set_integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated(
        &mut self,
        value: bool,
    ) -> &mut Self {
        self.integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of
    /// [`Self::integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated`]
    pub fn set_integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated(
        &mut self,
        value: bool,
    ) -> &mut Self {
        self.integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of
    /// [`Self::integer_dot_product_accumulating_saturating64_bit_signed_accelerated`]
    pub fn set_integer_dot_product_accumulating_saturating64_bit_signed_accelerated(
        &mut self,
        value: bool,
    ) -> &mut Self {
        self.integer_dot_product_accumulating_saturating64_bit_signed_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of
    /// [`Self::integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated`]
    pub fn set_integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated(
        &mut self,
        value: bool,
    ) -> &mut Self {
        self.integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::s_type`]
    pub fn with_s_type(mut self, value: crate::vulkan1_0::StructureType) -> Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn with_p_next(mut self, value: &'lt mut crate::vulkan1_0::BaseOutStructure<'lt>) -> Self {
        self.p_next = value as *mut _;
        self
    }
    ///Sets the value of [`Self::integer_dot_product8_bit_unsigned_accelerated`]
    pub fn with_integer_dot_product8_bit_unsigned_accelerated(mut self, value: bool) -> Self {
        self.integer_dot_product8_bit_unsigned_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::integer_dot_product8_bit_signed_accelerated`]
    pub fn with_integer_dot_product8_bit_signed_accelerated(mut self, value: bool) -> Self {
        self.integer_dot_product8_bit_signed_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::integer_dot_product8_bit_mixed_signedness_accelerated`]
    pub fn with_integer_dot_product8_bit_mixed_signedness_accelerated(mut self, value: bool) -> Self {
        self.integer_dot_product8_bit_mixed_signedness_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::integer_dot_product4x8_bit_packed_unsigned_accelerated`]
    pub fn with_integer_dot_product4x8_bit_packed_unsigned_accelerated(mut self, value: bool) -> Self {
        self.integer_dot_product4x8_bit_packed_unsigned_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::integer_dot_product4x8_bit_packed_signed_accelerated`]
    pub fn with_integer_dot_product4x8_bit_packed_signed_accelerated(mut self, value: bool) -> Self {
        self.integer_dot_product4x8_bit_packed_signed_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::integer_dot_product4x8_bit_packed_mixed_signedness_accelerated`]
    pub fn with_integer_dot_product4x8_bit_packed_mixed_signedness_accelerated(mut self, value: bool) -> Self {
        self.integer_dot_product4x8_bit_packed_mixed_signedness_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::integer_dot_product16_bit_unsigned_accelerated`]
    pub fn with_integer_dot_product16_bit_unsigned_accelerated(mut self, value: bool) -> Self {
        self.integer_dot_product16_bit_unsigned_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::integer_dot_product16_bit_signed_accelerated`]
    pub fn with_integer_dot_product16_bit_signed_accelerated(mut self, value: bool) -> Self {
        self.integer_dot_product16_bit_signed_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::integer_dot_product16_bit_mixed_signedness_accelerated`]
    pub fn with_integer_dot_product16_bit_mixed_signedness_accelerated(mut self, value: bool) -> Self {
        self.integer_dot_product16_bit_mixed_signedness_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::integer_dot_product32_bit_unsigned_accelerated`]
    pub fn with_integer_dot_product32_bit_unsigned_accelerated(mut self, value: bool) -> Self {
        self.integer_dot_product32_bit_unsigned_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::integer_dot_product32_bit_signed_accelerated`]
    pub fn with_integer_dot_product32_bit_signed_accelerated(mut self, value: bool) -> Self {
        self.integer_dot_product32_bit_signed_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::integer_dot_product32_bit_mixed_signedness_accelerated`]
    pub fn with_integer_dot_product32_bit_mixed_signedness_accelerated(mut self, value: bool) -> Self {
        self.integer_dot_product32_bit_mixed_signedness_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::integer_dot_product64_bit_unsigned_accelerated`]
    pub fn with_integer_dot_product64_bit_unsigned_accelerated(mut self, value: bool) -> Self {
        self.integer_dot_product64_bit_unsigned_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::integer_dot_product64_bit_signed_accelerated`]
    pub fn with_integer_dot_product64_bit_signed_accelerated(mut self, value: bool) -> Self {
        self.integer_dot_product64_bit_signed_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::integer_dot_product64_bit_mixed_signedness_accelerated`]
    pub fn with_integer_dot_product64_bit_mixed_signedness_accelerated(mut self, value: bool) -> Self {
        self.integer_dot_product64_bit_mixed_signedness_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of
    /// [`Self::integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated`]
    pub fn with_integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated(mut self, value: bool) -> Self {
        self.integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of
    /// [`Self::integer_dot_product_accumulating_saturating8_bit_signed_accelerated`]
    pub fn with_integer_dot_product_accumulating_saturating8_bit_signed_accelerated(mut self, value: bool) -> Self {
        self.integer_dot_product_accumulating_saturating8_bit_signed_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of
    /// [`Self::integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated`]
    pub fn with_integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated(
        mut self,
        value: bool,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of
    /// [`Self::integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated`]
    pub fn with_integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated(
        mut self,
        value: bool,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of
    /// [`Self::integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated`]
    pub fn with_integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated(
        mut self,
        value: bool,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of
    /// [`Self::integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated`]
    pub fn with_integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated(
        mut self,
        value: bool,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated =
            value as u8 as u32;
        self
    }
    ///Sets the value of
    /// [`Self::integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated`]
    pub fn with_integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated(mut self, value: bool) -> Self {
        self.integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of
    /// [`Self::integer_dot_product_accumulating_saturating16_bit_signed_accelerated`]
    pub fn with_integer_dot_product_accumulating_saturating16_bit_signed_accelerated(mut self, value: bool) -> Self {
        self.integer_dot_product_accumulating_saturating16_bit_signed_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of
    /// [`Self::integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated`]
    pub fn with_integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated(
        mut self,
        value: bool,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of
    /// [`Self::integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated`]
    pub fn with_integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated(mut self, value: bool) -> Self {
        self.integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of
    /// [`Self::integer_dot_product_accumulating_saturating32_bit_signed_accelerated`]
    pub fn with_integer_dot_product_accumulating_saturating32_bit_signed_accelerated(mut self, value: bool) -> Self {
        self.integer_dot_product_accumulating_saturating32_bit_signed_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of
    /// [`Self::integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated`]
    pub fn with_integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated(
        mut self,
        value: bool,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of
    /// [`Self::integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated`]
    pub fn with_integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated(mut self, value: bool) -> Self {
        self.integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of
    /// [`Self::integer_dot_product_accumulating_saturating64_bit_signed_accelerated`]
    pub fn with_integer_dot_product_accumulating_saturating64_bit_signed_accelerated(mut self, value: bool) -> Self {
        self.integer_dot_product_accumulating_saturating64_bit_signed_accelerated = value as u8 as u32;
        self
    }
    ///Sets the value of
    /// [`Self::integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated`]
    pub fn with_integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated(
        mut self,
        value: bool,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated = value as u8 as u32;
        self
    }
}
///[VkFormatProperties3](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFormatProperties3.html) - Structure specifying image format properties
///# C Specifications
///To query supported format extended features which are properties of the
///physical device, add [`FormatProperties3`] structure to the [`p_next`]
///chain of [`FormatProperties2`].The [`FormatProperties3`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_3
///typedef struct VkFormatProperties3 {
///    VkStructureType          sType;
///    void*                    pNext;
///    VkFormatFeatureFlags2    linearTilingFeatures;
///    VkFormatFeatureFlags2    optimalTilingFeatures;
///    VkFormatFeatureFlags2    bufferFeatures;
///} VkFormatProperties3;
///```
///or the equivalent
///```c
///// Provided by VK_KHR_format_feature_flags2
///typedef VkFormatProperties3 VkFormatProperties3KHR;
///```
///# Members
/// - [`linear_tiling_features`] is a bitmask of [`FormatFeatureFlagBits2`] specifying features
///   supported by images created with a `tiling` parameter of `VK_IMAGE_TILING_LINEAR`.
/// - [`optimal_tiling_features`] is a bitmask of [`FormatFeatureFlagBits2`] specifying features
///   supported by images created with a `tiling` parameter of `VK_IMAGE_TILING_OPTIMAL`.
/// - [`buffer_features`] is a bitmask of [`FormatFeatureFlagBits2`] specifying features supported
///   by buffers.
///# Description
///The bits reported in [`linear_tiling_features`], [`optimal_tiling_features`]
///and [`buffer_features`] **must**  include the bits reported in the
///corresponding fields of [`FormatProperties2::format_properties`].
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be `VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3`
///# Related
/// - [`khr_format_feature_flags2`]
/// - [`crate::vulkan1_3`]
/// - [`FormatFeatureFlags2`]
/// - [`StructureType`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkFormatProperties3")]
#[derive(Debug, Clone, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[repr(C)]
pub struct FormatProperties3<'lt> {
    ///Lifetime field
    pub _lifetime: PhantomData<&'lt ()>,
    ///No documentation found
    pub s_type: StructureType,
    ///No documentation found
    pub p_next: *mut BaseOutStructure<'lt>,
    ///[`linear_tiling_features`] is a bitmask of
    ///[`FormatFeatureFlagBits2`] specifying features supported by images
    ///created with a `tiling` parameter of `VK_IMAGE_TILING_LINEAR`.
    pub linear_tiling_features: FormatFeatureFlags2,
    ///[`optimal_tiling_features`] is a bitmask of
    ///[`FormatFeatureFlagBits2`] specifying features supported by images
    ///created with a `tiling` parameter of `VK_IMAGE_TILING_OPTIMAL`.
    pub optimal_tiling_features: FormatFeatureFlags2,
    ///[`buffer_features`] is a bitmask of [`FormatFeatureFlagBits2`]
    ///specifying features supported by buffers.
    pub buffer_features: FormatFeatureFlags2,
}
impl<'lt> Default for FormatProperties3<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: StructureType::FORMAT_PROPERTIES3,
            p_next: std::ptr::null_mut(),
            linear_tiling_features: Default::default(),
            optimal_tiling_features: Default::default(),
            buffer_features: Default::default(),
        }
    }
}
impl<'lt> FormatProperties3<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *mut BaseOutStructure<'lt> {
        self.p_next
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *mut BaseOutStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn with_p_next_raw(mut self, value: *mut BaseOutStructure<'lt>) -> Self {
        self.p_next = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseOutStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::linear_tiling_features`]
    pub fn linear_tiling_features(&self) -> FormatFeatureFlags2 {
        self.linear_tiling_features
    }
    ///Gets the value of [`Self::optimal_tiling_features`]
    pub fn optimal_tiling_features(&self) -> FormatFeatureFlags2 {
        self.optimal_tiling_features
    }
    ///Gets the value of [`Self::buffer_features`]
    pub fn buffer_features(&self) -> FormatFeatureFlags2 {
        self.buffer_features
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next_mut(&mut self) -> &mut BaseOutStructure<'lt> {
        &mut *self.p_next
    }
    ///Gets a mutable reference to the value of [`Self::linear_tiling_features`]
    pub fn linear_tiling_features_mut(&mut self) -> &mut FormatFeatureFlags2 {
        &mut self.linear_tiling_features
    }
    ///Gets a mutable reference to the value of [`Self::optimal_tiling_features`]
    pub fn optimal_tiling_features_mut(&mut self) -> &mut FormatFeatureFlags2 {
        &mut self.optimal_tiling_features
    }
    ///Gets a mutable reference to the value of [`Self::buffer_features`]
    pub fn buffer_features_mut(&mut self) -> &mut FormatFeatureFlags2 {
        &mut self.buffer_features
    }
    ///Sets the value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt mut crate::vulkan1_0::BaseOutStructure<'lt>) -> &mut Self {
        self.p_next = value as *mut _;
        self
    }
    ///Sets the value of [`Self::linear_tiling_features`]
    pub fn set_linear_tiling_features(&mut self, value: crate::vulkan1_3::FormatFeatureFlags2) -> &mut Self {
        self.linear_tiling_features = value;
        self
    }
    ///Sets the value of [`Self::optimal_tiling_features`]
    pub fn set_optimal_tiling_features(&mut self, value: crate::vulkan1_3::FormatFeatureFlags2) -> &mut Self {
        self.optimal_tiling_features = value;
        self
    }
    ///Sets the value of [`Self::buffer_features`]
    pub fn set_buffer_features(&mut self, value: crate::vulkan1_3::FormatFeatureFlags2) -> &mut Self {
        self.buffer_features = value;
        self
    }
    ///Sets the value of [`Self::s_type`]
    pub fn with_s_type(mut self, value: crate::vulkan1_0::StructureType) -> Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn with_p_next(mut self, value: &'lt mut crate::vulkan1_0::BaseOutStructure<'lt>) -> Self {
        self.p_next = value as *mut _;
        self
    }
    ///Sets the value of [`Self::linear_tiling_features`]
    pub fn with_linear_tiling_features(mut self, value: crate::vulkan1_3::FormatFeatureFlags2) -> Self {
        self.linear_tiling_features = value;
        self
    }
    ///Sets the value of [`Self::optimal_tiling_features`]
    pub fn with_optimal_tiling_features(mut self, value: crate::vulkan1_3::FormatFeatureFlags2) -> Self {
        self.optimal_tiling_features = value;
        self
    }
    ///Sets the value of [`Self::buffer_features`]
    pub fn with_buffer_features(mut self, value: crate::vulkan1_3::FormatFeatureFlags2) -> Self {
        self.buffer_features = value;
        self
    }
}
///[VkPipelineRenderingCreateInfo](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineRenderingCreateInfo.html) - Structure specifying attachment formats
///# C Specifications
///The [`PipelineRenderingCreateInfo`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_3
///typedef struct VkPipelineRenderingCreateInfo {
///    VkStructureType    sType;
///    const void*        pNext;
///    uint32_t           viewMask;
///    uint32_t           colorAttachmentCount;
///    const VkFormat*    pColorAttachmentFormats;
///    VkFormat           depthAttachmentFormat;
///    VkFormat           stencilAttachmentFormat;
///} VkPipelineRenderingCreateInfo;
///```
///or the equivalent
///```c
///// Provided by VK_KHR_dynamic_rendering
///typedef VkPipelineRenderingCreateInfo VkPipelineRenderingCreateInfoKHR;
///```
///# Members
/// - [`s_type`] is the type of this structure.
/// - [`p_next`] is `NULL` or a pointer to a structure extending this structure.
/// - [`view_mask`] is the viewMask used for rendering.
/// - [`color_attachment_count`] is the number of entries in [`color_attachment_formats`]
/// - [`color_attachment_formats`] is a pointer to an array of [`Format`] values defining the format
///   of color attachments used in this pipeline.
/// - [`depth_attachment_format`] is a [`Format`] value defining the format of the depth attachment
///   used in this pipeline.
/// - [`stencil_attachment_format`] is a [`Format`] value defining the format of the stencil
///   attachment used in this pipeline.
///# Description
///When a pipeline is created without a [`RenderPass`], if this structure
///is present in the [`p_next`] chain of [`GraphicsPipelineCreateInfo`],
///it specifies the view mask and format of attachments used for rendering.
///If this structure is not specified, and the pipeline does not include a
///[`RenderPass`], [`view_mask`] and [`color_attachment_count`] are `0`,
///and [`depth_attachment_format`] and [`stencil_attachment_format`] are
///`VK_FORMAT_UNDEFINED`.
///If a graphics pipeline is created with a valid [`RenderPass`],
///parameters of this structure are ignored.If [`depth_attachment_format`],
/// [`stencil_attachment_format`], or any
///element of [`color_attachment_formats`] is `VK_FORMAT_UNDEFINED`, it
///indicates that the corresponding attachment is unused within the render
///pass.
///Valid formats indicate that an attachment  **can**  be used - but it is still
///valid to set the attachment to `NULL` when beginning rendering.
///## Valid Usage
/// -    If any element of [`color_attachment_formats`] is not `VK_FORMAT_UNDEFINED`, it  **must**  be a format with [potential format features](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#potential-format-features) that includes either `VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT` or `VK_FORMAT_FEATURE_2_LINEAR_COLOR_ATTACHMENT_BIT_NV`
/// - If [`depth_attachment_format`] is not `VK_FORMAT_UNDEFINED`, it  **must**  be a format that
///   includes a depth aspect
/// - If [`stencil_attachment_format`] is not `VK_FORMAT_UNDEFINED`, it  **must**  be a format that
///   includes a stencil aspect
/// -    If [`depth_attachment_format`] is not `VK_FORMAT_UNDEFINED`, it  **must**  be a format with [potential format features](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#potential-format-features) that include `VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT`
/// -    If [`stencil_attachment_format`] is not `VK_FORMAT_UNDEFINED`, it  **must**  be a format with [potential format features](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#potential-format-features) that include `VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT`
/// - If [`depth_attachment_format`] is not `VK_FORMAT_UNDEFINED` and [`stencil_attachment_format`]
///   is not `VK_FORMAT_UNDEFINED`, [`depth_attachment_format`] **must**  equal
///   [`stencil_attachment_format`]
/// - If the [`multiview`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-multiview)
///   feature is not enabled, [`view_mask`] **must**  be `0`
/// - The index of the most significant bit in [`view_mask`] **must**  be less than [`maxMultiviewViewCount`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#limits-maxMultiviewViewCount)
///
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be `VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO`
/// - If [`color_attachment_count`] is not `0`, [`color_attachment_formats`] **must**  be a valid
///   pointer to an array of [`color_attachment_count`] valid [`Format`] values
/// - [`depth_attachment_format`] **must**  be a valid [`Format`] value
/// - [`stencil_attachment_format`] **must**  be a valid [`Format`] value
///# Related
/// - [`khr_dynamic_rendering`]
/// - [`crate::vulkan1_3`]
/// - [`Format`]
/// - [`StructureType`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkPipelineRenderingCreateInfo")]
#[derive(Debug, Clone, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[repr(C)]
pub struct PipelineRenderingCreateInfo<'lt> {
    ///Lifetime field
    pub _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] is the type of this structure.
    pub s_type: StructureType,
    ///[`p_next`] is `NULL` or a pointer to a structure extending this
    ///structure.
    pub p_next: *const BaseInStructure<'lt>,
    ///[`view_mask`] is the viewMask used for rendering.
    pub view_mask: u32,
    ///[`color_attachment_count`] is the number of entries in
    ///[`color_attachment_formats`]
    pub color_attachment_count: u32,
    ///[`color_attachment_formats`] is a pointer to an array of [`Format`]
    ///values defining the format of color attachments used in this pipeline.
    pub color_attachment_formats: *const Format,
    ///[`depth_attachment_format`] is a [`Format`] value defining the
    ///format of the depth attachment used in this pipeline.
    pub depth_attachment_format: Format,
    ///[`stencil_attachment_format`] is a [`Format`] value defining the
    ///format of the stencil attachment used in this pipeline.
    pub stencil_attachment_format: Format,
}
impl<'lt> Default for PipelineRenderingCreateInfo<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: StructureType::PIPELINE_RENDERING_CREATE_INFO,
            p_next: std::ptr::null(),
            view_mask: 0,
            color_attachment_count: 0,
            color_attachment_formats: std::ptr::null(),
            depth_attachment_format: Default::default(),
            stencil_attachment_format: Default::default(),
        }
    }
}
impl<'lt> PipelineRenderingCreateInfo<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *const BaseInStructure<'lt> {
        self.p_next
    }
    ///Gets the raw value of [`Self::color_attachment_formats`]
    pub fn color_attachment_formats_raw(&self) -> *const Format {
        self.color_attachment_formats
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *const BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::color_attachment_formats`]
    pub fn set_color_attachment_formats_raw(&mut self, value: *const Format) -> &mut Self {
        self.color_attachment_formats = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn with_p_next_raw(mut self, value: *const BaseInStructure<'lt>) -> Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::color_attachment_formats`]
    pub fn with_color_attachment_formats_raw(mut self, value: *const Format) -> Self {
        self.color_attachment_formats = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseInStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::view_mask`]
    pub fn view_mask(&self) -> u32 {
        self.view_mask
    }
    ///Gets the value of [`Self::color_attachment_count`]
    pub fn color_attachment_count(&self) -> u32 {
        self.color_attachment_count
    }
    ///Gets the value of [`Self::color_attachment_formats`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn color_attachment_formats(&self) -> &[Format] {
        std::slice::from_raw_parts(self.color_attachment_formats, self.color_attachment_count as usize)
    }
    ///Gets the value of [`Self::depth_attachment_format`]
    pub fn depth_attachment_format(&self) -> Format {
        self.depth_attachment_format
    }
    ///Gets the value of [`Self::stencil_attachment_format`]
    pub fn stencil_attachment_format(&self) -> Format {
        self.stencil_attachment_format
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::view_mask`]
    pub fn view_mask_mut(&mut self) -> &mut u32 {
        &mut self.view_mask
    }
    ///Gets a mutable reference to the value of [`Self::color_attachment_count`]
    pub fn color_attachment_count_mut(&mut self) -> &mut u32 {
        &mut self.color_attachment_count
    }
    ///Gets a mutable reference to the value of [`Self::depth_attachment_format`]
    pub fn depth_attachment_format_mut(&mut self) -> &mut Format {
        &mut self.depth_attachment_format
    }
    ///Gets a mutable reference to the value of [`Self::stencil_attachment_format`]
    pub fn stencil_attachment_format_mut(&mut self) -> &mut Format {
        &mut self.stencil_attachment_format
    }
    ///Sets the value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the value of [`Self::view_mask`]
    pub fn set_view_mask(&mut self, value: u32) -> &mut Self {
        self.view_mask = value;
        self
    }
    ///Sets the value of [`Self::color_attachment_count`]
    pub fn set_color_attachment_count(&mut self, value: u32) -> &mut Self {
        self.color_attachment_count = value;
        self
    }
    ///Sets the value of [`Self::color_attachment_formats`]
    pub fn set_color_attachment_formats(&mut self, value: &'lt [crate::vulkan1_0::Format]) -> &mut Self {
        let len_ = value.len() as u32;
        let len_ = len_;
        self.color_attachment_formats = value.as_ptr();
        self.color_attachment_count = len_;
        self
    }
    ///Sets the value of [`Self::depth_attachment_format`]
    pub fn set_depth_attachment_format(&mut self, value: crate::vulkan1_0::Format) -> &mut Self {
        self.depth_attachment_format = value;
        self
    }
    ///Sets the value of [`Self::stencil_attachment_format`]
    pub fn set_stencil_attachment_format(&mut self, value: crate::vulkan1_0::Format) -> &mut Self {
        self.stencil_attachment_format = value;
        self
    }
    ///Sets the value of [`Self::s_type`]
    pub fn with_s_type(mut self, value: crate::vulkan1_0::StructureType) -> Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn with_p_next(mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the value of [`Self::view_mask`]
    pub fn with_view_mask(mut self, value: u32) -> Self {
        self.view_mask = value;
        self
    }
    ///Sets the value of [`Self::color_attachment_count`]
    pub fn with_color_attachment_count(mut self, value: u32) -> Self {
        self.color_attachment_count = value;
        self
    }
    ///Sets the value of [`Self::color_attachment_formats`]
    pub fn with_color_attachment_formats(mut self, value: &'lt [crate::vulkan1_0::Format]) -> Self {
        let len_ = value.len() as u32;
        let len_ = len_;
        self.color_attachment_formats = value.as_ptr();
        self.color_attachment_count = len_;
        self
    }
    ///Sets the value of [`Self::depth_attachment_format`]
    pub fn with_depth_attachment_format(mut self, value: crate::vulkan1_0::Format) -> Self {
        self.depth_attachment_format = value;
        self
    }
    ///Sets the value of [`Self::stencil_attachment_format`]
    pub fn with_stencil_attachment_format(mut self, value: crate::vulkan1_0::Format) -> Self {
        self.stencil_attachment_format = value;
        self
    }
}
///[VkRenderingInfo](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderingInfo.html) - Structure specifying render pass instance begin info
///# C Specifications
///The [`RenderingInfo`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_3
///typedef struct VkRenderingInfo {
///    VkStructureType                     sType;
///    const void*                         pNext;
///    VkRenderingFlags                    flags;
///    VkRect2D                            renderArea;
///    uint32_t                            layerCount;
///    uint32_t                            viewMask;
///    uint32_t                            colorAttachmentCount;
///    const VkRenderingAttachmentInfo*    pColorAttachments;
///    const VkRenderingAttachmentInfo*    pDepthAttachment;
///    const VkRenderingAttachmentInfo*    pStencilAttachment;
///} VkRenderingInfo;
///```
///or the equivalent
///```c
///// Provided by VK_KHR_dynamic_rendering
///typedef VkRenderingInfo VkRenderingInfoKHR;
///```
///# Members
/// - [`s_type`] is the type of this structure.
/// - [`p_next`] is `NULL` or a pointer to a structure extending this structure.
/// - [`flags`] is a bitmask of [`RenderingFlagBits`].
/// - [`render_area`] is the render area that is affected by the render pass instance.
/// - [`layer_count`] is the number of layers rendered to in each attachment when [`view_mask`] is
///   `0`.
/// - [`view_mask`] is the view mask indicating the indices of attachment layers that will be
///   rendered when it is not `0`.
/// - [`color_attachment_count`] is the number of elements in [`color_attachments`].
/// - [`color_attachments`] is a pointer to an array of
///   [`color_attachment_count`][`RenderingAttachmentInfo`] structures describing any color
///   attachments used.
/// - [`depth_attachment`] is a pointer to a [`RenderingAttachmentInfo`] structure describing a
///   depth attachment.
/// - [`stencil_attachment`] is a pointer to a [`RenderingAttachmentInfo`] structure describing a
///   stencil attachment.
///# Description
///If [`view_mask`] is not `0`, multiview is enabled.If there is an instance of
/// [`DeviceGroupRenderPassBeginInfo`] included
///in the [`p_next`] chain and its `deviceCount` member is not `0`, then
///[`render_area`] is ignored, and the render area is defined per-device by
///that structure.Each element of the [`color_attachments`] array corresponds to an output
///location in the shader, i.e. if the shader declares an output variable
///decorated with a `Location` value of  **X** , then it uses the attachment
///provided in [`color_attachments`][ **X** ].
///If the `imageView` member of any element of [`color_attachments`] is
///[`crate::Handle::null`], writes to the corresponding location by a fragment are
///discarded.
///## Valid Usage
/// - If [`view_mask`] is `0`, [`layer_count`] **must**  not be `0`
/// - If neither the [`amd_mixed_attachment_samples`] nor the [`nv_framebuffer_mixed_samples`]
///   extensions are enabled, `imageView` members of [`depth_attachment`], [`stencil_attachment`],
///   and elements of [`color_attachments`] that are not [`crate::Handle::null`] **must**  have been
///   created with the same `sampleCount`
/// - If the [`p_next`] chain does not contain [`DeviceGroupRenderPassBeginInfo`] or its
///   `deviceRenderAreaCount` member is equal to 0, `renderArea.offset.x` **must**  be greater than
///   or equal to 0
/// - If the [`p_next`] chain does not contain [`DeviceGroupRenderPassBeginInfo`] or its
///   `deviceRenderAreaCount` member is equal to 0, `renderArea.offset.y` **must**  be greater than
///   or equal to 0
/// - If the [`p_next`] chain does not contain [`DeviceGroupRenderPassBeginInfo`] or its
///   `deviceRenderAreaCount` member is equal to 0, the width of the `imageView` member of any
///   element of [`color_attachments`], [`depth_attachment`], or [`stencil_attachment`] that is not
///   [`crate::Handle::null`] **must**  be greater than or equal to `renderArea.offset.x` +
///   `renderArea.extent.width`
/// - If the [`p_next`] chain does not contain [`DeviceGroupRenderPassBeginInfo`] or its
///   `deviceRenderAreaCount` member is equal to 0, the height of the `imageView` member of any
///   element of [`color_attachments`], [`depth_attachment`], or [`stencil_attachment`] that is not
///   [`crate::Handle::null`] **must**  be greater than or equal to `renderArea.offset.y` +
///   `renderArea.extent.height`
/// - If the [`p_next`] chain contains [`DeviceGroupRenderPassBeginInfo`], the width of the
///   `imageView` member of any element of [`color_attachments`], [`depth_attachment`], or
///   [`stencil_attachment`] that is not [`crate::Handle::null`] **must**  be greater than or equal
///   to the sum of the `offset.x` and `extent.width` members of each element of
///   `pDeviceRenderAreas`
/// - If the [`p_next`] chain contains [`DeviceGroupRenderPassBeginInfo`], the height of the
///   `imageView` member of any element of [`color_attachments`], [`depth_attachment`], or
///   [`stencil_attachment`] that is not [`crate::Handle::null`] **must**  be greater than or equal
///   to the sum of the `offset.y` and `extent.height` members of each element of
///   `pDeviceRenderAreas`
/// - If neither [`depth_attachment`] or [`stencil_attachment`] are `NULL` and the `imageView`
///   member of either structure is not [`crate::Handle::null`], the `imageView` member of each
///   structure  **must**  be the same
/// - If neither [`depth_attachment`] or [`stencil_attachment`] are `NULL`, and the `resolveMode`
///   member of each is not `VK_RESOLVE_MODE_NONE`, the `resolveImageView` member of each structure
///   **must**  be the same
/// - If [`color_attachment_count`] is not `0` and the `imageView` member of an element of
///   [`color_attachments`] is not [`crate::Handle::null`], that `imageView` **must**  have been
///   created with `VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT`
/// - If [`depth_attachment`] is not `NULL` and `pDepthAttachment->imageView` is not
///   [`crate::Handle::null`], `pDepthAttachment->imageView` **must**  have been created with a
///   format that includes a depth aspect
/// - If [`depth_attachment`] is not `NULL` and `pDepthAttachment->imageView` is not
///   [`crate::Handle::null`], `pDepthAttachment->imageView` **must**  have been created with
///   `VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT`
/// - If [`stencil_attachment`] is not `NULL` and `pStencilAttachment->imageView` is not
///   [`crate::Handle::null`], `pStencilAttachment->imageView` **must**  have been created with a
///   format that includes a stencil aspect
/// - If [`stencil_attachment`] is not `NULL` and `pStencilAttachment->imageView` is not
///   [`crate::Handle::null`], `pStencilAttachment->imageView` **must**  have been created with a
///   stencil usage including `VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT`
/// - If [`color_attachment_count`] is not `0` and the `imageView` member of an element of
///   [`color_attachments`] is not [`crate::Handle::null`], the `layout` member of that element of
///   [`color_attachments`] **must**  not be `VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL` or
///   `VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL`
/// - If [`color_attachment_count`] is not `0` and the `imageView` member of an element of
///   [`color_attachments`] is not [`crate::Handle::null`], if the `resolveMode` member of that
///   element of [`color_attachments`] is not `VK_RESOLVE_MODE_NONE`, its `resolveImageLayout`
///   member  **must**  not be `VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL` or
///   `VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL`
/// - If [`depth_attachment`] is not `NULL` and `pDepthAttachment->imageView` is not
///   [`crate::Handle::null`], `pDepthAttachment->layout` **must**  not be
///   `VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL`
/// - If [`depth_attachment`] is not `NULL`, `pDepthAttachment->imageView` is not
///   [`crate::Handle::null`], and `pDepthAttachment->resolveMode` is not `VK_RESOLVE_MODE_NONE`,
///   `pDepthAttachment->resolveImageLayout` **must**  not be
///   `VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL`
/// - If [`stencil_attachment`] is not `NULL` and `pStencilAttachment->imageView` is not
///   [`crate::Handle::null`], `pStencilAttachment->layout` **must**  not be
///   `VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL`
/// - If [`stencil_attachment`] is not `NULL`, `pStencilAttachment->imageView` is not
///   [`crate::Handle::null`], and `pStencilAttachment->resolveMode` is not `VK_RESOLVE_MODE_NONE`,
///   `pStencilAttachment->resolveImageLayout` **must**  not be
///   `VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL`
/// - If [`color_attachment_count`] is not `0` and the `imageView` member of an element of
///   [`color_attachments`] is not [`crate::Handle::null`], the `layout` member of that element of
///   [`color_attachments`] **must**  not be
///   `VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL` or
///   `VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL`
/// - If [`color_attachment_count`] is not `0` and the `imageView` member of an element of
///   [`color_attachments`] is not [`crate::Handle::null`], if the `resolveMode` member of that
///   element of [`color_attachments`] is not `VK_RESOLVE_MODE_NONE`, its `resolveImageLayout`
///   member  **must**  not be `VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL` or
///   `VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL`
/// - If [`depth_attachment`] is not `NULL`, `pDepthAttachment->imageView` is not
///   [`crate::Handle::null`], and `pDepthAttachment->resolveMode` is not `VK_RESOLVE_MODE_NONE`,
///   `pDepthAttachment->resolveImageLayout` **must**  not be
///   `VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL`
/// - If [`stencil_attachment`] is not `NULL`, `pStencilAttachment->imageView` is not
///   [`crate::Handle::null`], and `pStencilAttachment->resolveMode` is not `VK_RESOLVE_MODE_NONE`,
///   `pStencilAttachment->resolveImageLayout` **must**  not be
///   `VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL`
/// - If [`color_attachment_count`] is not `0` and the `imageView` member of an element of
///   [`color_attachments`] is not [`crate::Handle::null`], the `layout` member of that element of
///   [`color_attachments`] **must**  not be `VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL`,
///   `VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL`, `VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL`, or
///   `VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL`
/// - If [`color_attachment_count`] is not `0` and the `imageView` member of an element of
///   [`color_attachments`] is not [`crate::Handle::null`], if the `resolveMode` member of that
///   element of [`color_attachments`] is not `VK_RESOLVE_MODE_NONE`, its `resolveImageLayout`
///   member  **must**  not be `VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL`,
///   `VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL`, `VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL`, or
///   `VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL`
/// - If [`depth_attachment`] is not `NULL` and `pDepthAttachment->imageView` is not
///   [`crate::Handle::null`], `pDepthAttachment->resolveMode` **must**  be one of the bits set in
///   [`PhysicalDeviceDepthStencilResolveProperties::supported_depth_resolve_modes`]
/// - If [`stencil_attachment`] is not `NULL` and `pStencilAttachment->imageView` is not
///   [`crate::Handle::null`], `pStencilAttachment->resolveMode` **must**  be one of the bits set in
///   [`PhysicalDeviceDepthStencilResolveProperties::supported_stencil_resolve_modes`]
/// - If [`depth_attachment`] or [`stencil_attachment`] are both not `NULL`,
///   `pDepthAttachment->imageView` and `pStencilAttachment->imageView` are both not
///   [`crate::Handle::null`], and
///   [`PhysicalDeviceDepthStencilResolveProperties::independent_resolve_none`] is [`FALSE`], the
///   `resolveMode` of both structures  **must**  be the same value
/// - If [`depth_attachment`] or [`stencil_attachment`] are both not `NULL`,
///   `pDepthAttachment->imageView` and `pStencilAttachment->imageView` are both not
///   [`crate::Handle::null`], [`PhysicalDeviceDepthStencilResolveProperties::independent_resolve`]
///   is [`FALSE`], and the `resolveMode` of neither structure is `VK_RESOLVE_MODE_NONE`, the
///   `resolveMode` of both structures  **must**  be the same value
/// - [`color_attachment_count`] **must**  be less than or equal to
///   [`PhysicalDeviceLimits::max_color_attachments`]
/// -    If the `imageView` member of a [`RenderingFragmentDensityMapAttachmentInfoEXT`] structure included in the [`p_next`] chain is not [`crate::Handle::null`], and [non-subsample image feature](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-fragmentDensityMapNonSubsampledImages) is not enabled, valid `imageView` and `resolveImageView` members of [`depth_attachment`], [`stencil_attachment`], and each element of [`color_attachments`] **must**  be a [`ImageView`] created with `VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT`
/// - If the `imageView` member of a [`RenderingFragmentDensityMapAttachmentInfoEXT`] structure
///   included in the [`p_next`] chain is not [`crate::Handle::null`], and [`view_mask`] is not `0`,
///   `imageView` **must**  have a [`layer_count`] greater than or equal to the index of the most
///   significant bit in [`view_mask`]
/// - If the `imageView` member of a [`RenderingFragmentDensityMapAttachmentInfoEXT`] structure
///   included in the [`p_next`] chain is not [`crate::Handle::null`], and [`view_mask`] is `0`,
///   `imageView` **must**  have a [`layer_count`] equal to `1`
/// - If the [`p_next`] chain does not contain [`DeviceGroupRenderPassBeginInfo`] or its
///   `deviceRenderAreaCount` member is equal to 0 and the `imageView` member of a
///   [`RenderingFragmentDensityMapAttachmentInfoEXT`] structure included in the [`p_next`] chain is
///   not [`crate::Handle::null`], `imageView` **must**  have a width greater than or equal to <span
///   class="katex"><span aria-hidden="true" class="katex-html"><span class="base"><span
///   style="height:1.80002em;vertical-align:-0.65002em;" class="strut"></span><span
///   class="minner"><span style="top:0em;" class="mopen delimcenter"><span class="delimsizing
///   size2"></span></span><span class="mord"><span class="mord"><span class="mopen
///   nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span
///   class="vlist-r"><span class="vlist" style="height:0.9019679999999999em;"><span
///   style="top:-2.6550000000000002em;"><span style="height:3em;" class="pstrut"></span><span
///   class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord
///   mathdefault mtight">m</span><span class="mord mathdefault mtight">a</span><span class="mord
///   mathdefault mtight">x</span><span class="mord mathdefault mtight"
///   style="margin-right:0.13889em;">F</span><span class="mord mathdefault mtight"
///   style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">a</span><span
///   class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mord
///   mathdefault mtight">m</span><span class="mord mathdefault mtight">e</span><span class="mord
///   mathdefault mtight">n</span><span class="mord mathdefault mtight">t</span><span
///   style="margin-right:0.02778em;" class="mord mathdefault mtight">D</span><span class="mord
///   mathdefault mtight">e</span><span class="mord mathdefault mtight">n</span><span class="mord
///   mathdefault mtight">s</span><span class="mord mathdefault mtight">i</span><span class="mord
///   mathdefault mtight">t</span><span style="margin-right:0.03588em;" class="mord mathdefault
///   mtight">y</span><span class="mord mathdefault mtight"
///   style="margin-right:0.13889em;">T</span><span class="mord mathdefault mtight">e</span><span
///   class="mord mathdefault mtight">x</span><span class="mord mathdefault mtight">e</span><span
///   style="margin-right:0.01968em;" class="mord mathdefault mtight">l</span><span
///   style="margin-right:0.05764em;" class="mord mathdefault mtight">S</span><span class="mord
///   mathdefault mtight">i</span><span style="margin-right:0.04398em;" class="mord mathdefault
///   mtight">z</span><span class="mord mtight"><span class="mord mathdefault mtight">e</span><span
///   class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span
///   style="height:0.3448em;" class="vlist"><span
///   style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span
///   style="height:2.5em;" class="pstrut"></span><span class="sizing reset-size3 size1
///   mtight"><span class="mord mtight"><span style="margin-right:0.02691em;" class="mord
///   mathdefault mtight">w</span><span class="mord mathdefault mtight">i</span><span class="mord
///   mathdefault mtight">d</span><span class="mord mathdefault mtight">t</span><span class="mord
///   mathdefault mtight">h</span></span></span></span></span><span
///   class="vlist-s"></span></span><span class="vlist-r"><span class="vlist"
///   style="height:0.15122857142857138em;"><span></span></span></span></span></span></span></
///   span></span></span><span style="top:-3.23em;"><span class="pstrut"
///   style="height:3em;"></span><span class="frac-line"
///   style="border-bottom-width:0.04em;"></span></span><span style="top:-3.41586em;"><span
///   class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span
///   class="mord mtight"><span class="mord mathdefault mtight"
///   style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">e</span><span
///   class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">d</span><span
///   class="mord mathdefault mtight">e</span><span style="margin-right:0.02778em;" class="mord
///   mathdefault mtight">r</span><span class="mord mathdefault mtight">A</span><span class="mord
///   mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault
///   mtight">e</span><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span
///   class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist"
///   style="height:0.16454285714285719em;"><span
///   style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span
///   style="height:2.5em;" class="pstrut"></span><span class="sizing reset-size3 size1
///   mtight"><span class="mord mtight"><span class="mord mathdefault
///   mtight">x</span></span></span></span></span><span class="vlist-s"></span></span><span
///   class="vlist-r"><span style="height:0.143em;"
///   class="vlist"><span></span></span></span></span></span></span><span class="mbin
///   mtight">+</span><span class="mord mathdefault mtight"
///   style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">e</span><span
///   class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">d</span><span
///   class="mord mathdefault mtight">e</span><span style="margin-right:0.02778em;" class="mord
///   mathdefault mtight">r</span><span class="mord mathdefault mtight">A</span><span class="mord
///   mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault
///   mtight">e</span><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span
///   class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span
///   style="height:0.3448em;" class="vlist"><span
///   style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span
///   style="height:2.5em;" class="pstrut"></span><span class="sizing reset-size3 size1
///   mtight"><span class="mord mtight"><span style="margin-right:0.02691em;" class="mord
///   mathdefault mtight">w</span><span class="mord mathdefault mtight">i</span><span class="mord
///   mathdefault mtight">d</span><span class="mord mathdefault mtight">t</span><span class="mord
///   mathdefault mtight">h</span></span></span></span></span><span
///   class="vlist-s"></span></span><span class="vlist-r"><span class="vlist"
///   style="height:0.15122857142857138em;"><span></span></span></span></span></span></span></
///   span></span></span></span><span class="vlist-s"></span></span><span class="vlist-r"><span
///   class="vlist" style="height:0.481108em;"><span></span></span></span></span></span><span
///   class="mclose nulldelimiter"></span></span></span><span style="top:0em;" class="mclose
///   delimcenter"><span class="delimsizing size2"></span></span></span></span></span></span>
/// - If the [`p_next`] chain contains a [`DeviceGroupRenderPassBeginInfo`] structure, its
///   `deviceRenderAreaCount` member is not 0, and the `imageView` member of a
///   [`RenderingFragmentDensityMapAttachmentInfoEXT`] structure included in the [`p_next`] chain is
///   not [`crate::Handle::null`], `imageView` **must**  have a width greater than or equal to <span
///   class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span
///   class="strut" style="height:1.80002em;vertical-align:-0.65002em;"></span><span
///   class="minner"><span style="top:0em;" class="mopen delimcenter"><span class="delimsizing
///   size2"></span></span><span class="mord"><span class="mord"><span class="mopen
///   nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span
///   class="vlist-r"><span class="vlist" style="height:0.9322159999999999em;"><span
///   style="top:-2.6550000000000002em;"><span style="height:3em;" class="pstrut"></span><span
///   class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord
///   mathdefault mtight">m</span><span class="mord mathdefault mtight">a</span><span class="mord
///   mathdefault mtight">x</span><span class="mord mathdefault mtight"
///   style="margin-right:0.13889em;">F</span><span style="margin-right:0.02778em;" class="mord
///   mathdefault mtight">r</span><span class="mord mathdefault mtight">a</span><span
///   style="margin-right:0.03588em;" class="mord mathdefault mtight">g</span><span class="mord
///   mathdefault mtight">m</span><span class="mord mathdefault mtight">e</span><span class="mord
///   mathdefault mtight">n</span><span class="mord mathdefault mtight">t</span><span
///   style="margin-right:0.02778em;" class="mord mathdefault mtight">D</span><span class="mord
///   mathdefault mtight">e</span><span class="mord mathdefault mtight">n</span><span class="mord
///   mathdefault mtight">s</span><span class="mord mathdefault mtight">i</span><span class="mord
///   mathdefault mtight">t</span><span class="mord mathdefault mtight"
///   style="margin-right:0.03588em;">y</span><span class="mord mathdefault mtight"
///   style="margin-right:0.13889em;">T</span><span class="mord mathdefault mtight">e</span><span
///   class="mord mathdefault mtight">x</span><span class="mord mathdefault mtight">e</span><span
///   class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord
///   mathdefault mtight" style="margin-right:0.05764em;">S</span><span class="mord mathdefault
///   mtight">i</span><span class="mord mathdefault mtight"
///   style="margin-right:0.04398em;">z</span><span class="mord mtight"><span class="mord
///   mathdefault mtight">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span
///   class="vlist-r"><span class="vlist" style="height:0.3448em;"><span
///   style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span
///   class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1
///   mtight"><span class="mord mtight"><span class="mord mathdefault mtight"
///   style="margin-right:0.02691em;">w</span><span class="mord mathdefault mtight">i</span><span
///   class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">t</span><span
///   class="mord mathdefault mtight">h</span></span></span></span></span><span
///   class="vlist-s"></span></span><span class="vlist-r"><span
///   style="height:0.15122857142857138em;"
///   class="vlist"><span></span></span></span></span></span></span></span></span></span><span
///   style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line"
///   style="border-bottom-width:0.04em;"></span></span><span style="top:-3.446108em;"><span
///   class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span
///   class="mord mtight"><span class="mord mathdefault mtight">p</span><span
///   style="margin-right:0.02778em;" class="mord mathdefault mtight">D</span><span class="mord
///   mathdefault mtight">e</span><span class="mord mathdefault mtight"
///   style="margin-right:0.03588em;">v</span><span class="mord mathdefault mtight">i</span><span
///   class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">e</span><span
///   style="margin-right:0.00773em;" class="mord mathdefault mtight">R</span><span class="mord
///   mathdefault mtight">e</span><span class="mord mathdefault mtight">n</span><span class="mord
///   mathdefault mtight">d</span><span class="mord mathdefault mtight">e</span><span
///   style="margin-right:0.02778em;" class="mord mathdefault mtight">r</span><span class="mord
///   mathdefault mtight">A</span><span class="mord mathdefault mtight"
///   style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">e</span><span
///   class="mord mathdefault mtight">a</span><span class="mord mtight"><span class="mord
///   mathdefault mtight">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span
///   class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span
///   style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span
///   style="height:2.5em;" class="pstrut"></span><span class="sizing reset-size3 size1
///   mtight"><span class="mord mtight"><span class="mord mathdefault
///   mtight">x</span></span></span></span></span><span class="vlist-s"></span></span><span
///   class="vlist-r"><span class="vlist"
///   style="height:0.143em;"><span></span></span></span></span></span></span><span class="mbin
///   mtight">+</span><span class="mord mathdefault mtight">p</span><span class="mord mathdefault
///   mtight" style="margin-right:0.02778em;">D</span><span class="mord mathdefault
///   mtight">e</span><span class="mord mathdefault mtight"
///   style="margin-right:0.03588em;">v</span><span class="mord mathdefault mtight">i</span><span
///   class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">e</span><span
///   class="mord mathdefault mtight" style="margin-right:0.00773em;">R</span><span class="mord
///   mathdefault mtight">e</span><span class="mord mathdefault mtight">n</span><span class="mord
///   mathdefault mtight">d</span><span class="mord mathdefault mtight">e</span><span
///   style="margin-right:0.02778em;" class="mord mathdefault mtight">r</span><span class="mord
///   mathdefault mtight">A</span><span style="margin-right:0.02778em;" class="mord mathdefault
///   mtight">r</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault
///   mtight">a</span><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span
///   class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span
///   style="height:0.3448em;" class="vlist"><span
///   style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span
///   class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1
///   mtight"><span class="mord mtight"><span class="mord mathdefault mtight"
///   style="margin-right:0.02691em;">w</span><span class="mord mathdefault mtight">i</span><span
///   class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">t</span><span
///   class="mord mathdefault mtight">h</span></span></span></span></span><span
///   class="vlist-s"></span></span><span class="vlist-r"><span class="vlist"
///   style="height:0.15122857142857138em;"><span></span></span></span></span></span></span></
///   span></span></span></span><span class="vlist-s"></span></span><span class="vlist-r"><span
///   style="height:0.481108em;" class="vlist"><span></span></span></span></span></span><span
///   class="mclose nulldelimiter"></span></span></span><span class="mclose delimcenter"
///   style="top:0em;"><span class="delimsizing size2"></span></span></span></span></span></span>
///   for each element of `pDeviceRenderAreas`
/// - If the [`p_next`] chain does not contain [`DeviceGroupRenderPassBeginInfo`] or its
///   `deviceRenderAreaCount` member is equal to 0 and the `imageView` member of a
///   [`RenderingFragmentDensityMapAttachmentInfoEXT`] structure included in the [`p_next`] chain is
///   not [`crate::Handle::null`], `imageView` **must**  have a height greater than or equal to
///   <span class="katex"><span aria-hidden="true" class="katex-html"><span class="base"><span
///   class="strut" style="height:1.80002em;vertical-align:-0.65002em;"></span><span
///   class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing
///   size2"></span></span><span class="mord"><span class="mord"><span class="mopen
///   nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span
///   class="vlist-r"><span class="vlist" style="height:0.999188em;"><span
///   style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span
///   class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord
///   mathdefault mtight">m</span><span class="mord mathdefault mtight">a</span><span class="mord
///   mathdefault mtight">x</span><span class="mord mathdefault mtight"
///   style="margin-right:0.13889em;">F</span><span style="margin-right:0.02778em;" class="mord
///   mathdefault mtight">r</span><span class="mord mathdefault mtight">a</span><span class="mord
///   mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mord mathdefault
///   mtight">m</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault
///   mtight">n</span><span class="mord mathdefault mtight">t</span><span
///   style="margin-right:0.02778em;" class="mord mathdefault mtight">D</span><span class="mord
///   mathdefault mtight">e</span><span class="mord mathdefault mtight">n</span><span class="mord
///   mathdefault mtight">s</span><span class="mord mathdefault mtight">i</span><span class="mord
///   mathdefault mtight">t</span><span style="margin-right:0.03588em;" class="mord mathdefault
///   mtight">y</span><span class="mord mathdefault mtight"
///   style="margin-right:0.13889em;">T</span><span class="mord mathdefault mtight">e</span><span
///   class="mord mathdefault mtight">x</span><span class="mord mathdefault mtight">e</span><span
///   style="margin-right:0.01968em;" class="mord mathdefault mtight">l</span><span
///   style="margin-right:0.05764em;" class="mord mathdefault mtight">S</span><span class="mord
///   mathdefault mtight">i</span><span class="mord mathdefault mtight"
///   style="margin-right:0.04398em;">z</span><span class="mord mtight"><span class="mord
///   mathdefault mtight">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span
///   class="vlist-r"><span class="vlist" style="height:0.3448em;"><span
///   style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span
///   style="height:2.5em;" class="pstrut"></span><span class="sizing reset-size3 size1
///   mtight"><span class="mord mtight"><span class="mord mathdefault mtight">h</span><span
///   class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">i</span><span
///   class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mord
///   mathdefault mtight">h</span><span class="mord mathdefault
///   mtight">t</span></span></span></span></span><span class="vlist-s"></span></span><span
///   class="vlist-r"><span class="vlist"
///   style="height:0.29011428571428566em;"><span></span></span></span></span></span></span></
///   span></span></span><span style="top:-3.23em;"><span class="pstrut"
///   style="height:3em;"></span><span style="border-bottom-width:0.04em;"
///   class="frac-line"></span></span><span style="top:-3.51308em;"><span style="height:3em;"
///   class="pstrut"></span><span class="sizing reset-size6 size3 mtight"><span class="mord
///   mtight"><span style="margin-right:0.02778em;" class="mord mathdefault mtight">r</span><span
///   class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">n</span><span
///   class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">e</span><span
///   class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord
///   mathdefault mtight">A</span><span class="mord mathdefault mtight"
///   style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">e</span><span
///   class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="msupsub"><span
///   class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist"
///   style="height:0.16454285714285716em;"><span
///   style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut"
///   style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord
///   mtight"><span style="margin-right:0.03588em;" class="mord mathdefault
///   mtight">y</span></span></span></span></span><span class="vlist-s"></span></span><span
///   class="vlist-r"><span class="vlist"
///   style="height:0.2818857142857143em;"><span></span></span></span></span></span></span><span
///   class="mbin mtight">+</span><span class="mord mathdefault mtight"
///   style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">e</span><span
///   class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">d</span><span
///   class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight"
///   style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">A</span><span
///   class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord
///   mathdefault mtight">e</span><span class="mord mtight"><span class="mord mathdefault
///   mtight">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span
///   class="vlist-r"><span style="height:0.3448em;" class="vlist"><span
///   style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span
///   class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1
///   mtight"><span class="mord mtight"><span class="mord mathdefault mtight">h</span><span
///   class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">i</span><span
///   style="margin-right:0.03588em;" class="mord mathdefault mtight">g</span><span class="mord
///   mathdefault mtight">h</span><span class="mord mathdefault
///   mtight">t</span></span></span></span></span><span class="vlist-s"></span></span><span
///   class="vlist-r"><span class="vlist"
///   style="height:0.29011428571428566em;"><span></span></span></span></span></span></span></
///   span></span></span></span><span class="vlist-s"></span></span><span class="vlist-r"><span
///   style="height:0.5480799999999999em;"
///   class="vlist"><span></span></span></span></span></span><span class="mclose
///   nulldelimiter"></span></span></span><span class="mclose delimcenter" style="top:0em;"><span
///   class="delimsizing size2"></span></span></span></span></span></span>
/// - If the [`p_next`] chain contains a [`DeviceGroupRenderPassBeginInfo`] structure, its
///   `deviceRenderAreaCount` member is not 0, and the `imageView` member of a
///   [`RenderingFragmentDensityMapAttachmentInfoEXT`] structure included in the [`p_next`] chain is
///   not [`crate::Handle::null`], `imageView` **must**  have a height greater than or equal to
///   <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span
///   class="strut" style="height:1.80002em;vertical-align:-0.65002em;"></span><span
///   class="minner"><span style="top:0em;" class="mopen delimcenter"><span class="delimsizing
///   size2"></span></span><span class="mord"><span class="mord"><span class="mopen
///   nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span
///   class="vlist-r"><span style="height:0.999188em;" class="vlist"><span
///   style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span
///   class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord
///   mathdefault mtight">m</span><span class="mord mathdefault mtight">a</span><span class="mord
///   mathdefault mtight">x</span><span class="mord mathdefault mtight"
///   style="margin-right:0.13889em;">F</span><span class="mord mathdefault mtight"
///   style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">a</span><span
///   style="margin-right:0.03588em;" class="mord mathdefault mtight">g</span><span class="mord
///   mathdefault mtight">m</span><span class="mord mathdefault mtight">e</span><span class="mord
///   mathdefault mtight">n</span><span class="mord mathdefault mtight">t</span><span
///   style="margin-right:0.02778em;" class="mord mathdefault mtight">D</span><span class="mord
///   mathdefault mtight">e</span><span class="mord mathdefault mtight">n</span><span class="mord
///   mathdefault mtight">s</span><span class="mord mathdefault mtight">i</span><span class="mord
///   mathdefault mtight">t</span><span class="mord mathdefault mtight"
///   style="margin-right:0.03588em;">y</span><span style="margin-right:0.13889em;" class="mord
///   mathdefault mtight">T</span><span class="mord mathdefault mtight">e</span><span class="mord
///   mathdefault mtight">x</span><span class="mord mathdefault mtight">e</span><span class="mord
///   mathdefault mtight" style="margin-right:0.01968em;">l</span><span
///   style="margin-right:0.05764em;" class="mord mathdefault mtight">S</span><span class="mord
///   mathdefault mtight">i</span><span class="mord mathdefault mtight"
///   style="margin-right:0.04398em;">z</span><span class="mord mtight"><span class="mord
///   mathdefault mtight">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span
///   class="vlist-r"><span class="vlist" style="height:0.3448em;"><span
///   style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span
///   class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1
///   mtight"><span class="mord mtight"><span class="mord mathdefault mtight">h</span><span
///   class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">i</span><span
///   class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mord
///   mathdefault mtight">h</span><span class="mord mathdefault
///   mtight">t</span></span></span></span></span><span class="vlist-s"></span></span><span
///   class="vlist-r"><span style="height:0.29011428571428566em;"
///   class="vlist"><span></span></span></span></span></span></span></span></span></span><span
///   style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line"
///   style="border-bottom-width:0.04em;"></span></span><span style="top:-3.51308em;"><span
///   style="height:3em;" class="pstrut"></span><span class="sizing reset-size6 size3 mtight"><span
///   class="mord mtight"><span class="mord mathdefault mtight">p</span><span
///   style="margin-right:0.02778em;" class="mord mathdefault mtight">D</span><span class="mord
///   mathdefault mtight">e</span><span class="mord mathdefault mtight"
///   style="margin-right:0.03588em;">v</span><span class="mord mathdefault mtight">i</span><span
///   class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">e</span><span
///   style="margin-right:0.00773em;" class="mord mathdefault mtight">R</span><span class="mord
///   mathdefault mtight">e</span><span class="mord mathdefault mtight">n</span><span class="mord
///   mathdefault mtight">d</span><span class="mord mathdefault mtight">e</span><span class="mord
///   mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault
///   mtight">A</span><span class="mord mathdefault mtight"
///   style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">e</span><span
///   class="mord mathdefault mtight">a</span><span class="mord mtight"><span class="mord
///   mathdefault mtight">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span
///   class="vlist-r"><span class="vlist" style="height:0.16454285714285716em;"><span
///   style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut"
///   style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord
///   mtight"><span style="margin-right:0.03588em;" class="mord mathdefault
///   mtight">y</span></span></span></span></span><span class="vlist-s"></span></span><span
///   class="vlist-r"><span style="height:0.2818857142857143em;"
///   class="vlist"><span></span></span></span></span></span></span><span class="mbin
///   mtight">+</span><span class="mord mathdefault mtight">p</span><span
///   style="margin-right:0.02778em;" class="mord mathdefault mtight">D</span><span class="mord
///   mathdefault mtight">e</span><span class="mord mathdefault mtight"
///   style="margin-right:0.03588em;">v</span><span class="mord mathdefault mtight">i</span><span
///   class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">e</span><span
///   class="mord mathdefault mtight" style="margin-right:0.00773em;">R</span><span class="mord
///   mathdefault mtight">e</span><span class="mord mathdefault mtight">n</span><span class="mord
///   mathdefault mtight">d</span><span class="mord mathdefault mtight">e</span><span
///   style="margin-right:0.02778em;" class="mord mathdefault mtight">r</span><span class="mord
///   mathdefault mtight">A</span><span style="margin-right:0.02778em;" class="mord mathdefault
///   mtight">r</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault
///   mtight">a</span><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span
///   class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist"
///   style="height:0.3448em;"><span
///   style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span
///   class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1
///   mtight"><span class="mord mtight"><span class="mord mathdefault mtight">h</span><span
///   class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">i</span><span
///   class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mord
///   mathdefault mtight">h</span><span class="mord mathdefault
///   mtight">t</span></span></span></span></span><span class="vlist-s"></span></span><span
///   class="vlist-r"><span style="height:0.29011428571428566em;"
///   class="vlist"><span></span></span></span></span></span></span></span></span></span></
///   span><span class="vlist-s"></span></span><span class="vlist-r"><span
///   style="height:0.5480799999999999em;"
///   class="vlist"><span></span></span></span></span></span><span class="mclose
///   nulldelimiter"></span></span></span><span class="mclose delimcenter" style="top:0em;"><span
///   class="delimsizing size2"></span></span></span></span></span></span> for each element of
///   `pDeviceRenderAreas`
/// - If the `imageView` member of a [`RenderingFragmentDensityMapAttachmentInfoEXT`] structure
///   included in the [`p_next`] chain is not [`crate::Handle::null`], it  **must**  not be equal to
///   the `imageView` or `resolveImageView` member of [`depth_attachment`], [`stencil_attachment`],
///   or any element of [`color_attachments`]
/// - If the [`p_next`] chain does not contain [`DeviceGroupRenderPassBeginInfo`] or its
///   `deviceRenderAreaCount` member is equal to 0 and the `imageView` member of a
///   [`RenderingFragmentShadingRateAttachmentInfoKHR`] structure included in the [`p_next`] chain
///   is not [`crate::Handle::null`], `imageView` **must**  have a width greater than or equal to
///   <span class="katex"><span aria-hidden="true" class="katex-html"><span class="base"><span
///   style="height:1.80002em;vertical-align:-0.65002em;" class="strut"></span><span
///   class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing
///   size2"></span></span><span class="mord"><span class="mord"><span class="mopen
///   nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span
///   class="vlist-r"><span class="vlist" style="height:0.9019679999999999em;"><span
///   style="top:-2.6550000000000002em;"><span style="height:3em;" class="pstrut"></span><span
///   class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord
///   mathdefault mtight">s</span><span class="mord mathdefault mtight">h</span><span class="mord
///   mathdefault mtight">a</span><span class="mord mathdefault mtight">d</span><span class="mord
///   mathdefault mtight">i</span><span class="mord mathdefault mtight">n</span><span class="mord
///   mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mord mathdefault
///   mtight" style="margin-right:0.00773em;">R</span><span class="mord mathdefault
///   mtight">a</span><span class="mord mathdefault mtight">t</span><span class="mord mathdefault
///   mtight">e</span><span class="mord mathdefault mtight">A</span><span class="mord mathdefault
///   mtight">t</span><span class="mord mathdefault mtight">t</span><span class="mord mathdefault
///   mtight">a</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault
///   mtight">h</span><span class="mord mathdefault mtight">m</span><span class="mord mathdefault
///   mtight">e</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault
///   mtight">t</span><span class="mord mathdefault mtight"
///   style="margin-right:0.13889em;">T</span><span class="mord mathdefault mtight">e</span><span
///   class="mord mathdefault mtight">x</span><span class="mord mathdefault mtight">e</span><span
///   style="margin-right:0.01968em;" class="mord mathdefault mtight">l</span><span class="mord
///   mathdefault mtight" style="margin-right:0.05764em;">S</span><span class="mord mathdefault
///   mtight">i</span><span class="mord mathdefault mtight"
///   style="margin-right:0.04398em;">z</span><span class="mord mtight"><span class="mord
///   mathdefault mtight">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span
///   class="vlist-r"><span class="vlist" style="height:0.3448em;"><span
///   style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span
///   class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1
///   mtight"><span class="mord mtight"><span style="margin-right:0.02691em;" class="mord
///   mathdefault mtight">w</span><span class="mord mathdefault mtight">i</span><span class="mord
///   mathdefault mtight">d</span><span class="mord mathdefault mtight">t</span><span class="mord
///   mathdefault mtight">h</span></span></span></span></span><span
///   class="vlist-s"></span></span><span class="vlist-r"><span class="vlist"
///   style="height:0.15122857142857138em;"><span></span></span></span></span></span></span></
///   span></span></span><span style="top:-3.23em;"><span style="height:3em;"
///   class="pstrut"></span><span style="border-bottom-width:0.04em;"
///   class="frac-line"></span></span><span style="top:-3.41586em;"><span class="pstrut"
///   style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord
///   mtight"><span style="margin-right:0.02778em;" class="mord mathdefault mtight">r</span><span
///   class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">n</span><span
///   class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">e</span><span
///   class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord
///   mathdefault mtight">A</span><span class="mord mathdefault mtight"
///   style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">e</span><span
///   class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="msupsub"><span
///   class="vlist-t vlist-t2"><span class="vlist-r"><span style="height:0.16454285714285719em;"
///   class="vlist"><span
///   style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span
///   style="height:2.5em;" class="pstrut"></span><span class="sizing reset-size3 size1
///   mtight"><span class="mord mtight"><span class="mord mathdefault
///   mtight">x</span></span></span></span></span><span class="vlist-s"></span></span><span
///   class="vlist-r"><span style="height:0.143em;"
///   class="vlist"><span></span></span></span></span></span></span><span class="mbin
///   mtight">+</span><span class="mord mathdefault mtight"
///   style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">e</span><span
///   class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">d</span><span
///   class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight"
///   style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">A</span><span
///   style="margin-right:0.02778em;" class="mord mathdefault mtight">r</span><span class="mord
///   mathdefault mtight">e</span><span class="mord mtight"><span class="mord mathdefault
///   mtight">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span
///   class="vlist-r"><span style="height:0.3448em;" class="vlist"><span
///   style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span
///   class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1
///   mtight"><span class="mord mtight"><span class="mord mathdefault mtight"
///   style="margin-right:0.02691em;">w</span><span class="mord mathdefault mtight">i</span><span
///   class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">t</span><span
///   class="mord mathdefault mtight">h</span></span></span></span></span><span
///   class="vlist-s"></span></span><span class="vlist-r"><span class="vlist"
///   style="height:0.15122857142857138em;"><span></span></span></span></span></span></span></
///   span></span></span></span><span class="vlist-s"></span></span><span class="vlist-r"><span
///   class="vlist" style="height:0.481108em;"><span></span></span></span></span></span><span
///   class="mclose nulldelimiter"></span></span></span><span style="top:0em;" class="mclose
///   delimcenter"><span class="delimsizing size2"></span></span></span></span></span></span>
/// - If the [`p_next`] chain contains a [`DeviceGroupRenderPassBeginInfo`] structure, its
///   `deviceRenderAreaCount` member is not 0, and the `imageView` member of a
///   [`RenderingFragmentShadingRateAttachmentInfoKHR`] structure included in the [`p_next`] chain
///   is not [`crate::Handle::null`], `imageView` **must**  have a width greater than or equal to
///   <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span
///   class="strut" style="height:1.80002em;vertical-align:-0.65002em;"></span><span
///   class="minner"><span style="top:0em;" class="mopen delimcenter"><span class="delimsizing
///   size2"></span></span><span class="mord"><span class="mord"><span class="mopen
///   nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span
///   class="vlist-r"><span class="vlist" style="height:0.9322159999999999em;"><span
///   style="top:-2.6550000000000002em;"><span style="height:3em;" class="pstrut"></span><span
///   class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord
///   mathdefault mtight">s</span><span class="mord mathdefault mtight">h</span><span class="mord
///   mathdefault mtight">a</span><span class="mord mathdefault mtight">d</span><span class="mord
///   mathdefault mtight">i</span><span class="mord mathdefault mtight">n</span><span class="mord
///   mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mord mathdefault
///   mtight" style="margin-right:0.00773em;">R</span><span class="mord mathdefault
///   mtight">a</span><span class="mord mathdefault mtight">t</span><span class="mord mathdefault
///   mtight">e</span><span class="mord mathdefault mtight">A</span><span class="mord mathdefault
///   mtight">t</span><span class="mord mathdefault mtight">t</span><span class="mord mathdefault
///   mtight">a</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault
///   mtight">h</span><span class="mord mathdefault mtight">m</span><span class="mord mathdefault
///   mtight">e</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault
///   mtight">t</span><span class="mord mathdefault mtight"
///   style="margin-right:0.13889em;">T</span><span class="mord mathdefault mtight">e</span><span
///   class="mord mathdefault mtight">x</span><span class="mord mathdefault mtight">e</span><span
///   style="margin-right:0.01968em;" class="mord mathdefault mtight">l</span><span class="mord
///   mathdefault mtight" style="margin-right:0.05764em;">S</span><span class="mord mathdefault
///   mtight">i</span><span class="mord mathdefault mtight"
///   style="margin-right:0.04398em;">z</span><span class="mord mtight"><span class="mord
///   mathdefault mtight">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span
///   class="vlist-r"><span style="height:0.3448em;" class="vlist"><span
///   style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span
///   class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1
///   mtight"><span class="mord mtight"><span class="mord mathdefault mtight"
///   style="margin-right:0.02691em;">w</span><span class="mord mathdefault mtight">i</span><span
///   class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">t</span><span
///   class="mord mathdefault mtight">h</span></span></span></span></span><span
///   class="vlist-s"></span></span><span class="vlist-r"><span
///   style="height:0.15122857142857138em;"
///   class="vlist"><span></span></span></span></span></span></span></span></span></span><span
///   style="top:-3.23em;"><span style="height:3em;" class="pstrut"></span><span class="frac-line"
///   style="border-bottom-width:0.04em;"></span></span><span style="top:-3.446108em;"><span
///   class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span
///   class="mord mtight"><span class="mord mathdefault mtight">p</span><span class="mord
///   mathdefault mtight" style="margin-right:0.02778em;">D</span><span class="mord mathdefault
///   mtight">e</span><span class="mord mathdefault mtight"
///   style="margin-right:0.03588em;">v</span><span class="mord mathdefault mtight">i</span><span
///   class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">e</span><span
///   style="margin-right:0.00773em;" class="mord mathdefault mtight">R</span><span class="mord
///   mathdefault mtight">e</span><span class="mord mathdefault mtight">n</span><span class="mord
///   mathdefault mtight">d</span><span class="mord mathdefault mtight">e</span><span class="mord
///   mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault
///   mtight">A</span><span style="margin-right:0.02778em;" class="mord mathdefault
///   mtight">r</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault
///   mtight">a</span><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span
///   class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span
///   style="height:0.16454285714285719em;" class="vlist"><span
///   style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span
///   style="height:2.5em;" class="pstrut"></span><span class="sizing reset-size3 size1
///   mtight"><span class="mord mtight"><span class="mord mathdefault
///   mtight">x</span></span></span></span></span><span class="vlist-s"></span></span><span
///   class="vlist-r"><span style="height:0.143em;"
///   class="vlist"><span></span></span></span></span></span></span><span class="mbin
///   mtight">+</span><span class="mord mathdefault mtight">p</span><span class="mord mathdefault
///   mtight" style="margin-right:0.02778em;">D</span><span class="mord mathdefault
///   mtight">e</span><span class="mord mathdefault mtight"
///   style="margin-right:0.03588em;">v</span><span class="mord mathdefault mtight">i</span><span
///   class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">e</span><span
///   class="mord mathdefault mtight" style="margin-right:0.00773em;">R</span><span class="mord
///   mathdefault mtight">e</span><span class="mord mathdefault mtight">n</span><span class="mord
///   mathdefault mtight">d</span><span class="mord mathdefault mtight">e</span><span
///   style="margin-right:0.02778em;" class="mord mathdefault mtight">r</span><span class="mord
///   mathdefault mtight">A</span><span style="margin-right:0.02778em;" class="mord mathdefault
///   mtight">r</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault
///   mtight">a</span><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span
///   class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span
///   style="height:0.3448em;" class="vlist"><span
///   style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span
///   class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1
///   mtight"><span class="mord mtight"><span style="margin-right:0.02691em;" class="mord
///   mathdefault mtight">w</span><span class="mord mathdefault mtight">i</span><span class="mord
///   mathdefault mtight">d</span><span class="mord mathdefault mtight">t</span><span class="mord
///   mathdefault mtight">h</span></span></span></span></span><span
///   class="vlist-s"></span></span><span class="vlist-r"><span
///   style="height:0.15122857142857138em;"
///   class="vlist"><span></span></span></span></span></span></span></span></span></span></
///   span><span class="vlist-s"></span></span><span class="vlist-r"><span class="vlist"
///   style="height:0.481108em;"><span></span></span></span></span></span><span class="mclose
///   nulldelimiter"></span></span></span><span class="mclose delimcenter" style="top:0em;"><span
///   class="delimsizing size2"></span></span></span></span></span></span> for each element of
///   `pDeviceRenderAreas`
/// - If the [`p_next`] chain does not contain [`DeviceGroupRenderPassBeginInfo`] or its
///   `deviceRenderAreaCount` member is equal to 0 and the `imageView` member of a
///   [`RenderingFragmentShadingRateAttachmentInfoKHR`] structure included in the [`p_next`] chain
///   is not [`crate::Handle::null`], `imageView` **must**  have a height greater than or equal to
///   <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span
///   class="strut" style="height:1.80002em;vertical-align:-0.65002em;"></span><span
///   class="minner"><span style="top:0em;" class="mopen delimcenter"><span class="delimsizing
///   size2"></span></span><span class="mord"><span class="mord"><span class="mopen
///   nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span
///   class="vlist-r"><span class="vlist" style="height:0.999188em;"><span
///   style="top:-2.6550000000000002em;"><span style="height:3em;" class="pstrut"></span><span
///   class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord
///   mathdefault mtight">s</span><span class="mord mathdefault mtight">h</span><span class="mord
///   mathdefault mtight">a</span><span class="mord mathdefault mtight">d</span><span class="mord
///   mathdefault mtight">i</span><span class="mord mathdefault mtight">n</span><span class="mord
///   mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mord mathdefault
///   mtight" style="margin-right:0.00773em;">R</span><span class="mord mathdefault
///   mtight">a</span><span class="mord mathdefault mtight">t</span><span class="mord mathdefault
///   mtight">e</span><span class="mord mathdefault mtight">A</span><span class="mord mathdefault
///   mtight">t</span><span class="mord mathdefault mtight">t</span><span class="mord mathdefault
///   mtight">a</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault
///   mtight">h</span><span class="mord mathdefault mtight">m</span><span class="mord mathdefault
///   mtight">e</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault
///   mtight">t</span><span class="mord mathdefault mtight"
///   style="margin-right:0.13889em;">T</span><span class="mord mathdefault mtight">e</span><span
///   class="mord mathdefault mtight">x</span><span class="mord mathdefault mtight">e</span><span
///   class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord
///   mathdefault mtight" style="margin-right:0.05764em;">S</span><span class="mord mathdefault
///   mtight">i</span><span style="margin-right:0.04398em;" class="mord mathdefault
///   mtight">z</span><span class="mord mtight"><span class="mord mathdefault mtight">e</span><span
///   class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist"
///   style="height:0.3448em;"><span
///   style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span
///   class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1
///   mtight"><span class="mord mtight"><span class="mord mathdefault mtight">h</span><span
///   class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">i</span><span
///   class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mord
///   mathdefault mtight">h</span><span class="mord mathdefault
///   mtight">t</span></span></span></span></span><span class="vlist-s"></span></span><span
///   class="vlist-r"><span class="vlist"
///   style="height:0.29011428571428566em;"><span></span></span></span></span></span></span></
///   span></span></span><span style="top:-3.23em;"><span style="height:3em;"
///   class="pstrut"></span><span class="frac-line"
///   style="border-bottom-width:0.04em;"></span></span><span style="top:-3.51308em;"><span
///   style="height:3em;" class="pstrut"></span><span class="sizing reset-size6 size3 mtight"><span
///   class="mord mtight"><span style="margin-right:0.02778em;" class="mord mathdefault
///   mtight">r</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault
///   mtight">n</span><span class="mord mathdefault mtight">d</span><span class="mord mathdefault
///   mtight">e</span><span class="mord mathdefault mtight"
///   style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">A</span><span
///   style="margin-right:0.02778em;" class="mord mathdefault mtight">r</span><span class="mord
///   mathdefault mtight">e</span><span class="mord mtight"><span class="mord mathdefault
///   mtight">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span
///   class="vlist-r"><span style="height:0.16454285714285716em;" class="vlist"><span
///   style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut"
///   style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord
///   mtight"><span class="mord mathdefault mtight"
///   style="margin-right:0.03588em;">y</span></span></span></span></span><span
///   class="vlist-s"></span></span><span class="vlist-r"><span class="vlist"
///   style="height:0.2818857142857143em;"><span></span></span></span></span></span></span><span
///   class="mbin mtight">+</span><span style="margin-right:0.02778em;" class="mord mathdefault
///   mtight">r</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault
///   mtight">n</span><span class="mord mathdefault mtight">d</span><span class="mord mathdefault
///   mtight">e</span><span class="mord mathdefault mtight"
///   style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">A</span><span
///   style="margin-right:0.02778em;" class="mord mathdefault mtight">r</span><span class="mord
///   mathdefault mtight">e</span><span class="mord mtight"><span class="mord mathdefault
///   mtight">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span
///   class="vlist-r"><span class="vlist" style="height:0.3448em;"><span
///   style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span
///   class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1
///   mtight"><span class="mord mtight"><span class="mord mathdefault mtight">h</span><span
///   class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">i</span><span
///   style="margin-right:0.03588em;" class="mord mathdefault mtight">g</span><span class="mord
///   mathdefault mtight">h</span><span class="mord mathdefault
///   mtight">t</span></span></span></span></span><span class="vlist-s"></span></span><span
///   class="vlist-r"><span class="vlist"
///   style="height:0.29011428571428566em;"><span></span></span></span></span></span></span></
///   span></span></span></span><span class="vlist-s"></span></span><span class="vlist-r"><span
///   style="height:0.5480799999999999em;"
///   class="vlist"><span></span></span></span></span></span><span class="mclose
///   nulldelimiter"></span></span></span><span class="mclose delimcenter" style="top:0em;"><span
///   class="delimsizing size2"></span></span></span></span></span></span>
/// - If the [`p_next`] chain contains a [`DeviceGroupRenderPassBeginInfo`] structure, its
///   `deviceRenderAreaCount` member is not 0, and the `imageView` member of a
///   [`RenderingFragmentShadingRateAttachmentInfoKHR`] structure included in the [`p_next`] chain
///   is not [`crate::Handle::null`], `imageView` **must**  have a height greater than or equal to
///   <span class="katex"><span aria-hidden="true" class="katex-html"><span class="base"><span
///   class="strut" style="height:1.80002em;vertical-align:-0.65002em;"></span><span
///   class="minner"><span style="top:0em;" class="mopen delimcenter"><span class="delimsizing
///   size2"></span></span><span class="mord"><span class="mord"><span class="mopen
///   nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span
///   class="vlist-r"><span style="height:0.999188em;" class="vlist"><span
///   style="top:-2.6550000000000002em;"><span style="height:3em;" class="pstrut"></span><span
///   class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord
///   mathdefault mtight">s</span><span class="mord mathdefault mtight">h</span><span class="mord
///   mathdefault mtight">a</span><span class="mord mathdefault mtight">d</span><span class="mord
///   mathdefault mtight">i</span><span class="mord mathdefault mtight">n</span><span class="mord
///   mathdefault mtight" style="margin-right:0.03588em;">g</span><span
///   style="margin-right:0.00773em;" class="mord mathdefault mtight">R</span><span class="mord
///   mathdefault mtight">a</span><span class="mord mathdefault mtight">t</span><span class="mord
///   mathdefault mtight">e</span><span class="mord mathdefault mtight">A</span><span class="mord
///   mathdefault mtight">t</span><span class="mord mathdefault mtight">t</span><span class="mord
///   mathdefault mtight">a</span><span class="mord mathdefault mtight">c</span><span class="mord
///   mathdefault mtight">h</span><span class="mord mathdefault mtight">m</span><span class="mord
///   mathdefault mtight">e</span><span class="mord mathdefault mtight">n</span><span class="mord
///   mathdefault mtight">t</span><span style="margin-right:0.13889em;" class="mord mathdefault
///   mtight">T</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault
///   mtight">x</span><span class="mord mathdefault mtight">e</span><span
///   style="margin-right:0.01968em;" class="mord mathdefault mtight">l</span><span
///   style="margin-right:0.05764em;" class="mord mathdefault mtight">S</span><span class="mord
///   mathdefault mtight">i</span><span style="margin-right:0.04398em;" class="mord mathdefault
///   mtight">z</span><span class="mord mtight"><span class="mord mathdefault mtight">e</span><span
///   class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist"
///   style="height:0.3448em;"><span
///   style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span
///   style="height:2.5em;" class="pstrut"></span><span class="sizing reset-size3 size1
///   mtight"><span class="mord mtight"><span class="mord mathdefault mtight">h</span><span
///   class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">i</span><span
///   style="margin-right:0.03588em;" class="mord mathdefault mtight">g</span><span class="mord
///   mathdefault mtight">h</span><span class="mord mathdefault
///   mtight">t</span></span></span></span></span><span class="vlist-s"></span></span><span
///   class="vlist-r"><span class="vlist"
///   style="height:0.29011428571428566em;"><span></span></span></span></span></span></span></
///   span></span></span><span style="top:-3.23em;"><span style="height:3em;"
///   class="pstrut"></span><span style="border-bottom-width:0.04em;"
///   class="frac-line"></span></span><span style="top:-3.51308em;"><span class="pstrut"
///   style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord
///   mtight"><span class="mord mathdefault mtight">p</span><span style="margin-right:0.02778em;"
///   class="mord mathdefault mtight">D</span><span class="mord mathdefault mtight">e</span><span
///   class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span><span class="mord
///   mathdefault mtight">i</span><span class="mord mathdefault mtight">c</span><span class="mord
///   mathdefault mtight">e</span><span class="mord mathdefault mtight"
///   style="margin-right:0.00773em;">R</span><span class="mord mathdefault mtight">e</span><span
///   class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">d</span><span
///   class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight"
///   style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">A</span><span
///   class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord
///   mathdefault mtight">e</span><span class="mord mathdefault mtight">a</span><span class="mord
///   mtight"><span class="mord mathdefault mtight">s</span><span class="msupsub"><span
///   class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist"
///   style="height:0.16454285714285716em;"><span
///   style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut"
///   style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord
///   mtight"><span class="mord mathdefault mtight"
///   style="margin-right:0.03588em;">y</span></span></span></span></span><span
///   class="vlist-s"></span></span><span class="vlist-r"><span class="vlist"
///   style="height:0.2818857142857143em;"><span></span></span></span></span></span></span><span
///   class="mbin mtight">+</span><span class="mord mathdefault mtight">p</span><span
///   style="margin-right:0.02778em;" class="mord mathdefault mtight">D</span><span class="mord
///   mathdefault mtight">e</span><span style="margin-right:0.03588em;" class="mord mathdefault
///   mtight">v</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault
///   mtight">c</span><span class="mord mathdefault mtight">e</span><span
///   style="margin-right:0.00773em;" class="mord mathdefault mtight">R</span><span class="mord
///   mathdefault mtight">e</span><span class="mord mathdefault mtight">n</span><span class="mord
///   mathdefault mtight">d</span><span class="mord mathdefault mtight">e</span><span class="mord
///   mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault
///   mtight">A</span><span class="mord mathdefault mtight"
///   style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">e</span><span
///   class="mord mathdefault mtight">a</span><span class="mord mtight"><span class="mord
///   mathdefault mtight">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span
///   class="vlist-r"><span style="height:0.3448em;" class="vlist"><span
///   style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span
///   class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1
///   mtight"><span class="mord mtight"><span class="mord mathdefault mtight">h</span><span
///   class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">i</span><span
///   style="margin-right:0.03588em;" class="mord mathdefault mtight">g</span><span class="mord
///   mathdefault mtight">h</span><span class="mord mathdefault
///   mtight">t</span></span></span></span></span><span class="vlist-s"></span></span><span
///   class="vlist-r"><span class="vlist"
///   style="height:0.29011428571428566em;"><span></span></span></span></span></span></span></
///   span></span></span></span><span class="vlist-s"></span></span><span class="vlist-r"><span
///   class="vlist"
///   style="height:0.5480799999999999em;"><span></span></span></span></span></span><span
///   class="mclose nulldelimiter"></span></span></span><span style="top:0em;" class="mclose
///   delimcenter"><span class="delimsizing size2"></span></span></span></span></span></span> for
///   each element of `pDeviceRenderAreas`
/// - If the `imageView` member of a [`RenderingFragmentShadingRateAttachmentInfoKHR`] structure
///   included in the [`p_next`] chain is not [`crate::Handle::null`], and [`view_mask`] is `0`,
///   `imageView` **must**  have a [`layer_count`] that is either equal to `1` or greater than or
///   equal to [`layer_count`]
/// - If the `imageView` member of a [`RenderingFragmentShadingRateAttachmentInfoKHR`] structure
///   included in the [`p_next`] chain is not [`crate::Handle::null`], and [`view_mask`] is not `0`,
///   `imageView` **must**  have a [`layer_count`] that either equal to `1` or greater than or equal
///   to the index of the most significant bit in [`view_mask`]
/// - If the `imageView` member of a [`RenderingFragmentShadingRateAttachmentInfoKHR`] structure
///   included in the [`p_next`] chain is not [`crate::Handle::null`], it  **must**  not be equal to
///   the `imageView` or `resolveImageView` member of [`depth_attachment`], [`stencil_attachment`],
///   or any element of [`color_attachments`]
/// - If the `imageView` member of a [`RenderingFragmentShadingRateAttachmentInfoKHR`] structure
///   included in the [`p_next`] chain is not [`crate::Handle::null`], it  **must**  not be equal to
///   the `imageView` member of a [`RenderingFragmentDensityMapAttachmentInfoEXT`] structure
///   included in the [`p_next`] chain
/// - If the [`multiview`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-multiview)
///   feature is not enabled, [`view_mask`] **must**  be `0`
/// - The index of the most significant bit in [`view_mask`] **must**  be less than [`maxMultiviewViewCount`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#limits-maxMultiviewViewCount)
///
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be `VK_STRUCTURE_TYPE_RENDERING_INFO`
/// - Each [`p_next`] member of any structure (including this one) in the [`p_next`] chain  **must**
///   be either `NULL` or a pointer to a valid instance of [`DeviceGroupRenderPassBeginInfo`],
///   [`MultiviewPerViewAttributesInfoNVX`], [`RenderingFragmentDensityMapAttachmentInfoEXT`], or
///   [`RenderingFragmentShadingRateAttachmentInfoKHR`]
/// - The [`s_type`] value of each struct in the [`p_next`] chain  **must**  be unique
/// - [`flags`] **must**  be a valid combination of [`RenderingFlagBits`] values
/// - If [`color_attachment_count`] is not `0`, [`color_attachments`] **must**  be a valid pointer
///   to an array of [`color_attachment_count`] valid [`RenderingAttachmentInfo`] structures
/// - If [`depth_attachment`] is not `NULL`, [`depth_attachment`] **must**  be a valid pointer to a
///   valid [`RenderingAttachmentInfo`] structure
/// - If [`stencil_attachment`] is not `NULL`, [`stencil_attachment`] **must**  be a valid pointer
///   to a valid [`RenderingAttachmentInfo`] structure
///# Related
/// - [`khr_dynamic_rendering`]
/// - [`crate::vulkan1_3`]
/// - [`Rect2D`]
/// - [`RenderingAttachmentInfo`]
/// - [`RenderingFlags`]
/// - [`StructureType`]
/// - [`cmd_begin_rendering`]
/// - [`cmd_begin_rendering_khr`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkRenderingInfo")]
#[derive(Debug, Clone, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[repr(C)]
pub struct RenderingInfo<'lt> {
    ///Lifetime field
    pub _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] is the type of this structure.
    pub s_type: StructureType,
    ///[`p_next`] is `NULL` or a pointer to a structure extending this
    ///structure.
    pub p_next: *const BaseInStructure<'lt>,
    ///[`flags`] is a bitmask of [`RenderingFlagBits`].
    pub flags: RenderingFlags,
    ///[`render_area`] is the render area that is affected by the render pass
    ///instance.
    pub render_area: Rect2D,
    ///[`layer_count`] is the number of layers rendered to in each attachment
    ///when [`view_mask`] is `0`.
    pub layer_count: u32,
    ///[`view_mask`] is the view mask indicating the indices of attachment
    ///layers that will be rendered when it is not `0`.
    pub view_mask: u32,
    ///[`color_attachment_count`] is the number of elements in
    ///[`color_attachments`].
    pub color_attachment_count: u32,
    ///[`color_attachments`] is a pointer to an array of
    ///[`color_attachment_count`][`RenderingAttachmentInfo`] structures
    ///describing any color attachments used.
    pub color_attachments: *const RenderingAttachmentInfo<'lt>,
    ///[`depth_attachment`] is a pointer to a [`RenderingAttachmentInfo`]
    ///structure describing a depth attachment.
    pub depth_attachment: *const RenderingAttachmentInfo<'lt>,
    ///[`stencil_attachment`] is a pointer to a
    ///[`RenderingAttachmentInfo`] structure describing a stencil
    ///attachment.
    pub stencil_attachment: *const RenderingAttachmentInfo<'lt>,
}
impl<'lt> Default for RenderingInfo<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: StructureType::RENDERING_INFO,
            p_next: std::ptr::null(),
            flags: Default::default(),
            render_area: Default::default(),
            layer_count: 0,
            view_mask: 0,
            color_attachment_count: 0,
            color_attachments: std::ptr::null(),
            depth_attachment: std::ptr::null(),
            stencil_attachment: std::ptr::null(),
        }
    }
}
impl<'lt> RenderingInfo<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *const BaseInStructure<'lt> {
        self.p_next
    }
    ///Gets the raw value of [`Self::color_attachments`]
    pub fn color_attachments_raw(&self) -> *const RenderingAttachmentInfo<'lt> {
        self.color_attachments
    }
    ///Gets the raw value of [`Self::depth_attachment`]
    pub fn depth_attachment_raw(&self) -> *const RenderingAttachmentInfo<'lt> {
        self.depth_attachment
    }
    ///Gets the raw value of [`Self::stencil_attachment`]
    pub fn stencil_attachment_raw(&self) -> *const RenderingAttachmentInfo<'lt> {
        self.stencil_attachment
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *const BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::color_attachments`]
    pub fn set_color_attachments_raw(&mut self, value: *const RenderingAttachmentInfo<'lt>) -> &mut Self {
        self.color_attachments = value;
        self
    }
    ///Sets the raw value of [`Self::depth_attachment`]
    pub fn set_depth_attachment_raw(&mut self, value: *const RenderingAttachmentInfo<'lt>) -> &mut Self {
        self.depth_attachment = value;
        self
    }
    ///Sets the raw value of [`Self::stencil_attachment`]
    pub fn set_stencil_attachment_raw(&mut self, value: *const RenderingAttachmentInfo<'lt>) -> &mut Self {
        self.stencil_attachment = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn with_p_next_raw(mut self, value: *const BaseInStructure<'lt>) -> Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::color_attachments`]
    pub fn with_color_attachments_raw(mut self, value: *const RenderingAttachmentInfo<'lt>) -> Self {
        self.color_attachments = value;
        self
    }
    ///Sets the raw value of [`Self::depth_attachment`]
    pub fn with_depth_attachment_raw(mut self, value: *const RenderingAttachmentInfo<'lt>) -> Self {
        self.depth_attachment = value;
        self
    }
    ///Sets the raw value of [`Self::stencil_attachment`]
    pub fn with_stencil_attachment_raw(mut self, value: *const RenderingAttachmentInfo<'lt>) -> Self {
        self.stencil_attachment = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseInStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::flags`]
    pub fn flags(&self) -> RenderingFlags {
        self.flags
    }
    ///Gets the value of [`Self::render_area`]
    pub fn render_area(&self) -> Rect2D {
        self.render_area
    }
    ///Gets the value of [`Self::layer_count`]
    pub fn layer_count(&self) -> u32 {
        self.layer_count
    }
    ///Gets the value of [`Self::view_mask`]
    pub fn view_mask(&self) -> u32 {
        self.view_mask
    }
    ///Gets the value of [`Self::color_attachment_count`]
    pub fn color_attachment_count(&self) -> u32 {
        self.color_attachment_count
    }
    ///Gets the value of [`Self::color_attachments`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn color_attachments(&self) -> &[RenderingAttachmentInfo<'lt>] {
        std::slice::from_raw_parts(self.color_attachments, self.color_attachment_count as usize)
    }
    ///Gets the value of [`Self::depth_attachment`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn depth_attachment(&self) -> &RenderingAttachmentInfo<'lt> {
        &*self.depth_attachment
    }
    ///Gets the value of [`Self::stencil_attachment`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn stencil_attachment(&self) -> &RenderingAttachmentInfo<'lt> {
        &*self.stencil_attachment
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::flags`]
    pub fn flags_mut(&mut self) -> &mut RenderingFlags {
        &mut self.flags
    }
    ///Gets a mutable reference to the value of [`Self::render_area`]
    pub fn render_area_mut(&mut self) -> &mut Rect2D {
        &mut self.render_area
    }
    ///Gets a mutable reference to the value of [`Self::layer_count`]
    pub fn layer_count_mut(&mut self) -> &mut u32 {
        &mut self.layer_count
    }
    ///Gets a mutable reference to the value of [`Self::view_mask`]
    pub fn view_mask_mut(&mut self) -> &mut u32 {
        &mut self.view_mask
    }
    ///Gets a mutable reference to the value of [`Self::color_attachment_count`]
    pub fn color_attachment_count_mut(&mut self) -> &mut u32 {
        &mut self.color_attachment_count
    }
    ///Sets the value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the value of [`Self::flags`]
    pub fn set_flags(&mut self, value: crate::vulkan1_3::RenderingFlags) -> &mut Self {
        self.flags = value;
        self
    }
    ///Sets the value of [`Self::render_area`]
    pub fn set_render_area(&mut self, value: crate::vulkan1_0::Rect2D) -> &mut Self {
        self.render_area = value;
        self
    }
    ///Sets the value of [`Self::layer_count`]
    pub fn set_layer_count(&mut self, value: u32) -> &mut Self {
        self.layer_count = value;
        self
    }
    ///Sets the value of [`Self::view_mask`]
    pub fn set_view_mask(&mut self, value: u32) -> &mut Self {
        self.view_mask = value;
        self
    }
    ///Sets the value of [`Self::color_attachment_count`]
    pub fn set_color_attachment_count(&mut self, value: u32) -> &mut Self {
        self.color_attachment_count = value;
        self
    }
    ///Sets the value of [`Self::color_attachments`]
    pub fn set_color_attachments(&mut self, value: &'lt [crate::vulkan1_3::RenderingAttachmentInfo<'lt>]) -> &mut Self {
        let len_ = value.len() as u32;
        let len_ = len_;
        self.color_attachments = value.as_ptr();
        self.color_attachment_count = len_;
        self
    }
    ///Sets the value of [`Self::depth_attachment`]
    pub fn set_depth_attachment(&mut self, value: &'lt crate::vulkan1_3::RenderingAttachmentInfo<'lt>) -> &mut Self {
        self.depth_attachment = value as *const _;
        self
    }
    ///Sets the value of [`Self::stencil_attachment`]
    pub fn set_stencil_attachment(&mut self, value: &'lt crate::vulkan1_3::RenderingAttachmentInfo<'lt>) -> &mut Self {
        self.stencil_attachment = value as *const _;
        self
    }
    ///Sets the value of [`Self::s_type`]
    pub fn with_s_type(mut self, value: crate::vulkan1_0::StructureType) -> Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn with_p_next(mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the value of [`Self::flags`]
    pub fn with_flags(mut self, value: crate::vulkan1_3::RenderingFlags) -> Self {
        self.flags = value;
        self
    }
    ///Sets the value of [`Self::render_area`]
    pub fn with_render_area(mut self, value: crate::vulkan1_0::Rect2D) -> Self {
        self.render_area = value;
        self
    }
    ///Sets the value of [`Self::layer_count`]
    pub fn with_layer_count(mut self, value: u32) -> Self {
        self.layer_count = value;
        self
    }
    ///Sets the value of [`Self::view_mask`]
    pub fn with_view_mask(mut self, value: u32) -> Self {
        self.view_mask = value;
        self
    }
    ///Sets the value of [`Self::color_attachment_count`]
    pub fn with_color_attachment_count(mut self, value: u32) -> Self {
        self.color_attachment_count = value;
        self
    }
    ///Sets the value of [`Self::color_attachments`]
    pub fn with_color_attachments(mut self, value: &'lt [crate::vulkan1_3::RenderingAttachmentInfo<'lt>]) -> Self {
        let len_ = value.len() as u32;
        let len_ = len_;
        self.color_attachments = value.as_ptr();
        self.color_attachment_count = len_;
        self
    }
    ///Sets the value of [`Self::depth_attachment`]
    pub fn with_depth_attachment(mut self, value: &'lt crate::vulkan1_3::RenderingAttachmentInfo<'lt>) -> Self {
        self.depth_attachment = value as *const _;
        self
    }
    ///Sets the value of [`Self::stencil_attachment`]
    pub fn with_stencil_attachment(mut self, value: &'lt crate::vulkan1_3::RenderingAttachmentInfo<'lt>) -> Self {
        self.stencil_attachment = value as *const _;
        self
    }
}
unsafe impl<'this: 'extender + 'other, 'extender: 'other, 'other>
    crate::Chain<'other, DeviceGroupRenderPassBeginInfo<'extender>> for RenderingInfo<'this>
{
    type Out = RenderingInfo<'other>;
    #[must_use]
    #[inline]
    fn chain(mut self, new: &'other mut DeviceGroupRenderPassBeginInfo<'extender>) -> Self::Out {
        unsafe {
            crate::chaining::insert_ptr_in_chain(
                &mut self as *mut Self as *mut BaseOutStructure<'other>,
                new as *mut DeviceGroupRenderPassBeginInfo<'extender> as *mut BaseOutStructure<'other>,
            );
            std::mem::transmute(self)
        }
    }
}
#[cfg(feature = "VK_KHR_dynamic_rendering")]
unsafe impl<'this: 'extender + 'other, 'extender: 'other, 'other>
    crate::Chain<'other, RenderingFragmentShadingRateAttachmentInfoKHR<'extender>> for RenderingInfo<'this>
{
    type Out = RenderingInfo<'other>;
    #[must_use]
    #[inline]
    fn chain(mut self, new: &'other mut RenderingFragmentShadingRateAttachmentInfoKHR<'extender>) -> Self::Out {
        unsafe {
            crate::chaining::insert_ptr_in_chain(
                &mut self as *mut Self as *mut BaseOutStructure<'other>,
                new as *mut RenderingFragmentShadingRateAttachmentInfoKHR<'extender> as *mut BaseOutStructure<'other>,
            );
            std::mem::transmute(self)
        }
    }
}
#[cfg(feature = "VK_KHR_dynamic_rendering")]
unsafe impl<'this: 'extender + 'other, 'extender: 'other, 'other>
    crate::Chain<'other, RenderingFragmentDensityMapAttachmentInfoEXT<'extender>> for RenderingInfo<'this>
{
    type Out = RenderingInfo<'other>;
    #[must_use]
    #[inline]
    fn chain(mut self, new: &'other mut RenderingFragmentDensityMapAttachmentInfoEXT<'extender>) -> Self::Out {
        unsafe {
            crate::chaining::insert_ptr_in_chain(
                &mut self as *mut Self as *mut BaseOutStructure<'other>,
                new as *mut RenderingFragmentDensityMapAttachmentInfoEXT<'extender> as *mut BaseOutStructure<'other>,
            );
            std::mem::transmute(self)
        }
    }
}
#[cfg(feature = "VK_KHR_dynamic_rendering")]
unsafe impl<'this: 'extender + 'other, 'extender: 'other, 'other>
    crate::Chain<'other, MultiviewPerViewAttributesInfoNVX<'extender>> for RenderingInfo<'this>
{
    type Out = RenderingInfo<'other>;
    #[must_use]
    #[inline]
    fn chain(mut self, new: &'other mut MultiviewPerViewAttributesInfoNVX<'extender>) -> Self::Out {
        unsafe {
            crate::chaining::insert_ptr_in_chain(
                &mut self as *mut Self as *mut BaseOutStructure<'other>,
                new as *mut MultiviewPerViewAttributesInfoNVX<'extender> as *mut BaseOutStructure<'other>,
            );
            std::mem::transmute(self)
        }
    }
}
///[VkRenderingAttachmentInfo](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderingAttachmentInfo.html) - Structure specifying attachment information
///# C Specifications
///The [`RenderingAttachmentInfo`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_3
///typedef struct VkRenderingAttachmentInfo {
///    VkStructureType          sType;
///    const void*              pNext;
///    VkImageView              imageView;
///    VkImageLayout            imageLayout;
///    VkResolveModeFlagBits    resolveMode;
///    VkImageView              resolveImageView;
///    VkImageLayout            resolveImageLayout;
///    VkAttachmentLoadOp       loadOp;
///    VkAttachmentStoreOp      storeOp;
///    VkClearValue             clearValue;
///} VkRenderingAttachmentInfo;
///```
///or the equivalent
///```c
///// Provided by VK_KHR_dynamic_rendering
///typedef VkRenderingAttachmentInfo VkRenderingAttachmentInfoKHR;
///```
///# Members
/// - [`s_type`] is the type of this structure.
/// - [`p_next`] is `NULL` or a pointer to a structure extending this structure.
/// - [`image_view`] is the image view that will be used for rendering.
/// - [`image_layout`] is the layout that [`image_view`] will be in during rendering.
/// - [`resolve_mode`] is a [`ResolveModeFlagBits`] value defining how multisampled data written to
///   [`image_view`] will be resolved.
/// - [`resolve_image_view`] is an image view used to write resolved multisample data at the end of
///   rendering.
/// - [`resolve_image_layout`] is the layout that [`resolve_image_view`] will be in during
///   rendering.
/// - [`load_op`] is a [`AttachmentLoadOp`] value specifying how the contents of [`image_view`] are
///   treated at the start of the render pass instance.
/// - [`store_op`] is a [`AttachmentStoreOp`] value specifying how the contents of [`image_view`]
///   are treated at the end of the render pass instance.
/// - [`clear_value`] is a [`ClearValue`] structure defining values used to clear [`image_view`]
///   when [`load_op`] is `VK_ATTACHMENT_LOAD_OP_CLEAR`.
///# Description
///Values in [`image_view`] are loaded and stored according to the values of
///[`load_op`] and [`store_op`], within the render area
///for each device
///specified in [`RenderingInfo`].
///If [`image_view`] is [`crate::Handle::null`], other members of this structure
///are ignored; writes to this attachment will be discarded, and no load,
///store, or resolve operations will be performed.If [`resolve_mode`] is `VK_RESOLVE_MODE_NONE`,
/// then
///[`resolve_image_view`] is ignored.
///If [`resolve_mode`] is not `VK_RESOLVE_MODE_NONE`, values in
///[`resolve_image_view`] within the render area become undefined once
///rendering begins.
///At the end of rendering, the color values written to each pixel location in
///[`image_view`] will be resolved according to [`resolve_mode`] and stored
///into the the same location in [`resolve_image_view`].Store and resolve operations are only
/// performed at the end of a render pass
///instance that does not specify the `VK_RENDERING_SUSPENDING_BIT_KHR`
///flag.Load operations are only performed at the beginning of a render pass
///instance that does not specify the `VK_RENDERING_RESUMING_BIT_KHR` flag.Image contents at the
/// end of a suspended render pass instance remain defined
///for access by a resuming render pass instance.
///## Valid Usage
/// - If [`image_view`] is not [`crate::Handle::null`] and has a non-integer color format,
///   [`resolve_mode`] **must**  be `VK_RESOLVE_MODE_NONE` or `VK_RESOLVE_MODE_AVERAGE_BIT`
/// - If [`image_view`] is not [`crate::Handle::null`] and has an integer color format,
///   [`resolve_mode`] **must**  be `VK_RESOLVE_MODE_NONE` or `VK_RESOLVE_MODE_SAMPLE_ZERO_BIT`
/// - If [`image_view`] is not [`crate::Handle::null`] and [`resolve_mode`] is not
///   `VK_RESOLVE_MODE_NONE`, [`image_view`] **must**  not have a sample count of
///   `VK_SAMPLE_COUNT_1_BIT`
/// - If [`image_view`] is not [`crate::Handle::null`] and [`resolve_mode`] is not
///   `VK_RESOLVE_MODE_NONE`, [`resolve_image_view`] **must**  have a sample count of
///   `VK_SAMPLE_COUNT_1_BIT`
/// - If [`image_view`] is not [`crate::Handle::null`] and [`resolve_mode`] is not
///   `VK_RESOLVE_MODE_NONE`, [`image_view`] and [`resolve_image_view`] **must**  have the same
///   [`Format`]
/// - If [`image_view`] is not [`crate::Handle::null`], `layout` **must**  not be
///   `VK_IMAGE_LAYOUT_UNDEFINED`, `VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL`,
///   `VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL`, `VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL`, or
///   `VK_IMAGE_LAYOUT_PREINITIALIZED`
/// - If [`image_view`] is not [`crate::Handle::null`] and [`resolve_mode`] is not
///   `VK_RESOLVE_MODE_NONE`, [`resolve_image_layout`] **must**  not be `VK_IMAGE_LAYOUT_UNDEFINED`,
///   `VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL`, `VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL`,
///   `VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL`, `VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL`, or
///   `VK_IMAGE_LAYOUT_PREINITIALIZED`
/// - If [`image_view`] is not [`crate::Handle::null`] and [`resolve_mode`] is not
///   `VK_RESOLVE_MODE_NONE`, [`resolve_image_layout`] **must**  not be
///   `VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL` or `VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL`
/// - If [`image_view`] is not [`crate::Handle::null`], `layout` **must**  not be
///   `VK_IMAGE_LAYOUT_SHADING_RATE_OPTIMAL_NV`
/// - If [`image_view`] is not [`crate::Handle::null`] and [`resolve_mode`] is not
///   `VK_RESOLVE_MODE_NONE`, [`resolve_image_layout`] **must**  not be
///   `VK_IMAGE_LAYOUT_SHADING_RATE_OPTIMAL_NV`
/// - If [`image_view`] is not [`crate::Handle::null`], `layout` **must**  not be
///   `VK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT`
/// - If [`image_view`] is not [`crate::Handle::null`] and [`resolve_mode`] is not
///   `VK_RESOLVE_MODE_NONE`, [`resolve_image_layout`] **must**  not be
///   `VK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT`
/// - If [`image_view`] is not [`crate::Handle::null`] and [`resolve_mode`] is not
///   `VK_RESOLVE_MODE_NONE`, [`resolve_image_layout`] **must**  not be
///   `VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL_KHR`
/// - If [`image_view`] is not [`crate::Handle::null`], `layout` **must**  not be
///   `VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR`
/// - If [`image_view`] is not [`crate::Handle::null`] and [`resolve_mode`] is not
///   `VK_RESOLVE_MODE_NONE`, [`resolve_image_layout`] **must**  not be
///   `VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR`
/// - If [`image_view`] is not [`crate::Handle::null`], `layout` **must**  not be
///   `VK_IMAGE_LAYOUT_PRESENT_SRC_KHR`
/// - If [`image_view`] is not [`crate::Handle::null`] and [`resolve_mode`] is not
///   `VK_RESOLVE_MODE_NONE`, [`resolve_image_layout`] **must**  not be
///   `VK_IMAGE_LAYOUT_PRESENT_SRC_KHR`
///
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be `VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO`
/// - [`p_next`] **must**  be `NULL`
/// - If [`image_view`] is not [`crate::Handle::null`], [`image_view`] **must**  be a valid
///   [`ImageView`] handle
/// - [`image_layout`] **must**  be a valid [`ImageLayout`] value
/// - If [`resolve_mode`] is not `0`, [`resolve_mode`] **must**  be a valid [`ResolveModeFlagBits`]
///   value
/// - If [`resolve_image_view`] is not [`crate::Handle::null`], [`resolve_image_view`] **must**  be
///   a valid [`ImageView`] handle
/// - [`resolve_image_layout`] **must**  be a valid [`ImageLayout`] value
/// - [`load_op`] **must**  be a valid [`AttachmentLoadOp`] value
/// - [`store_op`] **must**  be a valid [`AttachmentStoreOp`] value
/// - [`clear_value`] **must**  be a valid [`ClearValue`] union
/// - Both of [`image_view`], and [`resolve_image_view`] that are valid handles of non-ignored
///   parameters  **must**  have been created, allocated, or retrieved from the same [`Device`]
///# Related
/// - [`khr_dynamic_rendering`]
/// - [`crate::vulkan1_3`]
/// - [`AttachmentLoadOp`]
/// - [`AttachmentStoreOp`]
/// - [`ClearValue`]
/// - [`ImageLayout`]
/// - [`ImageView`]
/// - [`RenderingInfo`]
/// - [`ResolveModeFlagBits`]
/// - [`StructureType`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkRenderingAttachmentInfo")]
#[derive(Clone)]
#[repr(C)]
pub struct RenderingAttachmentInfo<'lt> {
    ///Lifetime field
    pub _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] is the type of this structure.
    pub s_type: StructureType,
    ///[`p_next`] is `NULL` or a pointer to a structure extending this
    ///structure.
    pub p_next: *const BaseInStructure<'lt>,
    ///[`image_view`] is the image view that will be used for rendering.
    pub image_view: ImageView,
    ///[`image_layout`] is the layout that [`image_view`] will be in during
    ///rendering.
    pub image_layout: ImageLayout,
    ///[`resolve_mode`] is a [`ResolveModeFlagBits`] value defining how
    ///multisampled data written to [`image_view`] will be resolved.
    pub resolve_mode: ResolveModeFlagBits,
    ///[`resolve_image_view`] is an image view used to write resolved
    ///multisample data at the end of rendering.
    pub resolve_image_view: ImageView,
    ///[`resolve_image_layout`] is the layout that [`resolve_image_view`] will
    ///be in during rendering.
    pub resolve_image_layout: ImageLayout,
    ///[`load_op`] is a [`AttachmentLoadOp`] value specifying how the
    ///contents of [`image_view`] are treated at the start of the render pass
    ///instance.
    pub load_op: AttachmentLoadOp,
    ///[`store_op`] is a [`AttachmentStoreOp`] value specifying how the
    ///contents of [`image_view`] are treated at the end of the render pass
    ///instance.
    pub store_op: AttachmentStoreOp,
    ///[`clear_value`] is a [`ClearValue`] structure defining values used
    ///to clear [`image_view`] when [`load_op`] is
    ///`VK_ATTACHMENT_LOAD_OP_CLEAR`.
    pub clear_value: ClearValue,
}
impl<'lt> Default for RenderingAttachmentInfo<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: StructureType::RENDERING_ATTACHMENT_INFO,
            p_next: std::ptr::null(),
            image_view: Default::default(),
            image_layout: Default::default(),
            resolve_mode: Default::default(),
            resolve_image_view: Default::default(),
            resolve_image_layout: Default::default(),
            load_op: Default::default(),
            store_op: Default::default(),
            clear_value: unsafe { std::mem::zeroed() },
        }
    }
}
impl<'lt> RenderingAttachmentInfo<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *const BaseInStructure<'lt> {
        self.p_next
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *const BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn with_p_next_raw(mut self, value: *const BaseInStructure<'lt>) -> Self {
        self.p_next = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseInStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::image_view`]
    pub fn image_view(&self) -> ImageView {
        self.image_view
    }
    ///Gets the value of [`Self::image_layout`]
    pub fn image_layout(&self) -> ImageLayout {
        self.image_layout
    }
    ///Gets the value of [`Self::resolve_mode`]
    pub fn resolve_mode(&self) -> ResolveModeFlagBits {
        self.resolve_mode
    }
    ///Gets the value of [`Self::resolve_image_view`]
    pub fn resolve_image_view(&self) -> ImageView {
        self.resolve_image_view
    }
    ///Gets the value of [`Self::resolve_image_layout`]
    pub fn resolve_image_layout(&self) -> ImageLayout {
        self.resolve_image_layout
    }
    ///Gets the value of [`Self::load_op`]
    pub fn load_op(&self) -> AttachmentLoadOp {
        self.load_op
    }
    ///Gets the value of [`Self::store_op`]
    pub fn store_op(&self) -> AttachmentStoreOp {
        self.store_op
    }
    ///Gets the value of [`Self::clear_value`]
    pub fn clear_value(&self) -> ClearValue {
        self.clear_value
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::image_view`]
    pub fn image_view_mut(&mut self) -> &mut ImageView {
        &mut self.image_view
    }
    ///Gets a mutable reference to the value of [`Self::image_layout`]
    pub fn image_layout_mut(&mut self) -> &mut ImageLayout {
        &mut self.image_layout
    }
    ///Gets a mutable reference to the value of [`Self::resolve_mode`]
    pub fn resolve_mode_mut(&mut self) -> &mut ResolveModeFlagBits {
        &mut self.resolve_mode
    }
    ///Gets a mutable reference to the value of [`Self::resolve_image_view`]
    pub fn resolve_image_view_mut(&mut self) -> &mut ImageView {
        &mut self.resolve_image_view
    }
    ///Gets a mutable reference to the value of [`Self::resolve_image_layout`]
    pub fn resolve_image_layout_mut(&mut self) -> &mut ImageLayout {
        &mut self.resolve_image_layout
    }
    ///Gets a mutable reference to the value of [`Self::load_op`]
    pub fn load_op_mut(&mut self) -> &mut AttachmentLoadOp {
        &mut self.load_op
    }
    ///Gets a mutable reference to the value of [`Self::store_op`]
    pub fn store_op_mut(&mut self) -> &mut AttachmentStoreOp {
        &mut self.store_op
    }
    ///Gets a mutable reference to the value of [`Self::clear_value`]
    pub fn clear_value_mut(&mut self) -> &mut ClearValue {
        &mut self.clear_value
    }
    ///Sets the value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the value of [`Self::image_view`]
    pub fn set_image_view(&mut self, value: crate::vulkan1_0::ImageView) -> &mut Self {
        self.image_view = value;
        self
    }
    ///Sets the value of [`Self::image_layout`]
    pub fn set_image_layout(&mut self, value: crate::vulkan1_0::ImageLayout) -> &mut Self {
        self.image_layout = value;
        self
    }
    ///Sets the value of [`Self::resolve_mode`]
    pub fn set_resolve_mode(&mut self, value: crate::vulkan1_2::ResolveModeFlagBits) -> &mut Self {
        self.resolve_mode = value;
        self
    }
    ///Sets the value of [`Self::resolve_image_view`]
    pub fn set_resolve_image_view(&mut self, value: crate::vulkan1_0::ImageView) -> &mut Self {
        self.resolve_image_view = value;
        self
    }
    ///Sets the value of [`Self::resolve_image_layout`]
    pub fn set_resolve_image_layout(&mut self, value: crate::vulkan1_0::ImageLayout) -> &mut Self {
        self.resolve_image_layout = value;
        self
    }
    ///Sets the value of [`Self::load_op`]
    pub fn set_load_op(&mut self, value: crate::vulkan1_0::AttachmentLoadOp) -> &mut Self {
        self.load_op = value;
        self
    }
    ///Sets the value of [`Self::store_op`]
    pub fn set_store_op(&mut self, value: crate::vulkan1_0::AttachmentStoreOp) -> &mut Self {
        self.store_op = value;
        self
    }
    ///Sets the value of [`Self::clear_value`]
    pub fn set_clear_value(&mut self, value: crate::vulkan1_0::ClearValue) -> &mut Self {
        self.clear_value = value;
        self
    }
    ///Sets the value of [`Self::s_type`]
    pub fn with_s_type(mut self, value: crate::vulkan1_0::StructureType) -> Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn with_p_next(mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the value of [`Self::image_view`]
    pub fn with_image_view(mut self, value: crate::vulkan1_0::ImageView) -> Self {
        self.image_view = value;
        self
    }
    ///Sets the value of [`Self::image_layout`]
    pub fn with_image_layout(mut self, value: crate::vulkan1_0::ImageLayout) -> Self {
        self.image_layout = value;
        self
    }
    ///Sets the value of [`Self::resolve_mode`]
    pub fn with_resolve_mode(mut self, value: crate::vulkan1_2::ResolveModeFlagBits) -> Self {
        self.resolve_mode = value;
        self
    }
    ///Sets the value of [`Self::resolve_image_view`]
    pub fn with_resolve_image_view(mut self, value: crate::vulkan1_0::ImageView) -> Self {
        self.resolve_image_view = value;
        self
    }
    ///Sets the value of [`Self::resolve_image_layout`]
    pub fn with_resolve_image_layout(mut self, value: crate::vulkan1_0::ImageLayout) -> Self {
        self.resolve_image_layout = value;
        self
    }
    ///Sets the value of [`Self::load_op`]
    pub fn with_load_op(mut self, value: crate::vulkan1_0::AttachmentLoadOp) -> Self {
        self.load_op = value;
        self
    }
    ///Sets the value of [`Self::store_op`]
    pub fn with_store_op(mut self, value: crate::vulkan1_0::AttachmentStoreOp) -> Self {
        self.store_op = value;
        self
    }
    ///Sets the value of [`Self::clear_value`]
    pub fn with_clear_value(mut self, value: crate::vulkan1_0::ClearValue) -> Self {
        self.clear_value = value;
        self
    }
}
///[VkPhysicalDeviceDynamicRenderingFeatures](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDynamicRenderingFeatures.html) - Structure indicating support for dynamic render pass instances
///# C Specifications
///The [`PhysicalDeviceDynamicRenderingFeatures`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_3
///typedef struct VkPhysicalDeviceDynamicRenderingFeatures {
///    VkStructureType    sType;
///    void*              pNext;
///    VkBool32           dynamicRendering;
///} VkPhysicalDeviceDynamicRenderingFeatures;
///```
///or the equivalent
///```c
///// Provided by VK_KHR_dynamic_rendering
///typedef VkPhysicalDeviceDynamicRenderingFeatures VkPhysicalDeviceDynamicRenderingFeaturesKHR;
///```
///# Members
///The members of the [`PhysicalDeviceDynamicRenderingFeatures`] structure
///describe the following features:
///# Description
/// - [`dynamic_rendering`] specifies that the implementation supports dynamic render pass instances
///   using the [`cmd_begin_rendering`] command.
///If the [`PhysicalDeviceDynamicRenderingFeatures`] structure is included in the [`p_next`] chain
/// of the
///[`PhysicalDeviceFeatures2`] structure passed to
///[`get_physical_device_features2`], it is filled in to indicate whether each
///corresponding feature is supported.
///[`PhysicalDeviceDynamicRenderingFeatures`] **can**  also be used in the [`p_next`] chain of
///[`DeviceCreateInfo`] to selectively enable these features.
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be `VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES`
///# Related
/// - [`khr_dynamic_rendering`]
/// - [`crate::vulkan1_3`]
/// - [`Bool32`]
/// - [`StructureType`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkPhysicalDeviceDynamicRenderingFeatures")]
#[derive(Debug, Clone, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[repr(C)]
pub struct PhysicalDeviceDynamicRenderingFeatures<'lt> {
    ///Lifetime field
    pub _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] **must**  be `VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES`
    pub s_type: StructureType,
    ///No documentation found
    pub p_next: *mut BaseOutStructure<'lt>,
    ///[`dynamic_rendering`]
    ///specifies that the implementation supports dynamic render pass instances
    ///using the [`cmd_begin_rendering`] command.
    pub dynamic_rendering: Bool32,
}
impl<'lt> Default for PhysicalDeviceDynamicRenderingFeatures<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: StructureType::PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES,
            p_next: std::ptr::null_mut(),
            dynamic_rendering: 0,
        }
    }
}
impl<'lt> PhysicalDeviceDynamicRenderingFeatures<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *mut BaseOutStructure<'lt> {
        self.p_next
    }
    ///Gets the raw value of [`Self::dynamic_rendering`]
    pub fn dynamic_rendering_raw(&self) -> Bool32 {
        self.dynamic_rendering
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *mut BaseOutStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::dynamic_rendering`]
    pub fn set_dynamic_rendering_raw(&mut self, value: Bool32) -> &mut Self {
        self.dynamic_rendering = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn with_p_next_raw(mut self, value: *mut BaseOutStructure<'lt>) -> Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::dynamic_rendering`]
    pub fn with_dynamic_rendering_raw(mut self, value: Bool32) -> Self {
        self.dynamic_rendering = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseOutStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::dynamic_rendering`]
    pub fn dynamic_rendering(&self) -> bool {
        unsafe { std::mem::transmute(self.dynamic_rendering as u8) }
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next_mut(&mut self) -> &mut BaseOutStructure<'lt> {
        &mut *self.p_next
    }
    ///Gets a mutable reference to the value of [`Self::dynamic_rendering`]
    pub fn dynamic_rendering_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.dynamic_rendering as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.dynamic_rendering as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Sets the value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt mut crate::vulkan1_0::BaseOutStructure<'lt>) -> &mut Self {
        self.p_next = value as *mut _;
        self
    }
    ///Sets the value of [`Self::dynamic_rendering`]
    pub fn set_dynamic_rendering(&mut self, value: bool) -> &mut Self {
        self.dynamic_rendering = value as u8 as u32;
        self
    }
    ///Sets the value of [`Self::s_type`]
    pub fn with_s_type(mut self, value: crate::vulkan1_0::StructureType) -> Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn with_p_next(mut self, value: &'lt mut crate::vulkan1_0::BaseOutStructure<'lt>) -> Self {
        self.p_next = value as *mut _;
        self
    }
    ///Sets the value of [`Self::dynamic_rendering`]
    pub fn with_dynamic_rendering(mut self, value: bool) -> Self {
        self.dynamic_rendering = value as u8 as u32;
        self
    }
}
///[VkCommandBufferInheritanceRenderingInfo](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandBufferInheritanceRenderingInfo.html) - Structure specifying command buffer inheritance info for dynamic render pass instances
///# C Specifications
///The [`CommandBufferInheritanceRenderingInfo`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_3
///typedef struct VkCommandBufferInheritanceRenderingInfo {
///    VkStructureType          sType;
///    const void*              pNext;
///    VkRenderingFlags         flags;
///    uint32_t                 viewMask;
///    uint32_t                 colorAttachmentCount;
///    const VkFormat*          pColorAttachmentFormats;
///    VkFormat                 depthAttachmentFormat;
///    VkFormat                 stencilAttachmentFormat;
///    VkSampleCountFlagBits    rasterizationSamples;
///} VkCommandBufferInheritanceRenderingInfo;
///```
///or the equivalent
///```c
///// Provided by VK_KHR_dynamic_rendering
///typedef VkCommandBufferInheritanceRenderingInfo VkCommandBufferInheritanceRenderingInfoKHR;
///```
///# Members
/// - [`s_type`] is the type of this structure
/// - [`p_next`] is `NULL` or a pointer to a structure extending this structure
/// - [`flags`] is a bitmask of [`RenderingFlagBits`] used by the render pass instance.
/// - [`view_mask`] is the view mask used for rendering.
/// - [`color_attachment_count`] is the number of color attachments specified in the render pass
///   instance.
/// - [`color_attachment_formats`] is a pointer to an array of [`Format`] values defining the format
///   of color attachments.
/// - [`depth_attachment_format`] is a [`Format`] value defining the format of the depth attachment.
/// - [`stencil_attachment_format`] is a [`Format`] value defining the format of the stencil
///   attachment.
/// - [`rasterization_samples`] is a [`SampleCountFlagBits`] specifying the number of samples used
///   in rasterization.
///# Description
///If the [`p_next`] chain of [`CommandBufferInheritanceInfo`] includes a
///[`CommandBufferInheritanceRenderingInfo`] structure, then that structure
///controls parameters of dynamic render pass instances that the
///[`CommandBuffer`] **can**  be executed within.
///If [`CommandBufferInheritanceInfo::render_pass`] is not
///[`crate::Handle::null`], or
///`VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT` is not specified in
///[`CommandBufferBeginInfo`]::[`flags`], parameters of this structure
///are ignored.If [`color_attachment_count`] is `0` and the
///[`variableMultisampleRate`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-variableMultisampleRate) feature
///is enabled, [`rasterization_samples`] is ignored.If [`depth_attachment_format`],
/// [`stencil_attachment_format`], or any
///element of [`color_attachment_formats`] is `VK_FORMAT_UNDEFINED`, it
///indicates that the corresponding attachment is unused within the render
///pass.
///## Valid Usage
/// - If [`color_attachment_count`] is not `0`, [`rasterization_samples`] **must**  be a valid
///   [`SampleCountFlagBits`] value
/// - If the [`variableMultisampleRate`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-variableMultisampleRate)
///   feature is not enabled, [`rasterization_samples`] **must**  be a valid [`SampleCountFlagBits`]
///   value
/// -    If any element of [`color_attachment_formats`] is not `VK_FORMAT_UNDEFINED`, it  **must**  be a format with [potential format features](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#potential-format-features) that include `VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT`
/// - If [`depth_attachment_format`] is not `VK_FORMAT_UNDEFINED`, it  **must**  be a format that
///   includes a depth aspect
/// -    If [`depth_attachment_format`] is not `VK_FORMAT_UNDEFINED`, it  **must**  be a format with [potential format features](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#potential-format-features) that include `VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT`
/// -    When rendering to a [Linear Color attachment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#glossary), if any element of [`color_attachment_formats`] is not `VK_FORMAT_UNDEFINED`, it  **must**  be a format with [potential format features](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#potential-format-features) that include `VK_FORMAT_FEATURE_2_LINEAR_COLOR_ATTACHMENT_BIT_NV`
/// - If [`stencil_attachment_format`] is not `VK_FORMAT_UNDEFINED`, it  **must**  be a format that
///   includes a stencil aspect
/// -    If [`stencil_attachment_format`] is not `VK_FORMAT_UNDEFINED`, it  **must**  be a format with [potential format features](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#potential-format-features) that include `VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT`
/// - If [`depth_attachment_format`] is not `VK_FORMAT_UNDEFINED` and [`stencil_attachment_format`]
///   is not `VK_FORMAT_UNDEFINED`, [`depth_attachment_format`] **must**  equal
///   [`stencil_attachment_format`]
/// - If the [`multiview`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-multiview)
///   feature is not enabled, [`view_mask`] **must**  be `0`
/// - The index of the most significant bit in [`view_mask`] **must**  be less than [`maxMultiviewViewCount`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#limits-maxMultiviewViewCount)
///
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be `VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO`
/// - [`flags`] **must**  be a valid combination of [`RenderingFlagBits`] values
/// - If [`color_attachment_count`] is not `0`, [`color_attachment_formats`] **must**  be a valid
///   pointer to an array of [`color_attachment_count`] valid [`Format`] values
/// - [`depth_attachment_format`] **must**  be a valid [`Format`] value
/// - [`stencil_attachment_format`] **must**  be a valid [`Format`] value
/// - If [`rasterization_samples`] is not `0`, [`rasterization_samples`] **must**  be a valid
///   [`SampleCountFlagBits`] value
///# Related
/// - [`khr_dynamic_rendering`]
/// - [`crate::vulkan1_3`]
/// - [`Format`]
/// - [`RenderingFlags`]
/// - [`SampleCountFlagBits`]
/// - [`StructureType`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkCommandBufferInheritanceRenderingInfo")]
#[derive(Debug, Clone, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[repr(C)]
pub struct CommandBufferInheritanceRenderingInfo<'lt> {
    ///Lifetime field
    pub _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] is the type of this structure
    pub s_type: StructureType,
    ///[`p_next`] is `NULL` or a pointer to a structure extending this
    ///structure
    pub p_next: *const BaseInStructure<'lt>,
    ///[`flags`] is a bitmask of [`RenderingFlagBits`] used by the render
    ///pass instance.
    pub flags: RenderingFlags,
    ///[`view_mask`] is the view mask used for rendering.
    pub view_mask: u32,
    ///[`color_attachment_count`] is the number of color attachments specified
    ///in the render pass instance.
    pub color_attachment_count: u32,
    ///[`color_attachment_formats`] is a pointer to an array of [`Format`]
    ///values defining the format of color attachments.
    pub color_attachment_formats: *const Format,
    ///[`depth_attachment_format`] is a [`Format`] value defining the
    ///format of the depth attachment.
    pub depth_attachment_format: Format,
    ///[`stencil_attachment_format`] is a [`Format`] value defining the
    ///format of the stencil attachment.
    pub stencil_attachment_format: Format,
    ///[`rasterization_samples`] is a [`SampleCountFlagBits`] specifying
    ///the number of samples used in rasterization.
    pub rasterization_samples: SampleCountFlagBits,
}
impl<'lt> Default for CommandBufferInheritanceRenderingInfo<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: StructureType::COMMAND_BUFFER_INHERITANCE_RENDERING_INFO,
            p_next: std::ptr::null(),
            flags: Default::default(),
            view_mask: 0,
            color_attachment_count: 0,
            color_attachment_formats: std::ptr::null(),
            depth_attachment_format: Default::default(),
            stencil_attachment_format: Default::default(),
            rasterization_samples: Default::default(),
        }
    }
}
impl<'lt> CommandBufferInheritanceRenderingInfo<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *const BaseInStructure<'lt> {
        self.p_next
    }
    ///Gets the raw value of [`Self::color_attachment_formats`]
    pub fn color_attachment_formats_raw(&self) -> *const Format {
        self.color_attachment_formats
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *const BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::color_attachment_formats`]
    pub fn set_color_attachment_formats_raw(&mut self, value: *const Format) -> &mut Self {
        self.color_attachment_formats = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn with_p_next_raw(mut self, value: *const BaseInStructure<'lt>) -> Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::color_attachment_formats`]
    pub fn with_color_attachment_formats_raw(mut self, value: *const Format) -> Self {
        self.color_attachment_formats = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseInStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::flags`]
    pub fn flags(&self) -> RenderingFlags {
        self.flags
    }
    ///Gets the value of [`Self::view_mask`]
    pub fn view_mask(&self) -> u32 {
        self.view_mask
    }
    ///Gets the value of [`Self::color_attachment_count`]
    pub fn color_attachment_count(&self) -> u32 {
        self.color_attachment_count
    }
    ///Gets the value of [`Self::color_attachment_formats`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn color_attachment_formats(&self) -> &[Format] {
        std::slice::from_raw_parts(self.color_attachment_formats, self.color_attachment_count as usize)
    }
    ///Gets the value of [`Self::depth_attachment_format`]
    pub fn depth_attachment_format(&self) -> Format {
        self.depth_attachment_format
    }
    ///Gets the value of [`Self::stencil_attachment_format`]
    pub fn stencil_attachment_format(&self) -> Format {
        self.stencil_attachment_format
    }
    ///Gets the value of [`Self::rasterization_samples`]
    pub fn rasterization_samples(&self) -> SampleCountFlagBits {
        self.rasterization_samples
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::flags`]
    pub fn flags_mut(&mut self) -> &mut RenderingFlags {
        &mut self.flags
    }
    ///Gets a mutable reference to the value of [`Self::view_mask`]
    pub fn view_mask_mut(&mut self) -> &mut u32 {
        &mut self.view_mask
    }
    ///Gets a mutable reference to the value of [`Self::color_attachment_count`]
    pub fn color_attachment_count_mut(&mut self) -> &mut u32 {
        &mut self.color_attachment_count
    }
    ///Gets a mutable reference to the value of [`Self::depth_attachment_format`]
    pub fn depth_attachment_format_mut(&mut self) -> &mut Format {
        &mut self.depth_attachment_format
    }
    ///Gets a mutable reference to the value of [`Self::stencil_attachment_format`]
    pub fn stencil_attachment_format_mut(&mut self) -> &mut Format {
        &mut self.stencil_attachment_format
    }
    ///Gets a mutable reference to the value of [`Self::rasterization_samples`]
    pub fn rasterization_samples_mut(&mut self) -> &mut SampleCountFlagBits {
        &mut self.rasterization_samples
    }
    ///Sets the value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the value of [`Self::flags`]
    pub fn set_flags(&mut self, value: crate::vulkan1_3::RenderingFlags) -> &mut Self {
        self.flags = value;
        self
    }
    ///Sets the value of [`Self::view_mask`]
    pub fn set_view_mask(&mut self, value: u32) -> &mut Self {
        self.view_mask = value;
        self
    }
    ///Sets the value of [`Self::color_attachment_count`]
    pub fn set_color_attachment_count(&mut self, value: u32) -> &mut Self {
        self.color_attachment_count = value;
        self
    }
    ///Sets the value of [`Self::color_attachment_formats`]
    pub fn set_color_attachment_formats(&mut self, value: &'lt [crate::vulkan1_0::Format]) -> &mut Self {
        let len_ = value.len() as u32;
        let len_ = len_;
        self.color_attachment_formats = value.as_ptr();
        self.color_attachment_count = len_;
        self
    }
    ///Sets the value of [`Self::depth_attachment_format`]
    pub fn set_depth_attachment_format(&mut self, value: crate::vulkan1_0::Format) -> &mut Self {
        self.depth_attachment_format = value;
        self
    }
    ///Sets the value of [`Self::stencil_attachment_format`]
    pub fn set_stencil_attachment_format(&mut self, value: crate::vulkan1_0::Format) -> &mut Self {
        self.stencil_attachment_format = value;
        self
    }
    ///Sets the value of [`Self::rasterization_samples`]
    pub fn set_rasterization_samples(&mut self, value: crate::vulkan1_0::SampleCountFlagBits) -> &mut Self {
        self.rasterization_samples = value;
        self
    }
    ///Sets the value of [`Self::s_type`]
    pub fn with_s_type(mut self, value: crate::vulkan1_0::StructureType) -> Self {
        self.s_type = value;
        self
    }
    ///Sets the value of [`Self::p_next`]
    pub fn with_p_next(mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the value of [`Self::flags`]
    pub fn with_flags(mut self, value: crate::vulkan1_3::RenderingFlags) -> Self {
        self.flags = value;
        self
    }
    ///Sets the value of [`Self::view_mask`]
    pub fn with_view_mask(mut self, value: u32) -> Self {
        self.view_mask = value;
        self
    }
    ///Sets the value of [`Self::color_attachment_count`]
    pub fn with_color_attachment_count(mut self, value: u32) -> Self {
        self.color_attachment_count = value;
        self
    }
    ///Sets the value of [`Self::color_attachment_formats`]
    pub fn with_color_attachment_formats(mut self, value: &'lt [crate::vulkan1_0::Format]) -> Self {
        let len_ = value.len() as u32;
        let len_ = len_;
        self.color_attachment_formats = value.as_ptr();
        self.color_attachment_count = len_;
        self
    }
    ///Sets the value of [`Self::depth_attachment_format`]
    pub fn with_depth_attachment_format(mut self, value: crate::vulkan1_0::Format) -> Self {
        self.depth_attachment_format = value;
        self
    }
    ///Sets the value of [`Self::stencil_attachment_format`]
    pub fn with_stencil_attachment_format(mut self, value: crate::vulkan1_0::Format) -> Self {
        self.stencil_attachment_format = value;
        self
    }
    ///Sets the value of [`Self::rasterization_samples`]
    pub fn with_rasterization_samples(mut self, value: crate::vulkan1_0::SampleCountFlagBits) -> Self {
        self.rasterization_samples = value;
        self
    }
}
impl PhysicalDevice {
    ///[vkGetPhysicalDeviceToolProperties](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceToolProperties.html) - Reports properties of tools active on the specified physical device
    ///# C Specifications
    ///Information about tools providing debugging, profiling, or similar services,
    ///active for a given physical device, can be obtained by calling:
    ///```c
    ///// Provided by VK_VERSION_1_3
    ///VkResult vkGetPhysicalDeviceToolProperties(
    ///    VkPhysicalDevice                            physicalDevice,
    ///    uint32_t*                                   pToolCount,
    ///    VkPhysicalDeviceToolProperties*             pToolProperties);
    ///```
    ///or the equivalent command
    ///```c
    ///// Provided by VK_EXT_tooling_info
    ///VkResult vkGetPhysicalDeviceToolPropertiesEXT(
    ///    VkPhysicalDevice                            physicalDevice,
    ///    uint32_t*                                   pToolCount,
    ///    VkPhysicalDeviceToolProperties*             pToolProperties);
    ///```
    ///# Parameters
    /// - [`physical_device`] is the handle to the physical device to query for active tools.
    /// - [`p_tool_count`] is a pointer to an integer describing the number of tools active on
    ///   [`physical_device`].
    /// - [`p_tool_properties`] is either `NULL` or a pointer to an array of
    ///   [`PhysicalDeviceToolProperties`] structures.
    ///# Description
    ///If [`p_tool_properties`] is `NULL`, then the number of tools currently
    ///active on [`physical_device`] is returned in [`p_tool_count`].
    ///Otherwise, [`p_tool_count`] **must**  point to a variable set by the user to the
    ///number of elements in the [`p_tool_properties`] array, and on return the
    ///variable is overwritten with the number of structures actually written to
    ///[`p_tool_properties`].
    ///If [`p_tool_count`] is less than the number of currently active tools, at
    ///most [`p_tool_count`] structures will be written.The count and properties of active tools
    /// **may**  change in response to events
    ///outside the scope of the specification.
    ///An application  **should**  assume these properties might change at any given
    ///time.
    ///## Valid Usage (Implicit)
    /// - [`physical_device`] **must**  be a valid [`PhysicalDevice`] handle
    /// - [`p_tool_count`] **must**  be a valid pointer to a `uint32_t` value
    /// - If the value referenced by [`p_tool_count`] is not `0`, and [`p_tool_properties`] is not
    ///   `NULL`, [`p_tool_properties`] **must**  be a valid pointer to an array of
    ///   [`p_tool_count`][`PhysicalDeviceToolProperties`] structures
    ///
    ///## Return Codes
    /// * - `VK_SUCCESS`  - `VK_INCOMPLETE`
    /// * - `VK_ERROR_OUT_OF_HOST_MEMORY`
    ///# Related
    /// - [`ext_tooling_info`]
    /// - [`crate::vulkan1_3`]
    /// - [`PhysicalDevice`]
    /// - [`PhysicalDeviceToolProperties`]
    ///
    ///# Notes and documentation
    ///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
    ///
    ///This documentation is generated from the Vulkan specification and documentation.
    ///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
    /// Commons Attribution 4.0 International*.
    ///This license explicitely allows adapting the source material as long as proper credit is
    /// given.
    #[doc(alias = "vkGetPhysicalDeviceToolProperties")]
    #[doc(alias = "vkGetPhysicalDeviceToolPropertiesEXT")]
    #[track_caller]
    #[inline]
    pub unsafe fn get_physical_device_tool_properties<'lt>(
        self: &Unique<PhysicalDevice>,
        p_tool_count: Option<usize>,
    ) -> VulkanResult<SmallVec<PhysicalDeviceToolProperties<'lt>>> {
        #[cfg(any(debug_assertions, feature = "assertions"))]
        let _function = self
            .instance()
            .vtable()
            .vulkan1_3()
            .and_then(|vtable| vtable.get_physical_device_tool_properties())
            .or_else(|| {
                #[cfg(feature = "VK_EXT_tooling_info")]
                return self
                    .instance()
                    .vtable()
                    .ext_tooling_info()
                    .and_then(|vtable| vtable.get_physical_device_tool_properties_ext());
                #[cfg(not(feature = "VK_EXT_tooling_info"))]
                return None;
            })
            .expect("function not loaded");
        #[cfg(not(any(debug_assertions, feature = "assertions")))]
        let _function = self
            .instance()
            .vtable()
            .vulkan1_3()
            .and_then(|vtable| vtable.get_physical_device_tool_properties())
            .or_else(|| {
                #[cfg(feature = "VK_EXT_tooling_info")]
                return self
                    .instance()
                    .vtable()
                    .ext_tooling_info()
                    .and_then(|vtable| vtable.get_physical_device_tool_properties_ext());
                #[cfg(not(feature = "VK_EXT_tooling_info"))]
                return None;
            })
            .unwrap_unchecked();
        let mut p_tool_count = match p_tool_count {
            Some(v) => v as _,
            None => {
                let mut v = 0;
                _function(self.as_raw(), &mut v, std::ptr::null_mut());
                v
            },
        };
        let mut p_tool_properties =
            SmallVec::<PhysicalDeviceToolProperties<'lt>>::from_elem(Default::default(), p_tool_count as usize);
        let _return = _function(self.as_raw(), &mut p_tool_count, p_tool_properties.as_mut_ptr());
        match _return {
            VulkanResultCodes::SUCCESS | VulkanResultCodes::INCOMPLETE => {
                VulkanResult::Success(_return, p_tool_properties)
            },
            e => VulkanResult::Err(e),
        }
    }
}
impl Device {
    ///[vkGetDeviceBufferMemoryRequirements](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceBufferMemoryRequirements.html) - Returns the memory requirements for specified Vulkan object
    ///# C Specifications
    ///To determine the memory requirements for a buffer resource without creating
    ///an object, call:
    ///```c
    ///// Provided by VK_VERSION_1_3
    ///void vkGetDeviceBufferMemoryRequirements(
    ///    VkDevice                                    device,
    ///    const VkDeviceBufferMemoryRequirements*     pInfo,
    ///    VkMemoryRequirements2*                      pMemoryRequirements);
    ///```
    ///or the equivalent command
    ///```c
    ///// Provided by VK_KHR_maintenance4
    ///void vkGetDeviceBufferMemoryRequirementsKHR(
    ///    VkDevice                                    device,
    ///    const VkDeviceBufferMemoryRequirements*     pInfo,
    ///    VkMemoryRequirements2*                      pMemoryRequirements);
    ///```
    ///# Parameters
    /// - [`device`] is the logical device intended to own the buffer.
    /// - [`p_info`] is a pointer to a [`DeviceBufferMemoryRequirements`] structure containing
    ///   parameters required for the memory requirements query.
    /// - [`p_memory_requirements`] is a pointer to a [`MemoryRequirements2`] structure in which the
    ///   memory requirements of the buffer object are returned.
    ///# Description
    ///## Valid Usage (Implicit)
    /// - [`device`] **must**  be a valid [`Device`] handle
    /// - [`p_info`] **must**  be a valid pointer to a valid [`DeviceBufferMemoryRequirements`]
    ///   structure
    /// - [`p_memory_requirements`] **must**  be a valid pointer to a [`MemoryRequirements2`]
    ///   structure
    ///# Related
    /// - [`khr_maintenance4`]
    /// - [`crate::vulkan1_3`]
    /// - [`Device`]
    /// - [`DeviceBufferMemoryRequirements`]
    /// - [`MemoryRequirements2`]
    ///
    ///# Notes and documentation
    ///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
    ///
    ///This documentation is generated from the Vulkan specification and documentation.
    ///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
    /// Commons Attribution 4.0 International*.
    ///This license explicitely allows adapting the source material as long as proper credit is
    /// given.
    #[doc(alias = "vkGetDeviceBufferMemoryRequirements")]
    #[doc(alias = "vkGetDeviceBufferMemoryRequirementsKHR")]
    #[track_caller]
    #[inline]
    pub unsafe fn get_device_buffer_memory_requirements<'lt>(
        self: &Unique<Device>,
        p_info: &DeviceBufferMemoryRequirements<'lt>,
        p_memory_requirements: Option<MemoryRequirements2<'lt>>,
    ) -> MemoryRequirements2<'lt> {
        #[cfg(any(debug_assertions, feature = "assertions"))]
        let _function = self
            .vtable()
            .vulkan1_3()
            .and_then(|vtable| vtable.get_device_buffer_memory_requirements())
            .or_else(|| {
                #[cfg(feature = "VK_KHR_maintenance4")]
                return self
                    .vtable()
                    .khr_maintenance4()
                    .and_then(|vtable| vtable.get_device_buffer_memory_requirements_khr());
                #[cfg(not(feature = "VK_KHR_maintenance4"))]
                return None;
            })
            .expect("function not loaded");
        #[cfg(not(any(debug_assertions, feature = "assertions")))]
        let _function = self
            .vtable()
            .vulkan1_3()
            .and_then(|vtable| vtable.get_device_buffer_memory_requirements())
            .or_else(|| {
                #[cfg(feature = "VK_KHR_maintenance4")]
                return self
                    .vtable()
                    .khr_maintenance4()
                    .and_then(|vtable| vtable.get_device_buffer_memory_requirements_khr());
                #[cfg(not(feature = "VK_KHR_maintenance4"))]
                return None;
            })
            .unwrap_unchecked();
        let mut p_memory_requirements = p_memory_requirements.unwrap_or_default();
        let _return = _function(
            self.as_raw(),
            p_info as *const DeviceBufferMemoryRequirements<'lt>,
            &mut p_memory_requirements,
        );
        {
            p_memory_requirements.p_next = std::ptr::null_mut();
            p_memory_requirements
        }
    }
}
impl Device {
    ///[vkGetDeviceImageMemoryRequirements](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceImageMemoryRequirements.html) - Returns the memory requirements for specified Vulkan object
    ///# C Specifications
    ///To determine the memory requirements for an image resource without creating
    ///an object, call:
    ///```c
    ///// Provided by VK_VERSION_1_3
    ///void vkGetDeviceImageMemoryRequirements(
    ///    VkDevice                                    device,
    ///    const VkDeviceImageMemoryRequirements*      pInfo,
    ///    VkMemoryRequirements2*                      pMemoryRequirements);
    ///```
    ///or the equivalent command
    ///```c
    ///// Provided by VK_KHR_maintenance4
    ///void vkGetDeviceImageMemoryRequirementsKHR(
    ///    VkDevice                                    device,
    ///    const VkDeviceImageMemoryRequirements*      pInfo,
    ///    VkMemoryRequirements2*                      pMemoryRequirements);
    ///```
    ///# Parameters
    /// - [`device`] is the logical device intended to own the image.
    /// - [`p_info`] is a pointer to a [`DeviceImageMemoryRequirements`] structure containing
    ///   parameters required for the memory requirements query.
    /// - [`p_memory_requirements`] is a pointer to a [`MemoryRequirements2`] structure in which the
    ///   memory requirements of the image object are returned.
    ///# Description
    ///## Valid Usage (Implicit)
    /// - [`device`] **must**  be a valid [`Device`] handle
    /// - [`p_info`] **must**  be a valid pointer to a valid [`DeviceImageMemoryRequirements`]
    ///   structure
    /// - [`p_memory_requirements`] **must**  be a valid pointer to a [`MemoryRequirements2`]
    ///   structure
    ///# Related
    /// - [`khr_maintenance4`]
    /// - [`crate::vulkan1_3`]
    /// - [`Device`]
    /// - [`DeviceImageMemoryRequirements`]
    /// - [`MemoryRequirements2`]
    ///
    ///# Notes and documentation
    ///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
    ///
    ///This documentation is generated from the Vulkan specification and documentation.
    ///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
    /// Commons Attribution 4.0 International*.
    ///This license explicitely allows adapting the source material as long as proper credit is
    /// given.
    #[doc(alias = "vkGetDeviceImageMemoryRequirements")]
    #[doc(alias = "vkGetDeviceImageMemoryRequirementsKHR")]
    #[track_caller]
    #[inline]
    pub unsafe fn get_device_image_memory_requirements<'lt>(
        self: &Unique<Device>,
        p_info: &DeviceImageMemoryRequirements<'lt>,
        p_memory_requirements: Option<MemoryRequirements2<'lt>>,
    ) -> MemoryRequirements2<'lt> {
        #[cfg(any(debug_assertions, feature = "assertions"))]
        let _function = self
            .vtable()
            .vulkan1_3()
            .and_then(|vtable| vtable.get_device_image_memory_requirements())
            .or_else(|| {
                #[cfg(feature = "VK_KHR_maintenance4")]
                return self
                    .vtable()
                    .khr_maintenance4()
                    .and_then(|vtable| vtable.get_device_image_memory_requirements_khr());
                #[cfg(not(feature = "VK_KHR_maintenance4"))]
                return None;
            })
            .expect("function not loaded");
        #[cfg(not(any(debug_assertions, feature = "assertions")))]
        let _function = self
            .vtable()
            .vulkan1_3()
            .and_then(|vtable| vtable.get_device_image_memory_requirements())
            .or_else(|| {
                #[cfg(feature = "VK_KHR_maintenance4")]
                return self
                    .vtable()
                    .khr_maintenance4()
                    .and_then(|vtable| vtable.get_device_image_memory_requirements_khr());
                #[cfg(not(feature = "VK_KHR_maintenance4"))]
                return None;
            })
            .unwrap_unchecked();
        let mut p_memory_requirements = p_memory_requirements.unwrap_or_default();
        let _return = _function(
            self.as_raw(),
            p_info as *const DeviceImageMemoryRequirements<'lt>,
            &mut p_memory_requirements,
        );
        {
            p_memory_requirements.p_next = std::ptr::null_mut();
            p_memory_requirements
        }
    }
}
impl Device {
    ///[vkGetDeviceImageSparseMemoryRequirements](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceImageSparseMemoryRequirements.html) - Query the memory requirements for a sparse image
    ///# C Specifications
    ///To determine the sparse memory requirements for an image resource without
    ///creating an object, call:
    ///```c
    ///// Provided by VK_VERSION_1_3
    ///void vkGetDeviceImageSparseMemoryRequirements(
    ///    VkDevice                                    device,
    ///    const VkDeviceImageMemoryRequirements*      pInfo,
    ///    uint32_t*                                   pSparseMemoryRequirementCount,
    ///    VkSparseImageMemoryRequirements2*           pSparseMemoryRequirements);
    ///```
    ///or the equivalent command
    ///```c
    ///// Provided by VK_KHR_maintenance4
    ///void vkGetDeviceImageSparseMemoryRequirementsKHR(
    ///    VkDevice                                    device,
    ///    const VkDeviceImageMemoryRequirements*      pInfo,
    ///    uint32_t*                                   pSparseMemoryRequirementCount,
    ///    VkSparseImageMemoryRequirements2*           pSparseMemoryRequirements);
    ///```
    ///# Parameters
    /// - [`device`] is the logical device intended to own the image.
    /// - [`p_info`] is a pointer to a [`DeviceImageMemoryRequirements`] structure containing
    ///   parameters required for the memory requirements query.
    /// - [`p_sparse_memory_requirement_count`] is a pointer to an integer related to the number of
    ///   sparse memory requirements available or queried, as described below.
    /// - [`p_sparse_memory_requirements`] is either `NULL` or a pointer to an array of
    ///   [`SparseImageMemoryRequirements2`] structures.
    ///# Description
    ///## Valid Usage (Implicit)
    /// - [`device`] **must**  be a valid [`Device`] handle
    /// - [`p_info`] **must**  be a valid pointer to a valid [`DeviceImageMemoryRequirements`]
    ///   structure
    /// - [`p_sparse_memory_requirement_count`] **must**  be a valid pointer to a `uint32_t` value
    /// - If the value referenced by [`p_sparse_memory_requirement_count`] is not `0`, and
    ///   [`p_sparse_memory_requirements`] is not `NULL`, [`p_sparse_memory_requirements`] **must**
    ///   be a valid pointer to an array of
    ///   [`p_sparse_memory_requirement_count`][`SparseImageMemoryRequirements2`] structures
    ///# Related
    /// - [`khr_maintenance4`]
    /// - [`crate::vulkan1_3`]
    /// - [`Device`]
    /// - [`DeviceImageMemoryRequirements`]
    /// - [`SparseImageMemoryRequirements2`]
    ///
    ///# Notes and documentation
    ///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
    ///
    ///This documentation is generated from the Vulkan specification and documentation.
    ///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
    /// Commons Attribution 4.0 International*.
    ///This license explicitely allows adapting the source material as long as proper credit is
    /// given.
    #[doc(alias = "vkGetDeviceImageSparseMemoryRequirements")]
    #[doc(alias = "vkGetDeviceImageSparseMemoryRequirementsKHR")]
    #[track_caller]
    #[inline]
    pub unsafe fn get_device_image_sparse_memory_requirements<'lt>(
        self: &Unique<Device>,
        p_info: &DeviceImageMemoryRequirements<'lt>,
        p_sparse_memory_requirement_count: Option<usize>,
    ) -> SmallVec<SparseImageMemoryRequirements2<'lt>> {
        #[cfg(any(debug_assertions, feature = "assertions"))]
        let _function = self
            .vtable()
            .vulkan1_3()
            .and_then(|vtable| vtable.get_device_image_sparse_memory_requirements())
            .or_else(|| {
                #[cfg(feature = "VK_KHR_maintenance4")]
                return self
                    .vtable()
                    .khr_maintenance4()
                    .and_then(|vtable| vtable.get_device_image_sparse_memory_requirements_khr());
                #[cfg(not(feature = "VK_KHR_maintenance4"))]
                return None;
            })
            .expect("function not loaded");
        #[cfg(not(any(debug_assertions, feature = "assertions")))]
        let _function = self
            .vtable()
            .vulkan1_3()
            .and_then(|vtable| vtable.get_device_image_sparse_memory_requirements())
            .or_else(|| {
                #[cfg(feature = "VK_KHR_maintenance4")]
                return self
                    .vtable()
                    .khr_maintenance4()
                    .and_then(|vtable| vtable.get_device_image_sparse_memory_requirements_khr());
                #[cfg(not(feature = "VK_KHR_maintenance4"))]
                return None;
            })
            .unwrap_unchecked();
        let mut p_sparse_memory_requirement_count = match p_sparse_memory_requirement_count {
            Some(v) => v as _,
            None => {
                let mut v = 0;
                _function(
                    self.as_raw(),
                    p_info as *const DeviceImageMemoryRequirements<'lt>,
                    &mut v,
                    std::ptr::null_mut(),
                );
                v
            },
        };
        let mut p_sparse_memory_requirements = SmallVec::<SparseImageMemoryRequirements2<'lt>>::from_elem(
            Default::default(),
            p_sparse_memory_requirement_count as usize,
        );
        let _return = _function(
            self.as_raw(),
            p_info as *const DeviceImageMemoryRequirements<'lt>,
            &mut p_sparse_memory_requirement_count,
            p_sparse_memory_requirements.as_mut_ptr(),
        );
        p_sparse_memory_requirements
    }
}
impl Device {
    ///[vkCreatePrivateDataSlot](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreatePrivateDataSlot.html) - Create a slot for private data storage
    ///# C Specifications
    ///To create a private data slot, call:
    ///```c
    ///// Provided by VK_VERSION_1_3
    ///VkResult vkCreatePrivateDataSlot(
    ///    VkDevice                                    device,
    ///    const VkPrivateDataSlotCreateInfo*          pCreateInfo,
    ///    const VkAllocationCallbacks*                pAllocator,
    ///    VkPrivateDataSlot*                          pPrivateDataSlot);
    ///```
    ///or the equivalent command
    ///```c
    ///// Provided by VK_EXT_private_data
    ///VkResult vkCreatePrivateDataSlotEXT(
    ///    VkDevice                                    device,
    ///    const VkPrivateDataSlotCreateInfo*          pCreateInfo,
    ///    const VkAllocationCallbacks*                pAllocator,
    ///    VkPrivateDataSlot*                          pPrivateDataSlot);
    ///```
    ///# Parameters
    /// - [`device`] is the logical device associated with the creation of the object(s) holding the
    ///   private data slot.
    /// - [`p_create_info`] is a pointer to a [`PrivateDataSlotCreateInfo`]
    /// - [`p_allocator`] controls host memory allocation as described in the [Memory Allocation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#memory-allocation)
    ///   chapter.
    /// - [`p_private_data_slot`] is a pointer to a [`PrivateDataSlot`] handle in which the
    ///   resulting private data slot is returned
    ///# Description
    ///## Valid Usage
    /// - The [`privateData`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-privateData)
    ///   feature  **must**  be enabled
    ///
    ///## Valid Usage (Implicit)
    /// - [`device`] **must**  be a valid [`Device`] handle
    /// - [`p_create_info`] **must**  be a valid pointer to a valid [`PrivateDataSlotCreateInfo`]
    ///   structure
    /// - If [`p_allocator`] is not `NULL`, [`p_allocator`] **must**  be a valid pointer to a valid
    ///   [`AllocationCallbacks`] structure
    /// - [`p_private_data_slot`] **must**  be a valid pointer to a [`PrivateDataSlot`] handle
    ///
    ///## Return Codes
    /// * - `VK_SUCCESS`
    /// * - `VK_ERROR_OUT_OF_HOST_MEMORY`
    ///# Related
    /// - [`ext_private_data`]
    /// - [`crate::vulkan1_3`]
    /// - [`AllocationCallbacks`]
    /// - [`Device`]
    /// - [`PrivateDataSlot`]
    /// - [`PrivateDataSlotCreateInfo`]
    ///
    ///# Notes and documentation
    ///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
    ///
    ///This documentation is generated from the Vulkan specification and documentation.
    ///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
    /// Commons Attribution 4.0 International*.
    ///This license explicitely allows adapting the source material as long as proper credit is
    /// given.
    #[doc(alias = "vkCreatePrivateDataSlot")]
    #[doc(alias = "vkCreatePrivateDataSlotEXT")]
    #[track_caller]
    #[inline]
    pub unsafe fn create_private_data_slot<'lt>(
        self: &Unique<Device>,
        p_create_info: &PrivateDataSlotCreateInfo<'lt>,
        p_allocator: Option<&AllocationCallbacks<'lt>>,
    ) -> VulkanResult<Unique<PrivateDataSlot>> {
        #[cfg(any(debug_assertions, feature = "assertions"))]
        let _function = self
            .vtable()
            .vulkan1_3()
            .and_then(|vtable| vtable.create_private_data_slot())
            .or_else(|| {
                #[cfg(feature = "VK_EXT_private_data")]
                return self
                    .vtable()
                    .ext_private_data()
                    .and_then(|vtable| vtable.create_private_data_slot_ext());
                #[cfg(not(feature = "VK_EXT_private_data"))]
                return None;
            })
            .expect("function not loaded");
        #[cfg(not(any(debug_assertions, feature = "assertions")))]
        let _function = self
            .vtable()
            .vulkan1_3()
            .and_then(|vtable| vtable.create_private_data_slot())
            .or_else(|| {
                #[cfg(feature = "VK_EXT_private_data")]
                return self
                    .vtable()
                    .ext_private_data()
                    .and_then(|vtable| vtable.create_private_data_slot_ext());
                #[cfg(not(feature = "VK_EXT_private_data"))]
                return None;
            })
            .unwrap_unchecked();
        let mut p_private_data_slot = MaybeUninit::<PrivateDataSlot>::uninit();
        let _return = _function(
            self.as_raw(),
            p_create_info as *const PrivateDataSlotCreateInfo<'lt>,
            p_allocator
                .map(|v| v as *const AllocationCallbacks<'lt>)
                .unwrap_or_else(std::ptr::null),
            p_private_data_slot.as_mut_ptr(),
        );
        match _return {
            VulkanResultCodes::SUCCESS => VulkanResult::Success(
                _return,
                Unique::new(self, p_private_data_slot.assume_init(), AtomicBool::default()),
            ),
            e => VulkanResult::Err(e),
        }
    }
}
impl Device {
    ///[vkDestroyPrivateDataSlot](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyPrivateDataSlot.html) - Destroy a private data slot
    ///# C Specifications
    ///To destroy a private data slot, call:
    ///```c
    ///// Provided by VK_VERSION_1_3
    ///void vkDestroyPrivateDataSlot(
    ///    VkDevice                                    device,
    ///    VkPrivateDataSlot                           privateDataSlot,
    ///    const VkAllocationCallbacks*                pAllocator);
    ///```
    ///or the equivalent command
    ///```c
    ///// Provided by VK_EXT_private_data
    ///void vkDestroyPrivateDataSlotEXT(
    ///    VkDevice                                    device,
    ///    VkPrivateDataSlot                           privateDataSlot,
    ///    const VkAllocationCallbacks*                pAllocator);
    ///```
    ///# Parameters
    /// - [`device`] is the logical device associated with the creation of the object(s) holding the
    ///   private data slot.
    /// - [`p_allocator`] controls host memory allocation as described in the [Memory Allocation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#memory-allocation)
    ///   chapter.
    /// - [`private_data_slot`] is the private data slot to destroy.
    ///# Description
    ///## Valid Usage
    /// - If [`AllocationCallbacks`] were provided when [`private_data_slot`] was created, a
    ///   compatible set of callbacks  **must**  be provided here
    /// - If no [`AllocationCallbacks`] were provided when [`private_data_slot`] was created,
    ///   [`p_allocator`] **must**  be `NULL`
    ///
    ///## Valid Usage (Implicit)
    /// - [`device`] **must**  be a valid [`Device`] handle
    /// - If [`private_data_slot`] is not [`crate::Handle::null`], [`private_data_slot`] **must**
    ///   be a valid [`PrivateDataSlot`] handle
    /// - If [`p_allocator`] is not `NULL`, [`p_allocator`] **must**  be a valid pointer to a valid
    ///   [`AllocationCallbacks`] structure
    /// - If [`private_data_slot`] is a valid handle, it  **must**  have been created, allocated, or
    ///   retrieved from [`device`]
    ///
    ///## Host Synchronization
    /// - Host access to [`private_data_slot`] **must**  be externally synchronized
    ///# Related
    /// - [`ext_private_data`]
    /// - [`crate::vulkan1_3`]
    /// - [`AllocationCallbacks`]
    /// - [`Device`]
    /// - [`PrivateDataSlot`]
    ///
    ///# Notes and documentation
    ///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
    ///
    ///This documentation is generated from the Vulkan specification and documentation.
    ///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
    /// Commons Attribution 4.0 International*.
    ///This license explicitely allows adapting the source material as long as proper credit is
    /// given.
    #[doc(alias = "vkDestroyPrivateDataSlot")]
    #[doc(alias = "vkDestroyPrivateDataSlotEXT")]
    #[track_caller]
    #[inline]
    pub unsafe fn destroy_private_data_slot<'lt>(
        self: &Unique<Device>,
        private_data_slot: Option<PrivateDataSlot>,
        p_allocator: Option<&AllocationCallbacks<'lt>>,
    ) -> () {
        #[cfg(any(debug_assertions, feature = "assertions"))]
        let _function = self
            .vtable()
            .vulkan1_3()
            .and_then(|vtable| vtable.destroy_private_data_slot())
            .or_else(|| {
                #[cfg(feature = "VK_EXT_private_data")]
                return self
                    .vtable()
                    .ext_private_data()
                    .and_then(|vtable| vtable.destroy_private_data_slot_ext());
                #[cfg(not(feature = "VK_EXT_private_data"))]
                return None;
            })
            .expect("function not loaded");
        #[cfg(not(any(debug_assertions, feature = "assertions")))]
        let _function = self
            .vtable()
            .vulkan1_3()
            .and_then(|vtable| vtable.destroy_private_data_slot())
            .or_else(|| {
                #[cfg(feature = "VK_EXT_private_data")]
                return self
                    .vtable()
                    .ext_private_data()
                    .and_then(|vtable| vtable.destroy_private_data_slot_ext());
                #[cfg(not(feature = "VK_EXT_private_data"))]
                return None;
            })
            .unwrap_unchecked();
        let _return = _function(
            self.as_raw(),
            private_data_slot.unwrap_or_default(),
            p_allocator
                .map(|v| v as *const AllocationCallbacks<'lt>)
                .unwrap_or_else(std::ptr::null),
        );
        ()
    }
}
impl Device {
    ///[vkSetPrivateData](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkSetPrivateData.html) - Associate data with a Vulkan object
    ///# C Specifications
    ///To store user defined data in a slot associated with a Vulkan object, call:
    ///```c
    ///// Provided by VK_VERSION_1_3
    ///VkResult vkSetPrivateData(
    ///    VkDevice                                    device,
    ///    VkObjectType                                objectType,
    ///    uint64_t                                    objectHandle,
    ///    VkPrivateDataSlot                           privateDataSlot,
    ///    uint64_t                                    data);
    ///```
    ///or the equivalent command
    ///```c
    ///// Provided by VK_EXT_private_data
    ///VkResult vkSetPrivateDataEXT(
    ///    VkDevice                                    device,
    ///    VkObjectType                                objectType,
    ///    uint64_t                                    objectHandle,
    ///    VkPrivateDataSlot                           privateDataSlot,
    ///    uint64_t                                    data);
    ///```
    ///# Parameters
    /// - [`device`] is the device that created the object.
    /// - [`object_type`] is a [`ObjectType`] specifying the type of object to associate data with.
    /// - [`object_handle`] is a handle to the object to associate data with.
    /// - [`private_data_slot`] is a handle to a [`PrivateDataSlot`] specifying location of private
    ///   data storage.
    /// - [`data`] is user defined data to associate the object with. This data will be stored at
    ///   [`private_data_slot`].
    ///# Description
    ///## Valid Usage
    /// - [`object_handle`] **must**  be [`device`] or a child of [`device`]
    /// - [`object_handle`] **must**  be a valid handle to an object of type [`object_type`]
    ///
    ///## Valid Usage (Implicit)
    /// - [`device`] **must**  be a valid [`Device`] handle
    /// - [`object_type`] **must**  be a valid [`ObjectType`] value
    /// - [`private_data_slot`] **must**  be a valid [`PrivateDataSlot`] handle
    /// - [`private_data_slot`] **must**  have been created, allocated, or retrieved from [`device`]
    ///
    ///## Return Codes
    /// * - `VK_SUCCESS`
    /// * - `VK_ERROR_OUT_OF_HOST_MEMORY`
    ///# Related
    /// - [`ext_private_data`]
    /// - [`crate::vulkan1_3`]
    /// - [`Device`]
    /// - [`ObjectType`]
    /// - [`PrivateDataSlot`]
    ///
    ///# Notes and documentation
    ///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
    ///
    ///This documentation is generated from the Vulkan specification and documentation.
    ///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
    /// Commons Attribution 4.0 International*.
    ///This license explicitely allows adapting the source material as long as proper credit is
    /// given.
    #[doc(alias = "vkSetPrivateData")]
    #[doc(alias = "vkSetPrivateDataEXT")]
    #[track_caller]
    #[inline]
    pub unsafe fn set_private_data(
        self: &Unique<Device>,
        object_type: ObjectType,
        object_handle: Option<u64>,
        private_data_slot: PrivateDataSlot,
        data: Option<u64>,
    ) -> VulkanResult<()> {
        #[cfg(any(debug_assertions, feature = "assertions"))]
        let _function = self
            .vtable()
            .vulkan1_3()
            .and_then(|vtable| vtable.set_private_data())
            .or_else(|| {
                #[cfg(feature = "VK_EXT_private_data")]
                return self
                    .vtable()
                    .ext_private_data()
                    .and_then(|vtable| vtable.set_private_data_ext());
                #[cfg(not(feature = "VK_EXT_private_data"))]
                return None;
            })
            .expect("function not loaded");
        #[cfg(not(any(debug_assertions, feature = "assertions")))]
        let _function = self
            .vtable()
            .vulkan1_3()
            .and_then(|vtable| vtable.set_private_data())
            .or_else(|| {
                #[cfg(feature = "VK_EXT_private_data")]
                return self
                    .vtable()
                    .ext_private_data()
                    .and_then(|vtable| vtable.set_private_data_ext());
                #[cfg(not(feature = "VK_EXT_private_data"))]
                return None;
            })
            .unwrap_unchecked();
        let _return = _function(
            self.as_raw(),
            object_type,
            object_handle.unwrap_or_default() as _,
            private_data_slot,
            data.unwrap_or_default() as _,
        );
        match _return {
            VulkanResultCodes::SUCCESS => VulkanResult::Success(_return, ()),
            e => VulkanResult::Err(e),
        }
    }
}
impl Device {
    ///[vkGetPrivateData](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPrivateData.html) - Retrieve data associated with a Vulkan object
    ///# C Specifications
    ///To retrieve user defined data from a slot associated with a Vulkan object,
    ///call:
    ///```c
    ///// Provided by VK_VERSION_1_3
    ///void vkGetPrivateData(
    ///    VkDevice                                    device,
    ///    VkObjectType                                objectType,
    ///    uint64_t                                    objectHandle,
    ///    VkPrivateDataSlot                           privateDataSlot,
    ///    uint64_t*                                   pData);
    ///```
    ///or the equivalent command
    ///```c
    ///// Provided by VK_EXT_private_data
    ///void vkGetPrivateDataEXT(
    ///    VkDevice                                    device,
    ///    VkObjectType                                objectType,
    ///    uint64_t                                    objectHandle,
    ///    VkPrivateDataSlot                           privateDataSlot,
    ///    uint64_t*                                   pData);
    ///```
    ///# Parameters
    /// - [`device`] is the device that created the object
    /// - [`object_type`] is a [`ObjectType`] specifying the type of object data is associated with.
    /// - [`object_handle`] is a handle to the object data is associated with.
    /// - [`private_data_slot`] is a handle to a [`PrivateDataSlot`] specifying location of private
    ///   data pointer storage.
    /// - [`p_data`] is a pointer to specify where user data is returned. `0` will be written in the
    ///   absence of a previous call to [`set_private_data`] using the object specified by
    ///   [`object_handle`].
    ///# Description
    ///## Valid Usage
    /// - [`object_type`] **must**  be `VK_OBJECT_TYPE_DEVICE`, or an object type whose parent is
    ///   [`Device`]
    ///
    ///## Valid Usage (Implicit)
    /// - [`device`] **must**  be a valid [`Device`] handle
    /// - [`object_type`] **must**  be a valid [`ObjectType`] value
    /// - [`private_data_slot`] **must**  be a valid [`PrivateDataSlot`] handle
    /// - [`p_data`] **must**  be a valid pointer to a `uint64_t` value
    /// - [`private_data_slot`] **must**  have been created, allocated, or retrieved from [`device`]
    ///# Related
    /// - [`ext_private_data`]
    /// - [`crate::vulkan1_3`]
    /// - [`Device`]
    /// - [`ObjectType`]
    /// - [`PrivateDataSlot`]
    ///
    ///# Notes and documentation
    ///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
    ///
    ///This documentation is generated from the Vulkan specification and documentation.
    ///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
    /// Commons Attribution 4.0 International*.
    ///This license explicitely allows adapting the source material as long as proper credit is
    /// given.
    #[doc(alias = "vkGetPrivateData")]
    #[doc(alias = "vkGetPrivateDataEXT")]
    #[track_caller]
    #[inline]
    pub unsafe fn get_private_data(
        self: &Unique<Device>,
        object_type: ObjectType,
        object_handle: Option<u64>,
        private_data_slot: PrivateDataSlot,
    ) -> u64 {
        #[cfg(any(debug_assertions, feature = "assertions"))]
        let _function = self
            .vtable()
            .vulkan1_3()
            .and_then(|vtable| vtable.get_private_data())
            .or_else(|| {
                #[cfg(feature = "VK_EXT_private_data")]
                return self
                    .vtable()
                    .ext_private_data()
                    .and_then(|vtable| vtable.get_private_data_ext());
                #[cfg(not(feature = "VK_EXT_private_data"))]
                return None;
            })
            .expect("function not loaded");
        #[cfg(not(any(debug_assertions, feature = "assertions")))]
        let _function = self
            .vtable()
            .vulkan1_3()
            .and_then(|vtable| vtable.get_private_data())
            .or_else(|| {
                #[cfg(feature = "VK_EXT_private_data")]
                return self
                    .vtable()
                    .ext_private_data()
                    .and_then(|vtable| vtable.get_private_data_ext());
                #[cfg(not(feature = "VK_EXT_private_data"))]
                return None;
            })
            .unwrap_unchecked();
        let mut p_data = Default::default();
        let _return = _function(
            self.as_raw(),
            object_type,
            object_handle.unwrap_or_default() as _,
            private_data_slot,
            &mut p_data,
        );
        p_data
    }
}
impl Queue {
    ///[vkQueueSubmit2](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkQueueSubmit2.html) - Submits command buffers to a queue
    ///# C Specifications
    ///To submit command buffers to a queue, call:
    ///```c
    ///// Provided by VK_VERSION_1_3
    ///VkResult vkQueueSubmit2(
    ///    VkQueue                                     queue,
    ///    uint32_t                                    submitCount,
    ///    const VkSubmitInfo2*                        pSubmits,
    ///    VkFence                                     fence);
    ///```
    ///or the equivalent command
    ///```c
    ///// Provided by VK_KHR_synchronization2
    ///VkResult vkQueueSubmit2KHR(
    ///    VkQueue                                     queue,
    ///    uint32_t                                    submitCount,
    ///    const VkSubmitInfo2*                        pSubmits,
    ///    VkFence                                     fence);
    ///```
    ///# Parameters
    /// - [`queue`] is the queue that the command buffers will be submitted to.
    /// - [`submit_count`] is the number of elements in the [`p_submits`] array.
    /// - [`p_submits`] is a pointer to an array of [`SubmitInfo2`] structures, each specifying a
    ///   command buffer submission batch.
    /// - [`fence`] is an  **optional**  handle to a fence to be signaled once all submitted command
    ///   buffers have completed execution. If [`fence`] is not [`crate::Handle::null`], it defines a
    ///   [fence signal operation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-fences-signaling).
    ///# Description
    ///[`queue_submit2`] is a [queue submission
    ///command](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#devsandqueues-submission), with each batch defined by an element of [`p_submits`].Semaphore operations submitted with [`queue_submit2`] have additional
    ///ordering constraints compared to other submission commands, with
    ///dependencies involving previous and subsequent queue operations.
    ///Information about these additional constraints can be found in the
    ///[semaphore](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-semaphores) section of [the
    ///synchronization chapter](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization).If any command buffer submitted to this queue is in the
    ///[executable state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#commandbuffers-lifecycle), it is moved to the
    ///[pending state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#commandbuffers-lifecycle).
    ///Once execution of all submissions of a command buffer complete, it moves
    ///from the [pending state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#commandbuffers-lifecycle), back to the
    ///[executable state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#commandbuffers-lifecycle).
    ///If a command buffer was recorded with the
    ///`VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT` flag, it instead moves
    ///back to the [invalid state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#commandbuffers-lifecycle).If [`queue_submit2`] fails, it  **may**  return
    ///`VK_ERROR_OUT_OF_HOST_MEMORY` or `VK_ERROR_OUT_OF_DEVICE_MEMORY`.
    ///If it does, the implementation  **must**  ensure that the state and contents of
    ///any resources or synchronization primitives referenced by the submitted
    ///command buffers and any semaphores referenced by [`p_submits`] is
    ///unaffected by the call or its failure.
    ///If [`queue_submit2`] fails in such a way that the implementation is
    ///unable to make that guarantee, the implementation  **must**  return
    ///`VK_ERROR_DEVICE_LOST`.
    ///See [Lost Device](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#devsandqueues-lost-device).
    ///## Valid Usage
    /// - If [`fence`] is not [`crate::Handle::null`], [`fence`] **must**  be unsignaled
    /// - If [`fence`] is not [`crate::Handle::null`], [`fence`] **must**  not be associated with
    ///   any other queue command that has not yet completed execution on that queue
    /// - The [`synchronization2`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-synchronization2)
    ///   feature  **must**  be enabled
    /// - If a command recorded into the `commandBuffer` member of any element of the
    ///   `pCommandBufferInfos` member of any element of [`p_submits`] referenced an [`Event`], that
    ///   event  **must**  not be referenced by a command that has been submitted to another queue
    ///   and is still in the *pending state*
    /// - The `semaphore` member of any binary semaphore element of the `pSignalSemaphoreInfos`
    ///   member of any element of [`p_submits`] **must**  be unsignaled when the semaphore signal
    ///   operation it defines is executed on the device
    /// - The `stageMask` member of any element of the `pSignalSemaphoreInfos` member of any element
    ///   of [`p_submits`] **must**  only include pipeline stages that are supported by the queue
    ///   family which [`queue`] belongs to
    /// - The `stageMask` member of any element of the `pWaitSemaphoreInfos` member of any element
    ///   of [`p_submits`] **must**  only include pipeline stages that are supported by the queue
    ///   family which [`queue`] belongs to
    /// - When a semaphore wait operation for a binary semaphore is executed, as defined by the
    ///   `semaphore` member of any element of the `pWaitSemaphoreInfos` member of any element of
    ///   [`p_submits`], there  **must**  be no other queues waiting on the same semaphore
    /// -    The `semaphore` member of any element of the `pWaitSemaphoreInfos` member of any element of [`p_submits`] **must**  be semaphores that are signaled, or have [semaphore signal operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-semaphores-signaling) previously submitted for execution
    /// - Any `semaphore` member of any element of the `pWaitSemaphoreInfos` member of any element
    ///   of [`p_submits`] that was created with a [`SemaphoreTypeKHR`] of
    ///   `VK_SEMAPHORE_TYPE_BINARY_KHR` **must**  reference a semaphore signal operation that has
    ///   been submitted for execution and any semaphore signal operations on which it depends (if
    ///   any)  **must**  have also been submitted for execution
    /// -    The `commandBuffer` member of any element of the `pCommandBufferInfos` member of any element of [`p_submits`] **must**  be in the [pending or executable state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#commandbuffers-lifecycle)
    /// -    If a command recorded into the `commandBuffer` member of any element of the `pCommandBufferInfos` member of any element of [`p_submits`] was not recorded with the `VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT`, it  **must**  not be in the [pending state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#commandbuffers-lifecycle)
    /// -    Any [secondary command buffers recorded](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#commandbuffers-secondary) into the `commandBuffer` member of any element of the `pCommandBufferInfos` member of any element of [`p_submits`] **must**  be in the [pending or executable state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#commandbuffers-lifecycle)
    /// -    If any [secondary command buffers recorded](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#commandbuffers-secondary) into the `commandBuffer` member of any element of the `pCommandBufferInfos` member of any element of [`p_submits`] was not recorded with the `VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT`, it  **must**  not be in the [pending state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#commandbuffers-lifecycle)
    /// - The `commandBuffer` member of any element of the `pCommandBufferInfos` member of any
    ///   element of [`p_submits`] **must**  have been allocated from a [`CommandPool`] that was
    ///   created for the same queue family [`queue`] belongs to
    /// -    If a command recorded into the `commandBuffer` member of any element of the `pCommandBufferInfos` member of any element of [`p_submits`] includes a [Queue Family Transfer Acquire Operation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-queue-transfers-acquire), there  **must**  exist a previously submitted [Queue Family Transfer Release Operation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-queue-transfers-release) on a queue in the queue family identified by the acquire operation, with parameters matching the acquire operation as defined in the definition of such [acquire operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-queue-transfers-acquire), and which happens before the acquire operation
    /// -    If a command recorded into the `commandBuffer` member of any element of the `pCommandBufferInfos` member of any element of [`p_submits`] was a [`cmd_begin_query`] whose `queryPool` was created with a `queryType` of `VK_QUERY_TYPE_PERFORMANCE_QUERY_KHR`, the [profiling lock](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#profiling-lock) **must**  have been held continuously on the [`Device`] that [`queue`] was retrieved from, throughout recording of those command buffers
    /// - If [`queue`] was not created with `VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT`, the `flags`
    ///   member of any element of [`p_submits`] **must**  not include `VK_SUBMIT_PROTECTED_BIT_KHR`
    ///
    ///## Valid Usage (Implicit)
    /// - [`queue`] **must**  be a valid [`Queue`] handle
    /// - If [`submit_count`] is not `0`, [`p_submits`] **must**  be a valid pointer to an array of
    ///   [`submit_count`] valid [`SubmitInfo2`] structures
    /// - If [`fence`] is not [`crate::Handle::null`], [`fence`] **must**  be a valid [`Fence`]
    ///   handle
    /// - Both of [`fence`], and [`queue`] that are valid handles of non-ignored parameters
    ///   **must**  have been created, allocated, or retrieved from the same [`Device`]
    ///
    ///## Host Synchronization
    /// - Host access to [`queue`] **must**  be externally synchronized
    /// - Host access to [`fence`] **must**  be externally synchronized
    ///
    ///## Command Properties
    ///## Return Codes
    /// * - `VK_SUCCESS`
    /// * - `VK_ERROR_OUT_OF_HOST_MEMORY`  - `VK_ERROR_OUT_OF_DEVICE_MEMORY`  -
    ///   `VK_ERROR_DEVICE_LOST`
    ///# Related
    /// - [`khr_synchronization2`]
    /// - [`crate::vulkan1_3`]
    /// - [`Fence`]
    /// - [`Queue`]
    /// - [`SubmitInfo2`]
    ///
    ///# Notes and documentation
    ///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
    ///
    ///This documentation is generated from the Vulkan specification and documentation.
    ///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
    /// Commons Attribution 4.0 International*.
    ///This license explicitely allows adapting the source material as long as proper credit is
    /// given.
    #[doc(alias = "vkQueueSubmit2")]
    #[doc(alias = "vkQueueSubmit2KHR")]
    #[track_caller]
    #[inline]
    pub unsafe fn queue_submit2<'lt>(
        self: &Unique<Queue>,
        p_submits: &[crate::vulkan1_3::SubmitInfo2<'lt>],
        fence: Option<Fence>,
    ) -> VulkanResult<()> {
        #[cfg(any(debug_assertions, feature = "assertions"))]
        let _function = self
            .device()
            .vtable()
            .vulkan1_3()
            .and_then(|vtable| vtable.queue_submit2())
            .or_else(|| {
                #[cfg(feature = "VK_KHR_synchronization2")]
                return self
                    .device()
                    .vtable()
                    .khr_synchronization2()
                    .and_then(|vtable| vtable.queue_submit2_khr());
                #[cfg(not(feature = "VK_KHR_synchronization2"))]
                return None;
            })
            .expect("function not loaded");
        #[cfg(not(any(debug_assertions, feature = "assertions")))]
        let _function = self
            .device()
            .vtable()
            .vulkan1_3()
            .and_then(|vtable| vtable.queue_submit2())
            .or_else(|| {
                #[cfg(feature = "VK_KHR_synchronization2")]
                return self
                    .device()
                    .vtable()
                    .khr_synchronization2()
                    .and_then(|vtable| vtable.queue_submit2_khr());
                #[cfg(not(feature = "VK_KHR_synchronization2"))]
                return None;
            })
            .unwrap_unchecked();
        let submit_count = (|len: usize| len)(p_submits.len()) as _;
        let _return = _function(
            self.as_raw(),
            submit_count,
            p_submits.as_ptr(),
            fence.unwrap_or_default(),
        );
        match _return {
            VulkanResultCodes::SUCCESS => VulkanResult::Success(_return, ()),
            e => VulkanResult::Err(e),
        }
    }
}
impl CommandBuffer {
    ///[vkCmdSetCullMode](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetCullMode.html) - Set cull mode dynamically for a command buffer
    ///# C Specifications
    ///To [dynamically set](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipelines-dynamic-state) the cull mode, call:
    ///```c
    ///// Provided by VK_VERSION_1_3
    ///void vkCmdSetCullMode(
    ///    VkCommandBuffer                             commandBuffer,
    ///    VkCullModeFlags                             cullMode);
    ///```
    ///or the equivalent command
    ///```c
    ///// Provided by VK_EXT_extended_dynamic_state
    ///void vkCmdSetCullModeEXT(
    ///    VkCommandBuffer                             commandBuffer,
    ///    VkCullModeFlags                             cullMode);
    ///```
    ///# Parameters
    /// - [`command_buffer`] is the command buffer into which the command will be recorded.
    /// - [`cull_mode`] specifies the cull mode property to use for drawing.
    ///# Description
    ///This command sets the cull mode for subsequent drawing commands when the
    ///graphics pipeline is created with `VK_DYNAMIC_STATE_CULL_MODE` set in
    ///[`PipelineDynamicStateCreateInfo::dynamic_states`].
    ///Otherwise, this state is specified by the
    ///[`PipelineRasterizationStateCreateInfo`]::[`cull_mode`] value used to
    ///create the currently active pipeline.
    ///## Valid Usage (Implicit)
    /// - [`command_buffer`] **must**  be a valid [`CommandBuffer`] handle
    /// - [`cull_mode`] **must**  be a valid combination of [`CullModeFlagBits`] values
    /// - [`command_buffer`] **must**  be in the [recording state]()
    /// - The [`CommandPool`] that [`command_buffer`] was allocated from  **must**  support graphics
    ///   operations
    ///
    ///## Host Synchronization
    /// - Host access to [`command_buffer`] **must**  be externally synchronized
    /// - Host access to the [`CommandPool`] that [`command_buffer`] was allocated from  **must**
    ///   be externally synchronized
    ///
    ///## Command Properties
    ///# Related
    /// - [`ext_extended_dynamic_state`]
    /// - [`crate::vulkan1_3`]
    /// - [`CommandBuffer`]
    /// - [`CullModeFlags`]
    ///
    ///# Notes and documentation
    ///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
    ///
    ///This documentation is generated from the Vulkan specification and documentation.
    ///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
    /// Commons Attribution 4.0 International*.
    ///This license explicitely allows adapting the source material as long as proper credit is
    /// given.
    #[doc(alias = "vkCmdSetCullMode")]
    #[doc(alias = "vkCmdSetCullModeEXT")]
    #[track_caller]
    #[inline]
    pub unsafe fn cmd_set_cull_mode(self: &Unique<CommandBuffer>, cull_mode: CullModeFlags) -> () {
        #[cfg(any(debug_assertions, feature = "assertions"))]
        let _function = self
            .device()
            .vtable()
            .vulkan1_3()
            .and_then(|vtable| vtable.cmd_set_cull_mode())
            .or_else(|| {
                #[cfg(feature = "VK_EXT_extended_dynamic_state")]
                return self
                    .device()
                    .vtable()
                    .ext_extended_dynamic_state()
                    .and_then(|vtable| vtable.cmd_set_cull_mode_ext());
                #[cfg(not(feature = "VK_EXT_extended_dynamic_state"))]
                return None;
            })
            .expect("function not loaded");
        #[cfg(not(any(debug_assertions, feature = "assertions")))]
        let _function = self
            .device()
            .vtable()
            .vulkan1_3()
            .and_then(|vtable| vtable.cmd_set_cull_mode())
            .or_else(|| {
                #[cfg(feature = "VK_EXT_extended_dynamic_state")]
                return self
                    .device()
                    .vtable()
                    .ext_extended_dynamic_state()
                    .and_then(|vtable| vtable.cmd_set_cull_mode_ext());
                #[cfg(not(feature = "VK_EXT_extended_dynamic_state"))]
                return None;
            })
            .unwrap_unchecked();
        let _return = _function(self.as_raw(), cull_mode);
        ()
    }
}
impl CommandBuffer {
    ///[vkCmdSetFrontFace](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetFrontFace.html) - Set front face orientation dynamically for a command buffer
    ///# C Specifications
    ///To [dynamically set](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipelines-dynamic-state) the front face orientation,
    ///call:
    ///```c
    ///// Provided by VK_VERSION_1_3
    ///void vkCmdSetFrontFace(
    ///    VkCommandBuffer                             commandBuffer,
    ///    VkFrontFace                                 frontFace);
    ///```
    ///or the equivalent command
    ///```c
    ///// Provided by VK_EXT_extended_dynamic_state
    ///void vkCmdSetFrontFaceEXT(
    ///    VkCommandBuffer                             commandBuffer,
    ///    VkFrontFace                                 frontFace);
    ///```
    ///# Parameters
    /// - [`command_buffer`] is the command buffer into which the command will be recorded.
    /// - [`front_face`] is a [`FrontFace`] value specifying the front-facing triangle orientation
    ///   to be used for culling.
    ///# Description
    ///This command sets the front face orientation for subsequent drawing commands
    ///when the graphics pipeline is created with `VK_DYNAMIC_STATE_FRONT_FACE`
    ///set in [`PipelineDynamicStateCreateInfo::dynamic_states`].
    ///Otherwise, this state is specified by the
    ///[`PipelineRasterizationStateCreateInfo`]::[`front_face`] value used to
    ///create the currently active pipeline.
    ///## Valid Usage (Implicit)
    /// - [`command_buffer`] **must**  be a valid [`CommandBuffer`] handle
    /// - [`front_face`] **must**  be a valid [`FrontFace`] value
    /// - [`command_buffer`] **must**  be in the [recording state]()
    /// - The [`CommandPool`] that [`command_buffer`] was allocated from  **must**  support graphics
    ///   operations
    ///
    ///## Host Synchronization
    /// - Host access to [`command_buffer`] **must**  be externally synchronized
    /// - Host access to the [`CommandPool`] that [`command_buffer`] was allocated from  **must**
    ///   be externally synchronized
    ///
    ///## Command Properties
    ///# Related
    /// - [`ext_extended_dynamic_state`]
    /// - [`crate::vulkan1_3`]
    /// - [`CommandBuffer`]
    /// - [`FrontFace`]
    ///
    ///# Notes and documentation
    ///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
    ///
    ///This documentation is generated from the Vulkan specification and documentation.
    ///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
    /// Commons Attribution 4.0 International*.
    ///This license explicitely allows adapting the source material as long as proper credit is
    /// given.
    #[doc(alias = "vkCmdSetFrontFace")]
    #[doc(alias = "vkCmdSetFrontFaceEXT")]
    #[track_caller]
    #[inline]
    pub unsafe fn cmd_set_front_face(self: &Unique<CommandBuffer>, front_face: FrontFace) -> () {
        #[cfg(any(debug_assertions, feature = "assertions"))]
        let _function = self
            .device()
            .vtable()
            .vulkan1_3()
            .and_then(|vtable| vtable.cmd_set_front_face())
            .or_else(|| {
                #[cfg(feature = "VK_EXT_extended_dynamic_state")]
                return self
                    .device()
                    .vtable()
                    .ext_extended_dynamic_state()
                    .and_then(|vtable| vtable.cmd_set_front_face_ext());
                #[cfg(not(feature = "VK_EXT_extended_dynamic_state"))]
                return None;
            })
            .expect("function not loaded");
        #[cfg(not(any(debug_assertions, feature = "assertions")))]
        let _function = self
            .device()
            .vtable()
            .vulkan1_3()
            .and_then(|vtable| vtable.cmd_set_front_face())
            .or_else(|| {
                #[cfg(feature = "VK_EXT_extended_dynamic_state")]
                return self
                    .device()
                    .vtable()
                    .ext_extended_dynamic_state()
                    .and_then(|vtable| vtable.cmd_set_front_face_ext());
                #[cfg(not(feature = "VK_EXT_extended_dynamic_state"))]
                return None;
            })
            .unwrap_unchecked();
        let _return = _function(self.as_raw(), front_face);
        ()
    }
}
impl CommandBuffer {
    ///[vkCmdSetPrimitiveTopology](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetPrimitiveTopology.html) - Set primitive topology state dynamically for a command buffer
    ///# C Specifications
    ///To [dynamically set](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipelines-dynamic-state) primitive topology, call:
    ///```c
    ///// Provided by VK_VERSION_1_3
    ///void vkCmdSetPrimitiveTopology(
    ///    VkCommandBuffer                             commandBuffer,
    ///    VkPrimitiveTopology                         primitiveTopology);
    ///```
    ///or the equivalent command
    ///```c
    ///// Provided by VK_EXT_extended_dynamic_state
    ///void vkCmdSetPrimitiveTopologyEXT(
    ///    VkCommandBuffer                             commandBuffer,
    ///    VkPrimitiveTopology                         primitiveTopology);
    ///```
    ///# Parameters
    /// - [`command_buffer`] is the command buffer into which the command will be recorded.
    /// - [`primitive_topology`] specifies the primitive topology to use for drawing.
    ///# Description
    ///This command sets the primitive topology for subsequent drawing commands
    ///when the graphics pipeline is created with
    ///`VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY` set in
    ///[`PipelineDynamicStateCreateInfo::dynamic_states`].
    ///Otherwise, this state is specified by the
    ///[`PipelineInputAssemblyStateCreateInfo::topology`] value used to
    ///create the currently active pipeline.
    ///## Valid Usage (Implicit)
    /// - [`command_buffer`] **must**  be a valid [`CommandBuffer`] handle
    /// - [`primitive_topology`] **must**  be a valid [`PrimitiveTopology`] value
    /// - [`command_buffer`] **must**  be in the [recording state]()
    /// - The [`CommandPool`] that [`command_buffer`] was allocated from  **must**  support graphics
    ///   operations
    ///
    ///## Host Synchronization
    /// - Host access to [`command_buffer`] **must**  be externally synchronized
    /// - Host access to the [`CommandPool`] that [`command_buffer`] was allocated from  **must**
    ///   be externally synchronized
    ///
    ///## Command Properties
    ///# Related
    /// - [`ext_extended_dynamic_state`]
    /// - [`crate::vulkan1_3`]
    /// - [`CommandBuffer`]
    /// - [`PrimitiveTopology`]
    ///
    ///# Notes and documentation
    ///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
    ///
    ///This documentation is generated from the Vulkan specification and documentation.
    ///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
    /// Commons Attribution 4.0 International*.
    ///This license explicitely allows adapting the source material as long as proper credit is
    /// given.
    #[doc(alias = "vkCmdSetPrimitiveTopology")]
    #[doc(alias = "vkCmdSetPrimitiveTopologyEXT")]
    #[track_caller]
    #[inline]
    pub unsafe fn cmd_set_primitive_topology(
        self: &Unique<CommandBuffer>,
        primitive_topology: PrimitiveTopology,
    ) -> () {
        #[cfg(any(debug_assertions, feature = "assertions"))]
        let _function = self
            .device()
            .vtable()
            .vulkan1_3()
            .and_then(|vtable| vtable.cmd_set_primitive_topology())
            .or_else(|| {
                #[cfg(feature = "VK_EXT_extended_dynamic_state")]
                return self
                    .device()
                    .vtable()
                    .ext_extended_dynamic_state()
                    .and_then(|vtable| vtable.cmd_set_primitive_topology_ext());
                #[cfg(not(feature = "VK_EXT_extended_dynamic_state"))]
                return None;
            })
            .expect("function not loaded");
        #[cfg(not(any(debug_assertions, feature = "assertions")))]
        let _function = self
            .device()
            .vtable()
            .vulkan1_3()
            .and_then(|vtable| vtable.cmd_set_primitive_topology())
            .or_else(|| {
                #[cfg(feature = "VK_EXT_extended_dynamic_state")]
                return self
                    .device()
                    .vtable()
                    .ext_extended_dynamic_state()
                    .and_then(|vtable| vtable.cmd_set_primitive_topology_ext());
                #[cfg(not(feature = "VK_EXT_extended_dynamic_state"))]
                return None;
            })
            .unwrap_unchecked();
        let _return = _function(self.as_raw(), primitive_topology);
        ()
    }
}
impl CommandBuffer {
    ///[vkCmdSetViewportWithCount](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetViewportWithCount.html) - Set the viewport count and viewports dynamically for a command buffer
    ///# C Specifications
    ///To [dynamically set](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipelines-dynamic-state) the viewport count and
    ///viewports, call:
    ///```c
    ///// Provided by VK_VERSION_1_3
    ///void vkCmdSetViewportWithCount(
    ///    VkCommandBuffer                             commandBuffer,
    ///    uint32_t                                    viewportCount,
    ///    const VkViewport*                           pViewports);
    ///```
    ///or the equivalent command
    ///```c
    ///// Provided by VK_EXT_extended_dynamic_state
    ///void vkCmdSetViewportWithCountEXT(
    ///    VkCommandBuffer                             commandBuffer,
    ///    uint32_t                                    viewportCount,
    ///    const VkViewport*                           pViewports);
    ///```
    ///# Parameters
    /// - [`command_buffer`] is the command buffer into which the command will be recorded.
    /// - [`viewport_count`] specifies the viewport count.
    /// - [`p_viewports`] specifies the viewports to use for drawing.
    ///# Description
    ///This command sets the viewport count and viewports state for subsequent
    ///drawing commands when the graphics pipeline is created with
    ///`VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT` set in
    ///[`PipelineDynamicStateCreateInfo::dynamic_states`].
    ///Otherwise, this state is specified by the corresponding
    ///[`PipelineViewportStateCreateInfo`]::[`viewport_count`] and
    ///[`p_viewports`] values used to create the currently active pipeline.
    ///## Valid Usage
    /// - [`viewport_count`] **must**  be between `1` and [`PhysicalDeviceLimits::max_viewports`],
    ///   inclusive
    /// - If the [multiple viewports](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-multiViewport)
    ///   feature is not enabled, [`viewport_count`] **must**  be `1`
    /// - [`command_buffer`] **must**  not have
    ///   [`CommandBufferInheritanceViewportScissorInfoNV::viewport_scissor2_d`] enabled
    ///
    ///## Valid Usage (Implicit)
    /// - [`command_buffer`] **must**  be a valid [`CommandBuffer`] handle
    /// - [`p_viewports`] **must**  be a valid pointer to an array of [`viewport_count`] valid
    ///   [`Viewport`] structures
    /// - [`command_buffer`] **must**  be in the [recording state]()
    /// - The [`CommandPool`] that [`command_buffer`] was allocated from  **must**  support graphics
    ///   operations
    /// - [`viewport_count`] **must**  be greater than `0`
    ///
    ///## Host Synchronization
    /// - Host access to [`command_buffer`] **must**  be externally synchronized
    /// - Host access to the [`CommandPool`] that [`command_buffer`] was allocated from  **must**
    ///   be externally synchronized
    ///
    ///## Command Properties
    ///# Related
    /// - [`ext_extended_dynamic_state`]
    /// - [`crate::vulkan1_3`]
    /// - [`CommandBuffer`]
    /// - [`Viewport`]
    ///
    ///# Notes and documentation
    ///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
    ///
    ///This documentation is generated from the Vulkan specification and documentation.
    ///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
    /// Commons Attribution 4.0 International*.
    ///This license explicitely allows adapting the source material as long as proper credit is
    /// given.
    #[doc(alias = "vkCmdSetViewportWithCount")]
    #[doc(alias = "vkCmdSetViewportWithCountEXT")]
    #[track_caller]
    #[inline]
    pub unsafe fn cmd_set_viewport_with_count(
        self: &Unique<CommandBuffer>,
        p_viewports: &[crate::vulkan1_0::Viewport],
    ) -> () {
        #[cfg(any(debug_assertions, feature = "assertions"))]
        let _function = self
            .device()
            .vtable()
            .vulkan1_3()
            .and_then(|vtable| vtable.cmd_set_viewport_with_count())
            .or_else(|| {
                #[cfg(feature = "VK_EXT_extended_dynamic_state")]
                return self
                    .device()
                    .vtable()
                    .ext_extended_dynamic_state()
                    .and_then(|vtable| vtable.cmd_set_viewport_with_count_ext());
                #[cfg(not(feature = "VK_EXT_extended_dynamic_state"))]
                return None;
            })
            .expect("function not loaded");
        #[cfg(not(any(debug_assertions, feature = "assertions")))]
        let _function = self
            .device()
            .vtable()
            .vulkan1_3()
            .and_then(|vtable| vtable.cmd_set_viewport_with_count())
            .or_else(|| {
                #[cfg(feature = "VK_EXT_extended_dynamic_state")]
                return self
                    .device()
                    .vtable()
                    .ext_extended_dynamic_state()
                    .and_then(|vtable| vtable.cmd_set_viewport_with_count_ext());
                #[cfg(not(feature = "VK_EXT_extended_dynamic_state"))]
                return None;
            })
            .unwrap_unchecked();
        let viewport_count = (|len: usize| len)(p_viewports.len()) as _;
        let _return = _function(self.as_raw(), viewport_count, p_viewports.as_ptr());
        ()
    }
}
impl CommandBuffer {
    ///[vkCmdSetScissorWithCount](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetScissorWithCount.html) - Set the scissor count and scissor rectangular bounds dynamically for a command buffer
    ///# C Specifications
    ///To [dynamically set](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipelines-dynamic-state) the scissor count and
    ///scissor rectangular bounds, call:
    ///```c
    ///// Provided by VK_VERSION_1_3
    ///void vkCmdSetScissorWithCount(
    ///    VkCommandBuffer                             commandBuffer,
    ///    uint32_t                                    scissorCount,
    ///    const VkRect2D*                             pScissors);
    ///```
    ///or the equivalent command
    ///```c
    ///// Provided by VK_EXT_extended_dynamic_state
    ///void vkCmdSetScissorWithCountEXT(
    ///    VkCommandBuffer                             commandBuffer,
    ///    uint32_t                                    scissorCount,
    ///    const VkRect2D*                             pScissors);
    ///```
    ///# Parameters
    /// - [`command_buffer`] is the command buffer into which the command will be recorded.
    /// - [`scissor_count`] specifies the scissor count.
    /// - [`p_scissors`] specifies the scissors to use for drawing.
    ///# Description
    ///This command sets the scissor count and scissor rectangular bounds state for
    ///subsequence drawing commands when the graphics pipeline is created with
    ///`VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT` set in
    ///[`PipelineDynamicStateCreateInfo::dynamic_states`].
    ///Otherwise, this state is specified by the corresponding
    ///[`PipelineViewportStateCreateInfo`]::[`scissor_count`] and
    ///[`p_scissors`] values used to create the currently active pipeline.
    ///## Valid Usage
    /// - [`scissor_count`] **must**  be between `1` and [`PhysicalDeviceLimits::max_viewports`],
    ///   inclusive
    /// - If the [multiple viewports](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-multiViewport)
    ///   feature is not enabled, [`scissor_count`] **must**  be `1`
    /// - The `x` and `y` members of `offset` member of any element of [`p_scissors`] **must**  be
    ///   greater than or equal to `0`
    /// - Evaluation of (`offset.x` +  `extent.width`) **must**  not cause a signed integer addition
    ///   overflow for any element of [`p_scissors`]
    /// - Evaluation of (`offset.y` +  `extent.height`) **must**  not cause a signed integer
    ///   addition overflow for any element of [`p_scissors`]
    /// - [`command_buffer`] **must**  not have
    ///   [`CommandBufferInheritanceViewportScissorInfoNV::viewport_scissor2_d`] enabled
    ///
    ///## Valid Usage (Implicit)
    /// - [`command_buffer`] **must**  be a valid [`CommandBuffer`] handle
    /// - [`p_scissors`] **must**  be a valid pointer to an array of [`scissor_count`][`Rect2D`]
    ///   structures
    /// - [`command_buffer`] **must**  be in the [recording state]()
    /// - The [`CommandPool`] that [`command_buffer`] was allocated from  **must**  support graphics
    ///   operations
    /// - [`scissor_count`] **must**  be greater than `0`
    ///
    ///## Host Synchronization
    /// - Host access to [`command_buffer`] **must**  be externally synchronized
    /// - Host access to the [`CommandPool`] that [`command_buffer`] was allocated from  **must**
    ///   be externally synchronized
    ///
    ///## Command Properties
    ///# Related
    /// - [`ext_extended_dynamic_state`]
    /// - [`crate::vulkan1_3`]
    /// - [`CommandBuffer`]
    /// - [`Rect2D`]
    ///
    ///# Notes and documentation
    ///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
    ///
    ///This documentation is generated from the Vulkan specification and documentation.
    ///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
    /// Commons Attribution 4.0 International*.
    ///This license explicitely allows adapting the source material as long as proper credit is
    /// given.
    #[doc(alias = "vkCmdSetScissorWithCount")]
    #[doc(alias = "vkCmdSetScissorWithCountEXT")]
    #[track_caller]
    #[inline]
    pub unsafe fn cmd_set_scissor_with_count(
        self: &Unique<CommandBuffer>,
        p_scissors: &[crate::vulkan1_0::Rect2D],
    ) -> () {
        #[cfg(any(debug_assertions, feature = "assertions"))]
        let _function = self
            .device()
            .vtable()
            .vulkan1_3()
            .and_then(|vtable| vtable.cmd_set_scissor_with_count())
            .or_else(|| {
                #[cfg(feature = "VK_EXT_extended_dynamic_state")]
                return self
                    .device()
                    .vtable()
                    .ext_extended_dynamic_state()
                    .and_then(|vtable| vtable.cmd_set_scissor_with_count_ext());
                #[cfg(not(feature = "VK_EXT_extended_dynamic_state"))]
                return None;
            })
            .expect("function not loaded");
        #[cfg(not(any(debug_assertions, feature = "assertions")))]
        let _function = self
            .device()
            .vtable()
            .vulkan1_3()
            .and_then(|vtable| vtable.cmd_set_scissor_with_count())
            .or_else(|| {
                #[cfg(feature = "VK_EXT_extended_dynamic_state")]
                return self
                    .device()
                    .vtable()
                    .ext_extended_dynamic_state()
                    .and_then(|vtable| vtable.cmd_set_scissor_with_count_ext());
                #[cfg(not(feature = "VK_EXT_extended_dynamic_state"))]
                return None;
            })
            .unwrap_unchecked();
        let scissor_count = (|len: usize| len)(p_scissors.len()) as _;
        let _return = _function(self.as_raw(), scissor_count, p_scissors.as_ptr());
        ()
    }
}
impl CommandBuffer {
    ///[vkCmdBindVertexBuffers2](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBindVertexBuffers2.html) - Bind vertex buffers to a command buffer and dynamically set strides
    ///# C Specifications
    ///Alternatively, to bind vertex buffers, along with their sizes and strides,
    ///to a command buffer for use in subsequent drawing commands, call:
    ///```c
    ///// Provided by VK_VERSION_1_3
    ///void vkCmdBindVertexBuffers2(
    ///    VkCommandBuffer                             commandBuffer,
    ///    uint32_t                                    firstBinding,
    ///    uint32_t                                    bindingCount,
    ///    const VkBuffer*                             pBuffers,
    ///    const VkDeviceSize*                         pOffsets,
    ///    const VkDeviceSize*                         pSizes,
    ///    const VkDeviceSize*                         pStrides);
    ///```
    ///or the equivalent command
    ///```c
    ///// Provided by VK_EXT_extended_dynamic_state
    ///void vkCmdBindVertexBuffers2EXT(
    ///    VkCommandBuffer                             commandBuffer,
    ///    uint32_t                                    firstBinding,
    ///    uint32_t                                    bindingCount,
    ///    const VkBuffer*                             pBuffers,
    ///    const VkDeviceSize*                         pOffsets,
    ///    const VkDeviceSize*                         pSizes,
    ///    const VkDeviceSize*                         pStrides);
    ///```
    ///# Parameters
    /// - [`command_buffer`] is the command buffer into which the command is recorded.
    /// - [`first_binding`] is the index of the first vertex input binding whose state is updated by
    ///   the command.
    /// - [`binding_count`] is the number of vertex input bindings whose state is updated by the
    ///   command.
    /// - [`p_buffers`] is a pointer to an array of buffer handles.
    /// - [`p_offsets`] is a pointer to an array of buffer offsets.
    /// - [`p_sizes`] is `NULL` or a pointer to an array of the size in bytes of vertex data bound
    ///   from [`p_buffers`].
    /// - [`p_strides`] is `NULL` or a pointer to an array of buffer strides.
    ///# Description
    ///The values taken from elements i of [`p_buffers`] and [`p_offsets`]
    ///replace the current state for the vertex input binding
    ///[`first_binding`] +  i, for i in [0,
    ///[`binding_count`]).
    ///The vertex input binding is updated to start at the offset indicated by
    ///[`p_offsets`][i] from the start of the buffer [`p_buffers`][i].
    ///If [`p_sizes`] is not `NULL` then [`p_sizes`][i] specifies the bound size
    ///of the vertex buffer starting from the corresponding elements of
    ///[`p_buffers`][i] plus [`p_offsets`][i].
    ///All vertex input attributes that use each of these bindings will use these
    ///updated addresses in their address calculations for subsequent drawing
    ///commands.
    ///If the [nullDescriptor](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-nullDescriptor) feature is enabled,
    ///elements of [`p_buffers`] **can**  be [`crate::Handle::null`], and  **can**  be used by
    ///the vertex shader.
    ///If a vertex input attribute is bound to a vertex input binding that is
    ///[`crate::Handle::null`], the values taken from memory are considered to be
    ///zero, and missing G, B, or A components are
    ///[filled with (0,0,1)](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#fxvertex-input-extraction).This command also [dynamically sets](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipelines-dynamic-state) the byte
    ///strides between consecutive elements within buffer [`p_buffers`][i] to the
    ///corresponding [`p_strides`][i] value when the graphics pipeline is created
    ///with `VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE` set in
    ///[`PipelineDynamicStateCreateInfo::dynamic_states`].
    ///Otherwise, strides are specified by the
    ///[`VertexInputBindingDescription::stride`] values used to create
    ///the currently active pipeline.If the bound pipeline state object was also created with the
    ///`VK_DYNAMIC_STATE_VERTEX_INPUT_EXT` dynamic state enabled then
    ///[`cmd_set_vertex_input_ext`] **can**  be used instead of
    ///[`cmd_bind_vertex_buffers2`] to set the stride.
    ///## Valid Usage
    /// - [`first_binding`] **must**  be less than
    ///   [`PhysicalDeviceLimits::max_vertex_input_bindings`]
    /// - The sum of [`first_binding`] and [`binding_count`] **must**  be less than or equal to
    ///   [`PhysicalDeviceLimits::max_vertex_input_bindings`]
    /// - All elements of [`p_offsets`] **must**  be less than the size of the corresponding element
    ///   in [`p_buffers`]
    /// - If [`p_sizes`] is not `NULL`, all elements of [`p_offsets`] plus [`p_sizes`] **must**  be
    ///   less than or equal to the size of the corresponding element in [`p_buffers`]
    /// - All elements of [`p_buffers`] **must**  have been created with the
    ///   `VK_BUFFER_USAGE_VERTEX_BUFFER_BIT` flag
    /// - Each element of [`p_buffers`] that is non-sparse  **must**  be bound completely and
    ///   contiguously to a single [`DeviceMemory`] object
    /// - If the [nullDescriptor](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-nullDescriptor)
    ///   feature is not enabled, all elements of [`p_buffers`] **must**  not be
    ///   [`crate::Handle::null`]
    /// - If an element of [`p_buffers`] is [`crate::Handle::null`], then the corresponding element
    ///   of [`p_offsets`] **must**  be zero
    /// - If [`p_strides`] is not `NULL` each element of [`p_strides`] **must**  be less than or
    ///   equal to [`PhysicalDeviceLimits::max_vertex_input_binding_stride`]
    /// - If [`p_strides`] is not `NULL` each element of [`p_strides`] **must**  be either 0 or
    ///   greater than or equal to the maximum extent of all vertex input attributes fetched from
    ///   the corresponding binding, where the extent is calculated as the
    ///   [`VertexInputAttributeDescription::offset`] plus
    ///   [`VertexInputAttributeDescription::format`] size
    ///
    ///## Valid Usage (Implicit)
    /// - [`command_buffer`] **must**  be a valid [`CommandBuffer`] handle
    /// - [`p_buffers`] **must**  be a valid pointer to an array of [`binding_count`] valid or
    ///   [`crate::Handle::null`][`Buffer`] handles
    /// - [`p_offsets`] **must**  be a valid pointer to an array of [`binding_count`][`DeviceSize`]
    ///   values
    /// - If [`p_sizes`] is not `NULL`, [`p_sizes`] **must**  be a valid pointer to an array of
    ///   [`binding_count`][`DeviceSize`] values
    /// - If [`p_strides`] is not `NULL`, [`p_strides`] **must**  be a valid pointer to an array of
    ///   [`binding_count`][`DeviceSize`] values
    /// - [`command_buffer`] **must**  be in the [recording state]()
    /// - The [`CommandPool`] that [`command_buffer`] was allocated from  **must**  support graphics
    ///   operations
    /// - If any of [`p_sizes`], or [`p_strides`] are not `NULL`, [`binding_count`] **must**  be
    ///   greater than `0`
    /// - Both of [`command_buffer`], and the elements of [`p_buffers`] that are valid handles of
    ///   non-ignored parameters  **must**  have been created, allocated, or retrieved from the same
    ///   [`Device`]
    ///
    ///## Host Synchronization
    /// - Host access to [`command_buffer`] **must**  be externally synchronized
    /// - Host access to the [`CommandPool`] that [`command_buffer`] was allocated from  **must**
    ///   be externally synchronized
    ///
    ///## Command Properties
    ///# Related
    /// - [`ext_extended_dynamic_state`]
    /// - [`crate::vulkan1_3`]
    /// - [`Buffer`]
    /// - [`CommandBuffer`]
    /// - [`DeviceSize`]
    ///
    ///# Notes and documentation
    ///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
    ///
    ///This documentation is generated from the Vulkan specification and documentation.
    ///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
    /// Commons Attribution 4.0 International*.
    ///This license explicitely allows adapting the source material as long as proper credit is
    /// given.
    #[doc(alias = "vkCmdBindVertexBuffers2")]
    #[doc(alias = "vkCmdBindVertexBuffers2EXT")]
    #[track_caller]
    #[inline]
    pub unsafe fn cmd_bind_vertex_buffers2(
        self: &Unique<CommandBuffer>,
        first_binding: Option<u32>,
        p_buffers: Option<&[crate::vulkan1_0::Buffer]>,
        p_offsets: &[crate::vulkan1_0::DeviceSize],
        p_sizes: Option<&[crate::vulkan1_0::DeviceSize]>,
        p_strides: Option<&[crate::vulkan1_0::DeviceSize]>,
    ) -> () {
        #[cfg(any(debug_assertions, feature = "assertions"))]
        let _function = self
            .device()
            .vtable()
            .vulkan1_3()
            .and_then(|vtable| vtable.cmd_bind_vertex_buffers2())
            .or_else(|| {
                #[cfg(feature = "VK_EXT_extended_dynamic_state")]
                return self
                    .device()
                    .vtable()
                    .ext_extended_dynamic_state()
                    .and_then(|vtable| vtable.cmd_bind_vertex_buffers2_ext());
                #[cfg(not(feature = "VK_EXT_extended_dynamic_state"))]
                return None;
            })
            .expect("function not loaded");
        #[cfg(not(any(debug_assertions, feature = "assertions")))]
        let _function = self
            .device()
            .vtable()
            .vulkan1_3()
            .and_then(|vtable| vtable.cmd_bind_vertex_buffers2())
            .or_else(|| {
                #[cfg(feature = "VK_EXT_extended_dynamic_state")]
                return self
                    .device()
                    .vtable()
                    .ext_extended_dynamic_state()
                    .and_then(|vtable| vtable.cmd_bind_vertex_buffers2_ext());
                #[cfg(not(feature = "VK_EXT_extended_dynamic_state"))]
                return None;
            })
            .unwrap_unchecked();
        let binding_count = (|len: usize| len)(p_buffers.map_or(0, |i| i.len())) as _;
        let _return = _function(
            self.as_raw(),
            first_binding.unwrap_or_default() as _,
            binding_count,
            p_buffers.map(|slice| slice.as_ptr()).unwrap_or_else(std::ptr::null),
            p_offsets.as_ptr(),
            p_sizes.map(|slice| slice.as_ptr()).unwrap_or_else(std::ptr::null),
            p_strides.map(|slice| slice.as_ptr()).unwrap_or_else(std::ptr::null),
        );
        ()
    }
}
impl CommandBuffer {
    ///[vkCmdSetDepthTestEnable](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDepthTestEnable.html) - Set depth test enable dynamically for a command buffer
    ///# C Specifications
    ///To [dynamically enable or disable](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipelines-dynamic-state) the depth
    ///test, call:
    ///```c
    ///// Provided by VK_VERSION_1_3
    ///void vkCmdSetDepthTestEnable(
    ///    VkCommandBuffer                             commandBuffer,
    ///    VkBool32                                    depthTestEnable);
    ///```
    ///or the equivalent command
    ///```c
    ///// Provided by VK_EXT_extended_dynamic_state
    ///void vkCmdSetDepthTestEnableEXT(
    ///    VkCommandBuffer                             commandBuffer,
    ///    VkBool32                                    depthTestEnable);
    ///```
    ///# Parameters
    /// - [`command_buffer`] is the command buffer into which the command will be recorded.
    /// - [`depth_test_enable`] specifies if the depth test is enabled.
    ///# Description
    ///This command sets the depth test enable for subsequent drawing commands when
    ///the graphics pipeline is created with
    ///`VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE` set in
    ///[`PipelineDynamicStateCreateInfo::dynamic_states`].
    ///Otherwise, this state is specified by the
    ///[`PipelineDepthStencilStateCreateInfo`]::[`depth_test_enable`] value
    ///used to create the currently active pipeline.
    ///## Valid Usage (Implicit)
    /// - [`command_buffer`] **must**  be a valid [`CommandBuffer`] handle
    /// - [`command_buffer`] **must**  be in the [recording state]()
    /// - The [`CommandPool`] that [`command_buffer`] was allocated from  **must**  support graphics
    ///   operations
    ///
    ///## Host Synchronization
    /// - Host access to [`command_buffer`] **must**  be externally synchronized
    /// - Host access to the [`CommandPool`] that [`command_buffer`] was allocated from  **must**
    ///   be externally synchronized
    ///
    ///## Command Properties
    ///# Related
    /// - [`ext_extended_dynamic_state`]
    /// - [`crate::vulkan1_3`]
    /// - [`Bool32`]
    /// - [`CommandBuffer`]
    ///
    ///# Notes and documentation
    ///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
    ///
    ///This documentation is generated from the Vulkan specification and documentation.
    ///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
    /// Commons Attribution 4.0 International*.
    ///This license explicitely allows adapting the source material as long as proper credit is
    /// given.
    #[doc(alias = "vkCmdSetDepthTestEnable")]
    #[doc(alias = "vkCmdSetDepthTestEnableEXT")]
    #[track_caller]
    #[inline]
    pub unsafe fn cmd_set_depth_test_enable(self: &Unique<CommandBuffer>, depth_test_enable: bool) -> () {
        #[cfg(any(debug_assertions, feature = "assertions"))]
        let _function = self
            .device()
            .vtable()
            .vulkan1_3()
            .and_then(|vtable| vtable.cmd_set_depth_test_enable())
            .or_else(|| {
                #[cfg(feature = "VK_EXT_extended_dynamic_state")]
                return self
                    .device()
                    .vtable()
                    .ext_extended_dynamic_state()
                    .and_then(|vtable| vtable.cmd_set_depth_test_enable_ext());
                #[cfg(not(feature = "VK_EXT_extended_dynamic_state"))]
                return None;
            })
            .expect("function not loaded");
        #[cfg(not(any(debug_assertions, feature = "assertions")))]
        let _function = self
            .device()
            .vtable()
            .vulkan1_3()
            .and_then(|vtable| vtable.cmd_set_depth_test_enable())
            .or_else(|| {
                #[cfg(feature = "VK_EXT_extended_dynamic_state")]
                return self
                    .device()
                    .vtable()
                    .ext_extended_dynamic_state()
                    .and_then(|vtable| vtable.cmd_set_depth_test_enable_ext());
                #[cfg(not(feature = "VK_EXT_extended_dynamic_state"))]
                return None;
            })
            .unwrap_unchecked();
        let _return = _function(self.as_raw(), depth_test_enable as u8 as u32);
        ()
    }
}
impl CommandBuffer {
    ///[vkCmdSetDepthWriteEnable](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDepthWriteEnable.html) - Set depth write enable dynamically for a command buffer
    ///# C Specifications
    ///To [dynamically set](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipelines-dynamic-state) the depth write enable,
    ///call:
    ///```c
    ///// Provided by VK_VERSION_1_3
    ///void vkCmdSetDepthWriteEnable(
    ///    VkCommandBuffer                             commandBuffer,
    ///    VkBool32                                    depthWriteEnable);
    ///```
    ///or the equivalent command
    ///```c
    ///// Provided by VK_EXT_extended_dynamic_state
    ///void vkCmdSetDepthWriteEnableEXT(
    ///    VkCommandBuffer                             commandBuffer,
    ///    VkBool32                                    depthWriteEnable);
    ///```
    ///# Parameters
    /// - [`command_buffer`] is the command buffer into which the command will be recorded.
    /// - [`depth_write_enable`] specifies if depth writes are enabled.
    ///# Description
    ///This command sets the depth write enable for subsequent drawing commands
    ///when the graphics pipeline is created with
    ///`VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE` set in
    ///[`PipelineDynamicStateCreateInfo::dynamic_states`].
    ///Otherwise, this state is specified by the
    ///[`PipelineDepthStencilStateCreateInfo`]::[`depth_write_enable`] value
    ///used to create the currently active pipeline.
    ///## Valid Usage (Implicit)
    /// - [`command_buffer`] **must**  be a valid [`CommandBuffer`] handle
    /// - [`command_buffer`] **must**  be in the [recording state]()
    /// - The [`CommandPool`] that [`command_buffer`] was allocated from  **must**  support graphics
    ///   operations
    ///
    ///## Host Synchronization
    /// - Host access to [`command_buffer`] **must**  be externally synchronized
    /// - Host access to the [`CommandPool`] that [`command_buffer`] was allocated from  **must**
    ///   be externally synchronized
    ///
    ///## Command Properties
    ///# Related
    /// - [`ext_extended_dynamic_state`]
    /// - [`crate::vulkan1_3`]
    /// - [`Bool32`]
    /// - [`CommandBuffer`]
    ///
    ///# Notes and documentation
    ///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
    ///
    ///This documentation is generated from the Vulkan specification and documentation.
    ///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
    /// Commons Attribution 4.0 International*.
    ///This license explicitely allows adapting the source material as long as proper credit is
    /// given.
    #[doc(alias = "vkCmdSetDepthWriteEnable")]
    #[doc(alias = "vkCmdSetDepthWriteEnableEXT")]
    #[track_caller]
    #[inline]
    pub unsafe fn cmd_set_depth_write_enable(self: &Unique<CommandBuffer>, depth_write_enable: bool) -> () {
        #[cfg(any(debug_assertions, feature = "assertions"))]
        let _function = self
            .device()
            .vtable()
            .vulkan1_3()
            .and_then(|vtable| vtable.cmd_set_depth_write_enable())
            .or_else(|| {
                #[cfg(feature = "VK_EXT_extended_dynamic_state")]
                return self
                    .device()
                    .vtable()
                    .ext_extended_dynamic_state()
                    .and_then(|vtable| vtable.cmd_set_depth_write_enable_ext());
                #[cfg(not(feature = "VK_EXT_extended_dynamic_state"))]
                return None;
            })
            .expect("function not loaded");
        #[cfg(not(any(debug_assertions, feature = "assertions")))]
        let _function = self
            .device()
            .vtable()
            .vulkan1_3()
            .and_then(|vtable| vtable.cmd_set_depth_write_enable())
            .or_else(|| {
                #[cfg(feature = "VK_EXT_extended_dynamic_state")]
                return self
                    .device()
                    .vtable()
                    .ext_extended_dynamic_state()
                    .and_then(|vtable| vtable.cmd_set_depth_write_enable_ext());
                #[cfg(not(feature = "VK_EXT_extended_dynamic_state"))]
                return None;
            })
            .unwrap_unchecked();
        let _return = _function(self.as_raw(), depth_write_enable as u8 as u32);
        ()
    }
}
impl CommandBuffer {
    ///[vkCmdSetDepthCompareOp](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDepthCompareOp.html) - Set depth comparison operator dynamically for a command buffer
    ///# C Specifications
    ///To [dynamically set](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipelines-dynamic-state) the depth compare operator,
    ///call:
    ///```c
    ///// Provided by VK_VERSION_1_3
    ///void vkCmdSetDepthCompareOp(
    ///    VkCommandBuffer                             commandBuffer,
    ///    VkCompareOp                                 depthCompareOp);
    ///```
    ///or the equivalent command
    ///```c
    ///// Provided by VK_EXT_extended_dynamic_state
    ///void vkCmdSetDepthCompareOpEXT(
    ///    VkCommandBuffer                             commandBuffer,
    ///    VkCompareOp                                 depthCompareOp);
    ///```
    ///# Parameters
    /// - [`command_buffer`] is the command buffer into which the command will be recorded.
    /// - [`depth_compare_op`] specifies the depth comparison operator.
    ///# Description
    ///This command sets the depth comparison operator for subsequent drawing
    ///commands when the graphics pipeline is created with
    ///`VK_DYNAMIC_STATE_DEPTH_COMPARE_OP` set in
    ///[`PipelineDynamicStateCreateInfo::dynamic_states`].
    ///Otherwise, this state is specified by the
    ///[`PipelineDepthStencilStateCreateInfo`]::[`depth_compare_op`] value used
    ///to create the currently active pipeline.
    ///## Valid Usage (Implicit)
    /// - [`command_buffer`] **must**  be a valid [`CommandBuffer`] handle
    /// - [`depth_compare_op`] **must**  be a valid [`CompareOp`] value
    /// - [`command_buffer`] **must**  be in the [recording state]()
    /// - The [`CommandPool`] that [`command_buffer`] was allocated from  **must**  support graphics
    ///   operations
    ///
    ///## Host Synchronization
    /// - Host access to [`command_buffer`] **must**  be externally synchronized
    /// - Host access to the [`CommandPool`] that [`command_buffer`] was allocated from  **must**
    ///   be externally synchronized
    ///
    ///## Command Properties
    ///# Related
    /// - [`ext_extended_dynamic_state`]
    /// - [`crate::vulkan1_3`]
    /// - [`CommandBuffer`]
    /// - [`CompareOp`]
    ///
    ///# Notes and documentation
    ///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
    ///
    ///This documentation is generated from the Vulkan specification and documentation.
    ///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
    /// Commons Attribution 4.0 International*.
    ///This license explicitely allows adapting the source material as long as proper credit is
    /// given.
    #[doc(alias = "vkCmdSetDepthCompareOp")]
    #[doc(alias = "vkCmdSetDepthCompareOpEXT")]
    #[track_caller]
    #[inline]
    pub unsafe fn cmd_set_depth_compare_op(self: &Unique<CommandBuffer>, depth_compare_op: CompareOp) -> () {
        #[cfg(any(debug_assertions, feature = "assertions"))]
        let _function = self
            .device()
            .vtable()
            .vulkan1_3()
            .and_then(|vtable| vtable.cmd_set_depth_compare_op())
            .or_else(|| {
                #[cfg(feature = "VK_EXT_extended_dynamic_state")]
                return self
                    .device()
                    .vtable()
                    .ext_extended_dynamic_state()
                    .and_then(|vtable| vtable.cmd_set_depth_compare_op_ext());
                #[cfg(not(feature = "VK_EXT_extended_dynamic_state"))]
                return None;
            })
            .expect("function not loaded");
        #[cfg(not(any(debug_assertions, feature = "assertions")))]
        let _function = self
            .device()
            .vtable()
            .vulkan1_3()
            .and_then(|vtable| vtable.cmd_set_depth_compare_op())
            .or_else(|| {
                #[cfg(feature = "VK_EXT_extended_dynamic_state")]
                return self
                    .device()
                    .vtable()
                    .ext_extended_dynamic_state()
                    .and_then(|vtable| vtable.cmd_set_depth_compare_op_ext());
                #[cfg(not(feature = "VK_EXT_extended_dynamic_state"))]
                return None;
            })
            .unwrap_unchecked();
        let _return = _function(self.as_raw(), depth_compare_op);
        ()
    }
}
impl CommandBuffer {
    ///[vkCmdSetDepthBoundsTestEnable](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDepthBoundsTestEnable.html) - Set depth bounds test enable dynamically for a command buffer
    ///# C Specifications
    ///To [dynamically enable or disable](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipelines-dynamic-state) the depth
    ///bounds test, call:
    ///```c
    ///// Provided by VK_VERSION_1_3
    ///void vkCmdSetDepthBoundsTestEnable(
    ///    VkCommandBuffer                             commandBuffer,
    ///    VkBool32                                    depthBoundsTestEnable);
    ///```
    ///or the equivalent command
    ///```c
    ///// Provided by VK_EXT_extended_dynamic_state
    ///void vkCmdSetDepthBoundsTestEnableEXT(
    ///    VkCommandBuffer                             commandBuffer,
    ///    VkBool32                                    depthBoundsTestEnable);
    ///```
    ///# Parameters
    /// - [`command_buffer`] is the command buffer into which the command will be recorded.
    /// - [`depth_bounds_test_enable`] specifies if the depth bounds test is enabled.
    ///# Description
    ///This command sets the depth bounds enable for subsequent drawing commands
    ///when the graphics pipeline is created with
    ///`VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE` set in
    ///[`PipelineDynamicStateCreateInfo::dynamic_states`].
    ///Otherwise, this state is specified by the
    ///[`PipelineDepthStencilStateCreateInfo`]::[`depth_bounds_test_enable`]
    ///value used to create the currently active pipeline.
    ///## Valid Usage (Implicit)
    /// - [`command_buffer`] **must**  be a valid [`CommandBuffer`] handle
    /// - [`command_buffer`] **must**  be in the [recording state]()
    /// - The [`CommandPool`] that [`command_buffer`] was allocated from  **must**  support graphics
    ///   operations
    ///
    ///## Host Synchronization
    /// - Host access to [`command_buffer`] **must**  be externally synchronized
    /// - Host access to the [`CommandPool`] that [`command_buffer`] was allocated from  **must**
    ///   be externally synchronized
    ///
    ///## Command Properties
    ///# Related
    /// - [`ext_extended_dynamic_state`]
    /// - [`crate::vulkan1_3`]
    /// - [`Bool32`]
    /// - [`CommandBuffer`]
    ///
    ///# Notes and documentation
    ///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
    ///
    ///This documentation is generated from the Vulkan specification and documentation.
    ///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
    /// Commons Attribution 4.0 International*.
    ///This license explicitely allows adapting the source material as long as proper credit is
    /// given.
    #[doc(alias = "vkCmdSetDepthBoundsTestEnable")]
    #[doc(alias = "vkCmdSetDepthBoundsTestEnableEXT")]
    #[track_caller]
    #[inline]
    pub unsafe fn cmd_set_depth_bounds_test_enable(self: &Unique<CommandBuffer>, depth_bounds_test_enable: bool) -> () {
        #[cfg(any(debug_assertions, feature = "assertions"))]
        let _function = self
            .device()
            .vtable()
            .vulkan1_3()
            .and_then(|vtable| vtable.cmd_set_depth_bounds_test_enable())
            .or_else(|| {
                #[cfg(feature = "VK_EXT_extended_dynamic_state")]
                return self
                    .device()
                    .vtable()
                    .ext_extended_dynamic_state()
                    .and_then(|vtable| vtable.cmd_set_depth_bounds_test_enable_ext());
                #[cfg(not(feature = "VK_EXT_extended_dynamic_state"))]
                return None;
            })
            .expect("function not loaded");
        #[cfg(not(any(debug_assertions, feature = "assertions")))]
        let _function = self
            .device()
            .vtable()
            .vulkan1_3()
            .and_then(|vtable| vtable.cmd_set_depth_bounds_test_enable())
            .or_else(|| {
                #[cfg(feature = "VK_EXT_extended_dynamic_state")]
                return self
                    .device()
                    .vtable()
                    .ext_extended_dynamic_state()
                    .and_then(|vtable| vtable.cmd_set_depth_bounds_test_enable_ext());
                #[cfg(not(feature = "VK_EXT_extended_dynamic_state"))]
                return None;
            })
            .unwrap_unchecked();
        let _return = _function(self.as_raw(), depth_bounds_test_enable as u8 as u32);
        ()
    }
}
impl CommandBuffer {
    ///[vkCmdSetStencilTestEnable](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetStencilTestEnable.html) - Set stencil test enable dynamically for a command buffer
    ///# C Specifications
    ///To [dynamically enable or disable](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipelines-dynamic-state) the stencil
    ///test, call:
    ///```c
    ///// Provided by VK_VERSION_1_3
    ///void vkCmdSetStencilTestEnable(
    ///    VkCommandBuffer                             commandBuffer,
    ///    VkBool32                                    stencilTestEnable);
    ///```
    ///or the equivalent command
    ///```c
    ///// Provided by VK_EXT_extended_dynamic_state
    ///void vkCmdSetStencilTestEnableEXT(
    ///    VkCommandBuffer                             commandBuffer,
    ///    VkBool32                                    stencilTestEnable);
    ///```
    ///# Parameters
    /// - [`command_buffer`] is the command buffer into which the command will be recorded.
    /// - [`stencil_test_enable`] specifies if the stencil test is enabled.
    ///# Description
    ///This command sets the stencil test enable for subsequent drawing commands
    ///when the graphics pipeline is created with
    ///`VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE` set in
    ///[`PipelineDynamicStateCreateInfo::dynamic_states`].
    ///Otherwise, this state is specified by the
    ///[`PipelineDepthStencilStateCreateInfo`]::[`stencil_test_enable`] value
    ///used to create the currently active pipeline.
    ///## Valid Usage (Implicit)
    /// - [`command_buffer`] **must**  be a valid [`CommandBuffer`] handle
    /// - [`command_buffer`] **must**  be in the [recording state]()
    /// - The [`CommandPool`] that [`command_buffer`] was allocated from  **must**  support graphics
    ///   operations
    ///
    ///## Host Synchronization
    /// - Host access to [`command_buffer`] **must**  be externally synchronized
    /// - Host access to the [`CommandPool`] that [`command_buffer`] was allocated from  **must**
    ///   be externally synchronized
    ///
    ///## Command Properties
    ///# Related
    /// - [`ext_extended_dynamic_state`]
    /// - [`crate::vulkan1_3`]
    /// - [`Bool32`]
    /// - [`CommandBuffer`]
    ///
    ///# Notes and documentation
    ///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
    ///
    ///This documentation is generated from the Vulkan specification and documentation.
    ///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
    /// Commons Attribution 4.0 International*.
    ///This license explicitely allows adapting the source material as long as proper credit is
    /// given.
    #[doc(alias = "vkCmdSetStencilTestEnable")]
    #[doc(alias = "vkCmdSetStencilTestEnableEXT")]
    #[track_caller]
    #[inline]
    pub unsafe fn cmd_set_stencil_test_enable(self: &Unique<CommandBuffer>, stencil_test_enable: bool) -> () {
        #[cfg(any(debug_assertions, feature = "assertions"))]
        let _function = self
            .device()
            .vtable()
            .vulkan1_3()
            .and_then(|vtable| vtable.cmd_set_stencil_test_enable())
            .or_else(|| {
                #[cfg(feature = "VK_EXT_extended_dynamic_state")]
                return self
                    .device()
                    .vtable()
                    .ext_extended_dynamic_state()
                    .and_then(|vtable| vtable.cmd_set_stencil_test_enable_ext());
                #[cfg(not(feature = "VK_EXT_extended_dynamic_state"))]
                return None;
            })
            .expect("function not loaded");
        #[cfg(not(any(debug_assertions, feature = "assertions")))]
        let _function = self
            .device()
            .vtable()
            .vulkan1_3()
            .and_then(|vtable| vtable.cmd_set_stencil_test_enable())
            .or_else(|| {
                #[cfg(feature = "VK_EXT_extended_dynamic_state")]
                return self
                    .device()
                    .vtable()
                    .ext_extended_dynamic_state()
                    .and_then(|vtable| vtable.cmd_set_stencil_test_enable_ext());
                #[cfg(not(feature = "VK_EXT_extended_dynamic_state"))]
                return None;
            })
            .unwrap_unchecked();
        let _return = _function(self.as_raw(), stencil_test_enable as u8 as u32);
        ()
    }
}
impl CommandBuffer {
    ///[vkCmdSetStencilOp](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetStencilOp.html) - Set stencil operation dynamically for a command buffer
    ///# C Specifications
    ///To [dynamically set](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipelines-dynamic-state) the stencil operation, call:
    ///```c
    ///// Provided by VK_VERSION_1_3
    ///void vkCmdSetStencilOp(
    ///    VkCommandBuffer                             commandBuffer,
    ///    VkStencilFaceFlags                          faceMask,
    ///    VkStencilOp                                 failOp,
    ///    VkStencilOp                                 passOp,
    ///    VkStencilOp                                 depthFailOp,
    ///    VkCompareOp                                 compareOp);
    ///```
    ///or the equivalent command
    ///```c
    ///// Provided by VK_EXT_extended_dynamic_state
    ///void vkCmdSetStencilOpEXT(
    ///    VkCommandBuffer                             commandBuffer,
    ///    VkStencilFaceFlags                          faceMask,
    ///    VkStencilOp                                 failOp,
    ///    VkStencilOp                                 passOp,
    ///    VkStencilOp                                 depthFailOp,
    ///    VkCompareOp                                 compareOp);
    ///```
    ///# Parameters
    /// - [`command_buffer`] is the command buffer into which the command will be recorded.
    /// - [`face_mask`] is a bitmask of [`StencilFaceFlagBits`] specifying the set of stencil state
    ///   for which to update the stencil operation.
    /// - [`fail_op`] is a [`StencilOp`] value specifying the action performed on samples that fail
    ///   the stencil test.
    /// - [`pass_op`] is a [`StencilOp`] value specifying the action performed on samples that pass
    ///   both the depth and stencil tests.
    /// - [`depth_fail_op`] is a [`StencilOp`] value specifying the action performed on samples that
    ///   pass the stencil test and fail the depth test.
    /// - [`compare_op`] is a [`CompareOp`] value specifying the comparison operator used in the
    ///   stencil test.
    ///# Description
    ///This command sets the stencil operation for subsequent drawing commands when
    ///the graphics pipeline is created with `VK_DYNAMIC_STATE_STENCIL_OP` set
    ///in [`PipelineDynamicStateCreateInfo::dynamic_states`].
    ///Otherwise, this state is specified by the corresponding
    ///[`PipelineDepthStencilStateCreateInfo`]::[`fail_op`], [`pass_op`],
    ///[`depth_fail_op`], and [`compare_op`] values used to create the currently
    ///active pipeline, for both front and back faces.
    ///## Valid Usage (Implicit)
    /// - [`command_buffer`] **must**  be a valid [`CommandBuffer`] handle
    /// - [`face_mask`] **must**  be a valid combination of [`StencilFaceFlagBits`] values
    /// - [`face_mask`] **must**  not be `0`
    /// - [`fail_op`] **must**  be a valid [`StencilOp`] value
    /// - [`pass_op`] **must**  be a valid [`StencilOp`] value
    /// - [`depth_fail_op`] **must**  be a valid [`StencilOp`] value
    /// - [`compare_op`] **must**  be a valid [`CompareOp`] value
    /// - [`command_buffer`] **must**  be in the [recording state]()
    /// - The [`CommandPool`] that [`command_buffer`] was allocated from  **must**  support graphics
    ///   operations
    ///
    ///## Host Synchronization
    /// - Host access to [`command_buffer`] **must**  be externally synchronized
    /// - Host access to the [`CommandPool`] that [`command_buffer`] was allocated from  **must**
    ///   be externally synchronized
    ///
    ///## Command Properties
    ///# Related
    /// - [`ext_extended_dynamic_state`]
    /// - [`crate::vulkan1_3`]
    /// - [`CommandBuffer`]
    /// - [`CompareOp`]
    /// - [`StencilFaceFlags`]
    /// - [`StencilOp`]
    ///
    ///# Notes and documentation
    ///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
    ///
    ///This documentation is generated from the Vulkan specification and documentation.
    ///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
    /// Commons Attribution 4.0 International*.
    ///This license explicitely allows adapting the source material as long as proper credit is
    /// given.
    #[doc(alias = "vkCmdSetStencilOp")]
    #[doc(alias = "vkCmdSetStencilOpEXT")]
    #[track_caller]
    #[inline]
    pub unsafe fn cmd_set_stencil_op(
        self: &Unique<CommandBuffer>,
        face_mask: StencilFaceFlags,
        fail_op: StencilOp,
        pass_op: StencilOp,
        depth_fail_op: StencilOp,
        compare_op: CompareOp,
    ) -> () {
        #[cfg(any(debug_assertions, feature = "assertions"))]
        let _function = self
            .device()
            .vtable()
            .vulkan1_3()
            .and_then(|vtable| vtable.cmd_set_stencil_op())
            .or_else(|| {
                #[cfg(feature = "VK_EXT_extended_dynamic_state")]
                return self
                    .device()
                    .vtable()
                    .ext_extended_dynamic_state()
                    .and_then(|vtable| vtable.cmd_set_stencil_op_ext());
                #[cfg(not(feature = "VK_EXT_extended_dynamic_state"))]
                return None;
            })
            .expect("function not loaded");
        #[cfg(not(any(debug_assertions, feature = "assertions")))]
        let _function = self
            .device()
            .vtable()
            .vulkan1_3()
            .and_then(|vtable| vtable.cmd_set_stencil_op())
            .or_else(|| {
                #[cfg(feature = "VK_EXT_extended_dynamic_state")]
                return self
                    .device()
                    .vtable()
                    .ext_extended_dynamic_state()
                    .and_then(|vtable| vtable.cmd_set_stencil_op_ext());
                #[cfg(not(feature = "VK_EXT_extended_dynamic_state"))]
                return None;
            })
            .unwrap_unchecked();
        let _return = _function(self.as_raw(), face_mask, fail_op, pass_op, depth_fail_op, compare_op);
        ()
    }
}
impl CommandBuffer {
    ///[vkCmdSetRasterizerDiscardEnable](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetRasterizerDiscardEnable.html) - Control whether primitives are discarded before the rasterization stage dynamically for a command buffer
    ///# C Specifications
    ///To [dynamically enable](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipelines-dynamic-state) whether primitives are
    ///discarded before the rasterization stage, call:
    ///```c
    ///// Provided by VK_VERSION_1_3
    ///void vkCmdSetRasterizerDiscardEnable(
    ///    VkCommandBuffer                             commandBuffer,
    ///    VkBool32                                    rasterizerDiscardEnable);
    ///```
    ///or the equivalent command
    ///```c
    ///// Provided by VK_EXT_extended_dynamic_state2
    ///void vkCmdSetRasterizerDiscardEnableEXT(
    ///    VkCommandBuffer                             commandBuffer,
    ///    VkBool32                                    rasterizerDiscardEnable);
    ///```
    ///# Parameters
    /// - [`command_buffer`] is the command buffer into which the command will be recorded.
    /// - [`rasterizer_discard_enable`] controls whether primitives are discarded immediately before
    ///   the rasterization stage.
    ///# Description
    ///This command sets the discard enable for subsequent drawing commands when
    ///the graphics pipeline is created with
    ///`VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE` set in
    ///[`PipelineDynamicStateCreateInfo::dynamic_states`].
    ///Otherwise, this state is specified by the
    ///[`PipelineRasterizationStateCreateInfo`]::[`rasterizer_discard_enable`]
    ///value used to create the currently active pipeline.
    ///## Valid Usage (Implicit)
    /// - [`command_buffer`] **must**  be a valid [`CommandBuffer`] handle
    /// - [`command_buffer`] **must**  be in the [recording state]()
    /// - The [`CommandPool`] that [`command_buffer`] was allocated from  **must**  support graphics
    ///   operations
    ///
    ///## Host Synchronization
    /// - Host access to [`command_buffer`] **must**  be externally synchronized
    /// - Host access to the [`CommandPool`] that [`command_buffer`] was allocated from  **must**
    ///   be externally synchronized
    ///
    ///## Command Properties
    ///# Related
    /// - [`ext_extended_dynamic_state2`]
    /// - [`crate::vulkan1_3`]
    /// - [`Bool32`]
    /// - [`CommandBuffer`]
    ///
    ///# Notes and documentation
    ///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
    ///
    ///This documentation is generated from the Vulkan specification and documentation.
    ///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
    /// Commons Attribution 4.0 International*.
    ///This license explicitely allows adapting the source material as long as proper credit is
    /// given.
    #[doc(alias = "vkCmdSetRasterizerDiscardEnable")]
    #[doc(alias = "vkCmdSetRasterizerDiscardEnableEXT")]
    #[track_caller]
    #[inline]
    pub unsafe fn cmd_set_rasterizer_discard_enable(
        self: &Unique<CommandBuffer>,
        rasterizer_discard_enable: bool,
    ) -> () {
        #[cfg(any(debug_assertions, feature = "assertions"))]
        let _function = self
            .device()
            .vtable()
            .vulkan1_3()
            .and_then(|vtable| vtable.cmd_set_rasterizer_discard_enable())
            .or_else(|| {
                #[cfg(feature = "VK_EXT_extended_dynamic_state2")]
                return self
                    .device()
                    .vtable()
                    .ext_extended_dynamic_state2()
                    .and_then(|vtable| vtable.cmd_set_rasterizer_discard_enable_ext());
                #[cfg(not(feature = "VK_EXT_extended_dynamic_state2"))]
                return None;
            })
            .expect("function not loaded");
        #[cfg(not(any(debug_assertions, feature = "assertions")))]
        let _function = self
            .device()
            .vtable()
            .vulkan1_3()
            .and_then(|vtable| vtable.cmd_set_rasterizer_discard_enable())
            .or_else(|| {
                #[cfg(feature = "VK_EXT_extended_dynamic_state2")]
                return self
                    .device()
                    .vtable()
                    .ext_extended_dynamic_state2()
                    .and_then(|vtable| vtable.cmd_set_rasterizer_discard_enable_ext());
                #[cfg(not(feature = "VK_EXT_extended_dynamic_state2"))]
                return None;
            })
            .unwrap_unchecked();
        let _return = _function(self.as_raw(), rasterizer_discard_enable as u8 as u32);
        ()
    }
}
impl CommandBuffer {
    ///[vkCmdSetDepthBiasEnable](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDepthBiasEnable.html) - Control whether to bias fragment depth values dynamically for a command buffer
    ///# C Specifications
    ///To [dynamically enable](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipelines-dynamic-state) whether to bias fragment
    ///depth values, call:
    ///```c
    ///// Provided by VK_VERSION_1_3
    ///void vkCmdSetDepthBiasEnable(
    ///    VkCommandBuffer                             commandBuffer,
    ///    VkBool32                                    depthBiasEnable);
    ///```
    ///or the equivalent command
    ///```c
    ///// Provided by VK_EXT_extended_dynamic_state2
    ///void vkCmdSetDepthBiasEnableEXT(
    ///    VkCommandBuffer                             commandBuffer,
    ///    VkBool32                                    depthBiasEnable);
    ///```
    ///# Parameters
    /// - [`command_buffer`] is the command buffer into which the command will be recorded.
    /// - [`depth_bias_enable`] controls whether to bias fragment depth values.
    ///# Description
    ///This command sets the depth bias enable for subsequent drawing commands when
    ///the graphics pipeline is created with
    ///`VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE` set in
    ///[`PipelineDynamicStateCreateInfo::dynamic_states`].
    ///Otherwise, this state is specified by the
    ///[`PipelineRasterizationStateCreateInfo`]::[`depth_bias_enable`] value
    ///used to create the currently active pipeline.
    ///## Valid Usage (Implicit)
    /// - [`command_buffer`] **must**  be a valid [`CommandBuffer`] handle
    /// - [`command_buffer`] **must**  be in the [recording state]()
    /// - The [`CommandPool`] that [`command_buffer`] was allocated from  **must**  support graphics
    ///   operations
    ///
    ///## Host Synchronization
    /// - Host access to [`command_buffer`] **must**  be externally synchronized
    /// - Host access to the [`CommandPool`] that [`command_buffer`] was allocated from  **must**
    ///   be externally synchronized
    ///
    ///## Command Properties
    ///# Related
    /// - [`ext_extended_dynamic_state2`]
    /// - [`crate::vulkan1_3`]
    /// - [`Bool32`]
    /// - [`CommandBuffer`]
    ///
    ///# Notes and documentation
    ///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
    ///
    ///This documentation is generated from the Vulkan specification and documentation.
    ///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
    /// Commons Attribution 4.0 International*.
    ///This license explicitely allows adapting the source material as long as proper credit is
    /// given.
    #[doc(alias = "vkCmdSetDepthBiasEnable")]
    #[doc(alias = "vkCmdSetDepthBiasEnableEXT")]
    #[track_caller]
    #[inline]
    pub unsafe fn cmd_set_depth_bias_enable(self: &Unique<CommandBuffer>, depth_bias_enable: bool) -> () {
        #[cfg(any(debug_assertions, feature = "assertions"))]
        let _function = self
            .device()
            .vtable()
            .vulkan1_3()
            .and_then(|vtable| vtable.cmd_set_depth_bias_enable())
            .or_else(|| {
                #[cfg(feature = "VK_EXT_extended_dynamic_state2")]
                return self
                    .device()
                    .vtable()
                    .ext_extended_dynamic_state2()
                    .and_then(|vtable| vtable.cmd_set_depth_bias_enable_ext());
                #[cfg(not(feature = "VK_EXT_extended_dynamic_state2"))]
                return None;
            })
            .expect("function not loaded");
        #[cfg(not(any(debug_assertions, feature = "assertions")))]
        let _function = self
            .device()
            .vtable()
            .vulkan1_3()
            .and_then(|vtable| vtable.cmd_set_depth_bias_enable())
            .or_else(|| {
                #[cfg(feature = "VK_EXT_extended_dynamic_state2")]
                return self
                    .device()
                    .vtable()
                    .ext_extended_dynamic_state2()
                    .and_then(|vtable| vtable.cmd_set_depth_bias_enable_ext());
                #[cfg(not(feature = "VK_EXT_extended_dynamic_state2"))]
                return None;
            })
            .unwrap_unchecked();
        let _return = _function(self.as_raw(), depth_bias_enable as u8 as u32);
        ()
    }
}
impl CommandBuffer {
    ///[vkCmdSetPrimitiveRestartEnable](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetPrimitiveRestartEnable.html) - Set primitive assembly restart state dynamically for a command buffer
    ///# C Specifications
    ///To [dynamically control](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipelines-dynamic-state) whether a special vertex
    ///index value is treated as restarting the assembly of primitives, call:
    ///```c
    ///// Provided by VK_VERSION_1_3
    ///void vkCmdSetPrimitiveRestartEnable(
    ///    VkCommandBuffer                             commandBuffer,
    ///    VkBool32                                    primitiveRestartEnable);
    ///```
    ///or the equivalent command
    ///```c
    ///// Provided by VK_EXT_extended_dynamic_state2
    ///void vkCmdSetPrimitiveRestartEnableEXT(
    ///    VkCommandBuffer                             commandBuffer,
    ///    VkBool32                                    primitiveRestartEnable);
    ///```
    ///# Parameters
    /// - [`command_buffer`] is the command buffer into which the command will be recorded.
    /// - [`primitive_restart_enable`] controls whether a special vertex index value is treated as
    ///   restarting the assembly of primitives. It behaves in the same way as
    ///   [`PipelineInputAssemblyStateCreateInfo`]::[`primitive_restart_enable`]
    ///# Description
    ///This command sets the primitive restart enable for subsequent drawing
    ///commands when the graphics pipeline is created with
    ///`VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE` set in
    ///[`PipelineDynamicStateCreateInfo::dynamic_states`].
    ///Otherwise, this state is specified by the
    ///[`PipelineInputAssemblyStateCreateInfo`]::[`primitive_restart_enable`]
    ///value used to create the currently active pipeline.
    ///## Valid Usage (Implicit)
    /// - [`command_buffer`] **must**  be a valid [`CommandBuffer`] handle
    /// - [`command_buffer`] **must**  be in the [recording state]()
    /// - The [`CommandPool`] that [`command_buffer`] was allocated from  **must**  support graphics
    ///   operations
    ///
    ///## Host Synchronization
    /// - Host access to [`command_buffer`] **must**  be externally synchronized
    /// - Host access to the [`CommandPool`] that [`command_buffer`] was allocated from  **must**
    ///   be externally synchronized
    ///
    ///## Command Properties
    ///# Related
    /// - [`ext_extended_dynamic_state2`]
    /// - [`crate::vulkan1_3`]
    /// - [`Bool32`]
    /// - [`CommandBuffer`]
    ///
    ///# Notes and documentation
    ///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
    ///
    ///This documentation is generated from the Vulkan specification and documentation.
    ///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
    /// Commons Attribution 4.0 International*.
    ///This license explicitely allows adapting the source material as long as proper credit is
    /// given.
    #[doc(alias = "vkCmdSetPrimitiveRestartEnable")]
    #[doc(alias = "vkCmdSetPrimitiveRestartEnableEXT")]
    #[track_caller]
    #[inline]
    pub unsafe fn cmd_set_primitive_restart_enable(self: &Unique<CommandBuffer>, primitive_restart_enable: bool) -> () {
        #[cfg(any(debug_assertions, feature = "assertions"))]
        let _function = self
            .device()
            .vtable()
            .vulkan1_3()
            .and_then(|vtable| vtable.cmd_set_primitive_restart_enable())
            .or_else(|| {
                #[cfg(feature = "VK_EXT_extended_dynamic_state2")]
                return self
                    .device()
                    .vtable()
                    .ext_extended_dynamic_state2()
                    .and_then(|vtable| vtable.cmd_set_primitive_restart_enable_ext());
                #[cfg(not(feature = "VK_EXT_extended_dynamic_state2"))]
                return None;
            })
            .expect("function not loaded");
        #[cfg(not(any(debug_assertions, feature = "assertions")))]
        let _function = self
            .device()
            .vtable()
            .vulkan1_3()
            .and_then(|vtable| vtable.cmd_set_primitive_restart_enable())
            .or_else(|| {
                #[cfg(feature = "VK_EXT_extended_dynamic_state2")]
                return self
                    .device()
                    .vtable()
                    .ext_extended_dynamic_state2()
                    .and_then(|vtable| vtable.cmd_set_primitive_restart_enable_ext());
                #[cfg(not(feature = "VK_EXT_extended_dynamic_state2"))]
                return None;
            })
            .unwrap_unchecked();
        let _return = _function(self.as_raw(), primitive_restart_enable as u8 as u32);
        ()
    }
}
impl CommandBuffer {
    ///[vkCmdCopyBuffer2](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCopyBuffer2.html) - Copy data between buffer regions
    ///# C Specifications
    ///To copy data between buffer objects, call:
    ///```c
    ///// Provided by VK_VERSION_1_3
    ///void vkCmdCopyBuffer2(
    ///    VkCommandBuffer                             commandBuffer,
    ///    const VkCopyBufferInfo2*                    pCopyBufferInfo);
    ///```
    ///or the equivalent command
    ///```c
    ///// Provided by VK_KHR_copy_commands2
    ///void vkCmdCopyBuffer2KHR(
    ///    VkCommandBuffer                             commandBuffer,
    ///    const VkCopyBufferInfo2*                    pCopyBufferInfo);
    ///```
    ///# Parameters
    /// - [`command_buffer`] is the command buffer into which the command will be recorded.
    /// - [`p_copy_buffer_info`] is a pointer to a [`CopyBufferInfo2`] structure describing the copy
    ///   parameters.
    ///# Description
    ///This command is functionally identical to [`cmd_copy_buffer`], but
    ///includes extensible sub-structures that include `sType` and `pNext`
    ///parameters, allowing them to be more easily extended.
    ///## Valid Usage
    /// - If [`command_buffer`] is an unprotected command buffer and [`protectedNoFault`]() is not
    ///   supported, `srcBuffer` **must**  not be a protected buffer
    /// - If [`command_buffer`] is an unprotected command buffer and [`protectedNoFault`]() is not
    ///   supported, `dstBuffer` **must**  not be a protected buffer
    /// - If [`command_buffer`] is a protected command buffer and [`protectedNoFault`]() is not
    ///   supported, `dstBuffer` **must**  not be an unprotected buffer
    ///
    ///## Valid Usage (Implicit)
    /// - [`command_buffer`] **must**  be a valid [`CommandBuffer`] handle
    /// - [`p_copy_buffer_info`] **must**  be a valid pointer to a valid [`CopyBufferInfo2`]
    ///   structure
    /// - [`command_buffer`] **must**  be in the [recording state]()
    /// - The [`CommandPool`] that [`command_buffer`] was allocated from  **must**  support
    ///   transfer, graphics, or compute operations
    /// - This command  **must**  only be called outside of a render pass instance
    ///
    ///## Host Synchronization
    /// - Host access to [`command_buffer`] **must**  be externally synchronized
    /// - Host access to the [`CommandPool`] that [`command_buffer`] was allocated from  **must**
    ///   be externally synchronized
    ///
    ///## Command Properties
    ///# Related
    /// - [`khr_copy_commands2`]
    /// - [`crate::vulkan1_3`]
    /// - [`CommandBuffer`]
    /// - [`CopyBufferInfo2`]
    ///
    ///# Notes and documentation
    ///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
    ///
    ///This documentation is generated from the Vulkan specification and documentation.
    ///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
    /// Commons Attribution 4.0 International*.
    ///This license explicitely allows adapting the source material as long as proper credit is
    /// given.
    #[doc(alias = "vkCmdCopyBuffer2")]
    #[doc(alias = "vkCmdCopyBuffer2KHR")]
    #[track_caller]
    #[inline]
    pub unsafe fn cmd_copy_buffer2<'lt>(self: &Unique<CommandBuffer>, p_copy_buffer_info: &CopyBufferInfo2<'lt>) -> () {
        #[cfg(any(debug_assertions, feature = "assertions"))]
        let _function = self
            .device()
            .vtable()
            .vulkan1_3()
            .and_then(|vtable| vtable.cmd_copy_buffer2())
            .or_else(|| {
                #[cfg(feature = "VK_KHR_copy_commands2")]
                return self
                    .device()
                    .vtable()
                    .khr_copy_commands2()
                    .and_then(|vtable| vtable.cmd_copy_buffer2_khr());
                #[cfg(not(feature = "VK_KHR_copy_commands2"))]
                return None;
            })
            .expect("function not loaded");
        #[cfg(not(any(debug_assertions, feature = "assertions")))]
        let _function = self
            .device()
            .vtable()
            .vulkan1_3()
            .and_then(|vtable| vtable.cmd_copy_buffer2())
            .or_else(|| {
                #[cfg(feature = "VK_KHR_copy_commands2")]
                return self
                    .device()
                    .vtable()
                    .khr_copy_commands2()
                    .and_then(|vtable| vtable.cmd_copy_buffer2_khr());
                #[cfg(not(feature = "VK_KHR_copy_commands2"))]
                return None;
            })
            .unwrap_unchecked();
        let _return = _function(self.as_raw(), p_copy_buffer_info as *const CopyBufferInfo2<'lt>);
        ()
    }
}
impl CommandBuffer {
    ///[vkCmdCopyImage2](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCopyImage2.html) - Copy data between images
    ///# C Specifications
    ///To copy data between image objects, call:
    ///```c
    ///// Provided by VK_VERSION_1_3
    ///void vkCmdCopyImage2(
    ///    VkCommandBuffer                             commandBuffer,
    ///    const VkCopyImageInfo2*                     pCopyImageInfo);
    ///```
    ///or the equivalent command
    ///```c
    ///// Provided by VK_KHR_copy_commands2
    ///void vkCmdCopyImage2KHR(
    ///    VkCommandBuffer                             commandBuffer,
    ///    const VkCopyImageInfo2*                     pCopyImageInfo);
    ///```
    ///# Parameters
    /// - [`command_buffer`] is the command buffer into which the command will be recorded.
    /// - [`p_copy_image_info`] is a pointer to a [`CopyImageInfo2`] structure describing the copy
    ///   parameters.
    ///# Description
    ///This command is functionally identical to [`cmd_copy_image`], but includes
    ///extensible sub-structures that include `sType` and `pNext`
    ///parameters, allowing them to be more easily extended.
    ///## Valid Usage
    /// - If [`command_buffer`] is an unprotected command buffer and [`protectedNoFault`]() is not
    ///   supported, `srcImage` **must**  not be a protected image
    /// - If [`command_buffer`] is an unprotected command buffer and [`protectedNoFault`]() is not
    ///   supported, `dstImage` **must**  not be a protected image
    /// - If [`command_buffer`] is a protected command buffer and [`protectedNoFault`]() is not
    ///   supported, `dstImage` **must**  not be an unprotected image
    ///
    ///## Valid Usage (Implicit)
    /// - [`command_buffer`] **must**  be a valid [`CommandBuffer`] handle
    /// - [`p_copy_image_info`] **must**  be a valid pointer to a valid [`CopyImageInfo2`] structure
    /// - [`command_buffer`] **must**  be in the [recording state]()
    /// - The [`CommandPool`] that [`command_buffer`] was allocated from  **must**  support
    ///   transfer, graphics, or compute operations
    /// - This command  **must**  only be called outside of a render pass instance
    ///
    ///## Host Synchronization
    /// - Host access to [`command_buffer`] **must**  be externally synchronized
    /// - Host access to the [`CommandPool`] that [`command_buffer`] was allocated from  **must**
    ///   be externally synchronized
    ///
    ///## Command Properties
    ///# Related
    /// - [`khr_copy_commands2`]
    /// - [`crate::vulkan1_3`]
    /// - [`CommandBuffer`]
    /// - [`CopyImageInfo2`]
    ///
    ///# Notes and documentation
    ///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
    ///
    ///This documentation is generated from the Vulkan specification and documentation.
    ///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
    /// Commons Attribution 4.0 International*.
    ///This license explicitely allows adapting the source material as long as proper credit is
    /// given.
    #[doc(alias = "vkCmdCopyImage2")]
    #[doc(alias = "vkCmdCopyImage2KHR")]
    #[track_caller]
    #[inline]
    pub unsafe fn cmd_copy_image2<'lt>(self: &Unique<CommandBuffer>, p_copy_image_info: &CopyImageInfo2<'lt>) -> () {
        #[cfg(any(debug_assertions, feature = "assertions"))]
        let _function = self
            .device()
            .vtable()
            .vulkan1_3()
            .and_then(|vtable| vtable.cmd_copy_image2())
            .or_else(|| {
                #[cfg(feature = "VK_KHR_copy_commands2")]
                return self
                    .device()
                    .vtable()
                    .khr_copy_commands2()
                    .and_then(|vtable| vtable.cmd_copy_image2_khr());
                #[cfg(not(feature = "VK_KHR_copy_commands2"))]
                return None;
            })
            .expect("function not loaded");
        #[cfg(not(any(debug_assertions, feature = "assertions")))]
        let _function = self
            .device()
            .vtable()
            .vulkan1_3()
            .and_then(|vtable| vtable.cmd_copy_image2())
            .or_else(|| {
                #[cfg(feature = "VK_KHR_copy_commands2")]
                return self
                    .device()
                    .vtable()
                    .khr_copy_commands2()
                    .and_then(|vtable| vtable.cmd_copy_image2_khr());
                #[cfg(not(feature = "VK_KHR_copy_commands2"))]
                return None;
            })
            .unwrap_unchecked();
        let _return = _function(self.as_raw(), p_copy_image_info as *const CopyImageInfo2<'lt>);
        ()
    }
}
impl CommandBuffer {
    ///[vkCmdBlitImage2](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBlitImage2.html) - Copy regions of an image, potentially performing format conversion,
    ///# C Specifications
    ///To copy regions of a source image into a destination image, potentially
    ///performing format conversion, arbitrary scaling, and filtering, call:
    ///```c
    ///// Provided by VK_VERSION_1_3
    ///void vkCmdBlitImage2(
    ///    VkCommandBuffer                             commandBuffer,
    ///    const VkBlitImageInfo2*                     pBlitImageInfo);
    ///```
    ///or the equivalent command
    ///```c
    ///// Provided by VK_KHR_copy_commands2
    ///void vkCmdBlitImage2KHR(
    ///    VkCommandBuffer                             commandBuffer,
    ///    const VkBlitImageInfo2*                     pBlitImageInfo);
    ///```
    ///# Parameters
    /// - [`command_buffer`] is the command buffer into which the command will be recorded.
    /// - [`p_blit_image_info`] is a pointer to a [`BlitImageInfo2`] structure describing the blit
    ///   parameters.
    ///# Description
    ///This command is functionally identical to [`cmd_blit_image`], but includes
    ///extensible sub-structures that include `sType` and `pNext`
    ///parameters, allowing them to be more easily extended.
    ///## Valid Usage
    /// - If [`command_buffer`] is an unprotected command buffer and [`protectedNoFault`]() is not
    ///   supported, `srcImage` **must**  not be a protected image
    /// - If [`command_buffer`] is an unprotected command buffer and [`protectedNoFault`]() is not
    ///   supported, `dstImage` **must**  not be a protected image
    /// - If [`command_buffer`] is a protected command buffer and [`protectedNoFault`]() is not
    ///   supported, `dstImage` **must**  not be an unprotected image
    ///
    ///## Valid Usage (Implicit)
    /// - [`command_buffer`] **must**  be a valid [`CommandBuffer`] handle
    /// - [`p_blit_image_info`] **must**  be a valid pointer to a valid [`BlitImageInfo2`] structure
    /// - [`command_buffer`] **must**  be in the [recording state]()
    /// - The [`CommandPool`] that [`command_buffer`] was allocated from  **must**  support graphics
    ///   operations
    /// - This command  **must**  only be called outside of a render pass instance
    ///
    ///## Host Synchronization
    /// - Host access to [`command_buffer`] **must**  be externally synchronized
    /// - Host access to the [`CommandPool`] that [`command_buffer`] was allocated from  **must**
    ///   be externally synchronized
    ///
    ///## Command Properties
    ///# Related
    /// - [`khr_copy_commands2`]
    /// - [`crate::vulkan1_3`]
    /// - [`BlitImageInfo2`]
    /// - [`CommandBuffer`]
    ///
    ///# Notes and documentation
    ///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
    ///
    ///This documentation is generated from the Vulkan specification and documentation.
    ///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
    /// Commons Attribution 4.0 International*.
    ///This license explicitely allows adapting the source material as long as proper credit is
    /// given.
    #[doc(alias = "vkCmdBlitImage2")]
    #[doc(alias = "vkCmdBlitImage2KHR")]
    #[track_caller]
    #[inline]
    pub unsafe fn cmd_blit_image2<'lt>(self: &Unique<CommandBuffer>, p_blit_image_info: &BlitImageInfo2<'lt>) -> () {
        #[cfg(any(debug_assertions, feature = "assertions"))]
        let _function = self
            .device()
            .vtable()
            .vulkan1_3()
            .and_then(|vtable| vtable.cmd_blit_image2())
            .or_else(|| {
                #[cfg(feature = "VK_KHR_copy_commands2")]
                return self
                    .device()
                    .vtable()
                    .khr_copy_commands2()
                    .and_then(|vtable| vtable.cmd_blit_image2_khr());
                #[cfg(not(feature = "VK_KHR_copy_commands2"))]
                return None;
            })
            .expect("function not loaded");
        #[cfg(not(any(debug_assertions, feature = "assertions")))]
        let _function = self
            .device()
            .vtable()
            .vulkan1_3()
            .and_then(|vtable| vtable.cmd_blit_image2())
            .or_else(|| {
                #[cfg(feature = "VK_KHR_copy_commands2")]
                return self
                    .device()
                    .vtable()
                    .khr_copy_commands2()
                    .and_then(|vtable| vtable.cmd_blit_image2_khr());
                #[cfg(not(feature = "VK_KHR_copy_commands2"))]
                return None;
            })
            .unwrap_unchecked();
        let _return = _function(self.as_raw(), p_blit_image_info as *const BlitImageInfo2<'lt>);
        ()
    }
}
impl CommandBuffer {
    ///[vkCmdCopyBufferToImage2](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCopyBufferToImage2.html) - Copy data from a buffer into an image
    ///# C Specifications
    ///To copy data from a buffer object to an image object, call:
    ///```c
    ///// Provided by VK_VERSION_1_3
    ///void vkCmdCopyBufferToImage2(
    ///    VkCommandBuffer                             commandBuffer,
    ///    const VkCopyBufferToImageInfo2*             pCopyBufferToImageInfo);
    ///```
    ///or the equivalent command
    ///```c
    ///// Provided by VK_KHR_copy_commands2
    ///void vkCmdCopyBufferToImage2KHR(
    ///    VkCommandBuffer                             commandBuffer,
    ///    const VkCopyBufferToImageInfo2*             pCopyBufferToImageInfo);
    ///```
    ///# Parameters
    /// - [`command_buffer`] is the command buffer into which the command will be recorded.
    /// - [`p_copy_buffer_to_image_info`] is a pointer to a [`CopyBufferToImageInfo2`] structure
    ///   describing the copy parameters.
    ///# Description
    ///This command is functionally identical to [`cmd_copy_buffer_to_image`], but
    ///includes extensible sub-structures that include `sType` and `pNext`
    ///parameters, allowing them to be more easily extended.
    ///## Valid Usage
    /// - If [`command_buffer`] is an unprotected command buffer and [`protectedNoFault`]() is not
    ///   supported, `srcBuffer` **must**  not be a protected buffer
    /// - If [`command_buffer`] is an unprotected command buffer and [`protectedNoFault`]() is not
    ///   supported, `dstImage` **must**  not be a protected image
    /// - If [`command_buffer`] is a protected command buffer and [`protectedNoFault`]() is not
    ///   supported, `dstImage` **must**  not be an unprotected image
    ///
    ///## Valid Usage (Implicit)
    /// - [`command_buffer`] **must**  be a valid [`CommandBuffer`] handle
    /// - [`p_copy_buffer_to_image_info`] **must**  be a valid pointer to a valid
    ///   [`CopyBufferToImageInfo2`] structure
    /// - [`command_buffer`] **must**  be in the [recording state]()
    /// - The [`CommandPool`] that [`command_buffer`] was allocated from  **must**  support
    ///   transfer, graphics, or compute operations
    /// - This command  **must**  only be called outside of a render pass instance
    ///
    ///## Host Synchronization
    /// - Host access to [`command_buffer`] **must**  be externally synchronized
    /// - Host access to the [`CommandPool`] that [`command_buffer`] was allocated from  **must**
    ///   be externally synchronized
    ///
    ///## Command Properties
    ///# Related
    /// - [`khr_copy_commands2`]
    /// - [`crate::vulkan1_3`]
    /// - [`CommandBuffer`]
    /// - [`CopyBufferToImageInfo2`]
    ///
    ///# Notes and documentation
    ///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
    ///
    ///This documentation is generated from the Vulkan specification and documentation.
    ///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
    /// Commons Attribution 4.0 International*.
    ///This license explicitely allows adapting the source material as long as proper credit is
    /// given.
    #[doc(alias = "vkCmdCopyBufferToImage2")]
    #[doc(alias = "vkCmdCopyBufferToImage2KHR")]
    #[track_caller]
    #[inline]
    pub unsafe fn cmd_copy_buffer_to_image2<'lt>(
        self: &Unique<CommandBuffer>,
        p_copy_buffer_to_image_info: &CopyBufferToImageInfo2<'lt>,
    ) -> () {
        #[cfg(any(debug_assertions, feature = "assertions"))]
        let _function = self
            .device()
            .vtable()
            .vulkan1_3()
            .and_then(|vtable| vtable.cmd_copy_buffer_to_image2())
            .or_else(|| {
                #[cfg(feature = "VK_KHR_copy_commands2")]
                return self
                    .device()
                    .vtable()
                    .khr_copy_commands2()
                    .and_then(|vtable| vtable.cmd_copy_buffer_to_image2_khr());
                #[cfg(not(feature = "VK_KHR_copy_commands2"))]
                return None;
            })
            .expect("function not loaded");
        #[cfg(not(any(debug_assertions, feature = "assertions")))]
        let _function = self
            .device()
            .vtable()
            .vulkan1_3()
            .and_then(|vtable| vtable.cmd_copy_buffer_to_image2())
            .or_else(|| {
                #[cfg(feature = "VK_KHR_copy_commands2")]
                return self
                    .device()
                    .vtable()
                    .khr_copy_commands2()
                    .and_then(|vtable| vtable.cmd_copy_buffer_to_image2_khr());
                #[cfg(not(feature = "VK_KHR_copy_commands2"))]
                return None;
            })
            .unwrap_unchecked();
        let _return = _function(
            self.as_raw(),
            p_copy_buffer_to_image_info as *const CopyBufferToImageInfo2<'lt>,
        );
        ()
    }
}
impl CommandBuffer {
    ///[vkCmdCopyImageToBuffer2](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCopyImageToBuffer2.html) - Copy image data into a buffer
    ///# C Specifications
    ///To copy data from an image object to a buffer object, call:
    ///```c
    ///// Provided by VK_VERSION_1_3
    ///void vkCmdCopyImageToBuffer2(
    ///    VkCommandBuffer                             commandBuffer,
    ///    const VkCopyImageToBufferInfo2*             pCopyImageToBufferInfo);
    ///```
    ///or the equivalent command
    ///```c
    ///// Provided by VK_KHR_copy_commands2
    ///void vkCmdCopyImageToBuffer2KHR(
    ///    VkCommandBuffer                             commandBuffer,
    ///    const VkCopyImageToBufferInfo2*             pCopyImageToBufferInfo);
    ///```
    ///# Parameters
    /// - [`command_buffer`] is the command buffer into which the command will be recorded.
    /// - [`p_copy_image_to_buffer_info`] is a pointer to a [`CopyImageToBufferInfo2`] structure
    ///   describing the copy parameters.
    ///# Description
    ///This command is functionally identical to [`cmd_copy_image_to_buffer`], but
    ///includes extensible sub-structures that include `sType` and `pNext`
    ///parameters, allowing them to be more easily extended.
    ///## Valid Usage
    /// - If [`command_buffer`] is an unprotected command buffer and [`protectedNoFault`]() is not
    ///   supported, `srcImage` **must**  not be a protected image
    /// - If [`command_buffer`] is an unprotected command buffer and [`protectedNoFault`]() is not
    ///   supported, `dstBuffer` **must**  not be a protected buffer
    /// - If [`command_buffer`] is a protected command buffer and [`protectedNoFault`]() is not
    ///   supported, `dstBuffer` **must**  not be an unprotected buffer
    ///
    ///## Valid Usage (Implicit)
    /// - [`command_buffer`] **must**  be a valid [`CommandBuffer`] handle
    /// - [`p_copy_image_to_buffer_info`] **must**  be a valid pointer to a valid
    ///   [`CopyImageToBufferInfo2`] structure
    /// - [`command_buffer`] **must**  be in the [recording state]()
    /// - The [`CommandPool`] that [`command_buffer`] was allocated from  **must**  support
    ///   transfer, graphics, or compute operations
    /// - This command  **must**  only be called outside of a render pass instance
    ///
    ///## Host Synchronization
    /// - Host access to [`command_buffer`] **must**  be externally synchronized
    /// - Host access to the [`CommandPool`] that [`command_buffer`] was allocated from  **must**
    ///   be externally synchronized
    ///
    ///## Command Properties
    ///# Related
    /// - [`khr_copy_commands2`]
    /// - [`crate::vulkan1_3`]
    /// - [`CommandBuffer`]
    /// - [`CopyImageToBufferInfo2`]
    ///
    ///# Notes and documentation
    ///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
    ///
    ///This documentation is generated from the Vulkan specification and documentation.
    ///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
    /// Commons Attribution 4.0 International*.
    ///This license explicitely allows adapting the source material as long as proper credit is
    /// given.
    #[doc(alias = "vkCmdCopyImageToBuffer2")]
    #[doc(alias = "vkCmdCopyImageToBuffer2KHR")]
    #[track_caller]
    #[inline]
    pub unsafe fn cmd_copy_image_to_buffer2<'lt>(
        self: &Unique<CommandBuffer>,
        p_copy_image_to_buffer_info: &CopyImageToBufferInfo2<'lt>,
    ) -> () {
        #[cfg(any(debug_assertions, feature = "assertions"))]
        let _function = self
            .device()
            .vtable()
            .vulkan1_3()
            .and_then(|vtable| vtable.cmd_copy_image_to_buffer2())
            .or_else(|| {
                #[cfg(feature = "VK_KHR_copy_commands2")]
                return self
                    .device()
                    .vtable()
                    .khr_copy_commands2()
                    .and_then(|vtable| vtable.cmd_copy_image_to_buffer2_khr());
                #[cfg(not(feature = "VK_KHR_copy_commands2"))]
                return None;
            })
            .expect("function not loaded");
        #[cfg(not(any(debug_assertions, feature = "assertions")))]
        let _function = self
            .device()
            .vtable()
            .vulkan1_3()
            .and_then(|vtable| vtable.cmd_copy_image_to_buffer2())
            .or_else(|| {
                #[cfg(feature = "VK_KHR_copy_commands2")]
                return self
                    .device()
                    .vtable()
                    .khr_copy_commands2()
                    .and_then(|vtable| vtable.cmd_copy_image_to_buffer2_khr());
                #[cfg(not(feature = "VK_KHR_copy_commands2"))]
                return None;
            })
            .unwrap_unchecked();
        let _return = _function(
            self.as_raw(),
            p_copy_image_to_buffer_info as *const CopyImageToBufferInfo2<'lt>,
        );
        ()
    }
}
impl CommandBuffer {
    ///[vkCmdResolveImage2](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdResolveImage2.html) - Resolve regions of an image
    ///# C Specifications
    ///To resolve a multisample image to a non-multisample image, call:
    ///```c
    ///// Provided by VK_VERSION_1_3
    ///void vkCmdResolveImage2(
    ///    VkCommandBuffer                             commandBuffer,
    ///    const VkResolveImageInfo2*                  pResolveImageInfo);
    ///```
    ///or the equivalent command
    ///```c
    ///// Provided by VK_KHR_copy_commands2
    ///void vkCmdResolveImage2KHR(
    ///    VkCommandBuffer                             commandBuffer,
    ///    const VkResolveImageInfo2*                  pResolveImageInfo);
    ///```
    ///# Parameters
    /// - [`command_buffer`] is the command buffer into which the command will be recorded.
    /// - [`p_resolve_image_info`] is a pointer to a [`ResolveImageInfo2`] structure describing the
    ///   resolve parameters.
    ///# Description
    ///This command is functionally identical to [`cmd_resolve_image`], but
    ///includes extensible sub-structures that include `sType` and `pNext`
    ///parameters, allowing them to be more easily extended.
    ///## Valid Usage
    /// - If [`command_buffer`] is an unprotected command buffer and [`protectedNoFault`]() is not
    ///   supported, `srcImage` **must**  not be a protected image
    /// - If [`command_buffer`] is an unprotected command buffer and [`protectedNoFault`]() is not
    ///   supported, `dstImage` **must**  not be a protected image
    /// - If [`command_buffer`] is a protected command buffer and [`protectedNoFault`]() is not
    ///   supported, `dstImage` **must**  not be an unprotected image
    ///
    ///## Valid Usage (Implicit)
    /// - [`command_buffer`] **must**  be a valid [`CommandBuffer`] handle
    /// - [`p_resolve_image_info`] **must**  be a valid pointer to a valid [`ResolveImageInfo2`]
    ///   structure
    /// - [`command_buffer`] **must**  be in the [recording state]()
    /// - The [`CommandPool`] that [`command_buffer`] was allocated from  **must**  support graphics
    ///   operations
    /// - This command  **must**  only be called outside of a render pass instance
    ///
    ///## Host Synchronization
    /// - Host access to [`command_buffer`] **must**  be externally synchronized
    /// - Host access to the [`CommandPool`] that [`command_buffer`] was allocated from  **must**
    ///   be externally synchronized
    ///
    ///## Command Properties
    ///# Related
    /// - [`khr_copy_commands2`]
    /// - [`crate::vulkan1_3`]
    /// - [`CommandBuffer`]
    /// - [`ResolveImageInfo2`]
    ///
    ///# Notes and documentation
    ///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
    ///
    ///This documentation is generated from the Vulkan specification and documentation.
    ///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
    /// Commons Attribution 4.0 International*.
    ///This license explicitely allows adapting the source material as long as proper credit is
    /// given.
    #[doc(alias = "vkCmdResolveImage2")]
    #[doc(alias = "vkCmdResolveImage2KHR")]
    #[track_caller]
    #[inline]
    pub unsafe fn cmd_resolve_image2<'lt>(
        self: &Unique<CommandBuffer>,
        p_resolve_image_info: &ResolveImageInfo2<'lt>,
    ) -> () {
        #[cfg(any(debug_assertions, feature = "assertions"))]
        let _function = self
            .device()
            .vtable()
            .vulkan1_3()
            .and_then(|vtable| vtable.cmd_resolve_image2())
            .or_else(|| {
                #[cfg(feature = "VK_KHR_copy_commands2")]
                return self
                    .device()
                    .vtable()
                    .khr_copy_commands2()
                    .and_then(|vtable| vtable.cmd_resolve_image2_khr());
                #[cfg(not(feature = "VK_KHR_copy_commands2"))]
                return None;
            })
            .expect("function not loaded");
        #[cfg(not(any(debug_assertions, feature = "assertions")))]
        let _function = self
            .device()
            .vtable()
            .vulkan1_3()
            .and_then(|vtable| vtable.cmd_resolve_image2())
            .or_else(|| {
                #[cfg(feature = "VK_KHR_copy_commands2")]
                return self
                    .device()
                    .vtable()
                    .khr_copy_commands2()
                    .and_then(|vtable| vtable.cmd_resolve_image2_khr());
                #[cfg(not(feature = "VK_KHR_copy_commands2"))]
                return None;
            })
            .unwrap_unchecked();
        let _return = _function(self.as_raw(), p_resolve_image_info as *const ResolveImageInfo2<'lt>);
        ()
    }
}
impl CommandBuffer {
    ///[vkCmdSetEvent2](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetEvent2.html) - Set an event object to signaled state
    ///# C Specifications
    ///To signal an event from a device, call:
    ///```c
    ///// Provided by VK_VERSION_1_3
    ///void vkCmdSetEvent2(
    ///    VkCommandBuffer                             commandBuffer,
    ///    VkEvent                                     event,
    ///    const VkDependencyInfo*                     pDependencyInfo);
    ///```
    ///or the equivalent command
    ///```c
    ///// Provided by VK_KHR_synchronization2
    ///void vkCmdSetEvent2KHR(
    ///    VkCommandBuffer                             commandBuffer,
    ///    VkEvent                                     event,
    ///    const VkDependencyInfo*                     pDependencyInfo);
    ///```
    ///# Parameters
    /// - [`command_buffer`] is the command buffer into which the command is recorded.
    /// - [`event`] is the event that will be signaled.
    /// - [`p_dependency_info`] is a pointer to a [`DependencyInfo`] structure defining the first
    ///   scopes of this operation.
    ///# Description
    ///When [`cmd_set_event2`] is submitted to a queue, it defines the first half
    ///of memory dependencies defined by [`p_dependency_info`], as well as an event
    ///signal operation which sets the event to the signaled state.
    ///A memory dependency is defined between the event signal operation and
    ///commands that occur earlier in submission order.The first [synchronization scope](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-dependencies-scopes) and
    ///[access scope](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-dependencies-access-scopes) are defined by
    ///the union of all the memory dependencies defined by [`p_dependency_info`],
    ///and are applied to all operations that occur earlier in
    ///[submission order](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-submission-order).
    ///[Queue family ownership transfers](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-queue-transfers) and
    ///[image layout transitions](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-image-layout-transitions)
    ///defined by [`p_dependency_info`] are also included in the first scopes.The second [synchronization scope](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-dependencies-scopes)
    ///includes only the event signal operation, and any
    ///[queue family ownership transfers](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-queue-transfers) and
    ///[image layout transitions](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-image-layout-transitions)
    ///defined by [`p_dependency_info`].The second [access scope](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-dependencies-access-scopes)
    ///includes only [queue family ownership
    ///transfers](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-queue-transfers) and [image layout
    ///transitions](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-image-layout-transitions).Future [`cmd_wait_events2`] commands rely on all values of each element in
    ///[`p_dependency_info`] matching exactly with those used to signal the
    ///corresponding event.
    ///[`cmd_wait_events`] **must**  not be used to wait on the result of a signal
    ///operation defined by [`cmd_set_event2`].If [`event`] is already in the signaled state when
    /// [`cmd_set_event2`] is
    ///executed on the device, then [`cmd_set_event2`] has no effect, no event
    ///signal operation occurs, and no dependency is generated.
    ///## Valid Usage
    /// - The [`synchronization2`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-synchronization2)
    ///   feature  **must**  be enabled
    /// - The `dependencyFlags` member of [`p_dependency_info`] **must**  be `0`
    /// - The current device mask of [`command_buffer`] **must**  include exactly one physical
    ///   device
    /// - The `srcStageMask` member of any element of the `pMemoryBarriers`,
    ///   `pBufferMemoryBarriers`, or `pImageMemoryBarriers` members of [`p_dependency_info`]
    ///   **must**  only include pipeline stages valid for the queue family that was used to create
    ///   the command pool that [`command_buffer`] was allocated from
    /// - The `dstStageMask` member of any element of the `pMemoryBarriers`,
    ///   `pBufferMemoryBarriers`, or `pImageMemoryBarriers` members of [`p_dependency_info`]
    ///   **must**  only include pipeline stages valid for the queue family that was used to create
    ///   the command pool that [`command_buffer`] was allocated from
    ///
    ///## Valid Usage (Implicit)
    /// - [`command_buffer`] **must**  be a valid [`CommandBuffer`] handle
    /// - [`event`] **must**  be a valid [`Event`] handle
    /// - [`p_dependency_info`] **must**  be a valid pointer to a valid [`DependencyInfo`] structure
    /// - [`command_buffer`] **must**  be in the [recording state]()
    /// - The [`CommandPool`] that [`command_buffer`] was allocated from  **must**  support
    ///   graphics, or compute operations
    /// - This command  **must**  only be called outside of a render pass instance
    /// - Both of [`command_buffer`], and [`event`] **must**  have been created, allocated, or
    ///   retrieved from the same [`Device`]
    ///
    ///## Host Synchronization
    /// - Host access to [`command_buffer`] **must**  be externally synchronized
    /// - Host access to the [`CommandPool`] that [`command_buffer`] was allocated from  **must**
    ///   be externally synchronized
    ///
    ///## Command Properties
    ///# Related
    /// - [`khr_synchronization2`]
    /// - [`crate::vulkan1_3`]
    /// - [`CommandBuffer`]
    /// - [`DependencyInfo`]
    /// - [`Event`]
    ///
    ///# Notes and documentation
    ///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
    ///
    ///This documentation is generated from the Vulkan specification and documentation.
    ///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
    /// Commons Attribution 4.0 International*.
    ///This license explicitely allows adapting the source material as long as proper credit is
    /// given.
    #[doc(alias = "vkCmdSetEvent2")]
    #[doc(alias = "vkCmdSetEvent2KHR")]
    #[track_caller]
    #[inline]
    pub unsafe fn cmd_set_event2<'lt>(
        self: &Unique<CommandBuffer>,
        event: Event,
        p_dependency_info: &DependencyInfo<'lt>,
    ) -> () {
        #[cfg(any(debug_assertions, feature = "assertions"))]
        let _function = self
            .device()
            .vtable()
            .vulkan1_3()
            .and_then(|vtable| vtable.cmd_set_event2())
            .or_else(|| {
                #[cfg(feature = "VK_KHR_synchronization2")]
                return self
                    .device()
                    .vtable()
                    .khr_synchronization2()
                    .and_then(|vtable| vtable.cmd_set_event2_khr());
                #[cfg(not(feature = "VK_KHR_synchronization2"))]
                return None;
            })
            .expect("function not loaded");
        #[cfg(not(any(debug_assertions, feature = "assertions")))]
        let _function = self
            .device()
            .vtable()
            .vulkan1_3()
            .and_then(|vtable| vtable.cmd_set_event2())
            .or_else(|| {
                #[cfg(feature = "VK_KHR_synchronization2")]
                return self
                    .device()
                    .vtable()
                    .khr_synchronization2()
                    .and_then(|vtable| vtable.cmd_set_event2_khr());
                #[cfg(not(feature = "VK_KHR_synchronization2"))]
                return None;
            })
            .unwrap_unchecked();
        let _return = _function(self.as_raw(), event, p_dependency_info as *const DependencyInfo<'lt>);
        ()
    }
}
impl CommandBuffer {
    ///[vkCmdResetEvent2](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdResetEvent2.html) - Reset an event object to non-signaled state
    ///# C Specifications
    ///To unsignal the event from a device, call:
    ///```c
    ///// Provided by VK_VERSION_1_3
    ///void vkCmdResetEvent2(
    ///    VkCommandBuffer                             commandBuffer,
    ///    VkEvent                                     event,
    ///    VkPipelineStageFlags2                       stageMask);
    ///```
    ///or the equivalent command
    ///```c
    ///// Provided by VK_KHR_synchronization2
    ///void vkCmdResetEvent2KHR(
    ///    VkCommandBuffer                             commandBuffer,
    ///    VkEvent                                     event,
    ///    VkPipelineStageFlags2                       stageMask);
    ///```
    ///# Parameters
    /// - [`command_buffer`] is the command buffer into which the command is recorded.
    /// - [`event`] is the event that will be unsignaled.
    /// - [`stage_mask`] is a [`PipelineStageFlags2`] mask of pipeline stages used to determine the first [synchronization scope](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-dependencies-scopes).
    ///# Description
    ///When [`cmd_reset_event2`] is submitted to a queue, it defines an execution
    ///dependency on commands that were submitted before it, and defines an event
    ///unsignal operation which resets the event to the unsignaled state.The first [synchronization scope](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-dependencies-scopes)
    ///includes all commands that occur earlier in
    ///[submission order](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-submission-order).
    ///The synchronization scope is limited to operations by [`stage_mask`] or
    ///stages that are [logically earlier](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-pipeline-stages-order)
    ///than [`stage_mask`].The second [synchronization scope](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-dependencies-scopes)
    ///includes only the event unsignal operation.If [`event`] is already in the unsignaled state
    /// when
    ///[`cmd_reset_event2`] is executed on the device, then this command has no
    ///effect, no event unsignal operation occurs, and no execution dependency is
    ///generated.
    ///## Valid Usage
    /// - If the [geometry shaders](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-geometryShader)
    ///   feature is not enabled, [`stage_mask`] **must**  not contain
    ///   `VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT`
    /// - If the [tessellation shaders](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-tessellationShader)
    ///   feature is not enabled, [`stage_mask`] **must**  not contain
    ///   `VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT` or
    ///   `VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT`
    /// - If the [conditional rendering](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-conditionalRendering)
    ///   feature is not enabled, [`stage_mask`] **must**  not contain
    ///   `VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT`
    /// - If the [fragment density map](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-fragmentDensityMap)
    ///   feature is not enabled, [`stage_mask`] **must**  not contain
    ///   `VK_PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT`
    /// - If the [transform feedback](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-transformFeedback)
    ///   feature is not enabled, [`stage_mask`] **must**  not contain
    ///   `VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT`
    /// - If the [mesh shaders](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-meshShader)
    ///   feature is not enabled, [`stage_mask`] **must**  not contain
    ///   `VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_NV`
    /// - If the [task shaders](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-taskShader)
    ///   feature is not enabled, [`stage_mask`] **must**  not contain
    ///   `VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_NV`
    /// - If the [shading rate image](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-shadingRateImage)
    ///   feature is not enabled, [`stage_mask`] **must**  not contain
    ///   `VK_PIPELINE_STAGE_2_SHADING_RATE_IMAGE_BIT_NV`
    /// - If the [subpass shading](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-subpassShading)
    ///   feature is not enabled, [`stage_mask`] **must**  not contain
    ///   `VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI`
    /// - If the [invocation mask image](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-invocationMask)
    ///   feature is not enabled, [`stage_mask`] **must**  not contain
    ///   `VK_PIPELINE_STAGE_2_INVOCATION_MASK_BIT_HUAWEI`
    /// - The [`synchronization2`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-synchronization2)
    ///   feature  **must**  be enabled
    /// - [`stage_mask`] **must**  not include `VK_PIPELINE_STAGE_2_HOST_BIT`
    /// - There  **must**  be an execution dependency between [`cmd_reset_event2`] and the execution
    ///   of any [`cmd_wait_events`] that includes [`event`] in its `pEvents` parameter
    /// - There  **must**  be an execution dependency between [`cmd_reset_event2`] and the execution
    ///   of any [`cmd_wait_events2`] that includes [`event`] in its `pEvents` parameter
    /// - [`command_buffer`]s current device mask  **must**  include exactly one physical device
    ///
    ///## Valid Usage (Implicit)
    /// - [`command_buffer`] **must**  be a valid [`CommandBuffer`] handle
    /// - [`event`] **must**  be a valid [`Event`] handle
    /// - [`stage_mask`] **must**  be a valid combination of [`PipelineStageFlagBits2`] values
    /// - [`command_buffer`] **must**  be in the [recording state]()
    /// - The [`CommandPool`] that [`command_buffer`] was allocated from  **must**  support
    ///   graphics, or compute operations
    /// - This command  **must**  only be called outside of a render pass instance
    /// - Both of [`command_buffer`], and [`event`] **must**  have been created, allocated, or
    ///   retrieved from the same [`Device`]
    ///
    ///## Host Synchronization
    /// - Host access to [`command_buffer`] **must**  be externally synchronized
    /// - Host access to the [`CommandPool`] that [`command_buffer`] was allocated from  **must**
    ///   be externally synchronized
    ///
    ///## Command Properties
    ///# Related
    /// - [`khr_synchronization2`]
    /// - [`crate::vulkan1_3`]
    /// - [`CommandBuffer`]
    /// - [`Event`]
    /// - [`PipelineStageFlags2`]
    ///
    ///# Notes and documentation
    ///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
    ///
    ///This documentation is generated from the Vulkan specification and documentation.
    ///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
    /// Commons Attribution 4.0 International*.
    ///This license explicitely allows adapting the source material as long as proper credit is
    /// given.
    #[doc(alias = "vkCmdResetEvent2")]
    #[doc(alias = "vkCmdResetEvent2KHR")]
    #[track_caller]
    #[inline]
    pub unsafe fn cmd_reset_event2(self: &Unique<CommandBuffer>, event: Event, stage_mask: PipelineStageFlags2) -> () {
        #[cfg(any(debug_assertions, feature = "assertions"))]
        let _function = self
            .device()
            .vtable()
            .vulkan1_3()
            .and_then(|vtable| vtable.cmd_reset_event2())
            .or_else(|| {
                #[cfg(feature = "VK_KHR_synchronization2")]
                return self
                    .device()
                    .vtable()
                    .khr_synchronization2()
                    .and_then(|vtable| vtable.cmd_reset_event2_khr());
                #[cfg(not(feature = "VK_KHR_synchronization2"))]
                return None;
            })
            .expect("function not loaded");
        #[cfg(not(any(debug_assertions, feature = "assertions")))]
        let _function = self
            .device()
            .vtable()
            .vulkan1_3()
            .and_then(|vtable| vtable.cmd_reset_event2())
            .or_else(|| {
                #[cfg(feature = "VK_KHR_synchronization2")]
                return self
                    .device()
                    .vtable()
                    .khr_synchronization2()
                    .and_then(|vtable| vtable.cmd_reset_event2_khr());
                #[cfg(not(feature = "VK_KHR_synchronization2"))]
                return None;
            })
            .unwrap_unchecked();
        let _return = _function(self.as_raw(), event, stage_mask);
        ()
    }
}
impl CommandBuffer {
    ///[vkCmdWaitEvents2](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdWaitEvents2.html) - Wait for one or more events
    ///# C Specifications
    ///To wait for one or more events to enter the signaled state on a device,
    ///call:
    ///```c
    ///// Provided by VK_VERSION_1_3
    ///void vkCmdWaitEvents2(
    ///    VkCommandBuffer                             commandBuffer,
    ///    uint32_t                                    eventCount,
    ///    const VkEvent*                              pEvents,
    ///    const VkDependencyInfo*                     pDependencyInfos);
    ///```
    ///or the equivalent command
    ///```c
    ///// Provided by VK_KHR_synchronization2
    ///void vkCmdWaitEvents2KHR(
    ///    VkCommandBuffer                             commandBuffer,
    ///    uint32_t                                    eventCount,
    ///    const VkEvent*                              pEvents,
    ///    const VkDependencyInfo*                     pDependencyInfos);
    ///```
    ///# Parameters
    /// - [`command_buffer`] is the command buffer into which the command is recorded.
    /// - [`event_count`] is the length of the [`p_events`] array.
    /// - [`p_events`] is a pointer to an array of [`event_count`] events to wait on.
    /// - [`p_dependency_infos`] is a pointer to an array of [`event_count`][`DependencyInfo`] structures, defining the second [synchronization scope](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-dependencies-scopes).
    ///# Description
    ///When [`cmd_wait_events2`] is submitted to a queue, it inserts memory
    ///dependencies according to the elements of [`p_dependency_infos`] and each
    ///corresponding element of [`p_events`].
    ///[`cmd_wait_events2`] **must**  not be used to wait on event signal operations
    ///occurring on other queues, or signal operations executed by
    ///[`cmd_set_event`].The first [synchronization scope](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-dependencies-scopes) and
    ///[access scope](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-dependencies-access-scopes) of each memory
    ///dependency defined by any element i of [`p_dependency_infos`] are
    ///applied to operations that occurred earlier in
    ///[submission order](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-submission-order) than the last event
    ///signal operation on element i of [`p_events`].Signal operations for an event at index i are
    /// only included if:
    /// - The event was signaled by a [`cmd_set_event2`] command that occurred earlier in [submission order](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-submission-order) with a `dependencyInfo` parameter exactly equal to the element of [`p_dependency_infos`] at index i ; or
    /// - The event was created without `VK_EVENT_CREATE_DEVICE_ONLY_BIT`, and the first [synchronization scope](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-dependencies-scopes) defined by the element of [`p_dependency_infos`] at index i only includes host operations (`VK_PIPELINE_STAGE_2_HOST_BIT`).
    ///The second [synchronization scope](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-dependencies-scopes)
    ///and [access scope](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-dependencies-access-scopes) of each
    ///memory dependency defined by any element i of [`p_dependency_infos`]
    ///are applied to operations that occurred later in
    ///[submission order](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-submission-order) than
    ///[`cmd_wait_events2`].
    ///## Valid Usage
    /// - The [`synchronization2`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-synchronization2)
    ///   feature  **must**  be enabled
    /// - Members of [`p_events`] **must**  not have been signaled by [`cmd_set_event`]
    /// - For any element i of [`p_events`], if that event is signaled by [`cmd_set_event2`], that
    ///   commands `dependencyInfo` parameter  **must**  be exactly equal to the ith element of
    ///   [`p_dependency_infos`]
    /// - For any element i of [`p_events`], if that event is signaled by [`set_event`], barriers in
    ///   the ith element of [`p_dependency_infos`] **must**  include only host operations in their first
    ///   [synchronization scope](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-dependencies-scopes)
    /// - For any element i of [`p_events`], if barriers in the ith element of
    ///   [`p_dependency_infos`] include only host operations, the ith element of [`p_events`]
    ///   **must**  be signaled before [`cmd_wait_events2`] is executed
    /// -    For any element i of [`p_events`], if barriers in the ith element of [`p_dependency_infos`] do not include host operations, the ith element of [`p_events`] **must**  be signaled by a corresponding [`cmd_set_event2`] that occurred earlier in [submission order](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-submission-order)
    /// - The `srcStageMask` member of any element of the `pMemoryBarriers`,
    ///   `pBufferMemoryBarriers`, or `pImageMemoryBarriers` members of [`p_dependency_infos`]
    ///   **must**  either include only pipeline stages valid for the queue family that was used to
    ///   create the command pool that [`command_buffer`] was allocated from, or include only
    ///   `VK_PIPELINE_STAGE_2_HOST_BIT`
    /// - The `dstStageMask` member of any element of the `pMemoryBarriers`,
    ///   `pBufferMemoryBarriers`, or `pImageMemoryBarriers` members of [`p_dependency_infos`]
    ///   **must**  only include pipeline stages valid for the queue family that was used to create
    ///   the command pool that [`command_buffer`] was allocated from
    /// - The `dependencyFlags` member of any element of `pDependencyInfo` **must**  be `0`
    /// - If [`p_events`] includes one or more events that will be signaled by [`set_event`] after
    ///   [`command_buffer`] has been submitted to a queue, then [`cmd_wait_events2`] **must**  not
    ///   be called inside a render pass instance
    /// - [`command_buffer`]s current device mask  **must**  include exactly one physical device
    ///
    ///## Valid Usage (Implicit)
    /// - [`command_buffer`] **must**  be a valid [`CommandBuffer`] handle
    /// - [`p_events`] **must**  be a valid pointer to an array of [`event_count`] valid [`Event`]
    ///   handles
    /// - [`p_dependency_infos`] **must**  be a valid pointer to an array of [`event_count`] valid
    ///   [`DependencyInfo`] structures
    /// - [`command_buffer`] **must**  be in the [recording state]()
    /// - The [`CommandPool`] that [`command_buffer`] was allocated from  **must**  support
    ///   graphics, or compute operations
    /// - [`event_count`] **must**  be greater than `0`
    /// - Both of [`command_buffer`], and the elements of [`p_events`] **must**  have been created,
    ///   allocated, or retrieved from the same [`Device`]
    ///
    ///## Host Synchronization
    /// - Host access to [`command_buffer`] **must**  be externally synchronized
    /// - Host access to the [`CommandPool`] that [`command_buffer`] was allocated from  **must**
    ///   be externally synchronized
    ///
    ///## Command Properties
    ///# Related
    /// - [`khr_synchronization2`]
    /// - [`crate::vulkan1_3`]
    /// - [`CommandBuffer`]
    /// - [`DependencyInfo`]
    /// - [`Event`]
    ///
    ///# Notes and documentation
    ///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
    ///
    ///This documentation is generated from the Vulkan specification and documentation.
    ///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
    /// Commons Attribution 4.0 International*.
    ///This license explicitely allows adapting the source material as long as proper credit is
    /// given.
    #[doc(alias = "vkCmdWaitEvents2")]
    #[doc(alias = "vkCmdWaitEvents2KHR")]
    #[track_caller]
    #[inline]
    pub unsafe fn cmd_wait_events2<'lt>(
        self: &Unique<CommandBuffer>,
        p_events: &[crate::vulkan1_0::Event],
        p_dependency_infos: &[crate::vulkan1_3::DependencyInfo<'lt>],
    ) -> () {
        #[cfg(any(debug_assertions, feature = "assertions"))]
        let _function = self
            .device()
            .vtable()
            .vulkan1_3()
            .and_then(|vtable| vtable.cmd_wait_events2())
            .or_else(|| {
                #[cfg(feature = "VK_KHR_synchronization2")]
                return self
                    .device()
                    .vtable()
                    .khr_synchronization2()
                    .and_then(|vtable| vtable.cmd_wait_events2_khr());
                #[cfg(not(feature = "VK_KHR_synchronization2"))]
                return None;
            })
            .expect("function not loaded");
        #[cfg(not(any(debug_assertions, feature = "assertions")))]
        let _function = self
            .device()
            .vtable()
            .vulkan1_3()
            .and_then(|vtable| vtable.cmd_wait_events2())
            .or_else(|| {
                #[cfg(feature = "VK_KHR_synchronization2")]
                return self
                    .device()
                    .vtable()
                    .khr_synchronization2()
                    .and_then(|vtable| vtable.cmd_wait_events2_khr());
                #[cfg(not(feature = "VK_KHR_synchronization2"))]
                return None;
            })
            .unwrap_unchecked();
        let event_count = (|len: usize| len)(p_events.len()) as _;
        let _return = _function(
            self.as_raw(),
            event_count,
            p_events.as_ptr(),
            p_dependency_infos.as_ptr(),
        );
        ()
    }
}
impl CommandBuffer {
    ///[vkCmdPipelineBarrier2](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdPipelineBarrier2.html) - Insert a memory dependency
    ///# C Specifications
    ///To record a pipeline barrier, call:
    ///```c
    ///// Provided by VK_VERSION_1_3
    ///void vkCmdPipelineBarrier2(
    ///    VkCommandBuffer                             commandBuffer,
    ///    const VkDependencyInfo*                     pDependencyInfo);
    ///```
    ///or the equivalent command
    ///```c
    ///// Provided by VK_KHR_synchronization2
    ///void vkCmdPipelineBarrier2KHR(
    ///    VkCommandBuffer                             commandBuffer,
    ///    const VkDependencyInfo*                     pDependencyInfo);
    ///```
    ///# Parameters
    /// - [`command_buffer`] is the command buffer into which the command is recorded.
    /// - [`p_dependency_info`] is a pointer to a [`DependencyInfo`] structure defining the scopes
    ///   of this operation.
    ///# Description
    ///When [`cmd_pipeline_barrier2`] is submitted to a queue, it defines memory
    ///dependencies between commands that were submitted before it, and those
    ///submitted after it.The first [synchronization scope](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-dependencies-scopes) and
    ///[access scope](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-dependencies-access-scopes) of each memory
    ///dependency defined by [`p_dependency_info`] are applied to operations that
    ///occurred earlier in [submission order](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-submission-order).The second [synchronization scope](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-dependencies-scopes)
    ///and [access scope](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-dependencies-access-scopes) of each
    ///memory dependency defined by [`p_dependency_info`] are applied to operations
    ///that occurred later in [submission
    ///order](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-submission-order).If [`cmd_pipeline_barrier2`] is recorded within a render pass instance,
    ///the synchronization scopes are
    ///[limited to
    ///operations within the same subpass](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-pipeline-barriers-subpass-self-dependencies).
    ///## Valid Usage
    /// - If [`cmd_pipeline_barrier2`] is called within a render pass instance, the render pass
    ///   **must**  have been created with at least one [`SubpassDependency`] instance in
    ///   [`RenderPassCreateInfo::dependencies`] that expresses a dependency from the current
    ///   subpass to itself, with [synchronization scopes]() and [access scopes]() that are all
    ///   supersets of the scopes defined in this command
    /// - If [`cmd_pipeline_barrier2`] is called within a render pass instance, it  **must**  not
    ///   include any buffer memory barriers
    /// - If [`cmd_pipeline_barrier2`] is called within a render pass instance, the `image` member
    ///   of any image memory barrier included in this command  **must**  be an attachment used in
    ///   the current subpass both as an input attachment, and as either a color or depth/stencil
    ///   attachment
    /// - If [`cmd_pipeline_barrier2`] is called within a render pass instance, the `oldLayout` and
    ///   `newLayout` members of any image memory barrier included in this command  **must**  be
    ///   equal
    /// - If [`cmd_pipeline_barrier2`] is called within a render pass instance, the
    ///   `srcQueueFamilyIndex` and `dstQueueFamilyIndex` members of any image memory barrier
    ///   included in this command  **must**  be equal
    /// - If [`cmd_pipeline_barrier2`] is called outside of a render pass instance,
    ///   `VK_DEPENDENCY_VIEW_LOCAL_BIT` **must**  not be included in the dependency flags
    /// - If [`cmd_pipeline_barrier2`] is called within a render pass instance, the render pass
    ///   **must**  not have been started with [`cmd_begin_rendering`]
    /// - The [`synchronization2`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-synchronization2)
    ///   feature  **must**  be enabled
    /// - The `srcStageMask` member of any element of the `pMemoryBarriers`,
    ///   `pBufferMemoryBarriers`, or `pImageMemoryBarriers` members of [`p_dependency_info`]
    ///   **must**  only include pipeline stages valid for the queue family that was used to create
    ///   the command pool that [`command_buffer`] was allocated from
    /// - The `dstStageMask` member of any element of the `pMemoryBarriers`,
    ///   `pBufferMemoryBarriers`, or `pImageMemoryBarriers` members of [`p_dependency_info`]
    ///   **must**  only include pipeline stages valid for the queue family that was used to create
    ///   the command pool that [`command_buffer`] was allocated from
    ///
    ///## Valid Usage (Implicit)
    /// - [`command_buffer`] **must**  be a valid [`CommandBuffer`] handle
    /// - [`p_dependency_info`] **must**  be a valid pointer to a valid [`DependencyInfo`] structure
    /// - [`command_buffer`] **must**  be in the [recording state]()
    /// - The [`CommandPool`] that [`command_buffer`] was allocated from  **must**  support
    ///   transfer, graphics, or compute operations
    ///
    ///## Host Synchronization
    /// - Host access to [`command_buffer`] **must**  be externally synchronized
    /// - Host access to the [`CommandPool`] that [`command_buffer`] was allocated from  **must**
    ///   be externally synchronized
    ///
    ///## Command Properties
    ///# Related
    /// - [`khr_synchronization2`]
    /// - [`crate::vulkan1_3`]
    /// - [`CommandBuffer`]
    /// - [`DependencyInfo`]
    ///
    ///# Notes and documentation
    ///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
    ///
    ///This documentation is generated from the Vulkan specification and documentation.
    ///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
    /// Commons Attribution 4.0 International*.
    ///This license explicitely allows adapting the source material as long as proper credit is
    /// given.
    #[doc(alias = "vkCmdPipelineBarrier2")]
    #[doc(alias = "vkCmdPipelineBarrier2KHR")]
    #[track_caller]
    #[inline]
    pub unsafe fn cmd_pipeline_barrier2<'lt>(
        self: &Unique<CommandBuffer>,
        p_dependency_info: &DependencyInfo<'lt>,
    ) -> () {
        #[cfg(any(debug_assertions, feature = "assertions"))]
        let _function = self
            .device()
            .vtable()
            .vulkan1_3()
            .and_then(|vtable| vtable.cmd_pipeline_barrier2())
            .or_else(|| {
                #[cfg(feature = "VK_KHR_synchronization2")]
                return self
                    .device()
                    .vtable()
                    .khr_synchronization2()
                    .and_then(|vtable| vtable.cmd_pipeline_barrier2_khr());
                #[cfg(not(feature = "VK_KHR_synchronization2"))]
                return None;
            })
            .expect("function not loaded");
        #[cfg(not(any(debug_assertions, feature = "assertions")))]
        let _function = self
            .device()
            .vtable()
            .vulkan1_3()
            .and_then(|vtable| vtable.cmd_pipeline_barrier2())
            .or_else(|| {
                #[cfg(feature = "VK_KHR_synchronization2")]
                return self
                    .device()
                    .vtable()
                    .khr_synchronization2()
                    .and_then(|vtable| vtable.cmd_pipeline_barrier2_khr());
                #[cfg(not(feature = "VK_KHR_synchronization2"))]
                return None;
            })
            .unwrap_unchecked();
        let _return = _function(self.as_raw(), p_dependency_info as *const DependencyInfo<'lt>);
        ()
    }
}
impl CommandBuffer {
    ///[vkCmdWriteTimestamp2](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdWriteTimestamp2.html) - Write a device timestamp into a query object
    ///# C Specifications
    ///To request a timestamp, call:
    ///```c
    ///// Provided by VK_VERSION_1_3
    ///void vkCmdWriteTimestamp2(
    ///    VkCommandBuffer                             commandBuffer,
    ///    VkPipelineStageFlags2                       stage,
    ///    VkQueryPool                                 queryPool,
    ///    uint32_t                                    query);
    ///```
    ///or the equivalent command
    ///```c
    ///// Provided by VK_KHR_synchronization2
    ///void vkCmdWriteTimestamp2KHR(
    ///    VkCommandBuffer                             commandBuffer,
    ///    VkPipelineStageFlags2                       stage,
    ///    VkQueryPool                                 queryPool,
    ///    uint32_t                                    query);
    ///```
    ///# Parameters
    /// - [`command_buffer`] is the command buffer into which the command will be recorded.
    /// - [`stage`] specifies a stage of the pipeline.
    /// - [`query_pool`] is the query pool that will manage the timestamp.
    /// - [`query`] is the query within the query pool that will contain the timestamp.
    ///# Description
    ///When [`cmd_write_timestamp2`] is submitted to a queue, it defines an
    ///execution dependency on commands that were submitted before it, and writes a
    ///timestamp to a query pool.The first [synchronization scope](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-dependencies-scopes)
    ///includes all commands that occur earlier in
    ///[submission order](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-submission-order).
    ///The synchronization scope is limited to operations on the pipeline stage
    ///specified by [`stage`].The second [synchronization scope](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-dependencies-scopes)
    ///includes only the timestamp write operation.When the timestamp value is written, the
    /// availability status of the query is
    ///set to available.Comparisons between timestamps are not meaningful if the timestamps are
    ///written by commands submitted to different queues.If [`cmd_write_timestamp2`] is called
    /// while executing a render pass
    ///instance that has multiview enabled, the timestamp uses N consecutive
    ///query indices in the query pool (starting at [`query`]) where N is
    ///the number of bits set in the view mask of the subpass the command is
    ///executed in.
    ///The resulting query values are determined by an implementation-dependent
    ///choice of one of the following behaviors:
    /// - The first query is a timestamp value and (if more than one bit is set in the view mask)
    ///   zero is written to the remaining queries. If two timestamps are written in the same
    ///   subpass, the sum of the execution time of all views between those commands is the
    ///   difference between the first query written by each command.
    /// - All N queries are timestamp values. If two timestamps are written in the same subpass, the
    ///   sum of the execution time of all views between those commands is the sum of the difference
    ///   between corresponding queries written by each command. The difference between
    ///   corresponding queries  **may**  be the execution time of a single view.
    ///In either case, the application  **can**  sum the differences between all N
    ///queries to determine the total execution time.
    ///## Valid Usage
    /// - If the [geometry shaders](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-geometryShader)
    ///   feature is not enabled, [`stage`] **must**  not contain
    ///   `VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT`
    /// - If the [tessellation shaders](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-tessellationShader)
    ///   feature is not enabled, [`stage`] **must**  not contain
    ///   `VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT` or
    ///   `VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT`
    /// - If the [conditional rendering](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-conditionalRendering)
    ///   feature is not enabled, [`stage`] **must**  not contain
    ///   `VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT`
    /// - If the [fragment density map](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-fragmentDensityMap)
    ///   feature is not enabled, [`stage`] **must**  not contain
    ///   `VK_PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT`
    /// - If the [transform feedback](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-transformFeedback)
    ///   feature is not enabled, [`stage`] **must**  not contain
    ///   `VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT`
    /// - If the [mesh shaders](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-meshShader)
    ///   feature is not enabled, [`stage`] **must**  not contain
    ///   `VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_NV`
    /// - If the [task shaders](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-taskShader)
    ///   feature is not enabled, [`stage`] **must**  not contain
    ///   `VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_NV`
    /// - If the [shading rate image](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-shadingRateImage)
    ///   feature is not enabled, [`stage`] **must**  not contain
    ///   `VK_PIPELINE_STAGE_2_SHADING_RATE_IMAGE_BIT_NV`
    /// - If the [subpass shading](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-subpassShading)
    ///   feature is not enabled, [`stage`] **must**  not contain
    ///   `VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI`
    /// - If the [invocation mask image](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-invocationMask)
    ///   feature is not enabled, [`stage`] **must**  not contain
    ///   `VK_PIPELINE_STAGE_2_INVOCATION_MASK_BIT_HUAWEI`
    /// - The [`synchronization2`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-synchronization2)
    ///   feature  **must**  be enabled
    /// - [`stage`] **must**  only include a single pipeline stage
    /// - [`stage`] **must**  only include stages valid for the queue family that was used to create
    ///   the command pool that [`command_buffer`] was allocated from
    /// - [`query_pool`] **must**  have been created with a `queryType` of `VK_QUERY_TYPE_TIMESTAMP`
    /// - The query identified by [`query_pool`] and [`query`] **must**  be *unavailable*
    /// - The command pools queue family  **must**  support a non-zero `timestampValidBits`
    /// - [`query`] **must**  be less than the number of queries in [`query_pool`]
    /// - All queries used by the command  **must**  be unavailable
    /// - If [`cmd_write_timestamp2`] is called within a render pass instance, the sum of [`query`]
    ///   and the number of bits set in the current subpasss view mask  **must**  be less than or
    ///   equal to the number of queries in [`query_pool`]
    ///
    ///## Valid Usage (Implicit)
    /// - [`command_buffer`] **must**  be a valid [`CommandBuffer`] handle
    /// - [`stage`] **must**  be a valid combination of [`PipelineStageFlagBits2`] values
    /// - [`query_pool`] **must**  be a valid [`QueryPool`] handle
    /// - [`command_buffer`] **must**  be in the [recording state]()
    /// - The [`CommandPool`] that [`command_buffer`] was allocated from  **must**  support
    ///   transfer, graphics, compute, decode, or encode operations
    /// - Both of [`command_buffer`], and [`query_pool`] **must**  have been created, allocated, or
    ///   retrieved from the same [`Device`]
    ///
    ///## Host Synchronization
    /// - Host access to [`command_buffer`] **must**  be externally synchronized
    /// - Host access to the [`CommandPool`] that [`command_buffer`] was allocated from  **must**
    ///   be externally synchronized
    ///
    ///## Command Properties
    ///# Related
    /// - [`khr_synchronization2`]
    /// - [`crate::vulkan1_3`]
    /// - [`CommandBuffer`]
    /// - [`PipelineStageFlags2`]
    /// - [`QueryPool`]
    ///
    ///# Notes and documentation
    ///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
    ///
    ///This documentation is generated from the Vulkan specification and documentation.
    ///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
    /// Commons Attribution 4.0 International*.
    ///This license explicitely allows adapting the source material as long as proper credit is
    /// given.
    #[doc(alias = "vkCmdWriteTimestamp2")]
    #[doc(alias = "vkCmdWriteTimestamp2KHR")]
    #[track_caller]
    #[inline]
    pub unsafe fn cmd_write_timestamp2(
        self: &Unique<CommandBuffer>,
        stage: PipelineStageFlags2,
        query_pool: QueryPool,
        query: Option<u32>,
    ) -> () {
        #[cfg(any(debug_assertions, feature = "assertions"))]
        let _function = self
            .device()
            .vtable()
            .vulkan1_3()
            .and_then(|vtable| vtable.cmd_write_timestamp2())
            .or_else(|| {
                #[cfg(feature = "VK_KHR_synchronization2")]
                return self
                    .device()
                    .vtable()
                    .khr_synchronization2()
                    .and_then(|vtable| vtable.cmd_write_timestamp2_khr());
                #[cfg(not(feature = "VK_KHR_synchronization2"))]
                return None;
            })
            .expect("function not loaded");
        #[cfg(not(any(debug_assertions, feature = "assertions")))]
        let _function = self
            .device()
            .vtable()
            .vulkan1_3()
            .and_then(|vtable| vtable.cmd_write_timestamp2())
            .or_else(|| {
                #[cfg(feature = "VK_KHR_synchronization2")]
                return self
                    .device()
                    .vtable()
                    .khr_synchronization2()
                    .and_then(|vtable| vtable.cmd_write_timestamp2_khr());
                #[cfg(not(feature = "VK_KHR_synchronization2"))]
                return None;
            })
            .unwrap_unchecked();
        let _return = _function(self.as_raw(), stage, query_pool, query.unwrap_or_default() as _);
        ()
    }
}
impl CommandBuffer {
    ///[vkCmdBeginRendering](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBeginRendering.html) - Begin a dynamic render pass instance
    ///# C Specifications
    ///To begin a render pass instance, call:
    ///```c
    ///// Provided by VK_VERSION_1_3
    ///void vkCmdBeginRendering(
    ///    VkCommandBuffer                             commandBuffer,
    ///    const VkRenderingInfo*                      pRenderingInfo);
    ///```
    ///or the equivalent command
    ///```c
    ///// Provided by VK_KHR_dynamic_rendering
    ///void vkCmdBeginRenderingKHR(
    ///    VkCommandBuffer                             commandBuffer,
    ///    const VkRenderingInfo*                      pRenderingInfo);
    ///```
    ///# Parameters
    /// - [`command_buffer`] is the command buffer in which to record the command.
    /// - [`p_rendering_info`] is a pointer to a [`RenderingInfo`] structure specifying details of
    ///   the render pass instance to begin.
    ///# Description
    ///After beginning a render pass instance, the command buffer is ready to
    ///record [draw commands](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#drawing).If `pRenderingInfo->flags` includes `VK_RENDERING_RESUMING_BIT` then
    ///this render pass is resumed from a render pass instance that has been
    ///suspended earlier in [submission order](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-submission-order).
    ///## Valid Usage
    /// - The [`dynamicRendering`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-dynamicRendering)
    ///   feature  **must**  be enabled
    /// - If [`command_buffer`] is a secondary command buffer, `pRenderingInfo->flags` **must**  not
    ///   include `VK_RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT`
    ///
    ///## Valid Usage (Implicit)
    /// - [`command_buffer`] **must**  be a valid [`CommandBuffer`] handle
    /// - [`p_rendering_info`] **must**  be a valid pointer to a valid [`RenderingInfo`] structure
    /// - [`command_buffer`] **must**  be in the [recording state]()
    /// - The [`CommandPool`] that [`command_buffer`] was allocated from  **must**  support graphics
    ///   operations
    /// - This command  **must**  only be called outside of a render pass instance
    ///
    ///## Host Synchronization
    /// - Host access to [`command_buffer`] **must**  be externally synchronized
    /// - Host access to the [`CommandPool`] that [`command_buffer`] was allocated from  **must**
    ///   be externally synchronized
    ///
    ///## Command Properties
    ///# Related
    /// - [`khr_dynamic_rendering`]
    /// - [`crate::vulkan1_3`]
    /// - [`CommandBuffer`]
    /// - [`RenderingInfo`]
    ///
    ///# Notes and documentation
    ///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
    ///
    ///This documentation is generated from the Vulkan specification and documentation.
    ///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
    /// Commons Attribution 4.0 International*.
    ///This license explicitely allows adapting the source material as long as proper credit is
    /// given.
    #[doc(alias = "vkCmdBeginRendering")]
    #[doc(alias = "vkCmdBeginRenderingKHR")]
    #[track_caller]
    #[inline]
    pub unsafe fn cmd_begin_rendering<'lt>(self: &Unique<CommandBuffer>, p_rendering_info: &RenderingInfo<'lt>) -> () {
        #[cfg(any(debug_assertions, feature = "assertions"))]
        let _function = self
            .device()
            .vtable()
            .vulkan1_3()
            .and_then(|vtable| vtable.cmd_begin_rendering())
            .or_else(|| {
                #[cfg(feature = "VK_KHR_dynamic_rendering")]
                return self
                    .device()
                    .vtable()
                    .khr_dynamic_rendering()
                    .and_then(|vtable| vtable.cmd_begin_rendering_khr());
                #[cfg(not(feature = "VK_KHR_dynamic_rendering"))]
                return None;
            })
            .expect("function not loaded");
        #[cfg(not(any(debug_assertions, feature = "assertions")))]
        let _function = self
            .device()
            .vtable()
            .vulkan1_3()
            .and_then(|vtable| vtable.cmd_begin_rendering())
            .or_else(|| {
                #[cfg(feature = "VK_KHR_dynamic_rendering")]
                return self
                    .device()
                    .vtable()
                    .khr_dynamic_rendering()
                    .and_then(|vtable| vtable.cmd_begin_rendering_khr());
                #[cfg(not(feature = "VK_KHR_dynamic_rendering"))]
                return None;
            })
            .unwrap_unchecked();
        let _return = _function(self.as_raw(), p_rendering_info as *const RenderingInfo<'lt>);
        ()
    }
}
impl CommandBuffer {
    ///[vkCmdEndRendering](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdEndRendering.html) - End a dynamic render pass instance
    ///# C Specifications
    ///To end a render pass instance, call:
    ///```c
    ///// Provided by VK_VERSION_1_3
    ///void vkCmdEndRendering(
    ///    VkCommandBuffer                             commandBuffer);
    ///```
    ///or the equivalent command
    ///```c
    ///// Provided by VK_KHR_dynamic_rendering
    ///void vkCmdEndRenderingKHR(
    ///    VkCommandBuffer                             commandBuffer);
    ///```
    ///# Parameters
    /// - [`command_buffer`] is the command buffer in which to record the command.
    ///# Description
    ///If the value of `pRenderingInfo->flags` used to begin this render pass
    ///instance included `VK_RENDERING_SUSPENDING_BIT`, then this render pass
    ///is suspended and will be resumed later in
    ///[submission order](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-submission-order).
    ///## Valid Usage
    /// - The current render pass instance  **must**  have been begun with [`cmd_begin_rendering`]
    /// - The current render pass instance  **must**  have been begun in [`command_buffer`]
    ///
    ///## Valid Usage (Implicit)
    /// - [`command_buffer`] **must**  be a valid [`CommandBuffer`] handle
    /// - [`command_buffer`] **must**  be in the [recording state]()
    /// - The [`CommandPool`] that [`command_buffer`] was allocated from  **must**  support graphics
    ///   operations
    /// - This command  **must**  only be called inside of a render pass instance
    ///
    ///## Host Synchronization
    /// - Host access to [`command_buffer`] **must**  be externally synchronized
    /// - Host access to the [`CommandPool`] that [`command_buffer`] was allocated from  **must**
    ///   be externally synchronized
    ///
    ///## Command Properties
    ///# Related
    /// - [`khr_dynamic_rendering`]
    /// - [`crate::vulkan1_3`]
    /// - [`CommandBuffer`]
    ///
    ///# Notes and documentation
    ///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
    ///
    ///This documentation is generated from the Vulkan specification and documentation.
    ///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
    /// Commons Attribution 4.0 International*.
    ///This license explicitely allows adapting the source material as long as proper credit is
    /// given.
    #[doc(alias = "vkCmdEndRendering")]
    #[doc(alias = "vkCmdEndRenderingKHR")]
    #[track_caller]
    #[inline]
    pub unsafe fn cmd_end_rendering(self: &Unique<CommandBuffer>) -> () {
        #[cfg(any(debug_assertions, feature = "assertions"))]
        let _function = self
            .device()
            .vtable()
            .vulkan1_3()
            .and_then(|vtable| vtable.cmd_end_rendering())
            .or_else(|| {
                #[cfg(feature = "VK_KHR_dynamic_rendering")]
                return self
                    .device()
                    .vtable()
                    .khr_dynamic_rendering()
                    .and_then(|vtable| vtable.cmd_end_rendering_khr());
                #[cfg(not(feature = "VK_KHR_dynamic_rendering"))]
                return None;
            })
            .expect("function not loaded");
        #[cfg(not(any(debug_assertions, feature = "assertions")))]
        let _function = self
            .device()
            .vtable()
            .vulkan1_3()
            .and_then(|vtable| vtable.cmd_end_rendering())
            .or_else(|| {
                #[cfg(feature = "VK_KHR_dynamic_rendering")]
                return self
                    .device()
                    .vtable()
                    .khr_dynamic_rendering()
                    .and_then(|vtable| vtable.cmd_end_rendering_khr());
                #[cfg(not(feature = "VK_KHR_dynamic_rendering"))]
                return None;
            })
            .unwrap_unchecked();
        let _return = _function(self.as_raw());
        ()
    }
}
///[VkPrivateDataSlot](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPrivateDataSlot.html) - Opaque handle to a private data slot object
///# C Specifications
///Private data slots are represented by [`PrivateDataSlot`] handles:
///```c
///// Provided by VK_VERSION_1_3
///VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkPrivateDataSlot)
///```
///or the equivalent
///```c
///// Provided by VK_EXT_private_data
///typedef VkPrivateDataSlot VkPrivateDataSlotEXT;
///```
///# Related
/// - [`ext_private_data`]
/// - [`crate::vulkan1_3`]
/// - [`create_private_data_slot`]
/// - [`create_private_data_slot_ext`]
/// - [`destroy_private_data_slot`]
/// - [`destroy_private_data_slot_ext`]
/// - [`get_private_data`]
/// - [`get_private_data_ext`]
/// - [`set_private_data`]
/// - [`set_private_data_ext`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkPrivateDataSlot")]
#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[repr(transparent)]
pub struct PrivateDataSlot(pub u64);
impl PrivateDataSlot {
    ///Creates a new null handle
    #[inline]
    pub const fn null() -> Self {
        Self(0)
    }
    ///Checks if this is a null handle
    #[inline]
    pub fn is_null(&self) -> bool {
        self == &Self::null()
    }
    ///Gets the raw value
    #[inline]
    pub fn raw(&self) -> u64 {
        self.0
    }
}
unsafe impl Send for PrivateDataSlot {}
impl Default for PrivateDataSlot {
    fn default() -> Self {
        Self::null()
    }
}
impl Handle for PrivateDataSlot {
    type Parent = Unique<Device>;
    type VTable = ();
    type Metadata = AtomicBool;
    type Storage = u64;
    #[inline]
    fn as_stored(self) -> Self::Storage {
        self.0
    }
    #[inline]
    unsafe fn from_stored(this: Self::Storage) -> Self {
        Self(this)
    }
    #[inline]
    #[track_caller]
    unsafe fn destroy(self: &mut Unique<Self>) {
        if !self.metadata().load(Ordering::Acquire) {
            self.device()
                .destroy_private_data_slot(Some(self.as_raw().coerce()), None);
        }
    }
    #[inline]
    unsafe fn load_vtable(&self, _: &Self::Parent, _: &Self::Metadata) -> Self::VTable {}
}
impl Unique<PrivateDataSlot> {
    ///Gets the reference to the [`Entry`]
    #[inline]
    pub fn entry(&self) -> &Arc<Entry> {
        self.parent().parent().parent().parent()
    }
    ///Gets the reference to the [`Instance`]
    #[inline]
    pub fn instance(&self) -> &Unique<Instance> {
        self.parent().parent().parent()
    }
    ///Gets the reference to the [`PhysicalDevice`]
    #[inline]
    pub fn physical_device(&self) -> &Unique<PhysicalDevice> {
        self.parent().parent()
    }
    ///Gets the reference to the [`Device`]
    #[inline]
    pub fn device(&self) -> &Unique<Device> {
        self.parent()
    }
    ///Disables the base dropping behaviour of this handle
    #[inline]
    pub fn disable_drop(&self) {
        self.metadata().store(true, Ordering::Relaxed);
    }
}
#[cfg(feature = "VK_EXT_debug_utils")]
impl PrivateDataSlot {
    ///Give a user-friendly name to an object
    pub fn set_name(self: &Unique<Self>, name: &std::ffi::CStr) {
        assert!(
            self.strong_count() == 1,
            "`set_name` requires that the object be synchronized"
        );
        if !self.device().instance().metadata().ext_debug_utils() {
            return;
        }
        let info = crate::generated::extensions::ext_debug_utils::DebugUtilsObjectNameInfoEXT::default()
            .with_object_type(crate::generated::vulkan1_0::ObjectType::PRIVATE_DATA_SLOT)
            .with_object_handle(self.as_stored() as u64)
            .with_object_name(name.as_ptr());
        unsafe {
            self.device().set_debug_utils_object_name_ext(&info).unwrap();
        }
    }
    ///Attach arbitrary data to an object
    ///In addition to setting a name for an object, debugging and validation layers may have uses
    /// for additional
    ///binary data on a per-object basis that has no other place in the Vulkan API. For example, a
    /// VkShaderModule
    ///could have additional debugging data attached to it to aid in offline shader tracing.
    pub fn set_tag(self: &Unique<Self>, tag: u64, data: &[u8]) {
        assert!(
            self.strong_count() == 1,
            "`set_name` requires that the object be synchronized"
        );
        if !self.device().instance().metadata().ext_debug_utils() {
            return;
        }
        let info = crate::generated::extensions::ext_debug_utils::DebugUtilsObjectTagInfoEXT::default()
            .with_object_type(crate::generated::vulkan1_0::ObjectType::PRIVATE_DATA_SLOT)
            .with_object_handle(self.as_stored() as u64)
            .with_tag_name(tag)
            .with_tag_size(data.len() as _)
            .with_tag_raw(data.as_ptr().cast());
        unsafe {
            self.device().set_debug_utils_object_tag_ext(&info).unwrap();
        }
    }
}
///The V-table of [`Instance`] for functions from `VULKAN_1_3`
pub struct InstanceV13VTable {
    ///See [`FNGetPhysicalDeviceToolProperties`] for more information.
    pub get_physical_device_tool_properties: FNGetPhysicalDeviceToolProperties,
}
impl InstanceV13VTable {
    ///Loads the VTable from the owner and the names
    #[track_caller]
    pub fn load(
        loader_fn: unsafe extern "system" fn(
            Instance,
            *const std::os::raw::c_char,
        ) -> Option<unsafe extern "system" fn()>,
        loader: Instance,
    ) -> Self {
        Self {
            get_physical_device_tool_properties: unsafe {
                std::mem::transmute(loader_fn(
                    loader,
                    crate::cstr!("vkGetPhysicalDeviceToolProperties").as_ptr(),
                ))
            },
        }
    }
    ///Gets [`Self::get_physical_device_tool_properties`]. See
    /// [`FNGetPhysicalDeviceToolProperties`] for more information.
    pub fn get_physical_device_tool_properties(&self) -> FNGetPhysicalDeviceToolProperties {
        self.get_physical_device_tool_properties
    }
}
///The V-table of [`Device`] for functions from `VULKAN_1_3`
pub struct DeviceV13VTable {
    ///See [`FNGetDeviceBufferMemoryRequirements`] for more information.
    pub get_device_buffer_memory_requirements: FNGetDeviceBufferMemoryRequirements,
    ///See [`FNGetDeviceImageMemoryRequirements`] for more information.
    pub get_device_image_memory_requirements: FNGetDeviceImageMemoryRequirements,
    ///See [`FNGetDeviceImageSparseMemoryRequirements`] for more information.
    pub get_device_image_sparse_memory_requirements: FNGetDeviceImageSparseMemoryRequirements,
    ///See [`FNCreatePrivateDataSlot`] for more information.
    pub create_private_data_slot: FNCreatePrivateDataSlot,
    ///See [`FNDestroyPrivateDataSlot`] for more information.
    pub destroy_private_data_slot: FNDestroyPrivateDataSlot,
    ///See [`FNSetPrivateData`] for more information.
    pub set_private_data: FNSetPrivateData,
    ///See [`FNGetPrivateData`] for more information.
    pub get_private_data: FNGetPrivateData,
    ///See [`FNQueueSubmit2`] for more information.
    pub queue_submit2: FNQueueSubmit2,
    ///See [`FNCmdSetCullMode`] for more information.
    pub cmd_set_cull_mode: FNCmdSetCullMode,
    ///See [`FNCmdSetFrontFace`] for more information.
    pub cmd_set_front_face: FNCmdSetFrontFace,
    ///See [`FNCmdSetPrimitiveTopology`] for more information.
    pub cmd_set_primitive_topology: FNCmdSetPrimitiveTopology,
    ///See [`FNCmdSetViewportWithCount`] for more information.
    pub cmd_set_viewport_with_count: FNCmdSetViewportWithCount,
    ///See [`FNCmdSetScissorWithCount`] for more information.
    pub cmd_set_scissor_with_count: FNCmdSetScissorWithCount,
    ///See [`FNCmdBindVertexBuffers2`] for more information.
    pub cmd_bind_vertex_buffers2: FNCmdBindVertexBuffers2,
    ///See [`FNCmdSetDepthTestEnable`] for more information.
    pub cmd_set_depth_test_enable: FNCmdSetDepthTestEnable,
    ///See [`FNCmdSetDepthWriteEnable`] for more information.
    pub cmd_set_depth_write_enable: FNCmdSetDepthWriteEnable,
    ///See [`FNCmdSetDepthCompareOp`] for more information.
    pub cmd_set_depth_compare_op: FNCmdSetDepthCompareOp,
    ///See [`FNCmdSetDepthBoundsTestEnable`] for more information.
    pub cmd_set_depth_bounds_test_enable: FNCmdSetDepthBoundsTestEnable,
    ///See [`FNCmdSetStencilTestEnable`] for more information.
    pub cmd_set_stencil_test_enable: FNCmdSetStencilTestEnable,
    ///See [`FNCmdSetStencilOp`] for more information.
    pub cmd_set_stencil_op: FNCmdSetStencilOp,
    ///See [`FNCmdSetRasterizerDiscardEnable`] for more information.
    pub cmd_set_rasterizer_discard_enable: FNCmdSetRasterizerDiscardEnable,
    ///See [`FNCmdSetDepthBiasEnable`] for more information.
    pub cmd_set_depth_bias_enable: FNCmdSetDepthBiasEnable,
    ///See [`FNCmdSetPrimitiveRestartEnable`] for more information.
    pub cmd_set_primitive_restart_enable: FNCmdSetPrimitiveRestartEnable,
    ///See [`FNCmdCopyBuffer2`] for more information.
    pub cmd_copy_buffer2: FNCmdCopyBuffer2,
    ///See [`FNCmdCopyImage2`] for more information.
    pub cmd_copy_image2: FNCmdCopyImage2,
    ///See [`FNCmdBlitImage2`] for more information.
    pub cmd_blit_image2: FNCmdBlitImage2,
    ///See [`FNCmdCopyBufferToImage2`] for more information.
    pub cmd_copy_buffer_to_image2: FNCmdCopyBufferToImage2,
    ///See [`FNCmdCopyImageToBuffer2`] for more information.
    pub cmd_copy_image_to_buffer2: FNCmdCopyImageToBuffer2,
    ///See [`FNCmdResolveImage2`] for more information.
    pub cmd_resolve_image2: FNCmdResolveImage2,
    ///See [`FNCmdSetEvent2`] for more information.
    pub cmd_set_event2: FNCmdSetEvent2,
    ///See [`FNCmdResetEvent2`] for more information.
    pub cmd_reset_event2: FNCmdResetEvent2,
    ///See [`FNCmdWaitEvents2`] for more information.
    pub cmd_wait_events2: FNCmdWaitEvents2,
    ///See [`FNCmdPipelineBarrier2`] for more information.
    pub cmd_pipeline_barrier2: FNCmdPipelineBarrier2,
    ///See [`FNCmdWriteTimestamp2`] for more information.
    pub cmd_write_timestamp2: FNCmdWriteTimestamp2,
    ///See [`FNCmdBeginRendering`] for more information.
    pub cmd_begin_rendering: FNCmdBeginRendering,
    ///See [`FNCmdEndRendering`] for more information.
    pub cmd_end_rendering: FNCmdEndRendering,
}
impl DeviceV13VTable {
    ///Loads the VTable from the owner and the names
    #[track_caller]
    pub fn load(
        loader_fn: unsafe extern "system" fn(
            Device,
            *const std::os::raw::c_char,
        ) -> Option<unsafe extern "system" fn()>,
        loader: Device,
    ) -> Self {
        Self {
            get_device_buffer_memory_requirements: unsafe {
                std::mem::transmute(loader_fn(
                    loader,
                    crate::cstr!("vkGetDeviceBufferMemoryRequirements").as_ptr(),
                ))
            },
            get_device_image_memory_requirements: unsafe {
                std::mem::transmute(loader_fn(
                    loader,
                    crate::cstr!("vkGetDeviceImageMemoryRequirements").as_ptr(),
                ))
            },
            get_device_image_sparse_memory_requirements: unsafe {
                std::mem::transmute(loader_fn(
                    loader,
                    crate::cstr!("vkGetDeviceImageSparseMemoryRequirements").as_ptr(),
                ))
            },
            create_private_data_slot: unsafe {
                std::mem::transmute(loader_fn(loader, crate::cstr!("vkCreatePrivateDataSlot").as_ptr()))
            },
            destroy_private_data_slot: unsafe {
                std::mem::transmute(loader_fn(loader, crate::cstr!("vkDestroyPrivateDataSlot").as_ptr()))
            },
            set_private_data: unsafe {
                std::mem::transmute(loader_fn(loader, crate::cstr!("vkSetPrivateData").as_ptr()))
            },
            get_private_data: unsafe {
                std::mem::transmute(loader_fn(loader, crate::cstr!("vkGetPrivateData").as_ptr()))
            },
            queue_submit2: unsafe { std::mem::transmute(loader_fn(loader, crate::cstr!("vkQueueSubmit2").as_ptr())) },
            cmd_set_cull_mode: unsafe {
                std::mem::transmute(loader_fn(loader, crate::cstr!("vkCmdSetCullMode").as_ptr()))
            },
            cmd_set_front_face: unsafe {
                std::mem::transmute(loader_fn(loader, crate::cstr!("vkCmdSetFrontFace").as_ptr()))
            },
            cmd_set_primitive_topology: unsafe {
                std::mem::transmute(loader_fn(loader, crate::cstr!("vkCmdSetPrimitiveTopology").as_ptr()))
            },
            cmd_set_viewport_with_count: unsafe {
                std::mem::transmute(loader_fn(loader, crate::cstr!("vkCmdSetViewportWithCount").as_ptr()))
            },
            cmd_set_scissor_with_count: unsafe {
                std::mem::transmute(loader_fn(loader, crate::cstr!("vkCmdSetScissorWithCount").as_ptr()))
            },
            cmd_bind_vertex_buffers2: unsafe {
                std::mem::transmute(loader_fn(loader, crate::cstr!("vkCmdBindVertexBuffers2").as_ptr()))
            },
            cmd_set_depth_test_enable: unsafe {
                std::mem::transmute(loader_fn(loader, crate::cstr!("vkCmdSetDepthTestEnable").as_ptr()))
            },
            cmd_set_depth_write_enable: unsafe {
                std::mem::transmute(loader_fn(loader, crate::cstr!("vkCmdSetDepthWriteEnable").as_ptr()))
            },
            cmd_set_depth_compare_op: unsafe {
                std::mem::transmute(loader_fn(loader, crate::cstr!("vkCmdSetDepthCompareOp").as_ptr()))
            },
            cmd_set_depth_bounds_test_enable: unsafe {
                std::mem::transmute(loader_fn(
                    loader,
                    crate::cstr!("vkCmdSetDepthBoundsTestEnable").as_ptr(),
                ))
            },
            cmd_set_stencil_test_enable: unsafe {
                std::mem::transmute(loader_fn(loader, crate::cstr!("vkCmdSetStencilTestEnable").as_ptr()))
            },
            cmd_set_stencil_op: unsafe {
                std::mem::transmute(loader_fn(loader, crate::cstr!("vkCmdSetStencilOp").as_ptr()))
            },
            cmd_set_rasterizer_discard_enable: unsafe {
                std::mem::transmute(loader_fn(
                    loader,
                    crate::cstr!("vkCmdSetRasterizerDiscardEnable").as_ptr(),
                ))
            },
            cmd_set_depth_bias_enable: unsafe {
                std::mem::transmute(loader_fn(loader, crate::cstr!("vkCmdSetDepthBiasEnable").as_ptr()))
            },
            cmd_set_primitive_restart_enable: unsafe {
                std::mem::transmute(loader_fn(
                    loader,
                    crate::cstr!("vkCmdSetPrimitiveRestartEnable").as_ptr(),
                ))
            },
            cmd_copy_buffer2: unsafe {
                std::mem::transmute(loader_fn(loader, crate::cstr!("vkCmdCopyBuffer2").as_ptr()))
            },
            cmd_copy_image2: unsafe {
                std::mem::transmute(loader_fn(loader, crate::cstr!("vkCmdCopyImage2").as_ptr()))
            },
            cmd_blit_image2: unsafe {
                std::mem::transmute(loader_fn(loader, crate::cstr!("vkCmdBlitImage2").as_ptr()))
            },
            cmd_copy_buffer_to_image2: unsafe {
                std::mem::transmute(loader_fn(loader, crate::cstr!("vkCmdCopyBufferToImage2").as_ptr()))
            },
            cmd_copy_image_to_buffer2: unsafe {
                std::mem::transmute(loader_fn(loader, crate::cstr!("vkCmdCopyImageToBuffer2").as_ptr()))
            },
            cmd_resolve_image2: unsafe {
                std::mem::transmute(loader_fn(loader, crate::cstr!("vkCmdResolveImage2").as_ptr()))
            },
            cmd_set_event2: unsafe { std::mem::transmute(loader_fn(loader, crate::cstr!("vkCmdSetEvent2").as_ptr())) },
            cmd_reset_event2: unsafe {
                std::mem::transmute(loader_fn(loader, crate::cstr!("vkCmdResetEvent2").as_ptr()))
            },
            cmd_wait_events2: unsafe {
                std::mem::transmute(loader_fn(loader, crate::cstr!("vkCmdWaitEvents2").as_ptr()))
            },
            cmd_pipeline_barrier2: unsafe {
                std::mem::transmute(loader_fn(loader, crate::cstr!("vkCmdPipelineBarrier2").as_ptr()))
            },
            cmd_write_timestamp2: unsafe {
                std::mem::transmute(loader_fn(loader, crate::cstr!("vkCmdWriteTimestamp2").as_ptr()))
            },
            cmd_begin_rendering: unsafe {
                std::mem::transmute(loader_fn(loader, crate::cstr!("vkCmdBeginRendering").as_ptr()))
            },
            cmd_end_rendering: unsafe {
                std::mem::transmute(loader_fn(loader, crate::cstr!("vkCmdEndRendering").as_ptr()))
            },
        }
    }
    ///Gets [`Self::get_device_buffer_memory_requirements`]. See
    /// [`FNGetDeviceBufferMemoryRequirements`] for more information.
    pub fn get_device_buffer_memory_requirements(&self) -> FNGetDeviceBufferMemoryRequirements {
        self.get_device_buffer_memory_requirements
    }
    ///Gets [`Self::get_device_image_memory_requirements`]. See
    /// [`FNGetDeviceImageMemoryRequirements`] for more information.
    pub fn get_device_image_memory_requirements(&self) -> FNGetDeviceImageMemoryRequirements {
        self.get_device_image_memory_requirements
    }
    ///Gets [`Self::get_device_image_sparse_memory_requirements`]. See
    /// [`FNGetDeviceImageSparseMemoryRequirements`] for more information.
    pub fn get_device_image_sparse_memory_requirements(&self) -> FNGetDeviceImageSparseMemoryRequirements {
        self.get_device_image_sparse_memory_requirements
    }
    ///Gets [`Self::create_private_data_slot`]. See [`FNCreatePrivateDataSlot`] for more
    /// information.
    pub fn create_private_data_slot(&self) -> FNCreatePrivateDataSlot {
        self.create_private_data_slot
    }
    ///Gets [`Self::destroy_private_data_slot`]. See [`FNDestroyPrivateDataSlot`] for more
    /// information.
    pub fn destroy_private_data_slot(&self) -> FNDestroyPrivateDataSlot {
        self.destroy_private_data_slot
    }
    ///Gets [`Self::set_private_data`]. See [`FNSetPrivateData`] for more information.
    pub fn set_private_data(&self) -> FNSetPrivateData {
        self.set_private_data
    }
    ///Gets [`Self::get_private_data`]. See [`FNGetPrivateData`] for more information.
    pub fn get_private_data(&self) -> FNGetPrivateData {
        self.get_private_data
    }
    ///Gets [`Self::queue_submit2`]. See [`FNQueueSubmit2`] for more information.
    pub fn queue_submit2(&self) -> FNQueueSubmit2 {
        self.queue_submit2
    }
    ///Gets [`Self::cmd_set_cull_mode`]. See [`FNCmdSetCullMode`] for more information.
    pub fn cmd_set_cull_mode(&self) -> FNCmdSetCullMode {
        self.cmd_set_cull_mode
    }
    ///Gets [`Self::cmd_set_front_face`]. See [`FNCmdSetFrontFace`] for more information.
    pub fn cmd_set_front_face(&self) -> FNCmdSetFrontFace {
        self.cmd_set_front_face
    }
    ///Gets [`Self::cmd_set_primitive_topology`]. See [`FNCmdSetPrimitiveTopology`] for more
    /// information.
    pub fn cmd_set_primitive_topology(&self) -> FNCmdSetPrimitiveTopology {
        self.cmd_set_primitive_topology
    }
    ///Gets [`Self::cmd_set_viewport_with_count`]. See [`FNCmdSetViewportWithCount`] for more
    /// information.
    pub fn cmd_set_viewport_with_count(&self) -> FNCmdSetViewportWithCount {
        self.cmd_set_viewport_with_count
    }
    ///Gets [`Self::cmd_set_scissor_with_count`]. See [`FNCmdSetScissorWithCount`] for more
    /// information.
    pub fn cmd_set_scissor_with_count(&self) -> FNCmdSetScissorWithCount {
        self.cmd_set_scissor_with_count
    }
    ///Gets [`Self::cmd_bind_vertex_buffers2`]. See [`FNCmdBindVertexBuffers2`] for more
    /// information.
    pub fn cmd_bind_vertex_buffers2(&self) -> FNCmdBindVertexBuffers2 {
        self.cmd_bind_vertex_buffers2
    }
    ///Gets [`Self::cmd_set_depth_test_enable`]. See [`FNCmdSetDepthTestEnable`] for more
    /// information.
    pub fn cmd_set_depth_test_enable(&self) -> FNCmdSetDepthTestEnable {
        self.cmd_set_depth_test_enable
    }
    ///Gets [`Self::cmd_set_depth_write_enable`]. See [`FNCmdSetDepthWriteEnable`] for more
    /// information.
    pub fn cmd_set_depth_write_enable(&self) -> FNCmdSetDepthWriteEnable {
        self.cmd_set_depth_write_enable
    }
    ///Gets [`Self::cmd_set_depth_compare_op`]. See [`FNCmdSetDepthCompareOp`] for more
    /// information.
    pub fn cmd_set_depth_compare_op(&self) -> FNCmdSetDepthCompareOp {
        self.cmd_set_depth_compare_op
    }
    ///Gets [`Self::cmd_set_depth_bounds_test_enable`]. See [`FNCmdSetDepthBoundsTestEnable`] for
    /// more information.
    pub fn cmd_set_depth_bounds_test_enable(&self) -> FNCmdSetDepthBoundsTestEnable {
        self.cmd_set_depth_bounds_test_enable
    }
    ///Gets [`Self::cmd_set_stencil_test_enable`]. See [`FNCmdSetStencilTestEnable`] for more
    /// information.
    pub fn cmd_set_stencil_test_enable(&self) -> FNCmdSetStencilTestEnable {
        self.cmd_set_stencil_test_enable
    }
    ///Gets [`Self::cmd_set_stencil_op`]. See [`FNCmdSetStencilOp`] for more information.
    pub fn cmd_set_stencil_op(&self) -> FNCmdSetStencilOp {
        self.cmd_set_stencil_op
    }
    ///Gets [`Self::cmd_set_rasterizer_discard_enable`]. See [`FNCmdSetRasterizerDiscardEnable`]
    /// for more information.
    pub fn cmd_set_rasterizer_discard_enable(&self) -> FNCmdSetRasterizerDiscardEnable {
        self.cmd_set_rasterizer_discard_enable
    }
    ///Gets [`Self::cmd_set_depth_bias_enable`]. See [`FNCmdSetDepthBiasEnable`] for more
    /// information.
    pub fn cmd_set_depth_bias_enable(&self) -> FNCmdSetDepthBiasEnable {
        self.cmd_set_depth_bias_enable
    }
    ///Gets [`Self::cmd_set_primitive_restart_enable`]. See [`FNCmdSetPrimitiveRestartEnable`] for
    /// more information.
    pub fn cmd_set_primitive_restart_enable(&self) -> FNCmdSetPrimitiveRestartEnable {
        self.cmd_set_primitive_restart_enable
    }
    ///Gets [`Self::cmd_copy_buffer2`]. See [`FNCmdCopyBuffer2`] for more information.
    pub fn cmd_copy_buffer2(&self) -> FNCmdCopyBuffer2 {
        self.cmd_copy_buffer2
    }
    ///Gets [`Self::cmd_copy_image2`]. See [`FNCmdCopyImage2`] for more information.
    pub fn cmd_copy_image2(&self) -> FNCmdCopyImage2 {
        self.cmd_copy_image2
    }
    ///Gets [`Self::cmd_blit_image2`]. See [`FNCmdBlitImage2`] for more information.
    pub fn cmd_blit_image2(&self) -> FNCmdBlitImage2 {
        self.cmd_blit_image2
    }
    ///Gets [`Self::cmd_copy_buffer_to_image2`]. See [`FNCmdCopyBufferToImage2`] for more
    /// information.
    pub fn cmd_copy_buffer_to_image2(&self) -> FNCmdCopyBufferToImage2 {
        self.cmd_copy_buffer_to_image2
    }
    ///Gets [`Self::cmd_copy_image_to_buffer2`]. See [`FNCmdCopyImageToBuffer2`] for more
    /// information.
    pub fn cmd_copy_image_to_buffer2(&self) -> FNCmdCopyImageToBuffer2 {
        self.cmd_copy_image_to_buffer2
    }
    ///Gets [`Self::cmd_resolve_image2`]. See [`FNCmdResolveImage2`] for more information.
    pub fn cmd_resolve_image2(&self) -> FNCmdResolveImage2 {
        self.cmd_resolve_image2
    }
    ///Gets [`Self::cmd_set_event2`]. See [`FNCmdSetEvent2`] for more information.
    pub fn cmd_set_event2(&self) -> FNCmdSetEvent2 {
        self.cmd_set_event2
    }
    ///Gets [`Self::cmd_reset_event2`]. See [`FNCmdResetEvent2`] for more information.
    pub fn cmd_reset_event2(&self) -> FNCmdResetEvent2 {
        self.cmd_reset_event2
    }
    ///Gets [`Self::cmd_wait_events2`]. See [`FNCmdWaitEvents2`] for more information.
    pub fn cmd_wait_events2(&self) -> FNCmdWaitEvents2 {
        self.cmd_wait_events2
    }
    ///Gets [`Self::cmd_pipeline_barrier2`]. See [`FNCmdPipelineBarrier2`] for more information.
    pub fn cmd_pipeline_barrier2(&self) -> FNCmdPipelineBarrier2 {
        self.cmd_pipeline_barrier2
    }
    ///Gets [`Self::cmd_write_timestamp2`]. See [`FNCmdWriteTimestamp2`] for more information.
    pub fn cmd_write_timestamp2(&self) -> FNCmdWriteTimestamp2 {
        self.cmd_write_timestamp2
    }
    ///Gets [`Self::cmd_begin_rendering`]. See [`FNCmdBeginRendering`] for more information.
    pub fn cmd_begin_rendering(&self) -> FNCmdBeginRendering {
        self.cmd_begin_rendering
    }
    ///Gets [`Self::cmd_end_rendering`]. See [`FNCmdEndRendering`] for more information.
    pub fn cmd_end_rendering(&self) -> FNCmdEndRendering {
        self.cmd_end_rendering
    }
}
