use crate::{
    core::{
        MAX_DESCRIPTION_SIZE, MAX_EXTENSION_NAME_SIZE, MAX_MEMORY_HEAPS, MAX_MEMORY_TYPES,
        MAX_PHYSICAL_DEVICE_NAME_SIZE, UUID_SIZE,
    },
    extensions::{
        arm_rasterization_order_attachment_access::{
            PipelineColorBlendStateCreateFlagBits, PipelineDepthStencilStateCreateFlagBits,
        },
        ext_pipeline_creation_cache_control::PipelineCacheCreateFlagBits,
    },
    vulkan1_1::DeviceQueueCreateFlagBits,
};
#[cfg(feature = "bytemuck")]
use bytemuck::{Pod, Zeroable};
#[cfg(feature = "serde")]
use serde::{Deserialize, Serialize};
use std::{
    ffi::{c_void, CStr},
    marker::PhantomData,
    os::raw::c_char,
};
///[VK_LOD_CLAMP_NONE](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_LOD_CLAMP_NONE.html) - Maximum level of detail unclamped access sentinel
///# C Specifications
///[`LOD_CLAMP_NONE`] is a special constant value used for
///[`SamplerCreateInfo::max_lod`] to indicate that maximum LOD
///clamping should not be performed.
///```c
///#define VK_LOD_CLAMP_NONE                 1000.0F
///```
///# Related
/// - [`crate::vulkan1_0`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VK_LOD_CLAMP_NONE")]
pub const LOD_CLAMP_NONE: f32 = 1000.0;
///[VK_REMAINING_MIP_LEVELS](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_REMAINING_MIP_LEVELS.html) - Sentinel for all remaining mipmap levels
///# C Specifications
///[`REMAINING_MIP_LEVELS`] is a special constant value used for image
///views to indicate that all remaining mipmap levels in an image after the
///base level should be included in the view.
///```c
///#define VK_REMAINING_MIP_LEVELS           (~0U)
///```
///# Related
/// - [`crate::vulkan1_0`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VK_REMAINING_MIP_LEVELS")]
pub const REMAINING_MIP_LEVELS: u32 = !0;
///[VK_REMAINING_ARRAY_LAYERS](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_REMAINING_ARRAY_LAYERS.html) - Sentinel for all remaining array layers
///# C Specifications
///[`REMAINING_ARRAY_LAYERS`] is a special constant value used for image
///views to indicate that all remaining array layers in an image after the base
///layer should be included in the view.
///```c
///#define VK_REMAINING_ARRAY_LAYERS         (~0U)
///```
///# Related
/// - [`crate::vulkan1_0`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VK_REMAINING_ARRAY_LAYERS")]
pub const REMAINING_ARRAY_LAYERS: u32 = !0;
///[VK_WHOLE_SIZE](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_WHOLE_SIZE.html) - Sentinel value to use entire remaining array length
///# C Specifications
///[`WHOLE_SIZE`] is a special value indicating that the entire remaining
///length of a buffer following a given `offset` should be used.
///It  **can**  be specified for [`BufferMemoryBarrier::size`] and other
///structures.
///```c
///#define VK_WHOLE_SIZE                     (~0ULL)
///```
///# Related
/// - [`crate::vulkan1_0`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VK_WHOLE_SIZE")]
pub const WHOLE_SIZE: u64 = !0;
///[VK_ATTACHMENT_UNUSED](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_ATTACHMENT_UNUSED.html) - Unused attachment sentinel
///# C Specifications
///[`ATTACHMENT_UNUSED`] is a constant indicating that a render pass
///attachment is not used.
///```c
///#define VK_ATTACHMENT_UNUSED              (~0U)
///```
///# Related
/// - [`crate::vulkan1_0`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VK_ATTACHMENT_UNUSED")]
pub const ATTACHMENT_UNUSED: u32 = !0;
///[VK_TRUE](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_TRUE.html) - Boolean true value
///# C Specifications
///[`TRUE`] is a constant representing a [`Bool32`] **True**  value.
///```c
///#define VK_TRUE                           1U
///```
///# Related
/// - [`FALSE`]
/// - [`crate::vulkan1_0`]
/// - [`Bool32`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VK_TRUE")]
pub const TRUE: u32 = 1;
///[VK_FALSE](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_FALSE.html) - Boolean false value
///# C Specifications
///[`FALSE`] is a constant representing a [`Bool32`] **False**  value.
///```c
///#define VK_FALSE                          0U
///```
///# Related
/// - [`TRUE`]
/// - [`crate::vulkan1_0`]
/// - [`Bool32`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VK_FALSE")]
pub const FALSE: u32 = 0;
///[VK_QUEUE_FAMILY_IGNORED](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_QUEUE_FAMILY_IGNORED.html) - Ignored queue family index sentinel
///# C Specifications
///The special queue family index [`QUEUE_FAMILY_IGNORED`] indicates that
///a queue family parameter or member is ignored.
///```c
///#define VK_QUEUE_FAMILY_IGNORED           (~0U)
///```
///# Related
/// - [`crate::vulkan1_0`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VK_QUEUE_FAMILY_IGNORED")]
pub const QUEUE_FAMILY_IGNORED: u32 = !0;
///[VK_SUBPASS_EXTERNAL](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_SUBPASS_EXTERNAL.html) - Subpass index sentinel expanding synchronization scope outside a subpass
///# C Specifications
///[`SUBPASS_EXTERNAL`] is a special subpass index value expanding
///synchronization scope outside a subpass.
///It is described in more detail by [`SubpassDependency`].
///```c
///#define VK_SUBPASS_EXTERNAL               (~0U)
///```
///# Related
/// - [`crate::vulkan1_0`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VK_SUBPASS_EXTERNAL")]
pub const SUBPASS_EXTERNAL: u32 = !0;
///[VkSampleMask](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSampleMask.html) - Mask of sample coverage information
///# C Specifications
///The elements of the sample mask array are of type [`SampleMask`],
///each representing 32 bits of coverage information:
///```c
///// Provided by VK_VERSION_1_0
///typedef uint32_t VkSampleMask;
///```
///# Related
/// - [`crate::vulkan1_0`]
/// - [`PipelineMultisampleStateCreateInfo`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkSampleMask")]
pub type SampleMask = u32;
///[VkBool32](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBool32.html) - Vulkan boolean type
///# C Specifications
///[`Bool32`] represents boolean `True` and `False` values, since C does
///not have a sufficiently portable built-in boolean type:
///```c
///// Provided by VK_VERSION_1_0
///typedef uint32_t VkBool32;
///```
///# Related
/// - [`FALSE`]
/// - [`TRUE`]
/// - [`crate::vulkan1_0`]
/// - [`AccelerationStructureGeometryInstancesDataKHR`]
/// - [`CommandBufferInheritanceConditionalRenderingInfoEXT`]
/// - [`CommandBufferInheritanceInfo`]
/// - [`CommandBufferInheritanceViewportScissorInfoNV`]
/// - [`DedicatedAllocationBufferCreateInfoNV`]
/// - [`DedicatedAllocationImageCreateInfoNV`]
/// - [`DescriptorSetLayoutSupport`]
/// - [`DisplayNativeHdrSurfaceCapabilitiesAMD`]
/// - [`DisplayPresentInfoKHR`]
/// - [`DisplayPropertiesKHR`]
/// - [`FilterCubicImageViewImageFormatPropertiesEXT`]
/// - [`IndirectCommandsLayoutTokenNV`]
/// - [`MemoryDedicatedRequirements`]
/// - [`MultiviewPerViewAttributesInfoNVX`]
/// - [`PerformanceOverrideInfoINTEL`]
/// - [`PerformanceValueDataINTEL`]
/// - [`PhysicalDevice16BitStorageFeatures`]
/// - [`PhysicalDevice4444FormatsFeaturesEXT`]
/// - [`PhysicalDevice8BitStorageFeatures`]
/// - [`PhysicalDeviceAstcDecodeFeaturesEXT`]
/// - [`PhysicalDeviceAccelerationStructureFeaturesKHR`]
/// - [`PhysicalDeviceBlendOperationAdvancedFeaturesEXT`]
/// - [`PhysicalDeviceBlendOperationAdvancedPropertiesEXT`]
/// - [`PhysicalDeviceBorderColorSwizzleFeaturesEXT`]
/// - [`PhysicalDeviceBufferDeviceAddressFeatures`]
/// - [`PhysicalDeviceBufferDeviceAddressFeaturesEXT`]
/// - [`PhysicalDeviceCoherentMemoryFeaturesAMD`]
/// - [`PhysicalDeviceColorWriteEnableFeaturesEXT`]
/// - [`PhysicalDeviceComputeShaderDerivativesFeaturesNV`]
/// - [`PhysicalDeviceConditionalRenderingFeaturesEXT`]
/// - [`PhysicalDeviceConservativeRasterizationPropertiesEXT`]
/// - [`PhysicalDeviceCooperativeMatrixFeaturesNV`]
/// - [`PhysicalDeviceCornerSampledImageFeaturesNV`]
/// - [`PhysicalDeviceCoverageReductionModeFeaturesNV`]
/// - [`PhysicalDeviceCustomBorderColorFeaturesEXT`]
/// - [`PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV`]
/// - [`PhysicalDeviceDepthClipControlFeaturesEXT`]
/// - [`PhysicalDeviceDepthClipEnableFeaturesEXT`]
/// - [`PhysicalDeviceDepthStencilResolveProperties`]
/// - [`PhysicalDeviceDescriptorIndexingFeatures`]
/// - [`PhysicalDeviceDescriptorIndexingProperties`]
/// - [`PhysicalDeviceDescriptorSetHostMappingFeaturesVALVE`]
/// - [`PhysicalDeviceDeviceGeneratedCommandsFeaturesNV`]
/// - [`PhysicalDeviceDeviceMemoryReportFeaturesEXT`]
/// - [`PhysicalDeviceDiagnosticsConfigFeaturesNV`]
/// - [`PhysicalDeviceDrmPropertiesEXT`]
/// - [`PhysicalDeviceDynamicRenderingFeatures`]
/// - [`PhysicalDeviceExclusiveScissorFeaturesNV`]
/// - [`PhysicalDeviceExtendedDynamicState2FeaturesEXT`]
/// - [`PhysicalDeviceExtendedDynamicStateFeaturesEXT`]
/// - [`PhysicalDeviceExternalMemoryRdmaFeaturesNV`]
/// - [`PhysicalDeviceFeatures`]
/// - [`PhysicalDeviceFloatControlsProperties`]
/// - [`PhysicalDeviceFragmentDensityMap2FeaturesEXT`]
/// - [`PhysicalDeviceFragmentDensityMap2PropertiesEXT`]
/// - [`PhysicalDeviceFragmentDensityMapFeaturesEXT`]
/// - [`PhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM`]
/// - [`PhysicalDeviceFragmentDensityMapPropertiesEXT`]
/// - [`PhysicalDeviceFragmentShaderBarycentricFeaturesNV`]
/// - [`PhysicalDeviceFragmentShaderInterlockFeaturesEXT`]
/// - [`PhysicalDeviceFragmentShadingRateEnumsFeaturesNV`]
/// - [`PhysicalDeviceFragmentShadingRateFeaturesKHR`]
/// - [`PhysicalDeviceFragmentShadingRatePropertiesKHR`]
/// - [`PhysicalDeviceGlobalPriorityQueryFeaturesKHR`]
/// - [`PhysicalDeviceGroupProperties`]
/// - [`PhysicalDeviceHostQueryResetFeatures`]
/// - [`PhysicalDeviceIdProperties`]
/// - [`PhysicalDeviceImageRobustnessFeatures`]
/// - [`PhysicalDeviceImageViewMinLodFeaturesEXT`]
/// - [`PhysicalDeviceImagelessFramebufferFeatures`]
/// - [`PhysicalDeviceIndexTypeUint8FeaturesEXT`]
/// - [`PhysicalDeviceInheritedViewportScissorFeaturesNV`]
/// - [`PhysicalDeviceInlineUniformBlockFeatures`]
/// - [`PhysicalDeviceInvocationMaskFeaturesHUAWEI`]
/// - [`PhysicalDeviceLimits`]
/// - [`PhysicalDeviceLineRasterizationFeaturesEXT`]
/// - [`PhysicalDeviceLinearColorAttachmentFeaturesNV`]
/// - [`PhysicalDeviceMaintenance4Features`]
/// - [`PhysicalDeviceMemoryPriorityFeaturesEXT`]
/// - [`PhysicalDeviceMeshShaderFeaturesNV`]
/// - [`PhysicalDeviceMultiDrawFeaturesEXT`]
/// - [`PhysicalDeviceMultiviewFeatures`]
/// - [`PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX`]
/// - [`PhysicalDeviceMutableDescriptorTypeFeaturesVALVE`]
/// - [`PhysicalDevicePageableDeviceLocalMemoryFeaturesEXT`]
/// - [`PhysicalDevicePerformanceQueryFeaturesKHR`]
/// - [`PhysicalDevicePerformanceQueryPropertiesKHR`]
/// - [`PhysicalDevicePipelineCreationCacheControlFeatures`]
/// - [`PhysicalDevicePipelineExecutablePropertiesFeaturesKHR`]
/// - [`PhysicalDevicePortabilitySubsetFeaturesKHR`]
/// - [`PhysicalDevicePresentIdFeaturesKHR`]
/// - [`PhysicalDevicePresentWaitFeaturesKHR`]
/// - [`PhysicalDevicePrimitiveTopologyListRestartFeaturesEXT`]
/// - [`PhysicalDevicePrivateDataFeatures`]
/// - [`PhysicalDeviceProtectedMemoryFeatures`]
/// - [`PhysicalDeviceProtectedMemoryProperties`]
/// - [`PhysicalDeviceProvokingVertexFeaturesEXT`]
/// - [`PhysicalDeviceProvokingVertexPropertiesEXT`]
/// - [`PhysicalDeviceRgba10X6FormatsFeaturesEXT`]
/// - [`PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesARM`]
/// - [`PhysicalDeviceRayQueryFeaturesKHR`]
/// - [`PhysicalDeviceRayTracingMotionBlurFeaturesNV`]
/// - [`PhysicalDeviceRayTracingPipelineFeaturesKHR`]
/// - [`PhysicalDeviceRepresentativeFragmentTestFeaturesNV`]
/// - [`PhysicalDeviceRobustness2FeaturesEXT`]
/// - [`PhysicalDeviceSampleLocationsPropertiesEXT`]
/// - [`PhysicalDeviceSamplerFilterMinmaxProperties`]
/// - [`PhysicalDeviceSamplerYcbcrConversionFeatures`]
/// - [`PhysicalDeviceScalarBlockLayoutFeatures`]
/// - [`PhysicalDeviceSeparateDepthStencilLayoutsFeatures`]
/// - [`PhysicalDeviceShaderAtomicFloat2FeaturesEXT`]
/// - [`PhysicalDeviceShaderAtomicFloatFeaturesEXT`]
/// - [`PhysicalDeviceShaderAtomicInt64Features`]
/// - [`PhysicalDeviceShaderClockFeaturesKHR`]
/// - [`PhysicalDeviceShaderDemoteToHelperInvocationFeatures`]
/// - [`PhysicalDeviceShaderDrawParametersFeatures`]
/// - [`PhysicalDeviceShaderFloat16Int8Features`]
/// - [`PhysicalDeviceShaderImageAtomicInt64FeaturesEXT`]
/// - [`PhysicalDeviceShaderImageFootprintFeaturesNV`]
/// - [`PhysicalDeviceShaderIntegerDotProductFeatures`]
/// - [`PhysicalDeviceShaderIntegerDotProductProperties`]
/// - [`PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL`]
/// - [`PhysicalDeviceShaderSmBuiltinsFeaturesNV`]
/// - [`PhysicalDeviceShaderSubgroupExtendedTypesFeatures`]
/// - [`PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR`]
/// - [`PhysicalDeviceShaderTerminateInvocationFeatures`]
/// - [`PhysicalDeviceShadingRateImageFeaturesNV`]
/// - [`PhysicalDeviceSparseProperties`]
/// - [`PhysicalDeviceSubgroupProperties`]
/// - [`PhysicalDeviceSubgroupSizeControlFeatures`]
/// - [`PhysicalDeviceSubpassShadingFeaturesHUAWEI`]
/// - [`PhysicalDeviceSynchronization2Features`]
/// - [`PhysicalDeviceTexelBufferAlignmentFeaturesEXT`]
/// - [`PhysicalDeviceTexelBufferAlignmentProperties`]
/// - [`PhysicalDeviceTextureCompressionAstchdrFeatures`]
/// - [`PhysicalDeviceTimelineSemaphoreFeatures`]
/// - [`PhysicalDeviceTransformFeedbackFeaturesEXT`]
/// - [`PhysicalDeviceTransformFeedbackPropertiesEXT`]
/// - [`PhysicalDeviceUniformBufferStandardLayoutFeatures`]
/// - [`PhysicalDeviceVariablePointersFeatures`]
/// - [`PhysicalDeviceVertexAttributeDivisorFeaturesEXT`]
/// - [`PhysicalDeviceVertexInputDynamicStateFeaturesEXT`]
/// - [`PhysicalDeviceVulkan11Features`]
/// - [`PhysicalDeviceVulkan11Properties`]
/// - [`PhysicalDeviceVulkan12Features`]
/// - [`PhysicalDeviceVulkan12Properties`]
/// - [`PhysicalDeviceVulkan13Features`]
/// - [`PhysicalDeviceVulkan13Properties`]
/// - [`PhysicalDeviceVulkanMemoryModelFeatures`]
/// - [`PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR`]
/// - [`PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT`]
/// - [`PhysicalDeviceYcbcrImageArraysFeaturesEXT`]
/// - [`PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures`]
/// - [`PipelineColorBlendAdvancedStateCreateInfoEXT`]
/// - [`PipelineColorBlendAttachmentState`]
/// - [`PipelineColorBlendStateCreateInfo`]
/// - [`PipelineColorWriteCreateInfoEXT`]
/// - [`PipelineCoverageModulationStateCreateInfoNV`]
/// - [`PipelineCoverageToColorStateCreateInfoNV`]
/// - [`PipelineDepthStencilStateCreateInfo`]
/// - [`PipelineExecutableInternalRepresentationKHR`]
/// - [`PipelineExecutableStatisticValueKHR`]
/// - [`PipelineInputAssemblyStateCreateInfo`]
/// - [`PipelineMultisampleStateCreateInfo`]
/// - [`PipelineRasterizationDepthClipStateCreateInfoEXT`]
/// - [`PipelineRasterizationLineStateCreateInfoEXT`]
/// - [`PipelineRasterizationStateCreateInfo`]
/// - [`PipelineRepresentativeFragmentTestStateCreateInfoNV`]
/// - [`PipelineSampleLocationsStateCreateInfoEXT`]
/// - [`PipelineViewportDepthClipControlCreateInfoEXT`]
/// - [`PipelineViewportShadingRateImageStateCreateInfoNV`]
/// - [`PipelineViewportWScalingStateCreateInfoNV`]
/// - [`ProtectedSubmitInfo`]
/// - [`QueueFamilyQueryResultStatusProperties2KHR`]
/// - [`SamplerBorderColorComponentMappingCreateInfoEXT`]
/// - [`SamplerCreateInfo`]
/// - [`SamplerYcbcrConversionCreateInfo`]
/// - [`SurfaceCapabilitiesFullScreenExclusiveEXT`]
/// - [`SurfaceProtectedCapabilitiesKHR`]
/// - [`SwapchainCreateInfoKHR`]
/// - [`SwapchainDisplayNativeHdrCreateInfoAMD`]
/// - [`TextureLodGatherFormatPropertiesAMD`]
/// - [`VideoEncodeH264CapabilitiesEXT`]
/// - [`VideoEncodeH264EmitPictureParametersEXT`]
/// - [`VideoEncodeH264RateControlLayerInfoEXT`]
/// - [`VideoEncodeH265EmitPictureParametersEXT`]
/// - [`VideoEncodeH265RateControlLayerInfoEXT`]
/// - [`CmdBuildAccelerationStructureNV`]
/// - [`CmdExecuteGeneratedCommandsNV`]
/// - [`CmdSetColorWriteEnableEXT`]
/// - [`CmdSetDepthBiasEnable`]
/// - [`CmdSetDepthBiasEnableEXT`]
/// - [`CmdSetDepthBoundsTestEnable`]
/// - [`CmdSetDepthBoundsTestEnableEXT`]
/// - [`CmdSetDepthTestEnable`]
/// - [`CmdSetDepthTestEnableEXT`]
/// - [`CmdSetDepthWriteEnable`]
/// - [`CmdSetDepthWriteEnableEXT`]
/// - [`CmdSetPrimitiveRestartEnable`]
/// - [`CmdSetPrimitiveRestartEnableEXT`]
/// - [`CmdSetRasterizerDiscardEnable`]
/// - [`CmdSetRasterizerDiscardEnableEXT`]
/// - [`CmdSetStencilTestEnable`]
/// - [`CmdSetStencilTestEnableEXT`]
/// - [`GetPhysicalDeviceSurfaceSupportKHR`]
/// - [`SetLocalDimmingAMD`]
/// - [`WaitForFences`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkBool32")]
pub type Bool32 = u32;
///[VkFlags](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFlags.html) - Vulkan bitmasks
///# C Specifications
///A collection of flags is represented by a bitmask using the type
///[`Flags`]:
///```c
///// Provided by VK_VERSION_1_0
///typedef uint32_t VkFlags;
///```
///# Related
/// - [`crate::vulkan1_0`]
/// - [`ColorComponentFlags`]
/// - [`Flags64`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkFlags")]
pub type Flags = u32;
///[VkDeviceSize](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceSize.html) - Vulkan device memory size and offsets
///# C Specifications
///[`DeviceSize`] represents device memory size and offset values:
///```c
///// Provided by VK_VERSION_1_0
///typedef uint64_t VkDeviceSize;
///```
///# Related
/// - [`crate::vulkan1_0`]
/// - [`AccelerationStructureBuildSizesInfoKHR`]
/// - [`AccelerationStructureCreateInfoKHR`]
/// - [`AccelerationStructureCreateInfoNV`]
/// - [`AccelerationStructureGeometryAabbsDataKHR`]
/// - [`AccelerationStructureGeometryTrianglesDataKHR`]
/// - [`AndroidHardwareBufferPropertiesANDROID`]
/// - [`BindAccelerationStructureMemoryInfoNV`]
/// - [`BindBufferMemoryInfo`]
/// - [`BindImageMemoryInfo`]
/// - [`BufferCopy`]
/// - [`BufferCopy2`]
/// - [`BufferCreateInfo`]
/// - [`BufferImageCopy`]
/// - [`BufferImageCopy2`]
/// - [`BufferMemoryBarrier`]
/// - [`BufferMemoryBarrier2`]
/// - [`BufferViewCreateInfo`]
/// - [`ConditionalRenderingBeginInfoEXT`]
/// - [`DescriptorBufferInfo`]
/// - [`DeviceMemoryReportCallbackDataEXT`]
/// - [`GeneratedCommandsInfoNV`]
/// - [`GeometryAabbNV`]
/// - [`GeometryTrianglesNV`]
/// - [`ImageFormatProperties`]
/// - [`ImageViewAddressPropertiesNVX`]
/// - [`IndirectCommandsStreamNV`]
/// - [`MappedMemoryRange`]
/// - [`MemoryAllocateInfo`]
/// - [`MemoryHeap`]
/// - [`MemoryRequirements`]
/// - [`PhysicalDeviceExternalMemoryHostPropertiesEXT`]
/// - [`PhysicalDeviceLimits`]
/// - [`PhysicalDeviceMaintenance3Properties`]
/// - [`PhysicalDeviceMaintenance4Properties`]
/// - [`PhysicalDeviceMemoryBudgetPropertiesEXT`]
/// - [`PhysicalDeviceRobustness2PropertiesEXT`]
/// - [`PhysicalDeviceTexelBufferAlignmentProperties`]
/// - [`PhysicalDeviceTransformFeedbackPropertiesEXT`]
/// - [`PhysicalDeviceVulkan11Properties`]
/// - [`PhysicalDeviceVulkan13Properties`]
/// - [`SparseImageMemoryBind`]
/// - [`SparseImageMemoryRequirements`]
/// - [`SparseMemoryBind`]
/// - [`StridedDeviceAddressRegionKHR`]
/// - [`SubresourceLayout`]
/// - [`VideoBindMemoryKHR`]
/// - [`VideoCapabilitiesKHR`]
/// - [`VideoDecodeInfoKHR`]
/// - [`VideoEncodeInfoKHR`]
/// - [`BindBufferMemory`]
/// - [`BindImageMemory`]
/// - [`CmdBeginTransformFeedbackEXT`]
/// - [`CmdBindIndexBuffer`]
/// - [`CmdBindTransformFeedbackBuffersEXT`]
/// - [`CmdBindVertexBuffers`]
/// - [`CmdBindVertexBuffers2`]
/// - [`CmdBindVertexBuffers2EXT`]
/// - [`CmdBuildAccelerationStructureNV`]
/// - [`CmdCopyQueryPoolResults`]
/// - [`CmdDispatchIndirect`]
/// - [`CmdDrawIndexedIndirect`]
/// - [`CmdDrawIndexedIndirectCount`]
/// - [`CmdDrawIndexedIndirectCountAMD`]
/// - [`CmdDrawIndexedIndirectCountKHR`]
/// - [`CmdDrawIndirect`]
/// - [`CmdDrawIndirectByteCountEXT`]
/// - [`CmdDrawIndirectCount`]
/// - [`CmdDrawIndirectCountAMD`]
/// - [`CmdDrawIndirectCountKHR`]
/// - [`CmdDrawMeshTasksIndirectCountNV`]
/// - [`CmdDrawMeshTasksIndirectNV`]
/// - [`CmdEndTransformFeedbackEXT`]
/// - [`CmdFillBuffer`]
/// - [`CmdTraceRaysNV`]
/// - [`CmdUpdateBuffer`]
/// - [`CmdWriteBufferMarker2AMD`]
/// - [`CmdWriteBufferMarkerAMD`]
/// - [`GetDeviceMemoryCommitment`]
/// - [`GetQueryPoolResults`]
/// - [`MapMemory`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkDeviceSize")]
pub type DeviceSize = u64;
///[VkDeviceAddress](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceAddress.html) - Vulkan device address type
///# C Specifications
///[`DeviceAddress`] represents device buffer address values:
///```c
///// Provided by VK_VERSION_1_0
///typedef uint64_t VkDeviceAddress;
///```
///# Related
/// - [`crate::vulkan1_0`]
/// - [`AccelerationStructureCreateInfoKHR`]
/// - [`BindIndexBufferIndirectCommandNV`]
/// - [`BindVertexBufferIndirectCommandNV`]
/// - [`BufferDeviceAddressCreateInfoEXT`]
/// - [`DeviceOrHostAddressConstKHR`]
/// - [`DeviceOrHostAddressKHR`]
/// - [`ImageViewAddressPropertiesNVX`]
/// - [`StridedDeviceAddressRegionKHR`]
/// - [`CmdBuildAccelerationStructuresIndirectKHR`]
/// - [`CmdTraceRaysIndirectKHR`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkDeviceAddress")]
pub type DeviceAddress = u64;
///[VkImageLayout](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageLayout.html) - Layout of image and image subresources
///# C Specifications
///The set of image layouts consists of:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkImageLayout {
///    VK_IMAGE_LAYOUT_UNDEFINED = 0,
///    VK_IMAGE_LAYOUT_GENERAL = 1,
///    VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL = 2,
///    VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL = 3,
///    VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL = 4,
///    VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL = 5,
///    VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL = 6,
///    VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL = 7,
///    VK_IMAGE_LAYOUT_PREINITIALIZED = 8,
///  // Provided by VK_VERSION_1_1
///    VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL = 1000117000,
///  // Provided by VK_VERSION_1_1
///    VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL = 1000117001,
///  // Provided by VK_VERSION_1_2
///    VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL = 1000241000,
///  // Provided by VK_VERSION_1_2
///    VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL = 1000241001,
///  // Provided by VK_VERSION_1_2
///    VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL = 1000241002,
///  // Provided by VK_VERSION_1_2
///    VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL = 1000241003,
///  // Provided by VK_VERSION_1_3
///    VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL = 1000314000,
///  // Provided by VK_VERSION_1_3
///    VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL = 1000314001,
///  // Provided by VK_KHR_swapchain
///    VK_IMAGE_LAYOUT_PRESENT_SRC_KHR = 1000001002,
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_KHR_video_decode_queue
///    VK_IMAGE_LAYOUT_VIDEO_DECODE_DST_KHR = 1000024000,
///#endif
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_KHR_video_decode_queue
///    VK_IMAGE_LAYOUT_VIDEO_DECODE_SRC_KHR = 1000024001,
///#endif
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_KHR_video_decode_queue
///    VK_IMAGE_LAYOUT_VIDEO_DECODE_DPB_KHR = 1000024002,
///#endif
///  // Provided by VK_KHR_shared_presentable_image
///    VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR = 1000111000,
///  // Provided by VK_EXT_fragment_density_map
///    VK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT = 1000218000,
///  // Provided by VK_KHR_fragment_shading_rate
///    VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR = 1000164003,
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_KHR_video_encode_queue
///    VK_IMAGE_LAYOUT_VIDEO_ENCODE_DST_KHR = 1000299000,
///#endif
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_KHR_video_encode_queue
///    VK_IMAGE_LAYOUT_VIDEO_ENCODE_SRC_KHR = 1000299001,
///#endif
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_KHR_video_encode_queue
///    VK_IMAGE_LAYOUT_VIDEO_ENCODE_DPB_KHR = 1000299002,
///#endif
///  // Provided by VK_KHR_maintenance2
///    VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL_KHR =
/// VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL,
///  // Provided by VK_KHR_maintenance2
///    VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL_KHR =
/// VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL,
///  // Provided by VK_NV_shading_rate_image
///    VK_IMAGE_LAYOUT_SHADING_RATE_OPTIMAL_NV =
/// VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR,
///  // Provided by VK_KHR_separate_depth_stencil_layouts
///    VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL_KHR = VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL,
///  // Provided by VK_KHR_separate_depth_stencil_layouts
///    VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL_KHR = VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL,
///  // Provided by VK_KHR_separate_depth_stencil_layouts
///    VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL_KHR = VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL,
///  // Provided by VK_KHR_separate_depth_stencil_layouts
///    VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL_KHR = VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL,
///  // Provided by VK_KHR_synchronization2
///    VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL_KHR = VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL,
///  // Provided by VK_KHR_synchronization2
///    VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL_KHR = VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL,
///} VkImageLayout;
///```
///# Description
///The type(s) of device access supported by each layout are:
/// - [`Undefined`] specifies that the layout is unknown. Image memory  **cannot**  be transitioned
///   into this layout. This layout  **can**  be used as the `initialLayout` member of
///   [`ImageCreateInfo`]. This layout  **can**  be used in place of the current image layout in a
///   layout transition, but doing so will cause the contents of the image’s memory to be undefined.
/// - [`Preinitialized`] specifies that an image’s memory is in a defined layout and  **can**  be populated by data, but that it has not yet been initialized by the driver. Image memory  **cannot**  be transitioned into this layout. This layout  **can**  be used as the `initialLayout` member of [`ImageCreateInfo`]. This layout is intended to be used as the initial layout for an image whose contents are written by the host, and hence the data  **can**  be written to memory immediately, without first executing a layout transition. Currently, [`Preinitialized`] is only useful with [linear](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#glossary-linear-resource) images because there is not a standard layout defined for `VK_IMAGE_TILING_OPTIMAL` images.
/// - [`General`] supports all types of device access.
/// - [`AttachmentOptimal`] specifies a layout that  **must**  only be used with attachment accesses
///   in the graphics pipeline.
/// - [`ReadOnlyOptimal`] specifies a layout allowing read only access as an attachment, or in
///   shaders as a sampled image, combined image/sampler, or input attachment.
/// - [`ColorAttachmentOptimal`] **must**  only be used as a color or resolve attachment in a
///   [`Framebuffer`]. This layout is valid only for image subresources of images created with the
///   `VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT` usage bit enabled.
/// - [`DepthStencilAttachmentOptimal`] specifies a layout for both the depth and stencil aspects of
///   a depth/stencil format image allowing read and write access as a depth/stencil attachment. It
///   is equivalent to [`DepthAttachmentOptimal`] and [`StencilAttachmentOptimal`].
/// - [`DepthStencilReadOnlyOptimal`] specifies a layout for both the depth and stencil aspects of a
///   depth/stencil format image allowing read only access as a depth/stencil attachment or in
///   shaders as a sampled image, combined image/sampler, or input attachment. It is equivalent to
///   [`DepthReadOnlyOptimal`] and [`StencilReadOnlyOptimal`].
/// - [`DepthReadOnlyStencilAttachmentOptimal`] specifies a layout for depth/stencil format images
///   allowing read and write access to the stencil aspect as a stencil attachment, and read only
///   access to the depth aspect as a depth attachment or in shaders as a sampled image, combined
///   image/sampler, or input attachment. It is equivalent to [`DepthReadOnlyOptimal`] and
///   [`StencilAttachmentOptimal`].
/// - [`DepthAttachmentStencilReadOnlyOptimal`] specifies a layout for depth/stencil format images
///   allowing read and write access to the depth aspect as a depth attachment, and read only access
///   to the stencil aspect as a stencil attachment or in shaders as a sampled image, combined
///   image/sampler, or input attachment. It is equivalent to [`DepthAttachmentOptimal`] and
///   [`StencilReadOnlyOptimal`].
/// - [`DepthAttachmentOptimal`] specifies a layout for the depth aspect of a depth/stencil format
///   image allowing read and write access as a depth attachment.
/// - [`DepthReadOnlyOptimal`] specifies a layout for the depth aspect of a depth/stencil format
///   image allowing read-only access as a depth attachment or in shaders as a sampled image,
///   combined image/sampler, or input attachment.
/// - [`StencilAttachmentOptimal`] specifies a layout for the stencil aspect of a depth/stencil
///   format image allowing read and write access as a stencil attachment.
/// - [`StencilReadOnlyOptimal`] specifies a layout for the stencil aspect of a depth/stencil format
///   image allowing read-only access as a stencil attachment or in shaders as a sampled image,
///   combined image/sampler, or input attachment.
/// - [`ShaderReadOnlyOptimal`] specifies a layout allowing read-only access in a shader as a
///   sampled image, combined image/sampler, or input attachment. This layout is valid only for
///   image subresources of images created with the `VK_IMAGE_USAGE_SAMPLED_BIT` or
///   `VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT` usage bits enabled.
/// - [`TransferSrcOptimal`] **must**  only be used as a source image of a transfer command (see the
///   definition of [`VK_PIPELINE_STAGE_TRANSFER_BIT`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-pipeline-stages-transfer)).
///   This layout is valid only for image subresources of images created with the
///   `VK_IMAGE_USAGE_TRANSFER_SRC_BIT` usage bit enabled.
/// - [`TransferDstOptimal`] **must**  only be used as a destination image of a transfer command.
///   This layout is valid only for image subresources of images created with the
///   `VK_IMAGE_USAGE_TRANSFER_DST_BIT` usage bit enabled.
/// - [`PresentSrcKhr`] **must**  only be used for presenting a presentable image for display. A
///   swapchain’s image  **must**  be transitioned to this layout before calling
///   [`QueuePresentKHR`], and  **must**  be transitioned away from this layout after calling
///   [`AcquireNextImageKHR`].
/// - [`SharedPresentKhr`] is valid only for shared presentable images, and  **must**  be used for
///   any usage the image supports.
/// - [`FragmentShadingRateAttachmentOptimalKhr`] **must**      only be used as a     [fragment shading rate     attachment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#primsrast-fragment-shading-rate-attachment) or     [shading rate image](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#primsrast-shading-rate-image).     This layout is valid only for image subresources of images created with     the `VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR` usage     bit enabled.
/// - [`FragmentDensityMapOptimalExt`] **must**  only be used as a fragment density map attachment
///   in a [`RenderPass`]. This layout is valid only for image subresources of images created with
///   the `VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT` usage bit enabled.
/// - [`VideoDecodeDstKhr`] **must**  only be used as a decode output image of a [video decode operation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-decode-operations).
///   This layout is valid only for image subresources of images created with the
///   `VK_IMAGE_USAGE_VIDEO_DECODE_DST_BIT_KHR` usage bit enabled.
/// - [`VideoDecodeSrcKhr`] is reserved for future use.
/// - [`VideoDecodeDpbKhr`] **must**  only be used as a decode source or destination image of a [video decode operation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-decode-operations). This layout is valid only for image subresources of images created with the `VK_IMAGE_USAGE_VIDEO_DECODE_DPB_BIT_KHR` usage bit enabled.
/// - [`VideoEncodeDstKhr`] is reserved for future use.
/// - [`VideoEncodeSrcKhr`] **must**  only be used as a encode source image of a [video encode operation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-encode-operations).
///   This layout is valid only for image subresources of images created with the
///   `VK_IMAGE_USAGE_VIDEO_ENCODE_SRC_BIT_KHR` usage bit enabled.
/// - [`VideoEncodeDpbKhr`] **must**  only be used as a encode source or destination image of a [video encode operation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-encode-operations). This layout is valid only for image subresources of images created with the `VK_IMAGE_USAGE_VIDEO_ENCODE_DPB_BIT_KHR` usage bit enabled.
///The layout of each image subresource is not a state of the image subresource
///itself, but is rather a property of how the data in memory is organized, and
///thus for each mechanism of accessing an image in the API the application
/// **must**  specify a parameter or structure member that indicates which image
///layout the image subresource(s) are considered to be in when the image will
///be accessed.
///For transfer commands, this is a parameter to the command (see [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#clears](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#clears)
///and [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#copies](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#copies)).
///For use as a framebuffer attachment, this is a member in the substructures
///of the [`RenderPassCreateInfo`] (see [Render Pass](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass)).
///For use in a descriptor set, this is a member in the
///[`DescriptorImageInfo`] structure (see [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-updates](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-updates)).
///# Related
/// - [`crate::vulkan1_0`]
/// - [`AttachmentDescription`]
/// - [`AttachmentDescription2`]
/// - [`AttachmentDescriptionStencilLayout`]
/// - [`AttachmentReference`]
/// - [`AttachmentReference2`]
/// - [`AttachmentReferenceStencilLayout`]
/// - [`BlitImageInfo2`]
/// - [`CopyBufferToImageInfo2`]
/// - [`CopyImageInfo2`]
/// - [`CopyImageToBufferInfo2`]
/// - [`DescriptorImageInfo`]
/// - [`ImageCreateInfo`]
/// - [`ImageMemoryBarrier`]
/// - [`ImageMemoryBarrier2`]
/// - [`RenderingAttachmentInfo`]
/// - [`RenderingFragmentDensityMapAttachmentInfoEXT`]
/// - [`RenderingFragmentShadingRateAttachmentInfoKHR`]
/// - [`ResolveImageInfo2`]
/// - [`CmdBindInvocationMaskHUAWEI`]
/// - [`CmdBindShadingRateImageNV`]
/// - [`CmdBlitImage`]
/// - [`CmdClearColorImage`]
/// - [`CmdClearDepthStencilImage`]
/// - [`CmdCopyBufferToImage`]
/// - [`CmdCopyImage`]
/// - [`CmdCopyImageToBuffer`]
/// - [`CmdResolveImage`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkImageLayout")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
#[repr(i32)]
pub enum ImageLayout {
    ///[`Undefined`] specifies that the layout is unknown.
    ///Image memory  **cannot**  be transitioned into this layout.
    ///This layout  **can**  be used as the `initialLayout` member of
    ///[`ImageCreateInfo`].
    ///This layout  **can**  be used in place of the current image layout in a
    ///layout transition, but doing so will cause the contents of the image’s
    ///memory to be undefined.
    Undefined = 0,
    ///[`General`] supports all types of device access.
    General = 1,
    ///[`ColorAttachmentOptimal`] **must**  only be used as a
    ///color or resolve attachment in a [`Framebuffer`].
    ///This layout is valid only for image subresources of images created with
    ///the `VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT` usage bit enabled.
    ColorAttachmentOptimal = 2,
    ///[`DepthStencilAttachmentOptimal`] specifies a
    ///layout for both the depth and stencil aspects of a depth/stencil format
    ///image allowing read and write access as a depth/stencil attachment.
    ///It is equivalent to [`DepthAttachmentOptimal`] and
    ///[`StencilAttachmentOptimal`].
    DepthStencilAttachmentOptimal = 3,
    ///[`DepthStencilReadOnlyOptimal`] specifies a layout
    ///for both the depth and stencil aspects of a depth/stencil format image
    ///allowing read only access as a depth/stencil attachment or in shaders as
    ///a sampled image, combined image/sampler, or input attachment.
    ///It is equivalent to [`DepthReadOnlyOptimal`] and
    ///[`StencilReadOnlyOptimal`].
    DepthStencilReadOnlyOptimal = 4,
    ///[`ShaderReadOnlyOptimal`] specifies a layout
    ///allowing read-only access in a shader as a sampled image, combined
    ///image/sampler, or input attachment.
    ///This layout is valid only for image subresources of images created with
    ///the `VK_IMAGE_USAGE_SAMPLED_BIT` or
    ///`VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT` usage bits enabled.
    ShaderReadOnlyOptimal = 5,
    ///[`TransferSrcOptimal`] **must**  only be used as a
    ///source image of a transfer command (see the definition of
    ///[`VK_PIPELINE_STAGE_TRANSFER_BIT`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-pipeline-stages-transfer)).
    ///This layout is valid only for image subresources of images created with
    ///the `VK_IMAGE_USAGE_TRANSFER_SRC_BIT` usage bit enabled.
    TransferSrcOptimal = 6,
    ///[`TransferDstOptimal`] **must**  only be used as a
    ///destination image of a transfer command.
    ///This layout is valid only for image subresources of images created with
    ///the `VK_IMAGE_USAGE_TRANSFER_DST_BIT` usage bit enabled.
    TransferDstOptimal = 7,
    ///[`Preinitialized`] specifies that an image’s memory is
    ///in a defined layout and  **can**  be populated by data, but that it has not
    ///yet been initialized by the driver.
    ///Image memory  **cannot**  be transitioned into this layout.
    ///This layout  **can**  be used as the `initialLayout` member of
    ///[`ImageCreateInfo`].
    ///This layout is intended to be used as the initial layout for an image
    ///whose contents are written by the host, and hence the data  **can**  be
    ///written to memory immediately, without first executing a layout
    ///transition.
    ///Currently, [`Preinitialized`] is only useful with
    ///[linear](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#glossary-linear-resource) images because there is not a
    ///standard layout defined for `VK_IMAGE_TILING_OPTIMAL` images.
    Preinitialized = 8,
    ///[`DepthReadOnlyStencilAttachmentOptimal`]
    ///specifies a layout for depth/stencil format images allowing read and
    ///write access to the stencil aspect as a stencil attachment, and read
    ///only access to the depth aspect as a depth attachment or in shaders as a
    ///sampled image, combined image/sampler, or input attachment.
    ///It is equivalent to [`DepthReadOnlyOptimal`] and
    ///[`StencilAttachmentOptimal`].
    ///
    ///Provided by [`crate::vulkan1_1`]
    DepthReadOnlyStencilAttachmentOptimal = 1000117000,
    ///[`DepthAttachmentStencilReadOnlyOptimal`]
    ///specifies a layout for depth/stencil format images allowing read and
    ///write access to the depth aspect as a depth attachment, and read only
    ///access to the stencil aspect as a stencil attachment or in shaders as a
    ///sampled image, combined image/sampler, or input attachment.
    ///It is equivalent to [`DepthAttachmentOptimal`] and
    ///[`StencilReadOnlyOptimal`].
    ///
    ///Provided by [`crate::vulkan1_1`]
    DepthAttachmentStencilReadOnlyOptimal = 1000117001,
    ///[`DepthAttachmentOptimal`] specifies a layout for
    ///the depth aspect of a depth/stencil format image allowing read and write
    ///access as a depth attachment.
    ///
    ///Provided by [`crate::vulkan1_2`]
    DepthAttachmentOptimal = 1000241000,
    ///[`DepthReadOnlyOptimal`] specifies a layout for the
    ///depth aspect of a depth/stencil format image allowing read-only access
    ///as a depth attachment or in shaders as a sampled image, combined
    ///image/sampler, or input attachment.
    ///
    ///Provided by [`crate::vulkan1_2`]
    DepthReadOnlyOptimal = 1000241001,
    ///[`StencilAttachmentOptimal`] specifies a layout for
    ///the stencil aspect of a depth/stencil format image allowing read and
    ///write access as a stencil attachment.
    ///
    ///Provided by [`crate::vulkan1_2`]
    StencilAttachmentOptimal = 1000241002,
    ///[`StencilReadOnlyOptimal`] specifies a layout for
    ///the stencil aspect of a depth/stencil format image allowing read-only
    ///access as a stencil attachment or in shaders as a sampled image,
    ///combined image/sampler, or input attachment.
    ///
    ///Provided by [`crate::vulkan1_2`]
    StencilReadOnlyOptimal = 1000241003,
    ///[`ReadOnlyOptimal`] specifies a layout allowing read
    ///only access as an attachment, or in shaders as a sampled image, combined
    ///image/sampler, or input attachment.
    ///
    ///Provided by [`crate::vulkan1_3`]
    ReadOnlyOptimal = 1000314000,
    ///[`AttachmentOptimal`] specifies a layout that  **must**
    ///only be used with attachment accesses in the graphics pipeline.
    ///
    ///Provided by [`crate::vulkan1_3`]
    AttachmentOptimal = 1000314001,
    ///[`PresentSrcKhr`] **must**  only be used for presenting
    ///a presentable image for display.
    ///A swapchain’s image  **must**  be transitioned to this layout before calling
    ///[`QueuePresentKHR`], and  **must**  be transitioned away from this layout
    ///after calling [`AcquireNextImageKHR`].
    ///
    ///Provided by [`crate::extensions::khr_swapchain`]
    PresentSrcKhr = 1000001002,
    ///[`VideoDecodeDstKhr`] **must**  only be used as a
    ///decode output image of a [video decode
    ///operation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-decode-operations).
    ///This layout is valid only for image subresources of images created with
    ///the `VK_IMAGE_USAGE_VIDEO_DECODE_DST_BIT_KHR` usage bit enabled.
    ///
    ///Provided by [`crate::extensions::khr_video_decode_queue`]
    VideoDecodeDstKhr = 1000024000,
    ///[`VideoDecodeSrcKhr`] is reserved for future use.
    ///
    ///Provided by [`crate::extensions::khr_video_decode_queue`]
    VideoDecodeSrcKhr = 1000024001,
    ///[`VideoDecodeDpbKhr`] **must**  only be used as a
    ///decode source or destination image of a [video
    ///decode operation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-decode-operations).
    ///This layout is valid only for image subresources of images created with
    ///the `VK_IMAGE_USAGE_VIDEO_DECODE_DPB_BIT_KHR` usage bit enabled.
    ///
    ///Provided by [`crate::extensions::khr_video_decode_queue`]
    VideoDecodeDpbKhr = 1000024002,
    ///[`SharedPresentKhr`] is valid only for shared
    ///presentable images, and  **must**  be used for any usage the image supports.
    ///
    ///Provided by [`crate::extensions::khr_shared_presentable_image`]
    SharedPresentKhr = 1000111000,
    ///[`FragmentDensityMapOptimalExt`] **must**  only be
    ///used as a fragment density map attachment in a [`RenderPass`].
    ///This layout is valid only for image subresources of images created with
    ///the `VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT` usage bit enabled.
    ///
    ///Provided by [`crate::extensions::ext_fragment_density_map`]
    FragmentDensityMapOptimalExt = 1000218000,
    ///[`FragmentShadingRateAttachmentOptimalKhr`] **must**
    ///    only be used as a
    ///    [fragment shading rate
    ///    attachment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#primsrast-fragment-shading-rate-attachment)
    ///or
    ///    [shading rate image](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#primsrast-shading-rate-image).
    ///    This layout is valid only for image subresources of images created with
    ///    the `VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR` usage
    ///    bit enabled.
    ///
    ///Provided by [`crate::extensions::khr_fragment_shading_rate`]
    FragmentShadingRateAttachmentOptimalKhr = 1000164003,
    ///[`VideoEncodeDstKhr`] is reserved for future use.
    ///
    ///Provided by [`crate::extensions::khr_video_encode_queue`]
    VideoEncodeDstKhr = 1000299000,
    ///[`VideoEncodeSrcKhr`] **must**  only be used as a
    ///encode source image of a [video encode
    ///operation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-encode-operations).
    ///This layout is valid only for image subresources of images created with
    ///the `VK_IMAGE_USAGE_VIDEO_ENCODE_SRC_BIT_KHR` usage bit enabled.
    ///
    ///Provided by [`crate::extensions::khr_video_encode_queue`]
    VideoEncodeSrcKhr = 1000299001,
    ///[`VideoEncodeDpbKhr`] **must**  only be used as a
    ///encode source or destination image of a [video
    ///encode operation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-encode-operations).
    ///This layout is valid only for image subresources of images created with
    ///the `VK_IMAGE_USAGE_VIDEO_ENCODE_DPB_BIT_KHR` usage bit enabled.
    ///
    ///Provided by [`crate::extensions::khr_video_encode_queue`]
    VideoEncodeDpbKhr = 1000299002,
}
impl const Default for ImageLayout {
    fn default() -> Self {
        Self::Undefined
    }
}
impl ImageLayout {
    ///Default empty value
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Gets the raw underlying value
    #[inline]
    pub const fn bits(&self) -> i32 {
        self as i32
    }
    ///Gets a value from a raw underlying value, unchecked and therefore unsafe
    #[inline]
    pub const unsafe fn from_bits(bits: i32) -> i32 {
        std::mem::transmute(bits)
    }
}
///[VkAttachmentLoadOp](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAttachmentLoadOp.html) - Specify how contents of an attachment are treated at the beginning of a subpass
///# C Specifications
///Possible values of [`AttachmentDescription::load_op`] and
///`stencilLoadOp`, specifying how the contents of the attachment are
///treated, are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkAttachmentLoadOp {
///    VK_ATTACHMENT_LOAD_OP_LOAD = 0,
///    VK_ATTACHMENT_LOAD_OP_CLEAR = 1,
///    VK_ATTACHMENT_LOAD_OP_DONT_CARE = 2,
///  // Provided by VK_EXT_load_store_op_none
///    VK_ATTACHMENT_LOAD_OP_NONE_EXT = 1000400000,
///} VkAttachmentLoadOp;
///```
///# Description
/// - [`Load`] specifies that the previous contents of the image within the render area will be
///   preserved. For attachments with a depth/stencil format, this uses the access type
///   `VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT`. For attachments with a color format, this uses
///   the access type `VK_ACCESS_COLOR_ATTACHMENT_READ_BIT`.
/// - [`Clear`] specifies that the contents within the render area will be cleared to a uniform
///   value, which is specified when a render pass instance is begun. For attachments with a
///   depth/stencil format, this uses the access type
///   `VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT`. For attachments with a color format, this uses
///   the access type `VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT`.
/// - [`DontCare`] specifies that the previous contents within the area need not be preserved; the
///   contents of the attachment will be undefined inside the render area. For attachments with a
///   depth/stencil format, this uses the access type
///   `VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT`. For attachments with a color format, this uses
///   the access type `VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT`.
/// - [`NoneExt`] specifies that the previous contents of the image within the render area will be
///   preserved, but the contents of the attachment will be undefined inside the render pass. No
///   access type is used as the image is not accessed.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`AttachmentDescription`]
/// - [`AttachmentDescription2`]
/// - [`RenderingAttachmentInfo`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkAttachmentLoadOp")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
#[repr(i32)]
pub enum AttachmentLoadOp {
    ///[`Load`] specifies that the previous contents of
    ///the image within the render area will be preserved.
    ///For attachments with a depth/stencil format, this uses the access type
    ///`VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT`.
    ///For attachments with a color format, this uses the access type
    ///`VK_ACCESS_COLOR_ATTACHMENT_READ_BIT`.
    Load = 0,
    ///[`Clear`] specifies that the contents within the
    ///render area will be cleared to a uniform value, which is specified when
    ///a render pass instance is begun.
    ///For attachments with a depth/stencil format, this uses the access type
    ///`VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT`.
    ///For attachments with a color format, this uses the access type
    ///`VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT`.
    Clear = 1,
    ///[`DontCare`] specifies that the previous
    ///contents within the area need not be preserved; the contents of the
    ///attachment will be undefined inside the render area.
    ///For attachments with a depth/stencil format, this uses the access type
    ///`VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT`.
    ///For attachments with a color format, this uses the access type
    ///`VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT`.
    DontCare = 2,
    ///[`NoneExt`] specifies that the previous
    ///contents of the image within the render area will be preserved, but the
    ///contents of the attachment will be undefined inside the render pass.
    ///No access type is used as the image is not accessed.
    ///
    ///Provided by [`crate::extensions::ext_load_store_op_none`]
    NoneExt = 1000400000,
}
impl const Default for AttachmentLoadOp {
    fn default() -> Self {
        Self::Load
    }
}
impl AttachmentLoadOp {
    ///Default empty value
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Gets the raw underlying value
    #[inline]
    pub const fn bits(&self) -> i32 {
        self as i32
    }
    ///Gets a value from a raw underlying value, unchecked and therefore unsafe
    #[inline]
    pub const unsafe fn from_bits(bits: i32) -> i32 {
        std::mem::transmute(bits)
    }
}
///[VkAttachmentStoreOp](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAttachmentStoreOp.html) - Specify how contents of an attachment are treated at the end of a subpass
///# C Specifications
///Possible values of [`AttachmentDescription::store_op`] and
///`stencilStoreOp`, specifying how the contents of the attachment are
///treated, are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkAttachmentStoreOp {
///    VK_ATTACHMENT_STORE_OP_STORE = 0,
///    VK_ATTACHMENT_STORE_OP_DONT_CARE = 1,
///  // Provided by VK_VERSION_1_3
///    VK_ATTACHMENT_STORE_OP_NONE = 1000301000,
///  // Provided by VK_KHR_dynamic_rendering
///    VK_ATTACHMENT_STORE_OP_NONE_KHR = VK_ATTACHMENT_STORE_OP_NONE,
///  // Provided by VK_QCOM_render_pass_store_ops
///    VK_ATTACHMENT_STORE_OP_NONE_QCOM = VK_ATTACHMENT_STORE_OP_NONE,
///  // Provided by VK_EXT_load_store_op_none
///    VK_ATTACHMENT_STORE_OP_NONE_EXT = VK_ATTACHMENT_STORE_OP_NONE,
///} VkAttachmentStoreOp;
///```
///# Description
/// - [`Store`] specifies the contents generated during the render pass and within the render area
///   are written to memory. For attachments with a depth/stencil format, this uses the access type
///   `VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT`. For attachments with a color format, this uses
///   the access type `VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT`.
/// - [`DontCare`] specifies the contents within the render area are not needed after rendering, and
///   **may**  be discarded; the contents of the attachment will be undefined inside the render
///   area. For attachments with a depth/stencil format, this uses the access type
///   `VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT`. For attachments with a color format, this uses
///   the access type `VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT`.
/// - [`None`] specifies the contents within the render area are not accessed by the store
///   operation. However, if the attachment was written to during the render pass, the contents of
///   the attachment will be undefined inside the render area.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`AttachmentDescription`]
/// - [`AttachmentDescription2`]
/// - [`RenderingAttachmentInfo`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkAttachmentStoreOp")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
#[repr(i32)]
pub enum AttachmentStoreOp {
    ///[`Store`] specifies the contents generated
    ///during the render pass and within the render area are written to memory.
    ///For attachments with a depth/stencil format, this uses the access type
    ///`VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT`.
    ///For attachments with a color format, this uses the access type
    ///`VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT`.
    Store = 0,
    ///[`DontCare`] specifies the contents within the
    ///render area are not needed after rendering, and  **may**  be discarded; the
    ///contents of the attachment will be undefined inside the render area.
    ///For attachments with a depth/stencil format, this uses the access type
    ///`VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT`.
    ///For attachments with a color format, this uses the access type
    ///`VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT`.
    DontCare = 1,
    ///[`None`] specifies the contents within the
    ///render area are not accessed by the store operation.
    ///However, if the attachment was written to during the render pass, the
    ///contents of the attachment will be undefined inside the render area.
    ///
    ///Provided by [`crate::vulkan1_3`]
    None = 1000301000,
}
impl const Default for AttachmentStoreOp {
    fn default() -> Self {
        Self::Store
    }
}
impl AttachmentStoreOp {
    ///Default empty value
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Gets the raw underlying value
    #[inline]
    pub const fn bits(&self) -> i32 {
        self as i32
    }
    ///Gets a value from a raw underlying value, unchecked and therefore unsafe
    #[inline]
    pub const unsafe fn from_bits(bits: i32) -> i32 {
        std::mem::transmute(bits)
    }
}
///[VkImageType](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageType.html) - Specifies the type of an image object
///# C Specifications
///Possible values of [`ImageCreateInfo::image_type`], specifying the
///basic dimensionality of an image, are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkImageType {
///    VK_IMAGE_TYPE_1D = 0,
///    VK_IMAGE_TYPE_2D = 1,
///    VK_IMAGE_TYPE_3D = 2,
///} VkImageType;
///```
///# Description
/// - [`1D`] specifies a one-dimensional image.
/// - [`2D`] specifies a two-dimensional image.
/// - [`3D`] specifies a three-dimensional image.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`ImageCreateInfo`]
/// - [`PhysicalDeviceImageFormatInfo2`]
/// - [`PhysicalDeviceSparseImageFormatInfo2`]
/// - [`GetPhysicalDeviceExternalImageFormatPropertiesNV`]
/// - [`GetPhysicalDeviceImageFormatProperties`]
/// - [`GetPhysicalDeviceSparseImageFormatProperties`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkImageType")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
#[repr(i32)]
pub enum ImageType {
    ///[`1D`] specifies a one-dimensional image.
    _1D = 0,
    ///[`2D`] specifies a two-dimensional image.
    _2D = 1,
    ///[`3D`] specifies a three-dimensional image.
    _3D = 2,
}
impl const Default for ImageType {
    fn default() -> Self {
        Self::_1D
    }
}
impl ImageType {
    ///Default empty value
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Gets the raw underlying value
    #[inline]
    pub const fn bits(&self) -> i32 {
        self as i32
    }
    ///Gets a value from a raw underlying value, unchecked and therefore unsafe
    #[inline]
    pub const unsafe fn from_bits(bits: i32) -> i32 {
        std::mem::transmute(bits)
    }
}
///[VkImageTiling](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageTiling.html) - Specifies the tiling arrangement of data in an image
///# C Specifications
///Possible values of [`ImageCreateInfo::tiling`], specifying the
///tiling arrangement of texel blocks in an image, are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkImageTiling {
///    VK_IMAGE_TILING_OPTIMAL = 0,
///    VK_IMAGE_TILING_LINEAR = 1,
///  // Provided by VK_EXT_image_drm_format_modifier
///    VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT = 1000158000,
///} VkImageTiling;
///```
///# Description
/// - [`Optimal`] specifies optimal tiling (texels are laid out in an implementation-dependent
///   arrangement, for more efficient memory access).
/// - [`Linear`] specifies linear tiling (texels are laid out in memory in row-major order, possibly
///   with some padding on each row).
/// - [`DrmFormatModifierExt`] indicates that the image’s tiling is defined by a [Linux DRM format modifier](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#glossary-drm-format-modifier).
///   The modifier is specified at image creation with [`ImageDrmFormatModifierListCreateInfoEXT`]
///   or [`ImageDrmFormatModifierExplicitCreateInfoEXT`], and  **can**  be queried with
///   [`GetImageDrmFormatModifierPropertiesEXT`].
///# Related
/// - [`crate::vulkan1_0`]
/// - [`ImageCreateInfo`]
/// - [`PhysicalDeviceImageFormatInfo2`]
/// - [`PhysicalDeviceSparseImageFormatInfo2`]
/// - [`GetPhysicalDeviceExternalImageFormatPropertiesNV`]
/// - [`GetPhysicalDeviceImageFormatProperties`]
/// - [`GetPhysicalDeviceSparseImageFormatProperties`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkImageTiling")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
#[repr(i32)]
pub enum ImageTiling {
    ///[`Optimal`] specifies optimal tiling (texels are laid
    ///out in an implementation-dependent arrangement, for more efficient
    ///memory access).
    Optimal = 0,
    ///[`Linear`] specifies linear tiling (texels are laid
    ///out in memory in row-major order, possibly with some padding on each
    ///row).
    Linear = 1,
    ///[`DrmFormatModifierExt`] indicates that the image’s
    ///tiling is defined by a [Linux DRM format
    ///modifier](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#glossary-drm-format-modifier).
    ///The modifier is specified at image creation with
    ///[`ImageDrmFormatModifierListCreateInfoEXT`] or
    ///[`ImageDrmFormatModifierExplicitCreateInfoEXT`], and  **can**  be queried
    ///with [`GetImageDrmFormatModifierPropertiesEXT`].
    ///
    ///Provided by [`crate::extensions::ext_image_drm_format_modifier`]
    DrmFormatModifierExt = 1000158000,
}
impl const Default for ImageTiling {
    fn default() -> Self {
        Self::Optimal
    }
}
impl ImageTiling {
    ///Default empty value
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Gets the raw underlying value
    #[inline]
    pub const fn bits(&self) -> i32 {
        self as i32
    }
    ///Gets a value from a raw underlying value, unchecked and therefore unsafe
    #[inline]
    pub const unsafe fn from_bits(bits: i32) -> i32 {
        std::mem::transmute(bits)
    }
}
///[VkImageViewType](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageViewType.html) - Image view types
///# C Specifications
///The types of image views that  **can**  be created are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkImageViewType {
///    VK_IMAGE_VIEW_TYPE_1D = 0,
///    VK_IMAGE_VIEW_TYPE_2D = 1,
///    VK_IMAGE_VIEW_TYPE_3D = 2,
///    VK_IMAGE_VIEW_TYPE_CUBE = 3,
///    VK_IMAGE_VIEW_TYPE_1D_ARRAY = 4,
///    VK_IMAGE_VIEW_TYPE_2D_ARRAY = 5,
///    VK_IMAGE_VIEW_TYPE_CUBE_ARRAY = 6,
///} VkImageViewType;
///```
///# Related
/// - [`crate::vulkan1_0`]
/// - [`ImageViewCreateInfo`]
/// - [`PhysicalDeviceImageViewImageFormatInfoEXT`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkImageViewType")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
#[repr(i32)]
pub enum ImageViewType {
    ///No documentation found
    _1D = 0,
    ///No documentation found
    _2D = 1,
    ///No documentation found
    _3D = 2,
    ///No documentation found
    Cube = 3,
    ///No documentation found
    _1DArray = 4,
    ///No documentation found
    _2DArray = 5,
    ///No documentation found
    CubeArray = 6,
}
impl const Default for ImageViewType {
    fn default() -> Self {
        Self::_1D
    }
}
impl ImageViewType {
    ///Default empty value
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Gets the raw underlying value
    #[inline]
    pub const fn bits(&self) -> i32 {
        self as i32
    }
    ///Gets a value from a raw underlying value, unchecked and therefore unsafe
    #[inline]
    pub const unsafe fn from_bits(bits: i32) -> i32 {
        std::mem::transmute(bits)
    }
}
///[VkCommandBufferLevel](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandBufferLevel.html) - Enumerant specifying a command buffer level
///# C Specifications
///Possible values of [`CommandBufferAllocateInfo::level`],
///specifying the command buffer level, are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkCommandBufferLevel {
///    VK_COMMAND_BUFFER_LEVEL_PRIMARY = 0,
///    VK_COMMAND_BUFFER_LEVEL_SECONDARY = 1,
///} VkCommandBufferLevel;
///```
///# Description
/// - [`Primary`] specifies a primary command buffer.
/// - [`Secondary`] specifies a secondary command buffer.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`CommandBufferAllocateInfo`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkCommandBufferLevel")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
#[repr(i32)]
pub enum CommandBufferLevel {
    ///[`Primary`] specifies a primary command
    ///buffer.
    Primary = 0,
    ///[`Secondary`] specifies a secondary command
    ///buffer.
    Secondary = 1,
}
impl const Default for CommandBufferLevel {
    fn default() -> Self {
        Self::Primary
    }
}
impl CommandBufferLevel {
    ///Default empty value
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Gets the raw underlying value
    #[inline]
    pub const fn bits(&self) -> i32 {
        self as i32
    }
    ///Gets a value from a raw underlying value, unchecked and therefore unsafe
    #[inline]
    pub const unsafe fn from_bits(bits: i32) -> i32 {
        std::mem::transmute(bits)
    }
}
///[VkComponentSwizzle](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkComponentSwizzle.html) - Specify how a component is swizzled
///# C Specifications
///Possible values of the members of [`ComponentMapping`], specifying the
///component values placed in each component of the output vector, are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkComponentSwizzle {
///    VK_COMPONENT_SWIZZLE_IDENTITY = 0,
///    VK_COMPONENT_SWIZZLE_ZERO = 1,
///    VK_COMPONENT_SWIZZLE_ONE = 2,
///    VK_COMPONENT_SWIZZLE_R = 3,
///    VK_COMPONENT_SWIZZLE_G = 4,
///    VK_COMPONENT_SWIZZLE_B = 5,
///    VK_COMPONENT_SWIZZLE_A = 6,
///} VkComponentSwizzle;
///```
///# Description
/// - [`Identity`] specifies that the component is set to the identity swizzle.
/// - [`Zero`] specifies that the component is set to zero.
/// - [`One`] specifies that the component is set to either 1 or 1.0, depending on whether the type of the image view format is integer or floating-point respectively, as determined by the [Format Definition](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#formats-definition) section for each [`Format`].
/// - [`R`] specifies that the component is set to the value of the R component of the image.
/// - [`G`] specifies that the component is set to the value of the G component of the image.
/// - [`B`] specifies that the component is set to the value of the B component of the image.
/// - [`A`] specifies that the component is set to the value of the A component of the image.
///Setting the identity swizzle on a component is equivalent to setting the
///identity mapping on that component.
///That is:
///# Related
/// - [`crate::vulkan1_0`]
/// - [`ComponentMapping`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkComponentSwizzle")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
#[repr(i32)]
pub enum ComponentSwizzle {
    ///[`Identity`] specifies that the component is set
    ///to the identity swizzle.
    Identity = 0,
    ///[`Zero`] specifies that the component is set to
    ///zero.
    Zero = 1,
    ///[`One`] specifies that the component is set to
    ///either 1 or 1.0, depending on whether the type of the image view format
    ///is integer or floating-point respectively, as determined by the
    ///[Format Definition](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#formats-definition) section for each
    ///[`Format`].
    One = 2,
    ///[`R`] specifies that the component is set to the
    ///value of the R component of the image.
    R = 3,
    ///[`G`] specifies that the component is set to the
    ///value of the G component of the image.
    G = 4,
    ///[`B`] specifies that the component is set to the
    ///value of the B component of the image.
    B = 5,
    ///[`A`] specifies that the component is set to the
    ///value of the A component of the image.
    A = 6,
}
impl const Default for ComponentSwizzle {
    fn default() -> Self {
        Self::Identity
    }
}
impl ComponentSwizzle {
    ///Default empty value
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Gets the raw underlying value
    #[inline]
    pub const fn bits(&self) -> i32 {
        self as i32
    }
    ///Gets a value from a raw underlying value, unchecked and therefore unsafe
    #[inline]
    pub const unsafe fn from_bits(bits: i32) -> i32 {
        std::mem::transmute(bits)
    }
}
///[VkDescriptorType](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorType.html) - Specifies the type of a descriptor in a descriptor set
///# C Specifications
///The type of descriptors in a descriptor set is specified by
///[`WriteDescriptorSet::descriptor_type`], which  **must**  be one of the
///values:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkDescriptorType {
///    VK_DESCRIPTOR_TYPE_SAMPLER = 0,
///    VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER = 1,
///    VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE = 2,
///    VK_DESCRIPTOR_TYPE_STORAGE_IMAGE = 3,
///    VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER = 4,
///    VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER = 5,
///    VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER = 6,
///    VK_DESCRIPTOR_TYPE_STORAGE_BUFFER = 7,
///    VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC = 8,
///    VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC = 9,
///    VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT = 10,
///  // Provided by VK_VERSION_1_3
///    VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK = 1000138000,
///  // Provided by VK_KHR_acceleration_structure
///    VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR = 1000150000,
///  // Provided by VK_NV_ray_tracing
///    VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV = 1000165000,
///  // Provided by VK_VALVE_mutable_descriptor_type
///    VK_DESCRIPTOR_TYPE_MUTABLE_VALVE = 1000351000,
///  // Provided by VK_EXT_inline_uniform_block
///    VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT = VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK,
///} VkDescriptorType;
///```
///# Description
/// - [`Sampler`] specifies a [sampler descriptor](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-sampler).
/// - [`CombinedImageSampler`] specifies a [combined image sampler descriptor](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-combinedimagesampler).
/// - [`SampledImage`] specifies a [sampled image descriptor](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-sampledimage).
/// - [`StorageImage`] specifies a [storage image descriptor](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storageimage).
/// - [`UniformTexelBuffer`] specifies a [uniform texel buffer descriptor](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-uniformtexelbuffer).
/// - [`StorageTexelBuffer`] specifies a [storage texel buffer descriptor](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storagetexelbuffer).
/// - [`UniformBuffer`] specifies a [uniform buffer descriptor](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-uniformbuffer).
/// - [`StorageBuffer`] specifies a [storage buffer descriptor](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storagebuffer).
/// - [`UniformBufferDynamic`] specifies a [dynamic uniform buffer descriptor](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-uniformbufferdynamic).
/// - [`StorageBufferDynamic`] specifies a [dynamic storage buffer descriptor](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storagebufferdynamic).
/// - [`InputAttachment`] specifies an [input attachment descriptor](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-inputattachment).
/// - [`InlineUniformBlock`] specifies an [inline uniform block](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-inlineuniformblock).
/// - [`MutableValve`] specifies a [descriptor of mutable type](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-mutable).
///When a descriptor set is updated via elements of [`WriteDescriptorSet`],
///members of `pImageInfo`, `pBufferInfo` and `pTexelBufferView`
///are only accessed by the implementation when they correspond to descriptor
///type being defined - otherwise they are ignored.
///The members accessed are as follows for each descriptor type:
/// - For [`Sampler`], only the `sampler` member of each element of
///   [`WriteDescriptorSet::image_info`] is accessed.
/// - For [`SampledImage`], [`StorageImage`], or [`InputAttachment`], only the `imageView` and
///   `imageLayout` members of each element of [`WriteDescriptorSet::image_info`] are accessed.
/// - For [`CombinedImageSampler`], all members of each element of
///   [`WriteDescriptorSet::image_info`] are accessed.
/// - For [`UniformBuffer`], [`StorageBuffer`], [`UniformBufferDynamic`], or
///   [`StorageBufferDynamic`], all members of each element of [`WriteDescriptorSet::buffer_info`]
///   are accessed.
/// - For [`UniformTexelBuffer`] or [`StorageTexelBuffer`], each element of
///   [`WriteDescriptorSet::texel_buffer_view`] is accessed.
///When updating descriptors with a `descriptorType` of
///[`InlineUniformBlock`], none of the `pImageInfo`,
///`pBufferInfo`, or `pTexelBufferView` members are accessed, instead
///the source data of the descriptor update operation is taken from the
///[`WriteDescriptorSetInlineUniformBlock`] structure in the `pNext`
///chain of [`WriteDescriptorSet`].
///When updating descriptors with a `descriptorType` of
///[`AccelerationStructureKhr`], none of the
///`pImageInfo`, `pBufferInfo`, or `pTexelBufferView` members are
///accessed, instead the source data of the descriptor update operation is
///taken from the [`WriteDescriptorSetAccelerationStructureKHR`] structure
///in the `pNext` chain of [`WriteDescriptorSet`].
///When updating descriptors with a `descriptorType` of
///[`AccelerationStructureNv`], none of the
///`pImageInfo`, `pBufferInfo`, or `pTexelBufferView` members are
///accessed, instead the source data of the descriptor update operation is
///taken from the [`WriteDescriptorSetAccelerationStructureNV`] structure
///in the `pNext` chain of [`WriteDescriptorSet`].
///# Related
/// - [`crate::vulkan1_0`]
/// - [`DescriptorPoolSize`]
/// - [`DescriptorSetLayoutBinding`]
/// - [`DescriptorUpdateTemplateEntry`]
/// - [`ImageViewHandleInfoNVX`]
/// - [`MutableDescriptorTypeListVALVE`]
/// - [`WriteDescriptorSet`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkDescriptorType")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
#[repr(i32)]
pub enum DescriptorType {
    ///[`Sampler`] specifies a [sampler descriptor](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-sampler).
    Sampler = 0,
    ///[`CombinedImageSampler`] specifies a
    ///[combined image sampler
    ///descriptor](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-combinedimagesampler).
    CombinedImageSampler = 1,
    ///[`SampledImage`] specifies a
    ///[sampled image descriptor](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-sampledimage).
    SampledImage = 2,
    ///[`StorageImage`] specifies a
    ///[storage image descriptor](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storageimage).
    StorageImage = 3,
    ///[`UniformTexelBuffer`] specifies a
    ///[uniform texel buffer descriptor](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-uniformtexelbuffer).
    UniformTexelBuffer = 4,
    ///[`StorageTexelBuffer`] specifies a
    ///[storage texel buffer descriptor](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storagetexelbuffer).
    StorageTexelBuffer = 5,
    ///[`UniformBuffer`] specifies a
    ///[uniform buffer descriptor](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-uniformbuffer).
    UniformBuffer = 6,
    ///[`StorageBuffer`] specifies a
    ///[storage buffer descriptor](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storagebuffer).
    StorageBuffer = 7,
    ///[`UniformBufferDynamic`] specifies a
    ///[dynamic uniform buffer
    ///descriptor](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-uniformbufferdynamic).
    UniformBufferDynamic = 8,
    ///[`StorageBufferDynamic`] specifies a
    ///[dynamic storage buffer
    ///descriptor](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storagebufferdynamic).
    StorageBufferDynamic = 9,
    ///[`InputAttachment`] specifies an
    ///[input attachment descriptor](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-inputattachment).
    InputAttachment = 10,
    ///[`InlineUniformBlock`] specifies an
    ///[inline uniform block](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-inlineuniformblock).
    ///
    ///Provided by [`crate::vulkan1_3`]
    InlineUniformBlock = 1000138000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_acceleration_structure`]
    AccelerationStructureKhr = 1000150000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::nv_ray_tracing`]
    AccelerationStructureNv = 1000165000,
    ///[`MutableValve`] specifies a
    ///[descriptor of mutable type](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-mutable).
    ///
    ///Provided by [`crate::extensions::valve_mutable_descriptor_type`]
    MutableValve = 1000351000,
}
impl const Default for DescriptorType {
    fn default() -> Self {
        Self::Sampler
    }
}
impl DescriptorType {
    ///Default empty value
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Gets the raw underlying value
    #[inline]
    pub const fn bits(&self) -> i32 {
        self as i32
    }
    ///Gets a value from a raw underlying value, unchecked and therefore unsafe
    #[inline]
    pub const unsafe fn from_bits(bits: i32) -> i32 {
        std::mem::transmute(bits)
    }
}
///[VkQueryType](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkQueryType.html) - Specify the type of queries managed by a query pool
///# C Specifications
///Possible values of [`QueryPoolCreateInfo::query_type`], specifying
///the type of queries managed by the pool, are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkQueryType {
///    VK_QUERY_TYPE_OCCLUSION = 0,
///    VK_QUERY_TYPE_PIPELINE_STATISTICS = 1,
///    VK_QUERY_TYPE_TIMESTAMP = 2,
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_KHR_video_queue
///    VK_QUERY_TYPE_RESULT_STATUS_ONLY_KHR = 1000023000,
///#endif
///  // Provided by VK_EXT_transform_feedback
///    VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT = 1000028004,
///  // Provided by VK_KHR_performance_query
///    VK_QUERY_TYPE_PERFORMANCE_QUERY_KHR = 1000116000,
///  // Provided by VK_KHR_acceleration_structure
///    VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_KHR = 1000150000,
///  // Provided by VK_KHR_acceleration_structure
///    VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_SIZE_KHR = 1000150001,
///  // Provided by VK_NV_ray_tracing
///    VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_NV = 1000165000,
///  // Provided by VK_INTEL_performance_query
///    VK_QUERY_TYPE_PERFORMANCE_QUERY_INTEL = 1000210000,
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_KHR_video_encode_queue
///    VK_QUERY_TYPE_VIDEO_ENCODE_BITSTREAM_BUFFER_RANGE_KHR = 1000299000,
///#endif
///} VkQueryType;
///```
///# Description
/// - [`Occlusion`] specifies an [occlusion query](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#queries-occlusion).
/// - [`PipelineStatistics`] specifies a [pipeline statistics query](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#queries-pipestats).
/// - [`Timestamp`] specifies a [timestamp query](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#queries-timestamps).
/// - [`PerformanceQueryKhr`] specifies a [performance query](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#queries-performance).
/// - [`TransformFeedbackStreamExt`] specifies a [transform feedback query](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#queries-transform-feedback).
/// - [`AccelerationStructureCompactedSizeKhr`] specifies a [acceleration structure size query](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#acceleration-structure-copying)
///   for use with [`CmdWriteAccelerationStructuresPropertiesKHR`] or
///   [`WriteAccelerationStructuresPropertiesKHR`].
/// - [`AccelerationStructureSerializationSizeKhr`] specifies a [serialization acceleration structure size query](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#acceleration-structure-copying)
/// - [`AccelerationStructureCompactedSizeNv`] specifies a [acceleration structure size query](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#acceleration-structure-copying)
///   for use with [`CmdWriteAccelerationStructuresPropertiesNV`].
/// - [`PerformanceQueryIntel`] specifies a [Intel performance query](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#queries-performance-intel).
/// - [`ResultStatusOnlyKhr`] specifies a [result status query](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#queries-result-status-only).
/// - [`VideoEncodeBitstreamBufferRangeKhr`] specifies a [video encode bitstream range query](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#queries-video-encode-bitstream-buffer-range).
///# Related
/// - [`crate::vulkan1_0`]
/// - [`QueryPoolCreateInfo`]
/// - [`CmdWriteAccelerationStructuresPropertiesKHR`]
/// - [`CmdWriteAccelerationStructuresPropertiesNV`]
/// - [`WriteAccelerationStructuresPropertiesKHR`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkQueryType")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
#[repr(i32)]
pub enum QueryType {
    ///[`Occlusion`] specifies an [occlusion query](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#queries-occlusion).
    Occlusion = 0,
    ///[`PipelineStatistics`] specifies a [pipeline statistics query](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#queries-pipestats).
    PipelineStatistics = 1,
    ///[`Timestamp`] specifies a [timestamp query](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#queries-timestamps).
    Timestamp = 2,
    ///[`ResultStatusOnlyKhr`] specifies a
    ///[result status query](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#queries-result-status-only).
    ///
    ///Provided by [`crate::extensions::khr_video_queue`]
    ResultStatusOnlyKhr = 1000023000,
    ///[`TransformFeedbackStreamExt`] specifies a
    ///[transform feedback query](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#queries-transform-feedback).
    ///
    ///Provided by [`crate::extensions::ext_transform_feedback`]
    TransformFeedbackStreamExt = 1000028004,
    ///[`PerformanceQueryKhr`] specifies a
    ///[performance query](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#queries-performance).
    ///
    ///Provided by [`crate::extensions::khr_performance_query`]
    PerformanceQueryKhr = 1000116000,
    ///[`AccelerationStructureCompactedSizeKhr`] specifies
    ///a [acceleration structure size query](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#acceleration-structure-copying)
    ///for use with [`CmdWriteAccelerationStructuresPropertiesKHR`] or
    ///[`WriteAccelerationStructuresPropertiesKHR`].
    ///
    ///Provided by [`crate::extensions::khr_acceleration_structure`]
    AccelerationStructureCompactedSizeKhr = 1000150000,
    ///[`AccelerationStructureSerializationSizeKhr`]
    ///specifies a [serialization acceleration
    ///structure size query](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#acceleration-structure-copying)
    ///
    ///Provided by [`crate::extensions::khr_acceleration_structure`]
    AccelerationStructureSerializationSizeKhr = 1000150001,
    ///[`AccelerationStructureCompactedSizeNv`] specifies a
    ///[acceleration structure size query](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#acceleration-structure-copying)
    ///for use with [`CmdWriteAccelerationStructuresPropertiesNV`].
    ///
    ///Provided by [`crate::extensions::nv_ray_tracing`]
    AccelerationStructureCompactedSizeNv = 1000165000,
    ///[`PerformanceQueryIntel`] specifies a
    ///[Intel performance query](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#queries-performance-intel).
    ///
    ///Provided by [`crate::extensions::intel_performance_query`]
    PerformanceQueryIntel = 1000210000,
    ///[`VideoEncodeBitstreamBufferRangeKhr`] specifies a
    ///[video encode bitstream
    ///range query](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#queries-video-encode-bitstream-buffer-range).
    ///
    ///Provided by [`crate::extensions::khr_video_encode_queue`]
    VideoEncodeBitstreamBufferRangeKhr = 1000299000,
}
impl const Default for QueryType {
    fn default() -> Self {
        Self::Occlusion
    }
}
impl QueryType {
    ///Default empty value
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Gets the raw underlying value
    #[inline]
    pub const fn bits(&self) -> i32 {
        self as i32
    }
    ///Gets a value from a raw underlying value, unchecked and therefore unsafe
    #[inline]
    pub const unsafe fn from_bits(bits: i32) -> i32 {
        std::mem::transmute(bits)
    }
}
///[VkBorderColor](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBorderColor.html) - Specify border color used for texture lookups
///# C Specifications
///Possible values of [`SamplerCreateInfo::border_color`], specifying
///the border color used for texture lookups, are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkBorderColor {
///    VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK = 0,
///    VK_BORDER_COLOR_INT_TRANSPARENT_BLACK = 1,
///    VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK = 2,
///    VK_BORDER_COLOR_INT_OPAQUE_BLACK = 3,
///    VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE = 4,
///    VK_BORDER_COLOR_INT_OPAQUE_WHITE = 5,
///  // Provided by VK_EXT_custom_border_color
///    VK_BORDER_COLOR_FLOAT_CUSTOM_EXT = 1000287003,
///  // Provided by VK_EXT_custom_border_color
///    VK_BORDER_COLOR_INT_CUSTOM_EXT = 1000287004,
///} VkBorderColor;
///```
///# Description
/// - [`FloatTransparentBlack`] specifies a transparent, floating-point format, black color.
/// - [`IntTransparentBlack`] specifies a transparent, integer format, black color.
/// - [`FloatOpaqueBlack`] specifies an opaque, floating-point format, black color.
/// - [`IntOpaqueBlack`] specifies an opaque, integer format, black color.
/// - [`FloatOpaqueWhite`] specifies an opaque, floating-point format, white color.
/// - [`IntOpaqueWhite`] specifies an opaque, integer format, white color.
/// - [`FloatCustomExt`] indicates that a [`SamplerCustomBorderColorCreateInfoEXT`] structure is
///   included in the [`SamplerCreateInfo::p_next`] chain containing the color data in
///   floating-point format.
/// - [`IntCustomExt`] indicates that a [`SamplerCustomBorderColorCreateInfoEXT`] structure is
///   included in the [`SamplerCreateInfo::p_next`] chain containing the color data in integer
///   format.
///These colors are described in detail in [Texel
///Replacement](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#textures-texel-replacement).
///# Related
/// - [`crate::vulkan1_0`]
/// - [`SamplerCreateInfo`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkBorderColor")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
#[repr(i32)]
pub enum BorderColor {
    ///[`FloatTransparentBlack`] specifies a transparent,
    ///floating-point format, black color.
    FloatTransparentBlack = 0,
    ///[`IntTransparentBlack`] specifies a transparent,
    ///integer format, black color.
    IntTransparentBlack = 1,
    ///[`FloatOpaqueBlack`] specifies an opaque,
    ///floating-point format, black color.
    FloatOpaqueBlack = 2,
    ///[`IntOpaqueBlack`] specifies an opaque, integer
    ///format, black color.
    IntOpaqueBlack = 3,
    ///[`FloatOpaqueWhite`] specifies an opaque,
    ///floating-point format, white color.
    FloatOpaqueWhite = 4,
    ///[`IntOpaqueWhite`] specifies an opaque, integer
    ///format, white color.
    IntOpaqueWhite = 5,
    ///[`FloatCustomExt`] indicates that a
    ///[`SamplerCustomBorderColorCreateInfoEXT`] structure is included in
    ///the [`SamplerCreateInfo`]::`pNext` chain containing the color
    ///data in floating-point format.
    ///
    ///Provided by [`crate::extensions::ext_custom_border_color`]
    FloatCustomExt = 1000287003,
    ///[`IntCustomExt`] indicates that a
    ///[`SamplerCustomBorderColorCreateInfoEXT`] structure is included in
    ///the [`SamplerCreateInfo`]::`pNext` chain containing the color
    ///data in integer format.
    ///
    ///Provided by [`crate::extensions::ext_custom_border_color`]
    IntCustomExt = 1000287004,
}
impl const Default for BorderColor {
    fn default() -> Self {
        Self::FloatTransparentBlack
    }
}
impl BorderColor {
    ///Default empty value
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Gets the raw underlying value
    #[inline]
    pub const fn bits(&self) -> i32 {
        self as i32
    }
    ///Gets a value from a raw underlying value, unchecked and therefore unsafe
    #[inline]
    pub const unsafe fn from_bits(bits: i32) -> i32 {
        std::mem::transmute(bits)
    }
}
///[VkPipelineBindPoint](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineBindPoint.html) - Specify the bind point of a pipeline object to a command buffer
///# C Specifications
///Possible values of [`CmdBindPipeline`]`::pipelineBindPoint`,
///specifying the bind point of a pipeline object, are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkPipelineBindPoint {
///    VK_PIPELINE_BIND_POINT_GRAPHICS = 0,
///    VK_PIPELINE_BIND_POINT_COMPUTE = 1,
///  // Provided by VK_KHR_ray_tracing_pipeline
///    VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR = 1000165000,
///  // Provided by VK_HUAWEI_subpass_shading
///    VK_PIPELINE_BIND_POINT_SUBPASS_SHADING_HUAWEI = 1000369003,
///  // Provided by VK_NV_ray_tracing
///    VK_PIPELINE_BIND_POINT_RAY_TRACING_NV = VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR,
///} VkPipelineBindPoint;
///```
///# Description
/// - [`Compute`] specifies binding as a compute pipeline.
/// - [`Graphics`] specifies binding as a graphics pipeline.
/// - [`RayTracingKhr`] specifies binding as a ray tracing pipeline.
/// - [`SubpassShadingHuawei`] specifies binding as a subpass shading pipeline.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`DescriptorUpdateTemplateCreateInfo`]
/// - [`GeneratedCommandsInfoNV`]
/// - [`GeneratedCommandsMemoryRequirementsInfoNV`]
/// - [`IndirectCommandsLayoutCreateInfoNV`]
/// - [`SubpassDescription`]
/// - [`SubpassDescription2`]
/// - [`CmdBindDescriptorSets`]
/// - [`CmdBindPipeline`]
/// - [`CmdBindPipelineShaderGroupNV`]
/// - [`CmdPushDescriptorSetKHR`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkPipelineBindPoint")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
#[repr(i32)]
pub enum PipelineBindPoint {
    ///[`Graphics`] specifies binding as a graphics
    ///pipeline.
    Graphics = 0,
    ///[`Compute`] specifies binding as a compute
    ///pipeline.
    Compute = 1,
    ///[`RayTracingKhr`] specifies binding as a ray
    ///tracing pipeline.
    ///
    ///Provided by [`crate::extensions::khr_ray_tracing_pipeline`]
    RayTracingKhr = 1000165000,
    ///[`SubpassShadingHuawei`] specifies binding as
    ///a subpass shading pipeline.
    ///
    ///Provided by [`crate::extensions::huawei_subpass_shading`]
    SubpassShadingHuawei = 1000369003,
}
impl const Default for PipelineBindPoint {
    fn default() -> Self {
        Self::Graphics
    }
}
impl PipelineBindPoint {
    ///Default empty value
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Gets the raw underlying value
    #[inline]
    pub const fn bits(&self) -> i32 {
        self as i32
    }
    ///Gets a value from a raw underlying value, unchecked and therefore unsafe
    #[inline]
    pub const unsafe fn from_bits(bits: i32) -> i32 {
        std::mem::transmute(bits)
    }
}
///[VkPipelineCacheHeaderVersion](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineCacheHeaderVersion.html) - Encode pipeline cache version
///# C Specifications
///Possible values of the `headerVersion` value of the pipeline cache
///header are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkPipelineCacheHeaderVersion {
///    VK_PIPELINE_CACHE_HEADER_VERSION_ONE = 1,
///} VkPipelineCacheHeaderVersion;
///```
///# Description
/// - [`One`] specifies version one of the pipeline cache.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`PipelineCacheHeaderVersionOne`]
/// - [`CreatePipelineCache`]
/// - [`GetPipelineCacheData`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkPipelineCacheHeaderVersion")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
#[repr(i32)]
pub enum PipelineCacheHeaderVersion {
    #[doc(hidden)]
    Empty = 0,
    ///[`One`] specifies version one of the
    ///pipeline cache.
    One = 1,
}
impl const Default for PipelineCacheHeaderVersion {
    fn default() -> Self {
        Self::Empty
    }
}
impl PipelineCacheHeaderVersion {
    ///Default empty value
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Gets the raw underlying value
    #[inline]
    pub const fn bits(&self) -> i32 {
        self as i32
    }
    ///Gets a value from a raw underlying value, unchecked and therefore unsafe
    #[inline]
    pub const unsafe fn from_bits(bits: i32) -> i32 {
        std::mem::transmute(bits)
    }
}
///[VkPrimitiveTopology](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPrimitiveTopology.html) - Supported primitive topologies
///# C Specifications
///The primitive topologies defined by [`PrimitiveTopology`] are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkPrimitiveTopology {
///    VK_PRIMITIVE_TOPOLOGY_POINT_LIST = 0,
///    VK_PRIMITIVE_TOPOLOGY_LINE_LIST = 1,
///    VK_PRIMITIVE_TOPOLOGY_LINE_STRIP = 2,
///    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST = 3,
///    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP = 4,
///    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN = 5,
///    VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY = 6,
///    VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY = 7,
///    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY = 8,
///    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY = 9,
///    VK_PRIMITIVE_TOPOLOGY_PATCH_LIST = 10,
///} VkPrimitiveTopology;
///```
///# Description
/// - [`PointList`] specifies a series of [separate point primitives](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#drawing-point-lists).
/// - [`LineList`] specifies a series of [separate line primitives](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#drawing-line-lists).
/// - [`LineStrip`] specifies a series of [connected line primitives](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#drawing-line-strips)
///   with consecutive lines sharing a vertex.
/// - [`TriangleList`] specifies a series of [separate triangle primitives](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#drawing-triangle-lists).
/// - [`TriangleStrip`] specifies a series of [connected triangle primitives](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#drawing-triangle-strips)
///   with consecutive triangles sharing an edge.
/// - [`TriangleFan`] specifies a series of [connected triangle primitives](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#drawing-triangle-fans)
///   with all triangles sharing a common vertex. If the `[`VK_KHR_portability_subset`]` extension
///   is enabled, and [`PhysicalDevicePortabilitySubsetFeaturesKHR::triangle_fans`] is [`FALSE`],
///   then triangle fans are not supported by the implementation, and [`TriangleFan`] **must**  not
///   be used.
/// - [`LineListWithAdjacency`] specifies a series of [separate line primitives with adjacency](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#drawing-line-lists-with-adjacency).
/// - [`LineStripWithAdjacency`] specifies a series of [connected line primitives with adjacency](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#drawing-line-strips-with-adjacency),
///   with consecutive primitives sharing three vertices.
/// - [`TriangleListWithAdjacency`] specifies a series of [separate triangle primitives with adjacency](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#drawing-triangle-lists-with-adjacency).
/// - [`TriangleStripWithAdjacency`] specifies [connected triangle primitives with adjacency](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#drawing-triangle-strips-with-adjacency),
///   with consecutive triangles sharing an edge.
/// - [`PatchList`] specifies [separate patch primitives](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#drawing-patch-lists).
///Each primitive topology, and its construction from a list of vertices, is
///described in detail below with a supporting diagram, according to the
///following key:The diagrams are supported with mathematical definitions where the vertices
///(v) and primitives (p) are numbered starting from 0;
///v<sub>0</sub> is the first vertex in the provided data and p<sub>0</sub> is the
///first primitive in the set of primitives defined by the vertices and
///topology.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`PipelineInputAssemblyStateCreateInfo`]
/// - [`CmdSetPrimitiveTopology`]
/// - [`CmdSetPrimitiveTopologyEXT`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkPrimitiveTopology")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
#[repr(i32)]
pub enum PrimitiveTopology {
    ///[`PointList`] specifies a series of
    ///[separate point primitives](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#drawing-point-lists).
    PointList = 0,
    ///[`LineList`] specifies a series of
    ///[separate line primitives](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#drawing-line-lists).
    LineList = 1,
    ///[`LineStrip`] specifies a series of
    ///[connected line primitives](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#drawing-line-strips) with consecutive lines
    ///sharing a vertex.
    LineStrip = 2,
    ///[`TriangleList`] specifies a series of
    ///[separate triangle primitives](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#drawing-triangle-lists).
    TriangleList = 3,
    ///[`TriangleStrip`] specifies a series of
    ///[connected triangle primitives](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#drawing-triangle-strips) with
    ///consecutive triangles sharing an edge.
    TriangleStrip = 4,
    ///[`TriangleFan`] specifies a series of
    ///[connected triangle primitives](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#drawing-triangle-fans) with all
    ///triangles sharing a common vertex.
    ///If the `[`VK_KHR_portability_subset`]` extension is enabled, and
    ///[`PhysicalDevicePortabilitySubsetFeaturesKHR`]::`triangleFans`
    ///is [`FALSE`], then triangle fans are not supported by the
    ///implementation, and [`TriangleFan`] **must**  not
    ///be used.
    TriangleFan = 5,
    ///[`LineListWithAdjacency`] specifies a series
    ///of [separate line primitives with
    ///adjacency](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#drawing-line-lists-with-adjacency).
    LineListWithAdjacency = 6,
    ///[`LineStripWithAdjacency`] specifies a series
    ///of [connected line primitives with
    ///adjacency](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#drawing-line-strips-with-adjacency), with consecutive primitives sharing three vertices.
    LineStripWithAdjacency = 7,
    ///[`TriangleListWithAdjacency`] specifies a
    ///series of [separate triangle
    ///primitives with adjacency](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#drawing-triangle-lists-with-adjacency).
    TriangleListWithAdjacency = 8,
    ///[`TriangleStripWithAdjacency`] specifies
    ///[connected triangle primitives
    ///with adjacency](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#drawing-triangle-strips-with-adjacency), with consecutive triangles sharing an edge.
    TriangleStripWithAdjacency = 9,
    ///[`PatchList`] specifies
    ///[separate patch primitives](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#drawing-patch-lists).
    PatchList = 10,
}
impl const Default for PrimitiveTopology {
    fn default() -> Self {
        Self::PointList
    }
}
impl PrimitiveTopology {
    ///Default empty value
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Gets the raw underlying value
    #[inline]
    pub const fn bits(&self) -> i32 {
        self as i32
    }
    ///Gets a value from a raw underlying value, unchecked and therefore unsafe
    #[inline]
    pub const unsafe fn from_bits(bits: i32) -> i32 {
        std::mem::transmute(bits)
    }
}
///[VkSharingMode](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSharingMode.html) - Buffer and image sharing modes
///# C Specifications
///Buffer and image objects are created with a *sharing mode* controlling how
///they  **can**  be accessed from queues.
///The supported sharing modes are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkSharingMode {
///    VK_SHARING_MODE_EXCLUSIVE = 0,
///    VK_SHARING_MODE_CONCURRENT = 1,
///} VkSharingMode;
///```
///# Description
/// - [`Exclusive`] specifies that access to any range or image subresource of the object will be
///   exclusive to a single queue family at a time.
/// - [`Concurrent`] specifies that concurrent access to any range or image subresource of the
///   object from multiple queue families is supported.
///Ranges of buffers and image subresources of image objects created using
///[`Exclusive`] **must**  only be accessed by queues in the
///queue family that has *ownership* of the resource.
///Upon creation, such resources are not owned by any queue family; ownership
///is implicitly acquired upon first use within a queue.
///Once a resource using [`Exclusive`] is owned by some queue
///family, the application  **must**  perform a
///[queue family ownership transfer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-queue-transfers) to make
///the memory contents of a range or image subresource accessible to a
///different queue family.A queue family  **can**  take ownership of an image subresource or buffer
/// range
///of a resource created with [`Exclusive`], without an
///ownership transfer, in the same way as for a resource that was just created;
///however, taking ownership in this way has the effect that the contents of
///the image subresource or buffer range are undefined.Ranges of buffers and image subresources of
/// image objects created using
///[`Concurrent`] **must**  only be accessed by queues from the
///queue families specified through the `queueFamilyIndexCount` and
///`pQueueFamilyIndices` members of the corresponding create info
///structures.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`BufferCreateInfo`]
/// - [`ImageCreateInfo`]
/// - [`PhysicalDeviceImageDrmFormatModifierInfoEXT`]
/// - [`SwapchainCreateInfoKHR`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkSharingMode")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
#[repr(i32)]
pub enum SharingMode {
    ///[`Exclusive`] specifies that access to any range or
    ///image subresource of the object will be exclusive to a single queue
    ///family at a time.
    Exclusive = 0,
    ///[`Concurrent`] specifies that concurrent access to any
    ///range or image subresource of the object from multiple queue families is
    ///supported.
    Concurrent = 1,
}
impl const Default for SharingMode {
    fn default() -> Self {
        Self::Exclusive
    }
}
impl SharingMode {
    ///Default empty value
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Gets the raw underlying value
    #[inline]
    pub const fn bits(&self) -> i32 {
        self as i32
    }
    ///Gets a value from a raw underlying value, unchecked and therefore unsafe
    #[inline]
    pub const unsafe fn from_bits(bits: i32) -> i32 {
        std::mem::transmute(bits)
    }
}
///[VkIndexType](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkIndexType.html) - Type of index buffer indices
///# C Specifications
///Possible values of [`CmdBindIndexBuffer`]`::indexType`, specifying
///the size of indices, are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkIndexType {
///    VK_INDEX_TYPE_UINT16 = 0,
///    VK_INDEX_TYPE_UINT32 = 1,
///  // Provided by VK_KHR_acceleration_structure
///    VK_INDEX_TYPE_NONE_KHR = 1000165000,
///  // Provided by VK_EXT_index_type_uint8
///    VK_INDEX_TYPE_UINT8_EXT = 1000265000,
///  // Provided by VK_NV_ray_tracing
///    VK_INDEX_TYPE_NONE_NV = VK_INDEX_TYPE_NONE_KHR,
///} VkIndexType;
///```
///# Description
/// - [`Uint16`] specifies that indices are 16-bit unsigned integer values.
/// - [`Uint32`] specifies that indices are 32-bit unsigned integer values.
/// - [`NoneKhr`] specifies that no indices are provided.
/// - [`Uint8Ext`] specifies that indices are 8-bit unsigned integer values.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`AccelerationStructureGeometryTrianglesDataKHR`]
/// - [`BindIndexBufferIndirectCommandNV`]
/// - [`GeometryTrianglesNV`]
/// - [`IndirectCommandsLayoutTokenNV`]
/// - [`CmdBindIndexBuffer`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkIndexType")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
#[repr(i32)]
pub enum IndexType {
    ///[`Uint16`] specifies that indices are 16-bit unsigned
    ///integer values.
    Uint16 = 0,
    ///[`Uint32`] specifies that indices are 32-bit unsigned
    ///integer values.
    Uint32 = 1,
    ///[`NoneKhr`] specifies that no indices are provided.
    ///
    ///Provided by [`crate::extensions::khr_acceleration_structure`]
    NoneKhr = 1000165000,
    ///[`Uint8Ext`] specifies that indices are 8-bit unsigned
    ///integer values.
    ///
    ///Provided by [`crate::extensions::ext_index_type_uint_8`]
    Uint8Ext = 1000265000,
}
impl const Default for IndexType {
    fn default() -> Self {
        Self::Uint16
    }
}
impl IndexType {
    ///Default empty value
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Gets the raw underlying value
    #[inline]
    pub const fn bits(&self) -> i32 {
        self as i32
    }
    ///Gets a value from a raw underlying value, unchecked and therefore unsafe
    #[inline]
    pub const unsafe fn from_bits(bits: i32) -> i32 {
        std::mem::transmute(bits)
    }
}
///[VkFilter](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFilter.html) - Specify filters used for texture lookups
///# C Specifications
///Possible values of the [`SamplerCreateInfo::mag_filter`] and
///`minFilter` parameters, specifying filters used for texture lookups,
///are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkFilter {
///    VK_FILTER_NEAREST = 0,
///    VK_FILTER_LINEAR = 1,
///  // Provided by VK_IMG_filter_cubic
///    VK_FILTER_CUBIC_IMG = 1000015000,
///  // Provided by VK_EXT_filter_cubic
///    VK_FILTER_CUBIC_EXT = VK_FILTER_CUBIC_IMG,
///} VkFilter;
///```
///# Description
/// - [`Nearest`] specifies nearest filtering.
/// - [`Linear`] specifies linear filtering.
/// - [`CubicExt`] specifies cubic filtering.
///These filters are described in detail in [Texel
///Filtering](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#textures-texel-filtering).
///# Related
/// - [`crate::vulkan1_0`]
/// - [`BlitImageInfo2`]
/// - [`SamplerCreateInfo`]
/// - [`SamplerYcbcrConversionCreateInfo`]
/// - [`CmdBlitImage`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkFilter")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
#[repr(i32)]
pub enum Filter {
    ///[`Nearest`] specifies nearest filtering.
    Nearest = 0,
    ///[`Linear`] specifies linear filtering.
    Linear = 1,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::img_filter_cubic`]
    CubicImg = 1000015000,
}
impl const Default for Filter {
    fn default() -> Self {
        Self::Nearest
    }
}
impl Filter {
    ///Default empty value
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Gets the raw underlying value
    #[inline]
    pub const fn bits(&self) -> i32 {
        self as i32
    }
    ///Gets a value from a raw underlying value, unchecked and therefore unsafe
    #[inline]
    pub const unsafe fn from_bits(bits: i32) -> i32 {
        std::mem::transmute(bits)
    }
}
///[VkSamplerMipmapMode](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSamplerMipmapMode.html) - Specify mipmap mode used for texture lookups
///# C Specifications
///Possible values of the [`SamplerCreateInfo::mipmap_mode`],
///specifying the mipmap mode used for texture lookups, are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkSamplerMipmapMode {
///    VK_SAMPLER_MIPMAP_MODE_NEAREST = 0,
///    VK_SAMPLER_MIPMAP_MODE_LINEAR = 1,
///} VkSamplerMipmapMode;
///```
///# Description
/// - [`Nearest`] specifies nearest filtering.
/// - [`Linear`] specifies linear filtering.
///These modes are described in detail in [Texel
///Filtering](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#textures-texel-filtering).
///# Related
/// - [`crate::vulkan1_0`]
/// - [`SamplerCreateInfo`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkSamplerMipmapMode")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
#[repr(i32)]
pub enum SamplerMipmapMode {
    ///[`Nearest`] specifies nearest filtering.
    Nearest = 0,
    ///[`Linear`] specifies linear filtering.
    Linear = 1,
}
impl const Default for SamplerMipmapMode {
    fn default() -> Self {
        Self::Nearest
    }
}
impl SamplerMipmapMode {
    ///Default empty value
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Gets the raw underlying value
    #[inline]
    pub const fn bits(&self) -> i32 {
        self as i32
    }
    ///Gets a value from a raw underlying value, unchecked and therefore unsafe
    #[inline]
    pub const unsafe fn from_bits(bits: i32) -> i32 {
        std::mem::transmute(bits)
    }
}
///[VkSamplerAddressMode](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSamplerAddressMode.html) - Specify behavior of sampling with texture coordinates outside an image
///# C Specifications
///Possible values of the [`SamplerCreateInfo`]::`addressMode*`
///parameters, specifying the behavior of sampling with coordinates outside the
///range [0,1] for the respective u, v, or w coordinate
///as defined in the [Wrapping Operation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#textures-wrapping-operation)
///section, are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkSamplerAddressMode {
///    VK_SAMPLER_ADDRESS_MODE_REPEAT = 0,
///    VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT = 1,
///    VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE = 2,
///    VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER = 3,
///  // Provided by VK_VERSION_1_2, VK_KHR_sampler_mirror_clamp_to_edge
///    VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE = 4,
///  // Provided by VK_KHR_sampler_mirror_clamp_to_edge
///    VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE_KHR =
/// VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE,
///} VkSamplerAddressMode;
///```
///# Description
/// - [`Repeat`] specifies that the repeat wrap mode will be used.
/// - [`MirroredRepeat`] specifies that the mirrored repeat wrap mode will be used.
/// - [`ClampToEdge`] specifies that the clamp to edge wrap mode will be used.
/// - [`ClampToBorder`] specifies that the clamp to border wrap mode will be used.
/// - [`MirrorClampToEdge`] specifies that the     mirror clamp to edge wrap mode will be used.     This is only valid if [samplerMirrorClampToEdge](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-samplerMirrorClampToEdge) is enabled, or if     the `[`VK_KHR_sampler_mirror_clamp_to_edge`]` extension is enabled.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`SamplerCreateInfo`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkSamplerAddressMode")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
#[repr(i32)]
pub enum SamplerAddressMode {
    ///[`Repeat`] specifies that the repeat wrap mode
    ///will be used.
    Repeat = 0,
    ///[`MirroredRepeat`] specifies that the
    ///mirrored repeat wrap mode will be used.
    MirroredRepeat = 1,
    ///[`ClampToEdge`] specifies that the clamp to
    ///edge wrap mode will be used.
    ClampToEdge = 2,
    ///[`ClampToBorder`] specifies that the clamp
    ///to border wrap mode will be used.
    ClampToBorder = 3,
    ///[`MirrorClampToEdge`] specifies that the
    ///    mirror clamp to edge wrap mode will be used.
    ///    This is only valid if
    ///[samplerMirrorClampToEdge](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-samplerMirrorClampToEdge) is enabled, or if
    ///    the `[`VK_KHR_sampler_mirror_clamp_to_edge`]` extension is enabled.
    ///
    ///Provided by [`crate::extensions::khr_sampler_mirror_clamp_to_edge`]
    MirrorClampToEdge = 4,
}
impl const Default for SamplerAddressMode {
    fn default() -> Self {
        Self::Repeat
    }
}
impl SamplerAddressMode {
    ///Default empty value
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Gets the raw underlying value
    #[inline]
    pub const fn bits(&self) -> i32 {
        self as i32
    }
    ///Gets a value from a raw underlying value, unchecked and therefore unsafe
    #[inline]
    pub const unsafe fn from_bits(bits: i32) -> i32 {
        std::mem::transmute(bits)
    }
}
///[VkCompareOp](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCompareOp.html) - Stencil comparison function
///# C Specifications
///Possible values of [`StencilOpState::compare_op`], specifying the
///stencil comparison function, are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkCompareOp {
///    VK_COMPARE_OP_NEVER = 0,
///    VK_COMPARE_OP_LESS = 1,
///    VK_COMPARE_OP_EQUAL = 2,
///    VK_COMPARE_OP_LESS_OR_EQUAL = 3,
///    VK_COMPARE_OP_GREATER = 4,
///    VK_COMPARE_OP_NOT_EQUAL = 5,
///    VK_COMPARE_OP_GREATER_OR_EQUAL = 6,
///    VK_COMPARE_OP_ALWAYS = 7,
///} VkCompareOp;
///```
///# Description
/// - [`Never`] specifies that the test evaluates to false.
/// - [`Less`] specifies that the test evaluates A < B.
/// - [`Equal`] specifies that the test evaluates A = B.
/// - [`LessOrEqual`] specifies that the test evaluates A ≤ B.
/// - [`Greater`] specifies that the test evaluates A > B.
/// - [`NotEqual`] specifies that the test evaluates A ≠ B.
/// - [`GreaterOrEqual`] specifies that the test evaluates A ≥ B.
/// - [`Always`] specifies that the test evaluates to true.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`PipelineDepthStencilStateCreateInfo`]
/// - [`SamplerCreateInfo`]
/// - [`StencilOpState`]
/// - [`CmdSetDepthCompareOp`]
/// - [`CmdSetDepthCompareOpEXT`]
/// - [`CmdSetStencilOp`]
/// - [`CmdSetStencilOpEXT`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkCompareOp")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
#[repr(i32)]
pub enum CompareOp {
    ///[`Never`] specifies that the test evaluates to false.
    Never = 0,
    ///[`Less`] specifies that the test evaluates A < B.
    Less = 1,
    ///[`Equal`] specifies that the test evaluates A = B.
    Equal = 2,
    ///[`LessOrEqual`] specifies that the test evaluates
    ///A ≤ B.
    LessOrEqual = 3,
    ///[`Greater`] specifies that the test evaluates A >
    ///B.
    Greater = 4,
    ///[`NotEqual`] specifies that the test evaluates A
    ///≠ B.
    NotEqual = 5,
    ///[`GreaterOrEqual`] specifies that the test evaluates
    ///A ≥ B.
    GreaterOrEqual = 6,
    ///[`Always`] specifies that the test evaluates to true.
    Always = 7,
}
impl const Default for CompareOp {
    fn default() -> Self {
        Self::Never
    }
}
impl CompareOp {
    ///Default empty value
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Gets the raw underlying value
    #[inline]
    pub const fn bits(&self) -> i32 {
        self as i32
    }
    ///Gets a value from a raw underlying value, unchecked and therefore unsafe
    #[inline]
    pub const unsafe fn from_bits(bits: i32) -> i32 {
        std::mem::transmute(bits)
    }
}
///[VkPolygonMode](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPolygonMode.html) - Control polygon rasterization mode
///# C Specifications
///Possible values of the
///[`PipelineRasterizationStateCreateInfo::polygon_mode`] property of
///the currently active pipeline, specifying the method of rasterization for
///polygons, are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkPolygonMode {
///    VK_POLYGON_MODE_FILL = 0,
///    VK_POLYGON_MODE_LINE = 1,
///    VK_POLYGON_MODE_POINT = 2,
///  // Provided by VK_NV_fill_rectangle
///    VK_POLYGON_MODE_FILL_RECTANGLE_NV = 1000153000,
///} VkPolygonMode;
///```
///# Description
/// - [`Point`] specifies that polygon vertices are drawn as points.
/// - [`Line`] specifies that polygon edges are drawn as line segments.
/// - [`Fill`] specifies that polygons are rendered using the polygon rasterization rules in this
///   section.
/// - [`FillRectangleNv`] specifies that polygons are rendered using polygon rasterization rules,
///   modified to consider a sample within the primitive if the sample location is inside the
///   axis-aligned bounding box of the triangle after projection. Note that the barycentric weights
///   used in attribute interpolation  **can**  extend outside the range [0,1] when these primitives
///   are shaded. Special treatment is given to a sample position on the boundary edge of the
///   bounding box. In such a case, if two rectangles lie on either side of a common edge (with
///   identical endpoints) on which a sample position lies, then exactly one of the triangles
///   **must**  produce a fragment that covers that sample during rasterization.Polygons rendered in
///   [`FillRectangleNv`] mode  **may**  be clipped by the frustum or by user clip planes. If
///   clipping is applied, the triangle is culled rather than clipped.Area calculation and
///   facingness are determined for [`FillRectangleNv`] mode using the triangle’s vertices.
///These modes affect only the final rasterization of polygons: in particular,
///a polygon’s vertices are shaded and the polygon is clipped and possibly
///culled before these modes are applied.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`PipelineRasterizationStateCreateInfo`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkPolygonMode")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
#[repr(i32)]
pub enum PolygonMode {
    ///[`Fill`] specifies that polygons are rendered using
    ///the polygon rasterization rules in this section.
    Fill = 0,
    ///[`Line`] specifies that polygon edges are drawn as
    ///line segments.
    Line = 1,
    ///[`Point`] specifies that polygon vertices are drawn as
    ///points.
    Point = 2,
    ///[`FillRectangleNv`] specifies that polygons are
    ///rendered using polygon rasterization rules, modified to consider a
    ///sample within the primitive if the sample location is inside the
    ///axis-aligned bounding box of the triangle after projection.
    ///Note that the barycentric weights used in attribute interpolation  **can**
    ///extend outside the range [0,1] when these primitives are shaded.
    ///Special treatment is given to a sample position on the boundary edge of
    ///the bounding box.
    ///In such a case, if two rectangles lie on either side of a common edge
    ///(with identical endpoints) on which a sample position lies, then exactly
    ///one of the triangles  **must**  produce a fragment that covers that sample
    ///during rasterization.Polygons rendered in [`FillRectangleNv`] mode  **may**  be
    ///clipped by the frustum or by user clip planes.
    ///If clipping is applied, the triangle is culled rather than clipped.Area calculation and
    /// facingness are determined for [`FillRectangleNv`] mode using the triangle’s vertices.
    ///
    ///Provided by [`crate::extensions::nv_fill_rectangle`]
    FillRectangleNv = 1000153000,
}
impl const Default for PolygonMode {
    fn default() -> Self {
        Self::Fill
    }
}
impl PolygonMode {
    ///Default empty value
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Gets the raw underlying value
    #[inline]
    pub const fn bits(&self) -> i32 {
        self as i32
    }
    ///Gets a value from a raw underlying value, unchecked and therefore unsafe
    #[inline]
    pub const unsafe fn from_bits(bits: i32) -> i32 {
        std::mem::transmute(bits)
    }
}
///[VkFrontFace](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFrontFace.html) - Interpret polygon front-facing orientation
///# C Specifications
///The first step of polygon rasterization is to determine whether the triangle
///is *back-facing* or *front-facing*.
///This determination is made based on the sign of the (clipped or unclipped)
///polygon’s area computed in framebuffer coordinates.
///One way to compute this area is:<span class="katex"><span class="katex-html"
/// aria-hidden="true"><span class="base"><span style="height:0.43056em;vertical-align:0em;"
/// class="strut"></span><span class="mord mathdefault">a</span><span class="mspace"
/// style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span
/// style="margin-right:0.2777777777777778em;" class="mspace"></span></span><span class="base"><span
/// class="strut" style="height:3.0787820000000004em;vertical-align:-1.277669em;"></span><span
/// class="mord">−</span><span class="mord"><span class="mord"><span class="mopen
/// nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span
/// class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span
/// class="pstrut" style="height:3em;"></span><span class="mord"><span
/// class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut"
/// style="height:3em;"></span><span style="border-bottom-width:0.04em;"
/// class="frac-line"></span></span><span style="top:-3.677em;"><span class="pstrut"
/// style="height:3em;"></span><span class="mord"><span
/// class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span
/// class="vlist-r"><span style="height:0.686em;"
/// class="vlist"><span></span></span></span></span></span><span class="mclose
/// nulldelimiter"></span></span></span><span class="mspace"
/// style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span
/// class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist"
/// style="height:1.8011130000000004em;"><span style="top:-1.872331em;margin-left:0em;"><span
/// class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span
/// class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel
/// mtight">=</span><span class="mord mtight">0</span></span></span></span><span
/// style="top:-3.050005em;"><span style="height:3.05em;" class="pstrut"></span><span><span
/// class="mop op-symbol large-op">∑</span></span></span><span
/// style="top:-4.300005em;margin-left:0em;"><span class="pstrut"
/// style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord
/// mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span
/// class="mord mtight">1</span></span></span></span></span><span
/// class="vlist-s">​</span></span><span class="vlist-r"><span style="height:1.277669em;"
/// class="vlist"><span></span></span></span></span></span><span
/// style="margin-right:0.16666666666666666em;" class="mspace"></span><span class="mord"><span
/// class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span
/// class="vlist-r"><span class="vlist" style="height:0.874664em;"><span
/// style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut"
/// style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord
/// mathdefault mtight" style="margin-right:0.10764em;">f</span></span></span><span
/// style="top:-3.1130000000000004em;margin-right:0.05em;"><span style="height:2.7em;"
/// class="pstrut"></span><span class="sizing reset-size6 size3 mtight"><span class="mord
/// mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span
/// class="vlist-r"><span style="height:0.383108em;"
/// class="vlist"><span></span></span></span></span></span></span><span class="mord"><span
/// style="margin-right:0.03588em;" class="mord mathdefault">y</span><span class="msupsub"><span
/// class="vlist-t vlist-t2"><span class="vlist-r"><span style="height:0.874664em;"
/// class="vlist"><span
/// style="top:-2.4085610000000006em;margin-left:-0.03588em;margin-right:0.05em;"><span
/// style="height:2.7em;" class="pstrut"></span><span class="sizing reset-size6 size3 mtight"><span
/// style="margin-right:0.10764em;" class="mord mathdefault mtight">f</span></span></span><span
/// style="top:-3.113em;margin-right:0.05em;"><span style="height:2.7em;"
/// class="pstrut"></span><span class="sizing reset-size6 size3 mtight"><span class="mord
/// mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">⊕</span><span
/// class="mord mtight">1</span></span></span></span></span><span
/// class="vlist-s">​</span></span><span class="vlist-r"><span style="height:0.4275469999999999em;"
/// class="vlist"><span></span></span></span></span></span></span><span class="mspace"
/// style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span
/// class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span
/// style="height:1.3022109999999998em;vertical-align:-0.4275469999999999em;"
/// class="strut"></span><span class="mord"><span class="mord mathdefault">x</span><span
/// class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span
/// style="height:0.874664em;" class="vlist"><span
/// style="top:-2.4085610000000006em;margin-left:0em;margin-right:0.05em;"><span
/// style="height:2.7em;" class="pstrut"></span><span class="sizing reset-size6 size3 mtight"><span
/// style="margin-right:0.10764em;" class="mord mathdefault mtight">f</span></span></span><span
/// style="top:-3.113em;margin-right:0.05em;"><span style="height:2.7em;"
/// class="pstrut"></span><span class="sizing reset-size6 size3 mtight"><span class="mord
/// mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">⊕</span><span
/// class="mord mtight">1</span></span></span></span></span><span
/// class="vlist-s">​</span></span><span class="vlist-r"><span style="height:0.4275469999999999em;"
/// class="vlist"><span></span></span></span></span></span></span><span class="mord"><span
/// class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span
/// class="vlist-t vlist-t2"><span class="vlist-r"><span style="height:0.874664em;"
/// class="vlist"><span
/// style="top:-2.4530000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span
/// style="height:2.7em;" class="pstrut"></span><span class="sizing reset-size6 size3 mtight"><span
/// class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span></span></span><span
/// style="top:-3.1130000000000004em;margin-right:0.05em;"><span style="height:2.7em;"
/// class="pstrut"></span><span class="sizing reset-size6 size3 mtight"><span class="mord
/// mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span
/// class="vlist-r"><span class="vlist"
/// style="height:0.383108em;"><span></span></span></span></span></span></span></span></span></
/// span>where <span class="katex"><span class="katex-html" aria-hidden="true"><span
/// class="base"><span style="height:1.2438799999999999em;vertical-align:-0.4192159999999999em;"
/// class="strut"></span><span class="mord"><span class="mord mathdefault">x</span><span
/// class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist"
/// style="height:0.824664em;"><span
/// style="top:-2.4168920000000003em;margin-left:0em;margin-right:0.05em;"><span
/// style="height:2.7em;" class="pstrut"></span><span class="sizing reset-size6 size3 mtight"><span
/// class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span></span></span><span
/// style="top:-3.063em;margin-right:0.05em;"><span class="pstrut"
/// style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord
/// mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span
/// class="vlist-r"><span style="height:0.4192159999999999em;"
/// class="vlist"><span></span></span></span></span></span></span></span></span></span> and <span
/// class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
/// style="height:1.2438799999999999em;vertical-align:-0.4192159999999999em;"></span><span
/// class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span
/// class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist"
/// style="height:0.824664em;"><span
/// style="top:-2.4168920000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span
/// class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span
/// class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span></span></span><span
/// style="top:-3.063em;margin-right:0.05em;"><span class="pstrut"
/// style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord
/// mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span
/// class="vlist-r"><span style="height:0.4192159999999999em;"
/// class="vlist"><span></span></span></span></span></span></span></span></span></span> are the x
/// and y
///framebuffer coordinates of the ith vertex of the n-vertex
///polygon (vertices are numbered starting at zero for the purposes of this
///computation) and i ⊕ 1 is (i +  1) mod n.The interpretation of the sign of a is determined by
/// the
///[`PipelineRasterizationStateCreateInfo::front_face`] property of
///the currently active pipeline.
///Possible values are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkFrontFace {
///    VK_FRONT_FACE_COUNTER_CLOCKWISE = 0,
///    VK_FRONT_FACE_CLOCKWISE = 1,
///} VkFrontFace;
///```
///# Description
/// - [`CounterClockwise`] specifies that a triangle with positive area is considered front-facing.
/// - [`Clockwise`] specifies that a triangle with negative area is considered front-facing.
///Any triangle which is not front-facing is back-facing, including zero-area
///triangles.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`PipelineRasterizationStateCreateInfo`]
/// - [`CmdSetFrontFace`]
/// - [`CmdSetFrontFaceEXT`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkFrontFace")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
#[repr(i32)]
pub enum FrontFace {
    ///[`CounterClockwise`] specifies that a triangle with
    ///positive area is considered front-facing.
    CounterClockwise = 0,
    ///[`Clockwise`] specifies that a triangle with negative
    ///area is considered front-facing.
    Clockwise = 1,
}
impl const Default for FrontFace {
    fn default() -> Self {
        Self::CounterClockwise
    }
}
impl FrontFace {
    ///Default empty value
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Gets the raw underlying value
    #[inline]
    pub const fn bits(&self) -> i32 {
        self as i32
    }
    ///Gets a value from a raw underlying value, unchecked and therefore unsafe
    #[inline]
    pub const unsafe fn from_bits(bits: i32) -> i32 {
        std::mem::transmute(bits)
    }
}
///[VkBlendFactor](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBlendFactor.html) - Framebuffer blending factors
///# C Specifications
///The source and destination color and alpha blending factors are selected
///from the enum:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkBlendFactor {
///    VK_BLEND_FACTOR_ZERO = 0,
///    VK_BLEND_FACTOR_ONE = 1,
///    VK_BLEND_FACTOR_SRC_COLOR = 2,
///    VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR = 3,
///    VK_BLEND_FACTOR_DST_COLOR = 4,
///    VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR = 5,
///    VK_BLEND_FACTOR_SRC_ALPHA = 6,
///    VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA = 7,
///    VK_BLEND_FACTOR_DST_ALPHA = 8,
///    VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA = 9,
///    VK_BLEND_FACTOR_CONSTANT_COLOR = 10,
///    VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR = 11,
///    VK_BLEND_FACTOR_CONSTANT_ALPHA = 12,
///    VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA = 13,
///    VK_BLEND_FACTOR_SRC_ALPHA_SATURATE = 14,
///    VK_BLEND_FACTOR_SRC1_COLOR = 15,
///    VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR = 16,
///    VK_BLEND_FACTOR_SRC1_ALPHA = 17,
///    VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA = 18,
///} VkBlendFactor;
///```
///# Description
///The semantics of the enum values are described in the table below:In this table, the following
/// conventions are used:
/// - R<sub>s0</sub>,G<sub>s0</sub>,B<sub>s0</sub> and A<sub>s0</sub> represent the first source
///   color R, G, B, and A components, respectively, for the fragment output location corresponding
///   to the color attachment being blended.
/// - R<sub>s1</sub>,G<sub>s1</sub>,B<sub>s1</sub> and A<sub>s1</sub> represent the second source
///   color R, G, B, and A components, respectively, used in dual source blending modes, for the
///   fragment output location corresponding to the color attachment being blended.
/// - R<sub>d</sub>,G<sub>d</sub>,B<sub>d</sub> and A<sub>d</sub> represent the R, G, B, and A
///   components of the destination color. That is, the color currently in the corresponding color
///   attachment for this fragment/sample.
/// - R<sub>c</sub>,G<sub>c</sub>,B<sub>c</sub> and A<sub>c</sub> represent the blend constant R, G,
///   B, and A components, respectively.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`PipelineColorBlendAttachmentState`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkBlendFactor")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
#[repr(i32)]
pub enum BlendFactor {
    ///No documentation found
    Zero = 0,
    ///No documentation found
    One = 1,
    ///No documentation found
    SrcColor = 2,
    ///No documentation found
    OneMinusSrcColor = 3,
    ///No documentation found
    DstColor = 4,
    ///No documentation found
    OneMinusDstColor = 5,
    ///No documentation found
    SrcAlpha = 6,
    ///No documentation found
    OneMinusSrcAlpha = 7,
    ///No documentation found
    DstAlpha = 8,
    ///No documentation found
    OneMinusDstAlpha = 9,
    ///No documentation found
    ConstantColor = 10,
    ///No documentation found
    OneMinusConstantColor = 11,
    ///No documentation found
    ConstantAlpha = 12,
    ///No documentation found
    OneMinusConstantAlpha = 13,
    ///No documentation found
    SrcAlphaSaturate = 14,
    ///No documentation found
    Src1Color = 15,
    ///No documentation found
    OneMinusSrc1Color = 16,
    ///No documentation found
    Src1Alpha = 17,
    ///No documentation found
    OneMinusSrc1Alpha = 18,
}
impl const Default for BlendFactor {
    fn default() -> Self {
        Self::Zero
    }
}
impl BlendFactor {
    ///Default empty value
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Gets the raw underlying value
    #[inline]
    pub const fn bits(&self) -> i32 {
        self as i32
    }
    ///Gets a value from a raw underlying value, unchecked and therefore unsafe
    #[inline]
    pub const unsafe fn from_bits(bits: i32) -> i32 {
        std::mem::transmute(bits)
    }
}
///[VkBlendOp](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBlendOp.html) - Framebuffer blending operations
///# C Specifications
///Once the source and destination blend factors have been selected, they along
///with the source and destination components are passed to the blending
///operations.
///RGB and alpha components  **can**  use different operations.
///Possible values of [`BlendOp`], specifying the operations, are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkBlendOp {
///    VK_BLEND_OP_ADD = 0,
///    VK_BLEND_OP_SUBTRACT = 1,
///    VK_BLEND_OP_REVERSE_SUBTRACT = 2,
///    VK_BLEND_OP_MIN = 3,
///    VK_BLEND_OP_MAX = 4,
///  // Provided by VK_EXT_blend_operation_advanced
///    VK_BLEND_OP_ZERO_EXT = 1000148000,
///  // Provided by VK_EXT_blend_operation_advanced
///    VK_BLEND_OP_SRC_EXT = 1000148001,
///  // Provided by VK_EXT_blend_operation_advanced
///    VK_BLEND_OP_DST_EXT = 1000148002,
///  // Provided by VK_EXT_blend_operation_advanced
///    VK_BLEND_OP_SRC_OVER_EXT = 1000148003,
///  // Provided by VK_EXT_blend_operation_advanced
///    VK_BLEND_OP_DST_OVER_EXT = 1000148004,
///  // Provided by VK_EXT_blend_operation_advanced
///    VK_BLEND_OP_SRC_IN_EXT = 1000148005,
///  // Provided by VK_EXT_blend_operation_advanced
///    VK_BLEND_OP_DST_IN_EXT = 1000148006,
///  // Provided by VK_EXT_blend_operation_advanced
///    VK_BLEND_OP_SRC_OUT_EXT = 1000148007,
///  // Provided by VK_EXT_blend_operation_advanced
///    VK_BLEND_OP_DST_OUT_EXT = 1000148008,
///  // Provided by VK_EXT_blend_operation_advanced
///    VK_BLEND_OP_SRC_ATOP_EXT = 1000148009,
///  // Provided by VK_EXT_blend_operation_advanced
///    VK_BLEND_OP_DST_ATOP_EXT = 1000148010,
///  // Provided by VK_EXT_blend_operation_advanced
///    VK_BLEND_OP_XOR_EXT = 1000148011,
///  // Provided by VK_EXT_blend_operation_advanced
///    VK_BLEND_OP_MULTIPLY_EXT = 1000148012,
///  // Provided by VK_EXT_blend_operation_advanced
///    VK_BLEND_OP_SCREEN_EXT = 1000148013,
///  // Provided by VK_EXT_blend_operation_advanced
///    VK_BLEND_OP_OVERLAY_EXT = 1000148014,
///  // Provided by VK_EXT_blend_operation_advanced
///    VK_BLEND_OP_DARKEN_EXT = 1000148015,
///  // Provided by VK_EXT_blend_operation_advanced
///    VK_BLEND_OP_LIGHTEN_EXT = 1000148016,
///  // Provided by VK_EXT_blend_operation_advanced
///    VK_BLEND_OP_COLORDODGE_EXT = 1000148017,
///  // Provided by VK_EXT_blend_operation_advanced
///    VK_BLEND_OP_COLORBURN_EXT = 1000148018,
///  // Provided by VK_EXT_blend_operation_advanced
///    VK_BLEND_OP_HARDLIGHT_EXT = 1000148019,
///  // Provided by VK_EXT_blend_operation_advanced
///    VK_BLEND_OP_SOFTLIGHT_EXT = 1000148020,
///  // Provided by VK_EXT_blend_operation_advanced
///    VK_BLEND_OP_DIFFERENCE_EXT = 1000148021,
///  // Provided by VK_EXT_blend_operation_advanced
///    VK_BLEND_OP_EXCLUSION_EXT = 1000148022,
///  // Provided by VK_EXT_blend_operation_advanced
///    VK_BLEND_OP_INVERT_EXT = 1000148023,
///  // Provided by VK_EXT_blend_operation_advanced
///    VK_BLEND_OP_INVERT_RGB_EXT = 1000148024,
///  // Provided by VK_EXT_blend_operation_advanced
///    VK_BLEND_OP_LINEARDODGE_EXT = 1000148025,
///  // Provided by VK_EXT_blend_operation_advanced
///    VK_BLEND_OP_LINEARBURN_EXT = 1000148026,
///  // Provided by VK_EXT_blend_operation_advanced
///    VK_BLEND_OP_VIVIDLIGHT_EXT = 1000148027,
///  // Provided by VK_EXT_blend_operation_advanced
///    VK_BLEND_OP_LINEARLIGHT_EXT = 1000148028,
///  // Provided by VK_EXT_blend_operation_advanced
///    VK_BLEND_OP_PINLIGHT_EXT = 1000148029,
///  // Provided by VK_EXT_blend_operation_advanced
///    VK_BLEND_OP_HARDMIX_EXT = 1000148030,
///  // Provided by VK_EXT_blend_operation_advanced
///    VK_BLEND_OP_HSL_HUE_EXT = 1000148031,
///  // Provided by VK_EXT_blend_operation_advanced
///    VK_BLEND_OP_HSL_SATURATION_EXT = 1000148032,
///  // Provided by VK_EXT_blend_operation_advanced
///    VK_BLEND_OP_HSL_COLOR_EXT = 1000148033,
///  // Provided by VK_EXT_blend_operation_advanced
///    VK_BLEND_OP_HSL_LUMINOSITY_EXT = 1000148034,
///  // Provided by VK_EXT_blend_operation_advanced
///    VK_BLEND_OP_PLUS_EXT = 1000148035,
///  // Provided by VK_EXT_blend_operation_advanced
///    VK_BLEND_OP_PLUS_CLAMPED_EXT = 1000148036,
///  // Provided by VK_EXT_blend_operation_advanced
///    VK_BLEND_OP_PLUS_CLAMPED_ALPHA_EXT = 1000148037,
///  // Provided by VK_EXT_blend_operation_advanced
///    VK_BLEND_OP_PLUS_DARKER_EXT = 1000148038,
///  // Provided by VK_EXT_blend_operation_advanced
///    VK_BLEND_OP_MINUS_EXT = 1000148039,
///  // Provided by VK_EXT_blend_operation_advanced
///    VK_BLEND_OP_MINUS_CLAMPED_EXT = 1000148040,
///  // Provided by VK_EXT_blend_operation_advanced
///    VK_BLEND_OP_CONTRAST_EXT = 1000148041,
///  // Provided by VK_EXT_blend_operation_advanced
///    VK_BLEND_OP_INVERT_OVG_EXT = 1000148042,
///  // Provided by VK_EXT_blend_operation_advanced
///    VK_BLEND_OP_RED_EXT = 1000148043,
///  // Provided by VK_EXT_blend_operation_advanced
///    VK_BLEND_OP_GREEN_EXT = 1000148044,
///  // Provided by VK_EXT_blend_operation_advanced
///    VK_BLEND_OP_BLUE_EXT = 1000148045,
///} VkBlendOp;
///```
///# Description
///The semantics of the basic blend operations are described in the table
///below:In this table, the following conventions are used:
/// - R<sub>s0</sub>, G<sub>s0</sub>, B<sub>s0</sub> and A<sub>s0</sub> represent the first source
///   color R, G, B, and A components, respectively.
/// - R<sub>d</sub>, G<sub>d</sub>, B<sub>d</sub> and A<sub>d</sub> represent the R, G, B, and A
///   components of the destination color. That is, the color currently in the corresponding color
///   attachment for this fragment/sample.
/// - S<sub>r</sub>, S<sub>g</sub>, S<sub>b</sub> and S<sub>a</sub> represent the source blend
///   factor R, G, B, and A components, respectively.
/// - D<sub>r</sub>, D<sub>g</sub>, D<sub>b</sub> and D<sub>a</sub> represent the destination blend
///   factor R, G, B, and A components, respectively.
///The blending operation produces a new set of values R, G, B and
///A, which are written to the framebuffer attachment.
///If blending is not enabled for this attachment, then R, G, B and
///A are assigned R<sub>s0</sub>, G<sub>s0</sub>, B<sub>s0</sub> and A<sub>s0</sub>,
///respectively.If the color attachment is fixed-point, the components of the source and
///destination values and blend factors are each clamped to [0,1] or
///[-1,1] respectively for an unsigned normalized or signed normalized
///color attachment prior to evaluating the blend operations.
///If the color attachment is floating-point, no clamping occurs.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`PipelineColorBlendAttachmentState`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkBlendOp")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
#[repr(i32)]
pub enum BlendOp {
    ///No documentation found
    Add = 0,
    ///No documentation found
    Subtract = 1,
    ///No documentation found
    ReverseSubtract = 2,
    ///No documentation found
    Min = 3,
    ///No documentation found
    Max = 4,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_blend_operation_advanced`]
    ZeroExt = 1000148000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_blend_operation_advanced`]
    SrcExt = 1000148001,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_blend_operation_advanced`]
    DstExt = 1000148002,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_blend_operation_advanced`]
    SrcOverExt = 1000148003,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_blend_operation_advanced`]
    DstOverExt = 1000148004,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_blend_operation_advanced`]
    SrcInExt = 1000148005,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_blend_operation_advanced`]
    DstInExt = 1000148006,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_blend_operation_advanced`]
    SrcOutExt = 1000148007,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_blend_operation_advanced`]
    DstOutExt = 1000148008,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_blend_operation_advanced`]
    SrcAtopExt = 1000148009,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_blend_operation_advanced`]
    DstAtopExt = 1000148010,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_blend_operation_advanced`]
    XorExt = 1000148011,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_blend_operation_advanced`]
    MultiplyExt = 1000148012,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_blend_operation_advanced`]
    ScreenExt = 1000148013,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_blend_operation_advanced`]
    OverlayExt = 1000148014,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_blend_operation_advanced`]
    DarkenExt = 1000148015,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_blend_operation_advanced`]
    LightenExt = 1000148016,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_blend_operation_advanced`]
    ColordodgeExt = 1000148017,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_blend_operation_advanced`]
    ColorburnExt = 1000148018,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_blend_operation_advanced`]
    HardlightExt = 1000148019,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_blend_operation_advanced`]
    SoftlightExt = 1000148020,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_blend_operation_advanced`]
    DifferenceExt = 1000148021,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_blend_operation_advanced`]
    ExclusionExt = 1000148022,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_blend_operation_advanced`]
    InvertExt = 1000148023,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_blend_operation_advanced`]
    InvertRgbExt = 1000148024,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_blend_operation_advanced`]
    LineardodgeExt = 1000148025,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_blend_operation_advanced`]
    LinearburnExt = 1000148026,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_blend_operation_advanced`]
    VividlightExt = 1000148027,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_blend_operation_advanced`]
    LinearlightExt = 1000148028,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_blend_operation_advanced`]
    PinlightExt = 1000148029,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_blend_operation_advanced`]
    HardmixExt = 1000148030,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_blend_operation_advanced`]
    HslHueExt = 1000148031,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_blend_operation_advanced`]
    HslSaturationExt = 1000148032,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_blend_operation_advanced`]
    HslColorExt = 1000148033,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_blend_operation_advanced`]
    HslLuminosityExt = 1000148034,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_blend_operation_advanced`]
    PlusExt = 1000148035,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_blend_operation_advanced`]
    PlusClampedExt = 1000148036,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_blend_operation_advanced`]
    PlusClampedAlphaExt = 1000148037,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_blend_operation_advanced`]
    PlusDarkerExt = 1000148038,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_blend_operation_advanced`]
    MinusExt = 1000148039,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_blend_operation_advanced`]
    MinusClampedExt = 1000148040,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_blend_operation_advanced`]
    ContrastExt = 1000148041,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_blend_operation_advanced`]
    InvertOvgExt = 1000148042,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_blend_operation_advanced`]
    RedExt = 1000148043,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_blend_operation_advanced`]
    GreenExt = 1000148044,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_blend_operation_advanced`]
    BlueExt = 1000148045,
}
impl const Default for BlendOp {
    fn default() -> Self {
        Self::Add
    }
}
impl BlendOp {
    ///Default empty value
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Gets the raw underlying value
    #[inline]
    pub const fn bits(&self) -> i32 {
        self as i32
    }
    ///Gets a value from a raw underlying value, unchecked and therefore unsafe
    #[inline]
    pub const unsafe fn from_bits(bits: i32) -> i32 {
        std::mem::transmute(bits)
    }
}
///[VkStencilOp](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkStencilOp.html) - Stencil comparison function
///# C Specifications
///Possible values of the `failOp`, `passOp`, and `depthFailOp`
///members of [`StencilOpState`], specifying what happens to the stored
///stencil value if this or certain subsequent tests fail or pass, are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkStencilOp {
///    VK_STENCIL_OP_KEEP = 0,
///    VK_STENCIL_OP_ZERO = 1,
///    VK_STENCIL_OP_REPLACE = 2,
///    VK_STENCIL_OP_INCREMENT_AND_CLAMP = 3,
///    VK_STENCIL_OP_DECREMENT_AND_CLAMP = 4,
///    VK_STENCIL_OP_INVERT = 5,
///    VK_STENCIL_OP_INCREMENT_AND_WRAP = 6,
///    VK_STENCIL_OP_DECREMENT_AND_WRAP = 7,
///} VkStencilOp;
///```
///# Description
/// - [`Keep`] keeps the current value.
/// - [`Zero`] sets the value to 0.
/// - [`Replace`] sets the value to `reference`.
/// - [`IncrementAndClamp`] increments the current value and clamps to the maximum representable
///   unsigned value.
/// - [`DecrementAndClamp`] decrements the current value and clamps to 0.
/// - [`Invert`] bitwise-inverts the current value.
/// - [`IncrementAndWrap`] increments the current value and wraps to 0 when the maximum value would
///   have been exceeded.
/// - [`DecrementAndWrap`] decrements the current value and wraps to the maximum possible value when
///   the value would go below 0.
///For purposes of increment and decrement, the stencil bits are considered as
///an unsigned integer.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`StencilOpState`]
/// - [`CmdSetStencilOp`]
/// - [`CmdSetStencilOpEXT`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkStencilOp")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
#[repr(i32)]
pub enum StencilOp {
    ///[`Keep`] keeps the current value.
    Keep = 0,
    ///[`Zero`] sets the value to 0.
    Zero = 1,
    ///[`Replace`] sets the value to `reference`.
    Replace = 2,
    ///[`IncrementAndClamp`] increments the current value and
    ///clamps to the maximum representable unsigned value.
    IncrementAndClamp = 3,
    ///[`DecrementAndClamp`] decrements the current value and
    ///clamps to 0.
    DecrementAndClamp = 4,
    ///[`Invert`] bitwise-inverts the current value.
    Invert = 5,
    ///[`IncrementAndWrap`] increments the current value and
    ///wraps to 0 when the maximum value would have been exceeded.
    IncrementAndWrap = 6,
    ///[`DecrementAndWrap`] decrements the current value and
    ///wraps to the maximum possible value when the value would go below 0.
    DecrementAndWrap = 7,
}
impl const Default for StencilOp {
    fn default() -> Self {
        Self::Keep
    }
}
impl StencilOp {
    ///Default empty value
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Gets the raw underlying value
    #[inline]
    pub const fn bits(&self) -> i32 {
        self as i32
    }
    ///Gets a value from a raw underlying value, unchecked and therefore unsafe
    #[inline]
    pub const unsafe fn from_bits(bits: i32) -> i32 {
        std::mem::transmute(bits)
    }
}
///[VkLogicOp](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkLogicOp.html) - Framebuffer logical operations
///# C Specifications
///Logical operations are controlled by the `logicOpEnable` and
///`logicOp` members of [`PipelineColorBlendStateCreateInfo`].
///It can also be controlled by [`CmdSetLogicOpEXT`] if graphics pipeline
///is created with `VK_DYNAMIC_STATE_LOGIC_OP_EXT` set in
///[`PipelineDynamicStateCreateInfo::dynamic_states`].
///If `logicOpEnable` is [`TRUE`], then a logical operation selected
///by `logicOp` is applied between each color attachment and the fragment’s
///corresponding output value, and blending of all attachments is treated as if
///it were disabled.
///Any attachments using color formats for which logical operations are not
///supported simply pass through the color values unmodified.
///The logical operation is applied independently for each of the red, green,
///blue, and alpha components.
///The `logicOp` is selected from the following operations:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkLogicOp {
///    VK_LOGIC_OP_CLEAR = 0,
///    VK_LOGIC_OP_AND = 1,
///    VK_LOGIC_OP_AND_REVERSE = 2,
///    VK_LOGIC_OP_COPY = 3,
///    VK_LOGIC_OP_AND_INVERTED = 4,
///    VK_LOGIC_OP_NO_OP = 5,
///    VK_LOGIC_OP_XOR = 6,
///    VK_LOGIC_OP_OR = 7,
///    VK_LOGIC_OP_NOR = 8,
///    VK_LOGIC_OP_EQUIVALENT = 9,
///    VK_LOGIC_OP_INVERT = 10,
///    VK_LOGIC_OP_OR_REVERSE = 11,
///    VK_LOGIC_OP_COPY_INVERTED = 12,
///    VK_LOGIC_OP_OR_INVERTED = 13,
///    VK_LOGIC_OP_NAND = 14,
///    VK_LOGIC_OP_SET = 15,
///} VkLogicOp;
///```
///# Description
///The logical operations supported by Vulkan are summarized in the following
///table in which
/// - ¬ is bitwise invert,
/// - ∧ is bitwise and,
/// - ∨ is bitwise or,
/// - ⊕ is bitwise exclusive or,
/// - s is the fragment’s R<sub>s0</sub>, G<sub>s0</sub>, B<sub>s0</sub> or A<sub>s0</sub> component
///   value for the fragment output corresponding to the color attachment being updated, and
/// - d is the color attachment’s R, G, B or A component value:
///The result of the logical operation is then written to the color attachment
///as controlled by the component write mask, described in
///[Blend Operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#framebuffer-blendoperations).
///# Related
/// - [`crate::vulkan1_0`]
/// - [`PipelineColorBlendStateCreateInfo`]
/// - [`CmdSetLogicOpEXT`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkLogicOp")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
#[repr(i32)]
pub enum LogicOp {
    ///No documentation found
    Clear = 0,
    ///No documentation found
    And = 1,
    ///No documentation found
    AndReverse = 2,
    ///No documentation found
    Copy = 3,
    ///No documentation found
    AndInverted = 4,
    ///No documentation found
    NoOp = 5,
    ///No documentation found
    Xor = 6,
    ///No documentation found
    Or = 7,
    ///No documentation found
    Nor = 8,
    ///No documentation found
    Equivalent = 9,
    ///No documentation found
    Invert = 10,
    ///No documentation found
    OrReverse = 11,
    ///No documentation found
    CopyInverted = 12,
    ///No documentation found
    OrInverted = 13,
    ///No documentation found
    Nand = 14,
    ///No documentation found
    Set = 15,
}
impl const Default for LogicOp {
    fn default() -> Self {
        Self::Clear
    }
}
impl LogicOp {
    ///Default empty value
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Gets the raw underlying value
    #[inline]
    pub const fn bits(&self) -> i32 {
        self as i32
    }
    ///Gets a value from a raw underlying value, unchecked and therefore unsafe
    #[inline]
    pub const unsafe fn from_bits(bits: i32) -> i32 {
        std::mem::transmute(bits)
    }
}
///[VkInternalAllocationType](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkInternalAllocationType.html) - Allocation type
///# C Specifications
///The `allocationType` parameter to the `pfnInternalAllocation` and
///`pfnInternalFree` functions  **may**  be one of the following values:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkInternalAllocationType {
///    VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE = 0,
///} VkInternalAllocationType;
///```
///# Description
/// - [`Executable`] specifies that the allocation is intended for execution by the host.
///# Related
/// - [`PFNInternalAllocationNotification`]
/// - [`PFNInternalFreeNotification`]
/// - [`crate::vulkan1_0`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkInternalAllocationType")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
#[repr(i32)]
pub enum InternalAllocationType {
    ///[`Executable`] specifies that the
    ///allocation is intended for execution by the host.
    Executable = 0,
}
impl const Default for InternalAllocationType {
    fn default() -> Self {
        Self::Executable
    }
}
impl InternalAllocationType {
    ///Default empty value
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Gets the raw underlying value
    #[inline]
    pub const fn bits(&self) -> i32 {
        self as i32
    }
    ///Gets a value from a raw underlying value, unchecked and therefore unsafe
    #[inline]
    pub const unsafe fn from_bits(bits: i32) -> i32 {
        std::mem::transmute(bits)
    }
}
///[VkSystemAllocationScope](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSystemAllocationScope.html) - Allocation scope
///# C Specifications
///Each allocation has an *allocation scope* defining its lifetime and which
///object it is associated with.
///Possible values passed to the `allocationScope` parameter of the
///callback functions specified by [`AllocationCallbacks`], indicating the
///allocation scope, are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkSystemAllocationScope {
///    VK_SYSTEM_ALLOCATION_SCOPE_COMMAND = 0,
///    VK_SYSTEM_ALLOCATION_SCOPE_OBJECT = 1,
///    VK_SYSTEM_ALLOCATION_SCOPE_CACHE = 2,
///    VK_SYSTEM_ALLOCATION_SCOPE_DEVICE = 3,
///    VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE = 4,
///} VkSystemAllocationScope;
///```
///# Description
/// - [`Command`] specifies that the allocation is scoped to the duration of the Vulkan command.
/// - [`Object`] specifies that the allocation is scoped to the lifetime of the Vulkan object that
///   is being created or used.
/// - [`Cache`] specifies that the allocation is scoped to the lifetime of a [`PipelineCache`] or
///   [`ValidationCacheEXT`] object.
/// - [`Device`] specifies that the allocation is scoped to the lifetime of the Vulkan device.
/// - [`Instance`] specifies that the allocation is scoped to the lifetime of the Vulkan instance.
///Most Vulkan commands operate on a single object, or there is a sole object
///that is being created or manipulated.
///When an allocation uses an allocation scope of
///[`Object`] or
///[`Cache`], the allocation is scoped to the
///object being created or manipulated.When an implementation requires host memory, it will make
/// callbacks to the
///application using the most specific allocator and allocation scope
///available:
/// - If an allocation is scoped to the duration of a command, the allocator will use the
///   [`Command`] allocation scope. The most specific allocator available is used: if the object
///   being created or manipulated has an allocator, that object’s allocator will be used, else if
///   the parent [`Device`] has an allocator it will be used, else if the parent [`Instance`] has an
///   allocator it will be used. Else,
/// - If an allocation is associated with a [`ValidationCacheEXT`] or [`PipelineCache`] object, the
///   allocator will use the [`Cache`] allocation scope. The most specific allocator available is
///   used (cache, else device, else instance). Else,
/// - If an allocation is scoped to the lifetime of an object, that object is being created or
///   manipulated by the command, and that object’s type is not [`Device`] or [`Instance`], the
///   allocator will use an allocation scope of [`Object`]. The most specific allocator available is
///   used (object, else device, else instance). Else,
/// - If an allocation is scoped to the lifetime of a device, the allocator will use an allocation
///   scope of [`Device`]. The most specific allocator available is used (device, else instance).
///   Else,
/// - If the allocation is scoped to the lifetime of an instance and the instance has an allocator,
///   its allocator will be used with an allocation scope of [`Instance`].
/// - Otherwise an implementation will allocate memory through an alternative mechanism that is
///   unspecified.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`AllocationCallbacks`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkSystemAllocationScope")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
#[repr(i32)]
pub enum SystemAllocationScope {
    ///[`Command`] specifies that the allocation
    ///is scoped to the duration of the Vulkan command.
    Command = 0,
    ///[`Object`] specifies that the allocation is
    ///scoped to the lifetime of the Vulkan object that is being created or
    ///used.
    Object = 1,
    ///[`Cache`] specifies that the allocation is
    ///scoped to the lifetime of a [`PipelineCache`]
    ///or [`ValidationCacheEXT`]
    ///object.
    Cache = 2,
    ///[`Device`] specifies that the allocation is
    ///scoped to the lifetime of the Vulkan device.
    Device = 3,
    ///[`Instance`] specifies that the allocation
    ///is scoped to the lifetime of the Vulkan instance.
    Instance = 4,
}
impl const Default for SystemAllocationScope {
    fn default() -> Self {
        Self::Command
    }
}
impl SystemAllocationScope {
    ///Default empty value
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Gets the raw underlying value
    #[inline]
    pub const fn bits(&self) -> i32 {
        self as i32
    }
    ///Gets a value from a raw underlying value, unchecked and therefore unsafe
    #[inline]
    pub const unsafe fn from_bits(bits: i32) -> i32 {
        std::mem::transmute(bits)
    }
}
///[VkPhysicalDeviceType](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceType.html) - Supported physical device types
///# C Specifications
///The physical device types which  **may**  be returned in
///[`PhysicalDeviceProperties::device_type`] are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkPhysicalDeviceType {
///    VK_PHYSICAL_DEVICE_TYPE_OTHER = 0,
///    VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU = 1,
///    VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU = 2,
///    VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU = 3,
///    VK_PHYSICAL_DEVICE_TYPE_CPU = 4,
///} VkPhysicalDeviceType;
///```
///# Description
/// - [`Other`] - the device does not match any other available types.
/// - [`IntegratedGpu`] - the device is typically one embedded in or tightly coupled with the host.
/// - [`DiscreteGpu`] - the device is typically a separate processor connected to the host via an
///   interlink.
/// - [`VirtualGpu`] - the device is typically a virtual node in a virtualization environment.
/// - [`Cpu`] - the device is typically running on the same processors as the host.
///The physical device type is advertised for informational purposes only, and
///does not directly affect the operation of the system.
///However, the device type  **may**  correlate with other advertised properties or
///capabilities of the system, such as how many memory heaps there are.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`PhysicalDeviceProperties`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkPhysicalDeviceType")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
#[repr(i32)]
pub enum PhysicalDeviceType {
    ///[`Other`] - the device does not match any
    ///other available types.
    Other = 0,
    ///[`IntegratedGpu`] - the device is typically
    ///one embedded in or tightly coupled with the host.
    IntegratedGpu = 1,
    ///[`DiscreteGpu`] - the device is typically a
    ///separate processor connected to the host via an interlink.
    DiscreteGpu = 2,
    ///[`VirtualGpu`] - the device is typically a
    ///virtual node in a virtualization environment.
    VirtualGpu = 3,
    ///[`Cpu`] - the device is typically running on
    ///the same processors as the host.
    Cpu = 4,
}
impl const Default for PhysicalDeviceType {
    fn default() -> Self {
        Self::Other
    }
}
impl PhysicalDeviceType {
    ///Default empty value
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Gets the raw underlying value
    #[inline]
    pub const fn bits(&self) -> i32 {
        self as i32
    }
    ///Gets a value from a raw underlying value, unchecked and therefore unsafe
    #[inline]
    pub const unsafe fn from_bits(bits: i32) -> i32 {
        std::mem::transmute(bits)
    }
}
///[VkVertexInputRate](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVertexInputRate.html) - Specify rate at which vertex attributes are pulled from buffers
///# C Specifications
///Possible values of [`VertexInputBindingDescription::input_rate`],
///specifying the rate at which vertex attributes are pulled from buffers, are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkVertexInputRate {
///    VK_VERTEX_INPUT_RATE_VERTEX = 0,
///    VK_VERTEX_INPUT_RATE_INSTANCE = 1,
///} VkVertexInputRate;
///```
///# Description
/// - [`Vertex`] specifies that vertex attribute addressing is a function of the vertex index.
/// - [`Instance`] specifies that vertex attribute addressing is a function of the instance index.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`VertexInputBindingDescription`]
/// - [`VertexInputBindingDescription2EXT`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkVertexInputRate")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
#[repr(i32)]
pub enum VertexInputRate {
    ///[`Vertex`] specifies that vertex attribute
    ///addressing is a function of the vertex index.
    Vertex = 0,
    ///[`Instance`] specifies that vertex attribute
    ///addressing is a function of the instance index.
    Instance = 1,
}
impl const Default for VertexInputRate {
    fn default() -> Self {
        Self::Vertex
    }
}
impl VertexInputRate {
    ///Default empty value
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Gets the raw underlying value
    #[inline]
    pub const fn bits(&self) -> i32 {
        self as i32
    }
    ///Gets a value from a raw underlying value, unchecked and therefore unsafe
    #[inline]
    pub const unsafe fn from_bits(bits: i32) -> i32 {
        std::mem::transmute(bits)
    }
}
///[VkFormat](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFormat.html) - Available image formats
///# C Specifications
///The following image formats  **can**  be passed to, and  **may**  be returned from
///Vulkan commands.
///The memory required to store each format is discussed with that format, and
///also summarized in the [Representation and Texel Block
///Size](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#texel-block-size) section and the [Compatible formats](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#formats-compatibility) table.
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkFormat {
///    VK_FORMAT_UNDEFINED = 0,
///    VK_FORMAT_R4G4_UNORM_PACK8 = 1,
///    VK_FORMAT_R4G4B4A4_UNORM_PACK16 = 2,
///    VK_FORMAT_B4G4R4A4_UNORM_PACK16 = 3,
///    VK_FORMAT_R5G6B5_UNORM_PACK16 = 4,
///    VK_FORMAT_B5G6R5_UNORM_PACK16 = 5,
///    VK_FORMAT_R5G5B5A1_UNORM_PACK16 = 6,
///    VK_FORMAT_B5G5R5A1_UNORM_PACK16 = 7,
///    VK_FORMAT_A1R5G5B5_UNORM_PACK16 = 8,
///    VK_FORMAT_R8_UNORM = 9,
///    VK_FORMAT_R8_SNORM = 10,
///    VK_FORMAT_R8_USCALED = 11,
///    VK_FORMAT_R8_SSCALED = 12,
///    VK_FORMAT_R8_UINT = 13,
///    VK_FORMAT_R8_SINT = 14,
///    VK_FORMAT_R8_SRGB = 15,
///    VK_FORMAT_R8G8_UNORM = 16,
///    VK_FORMAT_R8G8_SNORM = 17,
///    VK_FORMAT_R8G8_USCALED = 18,
///    VK_FORMAT_R8G8_SSCALED = 19,
///    VK_FORMAT_R8G8_UINT = 20,
///    VK_FORMAT_R8G8_SINT = 21,
///    VK_FORMAT_R8G8_SRGB = 22,
///    VK_FORMAT_R8G8B8_UNORM = 23,
///    VK_FORMAT_R8G8B8_SNORM = 24,
///    VK_FORMAT_R8G8B8_USCALED = 25,
///    VK_FORMAT_R8G8B8_SSCALED = 26,
///    VK_FORMAT_R8G8B8_UINT = 27,
///    VK_FORMAT_R8G8B8_SINT = 28,
///    VK_FORMAT_R8G8B8_SRGB = 29,
///    VK_FORMAT_B8G8R8_UNORM = 30,
///    VK_FORMAT_B8G8R8_SNORM = 31,
///    VK_FORMAT_B8G8R8_USCALED = 32,
///    VK_FORMAT_B8G8R8_SSCALED = 33,
///    VK_FORMAT_B8G8R8_UINT = 34,
///    VK_FORMAT_B8G8R8_SINT = 35,
///    VK_FORMAT_B8G8R8_SRGB = 36,
///    VK_FORMAT_R8G8B8A8_UNORM = 37,
///    VK_FORMAT_R8G8B8A8_SNORM = 38,
///    VK_FORMAT_R8G8B8A8_USCALED = 39,
///    VK_FORMAT_R8G8B8A8_SSCALED = 40,
///    VK_FORMAT_R8G8B8A8_UINT = 41,
///    VK_FORMAT_R8G8B8A8_SINT = 42,
///    VK_FORMAT_R8G8B8A8_SRGB = 43,
///    VK_FORMAT_B8G8R8A8_UNORM = 44,
///    VK_FORMAT_B8G8R8A8_SNORM = 45,
///    VK_FORMAT_B8G8R8A8_USCALED = 46,
///    VK_FORMAT_B8G8R8A8_SSCALED = 47,
///    VK_FORMAT_B8G8R8A8_UINT = 48,
///    VK_FORMAT_B8G8R8A8_SINT = 49,
///    VK_FORMAT_B8G8R8A8_SRGB = 50,
///    VK_FORMAT_A8B8G8R8_UNORM_PACK32 = 51,
///    VK_FORMAT_A8B8G8R8_SNORM_PACK32 = 52,
///    VK_FORMAT_A8B8G8R8_USCALED_PACK32 = 53,
///    VK_FORMAT_A8B8G8R8_SSCALED_PACK32 = 54,
///    VK_FORMAT_A8B8G8R8_UINT_PACK32 = 55,
///    VK_FORMAT_A8B8G8R8_SINT_PACK32 = 56,
///    VK_FORMAT_A8B8G8R8_SRGB_PACK32 = 57,
///    VK_FORMAT_A2R10G10B10_UNORM_PACK32 = 58,
///    VK_FORMAT_A2R10G10B10_SNORM_PACK32 = 59,
///    VK_FORMAT_A2R10G10B10_USCALED_PACK32 = 60,
///    VK_FORMAT_A2R10G10B10_SSCALED_PACK32 = 61,
///    VK_FORMAT_A2R10G10B10_UINT_PACK32 = 62,
///    VK_FORMAT_A2R10G10B10_SINT_PACK32 = 63,
///    VK_FORMAT_A2B10G10R10_UNORM_PACK32 = 64,
///    VK_FORMAT_A2B10G10R10_SNORM_PACK32 = 65,
///    VK_FORMAT_A2B10G10R10_USCALED_PACK32 = 66,
///    VK_FORMAT_A2B10G10R10_SSCALED_PACK32 = 67,
///    VK_FORMAT_A2B10G10R10_UINT_PACK32 = 68,
///    VK_FORMAT_A2B10G10R10_SINT_PACK32 = 69,
///    VK_FORMAT_R16_UNORM = 70,
///    VK_FORMAT_R16_SNORM = 71,
///    VK_FORMAT_R16_USCALED = 72,
///    VK_FORMAT_R16_SSCALED = 73,
///    VK_FORMAT_R16_UINT = 74,
///    VK_FORMAT_R16_SINT = 75,
///    VK_FORMAT_R16_SFLOAT = 76,
///    VK_FORMAT_R16G16_UNORM = 77,
///    VK_FORMAT_R16G16_SNORM = 78,
///    VK_FORMAT_R16G16_USCALED = 79,
///    VK_FORMAT_R16G16_SSCALED = 80,
///    VK_FORMAT_R16G16_UINT = 81,
///    VK_FORMAT_R16G16_SINT = 82,
///    VK_FORMAT_R16G16_SFLOAT = 83,
///    VK_FORMAT_R16G16B16_UNORM = 84,
///    VK_FORMAT_R16G16B16_SNORM = 85,
///    VK_FORMAT_R16G16B16_USCALED = 86,
///    VK_FORMAT_R16G16B16_SSCALED = 87,
///    VK_FORMAT_R16G16B16_UINT = 88,
///    VK_FORMAT_R16G16B16_SINT = 89,
///    VK_FORMAT_R16G16B16_SFLOAT = 90,
///    VK_FORMAT_R16G16B16A16_UNORM = 91,
///    VK_FORMAT_R16G16B16A16_SNORM = 92,
///    VK_FORMAT_R16G16B16A16_USCALED = 93,
///    VK_FORMAT_R16G16B16A16_SSCALED = 94,
///    VK_FORMAT_R16G16B16A16_UINT = 95,
///    VK_FORMAT_R16G16B16A16_SINT = 96,
///    VK_FORMAT_R16G16B16A16_SFLOAT = 97,
///    VK_FORMAT_R32_UINT = 98,
///    VK_FORMAT_R32_SINT = 99,
///    VK_FORMAT_R32_SFLOAT = 100,
///    VK_FORMAT_R32G32_UINT = 101,
///    VK_FORMAT_R32G32_SINT = 102,
///    VK_FORMAT_R32G32_SFLOAT = 103,
///    VK_FORMAT_R32G32B32_UINT = 104,
///    VK_FORMAT_R32G32B32_SINT = 105,
///    VK_FORMAT_R32G32B32_SFLOAT = 106,
///    VK_FORMAT_R32G32B32A32_UINT = 107,
///    VK_FORMAT_R32G32B32A32_SINT = 108,
///    VK_FORMAT_R32G32B32A32_SFLOAT = 109,
///    VK_FORMAT_R64_UINT = 110,
///    VK_FORMAT_R64_SINT = 111,
///    VK_FORMAT_R64_SFLOAT = 112,
///    VK_FORMAT_R64G64_UINT = 113,
///    VK_FORMAT_R64G64_SINT = 114,
///    VK_FORMAT_R64G64_SFLOAT = 115,
///    VK_FORMAT_R64G64B64_UINT = 116,
///    VK_FORMAT_R64G64B64_SINT = 117,
///    VK_FORMAT_R64G64B64_SFLOAT = 118,
///    VK_FORMAT_R64G64B64A64_UINT = 119,
///    VK_FORMAT_R64G64B64A64_SINT = 120,
///    VK_FORMAT_R64G64B64A64_SFLOAT = 121,
///    VK_FORMAT_B10G11R11_UFLOAT_PACK32 = 122,
///    VK_FORMAT_E5B9G9R9_UFLOAT_PACK32 = 123,
///    VK_FORMAT_D16_UNORM = 124,
///    VK_FORMAT_X8_D24_UNORM_PACK32 = 125,
///    VK_FORMAT_D32_SFLOAT = 126,
///    VK_FORMAT_S8_UINT = 127,
///    VK_FORMAT_D16_UNORM_S8_UINT = 128,
///    VK_FORMAT_D24_UNORM_S8_UINT = 129,
///    VK_FORMAT_D32_SFLOAT_S8_UINT = 130,
///    VK_FORMAT_BC1_RGB_UNORM_BLOCK = 131,
///    VK_FORMAT_BC1_RGB_SRGB_BLOCK = 132,
///    VK_FORMAT_BC1_RGBA_UNORM_BLOCK = 133,
///    VK_FORMAT_BC1_RGBA_SRGB_BLOCK = 134,
///    VK_FORMAT_BC2_UNORM_BLOCK = 135,
///    VK_FORMAT_BC2_SRGB_BLOCK = 136,
///    VK_FORMAT_BC3_UNORM_BLOCK = 137,
///    VK_FORMAT_BC3_SRGB_BLOCK = 138,
///    VK_FORMAT_BC4_UNORM_BLOCK = 139,
///    VK_FORMAT_BC4_SNORM_BLOCK = 140,
///    VK_FORMAT_BC5_UNORM_BLOCK = 141,
///    VK_FORMAT_BC5_SNORM_BLOCK = 142,
///    VK_FORMAT_BC6H_UFLOAT_BLOCK = 143,
///    VK_FORMAT_BC6H_SFLOAT_BLOCK = 144,
///    VK_FORMAT_BC7_UNORM_BLOCK = 145,
///    VK_FORMAT_BC7_SRGB_BLOCK = 146,
///    VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK = 147,
///    VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK = 148,
///    VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK = 149,
///    VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK = 150,
///    VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK = 151,
///    VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK = 152,
///    VK_FORMAT_EAC_R11_UNORM_BLOCK = 153,
///    VK_FORMAT_EAC_R11_SNORM_BLOCK = 154,
///    VK_FORMAT_EAC_R11G11_UNORM_BLOCK = 155,
///    VK_FORMAT_EAC_R11G11_SNORM_BLOCK = 156,
///    VK_FORMAT_ASTC_4x4_UNORM_BLOCK = 157,
///    VK_FORMAT_ASTC_4x4_SRGB_BLOCK = 158,
///    VK_FORMAT_ASTC_5x4_UNORM_BLOCK = 159,
///    VK_FORMAT_ASTC_5x4_SRGB_BLOCK = 160,
///    VK_FORMAT_ASTC_5x5_UNORM_BLOCK = 161,
///    VK_FORMAT_ASTC_5x5_SRGB_BLOCK = 162,
///    VK_FORMAT_ASTC_6x5_UNORM_BLOCK = 163,
///    VK_FORMAT_ASTC_6x5_SRGB_BLOCK = 164,
///    VK_FORMAT_ASTC_6x6_UNORM_BLOCK = 165,
///    VK_FORMAT_ASTC_6x6_SRGB_BLOCK = 166,
///    VK_FORMAT_ASTC_8x5_UNORM_BLOCK = 167,
///    VK_FORMAT_ASTC_8x5_SRGB_BLOCK = 168,
///    VK_FORMAT_ASTC_8x6_UNORM_BLOCK = 169,
///    VK_FORMAT_ASTC_8x6_SRGB_BLOCK = 170,
///    VK_FORMAT_ASTC_8x8_UNORM_BLOCK = 171,
///    VK_FORMAT_ASTC_8x8_SRGB_BLOCK = 172,
///    VK_FORMAT_ASTC_10x5_UNORM_BLOCK = 173,
///    VK_FORMAT_ASTC_10x5_SRGB_BLOCK = 174,
///    VK_FORMAT_ASTC_10x6_UNORM_BLOCK = 175,
///    VK_FORMAT_ASTC_10x6_SRGB_BLOCK = 176,
///    VK_FORMAT_ASTC_10x8_UNORM_BLOCK = 177,
///    VK_FORMAT_ASTC_10x8_SRGB_BLOCK = 178,
///    VK_FORMAT_ASTC_10x10_UNORM_BLOCK = 179,
///    VK_FORMAT_ASTC_10x10_SRGB_BLOCK = 180,
///    VK_FORMAT_ASTC_12x10_UNORM_BLOCK = 181,
///    VK_FORMAT_ASTC_12x10_SRGB_BLOCK = 182,
///    VK_FORMAT_ASTC_12x12_UNORM_BLOCK = 183,
///    VK_FORMAT_ASTC_12x12_SRGB_BLOCK = 184,
///  // Provided by VK_VERSION_1_1
///    VK_FORMAT_G8B8G8R8_422_UNORM = 1000156000,
///  // Provided by VK_VERSION_1_1
///    VK_FORMAT_B8G8R8G8_422_UNORM = 1000156001,
///  // Provided by VK_VERSION_1_1
///    VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM = 1000156002,
///  // Provided by VK_VERSION_1_1
///    VK_FORMAT_G8_B8R8_2PLANE_420_UNORM = 1000156003,
///  // Provided by VK_VERSION_1_1
///    VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM = 1000156004,
///  // Provided by VK_VERSION_1_1
///    VK_FORMAT_G8_B8R8_2PLANE_422_UNORM = 1000156005,
///  // Provided by VK_VERSION_1_1
///    VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM = 1000156006,
///  // Provided by VK_VERSION_1_1
///    VK_FORMAT_R10X6_UNORM_PACK16 = 1000156007,
///  // Provided by VK_VERSION_1_1
///    VK_FORMAT_R10X6G10X6_UNORM_2PACK16 = 1000156008,
///  // Provided by VK_VERSION_1_1
///    VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16 = 1000156009,
///  // Provided by VK_VERSION_1_1
///    VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16 = 1000156010,
///  // Provided by VK_VERSION_1_1
///    VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16 = 1000156011,
///  // Provided by VK_VERSION_1_1
///    VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16 = 1000156012,
///  // Provided by VK_VERSION_1_1
///    VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16 = 1000156013,
///  // Provided by VK_VERSION_1_1
///    VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16 = 1000156014,
///  // Provided by VK_VERSION_1_1
///    VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16 = 1000156015,
///  // Provided by VK_VERSION_1_1
///    VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16 = 1000156016,
///  // Provided by VK_VERSION_1_1
///    VK_FORMAT_R12X4_UNORM_PACK16 = 1000156017,
///  // Provided by VK_VERSION_1_1
///    VK_FORMAT_R12X4G12X4_UNORM_2PACK16 = 1000156018,
///  // Provided by VK_VERSION_1_1
///    VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16 = 1000156019,
///  // Provided by VK_VERSION_1_1
///    VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16 = 1000156020,
///  // Provided by VK_VERSION_1_1
///    VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16 = 1000156021,
///  // Provided by VK_VERSION_1_1
///    VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16 = 1000156022,
///  // Provided by VK_VERSION_1_1
///    VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16 = 1000156023,
///  // Provided by VK_VERSION_1_1
///    VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16 = 1000156024,
///  // Provided by VK_VERSION_1_1
///    VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16 = 1000156025,
///  // Provided by VK_VERSION_1_1
///    VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16 = 1000156026,
///  // Provided by VK_VERSION_1_1
///    VK_FORMAT_G16B16G16R16_422_UNORM = 1000156027,
///  // Provided by VK_VERSION_1_1
///    VK_FORMAT_B16G16R16G16_422_UNORM = 1000156028,
///  // Provided by VK_VERSION_1_1
///    VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM = 1000156029,
///  // Provided by VK_VERSION_1_1
///    VK_FORMAT_G16_B16R16_2PLANE_420_UNORM = 1000156030,
///  // Provided by VK_VERSION_1_1
///    VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM = 1000156031,
///  // Provided by VK_VERSION_1_1
///    VK_FORMAT_G16_B16R16_2PLANE_422_UNORM = 1000156032,
///  // Provided by VK_VERSION_1_1
///    VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM = 1000156033,
///  // Provided by VK_VERSION_1_3
///    VK_FORMAT_G8_B8R8_2PLANE_444_UNORM = 1000330000,
///  // Provided by VK_VERSION_1_3
///    VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16 = 1000330001,
///  // Provided by VK_VERSION_1_3
///    VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16 = 1000330002,
///  // Provided by VK_VERSION_1_3
///    VK_FORMAT_G16_B16R16_2PLANE_444_UNORM = 1000330003,
///  // Provided by VK_VERSION_1_3
///    VK_FORMAT_A4R4G4B4_UNORM_PACK16 = 1000340000,
///  // Provided by VK_VERSION_1_3
///    VK_FORMAT_A4B4G4R4_UNORM_PACK16 = 1000340001,
///  // Provided by VK_VERSION_1_3
///    VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK = 1000066000,
///  // Provided by VK_VERSION_1_3
///    VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK = 1000066001,
///  // Provided by VK_VERSION_1_3
///    VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK = 1000066002,
///  // Provided by VK_VERSION_1_3
///    VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK = 1000066003,
///  // Provided by VK_VERSION_1_3
///    VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK = 1000066004,
///  // Provided by VK_VERSION_1_3
///    VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK = 1000066005,
///  // Provided by VK_VERSION_1_3
///    VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK = 1000066006,
///  // Provided by VK_VERSION_1_3
///    VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK = 1000066007,
///  // Provided by VK_VERSION_1_3
///    VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK = 1000066008,
///  // Provided by VK_VERSION_1_3
///    VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK = 1000066009,
///  // Provided by VK_VERSION_1_3
///    VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK = 1000066010,
///  // Provided by VK_VERSION_1_3
///    VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK = 1000066011,
///  // Provided by VK_VERSION_1_3
///    VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK = 1000066012,
///  // Provided by VK_VERSION_1_3
///    VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK = 1000066013,
///  // Provided by VK_IMG_format_pvrtc
///    VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG = 1000054000,
///  // Provided by VK_IMG_format_pvrtc
///    VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG = 1000054001,
///  // Provided by VK_IMG_format_pvrtc
///    VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG = 1000054002,
///  // Provided by VK_IMG_format_pvrtc
///    VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG = 1000054003,
///  // Provided by VK_IMG_format_pvrtc
///    VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG = 1000054004,
///  // Provided by VK_IMG_format_pvrtc
///    VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG = 1000054005,
///  // Provided by VK_IMG_format_pvrtc
///    VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG = 1000054006,
///  // Provided by VK_IMG_format_pvrtc
///    VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG = 1000054007,
///  // Provided by VK_EXT_texture_compression_astc_hdr
///    VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK_EXT = VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK,
///  // Provided by VK_EXT_texture_compression_astc_hdr
///    VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK_EXT = VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK,
///  // Provided by VK_EXT_texture_compression_astc_hdr
///    VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK_EXT = VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK,
///  // Provided by VK_EXT_texture_compression_astc_hdr
///    VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK_EXT = VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK,
///  // Provided by VK_EXT_texture_compression_astc_hdr
///    VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK_EXT = VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK,
///  // Provided by VK_EXT_texture_compression_astc_hdr
///    VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK_EXT = VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK,
///  // Provided by VK_EXT_texture_compression_astc_hdr
///    VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK_EXT = VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK,
///  // Provided by VK_EXT_texture_compression_astc_hdr
///    VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK_EXT = VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK,
///  // Provided by VK_EXT_texture_compression_astc_hdr
///    VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK_EXT = VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK,
///  // Provided by VK_EXT_texture_compression_astc_hdr
///    VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK_EXT = VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK,
///  // Provided by VK_EXT_texture_compression_astc_hdr
///    VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK_EXT = VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK,
///  // Provided by VK_EXT_texture_compression_astc_hdr
///    VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK_EXT = VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK,
///  // Provided by VK_EXT_texture_compression_astc_hdr
///    VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK_EXT = VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK,
///  // Provided by VK_EXT_texture_compression_astc_hdr
///    VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK_EXT = VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK,
///  // Provided by VK_KHR_sampler_ycbcr_conversion
///    VK_FORMAT_G8B8G8R8_422_UNORM_KHR = VK_FORMAT_G8B8G8R8_422_UNORM,
///  // Provided by VK_KHR_sampler_ycbcr_conversion
///    VK_FORMAT_B8G8R8G8_422_UNORM_KHR = VK_FORMAT_B8G8R8G8_422_UNORM,
///  // Provided by VK_KHR_sampler_ycbcr_conversion
///    VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM_KHR = VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM,
///  // Provided by VK_KHR_sampler_ycbcr_conversion
///    VK_FORMAT_G8_B8R8_2PLANE_420_UNORM_KHR = VK_FORMAT_G8_B8R8_2PLANE_420_UNORM,
///  // Provided by VK_KHR_sampler_ycbcr_conversion
///    VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM_KHR = VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM,
///  // Provided by VK_KHR_sampler_ycbcr_conversion
///    VK_FORMAT_G8_B8R8_2PLANE_422_UNORM_KHR = VK_FORMAT_G8_B8R8_2PLANE_422_UNORM,
///  // Provided by VK_KHR_sampler_ycbcr_conversion
///    VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM_KHR = VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM,
///  // Provided by VK_KHR_sampler_ycbcr_conversion
///    VK_FORMAT_R10X6_UNORM_PACK16_KHR = VK_FORMAT_R10X6_UNORM_PACK16,
///  // Provided by VK_KHR_sampler_ycbcr_conversion
///    VK_FORMAT_R10X6G10X6_UNORM_2PACK16_KHR = VK_FORMAT_R10X6G10X6_UNORM_2PACK16,
///  // Provided by VK_KHR_sampler_ycbcr_conversion
///    VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16_KHR =
/// VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16,
///  // Provided by VK_KHR_sampler_ycbcr_conversion
///    VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16_KHR =
/// VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16,
///  // Provided by VK_KHR_sampler_ycbcr_conversion
///    VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16_KHR =
/// VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16,
///  // Provided by VK_KHR_sampler_ycbcr_conversion
///    VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16_KHR =
/// VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16,
///  // Provided by VK_KHR_sampler_ycbcr_conversion
///    VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16_KHR =
/// VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16,
///  // Provided by VK_KHR_sampler_ycbcr_conversion
///    VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16_KHR =
/// VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16,
///  // Provided by VK_KHR_sampler_ycbcr_conversion
///    VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16_KHR =
/// VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16,
///  // Provided by VK_KHR_sampler_ycbcr_conversion
///    VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16_KHR =
/// VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16,
///  // Provided by VK_KHR_sampler_ycbcr_conversion
///    VK_FORMAT_R12X4_UNORM_PACK16_KHR = VK_FORMAT_R12X4_UNORM_PACK16,
///  // Provided by VK_KHR_sampler_ycbcr_conversion
///    VK_FORMAT_R12X4G12X4_UNORM_2PACK16_KHR = VK_FORMAT_R12X4G12X4_UNORM_2PACK16,
///  // Provided by VK_KHR_sampler_ycbcr_conversion
///    VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16_KHR =
/// VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16,
///  // Provided by VK_KHR_sampler_ycbcr_conversion
///    VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16_KHR =
/// VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16,
///  // Provided by VK_KHR_sampler_ycbcr_conversion
///    VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16_KHR =
/// VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16,
///  // Provided by VK_KHR_sampler_ycbcr_conversion
///    VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16_KHR =
/// VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16,
///  // Provided by VK_KHR_sampler_ycbcr_conversion
///    VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16_KHR =
/// VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16,
///  // Provided by VK_KHR_sampler_ycbcr_conversion
///    VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16_KHR =
/// VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16,
///  // Provided by VK_KHR_sampler_ycbcr_conversion
///    VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16_KHR =
/// VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16,
///  // Provided by VK_KHR_sampler_ycbcr_conversion
///    VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16_KHR =
/// VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16,
///  // Provided by VK_KHR_sampler_ycbcr_conversion
///    VK_FORMAT_G16B16G16R16_422_UNORM_KHR = VK_FORMAT_G16B16G16R16_422_UNORM,
///  // Provided by VK_KHR_sampler_ycbcr_conversion
///    VK_FORMAT_B16G16R16G16_422_UNORM_KHR = VK_FORMAT_B16G16R16G16_422_UNORM,
///  // Provided by VK_KHR_sampler_ycbcr_conversion
///    VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM_KHR = VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM,
///  // Provided by VK_KHR_sampler_ycbcr_conversion
///    VK_FORMAT_G16_B16R16_2PLANE_420_UNORM_KHR = VK_FORMAT_G16_B16R16_2PLANE_420_UNORM,
///  // Provided by VK_KHR_sampler_ycbcr_conversion
///    VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM_KHR = VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM,
///  // Provided by VK_KHR_sampler_ycbcr_conversion
///    VK_FORMAT_G16_B16R16_2PLANE_422_UNORM_KHR = VK_FORMAT_G16_B16R16_2PLANE_422_UNORM,
///  // Provided by VK_KHR_sampler_ycbcr_conversion
///    VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM_KHR = VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM,
///  // Provided by VK_EXT_ycbcr_2plane_444_formats
///    VK_FORMAT_G8_B8R8_2PLANE_444_UNORM_EXT = VK_FORMAT_G8_B8R8_2PLANE_444_UNORM,
///  // Provided by VK_EXT_ycbcr_2plane_444_formats
///    VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16_EXT =
/// VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16,
///  // Provided by VK_EXT_ycbcr_2plane_444_formats
///    VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16_EXT =
/// VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16,
///  // Provided by VK_EXT_ycbcr_2plane_444_formats
///    VK_FORMAT_G16_B16R16_2PLANE_444_UNORM_EXT = VK_FORMAT_G16_B16R16_2PLANE_444_UNORM,
///  // Provided by VK_EXT_4444_formats
///    VK_FORMAT_A4R4G4B4_UNORM_PACK16_EXT = VK_FORMAT_A4R4G4B4_UNORM_PACK16,
///  // Provided by VK_EXT_4444_formats
///    VK_FORMAT_A4B4G4R4_UNORM_PACK16_EXT = VK_FORMAT_A4B4G4R4_UNORM_PACK16,
///} VkFormat;
///```
///# Description
/// - [`Undefined`] specifies that the format is not specified.
/// - [`R4G4UnormPack8`] specifies a two-component, 8-bit packed unsigned normalized format that has
///   a 4-bit R component in bits 4..7, and a 4-bit G component in bits 0..3.
/// - [`R4G4B4A4UnormPack16`] specifies a four-component, 16-bit packed unsigned normalized format
///   that has a 4-bit R component in bits 12..15, a 4-bit G component in bits 8..11, a 4-bit B
///   component in bits 4..7, and a 4-bit A component in bits 0..3.
/// - [`B4G4R4A4UnormPack16`] specifies a four-component, 16-bit packed unsigned normalized format
///   that has a 4-bit B component in bits 12..15, a 4-bit G component in bits 8..11, a 4-bit R
///   component in bits 4..7, and a 4-bit A component in bits 0..3.
/// - [`A4R4G4B4UnormPack16`] specifies a four-component, 16-bit packed unsigned normalized format
///   that has a 4-bit A component in bits 12..15, a 4-bit R component in bits 8..11, a 4-bit G
///   component in bits 4..7, and a 4-bit B component in bits 0..3.
/// - [`A4B4G4R4UnormPack16`] specifies a four-component, 16-bit packed unsigned normalized format
///   that has a 4-bit A component in bits 12..15, a 4-bit B component in bits 8..11, a 4-bit G
///   component in bits 4..7, and a 4-bit R component in bits 0..3.
/// - [`R5G6B5UnormPack16`] specifies a three-component, 16-bit packed unsigned normalized format
///   that has a 5-bit R component in bits 11..15, a 6-bit G component in bits 5..10, and a 5-bit B
///   component in bits 0..4.
/// - [`B5G6R5UnormPack16`] specifies a three-component, 16-bit packed unsigned normalized format
///   that has a 5-bit B component in bits 11..15, a 6-bit G component in bits 5..10, and a 5-bit R
///   component in bits 0..4.
/// - [`R5G5B5A1UnormPack16`] specifies a four-component, 16-bit packed unsigned normalized format
///   that has a 5-bit R component in bits 11..15, a 5-bit G component in bits 6..10, a 5-bit B
///   component in bits 1..5, and a 1-bit A component in bit 0.
/// - [`B5G5R5A1UnormPack16`] specifies a four-component, 16-bit packed unsigned normalized format
///   that has a 5-bit B component in bits 11..15, a 5-bit G component in bits 6..10, a 5-bit R
///   component in bits 1..5, and a 1-bit A component in bit 0.
/// - [`A1R5G5B5UnormPack16`] specifies a four-component, 16-bit packed unsigned normalized format
///   that has a 1-bit A component in bit 15, a 5-bit R component in bits 10..14, a 5-bit G
///   component in bits 5..9, and a 5-bit B component in bits 0..4.
/// - [`R8Unorm`] specifies a one-component, 8-bit unsigned normalized format that has a single
///   8-bit R component.
/// - [`R8Snorm`] specifies a one-component, 8-bit signed normalized format that has a single 8-bit
///   R component.
/// - [`R8Uscaled`] specifies a one-component, 8-bit unsigned scaled integer format that has a
///   single 8-bit R component.
/// - [`R8Sscaled`] specifies a one-component, 8-bit signed scaled integer format that has a single
///   8-bit R component.
/// - [`R8Uint`] specifies a one-component, 8-bit unsigned integer format that has a single 8-bit R
///   component.
/// - [`R8Sint`] specifies a one-component, 8-bit signed integer format that has a single 8-bit R
///   component.
/// - [`R8Srgb`] specifies a one-component, 8-bit unsigned normalized format that has a single 8-bit
///   R component stored with sRGB nonlinear encoding.
/// - [`R8G8Unorm`] specifies a two-component, 16-bit unsigned normalized format that has an 8-bit R
///   component in byte 0, and an 8-bit G component in byte 1.
/// - [`R8G8Snorm`] specifies a two-component, 16-bit signed normalized format that has an 8-bit R
///   component in byte 0, and an 8-bit G component in byte 1.
/// - [`R8G8Uscaled`] specifies a two-component, 16-bit unsigned scaled integer format that has an
///   8-bit R component in byte 0, and an 8-bit G component in byte 1.
/// - [`R8G8Sscaled`] specifies a two-component, 16-bit signed scaled integer format that has an
///   8-bit R component in byte 0, and an 8-bit G component in byte 1.
/// - [`R8G8Uint`] specifies a two-component, 16-bit unsigned integer format that has an 8-bit R
///   component in byte 0, and an 8-bit G component in byte 1.
/// - [`R8G8Sint`] specifies a two-component, 16-bit signed integer format that has an 8-bit R
///   component in byte 0, and an 8-bit G component in byte 1.
/// - [`R8G8Srgb`] specifies a two-component, 16-bit unsigned normalized format that has an 8-bit R
///   component stored with sRGB nonlinear encoding in byte 0, and an 8-bit G component stored with
///   sRGB nonlinear encoding in byte 1.
/// - [`R8G8B8Unorm`] specifies a three-component, 24-bit unsigned normalized format that has an
///   8-bit R component in byte 0, an 8-bit G component in byte 1, and an 8-bit B component in byte
///   2.
/// - [`R8G8B8Snorm`] specifies a three-component, 24-bit signed normalized format that has an 8-bit
///   R component in byte 0, an 8-bit G component in byte 1, and an 8-bit B component in byte 2.
/// - [`R8G8B8Uscaled`] specifies a three-component, 24-bit unsigned scaled format that has an 8-bit
///   R component in byte 0, an 8-bit G component in byte 1, and an 8-bit B component in byte 2.
/// - [`R8G8B8Sscaled`] specifies a three-component, 24-bit signed scaled format that has an 8-bit R
///   component in byte 0, an 8-bit G component in byte 1, and an 8-bit B component in byte 2.
/// - [`R8G8B8Uint`] specifies a three-component, 24-bit unsigned integer format that has an 8-bit R
///   component in byte 0, an 8-bit G component in byte 1, and an 8-bit B component in byte 2.
/// - [`R8G8B8Sint`] specifies a three-component, 24-bit signed integer format that has an 8-bit R
///   component in byte 0, an 8-bit G component in byte 1, and an 8-bit B component in byte 2.
/// - [`R8G8B8Srgb`] specifies a three-component, 24-bit unsigned normalized format that has an
///   8-bit R component stored with sRGB nonlinear encoding in byte 0, an 8-bit G component stored
///   with sRGB nonlinear encoding in byte 1, and an 8-bit B component stored with sRGB nonlinear
///   encoding in byte 2.
/// - [`B8G8R8Unorm`] specifies a three-component, 24-bit unsigned normalized format that has an
///   8-bit B component in byte 0, an 8-bit G component in byte 1, and an 8-bit R component in byte
///   2.
/// - [`B8G8R8Snorm`] specifies a three-component, 24-bit signed normalized format that has an 8-bit
///   B component in byte 0, an 8-bit G component in byte 1, and an 8-bit R component in byte 2.
/// - [`B8G8R8Uscaled`] specifies a three-component, 24-bit unsigned scaled format that has an 8-bit
///   B component in byte 0, an 8-bit G component in byte 1, and an 8-bit R component in byte 2.
/// - [`B8G8R8Sscaled`] specifies a three-component, 24-bit signed scaled format that has an 8-bit B
///   component in byte 0, an 8-bit G component in byte 1, and an 8-bit R component in byte 2.
/// - [`B8G8R8Uint`] specifies a three-component, 24-bit unsigned integer format that has an 8-bit B
///   component in byte 0, an 8-bit G component in byte 1, and an 8-bit R component in byte 2.
/// - [`B8G8R8Sint`] specifies a three-component, 24-bit signed integer format that has an 8-bit B
///   component in byte 0, an 8-bit G component in byte 1, and an 8-bit R component in byte 2.
/// - [`B8G8R8Srgb`] specifies a three-component, 24-bit unsigned normalized format that has an
///   8-bit B component stored with sRGB nonlinear encoding in byte 0, an 8-bit G component stored
///   with sRGB nonlinear encoding in byte 1, and an 8-bit R component stored with sRGB nonlinear
///   encoding in byte 2.
/// - [`R8G8B8A8Unorm`] specifies a four-component, 32-bit unsigned normalized format that has an
///   8-bit R component in byte 0, an 8-bit G component in byte 1, an 8-bit B component in byte 2,
///   and an 8-bit A component in byte 3.
/// - [`R8G8B8A8Snorm`] specifies a four-component, 32-bit signed normalized format that has an
///   8-bit R component in byte 0, an 8-bit G component in byte 1, an 8-bit B component in byte 2,
///   and an 8-bit A component in byte 3.
/// - [`R8G8B8A8Uscaled`] specifies a four-component, 32-bit unsigned scaled format that has an
///   8-bit R component in byte 0, an 8-bit G component in byte 1, an 8-bit B component in byte 2,
///   and an 8-bit A component in byte 3.
/// - [`R8G8B8A8Sscaled`] specifies a four-component, 32-bit signed scaled format that has an 8-bit
///   R component in byte 0, an 8-bit G component in byte 1, an 8-bit B component in byte 2, and an
///   8-bit A component in byte 3.
/// - [`R8G8B8A8Uint`] specifies a four-component, 32-bit unsigned integer format that has an 8-bit
///   R component in byte 0, an 8-bit G component in byte 1, an 8-bit B component in byte 2, and an
///   8-bit A component in byte 3.
/// - [`R8G8B8A8Sint`] specifies a four-component, 32-bit signed integer format that has an 8-bit R
///   component in byte 0, an 8-bit G component in byte 1, an 8-bit B component in byte 2, and an
///   8-bit A component in byte 3.
/// - [`R8G8B8A8Srgb`] specifies a four-component, 32-bit unsigned normalized format that has an
///   8-bit R component stored with sRGB nonlinear encoding in byte 0, an 8-bit G component stored
///   with sRGB nonlinear encoding in byte 1, an 8-bit B component stored with sRGB nonlinear
///   encoding in byte 2, and an 8-bit A component in byte 3.
/// - [`B8G8R8A8Unorm`] specifies a four-component, 32-bit unsigned normalized format that has an
///   8-bit B component in byte 0, an 8-bit G component in byte 1, an 8-bit R component in byte 2,
///   and an 8-bit A component in byte 3.
/// - [`B8G8R8A8Snorm`] specifies a four-component, 32-bit signed normalized format that has an
///   8-bit B component in byte 0, an 8-bit G component in byte 1, an 8-bit R component in byte 2,
///   and an 8-bit A component in byte 3.
/// - [`B8G8R8A8Uscaled`] specifies a four-component, 32-bit unsigned scaled format that has an
///   8-bit B component in byte 0, an 8-bit G component in byte 1, an 8-bit R component in byte 2,
///   and an 8-bit A component in byte 3.
/// - [`B8G8R8A8Sscaled`] specifies a four-component, 32-bit signed scaled format that has an 8-bit
///   B component in byte 0, an 8-bit G component in byte 1, an 8-bit R component in byte 2, and an
///   8-bit A component in byte 3.
/// - [`B8G8R8A8Uint`] specifies a four-component, 32-bit unsigned integer format that has an 8-bit
///   B component in byte 0, an 8-bit G component in byte 1, an 8-bit R component in byte 2, and an
///   8-bit A component in byte 3.
/// - [`B8G8R8A8Sint`] specifies a four-component, 32-bit signed integer format that has an 8-bit B
///   component in byte 0, an 8-bit G component in byte 1, an 8-bit R component in byte 2, and an
///   8-bit A component in byte 3.
/// - [`B8G8R8A8Srgb`] specifies a four-component, 32-bit unsigned normalized format that has an
///   8-bit B component stored with sRGB nonlinear encoding in byte 0, an 8-bit G component stored
///   with sRGB nonlinear encoding in byte 1, an 8-bit R component stored with sRGB nonlinear
///   encoding in byte 2, and an 8-bit A component in byte 3.
/// - [`A8B8G8R8UnormPack32`] specifies a four-component, 32-bit packed unsigned normalized format
///   that has an 8-bit A component in bits 24..31, an 8-bit B component in bits 16..23, an 8-bit G
///   component in bits 8..15, and an 8-bit R component in bits 0..7.
/// - [`A8B8G8R8SnormPack32`] specifies a four-component, 32-bit packed signed normalized format
///   that has an 8-bit A component in bits 24..31, an 8-bit B component in bits 16..23, an 8-bit G
///   component in bits 8..15, and an 8-bit R component in bits 0..7.
/// - [`A8B8G8R8UscaledPack32`] specifies a four-component, 32-bit packed unsigned scaled integer
///   format that has an 8-bit A component in bits 24..31, an 8-bit B component in bits 16..23, an
///   8-bit G component in bits 8..15, and an 8-bit R component in bits 0..7.
/// - [`A8B8G8R8SscaledPack32`] specifies a four-component, 32-bit packed signed scaled integer
///   format that has an 8-bit A component in bits 24..31, an 8-bit B component in bits 16..23, an
///   8-bit G component in bits 8..15, and an 8-bit R component in bits 0..7.
/// - [`A8B8G8R8UintPack32`] specifies a four-component, 32-bit packed unsigned integer format that
///   has an 8-bit A component in bits 24..31, an 8-bit B component in bits 16..23, an 8-bit G
///   component in bits 8..15, and an 8-bit R component in bits 0..7.
/// - [`A8B8G8R8SintPack32`] specifies a four-component, 32-bit packed signed integer format that
///   has an 8-bit A component in bits 24..31, an 8-bit B component in bits 16..23, an 8-bit G
///   component in bits 8..15, and an 8-bit R component in bits 0..7.
/// - [`A8B8G8R8SrgbPack32`] specifies a four-component, 32-bit packed unsigned normalized format
///   that has an 8-bit A component in bits 24..31, an 8-bit B component stored with sRGB nonlinear
///   encoding in bits 16..23, an 8-bit G component stored with sRGB nonlinear encoding in bits
///   8..15, and an 8-bit R component stored with sRGB nonlinear encoding in bits 0..7.
/// - [`A2R10G10B10UnormPack32`] specifies a four-component, 32-bit packed unsigned normalized
///   format that has a 2-bit A component in bits 30..31, a 10-bit R component in bits 20..29, a
///   10-bit G component in bits 10..19, and a 10-bit B component in bits 0..9.
/// - [`A2R10G10B10SnormPack32`] specifies a four-component, 32-bit packed signed normalized format
///   that has a 2-bit A component in bits 30..31, a 10-bit R component in bits 20..29, a 10-bit G
///   component in bits 10..19, and a 10-bit B component in bits 0..9.
/// - [`A2R10G10B10UscaledPack32`] specifies a four-component, 32-bit packed unsigned scaled integer
///   format that has a 2-bit A component in bits 30..31, a 10-bit R component in bits 20..29, a
///   10-bit G component in bits 10..19, and a 10-bit B component in bits 0..9.
/// - [`A2R10G10B10SscaledPack32`] specifies a four-component, 32-bit packed signed scaled integer
///   format that has a 2-bit A component in bits 30..31, a 10-bit R component in bits 20..29, a
///   10-bit G component in bits 10..19, and a 10-bit B component in bits 0..9.
/// - [`A2R10G10B10UintPack32`] specifies a four-component, 32-bit packed unsigned integer format
///   that has a 2-bit A component in bits 30..31, a 10-bit R component in bits 20..29, a 10-bit G
///   component in bits 10..19, and a 10-bit B component in bits 0..9.
/// - [`A2R10G10B10SintPack32`] specifies a four-component, 32-bit packed signed integer format that
///   has a 2-bit A component in bits 30..31, a 10-bit R component in bits 20..29, a 10-bit G
///   component in bits 10..19, and a 10-bit B component in bits 0..9.
/// - [`A2B10G10R10UnormPack32`] specifies a four-component, 32-bit packed unsigned normalized
///   format that has a 2-bit A component in bits 30..31, a 10-bit B component in bits 20..29, a
///   10-bit G component in bits 10..19, and a 10-bit R component in bits 0..9.
/// - [`A2B10G10R10SnormPack32`] specifies a four-component, 32-bit packed signed normalized format
///   that has a 2-bit A component in bits 30..31, a 10-bit B component in bits 20..29, a 10-bit G
///   component in bits 10..19, and a 10-bit R component in bits 0..9.
/// - [`A2B10G10R10UscaledPack32`] specifies a four-component, 32-bit packed unsigned scaled integer
///   format that has a 2-bit A component in bits 30..31, a 10-bit B component in bits 20..29, a
///   10-bit G component in bits 10..19, and a 10-bit R component in bits 0..9.
/// - [`A2B10G10R10SscaledPack32`] specifies a four-component, 32-bit packed signed scaled integer
///   format that has a 2-bit A component in bits 30..31, a 10-bit B component in bits 20..29, a
///   10-bit G component in bits 10..19, and a 10-bit R component in bits 0..9.
/// - [`A2B10G10R10UintPack32`] specifies a four-component, 32-bit packed unsigned integer format
///   that has a 2-bit A component in bits 30..31, a 10-bit B component in bits 20..29, a 10-bit G
///   component in bits 10..19, and a 10-bit R component in bits 0..9.
/// - [`A2B10G10R10SintPack32`] specifies a four-component, 32-bit packed signed integer format that
///   has a 2-bit A component in bits 30..31, a 10-bit B component in bits 20..29, a 10-bit G
///   component in bits 10..19, and a 10-bit R component in bits 0..9.
/// - [`R16Unorm`] specifies a one-component, 16-bit unsigned normalized format that has a single
///   16-bit R component.
/// - [`R16Snorm`] specifies a one-component, 16-bit signed normalized format that has a single
///   16-bit R component.
/// - [`R16Uscaled`] specifies a one-component, 16-bit unsigned scaled integer format that has a
///   single 16-bit R component.
/// - [`R16Sscaled`] specifies a one-component, 16-bit signed scaled integer format that has a
///   single 16-bit R component.
/// - [`R16Uint`] specifies a one-component, 16-bit unsigned integer format that has a single 16-bit
///   R component.
/// - [`R16Sint`] specifies a one-component, 16-bit signed integer format that has a single 16-bit R
///   component.
/// - [`R16Sfloat`] specifies a one-component, 16-bit signed floating-point format that has a single
///   16-bit R component.
/// - [`R16G16Unorm`] specifies a two-component, 32-bit unsigned normalized format that has a 16-bit
///   R component in bytes 0..1, and a 16-bit G component in bytes 2..3.
/// - [`R16G16Snorm`] specifies a two-component, 32-bit signed normalized format that has a 16-bit R
///   component in bytes 0..1, and a 16-bit G component in bytes 2..3.
/// - [`R16G16Uscaled`] specifies a two-component, 32-bit unsigned scaled integer format that has a
///   16-bit R component in bytes 0..1, and a 16-bit G component in bytes 2..3.
/// - [`R16G16Sscaled`] specifies a two-component, 32-bit signed scaled integer format that has a
///   16-bit R component in bytes 0..1, and a 16-bit G component in bytes 2..3.
/// - [`R16G16Uint`] specifies a two-component, 32-bit unsigned integer format that has a 16-bit R
///   component in bytes 0..1, and a 16-bit G component in bytes 2..3.
/// - [`R16G16Sint`] specifies a two-component, 32-bit signed integer format that has a 16-bit R
///   component in bytes 0..1, and a 16-bit G component in bytes 2..3.
/// - [`R16G16Sfloat`] specifies a two-component, 32-bit signed floating-point format that has a
///   16-bit R component in bytes 0..1, and a 16-bit G component in bytes 2..3.
/// - [`R16G16B16Unorm`] specifies a three-component, 48-bit unsigned normalized format that has a
///   16-bit R component in bytes 0..1, a 16-bit G component in bytes 2..3, and a 16-bit B component
///   in bytes 4..5.
/// - [`R16G16B16Snorm`] specifies a three-component, 48-bit signed normalized format that has a
///   16-bit R component in bytes 0..1, a 16-bit G component in bytes 2..3, and a 16-bit B component
///   in bytes 4..5.
/// - [`R16G16B16Uscaled`] specifies a three-component, 48-bit unsigned scaled integer format that
///   has a 16-bit R component in bytes 0..1, a 16-bit G component in bytes 2..3, and a 16-bit B
///   component in bytes 4..5.
/// - [`R16G16B16Sscaled`] specifies a three-component, 48-bit signed scaled integer format that has
///   a 16-bit R component in bytes 0..1, a 16-bit G component in bytes 2..3, and a 16-bit B
///   component in bytes 4..5.
/// - [`R16G16B16Uint`] specifies a three-component, 48-bit unsigned integer format that has a
///   16-bit R component in bytes 0..1, a 16-bit G component in bytes 2..3, and a 16-bit B component
///   in bytes 4..5.
/// - [`R16G16B16Sint`] specifies a three-component, 48-bit signed integer format that has a 16-bit
///   R component in bytes 0..1, a 16-bit G component in bytes 2..3, and a 16-bit B component in
///   bytes 4..5.
/// - [`R16G16B16Sfloat`] specifies a three-component, 48-bit signed floating-point format that has
///   a 16-bit R component in bytes 0..1, a 16-bit G component in bytes 2..3, and a 16-bit B
///   component in bytes 4..5.
/// - [`R16G16B16A16Unorm`] specifies a four-component, 64-bit unsigned normalized format that has a
///   16-bit R component in bytes 0..1, a 16-bit G component in bytes 2..3, a 16-bit B component in
///   bytes 4..5, and a 16-bit A component in bytes 6..7.
/// - [`R16G16B16A16Snorm`] specifies a four-component, 64-bit signed normalized format that has a
///   16-bit R component in bytes 0..1, a 16-bit G component in bytes 2..3, a 16-bit B component in
///   bytes 4..5, and a 16-bit A component in bytes 6..7.
/// - [`R16G16B16A16Uscaled`] specifies a four-component, 64-bit unsigned scaled integer format that
///   has a 16-bit R component in bytes 0..1, a 16-bit G component in bytes 2..3, a 16-bit B
///   component in bytes 4..5, and a 16-bit A component in bytes 6..7.
/// - [`R16G16B16A16Sscaled`] specifies a four-component, 64-bit signed scaled integer format that
///   has a 16-bit R component in bytes 0..1, a 16-bit G component in bytes 2..3, a 16-bit B
///   component in bytes 4..5, and a 16-bit A component in bytes 6..7.
/// - [`R16G16B16A16Uint`] specifies a four-component, 64-bit unsigned integer format that has a
///   16-bit R component in bytes 0..1, a 16-bit G component in bytes 2..3, a 16-bit B component in
///   bytes 4..5, and a 16-bit A component in bytes 6..7.
/// - [`R16G16B16A16Sint`] specifies a four-component, 64-bit signed integer format that has a
///   16-bit R component in bytes 0..1, a 16-bit G component in bytes 2..3, a 16-bit B component in
///   bytes 4..5, and a 16-bit A component in bytes 6..7.
/// - [`R16G16B16A16Sfloat`] specifies a four-component, 64-bit signed floating-point format that
///   has a 16-bit R component in bytes 0..1, a 16-bit G component in bytes 2..3, a 16-bit B
///   component in bytes 4..5, and a 16-bit A component in bytes 6..7.
/// - [`R32Uint`] specifies a one-component, 32-bit unsigned integer format that has a single 32-bit
///   R component.
/// - [`R32Sint`] specifies a one-component, 32-bit signed integer format that has a single 32-bit R
///   component.
/// - [`R32Sfloat`] specifies a one-component, 32-bit signed floating-point format that has a single
///   32-bit R component.
/// - [`R32G32Uint`] specifies a two-component, 64-bit unsigned integer format that has a 32-bit R
///   component in bytes 0..3, and a 32-bit G component in bytes 4..7.
/// - [`R32G32Sint`] specifies a two-component, 64-bit signed integer format that has a 32-bit R
///   component in bytes 0..3, and a 32-bit G component in bytes 4..7.
/// - [`R32G32Sfloat`] specifies a two-component, 64-bit signed floating-point format that has a
///   32-bit R component in bytes 0..3, and a 32-bit G component in bytes 4..7.
/// - [`R32G32B32Uint`] specifies a three-component, 96-bit unsigned integer format that has a
///   32-bit R component in bytes 0..3, a 32-bit G component in bytes 4..7, and a 32-bit B component
///   in bytes 8..11.
/// - [`R32G32B32Sint`] specifies a three-component, 96-bit signed integer format that has a 32-bit
///   R component in bytes 0..3, a 32-bit G component in bytes 4..7, and a 32-bit B component in
///   bytes 8..11.
/// - [`R32G32B32Sfloat`] specifies a three-component, 96-bit signed floating-point format that has
///   a 32-bit R component in bytes 0..3, a 32-bit G component in bytes 4..7, and a 32-bit B
///   component in bytes 8..11.
/// - [`R32G32B32A32Uint`] specifies a four-component, 128-bit unsigned integer format that has a
///   32-bit R component in bytes 0..3, a 32-bit G component in bytes 4..7, a 32-bit B component in
///   bytes 8..11, and a 32-bit A component in bytes 12..15.
/// - [`R32G32B32A32Sint`] specifies a four-component, 128-bit signed integer format that has a
///   32-bit R component in bytes 0..3, a 32-bit G component in bytes 4..7, a 32-bit B component in
///   bytes 8..11, and a 32-bit A component in bytes 12..15.
/// - [`R32G32B32A32Sfloat`] specifies a four-component, 128-bit signed floating-point format that
///   has a 32-bit R component in bytes 0..3, a 32-bit G component in bytes 4..7, a 32-bit B
///   component in bytes 8..11, and a 32-bit A component in bytes 12..15.
/// - [`R64Uint`] specifies a one-component, 64-bit unsigned integer format that has a single 64-bit
///   R component.
/// - [`R64Sint`] specifies a one-component, 64-bit signed integer format that has a single 64-bit R
///   component.
/// - [`R64Sfloat`] specifies a one-component, 64-bit signed floating-point format that has a single
///   64-bit R component.
/// - [`R64G64Uint`] specifies a two-component, 128-bit unsigned integer format that has a 64-bit R
///   component in bytes 0..7, and a 64-bit G component in bytes 8..15.
/// - [`R64G64Sint`] specifies a two-component, 128-bit signed integer format that has a 64-bit R
///   component in bytes 0..7, and a 64-bit G component in bytes 8..15.
/// - [`R64G64Sfloat`] specifies a two-component, 128-bit signed floating-point format that has a
///   64-bit R component in bytes 0..7, and a 64-bit G component in bytes 8..15.
/// - [`R64G64B64Uint`] specifies a three-component, 192-bit unsigned integer format that has a
///   64-bit R component in bytes 0..7, a 64-bit G component in bytes 8..15, and a 64-bit B
///   component in bytes 16..23.
/// - [`R64G64B64Sint`] specifies a three-component, 192-bit signed integer format that has a 64-bit
///   R component in bytes 0..7, a 64-bit G component in bytes 8..15, and a 64-bit B component in
///   bytes 16..23.
/// - [`R64G64B64Sfloat`] specifies a three-component, 192-bit signed floating-point format that has
///   a 64-bit R component in bytes 0..7, a 64-bit G component in bytes 8..15, and a 64-bit B
///   component in bytes 16..23.
/// - [`R64G64B64A64Uint`] specifies a four-component, 256-bit unsigned integer format that has a
///   64-bit R component in bytes 0..7, a 64-bit G component in bytes 8..15, a 64-bit B component in
///   bytes 16..23, and a 64-bit A component in bytes 24..31.
/// - [`R64G64B64A64Sint`] specifies a four-component, 256-bit signed integer format that has a
///   64-bit R component in bytes 0..7, a 64-bit G component in bytes 8..15, a 64-bit B component in
///   bytes 16..23, and a 64-bit A component in bytes 24..31.
/// - [`R64G64B64A64Sfloat`] specifies a four-component, 256-bit signed floating-point format that
///   has a 64-bit R component in bytes 0..7, a 64-bit G component in bytes 8..15, a 64-bit B
///   component in bytes 16..23, and a 64-bit A component in bytes 24..31.
/// - [`B10G11R11UfloatPack32`] specifies a three-component, 32-bit packed unsigned floating-point format that has a 10-bit B component in bits 22..31, an 11-bit G component in bits 11..21, an 11-bit R component in bits 0..10. See [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fundamentals-fp10](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fundamentals-fp10) and [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fundamentals-fp11](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fundamentals-fp11).
/// - [`E5B9G9R9UfloatPack32`] specifies a three-component, 32-bit packed unsigned floating-point
///   format that has a 5-bit shared exponent in bits 27..31, a 9-bit B component mantissa in bits
///   18..26, a 9-bit G component mantissa in bits 9..17, and a 9-bit R component mantissa in bits
///   0..8.
/// - [`D16Unorm`] specifies a one-component, 16-bit unsigned normalized format that has a single
///   16-bit depth component.
/// - [`X8D24UnormPack32`] specifies a two-component, 32-bit format that has 24 unsigned normalized
///   bits in the depth component and,  **optionally** , 8 bits that are unused.
/// - [`D32Sfloat`] specifies a one-component, 32-bit signed floating-point format that has 32 bits
///   in the depth component.
/// - [`S8Uint`] specifies a one-component, 8-bit unsigned integer format that has 8 bits in the
///   stencil component.
/// - [`D16UnormS8Uint`] specifies a two-component, 24-bit format that has 16 unsigned normalized
///   bits in the depth component and 8 unsigned integer bits in the stencil component.
/// - [`D24UnormS8Uint`] specifies a two-component, 32-bit packed format that has 8 unsigned integer
///   bits in the stencil component, and 24 unsigned normalized bits in the depth component.
/// - [`D32SfloatS8Uint`] specifies a two-component format that has 32 signed float bits in the
///   depth component and 8 unsigned integer bits in the stencil component. There are
///   **optionally**  24 bits that are unused.
/// - [`Bc1RgbUnormBlock`] specifies a three-component, block-compressed format where each 64-bit
///   compressed texel block encodes a 4×4 rectangle of unsigned normalized RGB texel data. This
///   format has no alpha and is considered opaque.
/// - [`Bc1RgbSrgbBlock`] specifies a three-component, block-compressed format where each 64-bit
///   compressed texel block encodes a 4×4 rectangle of unsigned normalized RGB texel data with sRGB
///   nonlinear encoding. This format has no alpha and is considered opaque.
/// - [`Bc1RgbaUnormBlock`] specifies a four-component, block-compressed format where each 64-bit
///   compressed texel block encodes a 4×4 rectangle of unsigned normalized RGB texel data, and
///   provides 1 bit of alpha.
/// - [`Bc1RgbaSrgbBlock`] specifies a four-component, block-compressed format where each 64-bit
///   compressed texel block encodes a 4×4 rectangle of unsigned normalized RGB texel data with sRGB
///   nonlinear encoding, and provides 1 bit of alpha.
/// - [`Bc2UnormBlock`] specifies a four-component, block-compressed format where each 128-bit
///   compressed texel block encodes a 4×4 rectangle of unsigned normalized RGBA texel data with the
///   first 64 bits encoding alpha values followed by 64 bits encoding RGB values.
/// - [`Bc2SrgbBlock`] specifies a four-component, block-compressed format where each 128-bit
///   compressed texel block encodes a 4×4 rectangle of unsigned normalized RGBA texel data with the
///   first 64 bits encoding alpha values followed by 64 bits encoding RGB values with sRGB
///   nonlinear encoding.
/// - [`Bc3UnormBlock`] specifies a four-component, block-compressed format where each 128-bit
///   compressed texel block encodes a 4×4 rectangle of unsigned normalized RGBA texel data with the
///   first 64 bits encoding alpha values followed by 64 bits encoding RGB values.
/// - [`Bc3SrgbBlock`] specifies a four-component, block-compressed format where each 128-bit
///   compressed texel block encodes a 4×4 rectangle of unsigned normalized RGBA texel data with the
///   first 64 bits encoding alpha values followed by 64 bits encoding RGB values with sRGB
///   nonlinear encoding.
/// - [`Bc4UnormBlock`] specifies a one-component, block-compressed format where each 64-bit
///   compressed texel block encodes a 4×4 rectangle of unsigned normalized red texel data.
/// - [`Bc4SnormBlock`] specifies a one-component, block-compressed format where each 64-bit
///   compressed texel block encodes a 4×4 rectangle of signed normalized red texel data.
/// - [`Bc5UnormBlock`] specifies a two-component, block-compressed format where each 128-bit
///   compressed texel block encodes a 4×4 rectangle of unsigned normalized RG texel data with the
///   first 64 bits encoding red values followed by 64 bits encoding green values.
/// - [`Bc5SnormBlock`] specifies a two-component, block-compressed format where each 128-bit
///   compressed texel block encodes a 4×4 rectangle of signed normalized RG texel data with the
///   first 64 bits encoding red values followed by 64 bits encoding green values.
/// - [`Bc6HUfloatBlock`] specifies a three-component, block-compressed format where each 128-bit
///   compressed texel block encodes a 4×4 rectangle of unsigned floating-point RGB texel data.
/// - [`Bc6HSfloatBlock`] specifies a three-component, block-compressed format where each 128-bit
///   compressed texel block encodes a 4×4 rectangle of signed floating-point RGB texel data.
/// - [`Bc7UnormBlock`] specifies a four-component, block-compressed format where each 128-bit
///   compressed texel block encodes a 4×4 rectangle of unsigned normalized RGBA texel data.
/// - [`Bc7SrgbBlock`] specifies a four-component, block-compressed format where each 128-bit
///   compressed texel block encodes a 4×4 rectangle of unsigned normalized RGBA texel data with
///   sRGB nonlinear encoding applied to the RGB components.
/// - [`Etc2R8G8B8UnormBlock`] specifies a three-component, ETC2 compressed format where each 64-bit
///   compressed texel block encodes a 4×4 rectangle of unsigned normalized RGB texel data. This
///   format has no alpha and is considered opaque.
/// - [`Etc2R8G8B8SrgbBlock`] specifies a three-component, ETC2 compressed format where each 64-bit
///   compressed texel block encodes a 4×4 rectangle of unsigned normalized RGB texel data with sRGB
///   nonlinear encoding. This format has no alpha and is considered opaque.
/// - [`Etc2R8G8B8A1UnormBlock`] specifies a four-component, ETC2 compressed format where each
///   64-bit compressed texel block encodes a 4×4 rectangle of unsigned normalized RGB texel data,
///   and provides 1 bit of alpha.
/// - [`Etc2R8G8B8A1SrgbBlock`] specifies a four-component, ETC2 compressed format where each 64-bit
///   compressed texel block encodes a 4×4 rectangle of unsigned normalized RGB texel data with sRGB
///   nonlinear encoding, and provides 1 bit of alpha.
/// - [`Etc2R8G8B8A8UnormBlock`] specifies a four-component, ETC2 compressed format where each
///   128-bit compressed texel block encodes a 4×4 rectangle of unsigned normalized RGBA texel data
///   with the first 64 bits encoding alpha values followed by 64 bits encoding RGB values.
/// - [`Etc2R8G8B8A8SrgbBlock`] specifies a four-component, ETC2 compressed format where each
///   128-bit compressed texel block encodes a 4×4 rectangle of unsigned normalized RGBA texel data
///   with the first 64 bits encoding alpha values followed by 64 bits encoding RGB values with sRGB
///   nonlinear encoding applied.
/// - [`EacR11UnormBlock`] specifies a one-component, ETC2 compressed format where each 64-bit
///   compressed texel block encodes a 4×4 rectangle of unsigned normalized red texel data.
/// - [`EacR11SnormBlock`] specifies a one-component, ETC2 compressed format where each 64-bit
///   compressed texel block encodes a 4×4 rectangle of signed normalized red texel data.
/// - [`EacR11G11UnormBlock`] specifies a two-component, ETC2 compressed format where each 128-bit
///   compressed texel block encodes a 4×4 rectangle of unsigned normalized RG texel data with the
///   first 64 bits encoding red values followed by 64 bits encoding green values.
/// - [`EacR11G11SnormBlock`] specifies a two-component, ETC2 compressed format where each 128-bit
///   compressed texel block encodes a 4×4 rectangle of signed normalized RG texel data with the
///   first 64 bits encoding red values followed by 64 bits encoding green values.
/// - [`Astc4X4UnormBlock`] specifies a four-component, ASTC compressed format where each 128-bit
///   compressed texel block encodes a 4×4 rectangle of unsigned normalized RGBA texel data.
/// - [`Astc4X4SrgbBlock`] specifies a four-component, ASTC compressed format where each 128-bit
///   compressed texel block encodes a 4×4 rectangle of unsigned normalized RGBA texel data with
///   sRGB nonlinear encoding applied to the RGB components.
/// - [`Astc4X4SfloatBlock`] specifies a four-component, ASTC compressed format where each 128-bit
///   compressed texel block encodes a 4×4 rectangle of signed floating-point RGBA texel data.
/// - [`Astc5X4UnormBlock`] specifies a four-component, ASTC compressed format where each 128-bit
///   compressed texel block encodes a 5×4 rectangle of unsigned normalized RGBA texel data.
/// - [`Astc5X4SrgbBlock`] specifies a four-component, ASTC compressed format where each 128-bit
///   compressed texel block encodes a 5×4 rectangle of unsigned normalized RGBA texel data with
///   sRGB nonlinear encoding applied to the RGB components.
/// - [`Astc5X4SfloatBlock`] specifies a four-component, ASTC compressed format where each 128-bit
///   compressed texel block encodes a 5×4 rectangle of signed floating-point RGBA texel data.
/// - [`Astc5X5UnormBlock`] specifies a four-component, ASTC compressed format where each 128-bit
///   compressed texel block encodes a 5×5 rectangle of unsigned normalized RGBA texel data.
/// - [`Astc5X5SrgbBlock`] specifies a four-component, ASTC compressed format where each 128-bit
///   compressed texel block encodes a 5×5 rectangle of unsigned normalized RGBA texel data with
///   sRGB nonlinear encoding applied to the RGB components.
/// - [`Astc5X5SfloatBlock`] specifies a four-component, ASTC compressed format where each 128-bit
///   compressed texel block encodes a 5×5 rectangle of signed floating-point RGBA texel data.
/// - [`Astc6X5UnormBlock`] specifies a four-component, ASTC compressed format where each 128-bit
///   compressed texel block encodes a 6×5 rectangle of unsigned normalized RGBA texel data.
/// - [`Astc6X5SrgbBlock`] specifies a four-component, ASTC compressed format where each 128-bit
///   compressed texel block encodes a 6×5 rectangle of unsigned normalized RGBA texel data with
///   sRGB nonlinear encoding applied to the RGB components.
/// - [`Astc6X5SfloatBlock`] specifies a four-component, ASTC compressed format where each 128-bit
///   compressed texel block encodes a 6×5 rectangle of signed floating-point RGBA texel data.
/// - [`Astc6X6UnormBlock`] specifies a four-component, ASTC compressed format where each 128-bit
///   compressed texel block encodes a 6×6 rectangle of unsigned normalized RGBA texel data.
/// - [`Astc6X6SrgbBlock`] specifies a four-component, ASTC compressed format where each 128-bit
///   compressed texel block encodes a 6×6 rectangle of unsigned normalized RGBA texel data with
///   sRGB nonlinear encoding applied to the RGB components.
/// - [`Astc6X6SfloatBlock`] specifies a four-component, ASTC compressed format where each 128-bit
///   compressed texel block encodes a 6×6 rectangle of signed floating-point RGBA texel data.
/// - [`Astc8X5UnormBlock`] specifies a four-component, ASTC compressed format where each 128-bit
///   compressed texel block encodes an 8×5 rectangle of unsigned normalized RGBA texel data.
/// - [`Astc8X5SrgbBlock`] specifies a four-component, ASTC compressed format where each 128-bit
///   compressed texel block encodes an 8×5 rectangle of unsigned normalized RGBA texel data with
///   sRGB nonlinear encoding applied to the RGB components.
/// - [`Astc8X5SfloatBlock`] specifies a four-component, ASTC compressed format where each 128-bit
///   compressed texel block encodes a 8×5 rectangle of signed floating-point RGBA texel data.
/// - [`Astc8X6UnormBlock`] specifies a four-component, ASTC compressed format where each 128-bit
///   compressed texel block encodes an 8×6 rectangle of unsigned normalized RGBA texel data.
/// - [`Astc8X6SrgbBlock`] specifies a four-component, ASTC compressed format where each 128-bit
///   compressed texel block encodes an 8×6 rectangle of unsigned normalized RGBA texel data with
///   sRGB nonlinear encoding applied to the RGB components.
/// - [`Astc8X6SfloatBlock`] specifies a four-component, ASTC compressed format where each 128-bit
///   compressed texel block encodes a 8×6 rectangle of signed floating-point RGBA texel data.
/// - [`Astc8X8UnormBlock`] specifies a four-component, ASTC compressed format where each 128-bit
///   compressed texel block encodes an 8×8 rectangle of unsigned normalized RGBA texel data.
/// - [`Astc8X8SrgbBlock`] specifies a four-component, ASTC compressed format where each 128-bit
///   compressed texel block encodes an 8×8 rectangle of unsigned normalized RGBA texel data with
///   sRGB nonlinear encoding applied to the RGB components.
/// - [`Astc8X8SfloatBlock`] specifies a four-component, ASTC compressed format where each 128-bit
///   compressed texel block encodes a 8×8 rectangle of signed floating-point RGBA texel data.
/// - [`Astc10X5UnormBlock`] specifies a four-component, ASTC compressed format where each 128-bit
///   compressed texel block encodes a 10×5 rectangle of unsigned normalized RGBA texel data.
/// - [`Astc10X5SrgbBlock`] specifies a four-component, ASTC compressed format where each 128-bit
///   compressed texel block encodes a 10×5 rectangle of unsigned normalized RGBA texel data with
///   sRGB nonlinear encoding applied to the RGB components.
/// - [`Astc10X5SfloatBlock`] specifies a four-component, ASTC compressed format where each 128-bit
///   compressed texel block encodes a 10×5 rectangle of signed floating-point RGBA texel data.
/// - [`Astc10X6UnormBlock`] specifies a four-component, ASTC compressed format where each 128-bit
///   compressed texel block encodes a 10×6 rectangle of unsigned normalized RGBA texel data.
/// - [`Astc10X6SrgbBlock`] specifies a four-component, ASTC compressed format where each 128-bit
///   compressed texel block encodes a 10×6 rectangle of unsigned normalized RGBA texel data with
///   sRGB nonlinear encoding applied to the RGB components.
/// - [`Astc10X6SfloatBlock`] specifies a four-component, ASTC compressed format where each 128-bit
///   compressed texel block encodes a 10×6 rectangle of signed floating-point RGBA texel data.
/// - [`Astc10X8UnormBlock`] specifies a four-component, ASTC compressed format where each 128-bit
///   compressed texel block encodes a 10×8 rectangle of unsigned normalized RGBA texel data.
/// - [`Astc10X8SrgbBlock`] specifies a four-component, ASTC compressed format where each 128-bit
///   compressed texel block encodes a 10×8 rectangle of unsigned normalized RGBA texel data with
///   sRGB nonlinear encoding applied to the RGB components.
/// - [`Astc10X8SfloatBlock`] specifies a four-component, ASTC compressed format where each 128-bit
///   compressed texel block encodes a 10×8 rectangle of signed floating-point RGBA texel data.
/// - [`Astc10X10UnormBlock`] specifies a four-component, ASTC compressed format where each 128-bit
///   compressed texel block encodes a 10×10 rectangle of unsigned normalized RGBA texel data.
/// - [`Astc10X10SrgbBlock`] specifies a four-component, ASTC compressed format where each 128-bit
///   compressed texel block encodes a 10×10 rectangle of unsigned normalized RGBA texel data with
///   sRGB nonlinear encoding applied to the RGB components.
/// - [`Astc10X10SfloatBlock`] specifies a four-component, ASTC compressed format where each 128-bit
///   compressed texel block encodes a 10×10 rectangle of signed floating-point RGBA texel data.
/// - [`Astc12X10UnormBlock`] specifies a four-component, ASTC compressed format where each 128-bit
///   compressed texel block encodes a 12×10 rectangle of unsigned normalized RGBA texel data.
/// - [`Astc12X10SrgbBlock`] specifies a four-component, ASTC compressed format where each 128-bit
///   compressed texel block encodes a 12×10 rectangle of unsigned normalized RGBA texel data with
///   sRGB nonlinear encoding applied to the RGB components.
/// - [`Astc12X10SfloatBlock`] specifies a four-component, ASTC compressed format where each 128-bit
///   compressed texel block encodes a 12×10 rectangle of signed floating-point RGBA texel data.
/// - [`Astc12X12UnormBlock`] specifies a four-component, ASTC compressed format where each 128-bit
///   compressed texel block encodes a 12×12 rectangle of unsigned normalized RGBA texel data.
/// - [`Astc12X12SrgbBlock`] specifies a four-component, ASTC compressed format where each 128-bit
///   compressed texel block encodes a 12×12 rectangle of unsigned normalized RGBA texel data with
///   sRGB nonlinear encoding applied to the RGB components.
/// - [`Astc12X12SfloatBlock`] specifies a four-component, ASTC compressed format where each 128-bit
///   compressed texel block encodes a 12×12 rectangle of signed floating-point RGBA texel data.
/// - [`G8B8G8R8422Unorm`] specifies a four-component, 32-bit format containing a pair of G
///   components, an R component, and a B component, collectively encoding a 2×1 rectangle of
///   unsigned normalized RGB texel data. One G value is present at each *i* coordinate, with the B
///   and R values shared across both G values and thus recorded at half the horizontal resolution
///   of the image. This format has an 8-bit G component for the even *i* coordinate in byte 0, an
///   8-bit B component in byte 1, an 8-bit G component for the odd *i* coordinate in byte 2, and an
///   8-bit R component in byte 3. This format only supports images with a width that is a multiple
///   of two. For the purposes of the constraints on copy extents, this format is treated as a
///   compressed format with a 2×1 compressed texel block.
/// - [`B8G8R8G8422Unorm`] specifies a four-component, 32-bit format containing a pair of G
///   components, an R component, and a B component, collectively encoding a 2×1 rectangle of
///   unsigned normalized RGB texel data. One G value is present at each *i* coordinate, with the B
///   and R values shared across both G values and thus recorded at half the horizontal resolution
///   of the image. This format has an 8-bit B component in byte 0, an 8-bit G component for the
///   even *i* coordinate in byte 1, an 8-bit R component in byte 2, and an 8-bit G component for
///   the odd *i* coordinate in byte 3. This format only supports images with a width that is a
///   multiple of two. For the purposes of the constraints on copy extents, this format is treated
///   as a compressed format with a 2×1 compressed texel block.
/// - [`G8B8R83Plane420Unorm`] specifies an unsigned normalized *multi-planar format* that has an
///   8-bit G component in plane 0, an 8-bit B component in plane 1, and an 8-bit R component in
///   plane 2. The horizontal and vertical dimensions of the R and B planes are halved relative to
///   the image dimensions, and each R and B component is shared with the G components for which
///   <span class="katex"><span aria-hidden="true" class="katex-html"><span class="base"><span
///   class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span
///   style="top:0em;" class="mopen delimcenter">⌊</span><span class="mord"><span class="mord
///   mathdefault">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span
///   class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span
///   style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span
///   style="height:2.7em;" class="pstrut"></span><span class="sizing reset-size6 size3
///   mtight"><span class="mord mathdefault mtight">G</span></span></span></span><span
///   class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist"
///   style="height:0.15em;"><span></span></span></span></span></span></span><span
///   style="margin-right:0.2222222222222222em;" class="mspace"></span><span
///   class="mbin">×</span><span style="margin-right:0.2222222222222222em;"
///   class="mspace"></span><span class="mord">0</span><span class="mord">.</span><span
///   class="mord">5</span><span style="top:0em;" class="mclose delimcenter">⌋</span></span><span
///   class="mspace" style="margin-right:0.2777777777777778em;"></span><span
///   class="mrel">=</span><span class="mspace"
///   style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span
///   class="strut" style="height:0.80952em;vertical-align:-0.15em;"></span><span class="mord"><span
///   class="mord mathdefault">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span
///   class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span
///   style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut"
///   style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord
///   mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span><span
///   class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist"
///   style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace"
///   style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span
///   class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span
///   class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.15em;"></span><span
///   class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span class="vlist-t
///   vlist-t2"><span class="vlist-r"><span style="height:0.32833099999999993em;"
///   class="vlist"><span
///   style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut"
///   style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord
///   mathdefault mtight" style="margin-right:0.00773em;">R</span></span></span></span><span
///   class="vlist-s">​</span></span><span class="vlist-r"><span style="height:0.15em;"
///   class="vlist"><span></span></span></span></span></span></span></span></span></span> and <span
///   class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span
///   class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span
///   style="top:0em;" class="mopen delimcenter">⌊</span><span class="mord"><span class="mord
///   mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span
///   class="vlist-t vlist-t2"><span class="vlist-r"><span style="height:0.32833099999999993em;"
///   class="vlist"><span
///   style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span
///   class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3
///   mtight"><span class="mord mathdefault mtight">G</span></span></span></span><span
///   class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist"
///   style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace"
///   style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span
///   class="mspace" style="margin-right:0.2222222222222222em;"></span><span
///   class="mord">0</span><span class="mord">.</span><span class="mord">5</span><span
///   style="top:0em;" class="mclose delimcenter">⌋</span></span><span
///   style="margin-right:0.2777777777777778em;" class="mspace"></span><span
///   class="mrel">=</span><span class="mspace"
///   style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span
///   class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span
///   class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span
///   class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist"
///   style="height:0.32833099999999993em;"><span
///   style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span
///   style="height:2.7em;" class="pstrut"></span><span class="sizing reset-size6 size3
///   mtight"><span class="mord mathdefault mtight"
///   style="margin-right:0.05017em;">B</span></span></span></span><span
///   class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist"
///   style="height:0.15em;"><span></span></span></span></span></span></span><span
///   style="margin-right:0.2777777777777778em;" class="mspace"></span><span
///   class="mrel">=</span><span class="mspace"
///   style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span
///   class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span
///   class="mord"><span style="margin-right:0.05724em;" class="mord mathdefault">j</span><span
///   class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist"
///   style="height:0.32833099999999993em;"><span
///   style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span
///   class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3
///   mtight"><span class="mord mathdefault mtight"
///   style="margin-right:0.00773em;">R</span></span></span></span><span
///   class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist"
///   style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>.
///   The location of each plane when this image is in linear layout can be determined via
///   [`GetImageSubresourceLayout`], using `VK_IMAGE_ASPECT_PLANE_0_BIT` for the G plane,
///   `VK_IMAGE_ASPECT_PLANE_1_BIT` for the B plane, and `VK_IMAGE_ASPECT_PLANE_2_BIT` for the R
///   plane. This format only supports images with a width and height that is a multiple of two.
/// - [`G8B8R82Plane420Unorm`] specifies an unsigned normalized *multi-planar format* that has an
///   8-bit G component in plane 0, and a two-component, 16-bit BR plane 1 consisting of an 8-bit B
///   component in byte 0 and an 8-bit R component in byte 1. The horizontal and vertical dimensions
///   of the BR plane are halved relative to the image dimensions, and each R and B value is shared
///   with the G components for which <span class="katex"><span class="katex-html"
///   aria-hidden="true"><span class="base"><span class="strut"
///   style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen
///   delimcenter" style="top:0em;">⌊</span><span class="mord"><span class="mord
///   mathdefault">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span
///   class="vlist-r"><span style="height:0.32833099999999993em;" class="vlist"><span
///   style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut"
///   style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord
///   mathdefault mtight">G</span></span></span></span><span class="vlist-s">​</span></span><span
///   class="vlist-r"><span style="height:0.15em;"
///   class="vlist"><span></span></span></span></span></span></span><span
///   style="margin-right:0.2222222222222222em;" class="mspace"></span><span
///   class="mbin">×</span><span style="margin-right:0.2222222222222222em;"
///   class="mspace"></span><span class="mord">0</span><span class="mord">.</span><span
///   class="mord">5</span><span class="mclose delimcenter" style="top:0em;">⌋</span></span><span
///   style="margin-right:0.2777777777777778em;" class="mspace"></span><span
///   class="mrel">=</span><span class="mspace"
///   style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span
///   style="height:0.80952em;vertical-align:-0.15em;" class="strut"></span><span class="mord"><span
///   class="mord mathdefault">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span
///   class="vlist-r"><span style="height:0.32833099999999993em;" class="vlist"><span
///   style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut"
///   style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span
///   style="margin-right:0.05017em;" class="mord mathdefault
///   mtight">B</span></span></span></span><span class="vlist-s">​</span></span><span
///   class="vlist-r"><span style="height:0.15em;"
///   class="vlist"><span></span></span></span></span></span></span><span
///   style="margin-right:0.2777777777777778em;" class="mspace"></span><span
///   class="mrel">=</span><span class="mspace"
///   style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span
///   class="strut" style="height:0.80952em;vertical-align:-0.15em;"></span><span class="mord"><span
///   class="mord mathdefault">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span
///   class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span
///   style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span
///   style="height:2.7em;" class="pstrut"></span><span class="sizing reset-size6 size3
///   mtight"><span style="margin-right:0.00773em;" class="mord mathdefault
///   mtight">R</span></span></span></span><span class="vlist-s">​</span></span><span
///   class="vlist-r"><span class="vlist"
///   style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>
///   and <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span
///   style="height:1em;vertical-align:-0.25em;" class="strut"></span><span class="minner"><span
///   style="top:0em;" class="mopen delimcenter">⌊</span><span class="mord"><span
///   style="margin-right:0.05724em;" class="mord mathdefault">j</span><span class="msupsub"><span
///   class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist"
///   style="height:0.32833099999999993em;"><span
///   style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span
///   class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3
///   mtight"><span class="mord mathdefault mtight">G</span></span></span></span><span
///   class="vlist-s">​</span></span><span class="vlist-r"><span style="height:0.15em;"
///   class="vlist"><span></span></span></span></span></span></span><span class="mspace"
///   style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span
///   style="margin-right:0.2222222222222222em;" class="mspace"></span><span
///   class="mord">0</span><span class="mord">.</span><span class="mord">5</span><span
///   style="top:0em;" class="mclose delimcenter">⌋</span></span><span class="mspace"
///   style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span
///   class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span
///   class="base"><span style="height:0.85396em;vertical-align:-0.19444em;"
///   class="strut"></span><span class="mord"><span style="margin-right:0.05724em;" class="mord
///   mathdefault">j</span><span class="msupsub"><span class="vlist-t vlist-t2"><span
///   class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span
///   style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span
///   style="height:2.7em;" class="pstrut"></span><span class="sizing reset-size6 size3
///   mtight"><span style="margin-right:0.05017em;" class="mord mathdefault
///   mtight">B</span></span></span></span><span class="vlist-s">​</span></span><span
///   class="vlist-r"><span class="vlist"
///   style="height:0.15em;"><span></span></span></span></span></span></span><span
///   style="margin-right:0.2777777777777778em;" class="mspace"></span><span
///   class="mrel">=</span><span class="mspace"
///   style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span
///   class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span
///   class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span
///   class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span
///   style="height:0.32833099999999993em;" class="vlist"><span
///   style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span
///   class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3
///   mtight"><span style="margin-right:0.00773em;" class="mord mathdefault
///   mtight">R</span></span></span></span><span class="vlist-s">​</span></span><span
///   class="vlist-r"><span style="height:0.15em;"
///   class="vlist"><span></span></span></span></span></span></span></span></span></span>. The
///   location of each plane when this image is in linear layout can be determined via
///   [`GetImageSubresourceLayout`], using `VK_IMAGE_ASPECT_PLANE_0_BIT` for the G plane, and
///   `VK_IMAGE_ASPECT_PLANE_1_BIT` for the BR plane. This format only supports images with a width
///   and height that is a multiple of two.
/// - [`G8B8R83Plane422Unorm`] specifies an unsigned normalized *multi-planar format* that has an
///   8-bit G component in plane 0, an 8-bit B component in plane 1, and an 8-bit R component in
///   plane 2. The horizontal dimension of the R and B plane is halved relative to the image
///   dimensions, and each R and B value is shared with the G components for which <span
///   class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span
///   style="height:1em;vertical-align:-0.25em;" class="strut"></span><span class="minner"><span
///   class="mopen delimcenter" style="top:0em;">⌊</span><span class="mord"><span class="mord
///   mathdefault">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span
///   class="vlist-r"><span style="height:0.32833099999999993em;" class="vlist"><span
///   style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut"
///   style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord
///   mathdefault mtight">G</span></span></span></span><span class="vlist-s">​</span></span><span
///   class="vlist-r"><span class="vlist"
///   style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace"
///   style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span
///   style="margin-right:0.2222222222222222em;" class="mspace"></span><span
///   class="mord">0</span><span class="mord">.</span><span class="mord">5</span><span class="mclose
///   delimcenter" style="top:0em;">⌋</span></span><span class="mspace"
///   style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span
///   style="margin-right:0.2777777777777778em;" class="mspace"></span></span><span
///   class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.15em;"></span><span
///   class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span class="vlist-t
///   vlist-t2"><span class="vlist-r"><span class="vlist"
///   style="height:0.32833099999999993em;"><span
///   style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span
///   style="height:2.7em;" class="pstrut"></span><span class="sizing reset-size6 size3
///   mtight"><span style="margin-right:0.05017em;" class="mord mathdefault
///   mtight">B</span></span></span></span><span class="vlist-s">​</span></span><span
///   class="vlist-r"><span style="height:0.15em;"
///   class="vlist"><span></span></span></span></span></span></span><span class="mspace"
///   style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span
///   style="margin-right:0.2777777777777778em;" class="mspace"></span></span><span
///   class="base"><span style="height:0.80952em;vertical-align:-0.15em;" class="strut"></span><span
///   class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span class="vlist-t
///   vlist-t2"><span class="vlist-r"><span style="height:0.32833099999999993em;"
///   class="vlist"><span
///   style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span
///   style="height:2.7em;" class="pstrut"></span><span class="sizing reset-size6 size3
///   mtight"><span class="mord mathdefault mtight"
///   style="margin-right:0.00773em;">R</span></span></span></span><span
///   class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist"
///   style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>.
///   The location of each plane when this image is in linear layout can be determined via
///   [`GetImageSubresourceLayout`], using `VK_IMAGE_ASPECT_PLANE_0_BIT` for the G plane,
///   `VK_IMAGE_ASPECT_PLANE_1_BIT` for the B plane, and `VK_IMAGE_ASPECT_PLANE_2_BIT` for the R
///   plane. This format only supports images with a width that is a multiple of two.
/// - [`G8B8R82Plane422Unorm`] specifies an unsigned normalized *multi-planar format* that has an
///   8-bit G component in plane 0, and a two-component, 16-bit BR plane 1 consisting of an 8-bit B
///   component in byte 0 and an 8-bit R component in byte 1. The horizontal dimension of the BR
///   plane is halved relative to the image dimensions, and each R and B value is shared with the G
///   components for which <span class="katex"><span class="katex-html" aria-hidden="true"><span
///   class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span
///   class="minner"><span class="mopen delimcenter" style="top:0em;">⌊</span><span
///   class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span class="vlist-t
///   vlist-t2"><span class="vlist-r"><span class="vlist"
///   style="height:0.32833099999999993em;"><span
///   style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span
///   style="height:2.7em;" class="pstrut"></span><span class="sizing reset-size6 size3
///   mtight"><span class="mord mathdefault mtight">G</span></span></span></span><span
///   class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist"
///   style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace"
///   style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span
///   class="mspace" style="margin-right:0.2222222222222222em;"></span><span
///   class="mord">0</span><span class="mord">.</span><span class="mord">5</span><span class="mclose
///   delimcenter" style="top:0em;">⌋</span></span><span class="mspace"
///   style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span
///   style="margin-right:0.2777777777777778em;" class="mspace"></span></span><span
///   class="base"><span style="height:0.80952em;vertical-align:-0.15em;" class="strut"></span><span
///   class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span class="vlist-t
///   vlist-t2"><span class="vlist-r"><span class="vlist"
///   style="height:0.32833099999999993em;"><span
///   style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span
///   style="height:2.7em;" class="pstrut"></span><span class="sizing reset-size6 size3
///   mtight"><span class="mord mathdefault mtight"
///   style="margin-right:0.05017em;">B</span></span></span></span><span
///   class="vlist-s">​</span></span><span class="vlist-r"><span style="height:0.15em;"
///   class="vlist"><span></span></span></span></span></span></span><span
///   style="margin-right:0.2777777777777778em;" class="mspace"></span><span
///   class="mrel">=</span><span style="margin-right:0.2777777777777778em;"
///   class="mspace"></span></span><span class="base"><span
///   style="height:0.80952em;vertical-align:-0.15em;" class="strut"></span><span class="mord"><span
///   class="mord mathdefault">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span
///   class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span
///   style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut"
///   style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord
///   mathdefault mtight" style="margin-right:0.00773em;">R</span></span></span></span><span
///   class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist"
///   style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>.
///   The location of each plane when this image is in linear layout can be determined via
///   [`GetImageSubresourceLayout`], using `VK_IMAGE_ASPECT_PLANE_0_BIT` for the G plane, and
///   `VK_IMAGE_ASPECT_PLANE_1_BIT` for the BR plane. This format only supports images with a width
///   that is a multiple of two.
/// - [`G8B8R83Plane444Unorm`] specifies an unsigned normalized *multi-planar format* that has an
///   8-bit G component in plane 0, an 8-bit B component in plane 1, and an 8-bit R component in
///   plane 2. Each plane has the same dimensions and each R, G and B component contributes to a
///   single texel. The location of each plane when this image is in linear layout can be determined
///   via [`GetImageSubresourceLayout`], using `VK_IMAGE_ASPECT_PLANE_0_BIT` for the G plane,
///   `VK_IMAGE_ASPECT_PLANE_1_BIT` for the B plane, and `VK_IMAGE_ASPECT_PLANE_2_BIT` for the R
///   plane.
/// - [`R10X6UnormPack16`] specifies a one-component, 16-bit unsigned normalized format that has a
///   single 10-bit R component in the top 10 bits of a 16-bit word, with the bottom 6 bits unused.
/// - [`R10X6G10X6Unorm2Pack16`] specifies a two-component, 32-bit unsigned normalized format that
///   has a 10-bit R component in the top 10 bits of the word in bytes 0..1, and a 10-bit G
///   component in the top 10 bits of the word in bytes 2..3, with the bottom 6 bits of each word
///   unused.
/// - [`R10X6G10X6B10X6A10X6Unorm4Pack16`] specifies a four-component, 64-bit unsigned normalized
///   format that has a 10-bit R component in the top 10 bits of the word in bytes 0..1, a 10-bit G
///   component in the top 10 bits of the word in bytes 2..3, a 10-bit B component in the top 10
///   bits of the word in bytes 4..5, and a 10-bit A component in the top 10 bits of the word in
///   bytes 6..7, with the bottom 6 bits of each word unused.
/// - [`G10X6B10X6G10X6R10X6422Unorm4Pack16`] specifies a four-component, 64-bit format containing a
///   pair of G components, an R component, and a B component, collectively encoding a 2×1 rectangle
///   of unsigned normalized RGB texel data. One G value is present at each *i* coordinate, with the
///   B and R values shared across both G values and thus recorded at half the horizontal resolution
///   of the image. This format has a 10-bit G component for the even *i* coordinate in the top 10
///   bits of the word in bytes 0..1, a 10-bit B component in the top 10 bits of the word in bytes
///   2..3, a 10-bit G component for the odd *i* coordinate in the top 10 bits of the word in bytes
///   4..5, and a 10-bit R component in the top 10 bits of the word in bytes 6..7, with the bottom 6
///   bits of each word unused. This format only supports images with a width that is a multiple of
///   two. For the purposes of the constraints on copy extents, this format is treated as a
///   compressed format with a 2×1 compressed texel block.
/// - [`B10X6G10X6R10X6G10X6422Unorm4Pack16`] specifies a four-component, 64-bit format containing a
///   pair of G components, an R component, and a B component, collectively encoding a 2×1 rectangle
///   of unsigned normalized RGB texel data. One G value is present at each *i* coordinate, with the
///   B and R values shared across both G values and thus recorded at half the horizontal resolution
///   of the image. This format has a 10-bit B component in the top 10 bits of the word in bytes
///   0..1, a 10-bit G component for the even *i* coordinate in the top 10 bits of the word in bytes
///   2..3, a 10-bit R component in the top 10 bits of the word in bytes 4..5, and a 10-bit G
///   component for the odd *i* coordinate in the top 10 bits of the word in bytes 6..7, with the
///   bottom 6 bits of each word unused. This format only supports images with a width that is a
///   multiple of two. For the purposes of the constraints on copy extents, this format is treated
///   as a compressed format with a 2×1 compressed texel block.
/// - [`G10X6B10X6R10X63Plane420Unorm3Pack16`] specifies an unsigned normalized *multi-planar
///   format* that has a 10-bit G component in the top 10 bits of each 16-bit word of plane 0, a
///   10-bit B component in the top 10 bits of each 16-bit word of plane 1, and a 10-bit R component
///   in the top 10 bits of each 16-bit word of plane 2, with the bottom 6 bits of each word unused.
///   The horizontal and vertical dimensions of the R and B planes are halved relative to the image
///   dimensions, and each R and B component is shared with the G components for which <span
///   class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span
///   style="height:1em;vertical-align:-0.25em;" class="strut"></span><span class="minner"><span
///   style="top:0em;" class="mopen delimcenter">⌊</span><span class="mord"><span class="mord
///   mathdefault">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span
///   class="vlist-r"><span style="height:0.32833099999999993em;" class="vlist"><span
///   style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span
///   style="height:2.7em;" class="pstrut"></span><span class="sizing reset-size6 size3
///   mtight"><span class="mord mathdefault mtight">G</span></span></span></span><span
///   class="vlist-s">​</span></span><span class="vlist-r"><span style="height:0.15em;"
///   class="vlist"><span></span></span></span></span></span></span><span
///   style="margin-right:0.2222222222222222em;" class="mspace"></span><span
///   class="mbin">×</span><span class="mspace"
///   style="margin-right:0.2222222222222222em;"></span><span class="mord">0</span><span
///   class="mord">.</span><span class="mord">5</span><span style="top:0em;" class="mclose
///   delimcenter">⌋</span></span><span style="margin-right:0.2777777777777778em;"
///   class="mspace"></span><span class="mrel">=</span><span class="mspace"
///   style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span
///   style="height:0.80952em;vertical-align:-0.15em;" class="strut"></span><span class="mord"><span
///   class="mord mathdefault">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span
///   class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span
///   style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut"
///   style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord
///   mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span><span
///   class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist"
///   style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace"
///   style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span
///   style="margin-right:0.2777777777777778em;" class="mspace"></span></span><span
///   class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.15em;"></span><span
///   class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span class="vlist-t
///   vlist-t2"><span class="vlist-r"><span style="height:0.32833099999999993em;"
///   class="vlist"><span
///   style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span
///   style="height:2.7em;" class="pstrut"></span><span class="sizing reset-size6 size3
///   mtight"><span style="margin-right:0.00773em;" class="mord mathdefault
///   mtight">R</span></span></span></span><span class="vlist-s">​</span></span><span
///   class="vlist-r"><span class="vlist"
///   style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>
///   and <span class="katex"><span aria-hidden="true" class="katex-html"><span class="base"><span
///   class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span
///   style="top:0em;" class="mopen delimcenter">⌊</span><span class="mord"><span
///   style="margin-right:0.05724em;" class="mord mathdefault">j</span><span class="msupsub"><span
///   class="vlist-t vlist-t2"><span class="vlist-r"><span style="height:0.32833099999999993em;"
///   class="vlist"><span
///   style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span
///   style="height:2.7em;" class="pstrut"></span><span class="sizing reset-size6 size3
///   mtight"><span class="mord mathdefault mtight">G</span></span></span></span><span
///   class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist"
///   style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace"
///   style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span
///   class="mspace" style="margin-right:0.2222222222222222em;"></span><span
///   class="mord">0</span><span class="mord">.</span><span class="mord">5</span><span
///   style="top:0em;" class="mclose delimcenter">⌋</span></span><span class="mspace"
///   style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span
///   style="margin-right:0.2777777777777778em;" class="mspace"></span></span><span
///   class="base"><span style="height:0.85396em;vertical-align:-0.19444em;"
///   class="strut"></span><span class="mord"><span class="mord mathdefault"
///   style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t
///   vlist-t2"><span class="vlist-r"><span class="vlist"
///   style="height:0.32833099999999993em;"><span
///   style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span
///   style="height:2.7em;" class="pstrut"></span><span class="sizing reset-size6 size3
///   mtight"><span style="margin-right:0.05017em;" class="mord mathdefault
///   mtight">B</span></span></span></span><span class="vlist-s">​</span></span><span
///   class="vlist-r"><span style="height:0.15em;"
///   class="vlist"><span></span></span></span></span></span></span><span class="mspace"
///   style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span
///   class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span
///   class="base"><span class="strut"
///   style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord"><span
///   style="margin-right:0.05724em;" class="mord mathdefault">j</span><span class="msupsub"><span
///   class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist"
///   style="height:0.32833099999999993em;"><span
///   style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span
///   style="height:2.7em;" class="pstrut"></span><span class="sizing reset-size6 size3
///   mtight"><span style="margin-right:0.00773em;" class="mord mathdefault
///   mtight">R</span></span></span></span><span class="vlist-s">​</span></span><span
///   class="vlist-r"><span class="vlist"
///   style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>.
///   The location of each plane when this image is in linear layout can be determined via
///   [`GetImageSubresourceLayout`], using `VK_IMAGE_ASPECT_PLANE_0_BIT` for the G plane,
///   `VK_IMAGE_ASPECT_PLANE_1_BIT` for the B plane, and `VK_IMAGE_ASPECT_PLANE_2_BIT` for the R
///   plane. This format only supports images with a width and height that is a multiple of two.
/// - [`G10X6B10X6R10X62Plane420Unorm3Pack16`] specifies an unsigned normalized *multi-planar
///   format* that has a 10-bit G component in the top 10 bits of each 16-bit word of plane 0, and a
///   two-component, 32-bit BR plane 1 consisting of a 10-bit B component in the top 10 bits of the
///   word in bytes 0..1, and a 10-bit R component in the top 10 bits of the word in bytes 2..3,
///   with the bottom 6 bits of each word unused. The horizontal and vertical dimensions of the BR
///   plane are halved relative to the image dimensions, and each R and B value is shared with the G
///   components for which <span class="katex"><span class="katex-html" aria-hidden="true"><span
///   class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span
///   class="minner"><span style="top:0em;" class="mopen delimcenter">⌊</span><span
///   class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span class="vlist-t
///   vlist-t2"><span class="vlist-r"><span class="vlist"
///   style="height:0.32833099999999993em;"><span
///   style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span
///   style="height:2.7em;" class="pstrut"></span><span class="sizing reset-size6 size3
///   mtight"><span class="mord mathdefault mtight">G</span></span></span></span><span
///   class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist"
///   style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace"
///   style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span
///   class="mspace" style="margin-right:0.2222222222222222em;"></span><span
///   class="mord">0</span><span class="mord">.</span><span class="mord">5</span><span
///   style="top:0em;" class="mclose delimcenter">⌋</span></span><span class="mspace"
///   style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span
///   class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span
///   class="base"><span style="height:0.80952em;vertical-align:-0.15em;" class="strut"></span><span
///   class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span class="vlist-t
///   vlist-t2"><span class="vlist-r"><span class="vlist"
///   style="height:0.32833099999999993em;"><span
///   style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span
///   style="height:2.7em;" class="pstrut"></span><span class="sizing reset-size6 size3
///   mtight"><span style="margin-right:0.05017em;" class="mord mathdefault
///   mtight">B</span></span></span></span><span class="vlist-s">​</span></span><span
///   class="vlist-r"><span class="vlist"
///   style="height:0.15em;"><span></span></span></span></span></span></span><span
///   style="margin-right:0.2777777777777778em;" class="mspace"></span><span
///   class="mrel">=</span><span style="margin-right:0.2777777777777778em;"
///   class="mspace"></span></span><span class="base"><span class="strut"
///   style="height:0.80952em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord
///   mathdefault">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span
///   class="vlist-r"><span style="height:0.32833099999999993em;" class="vlist"><span
///   style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut"
///   style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span
///   style="margin-right:0.00773em;" class="mord mathdefault
///   mtight">R</span></span></span></span><span class="vlist-s">​</span></span><span
///   class="vlist-r"><span class="vlist"
///   style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>
///   and <span class="katex"><span aria-hidden="true" class="katex-html"><span class="base"><span
///   class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span
///   class="mopen delimcenter" style="top:0em;">⌊</span><span class="mord"><span class="mord
///   mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span
///   class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist"
///   style="height:0.32833099999999993em;"><span
///   style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span
///   class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3
///   mtight"><span class="mord mathdefault mtight">G</span></span></span></span><span
///   class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist"
///   style="height:0.15em;"><span></span></span></span></span></span></span><span
///   style="margin-right:0.2222222222222222em;" class="mspace"></span><span
///   class="mbin">×</span><span class="mspace"
///   style="margin-right:0.2222222222222222em;"></span><span class="mord">0</span><span
///   class="mord">.</span><span class="mord">5</span><span class="mclose delimcenter"
///   style="top:0em;">⌋</span></span><span class="mspace"
///   style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span
///   class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span
///   class="base"><span class="strut"
///   style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord"><span
///   class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span
///   class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist"
///   style="height:0.32833099999999993em;"><span
///   style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span
///   class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3
///   mtight"><span class="mord mathdefault mtight"
///   style="margin-right:0.05017em;">B</span></span></span></span><span
///   class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist"
///   style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace"
///   style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span
///   style="margin-right:0.2777777777777778em;" class="mspace"></span></span><span
///   class="base"><span class="strut"
///   style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord"><span
///   style="margin-right:0.05724em;" class="mord mathdefault">j</span><span class="msupsub"><span
///   class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist"
///   style="height:0.32833099999999993em;"><span
///   style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span
///   class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3
///   mtight"><span class="mord mathdefault mtight"
///   style="margin-right:0.00773em;">R</span></span></span></span><span
///   class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist"
///   style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>.
///   The location of each plane when this image is in linear layout can be determined via
///   [`GetImageSubresourceLayout`], using `VK_IMAGE_ASPECT_PLANE_0_BIT` for the G plane, and
///   `VK_IMAGE_ASPECT_PLANE_1_BIT` for the BR plane. This format only supports images with a width
///   and height that is a multiple of two.
/// - [`G10X6B10X6R10X63Plane422Unorm3Pack16`] specifies an unsigned normalized *multi-planar
///   format* that has a 10-bit G component in the top 10 bits of each 16-bit word of plane 0, a
///   10-bit B component in the top 10 bits of each 16-bit word of plane 1, and a 10-bit R component
///   in the top 10 bits of each 16-bit word of plane 2, with the bottom 6 bits of each word unused.
///   The horizontal dimension of the R and B plane is halved relative to the image dimensions, and
///   each R and B value is shared with the G components for which <span class="katex"><span
///   class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
///   style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen
///   delimcenter" style="top:0em;">⌊</span><span class="mord"><span class="mord
///   mathdefault">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span
///   class="vlist-r"><span style="height:0.32833099999999993em;" class="vlist"><span
///   style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut"
///   style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord
///   mathdefault mtight">G</span></span></span></span><span class="vlist-s">​</span></span><span
///   class="vlist-r"><span class="vlist"
///   style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace"
///   style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span
///   style="margin-right:0.2222222222222222em;" class="mspace"></span><span
///   class="mord">0</span><span class="mord">.</span><span class="mord">5</span><span class="mclose
///   delimcenter" style="top:0em;">⌋</span></span><span style="margin-right:0.2777777777777778em;"
///   class="mspace"></span><span class="mrel">=</span><span class="mspace"
///   style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span
///   style="height:0.80952em;vertical-align:-0.15em;" class="strut"></span><span class="mord"><span
///   class="mord mathdefault">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span
///   class="vlist-r"><span style="height:0.32833099999999993em;" class="vlist"><span
///   style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span
///   style="height:2.7em;" class="pstrut"></span><span class="sizing reset-size6 size3
///   mtight"><span class="mord mathdefault mtight"
///   style="margin-right:0.05017em;">B</span></span></span></span><span
///   class="vlist-s">​</span></span><span class="vlist-r"><span style="height:0.15em;"
///   class="vlist"><span></span></span></span></span></span></span><span
///   style="margin-right:0.2777777777777778em;" class="mspace"></span><span
///   class="mrel">=</span><span style="margin-right:0.2777777777777778em;"
///   class="mspace"></span></span><span class="base"><span class="strut"
///   style="height:0.80952em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord
///   mathdefault">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span
///   class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span
///   style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut"
///   style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord
///   mathdefault mtight" style="margin-right:0.00773em;">R</span></span></span></span><span
///   class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist"
///   style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>.
///   The location of each plane when this image is in linear layout can be determined via
///   [`GetImageSubresourceLayout`], using `VK_IMAGE_ASPECT_PLANE_0_BIT` for the G plane,
///   `VK_IMAGE_ASPECT_PLANE_1_BIT` for the B plane, and `VK_IMAGE_ASPECT_PLANE_2_BIT` for the R
///   plane. This format only supports images with a width that is a multiple of two.
/// - [`G10X6B10X6R10X62Plane422Unorm3Pack16`] specifies an unsigned normalized *multi-planar
///   format* that has a 10-bit G component in the top 10 bits of each 16-bit word of plane 0, and a
///   two-component, 32-bit BR plane 1 consisting of a 10-bit B component in the top 10 bits of the
///   word in bytes 0..1, and a 10-bit R component in the top 10 bits of the word in bytes 2..3,
///   with the bottom 6 bits of each word unused. The horizontal dimension of the BR plane is halved
///   relative to the image dimensions, and each R and B value is shared with the G components for
///   which <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span
///   style="height:1em;vertical-align:-0.25em;" class="strut"></span><span class="minner"><span
///   style="top:0em;" class="mopen delimcenter">⌊</span><span class="mord"><span class="mord
///   mathdefault">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span
///   class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span
///   style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut"
///   style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord
///   mathdefault mtight">G</span></span></span></span><span class="vlist-s">​</span></span><span
///   class="vlist-r"><span style="height:0.15em;"
///   class="vlist"><span></span></span></span></span></span></span><span class="mspace"
///   style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span
///   class="mspace" style="margin-right:0.2222222222222222em;"></span><span
///   class="mord">0</span><span class="mord">.</span><span class="mord">5</span><span
///   style="top:0em;" class="mclose delimcenter">⌋</span></span><span class="mspace"
///   style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span
///   style="margin-right:0.2777777777777778em;" class="mspace"></span></span><span
///   class="base"><span style="height:0.80952em;vertical-align:-0.15em;" class="strut"></span><span
///   class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span class="vlist-t
///   vlist-t2"><span class="vlist-r"><span style="height:0.32833099999999993em;"
///   class="vlist"><span
///   style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span
///   style="height:2.7em;" class="pstrut"></span><span class="sizing reset-size6 size3
///   mtight"><span class="mord mathdefault mtight"
///   style="margin-right:0.05017em;">B</span></span></span></span><span
///   class="vlist-s">​</span></span><span class="vlist-r"><span style="height:0.15em;"
///   class="vlist"><span></span></span></span></span></span></span><span class="mspace"
///   style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span
///   class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span
///   class="base"><span style="height:0.80952em;vertical-align:-0.15em;" class="strut"></span><span
///   class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span class="vlist-t
///   vlist-t2"><span class="vlist-r"><span class="vlist"
///   style="height:0.32833099999999993em;"><span
///   style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut"
///   style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord
///   mathdefault mtight" style="margin-right:0.00773em;">R</span></span></span></span><span
///   class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist"
///   style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>.
///   The location of each plane when this image is in linear layout can be determined via
///   [`GetImageSubresourceLayout`], using `VK_IMAGE_ASPECT_PLANE_0_BIT` for the G plane, and
///   `VK_IMAGE_ASPECT_PLANE_1_BIT` for the BR plane. This format only supports images with a width
///   that is a multiple of two.
/// - [`G10X6B10X6R10X63Plane444Unorm3Pack16`] specifies an unsigned normalized *multi-planar
///   format* that has a 10-bit G component in the top 10 bits of each 16-bit word of plane 0, a
///   10-bit B component in the top 10 bits of each 16-bit word of plane 1, and a 10-bit R component
///   in the top 10 bits of each 16-bit word of plane 2, with the bottom 6 bits of each word unused.
///   Each plane has the same dimensions and each R, G and B component contributes to a single
///   texel. The location of each plane when this image is in linear layout can be determined via
///   [`GetImageSubresourceLayout`], using `VK_IMAGE_ASPECT_PLANE_0_BIT` for the G plane,
///   `VK_IMAGE_ASPECT_PLANE_1_BIT` for the B plane, and `VK_IMAGE_ASPECT_PLANE_2_BIT` for the R
///   plane.
/// - [`R12X4UnormPack16`] specifies a one-component, 16-bit unsigned normalized format that has a
///   single 12-bit R component in the top 12 bits of a 16-bit word, with the bottom 4 bits unused.
/// - [`R12X4G12X4Unorm2Pack16`] specifies a two-component, 32-bit unsigned normalized format that
///   has a 12-bit R component in the top 12 bits of the word in bytes 0..1, and a 12-bit G
///   component in the top 12 bits of the word in bytes 2..3, with the bottom 4 bits of each word
///   unused.
/// - [`R12X4G12X4B12X4A12X4Unorm4Pack16`] specifies a four-component, 64-bit unsigned normalized
///   format that has a 12-bit R component in the top 12 bits of the word in bytes 0..1, a 12-bit G
///   component in the top 12 bits of the word in bytes 2..3, a 12-bit B component in the top 12
///   bits of the word in bytes 4..5, and a 12-bit A component in the top 12 bits of the word in
///   bytes 6..7, with the bottom 4 bits of each word unused.
/// - [`G12X4B12X4G12X4R12X4422Unorm4Pack16`] specifies a four-component, 64-bit format containing a
///   pair of G components, an R component, and a B component, collectively encoding a 2×1 rectangle
///   of unsigned normalized RGB texel data. One G value is present at each *i* coordinate, with the
///   B and R values shared across both G values and thus recorded at half the horizontal resolution
///   of the image. This format has a 12-bit G component for the even *i* coordinate in the top 12
///   bits of the word in bytes 0..1, a 12-bit B component in the top 12 bits of the word in bytes
///   2..3, a 12-bit G component for the odd *i* coordinate in the top 12 bits of the word in bytes
///   4..5, and a 12-bit R component in the top 12 bits of the word in bytes 6..7, with the bottom 4
///   bits of each word unused. This format only supports images with a width that is a multiple of
///   two. For the purposes of the constraints on copy extents, this format is treated as a
///   compressed format with a 2×1 compressed texel block.
/// - [`B12X4G12X4R12X4G12X4422Unorm4Pack16`] specifies a four-component, 64-bit format containing a
///   pair of G components, an R component, and a B component, collectively encoding a 2×1 rectangle
///   of unsigned normalized RGB texel data. One G value is present at each *i* coordinate, with the
///   B and R values shared across both G values and thus recorded at half the horizontal resolution
///   of the image. This format has a 12-bit B component in the top 12 bits of the word in bytes
///   0..1, a 12-bit G component for the even *i* coordinate in the top 12 bits of the word in bytes
///   2..3, a 12-bit R component in the top 12 bits of the word in bytes 4..5, and a 12-bit G
///   component for the odd *i* coordinate in the top 12 bits of the word in bytes 6..7, with the
///   bottom 4 bits of each word unused. This format only supports images with a width that is a
///   multiple of two. For the purposes of the constraints on copy extents, this format is treated
///   as a compressed format with a 2×1 compressed texel block.
/// - [`G12X4B12X4R12X43Plane420Unorm3Pack16`] specifies an unsigned normalized *multi-planar
///   format* that has a 12-bit G component in the top 12 bits of each 16-bit word of plane 0, a
///   12-bit B component in the top 12 bits of each 16-bit word of plane 1, and a 12-bit R component
///   in the top 12 bits of each 16-bit word of plane 2, with the bottom 4 bits of each word unused.
///   The horizontal and vertical dimensions of the R and B planes are halved relative to the image
///   dimensions, and each R and B component is shared with the G components for which <span
///   class="katex"><span aria-hidden="true" class="katex-html"><span class="base"><span
///   class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span
///   class="mopen delimcenter" style="top:0em;">⌊</span><span class="mord"><span class="mord
///   mathdefault">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span
///   class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span
///   style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut"
///   style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord
///   mathdefault mtight">G</span></span></span></span><span class="vlist-s">​</span></span><span
///   class="vlist-r"><span style="height:0.15em;"
///   class="vlist"><span></span></span></span></span></span></span><span class="mspace"
///   style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span
///   style="margin-right:0.2222222222222222em;" class="mspace"></span><span
///   class="mord">0</span><span class="mord">.</span><span class="mord">5</span><span
///   style="top:0em;" class="mclose delimcenter">⌋</span></span><span
///   style="margin-right:0.2777777777777778em;" class="mspace"></span><span
///   class="mrel">=</span><span class="mspace"
///   style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span
///   style="height:0.80952em;vertical-align:-0.15em;" class="strut"></span><span class="mord"><span
///   class="mord mathdefault">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span
///   class="vlist-r"><span style="height:0.32833099999999993em;" class="vlist"><span
///   style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span
///   style="height:2.7em;" class="pstrut"></span><span class="sizing reset-size6 size3
///   mtight"><span style="margin-right:0.05017em;" class="mord mathdefault
///   mtight">B</span></span></span></span><span class="vlist-s">​</span></span><span
///   class="vlist-r"><span style="height:0.15em;"
///   class="vlist"><span></span></span></span></span></span></span><span
///   style="margin-right:0.2777777777777778em;" class="mspace"></span><span
///   class="mrel">=</span><span style="margin-right:0.2777777777777778em;"
///   class="mspace"></span></span><span class="base"><span class="strut"
///   style="height:0.80952em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord
///   mathdefault">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span
///   class="vlist-r"><span style="height:0.32833099999999993em;" class="vlist"><span
///   style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut"
///   style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord
///   mathdefault mtight" style="margin-right:0.00773em;">R</span></span></span></span><span
///   class="vlist-s">​</span></span><span class="vlist-r"><span style="height:0.15em;"
///   class="vlist"><span></span></span></span></span></span></span></span></span></span> and <span
///   class="katex"><span aria-hidden="true" class="katex-html"><span class="base"><span
///   style="height:1em;vertical-align:-0.25em;" class="strut"></span><span class="minner"><span
///   style="top:0em;" class="mopen delimcenter">⌊</span><span class="mord"><span class="mord
///   mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span
///   class="vlist-t vlist-t2"><span class="vlist-r"><span style="height:0.32833099999999993em;"
///   class="vlist"><span
///   style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span
///   class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3
///   mtight"><span class="mord mathdefault mtight">G</span></span></span></span><span
///   class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist"
///   style="height:0.15em;"><span></span></span></span></span></span></span><span
///   style="margin-right:0.2222222222222222em;" class="mspace"></span><span
///   class="mbin">×</span><span style="margin-right:0.2222222222222222em;"
///   class="mspace"></span><span class="mord">0</span><span class="mord">.</span><span
///   class="mord">5</span><span style="top:0em;" class="mclose delimcenter">⌋</span></span><span
///   style="margin-right:0.2777777777777778em;" class="mspace"></span><span
///   class="mrel">=</span><span style="margin-right:0.2777777777777778em;"
///   class="mspace"></span></span><span class="base"><span class="strut"
///   style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord"><span
///   class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span
///   class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist"
///   style="height:0.32833099999999993em;"><span
///   style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span
///   class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3
///   mtight"><span style="margin-right:0.05017em;" class="mord mathdefault
///   mtight">B</span></span></span></span><span class="vlist-s">​</span></span><span
///   class="vlist-r"><span class="vlist"
///   style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace"
///   style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span
///   style="margin-right:0.2777777777777778em;" class="mspace"></span></span><span
///   class="base"><span class="strut"
///   style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord"><span
///   style="margin-right:0.05724em;" class="mord mathdefault">j</span><span class="msupsub"><span
///   class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist"
///   style="height:0.32833099999999993em;"><span
///   style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span
///   class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3
///   mtight"><span style="margin-right:0.00773em;" class="mord mathdefault
///   mtight">R</span></span></span></span><span class="vlist-s">​</span></span><span
///   class="vlist-r"><span style="height:0.15em;"
///   class="vlist"><span></span></span></span></span></span></span></span></span></span>. The
///   location of each plane when this image is in linear layout can be determined via
///   [`GetImageSubresourceLayout`], using `VK_IMAGE_ASPECT_PLANE_0_BIT` for the G plane,
///   `VK_IMAGE_ASPECT_PLANE_1_BIT` for the B plane, and `VK_IMAGE_ASPECT_PLANE_2_BIT` for the R
///   plane. This format only supports images with a width and height that is a multiple of two.
/// - [`G12X4B12X4R12X42Plane420Unorm3Pack16`] specifies an unsigned normalized *multi-planar
///   format* that has a 12-bit G component in the top 12 bits of each 16-bit word of plane 0, and a
///   two-component, 32-bit BR plane 1 consisting of a 12-bit B component in the top 12 bits of the
///   word in bytes 0..1, and a 12-bit R component in the top 12 bits of the word in bytes 2..3,
///   with the bottom 4 bits of each word unused. The horizontal and vertical dimensions of the BR
///   plane are halved relative to the image dimensions, and each R and B value is shared with the G
///   components for which <span class="katex"><span aria-hidden="true" class="katex-html"><span
///   class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span
///   class="minner"><span style="top:0em;" class="mopen delimcenter">⌊</span><span
///   class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span class="vlist-t
///   vlist-t2"><span class="vlist-r"><span style="height:0.32833099999999993em;"
///   class="vlist"><span
///   style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span
///   style="height:2.7em;" class="pstrut"></span><span class="sizing reset-size6 size3
///   mtight"><span class="mord mathdefault mtight">G</span></span></span></span><span
///   class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist"
///   style="height:0.15em;"><span></span></span></span></span></span></span><span
///   style="margin-right:0.2222222222222222em;" class="mspace"></span><span
///   class="mbin">×</span><span style="margin-right:0.2222222222222222em;"
///   class="mspace"></span><span class="mord">0</span><span class="mord">.</span><span
///   class="mord">5</span><span style="top:0em;" class="mclose delimcenter">⌋</span></span><span
///   style="margin-right:0.2777777777777778em;" class="mspace"></span><span
///   class="mrel">=</span><span style="margin-right:0.2777777777777778em;"
///   class="mspace"></span></span><span class="base"><span
///   style="height:0.80952em;vertical-align:-0.15em;" class="strut"></span><span class="mord"><span
///   class="mord mathdefault">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span
///   class="vlist-r"><span style="height:0.32833099999999993em;" class="vlist"><span
///   style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut"
///   style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord
///   mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span><span
///   class="vlist-s">​</span></span><span class="vlist-r"><span style="height:0.15em;"
///   class="vlist"><span></span></span></span></span></span></span><span class="mspace"
///   style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span
///   class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span
///   class="base"><span style="height:0.80952em;vertical-align:-0.15em;" class="strut"></span><span
///   class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span class="vlist-t
///   vlist-t2"><span class="vlist-r"><span style="height:0.32833099999999993em;"
///   class="vlist"><span
///   style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span
///   style="height:2.7em;" class="pstrut"></span><span class="sizing reset-size6 size3
///   mtight"><span style="margin-right:0.00773em;" class="mord mathdefault
///   mtight">R</span></span></span></span><span class="vlist-s">​</span></span><span
///   class="vlist-r"><span class="vlist"
///   style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>
///   and <span class="katex"><span aria-hidden="true" class="katex-html"><span class="base"><span
///   style="height:1em;vertical-align:-0.25em;" class="strut"></span><span class="minner"><span
///   class="mopen delimcenter" style="top:0em;">⌊</span><span class="mord"><span
///   style="margin-right:0.05724em;" class="mord mathdefault">j</span><span class="msupsub"><span
///   class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist"
///   style="height:0.32833099999999993em;"><span
///   style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span
///   class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3
///   mtight"><span class="mord mathdefault mtight">G</span></span></span></span><span
///   class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist"
///   style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace"
///   style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span
///   class="mspace" style="margin-right:0.2222222222222222em;"></span><span
///   class="mord">0</span><span class="mord">.</span><span class="mord">5</span><span
///   style="top:0em;" class="mclose delimcenter">⌋</span></span><span
///   style="margin-right:0.2777777777777778em;" class="mspace"></span><span
///   class="mrel">=</span><span class="mspace"
///   style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span
///   style="height:0.85396em;vertical-align:-0.19444em;" class="strut"></span><span
///   class="mord"><span style="margin-right:0.05724em;" class="mord mathdefault">j</span><span
///   class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span
///   style="height:0.32833099999999993em;" class="vlist"><span
///   style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span
///   class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3
///   mtight"><span class="mord mathdefault mtight"
///   style="margin-right:0.05017em;">B</span></span></span></span><span
///   class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist"
///   style="height:0.15em;"><span></span></span></span></span></span></span><span
///   style="margin-right:0.2777777777777778em;" class="mspace"></span><span
///   class="mrel">=</span><span style="margin-right:0.2777777777777778em;"
///   class="mspace"></span></span><span class="base"><span
///   style="height:0.85396em;vertical-align:-0.19444em;" class="strut"></span><span
///   class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span
///   class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span
///   style="height:0.32833099999999993em;" class="vlist"><span
///   style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span
///   style="height:2.7em;" class="pstrut"></span><span class="sizing reset-size6 size3
///   mtight"><span class="mord mathdefault mtight"
///   style="margin-right:0.00773em;">R</span></span></span></span><span
///   class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist"
///   style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>.
///   The location of each plane when this image is in linear layout can be determined via
///   [`GetImageSubresourceLayout`], using `VK_IMAGE_ASPECT_PLANE_0_BIT` for the G plane, and
///   `VK_IMAGE_ASPECT_PLANE_1_BIT` for the BR plane. This format only supports images with a width
///   and height that is a multiple of two.
/// - [`G12X4B12X4R12X43Plane422Unorm3Pack16`] specifies an unsigned normalized *multi-planar
///   format* that has a 12-bit G component in the top 12 bits of each 16-bit word of plane 0, a
///   12-bit B component in the top 12 bits of each 16-bit word of plane 1, and a 12-bit R component
///   in the top 12 bits of each 16-bit word of plane 2, with the bottom 4 bits of each word unused.
///   The horizontal dimension of the R and B plane is halved relative to the image dimensions, and
///   each R and B value is shared with the G components for which <span class="katex"><span
///   class="katex-html" aria-hidden="true"><span class="base"><span
///   style="height:1em;vertical-align:-0.25em;" class="strut"></span><span class="minner"><span
///   style="top:0em;" class="mopen delimcenter">⌊</span><span class="mord"><span class="mord
///   mathdefault">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span
///   class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span
///   style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut"
///   style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord
///   mathdefault mtight">G</span></span></span></span><span class="vlist-s">​</span></span><span
///   class="vlist-r"><span class="vlist"
///   style="height:0.15em;"><span></span></span></span></span></span></span><span
///   style="margin-right:0.2222222222222222em;" class="mspace"></span><span
///   class="mbin">×</span><span style="margin-right:0.2222222222222222em;"
///   class="mspace"></span><span class="mord">0</span><span class="mord">.</span><span
///   class="mord">5</span><span class="mclose delimcenter" style="top:0em;">⌋</span></span><span
///   class="mspace" style="margin-right:0.2777777777777778em;"></span><span
///   class="mrel">=</span><span style="margin-right:0.2777777777777778em;"
///   class="mspace"></span></span><span class="base"><span class="strut"
///   style="height:0.80952em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord
///   mathdefault">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span
///   class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span
///   style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut"
///   style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span
///   style="margin-right:0.05017em;" class="mord mathdefault
///   mtight">B</span></span></span></span><span class="vlist-s">​</span></span><span
///   class="vlist-r"><span class="vlist"
///   style="height:0.15em;"><span></span></span></span></span></span></span><span
///   style="margin-right:0.2777777777777778em;" class="mspace"></span><span
///   class="mrel">=</span><span class="mspace"
///   style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span
///   class="strut" style="height:0.80952em;vertical-align:-0.15em;"></span><span class="mord"><span
///   class="mord mathdefault">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span
///   class="vlist-r"><span style="height:0.32833099999999993em;" class="vlist"><span
///   style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut"
///   style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord
///   mathdefault mtight" style="margin-right:0.00773em;">R</span></span></span></span><span
///   class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist"
///   style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>.
///   The location of each plane when this image is in linear layout can be determined via
///   [`GetImageSubresourceLayout`], using `VK_IMAGE_ASPECT_PLANE_0_BIT` for the G plane,
///   `VK_IMAGE_ASPECT_PLANE_1_BIT` for the B plane, and `VK_IMAGE_ASPECT_PLANE_2_BIT` for the R
///   plane. This format only supports images with a width that is a multiple of two.
/// - [`G12X4B12X4R12X42Plane422Unorm3Pack16`] specifies an unsigned normalized *multi-planar
///   format* that has a 12-bit G component in the top 12 bits of each 16-bit word of plane 0, and a
///   two-component, 32-bit BR plane 1 consisting of a 12-bit B component in the top 12 bits of the
///   word in bytes 0..1, and a 12-bit R component in the top 12 bits of the word in bytes 2..3,
///   with the bottom 4 bits of each word unused. The horizontal dimension of the BR plane is halved
///   relative to the image dimensions, and each R and B value is shared with the G components for
///   which <span class="katex"><span aria-hidden="true" class="katex-html"><span class="base"><span
///   class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span
///   style="top:0em;" class="mopen delimcenter">⌊</span><span class="mord"><span class="mord
///   mathdefault">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span
///   class="vlist-r"><span style="height:0.32833099999999993em;" class="vlist"><span
///   style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut"
///   style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord
///   mathdefault mtight">G</span></span></span></span><span class="vlist-s">​</span></span><span
///   class="vlist-r"><span style="height:0.15em;"
///   class="vlist"><span></span></span></span></span></span></span><span
///   style="margin-right:0.2222222222222222em;" class="mspace"></span><span
///   class="mbin">×</span><span class="mspace"
///   style="margin-right:0.2222222222222222em;"></span><span class="mord">0</span><span
///   class="mord">.</span><span class="mord">5</span><span class="mclose delimcenter"
///   style="top:0em;">⌋</span></span><span class="mspace"
///   style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span
///   style="margin-right:0.2777777777777778em;" class="mspace"></span></span><span
///   class="base"><span style="height:0.80952em;vertical-align:-0.15em;" class="strut"></span><span
///   class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span class="vlist-t
///   vlist-t2"><span class="vlist-r"><span class="vlist"
///   style="height:0.32833099999999993em;"><span
///   style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut"
///   style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord
///   mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span><span
///   class="vlist-s">​</span></span><span class="vlist-r"><span style="height:0.15em;"
///   class="vlist"><span></span></span></span></span></span></span><span class="mspace"
///   style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span
///   class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span
///   class="base"><span style="height:0.80952em;vertical-align:-0.15em;" class="strut"></span><span
///   class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span class="vlist-t
///   vlist-t2"><span class="vlist-r"><span style="height:0.32833099999999993em;"
///   class="vlist"><span
///   style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span
///   style="height:2.7em;" class="pstrut"></span><span class="sizing reset-size6 size3
///   mtight"><span class="mord mathdefault mtight"
///   style="margin-right:0.00773em;">R</span></span></span></span><span
///   class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist"
///   style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>.
///   The location of each plane when this image is in linear layout can be determined via
///   [`GetImageSubresourceLayout`], using `VK_IMAGE_ASPECT_PLANE_0_BIT` for the G plane, and
///   `VK_IMAGE_ASPECT_PLANE_1_BIT` for the BR plane. This format only supports images with a width
///   that is a multiple of two.
/// - [`G12X4B12X4R12X43Plane444Unorm3Pack16`] specifies an unsigned normalized *multi-planar
///   format* that has a 12-bit G component in the top 12 bits of each 16-bit word of plane 0, a
///   12-bit B component in the top 12 bits of each 16-bit word of plane 1, and a 12-bit R component
///   in the top 12 bits of each 16-bit word of plane 2, with the bottom 4 bits of each word unused.
///   Each plane has the same dimensions and each R, G and B component contributes to a single
///   texel. The location of each plane when this image is in linear layout can be determined via
///   [`GetImageSubresourceLayout`], using `VK_IMAGE_ASPECT_PLANE_0_BIT` for the G plane,
///   `VK_IMAGE_ASPECT_PLANE_1_BIT` for the B plane, and `VK_IMAGE_ASPECT_PLANE_2_BIT` for the R
///   plane.
/// - [`G16B16G16R16422Unorm`] specifies a four-component, 64-bit format containing a pair of G
///   components, an R component, and a B component, collectively encoding a 2×1 rectangle of
///   unsigned normalized RGB texel data. One G value is present at each *i* coordinate, with the B
///   and R values shared across both G values and thus recorded at half the horizontal resolution
///   of the image. This format has a 16-bit G component for the even *i* coordinate in the word in
///   bytes 0..1, a 16-bit B component in the word in bytes 2..3, a 16-bit G component for the odd
///   *i* coordinate in the word in bytes 4..5, and a 16-bit R component in the word in bytes 6..7.
///   This format only supports images with a width that is a multiple of two. For the purposes of
///   the constraints on copy extents, this format is treated as a compressed format with a 2×1
///   compressed texel block.
/// - [`B16G16R16G16422Unorm`] specifies a four-component, 64-bit format containing a pair of G
///   components, an R component, and a B component, collectively encoding a 2×1 rectangle of
///   unsigned normalized RGB texel data. One G value is present at each *i* coordinate, with the B
///   and R values shared across both G values and thus recorded at half the horizontal resolution
///   of the image. This format has a 16-bit B component in the word in bytes 0..1, a 16-bit G
///   component for the even *i* coordinate in the word in bytes 2..3, a 16-bit R component in the
///   word in bytes 4..5, and a 16-bit G component for the odd *i* coordinate in the word in bytes
///   6..7. This format only supports images with a width that is a multiple of two. For the
///   purposes of the constraints on copy extents, this format is treated as a compressed format
///   with a 2×1 compressed texel block.
/// - [`G16B16R163Plane420Unorm`] specifies an unsigned normalized *multi-planar format* that has a
///   16-bit G component in each 16-bit word of plane 0, a 16-bit B component in each 16-bit word of
///   plane 1, and a 16-bit R component in each 16-bit word of plane 2. The horizontal and vertical
///   dimensions of the R and B planes are halved relative to the image dimensions, and each R and B
///   component is shared with the G components for which <span class="katex"><span
///   aria-hidden="true" class="katex-html"><span class="base"><span
///   style="height:1em;vertical-align:-0.25em;" class="strut"></span><span class="minner"><span
///   class="mopen delimcenter" style="top:0em;">⌊</span><span class="mord"><span class="mord
///   mathdefault">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span
///   class="vlist-r"><span style="height:0.32833099999999993em;" class="vlist"><span
///   style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span
///   style="height:2.7em;" class="pstrut"></span><span class="sizing reset-size6 size3
///   mtight"><span class="mord mathdefault mtight">G</span></span></span></span><span
///   class="vlist-s">​</span></span><span class="vlist-r"><span style="height:0.15em;"
///   class="vlist"><span></span></span></span></span></span></span><span class="mspace"
///   style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span
///   style="margin-right:0.2222222222222222em;" class="mspace"></span><span
///   class="mord">0</span><span class="mord">.</span><span class="mord">5</span><span class="mclose
///   delimcenter" style="top:0em;">⌋</span></span><span class="mspace"
///   style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span
///   style="margin-right:0.2777777777777778em;" class="mspace"></span></span><span
///   class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.15em;"></span><span
///   class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span class="vlist-t
///   vlist-t2"><span class="vlist-r"><span style="height:0.32833099999999993em;"
///   class="vlist"><span
///   style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut"
///   style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span
///   style="margin-right:0.05017em;" class="mord mathdefault
///   mtight">B</span></span></span></span><span class="vlist-s">​</span></span><span
///   class="vlist-r"><span class="vlist"
///   style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace"
///   style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span
///   class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span
///   class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.15em;"></span><span
///   class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span class="vlist-t
///   vlist-t2"><span class="vlist-r"><span style="height:0.32833099999999993em;"
///   class="vlist"><span
///   style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut"
///   style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span
///   style="margin-right:0.00773em;" class="mord mathdefault
///   mtight">R</span></span></span></span><span class="vlist-s">​</span></span><span
///   class="vlist-r"><span class="vlist"
///   style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>
///   and <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span
///   class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span
///   class="mopen delimcenter" style="top:0em;">⌊</span><span class="mord"><span class="mord
///   mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span
///   class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist"
///   style="height:0.32833099999999993em;"><span
///   style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span
///   style="height:2.7em;" class="pstrut"></span><span class="sizing reset-size6 size3
///   mtight"><span class="mord mathdefault mtight">G</span></span></span></span><span
///   class="vlist-s">​</span></span><span class="vlist-r"><span style="height:0.15em;"
///   class="vlist"><span></span></span></span></span></span></span><span class="mspace"
///   style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span
///   style="margin-right:0.2222222222222222em;" class="mspace"></span><span
///   class="mord">0</span><span class="mord">.</span><span class="mord">5</span><span class="mclose
///   delimcenter" style="top:0em;">⌋</span></span><span class="mspace"
///   style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span
///   class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span
///   class="base"><span class="strut"
///   style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord"><span
///   class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span
///   class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist"
///   style="height:0.32833099999999993em;"><span
///   style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span
///   class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3
///   mtight"><span class="mord mathdefault mtight"
///   style="margin-right:0.05017em;">B</span></span></span></span><span
///   class="vlist-s">​</span></span><span class="vlist-r"><span style="height:0.15em;"
///   class="vlist"><span></span></span></span></span></span></span><span
///   style="margin-right:0.2777777777777778em;" class="mspace"></span><span
///   class="mrel">=</span><span class="mspace"
///   style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span
///   class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span
///   class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span
///   class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span
///   style="height:0.32833099999999993em;" class="vlist"><span
///   style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span
///   class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3
///   mtight"><span style="margin-right:0.00773em;" class="mord mathdefault
///   mtight">R</span></span></span></span><span class="vlist-s">​</span></span><span
///   class="vlist-r"><span style="height:0.15em;"
///   class="vlist"><span></span></span></span></span></span></span></span></span></span>. The
///   location of each plane when this image is in linear layout can be determined via
///   [`GetImageSubresourceLayout`], using `VK_IMAGE_ASPECT_PLANE_0_BIT` for the G plane,
///   `VK_IMAGE_ASPECT_PLANE_1_BIT` for the B plane, and `VK_IMAGE_ASPECT_PLANE_2_BIT` for the R
///   plane. This format only supports images with a width and height that is a multiple of two.
/// - [`G16B16R162Plane420Unorm`] specifies an unsigned normalized *multi-planar format* that has a
///   16-bit G component in each 16-bit word of plane 0, and a two-component, 32-bit BR plane 1
///   consisting of a 16-bit B component in the word in bytes 0..1, and a 16-bit R component in the
///   word in bytes 2..3. The horizontal and vertical dimensions of the BR plane are halved relative
///   to the image dimensions, and each R and B value is shared with the G components for which
///   <span class="katex"><span aria-hidden="true" class="katex-html"><span class="base"><span
///   class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span
///   class="mopen delimcenter" style="top:0em;">⌊</span><span class="mord"><span class="mord
///   mathdefault">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span
///   class="vlist-r"><span style="height:0.32833099999999993em;" class="vlist"><span
///   style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span
///   style="height:2.7em;" class="pstrut"></span><span class="sizing reset-size6 size3
///   mtight"><span class="mord mathdefault mtight">G</span></span></span></span><span
///   class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist"
///   style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace"
///   style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span
///   style="margin-right:0.2222222222222222em;" class="mspace"></span><span
///   class="mord">0</span><span class="mord">.</span><span class="mord">5</span><span class="mclose
///   delimcenter" style="top:0em;">⌋</span></span><span style="margin-right:0.2777777777777778em;"
///   class="mspace"></span><span class="mrel">=</span><span class="mspace"
///   style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span
///   class="strut" style="height:0.80952em;vertical-align:-0.15em;"></span><span class="mord"><span
///   class="mord mathdefault">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span
///   class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span
///   style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span
///   style="height:2.7em;" class="pstrut"></span><span class="sizing reset-size6 size3
///   mtight"><span class="mord mathdefault mtight"
///   style="margin-right:0.05017em;">B</span></span></span></span><span
///   class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist"
///   style="height:0.15em;"><span></span></span></span></span></span></span><span
///   style="margin-right:0.2777777777777778em;" class="mspace"></span><span
///   class="mrel">=</span><span class="mspace"
///   style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span
///   style="height:0.80952em;vertical-align:-0.15em;" class="strut"></span><span class="mord"><span
///   class="mord mathdefault">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span
///   class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span
///   style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span
///   style="height:2.7em;" class="pstrut"></span><span class="sizing reset-size6 size3
///   mtight"><span class="mord mathdefault mtight"
///   style="margin-right:0.00773em;">R</span></span></span></span><span
///   class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist"
///   style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>
///   and <span class="katex"><span aria-hidden="true" class="katex-html"><span class="base"><span
///   style="height:1em;vertical-align:-0.25em;" class="strut"></span><span class="minner"><span
///   style="top:0em;" class="mopen delimcenter">⌊</span><span class="mord"><span class="mord
///   mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span
///   class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist"
///   style="height:0.32833099999999993em;"><span
///   style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span
///   class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3
///   mtight"><span class="mord mathdefault mtight">G</span></span></span></span><span
///   class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist"
///   style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace"
///   style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span
///   class="mspace" style="margin-right:0.2222222222222222em;"></span><span
///   class="mord">0</span><span class="mord">.</span><span class="mord">5</span><span
///   style="top:0em;" class="mclose delimcenter">⌋</span></span><span class="mspace"
///   style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span
///   class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span
///   class="base"><span style="height:0.85396em;vertical-align:-0.19444em;"
///   class="strut"></span><span class="mord"><span class="mord mathdefault"
///   style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t
///   vlist-t2"><span class="vlist-r"><span style="height:0.32833099999999993em;"
///   class="vlist"><span
///   style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span
///   style="height:2.7em;" class="pstrut"></span><span class="sizing reset-size6 size3
///   mtight"><span style="margin-right:0.05017em;" class="mord mathdefault
///   mtight">B</span></span></span></span><span class="vlist-s">​</span></span><span
///   class="vlist-r"><span class="vlist"
///   style="height:0.15em;"><span></span></span></span></span></span></span><span
///   style="margin-right:0.2777777777777778em;" class="mspace"></span><span
///   class="mrel">=</span><span class="mspace"
///   style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span
///   style="height:0.85396em;vertical-align:-0.19444em;" class="strut"></span><span
///   class="mord"><span style="margin-right:0.05724em;" class="mord mathdefault">j</span><span
///   class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span
///   style="height:0.32833099999999993em;" class="vlist"><span
///   style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span
///   style="height:2.7em;" class="pstrut"></span><span class="sizing reset-size6 size3
///   mtight"><span class="mord mathdefault mtight"
///   style="margin-right:0.00773em;">R</span></span></span></span><span
///   class="vlist-s">​</span></span><span class="vlist-r"><span style="height:0.15em;"
///   class="vlist"><span></span></span></span></span></span></span></span></span></span>. The
///   location of each plane when this image is in linear layout can be determined via
///   [`GetImageSubresourceLayout`], using `VK_IMAGE_ASPECT_PLANE_0_BIT` for the G plane, and
///   `VK_IMAGE_ASPECT_PLANE_1_BIT` for the BR plane. This format only supports images with a width
///   and height that is a multiple of two.
/// - [`G16B16R163Plane422Unorm`] specifies an unsigned normalized *multi-planar format* that has a
///   16-bit G component in each 16-bit word of plane 0, a 16-bit B component in each 16-bit word of
///   plane 1, and a 16-bit R component in each 16-bit word of plane 2. The horizontal dimension of
///   the R and B plane is halved relative to the image dimensions, and each R and B value is shared
///   with the G components for which <span class="katex"><span class="katex-html"
///   aria-hidden="true"><span class="base"><span style="height:1em;vertical-align:-0.25em;"
///   class="strut"></span><span class="minner"><span class="mopen delimcenter"
///   style="top:0em;">⌊</span><span class="mord"><span class="mord mathdefault">i</span><span
///   class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist"
///   style="height:0.32833099999999993em;"><span
///   style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut"
///   style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord
///   mathdefault mtight">G</span></span></span></span><span class="vlist-s">​</span></span><span
///   class="vlist-r"><span class="vlist"
///   style="height:0.15em;"><span></span></span></span></span></span></span><span
///   style="margin-right:0.2222222222222222em;" class="mspace"></span><span
///   class="mbin">×</span><span class="mspace"
///   style="margin-right:0.2222222222222222em;"></span><span class="mord">0</span><span
///   class="mord">.</span><span class="mord">5</span><span style="top:0em;" class="mclose
///   delimcenter">⌋</span></span><span style="margin-right:0.2777777777777778em;"
///   class="mspace"></span><span class="mrel">=</span><span class="mspace"
///   style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span
///   class="strut" style="height:0.80952em;vertical-align:-0.15em;"></span><span class="mord"><span
///   class="mord mathdefault">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span
///   class="vlist-r"><span style="height:0.32833099999999993em;" class="vlist"><span
///   style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut"
///   style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord
///   mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span><span
///   class="vlist-s">​</span></span><span class="vlist-r"><span style="height:0.15em;"
///   class="vlist"><span></span></span></span></span></span></span><span class="mspace"
///   style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span
///   class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span
///   class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.15em;"></span><span
///   class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span class="vlist-t
///   vlist-t2"><span class="vlist-r"><span style="height:0.32833099999999993em;"
///   class="vlist"><span
///   style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut"
///   style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span
///   style="margin-right:0.00773em;" class="mord mathdefault
///   mtight">R</span></span></span></span><span class="vlist-s">​</span></span><span
///   class="vlist-r"><span style="height:0.15em;"
///   class="vlist"><span></span></span></span></span></span></span></span></span></span>. The
///   location of each plane when this image is in linear layout can be determined via
///   [`GetImageSubresourceLayout`], using `VK_IMAGE_ASPECT_PLANE_0_BIT` for the G plane,
///   `VK_IMAGE_ASPECT_PLANE_1_BIT` for the B plane, and `VK_IMAGE_ASPECT_PLANE_2_BIT` for the R
///   plane. This format only supports images with a width that is a multiple of two.
/// - [`G16B16R162Plane422Unorm`] specifies an unsigned normalized *multi-planar format* that has a
///   16-bit G component in each 16-bit word of plane 0, and a two-component, 32-bit BR plane 1
///   consisting of a 16-bit B component in the word in bytes 0..1, and a 16-bit R component in the
///   word in bytes 2..3. The horizontal dimension of the BR plane is halved relative to the image
///   dimensions, and each R and B value is shared with the G components for which <span
///   class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span
///   class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span
///   style="top:0em;" class="mopen delimcenter">⌊</span><span class="mord"><span class="mord
///   mathdefault">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span
///   class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span
///   style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut"
///   style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord
///   mathdefault mtight">G</span></span></span></span><span class="vlist-s">​</span></span><span
///   class="vlist-r"><span style="height:0.15em;"
///   class="vlist"><span></span></span></span></span></span></span><span class="mspace"
///   style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span
///   class="mspace" style="margin-right:0.2222222222222222em;"></span><span
///   class="mord">0</span><span class="mord">.</span><span class="mord">5</span><span class="mclose
///   delimcenter" style="top:0em;">⌋</span></span><span class="mspace"
///   style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span
///   class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span
///   class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.15em;"></span><span
///   class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span class="vlist-t
///   vlist-t2"><span class="vlist-r"><span class="vlist"
///   style="height:0.32833099999999993em;"><span
///   style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut"
///   style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span
///   style="margin-right:0.05017em;" class="mord mathdefault
///   mtight">B</span></span></span></span><span class="vlist-s">​</span></span><span
///   class="vlist-r"><span class="vlist"
///   style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace"
///   style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span
///   style="margin-right:0.2777777777777778em;" class="mspace"></span></span><span
///   class="base"><span style="height:0.80952em;vertical-align:-0.15em;" class="strut"></span><span
///   class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span class="vlist-t
///   vlist-t2"><span class="vlist-r"><span style="height:0.32833099999999993em;"
///   class="vlist"><span
///   style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span
///   style="height:2.7em;" class="pstrut"></span><span class="sizing reset-size6 size3
///   mtight"><span class="mord mathdefault mtight"
///   style="margin-right:0.00773em;">R</span></span></span></span><span
///   class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist"
///   style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>.
///   The location of each plane when this image is in linear layout can be determined via
///   [`GetImageSubresourceLayout`], using `VK_IMAGE_ASPECT_PLANE_0_BIT` for the G plane, and
///   `VK_IMAGE_ASPECT_PLANE_1_BIT` for the BR plane. This format only supports images with a width
///   that is a multiple of two.
/// - [`G16B16R163Plane444Unorm`] specifies an unsigned normalized *multi-planar format* that has a
///   16-bit G component in each 16-bit word of plane 0, a 16-bit B component in each 16-bit word of
///   plane 1, and a 16-bit R component in each 16-bit word of plane 2. Each plane has the same
///   dimensions and each R, G and B component contributes to a single texel. The location of each
///   plane when this image is in linear layout can be determined via [`GetImageSubresourceLayout`],
///   using `VK_IMAGE_ASPECT_PLANE_0_BIT` for the G plane, `VK_IMAGE_ASPECT_PLANE_1_BIT` for the B
///   plane, and `VK_IMAGE_ASPECT_PLANE_2_BIT` for the R plane.
/// - [`G8B8R82Plane444Unorm`] specifies an unsigned normalized *multi-planar format* that has an
///   8-bit G component in plane 0, and a two-component, 16-bit BR plane 1 consisting of an 8-bit B
///   component in byte 0 and an 8-bit R component in byte 1. Both planes have the same dimensions
///   and each R, G and B component contributes to a single texel. The location of each plane when
///   this image is in linear layout can be determined via [`GetImageSubresourceLayout`], using
///   `VK_IMAGE_ASPECT_PLANE_0_BIT` for the G plane, and `VK_IMAGE_ASPECT_PLANE_1_BIT` for the BR
///   plane.
/// - [`G10X6B10X6R10X62Plane444Unorm3Pack16`] specifies an unsigned normalized *multi-planar
///   format* that has a 10-bit G component in the top 10 bits of each 16-bit word of plane 0, and a
///   two-component, 32-bit BR plane 1 consisting of a 10-bit B component in the top 10 bits of the
///   word in bytes 0..1, and a 10-bit R component in the top 10 bits of the word in bytes 2..3, the
///   bottom 6 bits of each word unused. Both planes have the same dimensions and each R, G and B
///   component contributes to a single texel. The location of each plane when this image is in
///   linear layout can be determined via [`GetImageSubresourceLayout`], using
///   `VK_IMAGE_ASPECT_PLANE_0_BIT` for the G plane, and `VK_IMAGE_ASPECT_PLANE_1_BIT` for the BR
///   plane.
/// - [`G12X4B12X4R12X42Plane444Unorm3Pack16`] specifies an unsigned normalized *multi-planar
///   format* that has a 12-bit G component in the top 12 bits of each 16-bit word of plane 0, and a
///   two-component, 32-bit BR plane 1 consisting of a 12-bit B component in the top 12 bits of the
///   word in bytes 0..1, and a 12-bit R component in the top 12 bits of the word in bytes 2..3, the
///   bottom 4 bits of each word unused. Both planes have the same dimensions and each R, G and B
///   component contributes to a single texel. The location of each plane when this image is in
///   linear layout can be determined via [`GetImageSubresourceLayout`], using
///   `VK_IMAGE_ASPECT_PLANE_0_BIT` for the G plane, and `VK_IMAGE_ASPECT_PLANE_1_BIT` for the BR
///   plane.
/// - [`G16B16R162Plane444Unorm`] specifies an unsigned normalized *multi-planar format* that has a
///   16-bit G component in each 16-bit word of plane 0, and a two-component, 32-bit BR plane 1
///   consisting of a 16-bit B component in the word in bytes 0..1, and a 16-bit R component in the
///   word in bytes 2..3. Both planes have the same dimensions and each R, G and B component
///   contributes to a single texel. The location of each plane when this image is in linear layout
///   can be determined via [`GetImageSubresourceLayout`], using `VK_IMAGE_ASPECT_PLANE_0_BIT` for
///   the G plane, and `VK_IMAGE_ASPECT_PLANE_1_BIT` for the BR plane.
/// - [`Pvrtc12BppUnormBlockImg`] specifies a four-component, PVRTC compressed format where each
///   64-bit compressed texel block encodes an 8×4 rectangle of unsigned normalized RGBA texel data.
/// - [`Pvrtc14BppUnormBlockImg`] specifies a four-component, PVRTC compressed format where each
///   64-bit compressed texel block encodes a 4×4 rectangle of unsigned normalized RGBA texel data.
/// - [`Pvrtc22BppUnormBlockImg`] specifies a four-component, PVRTC compressed format where each
///   64-bit compressed texel block encodes an 8×4 rectangle of unsigned normalized RGBA texel data.
/// - [`Pvrtc24BppUnormBlockImg`] specifies a four-component, PVRTC compressed format where each
///   64-bit compressed texel block encodes a 4×4 rectangle of unsigned normalized RGBA texel data.
/// - [`Pvrtc12BppSrgbBlockImg`] specifies a four-component, PVRTC compressed format where each
///   64-bit compressed texel block encodes an 8×4 rectangle of unsigned normalized RGBA texel data
///   with sRGB nonlinear encoding applied to the RGB components.
/// - [`Pvrtc14BppSrgbBlockImg`] specifies a four-component, PVRTC compressed format where each
///   64-bit compressed texel block encodes a 4×4 rectangle of unsigned normalized RGBA texel data
///   with sRGB nonlinear encoding applied to the RGB components.
/// - [`Pvrtc22BppSrgbBlockImg`] specifies a four-component, PVRTC compressed format where each
///   64-bit compressed texel block encodes an 8×4 rectangle of unsigned normalized RGBA texel data
///   with sRGB nonlinear encoding applied to the RGB components.
/// - [`Pvrtc24BppSrgbBlockImg`] specifies a four-component, PVRTC compressed format where each
///   64-bit compressed texel block encodes a 4×4 rectangle of unsigned normalized RGBA texel data
///   with sRGB nonlinear encoding applied to the RGB components.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`AccelerationStructureGeometryTrianglesDataKHR`]
/// - [`AndroidHardwareBufferFormatProperties2ANDROID`]
/// - [`AndroidHardwareBufferFormatPropertiesANDROID`]
/// - [`AttachmentDescription`]
/// - [`AttachmentDescription2`]
/// - [`BufferViewCreateInfo`]
/// - [`CommandBufferInheritanceRenderingInfo`]
/// - [`FramebufferAttachmentImageInfo`]
/// - [`GeometryTrianglesNV`]
/// - [`ImageCreateInfo`]
/// - [`ImageFormatListCreateInfo`]
/// - [`ImageViewAstcDecodeModeEXT`]
/// - [`ImageViewCreateInfo`]
/// - [`PhysicalDeviceImageFormatInfo2`]
/// - [`PhysicalDeviceSparseImageFormatInfo2`]
/// - [`PipelineRenderingCreateInfo`]
/// - [`SamplerCustomBorderColorCreateInfoEXT`]
/// - [`SamplerYcbcrConversionCreateInfo`]
/// - [`SurfaceFormatKHR`]
/// - [`SwapchainCreateInfoKHR`]
/// - [`VertexInputAttributeDescription`]
/// - [`VertexInputAttributeDescription2EXT`]
/// - [`VideoFormatPropertiesKHR`]
/// - [`VideoSessionCreateInfoKHR`]
/// - [`GetPhysicalDeviceExternalImageFormatPropertiesNV`]
/// - [`GetPhysicalDeviceFormatProperties`]
/// - [`GetPhysicalDeviceFormatProperties2`]
/// - [`GetPhysicalDeviceFormatProperties2KHR`]
/// - [`GetPhysicalDeviceImageFormatProperties`]
/// - [`GetPhysicalDeviceSparseImageFormatProperties`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkFormat")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
#[repr(i32)]
pub enum Format {
    ///[`Undefined`] specifies that the format is not specified.
    Undefined = 0,
    ///[`R4G4UnormPack8`] specifies a two-component, 8-bit packed
    ///unsigned normalized format that has a 4-bit R component in bits 4..7,
    ///and a 4-bit G component in bits 0..3.
    R4G4UnormPack8 = 1,
    ///[`R4G4B4A4UnormPack16`] specifies a four-component, 16-bit
    ///packed unsigned normalized format that has a 4-bit R component in bits
    ///12..15, a 4-bit G component in bits 8..11, a 4-bit B component in bits
    ///4..7, and a 4-bit A component in bits 0..3.
    R4G4B4A4UnormPack16 = 2,
    ///[`B4G4R4A4UnormPack16`] specifies a four-component, 16-bit
    ///packed unsigned normalized format that has a 4-bit B component in bits
    ///12..15, a 4-bit G component in bits 8..11, a 4-bit R component in bits
    ///4..7, and a 4-bit A component in bits 0..3.
    B4G4R4A4UnormPack16 = 3,
    ///[`R5G6B5UnormPack16`] specifies a three-component, 16-bit
    ///packed unsigned normalized format that has a 5-bit R component in bits
    ///11..15, a 6-bit G component in bits 5..10, and a 5-bit B component in
    ///bits 0..4.
    R5G6B5UnormPack16 = 4,
    ///[`B5G6R5UnormPack16`] specifies a three-component, 16-bit
    ///packed unsigned normalized format that has a 5-bit B component in bits
    ///11..15, a 6-bit G component in bits 5..10, and a 5-bit R component in
    ///bits 0..4.
    B5G6R5UnormPack16 = 5,
    ///[`R5G5B5A1UnormPack16`] specifies a four-component, 16-bit
    ///packed unsigned normalized format that has a 5-bit R component in bits
    ///11..15, a 5-bit G component in bits 6..10, a 5-bit B component in bits
    ///1..5, and a 1-bit A component in bit 0.
    R5G5B5A1UnormPack16 = 6,
    ///[`B5G5R5A1UnormPack16`] specifies a four-component, 16-bit
    ///packed unsigned normalized format that has a 5-bit B component in bits
    ///11..15, a 5-bit G component in bits 6..10, a 5-bit R component in bits
    ///1..5, and a 1-bit A component in bit 0.
    B5G5R5A1UnormPack16 = 7,
    ///[`A1R5G5B5UnormPack16`] specifies a four-component, 16-bit
    ///packed unsigned normalized format that has a 1-bit A component in bit
    ///15, a 5-bit R component in bits 10..14, a 5-bit G component in bits
    ///5..9, and a 5-bit B component in bits 0..4.
    A1R5G5B5UnormPack16 = 8,
    ///[`R8Unorm`] specifies a one-component, 8-bit unsigned
    ///normalized format that has a single 8-bit R component.
    R8Unorm = 9,
    ///[`R8Snorm`] specifies a one-component, 8-bit signed
    ///normalized format that has a single 8-bit R component.
    R8Snorm = 10,
    ///[`R8Uscaled`] specifies a one-component, 8-bit unsigned
    ///scaled integer format that has a single 8-bit R component.
    R8Uscaled = 11,
    ///[`R8Sscaled`] specifies a one-component, 8-bit signed
    ///scaled integer format that has a single 8-bit R component.
    R8Sscaled = 12,
    ///[`R8Uint`] specifies a one-component, 8-bit unsigned
    ///integer format that has a single 8-bit R component.
    R8Uint = 13,
    ///[`R8Sint`] specifies a one-component, 8-bit signed integer
    ///format that has a single 8-bit R component.
    R8Sint = 14,
    ///[`R8Srgb`] specifies a one-component, 8-bit unsigned
    ///normalized format that has a single 8-bit R component stored with sRGB
    ///nonlinear encoding.
    R8Srgb = 15,
    ///[`R8G8Unorm`] specifies a two-component, 16-bit unsigned
    ///normalized format that has an 8-bit R component in byte 0, and an 8-bit
    ///G component in byte 1.
    R8G8Unorm = 16,
    ///[`R8G8Snorm`] specifies a two-component, 16-bit signed
    ///normalized format that has an 8-bit R component in byte 0, and an 8-bit
    ///G component in byte 1.
    R8G8Snorm = 17,
    ///[`R8G8Uscaled`] specifies a two-component, 16-bit unsigned
    ///scaled integer format that has an 8-bit R component in byte 0, and an
    ///8-bit G component in byte 1.
    R8G8Uscaled = 18,
    ///[`R8G8Sscaled`] specifies a two-component, 16-bit signed
    ///scaled integer format that has an 8-bit R component in byte 0, and an
    ///8-bit G component in byte 1.
    R8G8Sscaled = 19,
    ///[`R8G8Uint`] specifies a two-component, 16-bit unsigned
    ///integer format that has an 8-bit R component in byte 0, and an 8-bit G
    ///component in byte 1.
    R8G8Uint = 20,
    ///[`R8G8Sint`] specifies a two-component, 16-bit signed
    ///integer format that has an 8-bit R component in byte 0, and an 8-bit G
    ///component in byte 1.
    R8G8Sint = 21,
    ///[`R8G8Srgb`] specifies a two-component, 16-bit unsigned
    ///normalized format that has an 8-bit R component stored with sRGB
    ///nonlinear encoding in byte 0, and an 8-bit G component stored with sRGB
    ///nonlinear encoding in byte 1.
    R8G8Srgb = 22,
    ///[`R8G8B8Unorm`] specifies a three-component, 24-bit
    ///unsigned normalized format that has an 8-bit R component in byte 0, an
    ///8-bit G component in byte 1, and an 8-bit B component in byte 2.
    R8G8B8Unorm = 23,
    ///[`R8G8B8Snorm`] specifies a three-component, 24-bit signed
    ///normalized format that has an 8-bit R component in byte 0, an 8-bit G
    ///component in byte 1, and an 8-bit B component in byte 2.
    R8G8B8Snorm = 24,
    ///[`R8G8B8Uscaled`] specifies a three-component, 24-bit
    ///unsigned scaled format that has an 8-bit R component in byte 0, an 8-bit
    ///G component in byte 1, and an 8-bit B component in byte 2.
    R8G8B8Uscaled = 25,
    ///[`R8G8B8Sscaled`] specifies a three-component, 24-bit
    ///signed scaled format that has an 8-bit R component in byte 0, an 8-bit G
    ///component in byte 1, and an 8-bit B component in byte 2.
    R8G8B8Sscaled = 26,
    ///[`R8G8B8Uint`] specifies a three-component, 24-bit unsigned
    ///integer format that has an 8-bit R component in byte 0, an 8-bit G
    ///component in byte 1, and an 8-bit B component in byte 2.
    R8G8B8Uint = 27,
    ///[`R8G8B8Sint`] specifies a three-component, 24-bit signed
    ///integer format that has an 8-bit R component in byte 0, an 8-bit G
    ///component in byte 1, and an 8-bit B component in byte 2.
    R8G8B8Sint = 28,
    ///[`R8G8B8Srgb`] specifies a three-component, 24-bit unsigned
    ///normalized format that has an 8-bit R component stored with sRGB
    ///nonlinear encoding in byte 0, an 8-bit G component stored with sRGB
    ///nonlinear encoding in byte 1, and an 8-bit B component stored with sRGB
    ///nonlinear encoding in byte 2.
    R8G8B8Srgb = 29,
    ///[`B8G8R8Unorm`] specifies a three-component, 24-bit
    ///unsigned normalized format that has an 8-bit B component in byte 0, an
    ///8-bit G component in byte 1, and an 8-bit R component in byte 2.
    B8G8R8Unorm = 30,
    ///[`B8G8R8Snorm`] specifies a three-component, 24-bit signed
    ///normalized format that has an 8-bit B component in byte 0, an 8-bit G
    ///component in byte 1, and an 8-bit R component in byte 2.
    B8G8R8Snorm = 31,
    ///[`B8G8R8Uscaled`] specifies a three-component, 24-bit
    ///unsigned scaled format that has an 8-bit B component in byte 0, an 8-bit
    ///G component in byte 1, and an 8-bit R component in byte 2.
    B8G8R8Uscaled = 32,
    ///[`B8G8R8Sscaled`] specifies a three-component, 24-bit
    ///signed scaled format that has an 8-bit B component in byte 0, an 8-bit G
    ///component in byte 1, and an 8-bit R component in byte 2.
    B8G8R8Sscaled = 33,
    ///[`B8G8R8Uint`] specifies a three-component, 24-bit unsigned
    ///integer format that has an 8-bit B component in byte 0, an 8-bit G
    ///component in byte 1, and an 8-bit R component in byte 2.
    B8G8R8Uint = 34,
    ///[`B8G8R8Sint`] specifies a three-component, 24-bit signed
    ///integer format that has an 8-bit B component in byte 0, an 8-bit G
    ///component in byte 1, and an 8-bit R component in byte 2.
    B8G8R8Sint = 35,
    ///[`B8G8R8Srgb`] specifies a three-component, 24-bit unsigned
    ///normalized format that has an 8-bit B component stored with sRGB
    ///nonlinear encoding in byte 0, an 8-bit G component stored with sRGB
    ///nonlinear encoding in byte 1, and an 8-bit R component stored with sRGB
    ///nonlinear encoding in byte 2.
    B8G8R8Srgb = 36,
    ///[`R8G8B8A8Unorm`] specifies a four-component, 32-bit
    ///unsigned normalized format that has an 8-bit R component in byte 0, an
    ///8-bit G component in byte 1, an 8-bit B component in byte 2, and an
    ///8-bit A component in byte 3.
    R8G8B8A8Unorm = 37,
    ///[`R8G8B8A8Snorm`] specifies a four-component, 32-bit signed
    ///normalized format that has an 8-bit R component in byte 0, an 8-bit G
    ///component in byte 1, an 8-bit B component in byte 2, and an 8-bit A
    ///component in byte 3.
    R8G8B8A8Snorm = 38,
    ///[`R8G8B8A8Uscaled`] specifies a four-component, 32-bit
    ///unsigned scaled format that has an 8-bit R component in byte 0, an 8-bit
    ///G component in byte 1, an 8-bit B component in byte 2, and an 8-bit A
    ///component in byte 3.
    R8G8B8A8Uscaled = 39,
    ///[`R8G8B8A8Sscaled`] specifies a four-component, 32-bit
    ///signed scaled format that has an 8-bit R component in byte 0, an 8-bit G
    ///component in byte 1, an 8-bit B component in byte 2, and an 8-bit A
    ///component in byte 3.
    R8G8B8A8Sscaled = 40,
    ///[`R8G8B8A8Uint`] specifies a four-component, 32-bit
    ///unsigned integer format that has an 8-bit R component in byte 0, an
    ///8-bit G component in byte 1, an 8-bit B component in byte 2, and an
    ///8-bit A component in byte 3.
    R8G8B8A8Uint = 41,
    ///[`R8G8B8A8Sint`] specifies a four-component, 32-bit signed
    ///integer format that has an 8-bit R component in byte 0, an 8-bit G
    ///component in byte 1, an 8-bit B component in byte 2, and an 8-bit A
    ///component in byte 3.
    R8G8B8A8Sint = 42,
    ///[`R8G8B8A8Srgb`] specifies a four-component, 32-bit
    ///unsigned normalized format that has an 8-bit R component stored with
    ///sRGB nonlinear encoding in byte 0, an 8-bit G component stored with sRGB
    ///nonlinear encoding in byte 1, an 8-bit B component stored with sRGB
    ///nonlinear encoding in byte 2, and an 8-bit A component in byte 3.
    R8G8B8A8Srgb = 43,
    ///[`B8G8R8A8Unorm`] specifies a four-component, 32-bit
    ///unsigned normalized format that has an 8-bit B component in byte 0, an
    ///8-bit G component in byte 1, an 8-bit R component in byte 2, and an
    ///8-bit A component in byte 3.
    B8G8R8A8Unorm = 44,
    ///[`B8G8R8A8Snorm`] specifies a four-component, 32-bit signed
    ///normalized format that has an 8-bit B component in byte 0, an 8-bit G
    ///component in byte 1, an 8-bit R component in byte 2, and an 8-bit A
    ///component in byte 3.
    B8G8R8A8Snorm = 45,
    ///[`B8G8R8A8Uscaled`] specifies a four-component, 32-bit
    ///unsigned scaled format that has an 8-bit B component in byte 0, an 8-bit
    ///G component in byte 1, an 8-bit R component in byte 2, and an 8-bit A
    ///component in byte 3.
    B8G8R8A8Uscaled = 46,
    ///[`B8G8R8A8Sscaled`] specifies a four-component, 32-bit
    ///signed scaled format that has an 8-bit B component in byte 0, an 8-bit G
    ///component in byte 1, an 8-bit R component in byte 2, and an 8-bit A
    ///component in byte 3.
    B8G8R8A8Sscaled = 47,
    ///[`B8G8R8A8Uint`] specifies a four-component, 32-bit
    ///unsigned integer format that has an 8-bit B component in byte 0, an
    ///8-bit G component in byte 1, an 8-bit R component in byte 2, and an
    ///8-bit A component in byte 3.
    B8G8R8A8Uint = 48,
    ///[`B8G8R8A8Sint`] specifies a four-component, 32-bit signed
    ///integer format that has an 8-bit B component in byte 0, an 8-bit G
    ///component in byte 1, an 8-bit R component in byte 2, and an 8-bit A
    ///component in byte 3.
    B8G8R8A8Sint = 49,
    ///[`B8G8R8A8Srgb`] specifies a four-component, 32-bit
    ///unsigned normalized format that has an 8-bit B component stored with
    ///sRGB nonlinear encoding in byte 0, an 8-bit G component stored with sRGB
    ///nonlinear encoding in byte 1, an 8-bit R component stored with sRGB
    ///nonlinear encoding in byte 2, and an 8-bit A component in byte 3.
    B8G8R8A8Srgb = 50,
    ///[`A8B8G8R8UnormPack32`] specifies a four-component, 32-bit
    ///packed unsigned normalized format that has an 8-bit A component in bits
    ///24..31, an 8-bit B component in bits 16..23, an 8-bit G component in
    ///bits 8..15, and an 8-bit R component in bits 0..7.
    A8B8G8R8UnormPack32 = 51,
    ///[`A8B8G8R8SnormPack32`] specifies a four-component, 32-bit
    ///packed signed normalized format that has an 8-bit A component in bits
    ///24..31, an 8-bit B component in bits 16..23, an 8-bit G component in
    ///bits 8..15, and an 8-bit R component in bits 0..7.
    A8B8G8R8SnormPack32 = 52,
    ///[`A8B8G8R8UscaledPack32`] specifies a four-component,
    ///32-bit packed unsigned scaled integer format that has an 8-bit A
    ///component in bits 24..31, an 8-bit B component in bits 16..23, an 8-bit
    ///G component in bits 8..15, and an 8-bit R component in bits 0..7.
    A8B8G8R8UscaledPack32 = 53,
    ///[`A8B8G8R8SscaledPack32`] specifies a four-component,
    ///32-bit packed signed scaled integer format that has an 8-bit A component
    ///in bits 24..31, an 8-bit B component in bits 16..23, an 8-bit G
    ///component in bits 8..15, and an 8-bit R component in bits 0..7.
    A8B8G8R8SscaledPack32 = 54,
    ///[`A8B8G8R8UintPack32`] specifies a four-component, 32-bit
    ///packed unsigned integer format that has an 8-bit A component in bits
    ///24..31, an 8-bit B component in bits 16..23, an 8-bit G component in
    ///bits 8..15, and an 8-bit R component in bits 0..7.
    A8B8G8R8UintPack32 = 55,
    ///[`A8B8G8R8SintPack32`] specifies a four-component, 32-bit
    ///packed signed integer format that has an 8-bit A component in bits
    ///24..31, an 8-bit B component in bits 16..23, an 8-bit G component in
    ///bits 8..15, and an 8-bit R component in bits 0..7.
    A8B8G8R8SintPack32 = 56,
    ///[`A8B8G8R8SrgbPack32`] specifies a four-component, 32-bit
    ///packed unsigned normalized format that has an 8-bit A component in bits
    ///24..31, an 8-bit B component stored with sRGB nonlinear encoding in bits
    ///16..23, an 8-bit G component stored with sRGB nonlinear encoding in bits
    ///8..15, and an 8-bit R component stored with sRGB nonlinear encoding in
    ///bits 0..7.
    A8B8G8R8SrgbPack32 = 57,
    ///[`A2R10G10B10UnormPack32`] specifies a four-component,
    ///32-bit packed unsigned normalized format that has a 2-bit A component in
    ///bits 30..31, a 10-bit R component in bits 20..29, a 10-bit G component
    ///in bits 10..19, and a 10-bit B component in bits 0..9.
    A2R10G10B10UnormPack32 = 58,
    ///[`A2R10G10B10SnormPack32`] specifies a four-component,
    ///32-bit packed signed normalized format that has a 2-bit A component in
    ///bits 30..31, a 10-bit R component in bits 20..29, a 10-bit G component
    ///in bits 10..19, and a 10-bit B component in bits 0..9.
    A2R10G10B10SnormPack32 = 59,
    ///[`A2R10G10B10UscaledPack32`] specifies a four-component,
    ///32-bit packed unsigned scaled integer format that has a 2-bit A
    ///component in bits 30..31, a 10-bit R component in bits 20..29, a 10-bit
    ///G component in bits 10..19, and a 10-bit B component in bits 0..9.
    A2R10G10B10UscaledPack32 = 60,
    ///[`A2R10G10B10SscaledPack32`] specifies a four-component,
    ///32-bit packed signed scaled integer format that has a 2-bit A component
    ///in bits 30..31, a 10-bit R component in bits 20..29, a 10-bit G
    ///component in bits 10..19, and a 10-bit B component in bits 0..9.
    A2R10G10B10SscaledPack32 = 61,
    ///[`A2R10G10B10UintPack32`] specifies a four-component,
    ///32-bit packed unsigned integer format that has a 2-bit A component in
    ///bits 30..31, a 10-bit R component in bits 20..29, a 10-bit G component
    ///in bits 10..19, and a 10-bit B component in bits 0..9.
    A2R10G10B10UintPack32 = 62,
    ///[`A2R10G10B10SintPack32`] specifies a four-component,
    ///32-bit packed signed integer format that has a 2-bit A component in bits
    ///30..31, a 10-bit R component in bits 20..29, a 10-bit G component in
    ///bits 10..19, and a 10-bit B component in bits 0..9.
    A2R10G10B10SintPack32 = 63,
    ///[`A2B10G10R10UnormPack32`] specifies a four-component,
    ///32-bit packed unsigned normalized format that has a 2-bit A component in
    ///bits 30..31, a 10-bit B component in bits 20..29, a 10-bit G component
    ///in bits 10..19, and a 10-bit R component in bits 0..9.
    A2B10G10R10UnormPack32 = 64,
    ///[`A2B10G10R10SnormPack32`] specifies a four-component,
    ///32-bit packed signed normalized format that has a 2-bit A component in
    ///bits 30..31, a 10-bit B component in bits 20..29, a 10-bit G component
    ///in bits 10..19, and a 10-bit R component in bits 0..9.
    A2B10G10R10SnormPack32 = 65,
    ///[`A2B10G10R10UscaledPack32`] specifies a four-component,
    ///32-bit packed unsigned scaled integer format that has a 2-bit A
    ///component in bits 30..31, a 10-bit B component in bits 20..29, a 10-bit
    ///G component in bits 10..19, and a 10-bit R component in bits 0..9.
    A2B10G10R10UscaledPack32 = 66,
    ///[`A2B10G10R10SscaledPack32`] specifies a four-component,
    ///32-bit packed signed scaled integer format that has a 2-bit A component
    ///in bits 30..31, a 10-bit B component in bits 20..29, a 10-bit G
    ///component in bits 10..19, and a 10-bit R component in bits 0..9.
    A2B10G10R10SscaledPack32 = 67,
    ///[`A2B10G10R10UintPack32`] specifies a four-component,
    ///32-bit packed unsigned integer format that has a 2-bit A component in
    ///bits 30..31, a 10-bit B component in bits 20..29, a 10-bit G component
    ///in bits 10..19, and a 10-bit R component in bits 0..9.
    A2B10G10R10UintPack32 = 68,
    ///[`A2B10G10R10SintPack32`] specifies a four-component,
    ///32-bit packed signed integer format that has a 2-bit A component in bits
    ///30..31, a 10-bit B component in bits 20..29, a 10-bit G component in
    ///bits 10..19, and a 10-bit R component in bits 0..9.
    A2B10G10R10SintPack32 = 69,
    ///[`R16Unorm`] specifies a one-component, 16-bit unsigned
    ///normalized format that has a single 16-bit R component.
    R16Unorm = 70,
    ///[`R16Snorm`] specifies a one-component, 16-bit signed
    ///normalized format that has a single 16-bit R component.
    R16Snorm = 71,
    ///[`R16Uscaled`] specifies a one-component, 16-bit unsigned
    ///scaled integer format that has a single 16-bit R component.
    R16Uscaled = 72,
    ///[`R16Sscaled`] specifies a one-component, 16-bit signed
    ///scaled integer format that has a single 16-bit R component.
    R16Sscaled = 73,
    ///[`R16Uint`] specifies a one-component, 16-bit unsigned
    ///integer format that has a single 16-bit R component.
    R16Uint = 74,
    ///[`R16Sint`] specifies a one-component, 16-bit signed
    ///integer format that has a single 16-bit R component.
    R16Sint = 75,
    ///[`R16Sfloat`] specifies a one-component, 16-bit signed
    ///floating-point format that has a single 16-bit R component.
    R16Sfloat = 76,
    ///[`R16G16Unorm`] specifies a two-component, 32-bit unsigned
    ///normalized format that has a 16-bit R component in bytes 0..1, and a
    ///16-bit G component in bytes 2..3.
    R16G16Unorm = 77,
    ///[`R16G16Snorm`] specifies a two-component, 32-bit signed
    ///normalized format that has a 16-bit R component in bytes 0..1, and a
    ///16-bit G component in bytes 2..3.
    R16G16Snorm = 78,
    ///[`R16G16Uscaled`] specifies a two-component, 32-bit
    ///unsigned scaled integer format that has a 16-bit R component in bytes
    ///0..1, and a 16-bit G component in bytes 2..3.
    R16G16Uscaled = 79,
    ///[`R16G16Sscaled`] specifies a two-component, 32-bit signed
    ///scaled integer format that has a 16-bit R component in bytes 0..1, and a
    ///16-bit G component in bytes 2..3.
    R16G16Sscaled = 80,
    ///[`R16G16Uint`] specifies a two-component, 32-bit unsigned
    ///integer format that has a 16-bit R component in bytes 0..1, and a 16-bit
    ///G component in bytes 2..3.
    R16G16Uint = 81,
    ///[`R16G16Sint`] specifies a two-component, 32-bit signed
    ///integer format that has a 16-bit R component in bytes 0..1, and a 16-bit
    ///G component in bytes 2..3.
    R16G16Sint = 82,
    ///[`R16G16Sfloat`] specifies a two-component, 32-bit signed
    ///floating-point format that has a 16-bit R component in bytes 0..1, and a
    ///16-bit G component in bytes 2..3.
    R16G16Sfloat = 83,
    ///[`R16G16B16Unorm`] specifies a three-component, 48-bit
    ///unsigned normalized format that has a 16-bit R component in bytes 0..1,
    ///a 16-bit G component in bytes 2..3, and a 16-bit B component in bytes
    ///4..5.
    R16G16B16Unorm = 84,
    ///[`R16G16B16Snorm`] specifies a three-component, 48-bit
    ///signed normalized format that has a 16-bit R component in bytes 0..1, a
    ///16-bit G component in bytes 2..3, and a 16-bit B component in bytes
    ///4..5.
    R16G16B16Snorm = 85,
    ///[`R16G16B16Uscaled`] specifies a three-component, 48-bit
    ///unsigned scaled integer format that has a 16-bit R component in bytes
    ///0..1, a 16-bit G component in bytes 2..3, and a 16-bit B component in
    ///bytes 4..5.
    R16G16B16Uscaled = 86,
    ///[`R16G16B16Sscaled`] specifies a three-component, 48-bit
    ///signed scaled integer format that has a 16-bit R component in bytes
    ///0..1, a 16-bit G component in bytes 2..3, and a 16-bit B component in
    ///bytes 4..5.
    R16G16B16Sscaled = 87,
    ///[`R16G16B16Uint`] specifies a three-component, 48-bit
    ///unsigned integer format that has a 16-bit R component in bytes 0..1, a
    ///16-bit G component in bytes 2..3, and a 16-bit B component in bytes
    ///4..5.
    R16G16B16Uint = 88,
    ///[`R16G16B16Sint`] specifies a three-component, 48-bit
    ///signed integer format that has a 16-bit R component in bytes 0..1, a
    ///16-bit G component in bytes 2..3, and a 16-bit B component in bytes
    ///4..5.
    R16G16B16Sint = 89,
    ///[`R16G16B16Sfloat`] specifies a three-component, 48-bit
    ///signed floating-point format that has a 16-bit R component in bytes
    ///0..1, a 16-bit G component in bytes 2..3, and a 16-bit B component in
    ///bytes 4..5.
    R16G16B16Sfloat = 90,
    ///[`R16G16B16A16Unorm`] specifies a four-component, 64-bit
    ///unsigned normalized format that has a 16-bit R component in bytes 0..1,
    ///a 16-bit G component in bytes 2..3, a 16-bit B component in bytes 4..5,
    ///and a 16-bit A component in bytes 6..7.
    R16G16B16A16Unorm = 91,
    ///[`R16G16B16A16Snorm`] specifies a four-component, 64-bit
    ///signed normalized format that has a 16-bit R component in bytes 0..1, a
    ///16-bit G component in bytes 2..3, a 16-bit B component in bytes 4..5,
    ///and a 16-bit A component in bytes 6..7.
    R16G16B16A16Snorm = 92,
    ///[`R16G16B16A16Uscaled`] specifies a four-component, 64-bit
    ///unsigned scaled integer format that has a 16-bit R component in bytes
    ///0..1, a 16-bit G component in bytes 2..3, a 16-bit B component in bytes
    ///4..5, and a 16-bit A component in bytes 6..7.
    R16G16B16A16Uscaled = 93,
    ///[`R16G16B16A16Sscaled`] specifies a four-component, 64-bit
    ///signed scaled integer format that has a 16-bit R component in bytes
    ///0..1, a 16-bit G component in bytes 2..3, a 16-bit B component in bytes
    ///4..5, and a 16-bit A component in bytes 6..7.
    R16G16B16A16Sscaled = 94,
    ///[`R16G16B16A16Uint`] specifies a four-component, 64-bit
    ///unsigned integer format that has a 16-bit R component in bytes 0..1, a
    ///16-bit G component in bytes 2..3, a 16-bit B component in bytes 4..5,
    ///and a 16-bit A component in bytes 6..7.
    R16G16B16A16Uint = 95,
    ///[`R16G16B16A16Sint`] specifies a four-component, 64-bit
    ///signed integer format that has a 16-bit R component in bytes 0..1, a
    ///16-bit G component in bytes 2..3, a 16-bit B component in bytes 4..5,
    ///and a 16-bit A component in bytes 6..7.
    R16G16B16A16Sint = 96,
    ///[`R16G16B16A16Sfloat`] specifies a four-component, 64-bit
    ///signed floating-point format that has a 16-bit R component in bytes
    ///0..1, a 16-bit G component in bytes 2..3, a 16-bit B component in bytes
    ///4..5, and a 16-bit A component in bytes 6..7.
    R16G16B16A16Sfloat = 97,
    ///[`R32Uint`] specifies a one-component, 32-bit unsigned
    ///integer format that has a single 32-bit R component.
    R32Uint = 98,
    ///[`R32Sint`] specifies a one-component, 32-bit signed
    ///integer format that has a single 32-bit R component.
    R32Sint = 99,
    ///[`R32Sfloat`] specifies a one-component, 32-bit signed
    ///floating-point format that has a single 32-bit R component.
    R32Sfloat = 100,
    ///[`R32G32Uint`] specifies a two-component, 64-bit unsigned
    ///integer format that has a 32-bit R component in bytes 0..3, and a 32-bit
    ///G component in bytes 4..7.
    R32G32Uint = 101,
    ///[`R32G32Sint`] specifies a two-component, 64-bit signed
    ///integer format that has a 32-bit R component in bytes 0..3, and a 32-bit
    ///G component in bytes 4..7.
    R32G32Sint = 102,
    ///[`R32G32Sfloat`] specifies a two-component, 64-bit signed
    ///floating-point format that has a 32-bit R component in bytes 0..3, and a
    ///32-bit G component in bytes 4..7.
    R32G32Sfloat = 103,
    ///[`R32G32B32Uint`] specifies a three-component, 96-bit
    ///unsigned integer format that has a 32-bit R component in bytes 0..3, a
    ///32-bit G component in bytes 4..7, and a 32-bit B component in bytes
    ///8..11.
    R32G32B32Uint = 104,
    ///[`R32G32B32Sint`] specifies a three-component, 96-bit
    ///signed integer format that has a 32-bit R component in bytes 0..3, a
    ///32-bit G component in bytes 4..7, and a 32-bit B component in bytes
    ///8..11.
    R32G32B32Sint = 105,
    ///[`R32G32B32Sfloat`] specifies a three-component, 96-bit
    ///signed floating-point format that has a 32-bit R component in bytes
    ///0..3, a 32-bit G component in bytes 4..7, and a 32-bit B component in
    ///bytes 8..11.
    R32G32B32Sfloat = 106,
    ///[`R32G32B32A32Uint`] specifies a four-component, 128-bit
    ///unsigned integer format that has a 32-bit R component in bytes 0..3, a
    ///32-bit G component in bytes 4..7, a 32-bit B component in bytes 8..11,
    ///and a 32-bit A component in bytes 12..15.
    R32G32B32A32Uint = 107,
    ///[`R32G32B32A32Sint`] specifies a four-component, 128-bit
    ///signed integer format that has a 32-bit R component in bytes 0..3, a
    ///32-bit G component in bytes 4..7, a 32-bit B component in bytes 8..11,
    ///and a 32-bit A component in bytes 12..15.
    R32G32B32A32Sint = 108,
    ///[`R32G32B32A32Sfloat`] specifies a four-component, 128-bit
    ///signed floating-point format that has a 32-bit R component in bytes
    ///0..3, a 32-bit G component in bytes 4..7, a 32-bit B component in bytes
    ///8..11, and a 32-bit A component in bytes 12..15.
    R32G32B32A32Sfloat = 109,
    ///[`R64Uint`] specifies a one-component, 64-bit unsigned
    ///integer format that has a single 64-bit R component.
    R64Uint = 110,
    ///[`R64Sint`] specifies a one-component, 64-bit signed
    ///integer format that has a single 64-bit R component.
    R64Sint = 111,
    ///[`R64Sfloat`] specifies a one-component, 64-bit signed
    ///floating-point format that has a single 64-bit R component.
    R64Sfloat = 112,
    ///[`R64G64Uint`] specifies a two-component, 128-bit unsigned
    ///integer format that has a 64-bit R component in bytes 0..7, and a 64-bit
    ///G component in bytes 8..15.
    R64G64Uint = 113,
    ///[`R64G64Sint`] specifies a two-component, 128-bit signed
    ///integer format that has a 64-bit R component in bytes 0..7, and a 64-bit
    ///G component in bytes 8..15.
    R64G64Sint = 114,
    ///[`R64G64Sfloat`] specifies a two-component, 128-bit signed
    ///floating-point format that has a 64-bit R component in bytes 0..7, and a
    ///64-bit G component in bytes 8..15.
    R64G64Sfloat = 115,
    ///[`R64G64B64Uint`] specifies a three-component, 192-bit
    ///unsigned integer format that has a 64-bit R component in bytes 0..7, a
    ///64-bit G component in bytes 8..15, and a 64-bit B component in bytes
    ///16..23.
    R64G64B64Uint = 116,
    ///[`R64G64B64Sint`] specifies a three-component, 192-bit
    ///signed integer format that has a 64-bit R component in bytes 0..7, a
    ///64-bit G component in bytes 8..15, and a 64-bit B component in bytes
    ///16..23.
    R64G64B64Sint = 117,
    ///[`R64G64B64Sfloat`] specifies a three-component, 192-bit
    ///signed floating-point format that has a 64-bit R component in bytes
    ///0..7, a 64-bit G component in bytes 8..15, and a 64-bit B component in
    ///bytes 16..23.
    R64G64B64Sfloat = 118,
    ///[`R64G64B64A64Uint`] specifies a four-component, 256-bit
    ///unsigned integer format that has a 64-bit R component in bytes 0..7, a
    ///64-bit G component in bytes 8..15, a 64-bit B component in bytes 16..23,
    ///and a 64-bit A component in bytes 24..31.
    R64G64B64A64Uint = 119,
    ///[`R64G64B64A64Sint`] specifies a four-component, 256-bit
    ///signed integer format that has a 64-bit R component in bytes 0..7, a
    ///64-bit G component in bytes 8..15, a 64-bit B component in bytes 16..23,
    ///and a 64-bit A component in bytes 24..31.
    R64G64B64A64Sint = 120,
    ///[`R64G64B64A64Sfloat`] specifies a four-component, 256-bit
    ///signed floating-point format that has a 64-bit R component in bytes
    ///0..7, a 64-bit G component in bytes 8..15, a 64-bit B component in bytes
    ///16..23, and a 64-bit A component in bytes 24..31.
    R64G64B64A64Sfloat = 121,
    ///[`B10G11R11UfloatPack32`] specifies a three-component,
    ///32-bit packed unsigned floating-point format that has a 10-bit B
    ///component in bits 22..31, an 11-bit G component in bits 11..21, an
    ///11-bit R component in bits 0..10.
    ///See [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fundamentals-fp10](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fundamentals-fp10) and [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fundamentals-fp11](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fundamentals-fp11).
    B10G11R11UfloatPack32 = 122,
    ///[`E5B9G9R9UfloatPack32`] specifies a three-component,
    ///32-bit packed unsigned floating-point format that has a 5-bit shared
    ///exponent in bits 27..31, a 9-bit B component mantissa in bits 18..26, a
    ///9-bit G component mantissa in bits 9..17, and a 9-bit R component
    ///mantissa in bits 0..8.
    E5B9G9R9UfloatPack32 = 123,
    ///[`D16Unorm`] specifies a one-component, 16-bit unsigned
    ///normalized format that has a single 16-bit depth component.
    D16Unorm = 124,
    ///[`X8D24UnormPack32`] specifies a two-component, 32-bit
    ///format that has 24 unsigned normalized bits in the depth component and,
    /// **optionally** , 8 bits that are unused.
    X8D24UnormPack32 = 125,
    ///[`D32Sfloat`] specifies a one-component, 32-bit signed
    ///floating-point format that has 32 bits in the depth component.
    D32Sfloat = 126,
    ///[`S8Uint`] specifies a one-component, 8-bit unsigned
    ///integer format that has 8 bits in the stencil component.
    S8Uint = 127,
    ///[`D16UnormS8Uint`] specifies a two-component, 24-bit
    ///format that has 16 unsigned normalized bits in the depth component and 8
    ///unsigned integer bits in the stencil component.
    D16UnormS8Uint = 128,
    ///[`D24UnormS8Uint`] specifies a two-component, 32-bit
    ///packed format that has 8 unsigned integer bits in the stencil component,
    ///and 24 unsigned normalized bits in the depth component.
    D24UnormS8Uint = 129,
    ///[`D32SfloatS8Uint`] specifies a two-component format that
    ///has 32 signed float bits in the depth component and 8 unsigned integer
    ///bits in the stencil component.
    ///There are  **optionally**  24 bits that are unused.
    D32SfloatS8Uint = 130,
    ///[`Bc1RgbUnormBlock`] specifies a three-component,
    ///block-compressed format where each 64-bit compressed texel block encodes
    ///a 4×4 rectangle of unsigned normalized RGB texel data.
    ///This format has no alpha and is considered opaque.
    Bc1RgbUnormBlock = 131,
    ///[`Bc1RgbSrgbBlock`] specifies a three-component,
    ///block-compressed format where each 64-bit compressed texel block encodes
    ///a 4×4 rectangle of unsigned normalized RGB texel data with sRGB
    ///nonlinear encoding.
    ///This format has no alpha and is considered opaque.
    Bc1RgbSrgbBlock = 132,
    ///[`Bc1RgbaUnormBlock`] specifies a four-component,
    ///block-compressed format where each 64-bit compressed texel block encodes
    ///a 4×4 rectangle of unsigned normalized RGB texel data, and
    ///provides 1 bit of alpha.
    Bc1RgbaUnormBlock = 133,
    ///[`Bc1RgbaSrgbBlock`] specifies a four-component,
    ///block-compressed format where each 64-bit compressed texel block encodes
    ///a 4×4 rectangle of unsigned normalized RGB texel data with sRGB
    ///nonlinear encoding, and provides 1 bit of alpha.
    Bc1RgbaSrgbBlock = 134,
    ///[`Bc2UnormBlock`] specifies a four-component,
    ///block-compressed format where each 128-bit compressed texel block
    ///encodes a 4×4 rectangle of unsigned normalized RGBA texel data
    ///with the first 64 bits encoding alpha values followed by 64 bits
    ///encoding RGB values.
    Bc2UnormBlock = 135,
    ///[`Bc2SrgbBlock`] specifies a four-component,
    ///block-compressed format where each 128-bit compressed texel block
    ///encodes a 4×4 rectangle of unsigned normalized RGBA texel data
    ///with the first 64 bits encoding alpha values followed by 64 bits
    ///encoding RGB values with sRGB nonlinear encoding.
    Bc2SrgbBlock = 136,
    ///[`Bc3UnormBlock`] specifies a four-component,
    ///block-compressed format where each 128-bit compressed texel block
    ///encodes a 4×4 rectangle of unsigned normalized RGBA texel data
    ///with the first 64 bits encoding alpha values followed by 64 bits
    ///encoding RGB values.
    Bc3UnormBlock = 137,
    ///[`Bc3SrgbBlock`] specifies a four-component,
    ///block-compressed format where each 128-bit compressed texel block
    ///encodes a 4×4 rectangle of unsigned normalized RGBA texel data
    ///with the first 64 bits encoding alpha values followed by 64 bits
    ///encoding RGB values with sRGB nonlinear encoding.
    Bc3SrgbBlock = 138,
    ///[`Bc4UnormBlock`] specifies a one-component,
    ///block-compressed format where each 64-bit compressed texel block encodes
    ///a 4×4 rectangle of unsigned normalized red texel data.
    Bc4UnormBlock = 139,
    ///[`Bc4SnormBlock`] specifies a one-component,
    ///block-compressed format where each 64-bit compressed texel block encodes
    ///a 4×4 rectangle of signed normalized red texel data.
    Bc4SnormBlock = 140,
    ///[`Bc5UnormBlock`] specifies a two-component,
    ///block-compressed format where each 128-bit compressed texel block
    ///encodes a 4×4 rectangle of unsigned normalized RG texel data with
    ///the first 64 bits encoding red values followed by 64 bits encoding green
    ///values.
    Bc5UnormBlock = 141,
    ///[`Bc5SnormBlock`] specifies a two-component,
    ///block-compressed format where each 128-bit compressed texel block
    ///encodes a 4×4 rectangle of signed normalized RG texel data with
    ///the first 64 bits encoding red values followed by 64 bits encoding green
    ///values.
    Bc5SnormBlock = 142,
    ///[`Bc6HUfloatBlock`] specifies a three-component,
    ///block-compressed format where each 128-bit compressed texel block
    ///encodes a 4×4 rectangle of unsigned floating-point RGB texel data.
    Bc6HUfloatBlock = 143,
    ///[`Bc6HSfloatBlock`] specifies a three-component,
    ///block-compressed format where each 128-bit compressed texel block
    ///encodes a 4×4 rectangle of signed floating-point RGB texel data.
    Bc6HSfloatBlock = 144,
    ///[`Bc7UnormBlock`] specifies a four-component,
    ///block-compressed format where each 128-bit compressed texel block
    ///encodes a 4×4 rectangle of unsigned normalized RGBA texel data.
    Bc7UnormBlock = 145,
    ///[`Bc7SrgbBlock`] specifies a four-component,
    ///block-compressed format where each 128-bit compressed texel block
    ///encodes a 4×4 rectangle of unsigned normalized RGBA texel data
    ///with sRGB nonlinear encoding applied to the RGB components.
    Bc7SrgbBlock = 146,
    ///[`Etc2R8G8B8UnormBlock`] specifies a three-component,
    ///ETC2 compressed format where each 64-bit compressed texel block encodes
    ///a 4×4 rectangle of unsigned normalized RGB texel data.
    ///This format has no alpha and is considered opaque.
    Etc2R8G8B8UnormBlock = 147,
    ///[`Etc2R8G8B8SrgbBlock`] specifies a three-component, ETC2
    ///compressed format where each 64-bit compressed texel block encodes a
    ///4×4 rectangle of unsigned normalized RGB texel data with sRGB
    ///nonlinear encoding.
    ///This format has no alpha and is considered opaque.
    Etc2R8G8B8SrgbBlock = 148,
    ///[`Etc2R8G8B8A1UnormBlock`] specifies a four-component,
    ///ETC2 compressed format where each 64-bit compressed texel block encodes
    ///a 4×4 rectangle of unsigned normalized RGB texel data, and
    ///provides 1 bit of alpha.
    Etc2R8G8B8A1UnormBlock = 149,
    ///[`Etc2R8G8B8A1SrgbBlock`] specifies a four-component,
    ///ETC2 compressed format where each 64-bit compressed texel block encodes
    ///a 4×4 rectangle of unsigned normalized RGB texel data with sRGB
    ///nonlinear encoding, and provides 1 bit of alpha.
    Etc2R8G8B8A1SrgbBlock = 150,
    ///[`Etc2R8G8B8A8UnormBlock`] specifies a four-component,
    ///ETC2 compressed format where each 128-bit compressed texel block encodes
    ///a 4×4 rectangle of unsigned normalized RGBA texel data with the
    ///first 64 bits encoding alpha values followed by 64 bits encoding RGB
    ///values.
    Etc2R8G8B8A8UnormBlock = 151,
    ///[`Etc2R8G8B8A8SrgbBlock`] specifies a four-component,
    ///ETC2 compressed format where each 128-bit compressed texel block encodes
    ///a 4×4 rectangle of unsigned normalized RGBA texel data with the
    ///first 64 bits encoding alpha values followed by 64 bits encoding RGB
    ///values with sRGB nonlinear encoding applied.
    Etc2R8G8B8A8SrgbBlock = 152,
    ///[`EacR11UnormBlock`] specifies a one-component, ETC2
    ///compressed format where each 64-bit compressed texel block encodes a
    ///4×4 rectangle of unsigned normalized red texel data.
    EacR11UnormBlock = 153,
    ///[`EacR11SnormBlock`] specifies a one-component, ETC2
    ///compressed format where each 64-bit compressed texel block encodes a
    ///4×4 rectangle of signed normalized red texel data.
    EacR11SnormBlock = 154,
    ///[`EacR11G11UnormBlock`] specifies a two-component, ETC2
    ///compressed format where each 128-bit compressed texel block encodes a
    ///4×4 rectangle of unsigned normalized RG texel data with the first
    ///64 bits encoding red values followed by 64 bits encoding green values.
    EacR11G11UnormBlock = 155,
    ///[`EacR11G11SnormBlock`] specifies a two-component, ETC2
    ///compressed format where each 128-bit compressed texel block encodes a
    ///4×4 rectangle of signed normalized RG texel data with the first 64
    ///bits encoding red values followed by 64 bits encoding green values.
    EacR11G11SnormBlock = 156,
    ///[`Astc4X4UnormBlock`] specifies a four-component, ASTC
    ///compressed format where each 128-bit compressed texel block encodes a
    ///4×4 rectangle of unsigned normalized RGBA texel data.
    Astc4X4UnormBlock = 157,
    ///[`Astc4X4SrgbBlock`] specifies a four-component, ASTC
    ///compressed format where each 128-bit compressed texel block encodes a
    ///4×4 rectangle of unsigned normalized RGBA texel data with sRGB
    ///nonlinear encoding applied to the RGB components.
    Astc4X4SrgbBlock = 158,
    ///[`Astc5X4UnormBlock`] specifies a four-component, ASTC
    ///compressed format where each 128-bit compressed texel block encodes a
    ///5×4 rectangle of unsigned normalized RGBA texel data.
    Astc5X4UnormBlock = 159,
    ///[`Astc5X4SrgbBlock`] specifies a four-component, ASTC
    ///compressed format where each 128-bit compressed texel block encodes a
    ///5×4 rectangle of unsigned normalized RGBA texel data with sRGB
    ///nonlinear encoding applied to the RGB components.
    Astc5X4SrgbBlock = 160,
    ///[`Astc5X5UnormBlock`] specifies a four-component, ASTC
    ///compressed format where each 128-bit compressed texel block encodes a
    ///5×5 rectangle of unsigned normalized RGBA texel data.
    Astc5X5UnormBlock = 161,
    ///[`Astc5X5SrgbBlock`] specifies a four-component, ASTC
    ///compressed format where each 128-bit compressed texel block encodes a
    ///5×5 rectangle of unsigned normalized RGBA texel data with sRGB
    ///nonlinear encoding applied to the RGB components.
    Astc5X5SrgbBlock = 162,
    ///[`Astc6X5UnormBlock`] specifies a four-component, ASTC
    ///compressed format where each 128-bit compressed texel block encodes a
    ///6×5 rectangle of unsigned normalized RGBA texel data.
    Astc6X5UnormBlock = 163,
    ///[`Astc6X5SrgbBlock`] specifies a four-component, ASTC
    ///compressed format where each 128-bit compressed texel block encodes a
    ///6×5 rectangle of unsigned normalized RGBA texel data with sRGB
    ///nonlinear encoding applied to the RGB components.
    Astc6X5SrgbBlock = 164,
    ///[`Astc6X6UnormBlock`] specifies a four-component, ASTC
    ///compressed format where each 128-bit compressed texel block encodes a
    ///6×6 rectangle of unsigned normalized RGBA texel data.
    Astc6X6UnormBlock = 165,
    ///[`Astc6X6SrgbBlock`] specifies a four-component, ASTC
    ///compressed format where each 128-bit compressed texel block encodes a
    ///6×6 rectangle of unsigned normalized RGBA texel data with sRGB
    ///nonlinear encoding applied to the RGB components.
    Astc6X6SrgbBlock = 166,
    ///[`Astc8X5UnormBlock`] specifies a four-component, ASTC
    ///compressed format where each 128-bit compressed texel block encodes an
    ///8×5 rectangle of unsigned normalized RGBA texel data.
    Astc8X5UnormBlock = 167,
    ///[`Astc8X5SrgbBlock`] specifies a four-component, ASTC
    ///compressed format where each 128-bit compressed texel block encodes an
    ///8×5 rectangle of unsigned normalized RGBA texel data with sRGB
    ///nonlinear encoding applied to the RGB components.
    Astc8X5SrgbBlock = 168,
    ///[`Astc8X6UnormBlock`] specifies a four-component, ASTC
    ///compressed format where each 128-bit compressed texel block encodes an
    ///8×6 rectangle of unsigned normalized RGBA texel data.
    Astc8X6UnormBlock = 169,
    ///[`Astc8X6SrgbBlock`] specifies a four-component, ASTC
    ///compressed format where each 128-bit compressed texel block encodes an
    ///8×6 rectangle of unsigned normalized RGBA texel data with sRGB
    ///nonlinear encoding applied to the RGB components.
    Astc8X6SrgbBlock = 170,
    ///[`Astc8X8UnormBlock`] specifies a four-component, ASTC
    ///compressed format where each 128-bit compressed texel block encodes an
    ///8×8 rectangle of unsigned normalized RGBA texel data.
    Astc8X8UnormBlock = 171,
    ///[`Astc8X8SrgbBlock`] specifies a four-component, ASTC
    ///compressed format where each 128-bit compressed texel block encodes an
    ///8×8 rectangle of unsigned normalized RGBA texel data with sRGB
    ///nonlinear encoding applied to the RGB components.
    Astc8X8SrgbBlock = 172,
    ///[`Astc10X5UnormBlock`] specifies a four-component, ASTC
    ///compressed format where each 128-bit compressed texel block encodes a
    ///10×5 rectangle of unsigned normalized RGBA texel data.
    Astc10X5UnormBlock = 173,
    ///[`Astc10X5SrgbBlock`] specifies a four-component, ASTC
    ///compressed format where each 128-bit compressed texel block encodes a
    ///10×5 rectangle of unsigned normalized RGBA texel data with sRGB
    ///nonlinear encoding applied to the RGB components.
    Astc10X5SrgbBlock = 174,
    ///[`Astc10X6UnormBlock`] specifies a four-component, ASTC
    ///compressed format where each 128-bit compressed texel block encodes a
    ///10×6 rectangle of unsigned normalized RGBA texel data.
    Astc10X6UnormBlock = 175,
    ///[`Astc10X6SrgbBlock`] specifies a four-component, ASTC
    ///compressed format where each 128-bit compressed texel block encodes a
    ///10×6 rectangle of unsigned normalized RGBA texel data with sRGB
    ///nonlinear encoding applied to the RGB components.
    Astc10X6SrgbBlock = 176,
    ///[`Astc10X8UnormBlock`] specifies a four-component, ASTC
    ///compressed format where each 128-bit compressed texel block encodes a
    ///10×8 rectangle of unsigned normalized RGBA texel data.
    Astc10X8UnormBlock = 177,
    ///[`Astc10X8SrgbBlock`] specifies a four-component, ASTC
    ///compressed format where each 128-bit compressed texel block encodes a
    ///10×8 rectangle of unsigned normalized RGBA texel data with sRGB
    ///nonlinear encoding applied to the RGB components.
    Astc10X8SrgbBlock = 178,
    ///[`Astc10X10UnormBlock`] specifies a four-component, ASTC
    ///compressed format where each 128-bit compressed texel block encodes a
    ///10×10 rectangle of unsigned normalized RGBA texel data.
    Astc10X10UnormBlock = 179,
    ///[`Astc10X10SrgbBlock`] specifies a four-component, ASTC
    ///compressed format where each 128-bit compressed texel block encodes a
    ///10×10 rectangle of unsigned normalized RGBA texel data with sRGB
    ///nonlinear encoding applied to the RGB components.
    Astc10X10SrgbBlock = 180,
    ///[`Astc12X10UnormBlock`] specifies a four-component, ASTC
    ///compressed format where each 128-bit compressed texel block encodes a
    ///12×10 rectangle of unsigned normalized RGBA texel data.
    Astc12X10UnormBlock = 181,
    ///[`Astc12X10SrgbBlock`] specifies a four-component, ASTC
    ///compressed format where each 128-bit compressed texel block encodes a
    ///12×10 rectangle of unsigned normalized RGBA texel data with sRGB
    ///nonlinear encoding applied to the RGB components.
    Astc12X10SrgbBlock = 182,
    ///[`Astc12X12UnormBlock`] specifies a four-component, ASTC
    ///compressed format where each 128-bit compressed texel block encodes a
    ///12×12 rectangle of unsigned normalized RGBA texel data.
    Astc12X12UnormBlock = 183,
    ///[`Astc12X12SrgbBlock`] specifies a four-component, ASTC
    ///compressed format where each 128-bit compressed texel block encodes a
    ///12×12 rectangle of unsigned normalized RGBA texel data with sRGB
    ///nonlinear encoding applied to the RGB components.
    Astc12X12SrgbBlock = 184,
    ///[`G8B8G8R8422Unorm`] specifies a four-component, 32-bit
    ///format containing a pair of G components, an R component, and a B
    ///component, collectively encoding a 2×1 rectangle of unsigned
    ///normalized RGB texel data.
    ///One G value is present at each *i* coordinate, with the B and R values
    ///shared across both G values and thus recorded at half the horizontal
    ///resolution of the image.
    ///This format has an 8-bit G component for the even *i* coordinate in byte
    ///0, an 8-bit B component in byte 1, an 8-bit G component for the odd *i*
    ///coordinate in byte 2, and an 8-bit R component in byte 3.
    ///This format only supports images with a width that is a multiple of two.
    ///For the purposes of the constraints on copy extents, this format is
    ///treated as a compressed format with a 2×1 compressed texel block.
    ///
    ///Provided by [`crate::vulkan1_1`]
    G8B8G8R8422Unorm = 1000156000,
    ///[`B8G8R8G8422Unorm`] specifies a four-component, 32-bit
    ///format containing a pair of G components, an R component, and a B
    ///component, collectively encoding a 2×1 rectangle of unsigned
    ///normalized RGB texel data.
    ///One G value is present at each *i* coordinate, with the B and R values
    ///shared across both G values and thus recorded at half the horizontal
    ///resolution of the image.
    ///This format has an 8-bit B component in byte 0, an 8-bit G component for
    ///the even *i* coordinate in byte 1, an 8-bit R component in byte 2, and
    ///an 8-bit G component for the odd *i* coordinate in byte 3.
    ///This format only supports images with a width that is a multiple of two.
    ///For the purposes of the constraints on copy extents, this format is
    ///treated as a compressed format with a 2×1 compressed texel block.
    ///
    ///Provided by [`crate::vulkan1_1`]
    B8G8R8G8422Unorm = 1000156001,
    ///[`G8B8R83Plane420Unorm`] specifies an unsigned
    ///normalized *multi-planar format* that has an 8-bit G component in plane
    ///0, an 8-bit B component in plane 1, and an 8-bit R component in plane 2.
    ///The horizontal and vertical dimensions of the R and B planes are halved
    ///relative to the image dimensions, and each R and B component is shared
    ///with the G components for which <span class="katex"><span aria-hidden="true"
    /// class="katex-html"><span class="base"><span class="strut"
    /// style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span
    /// style="top:0em;" class="mopen delimcenter">⌊</span><span class="mord"><span class="mord
    /// mathdefault">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span
    /// class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span
    /// style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span
    /// style="height:2.7em;" class="pstrut"></span><span class="sizing reset-size6 size3
    /// mtight"><span class="mord mathdefault mtight">G</span></span></span></span><span
    /// class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist"
    /// style="height:0.15em;"><span></span></span></span></span></span></span><span
    /// style="margin-right:0.2222222222222222em;" class="mspace"></span><span
    /// class="mbin">×</span><span style="margin-right:0.2222222222222222em;"
    /// class="mspace"></span><span class="mord">0</span><span class="mord">.</span><span
    /// class="mord">5</span><span style="top:0em;" class="mclose delimcenter">⌋</span></span><span
    /// class="mspace" style="margin-right:0.2777777777777778em;"></span><span
    /// class="mrel">=</span><span class="mspace"
    /// style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span
    /// class="strut" style="height:0.80952em;vertical-align:-0.15em;"></span><span
    /// class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span
    /// class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist"
    /// style="height:0.32833099999999993em;"><span
    /// style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut"
    /// style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord
    /// mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span><span
    /// class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist"
    /// style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace"
    /// style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span
    /// class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span
    /// class="base"><span class="strut"
    /// style="height:0.80952em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord
    /// mathdefault">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span
    /// class="vlist-r"><span style="height:0.32833099999999993em;" class="vlist"><span
    /// style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut"
    /// style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord
    /// mathdefault mtight" style="margin-right:0.00773em;">R</span></span></span></span><span
    /// class="vlist-s">​</span></span><span class="vlist-r"><span style="height:0.15em;"
    /// class="vlist"><span></span></span></span></span></span></span></span></span></span> and
    /// <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span
    /// class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span
    /// style="top:0em;" class="mopen delimcenter">⌊</span><span class="mord"><span class="mord
    /// mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span
    /// class="vlist-t vlist-t2"><span class="vlist-r"><span style="height:0.32833099999999993em;"
    /// class="vlist"><span
    /// style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span
    /// class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3
    /// mtight"><span class="mord mathdefault mtight">G</span></span></span></span><span
    /// class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist"
    /// style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace"
    /// style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span
    /// class="mspace" style="margin-right:0.2222222222222222em;"></span><span
    /// class="mord">0</span><span class="mord">.</span><span class="mord">5</span><span
    /// style="top:0em;" class="mclose delimcenter">⌋</span></span><span
    /// style="margin-right:0.2777777777777778em;" class="mspace"></span><span
    /// class="mrel">=</span><span class="mspace"
    /// style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span
    /// class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span
    /// class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span
    /// class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist"
    /// style="height:0.32833099999999993em;"><span
    /// style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span
    /// style="height:2.7em;" class="pstrut"></span><span class="sizing reset-size6 size3
    /// mtight"><span class="mord mathdefault mtight"
    /// style="margin-right:0.05017em;">B</span></span></span></span><span
    /// class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist"
    /// style="height:0.15em;"><span></span></span></span></span></span></span><span
    /// style="margin-right:0.2777777777777778em;" class="mspace"></span><span
    /// class="mrel">=</span><span class="mspace"
    /// style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span
    /// class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span
    /// class="mord"><span style="margin-right:0.05724em;" class="mord mathdefault">j</span><span
    /// class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist"
    /// style="height:0.32833099999999993em;"><span
    /// style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span
    /// class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3
    /// mtight"><span class="mord mathdefault mtight"
    /// style="margin-right:0.00773em;">R</span></span></span></span><span
    /// class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist"
    /// style="height:0.15em;"><span></span></span></span></span></span></span></span></span></
    /// span>. The location of each plane when this image is in linear layout can be
    ///determined via [`GetImageSubresourceLayout`], using
    ///`VK_IMAGE_ASPECT_PLANE_0_BIT` for the G plane,
    ///`VK_IMAGE_ASPECT_PLANE_1_BIT` for the B plane, and
    ///`VK_IMAGE_ASPECT_PLANE_2_BIT` for the R plane.
    ///This format only supports images with a width and height that is a
    ///multiple of two.
    ///
    ///Provided by [`crate::vulkan1_1`]
    G8B8R83Plane420Unorm = 1000156002,
    ///[`G8B8R82Plane420Unorm`] specifies an unsigned
    ///normalized *multi-planar format* that has an 8-bit G component in plane
    ///0, and a two-component, 16-bit BR plane 1 consisting of an 8-bit B
    ///component in byte 0 and an 8-bit R component in byte 1.
    ///The horizontal and vertical dimensions of the BR plane are halved
    ///relative to the image dimensions, and each R and B value is shared with
    ///the G components for which <span class="katex"><span class="katex-html"
    /// aria-hidden="true"><span class="base"><span class="strut"
    /// style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen
    /// delimcenter" style="top:0em;">⌊</span><span class="mord"><span class="mord
    /// mathdefault">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span
    /// class="vlist-r"><span style="height:0.32833099999999993em;" class="vlist"><span
    /// style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut"
    /// style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord
    /// mathdefault mtight">G</span></span></span></span><span class="vlist-s">​</span></span><span
    /// class="vlist-r"><span style="height:0.15em;"
    /// class="vlist"><span></span></span></span></span></span></span><span
    /// style="margin-right:0.2222222222222222em;" class="mspace"></span><span
    /// class="mbin">×</span><span style="margin-right:0.2222222222222222em;"
    /// class="mspace"></span><span class="mord">0</span><span class="mord">.</span><span
    /// class="mord">5</span><span class="mclose delimcenter" style="top:0em;">⌋</span></span><span
    /// style="margin-right:0.2777777777777778em;" class="mspace"></span><span
    /// class="mrel">=</span><span class="mspace"
    /// style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span
    /// style="height:0.80952em;vertical-align:-0.15em;" class="strut"></span><span
    /// class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span
    /// class="vlist-t vlist-t2"><span class="vlist-r"><span style="height:0.32833099999999993em;"
    /// class="vlist"><span
    /// style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut"
    /// style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span
    /// style="margin-right:0.05017em;" class="mord mathdefault
    /// mtight">B</span></span></span></span><span class="vlist-s">​</span></span><span
    /// class="vlist-r"><span style="height:0.15em;"
    /// class="vlist"><span></span></span></span></span></span></span><span
    /// style="margin-right:0.2777777777777778em;" class="mspace"></span><span
    /// class="mrel">=</span><span class="mspace"
    /// style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span
    /// class="strut" style="height:0.80952em;vertical-align:-0.15em;"></span><span
    /// class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span
    /// class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist"
    /// style="height:0.32833099999999993em;"><span
    /// style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span
    /// style="height:2.7em;" class="pstrut"></span><span class="sizing reset-size6 size3
    /// mtight"><span style="margin-right:0.00773em;" class="mord mathdefault
    /// mtight">R</span></span></span></span><span class="vlist-s">​</span></span><span
    /// class="vlist-r"><span class="vlist"
    /// style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>
    /// and <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span
    /// style="height:1em;vertical-align:-0.25em;" class="strut"></span><span class="minner"><span
    /// style="top:0em;" class="mopen delimcenter">⌊</span><span class="mord"><span
    /// style="margin-right:0.05724em;" class="mord mathdefault">j</span><span class="msupsub"><span
    /// class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist"
    /// style="height:0.32833099999999993em;"><span
    /// style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span
    /// class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3
    /// mtight"><span class="mord mathdefault mtight">G</span></span></span></span><span
    /// class="vlist-s">​</span></span><span class="vlist-r"><span style="height:0.15em;"
    /// class="vlist"><span></span></span></span></span></span></span><span class="mspace"
    /// style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span
    /// style="margin-right:0.2222222222222222em;" class="mspace"></span><span
    /// class="mord">0</span><span class="mord">.</span><span class="mord">5</span><span
    /// style="top:0em;" class="mclose delimcenter">⌋</span></span><span class="mspace"
    /// style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span
    /// class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span
    /// class="base"><span style="height:0.85396em;vertical-align:-0.19444em;"
    /// class="strut"></span><span class="mord"><span style="margin-right:0.05724em;" class="mord
    /// mathdefault">j</span><span class="msupsub"><span class="vlist-t vlist-t2"><span
    /// class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span
    /// style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span
    /// style="height:2.7em;" class="pstrut"></span><span class="sizing reset-size6 size3
    /// mtight"><span style="margin-right:0.05017em;" class="mord mathdefault
    /// mtight">B</span></span></span></span><span class="vlist-s">​</span></span><span
    /// class="vlist-r"><span class="vlist"
    /// style="height:0.15em;"><span></span></span></span></span></span></span><span
    /// style="margin-right:0.2777777777777778em;" class="mspace"></span><span
    /// class="mrel">=</span><span class="mspace"
    /// style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span
    /// class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span
    /// class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span
    /// class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span
    /// style="height:0.32833099999999993em;" class="vlist"><span
    /// style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span
    /// class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3
    /// mtight"><span style="margin-right:0.00773em;" class="mord mathdefault
    /// mtight">R</span></span></span></span><span class="vlist-s">​</span></span><span
    /// class="vlist-r"><span style="height:0.15em;"
    /// class="vlist"><span></span></span></span></span></span></span></span></span></span>. The
    /// location of each plane when this image is in linear layout can be determined via
    /// [`GetImageSubresourceLayout`], using `VK_IMAGE_ASPECT_PLANE_0_BIT` for the G plane, and
    ///`VK_IMAGE_ASPECT_PLANE_1_BIT` for the BR plane.
    ///This format only supports images with a width and height that is a
    ///multiple of two.
    ///
    ///Provided by [`crate::vulkan1_1`]
    G8B8R82Plane420Unorm = 1000156003,
    ///[`G8B8R83Plane422Unorm`] specifies an unsigned
    ///normalized *multi-planar format* that has an 8-bit G component in plane
    ///0, an 8-bit B component in plane 1, and an 8-bit R component in plane 2.
    ///The horizontal dimension of the R and B plane is halved relative to the
    ///image dimensions, and each R and B value is shared with the G components
    ///for which <span class="katex"><span class="katex-html" aria-hidden="true"><span
    /// class="base"><span style="height:1em;vertical-align:-0.25em;" class="strut"></span><span
    /// class="minner"><span class="mopen delimcenter" style="top:0em;">⌊</span><span
    /// class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span
    /// class="vlist-t vlist-t2"><span class="vlist-r"><span style="height:0.32833099999999993em;"
    /// class="vlist"><span
    /// style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut"
    /// style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord
    /// mathdefault mtight">G</span></span></span></span><span class="vlist-s">​</span></span><span
    /// class="vlist-r"><span class="vlist"
    /// style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace"
    /// style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span
    /// style="margin-right:0.2222222222222222em;" class="mspace"></span><span
    /// class="mord">0</span><span class="mord">.</span><span class="mord">5</span><span
    /// class="mclose delimcenter" style="top:0em;">⌋</span></span><span class="mspace"
    /// style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span
    /// style="margin-right:0.2777777777777778em;" class="mspace"></span></span><span
    /// class="base"><span class="strut"
    /// style="height:0.80952em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord
    /// mathdefault">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span
    /// class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span
    /// style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span
    /// style="height:2.7em;" class="pstrut"></span><span class="sizing reset-size6 size3
    /// mtight"><span style="margin-right:0.05017em;" class="mord mathdefault
    /// mtight">B</span></span></span></span><span class="vlist-s">​</span></span><span
    /// class="vlist-r"><span style="height:0.15em;"
    /// class="vlist"><span></span></span></span></span></span></span><span class="mspace"
    /// style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span
    /// style="margin-right:0.2777777777777778em;" class="mspace"></span></span><span
    /// class="base"><span style="height:0.80952em;vertical-align:-0.15em;"
    /// class="strut"></span><span class="mord"><span class="mord mathdefault">i</span><span
    /// class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span
    /// style="height:0.32833099999999993em;" class="vlist"><span
    /// style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span
    /// style="height:2.7em;" class="pstrut"></span><span class="sizing reset-size6 size3
    /// mtight"><span class="mord mathdefault mtight"
    /// style="margin-right:0.00773em;">R</span></span></span></span><span
    /// class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist"
    /// style="height:0.15em;"><span></span></span></span></span></span></span></span></span></
    /// span>. The location of each plane when this image is in linear layout can be
    ///determined via [`GetImageSubresourceLayout`], using
    ///`VK_IMAGE_ASPECT_PLANE_0_BIT` for the G plane,
    ///`VK_IMAGE_ASPECT_PLANE_1_BIT` for the B plane, and
    ///`VK_IMAGE_ASPECT_PLANE_2_BIT` for the R plane.
    ///This format only supports images with a width that is a multiple of two.
    ///
    ///Provided by [`crate::vulkan1_1`]
    G8B8R83Plane422Unorm = 1000156004,
    ///[`G8B8R82Plane422Unorm`] specifies an unsigned
    ///normalized *multi-planar format* that has an 8-bit G component in plane
    ///0, and a two-component, 16-bit BR plane 1 consisting of an 8-bit B
    ///component in byte 0 and an 8-bit R component in byte 1.
    ///The horizontal dimension of the BR plane is halved relative to the image
    ///dimensions, and each R and B value is shared with the G components for
    ///which <span class="katex"><span class="katex-html" aria-hidden="true"><span
    /// class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span
    /// class="minner"><span class="mopen delimcenter" style="top:0em;">⌊</span><span
    /// class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span
    /// class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist"
    /// style="height:0.32833099999999993em;"><span
    /// style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span
    /// style="height:2.7em;" class="pstrut"></span><span class="sizing reset-size6 size3
    /// mtight"><span class="mord mathdefault mtight">G</span></span></span></span><span
    /// class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist"
    /// style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace"
    /// style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span
    /// class="mspace" style="margin-right:0.2222222222222222em;"></span><span
    /// class="mord">0</span><span class="mord">.</span><span class="mord">5</span><span
    /// class="mclose delimcenter" style="top:0em;">⌋</span></span><span class="mspace"
    /// style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span
    /// style="margin-right:0.2777777777777778em;" class="mspace"></span></span><span
    /// class="base"><span style="height:0.80952em;vertical-align:-0.15em;"
    /// class="strut"></span><span class="mord"><span class="mord mathdefault">i</span><span
    /// class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist"
    /// style="height:0.32833099999999993em;"><span
    /// style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span
    /// style="height:2.7em;" class="pstrut"></span><span class="sizing reset-size6 size3
    /// mtight"><span class="mord mathdefault mtight"
    /// style="margin-right:0.05017em;">B</span></span></span></span><span
    /// class="vlist-s">​</span></span><span class="vlist-r"><span style="height:0.15em;"
    /// class="vlist"><span></span></span></span></span></span></span><span
    /// style="margin-right:0.2777777777777778em;" class="mspace"></span><span
    /// class="mrel">=</span><span style="margin-right:0.2777777777777778em;"
    /// class="mspace"></span></span><span class="base"><span
    /// style="height:0.80952em;vertical-align:-0.15em;" class="strut"></span><span
    /// class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span
    /// class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist"
    /// style="height:0.32833099999999993em;"><span
    /// style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut"
    /// style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord
    /// mathdefault mtight" style="margin-right:0.00773em;">R</span></span></span></span><span
    /// class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist"
    /// style="height:0.15em;"><span></span></span></span></span></span></span></span></span></
    /// span>. The location of each plane when this image is in linear layout can be
    ///determined via [`GetImageSubresourceLayout`], using
    ///`VK_IMAGE_ASPECT_PLANE_0_BIT` for the G plane, and
    ///`VK_IMAGE_ASPECT_PLANE_1_BIT` for the BR plane.
    ///This format only supports images with a width that is a multiple of two.
    ///
    ///Provided by [`crate::vulkan1_1`]
    G8B8R82Plane422Unorm = 1000156005,
    ///[`G8B8R83Plane444Unorm`] specifies an unsigned
    ///normalized *multi-planar format* that has an 8-bit G component in plane
    ///0, an 8-bit B component in plane 1, and an 8-bit R component in plane 2.
    ///Each plane has the same dimensions and each R, G and B component
    ///contributes to a single texel.
    ///The location of each plane when this image is in linear layout can be
    ///determined via [`GetImageSubresourceLayout`], using
    ///`VK_IMAGE_ASPECT_PLANE_0_BIT` for the G plane,
    ///`VK_IMAGE_ASPECT_PLANE_1_BIT` for the B plane, and
    ///`VK_IMAGE_ASPECT_PLANE_2_BIT` for the R plane.
    ///
    ///Provided by [`crate::vulkan1_1`]
    G8B8R83Plane444Unorm = 1000156006,
    ///[`R10X6UnormPack16`] specifies a one-component, 16-bit
    ///unsigned normalized format that has a single 10-bit R component in the
    ///top 10 bits of a 16-bit word, with the bottom 6 bits unused.
    ///
    ///Provided by [`crate::vulkan1_1`]
    R10X6UnormPack16 = 1000156007,
    ///[`R10X6G10X6Unorm2Pack16`] specifies a two-component,
    ///32-bit unsigned normalized format that has a 10-bit R component in the
    ///top 10 bits of the word in bytes 0..1, and a 10-bit G component in the
    ///top 10 bits of the word in bytes 2..3, with the bottom 6 bits of each
    ///word unused.
    ///
    ///Provided by [`crate::vulkan1_1`]
    R10X6G10X6Unorm2Pack16 = 1000156008,
    ///[`R10X6G10X6B10X6A10X6Unorm4Pack16`] specifies a
    ///four-component, 64-bit unsigned normalized format that has a 10-bit R
    ///component in the top 10 bits of the word in bytes 0..1, a 10-bit G
    ///component in the top 10 bits of the word in bytes 2..3, a 10-bit B
    ///component in the top 10 bits of the word in bytes 4..5, and a 10-bit A
    ///component in the top 10 bits of the word in bytes 6..7, with the bottom
    ///6 bits of each word unused.
    ///
    ///Provided by [`crate::vulkan1_1`]
    R10X6G10X6B10X6A10X6Unorm4Pack16 = 1000156009,
    ///[`G10X6B10X6G10X6R10X6422Unorm4Pack16`] specifies a
    ///four-component, 64-bit format containing a pair of G components, an R
    ///component, and a B component, collectively encoding a 2×1
    ///rectangle of unsigned normalized RGB texel data.
    ///One G value is present at each *i* coordinate, with the B and R values
    ///shared across both G values and thus recorded at half the horizontal
    ///resolution of the image.
    ///This format has a 10-bit G component for the even *i* coordinate in the
    ///top 10 bits of the word in bytes 0..1, a 10-bit B component in the top
    ///10 bits of the word in bytes 2..3, a 10-bit G component for the odd *i*
    ///coordinate in the top 10 bits of the word in bytes 4..5, and a 10-bit R
    ///component in the top 10 bits of the word in bytes 6..7, with the bottom
    ///6 bits of each word unused.
    ///This format only supports images with a width that is a multiple of two.
    ///For the purposes of the constraints on copy extents, this format is
    ///treated as a compressed format with a 2×1 compressed texel block.
    ///
    ///Provided by [`crate::vulkan1_1`]
    G10X6B10X6G10X6R10X6422Unorm4Pack16 = 1000156010,
    ///[`B10X6G10X6R10X6G10X6422Unorm4Pack16`] specifies a
    ///four-component, 64-bit format containing a pair of G components, an R
    ///component, and a B component, collectively encoding a 2×1
    ///rectangle of unsigned normalized RGB texel data.
    ///One G value is present at each *i* coordinate, with the B and R values
    ///shared across both G values and thus recorded at half the horizontal
    ///resolution of the image.
    ///This format has a 10-bit B component in the top 10 bits of the word in
    ///bytes 0..1, a 10-bit G component for the even *i* coordinate in the top
    ///10 bits of the word in bytes 2..3, a 10-bit R component in the top 10
    ///bits of the word in bytes 4..5, and a 10-bit G component for the odd *i*
    ///coordinate in the top 10 bits of the word in bytes 6..7, with the bottom
    ///6 bits of each word unused.
    ///This format only supports images with a width that is a multiple of two.
    ///For the purposes of the constraints on copy extents, this format is
    ///treated as a compressed format with a 2×1 compressed texel block.
    ///
    ///Provided by [`crate::vulkan1_1`]
    B10X6G10X6R10X6G10X6422Unorm4Pack16 = 1000156011,
    ///[`G10X6B10X6R10X63Plane420Unorm3Pack16`] specifies an
    ///unsigned normalized *multi-planar format* that has a 10-bit G component
    ///in the top 10 bits of each 16-bit word of plane 0, a 10-bit B component
    ///in the top 10 bits of each 16-bit word of plane 1, and a 10-bit R
    ///component in the top 10 bits of each 16-bit word of plane 2, with the
    ///bottom 6 bits of each word unused.
    ///The horizontal and vertical dimensions of the R and B planes are halved
    ///relative to the image dimensions, and each R and B component is shared
    ///with the G components for which <span class="katex"><span class="katex-html"
    /// aria-hidden="true"><span class="base"><span style="height:1em;vertical-align:-0.25em;"
    /// class="strut"></span><span class="minner"><span style="top:0em;" class="mopen
    /// delimcenter">⌊</span><span class="mord"><span class="mord mathdefault">i</span><span
    /// class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span
    /// style="height:0.32833099999999993em;" class="vlist"><span
    /// style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span
    /// style="height:2.7em;" class="pstrut"></span><span class="sizing reset-size6 size3
    /// mtight"><span class="mord mathdefault mtight">G</span></span></span></span><span
    /// class="vlist-s">​</span></span><span class="vlist-r"><span style="height:0.15em;"
    /// class="vlist"><span></span></span></span></span></span></span><span
    /// style="margin-right:0.2222222222222222em;" class="mspace"></span><span
    /// class="mbin">×</span><span class="mspace"
    /// style="margin-right:0.2222222222222222em;"></span><span class="mord">0</span><span
    /// class="mord">.</span><span class="mord">5</span><span style="top:0em;" class="mclose
    /// delimcenter">⌋</span></span><span style="margin-right:0.2777777777777778em;"
    /// class="mspace"></span><span class="mrel">=</span><span class="mspace"
    /// style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span
    /// style="height:0.80952em;vertical-align:-0.15em;" class="strut"></span><span
    /// class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span
    /// class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist"
    /// style="height:0.32833099999999993em;"><span
    /// style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut"
    /// style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord
    /// mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span><span
    /// class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist"
    /// style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace"
    /// style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span
    /// style="margin-right:0.2777777777777778em;" class="mspace"></span></span><span
    /// class="base"><span class="strut"
    /// style="height:0.80952em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord
    /// mathdefault">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span
    /// class="vlist-r"><span style="height:0.32833099999999993em;" class="vlist"><span
    /// style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span
    /// style="height:2.7em;" class="pstrut"></span><span class="sizing reset-size6 size3
    /// mtight"><span style="margin-right:0.00773em;" class="mord mathdefault
    /// mtight">R</span></span></span></span><span class="vlist-s">​</span></span><span
    /// class="vlist-r"><span class="vlist"
    /// style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>
    /// and <span class="katex"><span aria-hidden="true" class="katex-html"><span class="base"><span
    /// class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span
    /// style="top:0em;" class="mopen delimcenter">⌊</span><span class="mord"><span
    /// style="margin-right:0.05724em;" class="mord mathdefault">j</span><span class="msupsub"><span
    /// class="vlist-t vlist-t2"><span class="vlist-r"><span style="height:0.32833099999999993em;"
    /// class="vlist"><span
    /// style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span
    /// style="height:2.7em;" class="pstrut"></span><span class="sizing reset-size6 size3
    /// mtight"><span class="mord mathdefault mtight">G</span></span></span></span><span
    /// class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist"
    /// style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace"
    /// style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span
    /// class="mspace" style="margin-right:0.2222222222222222em;"></span><span
    /// class="mord">0</span><span class="mord">.</span><span class="mord">5</span><span
    /// style="top:0em;" class="mclose delimcenter">⌋</span></span><span class="mspace"
    /// style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span
    /// style="margin-right:0.2777777777777778em;" class="mspace"></span></span><span
    /// class="base"><span style="height:0.85396em;vertical-align:-0.19444em;"
    /// class="strut"></span><span class="mord"><span class="mord mathdefault"
    /// style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t
    /// vlist-t2"><span class="vlist-r"><span class="vlist"
    /// style="height:0.32833099999999993em;"><span
    /// style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span
    /// style="height:2.7em;" class="pstrut"></span><span class="sizing reset-size6 size3
    /// mtight"><span style="margin-right:0.05017em;" class="mord mathdefault
    /// mtight">B</span></span></span></span><span class="vlist-s">​</span></span><span
    /// class="vlist-r"><span style="height:0.15em;"
    /// class="vlist"><span></span></span></span></span></span></span><span class="mspace"
    /// style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span
    /// class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span
    /// class="base"><span class="strut"
    /// style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord"><span
    /// style="margin-right:0.05724em;" class="mord mathdefault">j</span><span class="msupsub"><span
    /// class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist"
    /// style="height:0.32833099999999993em;"><span
    /// style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span
    /// style="height:2.7em;" class="pstrut"></span><span class="sizing reset-size6 size3
    /// mtight"><span style="margin-right:0.00773em;" class="mord mathdefault
    /// mtight">R</span></span></span></span><span class="vlist-s">​</span></span><span
    /// class="vlist-r"><span class="vlist"
    /// style="height:0.15em;"><span></span></span></span></span></span></span></span></span></
    /// span>. The location of each plane when this image is in linear layout can be
    ///determined via [`GetImageSubresourceLayout`], using
    ///`VK_IMAGE_ASPECT_PLANE_0_BIT` for the G plane,
    ///`VK_IMAGE_ASPECT_PLANE_1_BIT` for the B plane, and
    ///`VK_IMAGE_ASPECT_PLANE_2_BIT` for the R plane.
    ///This format only supports images with a width and height that is a
    ///multiple of two.
    ///
    ///Provided by [`crate::vulkan1_1`]
    G10X6B10X6R10X63Plane420Unorm3Pack16 = 1000156012,
    ///[`G10X6B10X6R10X62Plane420Unorm3Pack16`] specifies an
    ///unsigned normalized *multi-planar format* that has a 10-bit G component
    ///in the top 10 bits of each 16-bit word of plane 0, and a two-component,
    ///32-bit BR plane 1 consisting of a 10-bit B component in the top 10 bits
    ///of the word in bytes 0..1, and a 10-bit R component in the top 10 bits
    ///of the word in bytes 2..3, with the bottom 6 bits of each word unused.
    ///The horizontal and vertical dimensions of the BR plane are halved
    ///relative to the image dimensions, and each R and B value is shared with
    ///the G components for which <span class="katex"><span class="katex-html"
    /// aria-hidden="true"><span class="base"><span class="strut"
    /// style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span
    /// style="top:0em;" class="mopen delimcenter">⌊</span><span class="mord"><span class="mord
    /// mathdefault">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span
    /// class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span
    /// style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span
    /// style="height:2.7em;" class="pstrut"></span><span class="sizing reset-size6 size3
    /// mtight"><span class="mord mathdefault mtight">G</span></span></span></span><span
    /// class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist"
    /// style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace"
    /// style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span
    /// class="mspace" style="margin-right:0.2222222222222222em;"></span><span
    /// class="mord">0</span><span class="mord">.</span><span class="mord">5</span><span
    /// style="top:0em;" class="mclose delimcenter">⌋</span></span><span class="mspace"
    /// style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span
    /// class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span
    /// class="base"><span style="height:0.80952em;vertical-align:-0.15em;"
    /// class="strut"></span><span class="mord"><span class="mord mathdefault">i</span><span
    /// class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist"
    /// style="height:0.32833099999999993em;"><span
    /// style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span
    /// style="height:2.7em;" class="pstrut"></span><span class="sizing reset-size6 size3
    /// mtight"><span style="margin-right:0.05017em;" class="mord mathdefault
    /// mtight">B</span></span></span></span><span class="vlist-s">​</span></span><span
    /// class="vlist-r"><span class="vlist"
    /// style="height:0.15em;"><span></span></span></span></span></span></span><span
    /// style="margin-right:0.2777777777777778em;" class="mspace"></span><span
    /// class="mrel">=</span><span style="margin-right:0.2777777777777778em;"
    /// class="mspace"></span></span><span class="base"><span class="strut"
    /// style="height:0.80952em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord
    /// mathdefault">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span
    /// class="vlist-r"><span style="height:0.32833099999999993em;" class="vlist"><span
    /// style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut"
    /// style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span
    /// style="margin-right:0.00773em;" class="mord mathdefault
    /// mtight">R</span></span></span></span><span class="vlist-s">​</span></span><span
    /// class="vlist-r"><span class="vlist"
    /// style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>
    /// and <span class="katex"><span aria-hidden="true" class="katex-html"><span class="base"><span
    /// class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span
    /// class="mopen delimcenter" style="top:0em;">⌊</span><span class="mord"><span class="mord
    /// mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span
    /// class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist"
    /// style="height:0.32833099999999993em;"><span
    /// style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span
    /// class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3
    /// mtight"><span class="mord mathdefault mtight">G</span></span></span></span><span
    /// class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist"
    /// style="height:0.15em;"><span></span></span></span></span></span></span><span
    /// style="margin-right:0.2222222222222222em;" class="mspace"></span><span
    /// class="mbin">×</span><span class="mspace"
    /// style="margin-right:0.2222222222222222em;"></span><span class="mord">0</span><span
    /// class="mord">.</span><span class="mord">5</span><span class="mclose delimcenter"
    /// style="top:0em;">⌋</span></span><span class="mspace"
    /// style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span
    /// class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span
    /// class="base"><span class="strut"
    /// style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord"><span
    /// class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span
    /// class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist"
    /// style="height:0.32833099999999993em;"><span
    /// style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span
    /// class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3
    /// mtight"><span class="mord mathdefault mtight"
    /// style="margin-right:0.05017em;">B</span></span></span></span><span
    /// class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist"
    /// style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace"
    /// style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span
    /// style="margin-right:0.2777777777777778em;" class="mspace"></span></span><span
    /// class="base"><span class="strut"
    /// style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord"><span
    /// style="margin-right:0.05724em;" class="mord mathdefault">j</span><span class="msupsub"><span
    /// class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist"
    /// style="height:0.32833099999999993em;"><span
    /// style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span
    /// class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3
    /// mtight"><span class="mord mathdefault mtight"
    /// style="margin-right:0.00773em;">R</span></span></span></span><span
    /// class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist"
    /// style="height:0.15em;"><span></span></span></span></span></span></span></span></span></
    /// span>. The location of each plane when this image is in linear layout can be
    ///determined via [`GetImageSubresourceLayout`], using
    ///`VK_IMAGE_ASPECT_PLANE_0_BIT` for the G plane, and
    ///`VK_IMAGE_ASPECT_PLANE_1_BIT` for the BR plane.
    ///This format only supports images with a width and height that is a
    ///multiple of two.
    ///
    ///Provided by [`crate::vulkan1_1`]
    G10X6B10X6R10X62Plane420Unorm3Pack16 = 1000156013,
    ///[`G10X6B10X6R10X63Plane422Unorm3Pack16`] specifies an
    ///unsigned normalized *multi-planar format* that has a 10-bit G component
    ///in the top 10 bits of each 16-bit word of plane 0, a 10-bit B component
    ///in the top 10 bits of each 16-bit word of plane 1, and a 10-bit R
    ///component in the top 10 bits of each 16-bit word of plane 2, with the
    ///bottom 6 bits of each word unused.
    ///The horizontal dimension of the R and B plane is halved relative to the
    ///image dimensions, and each R and B value is shared with the G components
    ///for which <span class="katex"><span class="katex-html" aria-hidden="true"><span
    /// class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span
    /// class="minner"><span class="mopen delimcenter" style="top:0em;">⌊</span><span
    /// class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span
    /// class="vlist-t vlist-t2"><span class="vlist-r"><span style="height:0.32833099999999993em;"
    /// class="vlist"><span
    /// style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut"
    /// style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord
    /// mathdefault mtight">G</span></span></span></span><span class="vlist-s">​</span></span><span
    /// class="vlist-r"><span class="vlist"
    /// style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace"
    /// style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span
    /// style="margin-right:0.2222222222222222em;" class="mspace"></span><span
    /// class="mord">0</span><span class="mord">.</span><span class="mord">5</span><span
    /// class="mclose delimcenter" style="top:0em;">⌋</span></span><span
    /// style="margin-right:0.2777777777777778em;" class="mspace"></span><span
    /// class="mrel">=</span><span class="mspace"
    /// style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span
    /// style="height:0.80952em;vertical-align:-0.15em;" class="strut"></span><span
    /// class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span
    /// class="vlist-t vlist-t2"><span class="vlist-r"><span style="height:0.32833099999999993em;"
    /// class="vlist"><span
    /// style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span
    /// style="height:2.7em;" class="pstrut"></span><span class="sizing reset-size6 size3
    /// mtight"><span class="mord mathdefault mtight"
    /// style="margin-right:0.05017em;">B</span></span></span></span><span
    /// class="vlist-s">​</span></span><span class="vlist-r"><span style="height:0.15em;"
    /// class="vlist"><span></span></span></span></span></span></span><span
    /// style="margin-right:0.2777777777777778em;" class="mspace"></span><span
    /// class="mrel">=</span><span style="margin-right:0.2777777777777778em;"
    /// class="mspace"></span></span><span class="base"><span class="strut"
    /// style="height:0.80952em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord
    /// mathdefault">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span
    /// class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span
    /// style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut"
    /// style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord
    /// mathdefault mtight" style="margin-right:0.00773em;">R</span></span></span></span><span
    /// class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist"
    /// style="height:0.15em;"><span></span></span></span></span></span></span></span></span></
    /// span>. The location of each plane when this image is in linear layout can be
    ///determined via [`GetImageSubresourceLayout`], using
    ///`VK_IMAGE_ASPECT_PLANE_0_BIT` for the G plane,
    ///`VK_IMAGE_ASPECT_PLANE_1_BIT` for the B plane, and
    ///`VK_IMAGE_ASPECT_PLANE_2_BIT` for the R plane.
    ///This format only supports images with a width that is a multiple of two.
    ///
    ///Provided by [`crate::vulkan1_1`]
    G10X6B10X6R10X63Plane422Unorm3Pack16 = 1000156014,
    ///[`G10X6B10X6R10X62Plane422Unorm3Pack16`] specifies an
    ///unsigned normalized *multi-planar format* that has a 10-bit G component
    ///in the top 10 bits of each 16-bit word of plane 0, and a two-component,
    ///32-bit BR plane 1 consisting of a 10-bit B component in the top 10 bits
    ///of the word in bytes 0..1, and a 10-bit R component in the top 10 bits
    ///of the word in bytes 2..3, with the bottom 6 bits of each word unused.
    ///The horizontal dimension of the BR plane is halved relative to the image
    ///dimensions, and each R and B value is shared with the G components for
    ///which <span class="katex"><span class="katex-html" aria-hidden="true"><span
    /// class="base"><span style="height:1em;vertical-align:-0.25em;" class="strut"></span><span
    /// class="minner"><span style="top:0em;" class="mopen delimcenter">⌊</span><span
    /// class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span
    /// class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist"
    /// style="height:0.32833099999999993em;"><span
    /// style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut"
    /// style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord
    /// mathdefault mtight">G</span></span></span></span><span class="vlist-s">​</span></span><span
    /// class="vlist-r"><span style="height:0.15em;"
    /// class="vlist"><span></span></span></span></span></span></span><span class="mspace"
    /// style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span
    /// class="mspace" style="margin-right:0.2222222222222222em;"></span><span
    /// class="mord">0</span><span class="mord">.</span><span class="mord">5</span><span
    /// style="top:0em;" class="mclose delimcenter">⌋</span></span><span class="mspace"
    /// style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span
    /// style="margin-right:0.2777777777777778em;" class="mspace"></span></span><span
    /// class="base"><span style="height:0.80952em;vertical-align:-0.15em;"
    /// class="strut"></span><span class="mord"><span class="mord mathdefault">i</span><span
    /// class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span
    /// style="height:0.32833099999999993em;" class="vlist"><span
    /// style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span
    /// style="height:2.7em;" class="pstrut"></span><span class="sizing reset-size6 size3
    /// mtight"><span class="mord mathdefault mtight"
    /// style="margin-right:0.05017em;">B</span></span></span></span><span
    /// class="vlist-s">​</span></span><span class="vlist-r"><span style="height:0.15em;"
    /// class="vlist"><span></span></span></span></span></span></span><span class="mspace"
    /// style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span
    /// class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span
    /// class="base"><span style="height:0.80952em;vertical-align:-0.15em;"
    /// class="strut"></span><span class="mord"><span class="mord mathdefault">i</span><span
    /// class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist"
    /// style="height:0.32833099999999993em;"><span
    /// style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut"
    /// style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord
    /// mathdefault mtight" style="margin-right:0.00773em;">R</span></span></span></span><span
    /// class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist"
    /// style="height:0.15em;"><span></span></span></span></span></span></span></span></span></
    /// span>. The location of each plane when this image is in linear layout can be
    ///determined via [`GetImageSubresourceLayout`], using
    ///`VK_IMAGE_ASPECT_PLANE_0_BIT` for the G plane, and
    ///`VK_IMAGE_ASPECT_PLANE_1_BIT` for the BR plane.
    ///This format only supports images with a width that is a multiple of two.
    ///
    ///Provided by [`crate::vulkan1_1`]
    G10X6B10X6R10X62Plane422Unorm3Pack16 = 1000156015,
    ///[`G10X6B10X6R10X63Plane444Unorm3Pack16`] specifies an
    ///unsigned normalized *multi-planar format* that has a 10-bit G component
    ///in the top 10 bits of each 16-bit word of plane 0, a 10-bit B component
    ///in the top 10 bits of each 16-bit word of plane 1, and a 10-bit R
    ///component in the top 10 bits of each 16-bit word of plane 2, with the
    ///bottom 6 bits of each word unused.
    ///Each plane has the same dimensions and each R, G and B component
    ///contributes to a single texel.
    ///The location of each plane when this image is in linear layout can be
    ///determined via [`GetImageSubresourceLayout`], using
    ///`VK_IMAGE_ASPECT_PLANE_0_BIT` for the G plane,
    ///`VK_IMAGE_ASPECT_PLANE_1_BIT` for the B plane, and
    ///`VK_IMAGE_ASPECT_PLANE_2_BIT` for the R plane.
    ///
    ///Provided by [`crate::vulkan1_1`]
    G10X6B10X6R10X63Plane444Unorm3Pack16 = 1000156016,
    ///[`R12X4UnormPack16`] specifies a one-component, 16-bit
    ///unsigned normalized format that has a single 12-bit R component in the
    ///top 12 bits of a 16-bit word, with the bottom 4 bits unused.
    ///
    ///Provided by [`crate::vulkan1_1`]
    R12X4UnormPack16 = 1000156017,
    ///[`R12X4G12X4Unorm2Pack16`] specifies a two-component,
    ///32-bit unsigned normalized format that has a 12-bit R component in the
    ///top 12 bits of the word in bytes 0..1, and a 12-bit G component in the
    ///top 12 bits of the word in bytes 2..3, with the bottom 4 bits of each
    ///word unused.
    ///
    ///Provided by [`crate::vulkan1_1`]
    R12X4G12X4Unorm2Pack16 = 1000156018,
    ///[`R12X4G12X4B12X4A12X4Unorm4Pack16`] specifies a
    ///four-component, 64-bit unsigned normalized format that has a 12-bit R
    ///component in the top 12 bits of the word in bytes 0..1, a 12-bit G
    ///component in the top 12 bits of the word in bytes 2..3, a 12-bit B
    ///component in the top 12 bits of the word in bytes 4..5, and a 12-bit A
    ///component in the top 12 bits of the word in bytes 6..7, with the bottom
    ///4 bits of each word unused.
    ///
    ///Provided by [`crate::vulkan1_1`]
    R12X4G12X4B12X4A12X4Unorm4Pack16 = 1000156019,
    ///[`G12X4B12X4G12X4R12X4422Unorm4Pack16`] specifies a
    ///four-component, 64-bit format containing a pair of G components, an R
    ///component, and a B component, collectively encoding a 2×1
    ///rectangle of unsigned normalized RGB texel data.
    ///One G value is present at each *i* coordinate, with the B and R values
    ///shared across both G values and thus recorded at half the horizontal
    ///resolution of the image.
    ///This format has a 12-bit G component for the even *i* coordinate in the
    ///top 12 bits of the word in bytes 0..1, a 12-bit B component in the top
    ///12 bits of the word in bytes 2..3, a 12-bit G component for the odd *i*
    ///coordinate in the top 12 bits of the word in bytes 4..5, and a 12-bit R
    ///component in the top 12 bits of the word in bytes 6..7, with the bottom
    ///4 bits of each word unused.
    ///This format only supports images with a width that is a multiple of two.
    ///For the purposes of the constraints on copy extents, this format is
    ///treated as a compressed format with a 2×1 compressed texel block.
    ///
    ///Provided by [`crate::vulkan1_1`]
    G12X4B12X4G12X4R12X4422Unorm4Pack16 = 1000156020,
    ///[`B12X4G12X4R12X4G12X4422Unorm4Pack16`] specifies a
    ///four-component, 64-bit format containing a pair of G components, an R
    ///component, and a B component, collectively encoding a 2×1
    ///rectangle of unsigned normalized RGB texel data.
    ///One G value is present at each *i* coordinate, with the B and R values
    ///shared across both G values and thus recorded at half the horizontal
    ///resolution of the image.
    ///This format has a 12-bit B component in the top 12 bits of the word in
    ///bytes 0..1, a 12-bit G component for the even *i* coordinate in the top
    ///12 bits of the word in bytes 2..3, a 12-bit R component in the top 12
    ///bits of the word in bytes 4..5, and a 12-bit G component for the odd *i*
    ///coordinate in the top 12 bits of the word in bytes 6..7, with the bottom
    ///4 bits of each word unused.
    ///This format only supports images with a width that is a multiple of two.
    ///For the purposes of the constraints on copy extents, this format is
    ///treated as a compressed format with a 2×1 compressed texel block.
    ///
    ///Provided by [`crate::vulkan1_1`]
    B12X4G12X4R12X4G12X4422Unorm4Pack16 = 1000156021,
    ///[`G12X4B12X4R12X43Plane420Unorm3Pack16`] specifies an
    ///unsigned normalized *multi-planar format* that has a 12-bit G component
    ///in the top 12 bits of each 16-bit word of plane 0, a 12-bit B component
    ///in the top 12 bits of each 16-bit word of plane 1, and a 12-bit R
    ///component in the top 12 bits of each 16-bit word of plane 2, with the
    ///bottom 4 bits of each word unused.
    ///The horizontal and vertical dimensions of the R and B planes are halved
    ///relative to the image dimensions, and each R and B component is shared
    ///with the G components for which <span class="katex"><span aria-hidden="true"
    /// class="katex-html"><span class="base"><span class="strut"
    /// style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen
    /// delimcenter" style="top:0em;">⌊</span><span class="mord"><span class="mord
    /// mathdefault">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span
    /// class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span
    /// style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut"
    /// style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord
    /// mathdefault mtight">G</span></span></span></span><span class="vlist-s">​</span></span><span
    /// class="vlist-r"><span style="height:0.15em;"
    /// class="vlist"><span></span></span></span></span></span></span><span class="mspace"
    /// style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span
    /// style="margin-right:0.2222222222222222em;" class="mspace"></span><span
    /// class="mord">0</span><span class="mord">.</span><span class="mord">5</span><span
    /// style="top:0em;" class="mclose delimcenter">⌋</span></span><span
    /// style="margin-right:0.2777777777777778em;" class="mspace"></span><span
    /// class="mrel">=</span><span class="mspace"
    /// style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span
    /// style="height:0.80952em;vertical-align:-0.15em;" class="strut"></span><span
    /// class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span
    /// class="vlist-t vlist-t2"><span class="vlist-r"><span style="height:0.32833099999999993em;"
    /// class="vlist"><span
    /// style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span
    /// style="height:2.7em;" class="pstrut"></span><span class="sizing reset-size6 size3
    /// mtight"><span style="margin-right:0.05017em;" class="mord mathdefault
    /// mtight">B</span></span></span></span><span class="vlist-s">​</span></span><span
    /// class="vlist-r"><span style="height:0.15em;"
    /// class="vlist"><span></span></span></span></span></span></span><span
    /// style="margin-right:0.2777777777777778em;" class="mspace"></span><span
    /// class="mrel">=</span><span style="margin-right:0.2777777777777778em;"
    /// class="mspace"></span></span><span class="base"><span class="strut"
    /// style="height:0.80952em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord
    /// mathdefault">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span
    /// class="vlist-r"><span style="height:0.32833099999999993em;" class="vlist"><span
    /// style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut"
    /// style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord
    /// mathdefault mtight" style="margin-right:0.00773em;">R</span></span></span></span><span
    /// class="vlist-s">​</span></span><span class="vlist-r"><span style="height:0.15em;"
    /// class="vlist"><span></span></span></span></span></span></span></span></span></span> and
    /// <span class="katex"><span aria-hidden="true" class="katex-html"><span class="base"><span
    /// style="height:1em;vertical-align:-0.25em;" class="strut"></span><span class="minner"><span
    /// style="top:0em;" class="mopen delimcenter">⌊</span><span class="mord"><span class="mord
    /// mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span
    /// class="vlist-t vlist-t2"><span class="vlist-r"><span style="height:0.32833099999999993em;"
    /// class="vlist"><span
    /// style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span
    /// class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3
    /// mtight"><span class="mord mathdefault mtight">G</span></span></span></span><span
    /// class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist"
    /// style="height:0.15em;"><span></span></span></span></span></span></span><span
    /// style="margin-right:0.2222222222222222em;" class="mspace"></span><span
    /// class="mbin">×</span><span style="margin-right:0.2222222222222222em;"
    /// class="mspace"></span><span class="mord">0</span><span class="mord">.</span><span
    /// class="mord">5</span><span style="top:0em;" class="mclose delimcenter">⌋</span></span><span
    /// style="margin-right:0.2777777777777778em;" class="mspace"></span><span
    /// class="mrel">=</span><span style="margin-right:0.2777777777777778em;"
    /// class="mspace"></span></span><span class="base"><span class="strut"
    /// style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord"><span
    /// class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span
    /// class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist"
    /// style="height:0.32833099999999993em;"><span
    /// style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span
    /// class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3
    /// mtight"><span style="margin-right:0.05017em;" class="mord mathdefault
    /// mtight">B</span></span></span></span><span class="vlist-s">​</span></span><span
    /// class="vlist-r"><span class="vlist"
    /// style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace"
    /// style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span
    /// style="margin-right:0.2777777777777778em;" class="mspace"></span></span><span
    /// class="base"><span class="strut"
    /// style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord"><span
    /// style="margin-right:0.05724em;" class="mord mathdefault">j</span><span class="msupsub"><span
    /// class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist"
    /// style="height:0.32833099999999993em;"><span
    /// style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span
    /// class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3
    /// mtight"><span style="margin-right:0.00773em;" class="mord mathdefault
    /// mtight">R</span></span></span></span><span class="vlist-s">​</span></span><span
    /// class="vlist-r"><span style="height:0.15em;"
    /// class="vlist"><span></span></span></span></span></span></span></span></span></span>. The
    /// location of each plane when this image is in linear layout can be determined via
    /// [`GetImageSubresourceLayout`], using `VK_IMAGE_ASPECT_PLANE_0_BIT` for the G plane,
    ///`VK_IMAGE_ASPECT_PLANE_1_BIT` for the B plane, and
    ///`VK_IMAGE_ASPECT_PLANE_2_BIT` for the R plane.
    ///This format only supports images with a width and height that is a
    ///multiple of two.
    ///
    ///Provided by [`crate::vulkan1_1`]
    G12X4B12X4R12X43Plane420Unorm3Pack16 = 1000156022,
    ///[`G12X4B12X4R12X42Plane420Unorm3Pack16`] specifies an
    ///unsigned normalized *multi-planar format* that has a 12-bit G component
    ///in the top 12 bits of each 16-bit word of plane 0, and a two-component,
    ///32-bit BR plane 1 consisting of a 12-bit B component in the top 12 bits
    ///of the word in bytes 0..1, and a 12-bit R component in the top 12 bits
    ///of the word in bytes 2..3, with the bottom 4 bits of each word unused.
    ///The horizontal and vertical dimensions of the BR plane are halved
    ///relative to the image dimensions, and each R and B value is shared with
    ///the G components for which <span class="katex"><span aria-hidden="true"
    /// class="katex-html"><span class="base"><span class="strut"
    /// style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span
    /// style="top:0em;" class="mopen delimcenter">⌊</span><span class="mord"><span class="mord
    /// mathdefault">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span
    /// class="vlist-r"><span style="height:0.32833099999999993em;" class="vlist"><span
    /// style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span
    /// style="height:2.7em;" class="pstrut"></span><span class="sizing reset-size6 size3
    /// mtight"><span class="mord mathdefault mtight">G</span></span></span></span><span
    /// class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist"
    /// style="height:0.15em;"><span></span></span></span></span></span></span><span
    /// style="margin-right:0.2222222222222222em;" class="mspace"></span><span
    /// class="mbin">×</span><span style="margin-right:0.2222222222222222em;"
    /// class="mspace"></span><span class="mord">0</span><span class="mord">.</span><span
    /// class="mord">5</span><span style="top:0em;" class="mclose delimcenter">⌋</span></span><span
    /// style="margin-right:0.2777777777777778em;" class="mspace"></span><span
    /// class="mrel">=</span><span style="margin-right:0.2777777777777778em;"
    /// class="mspace"></span></span><span class="base"><span
    /// style="height:0.80952em;vertical-align:-0.15em;" class="strut"></span><span
    /// class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span
    /// class="vlist-t vlist-t2"><span class="vlist-r"><span style="height:0.32833099999999993em;"
    /// class="vlist"><span
    /// style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut"
    /// style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord
    /// mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span><span
    /// class="vlist-s">​</span></span><span class="vlist-r"><span style="height:0.15em;"
    /// class="vlist"><span></span></span></span></span></span></span><span class="mspace"
    /// style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span
    /// class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span
    /// class="base"><span style="height:0.80952em;vertical-align:-0.15em;"
    /// class="strut"></span><span class="mord"><span class="mord mathdefault">i</span><span
    /// class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span
    /// style="height:0.32833099999999993em;" class="vlist"><span
    /// style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span
    /// style="height:2.7em;" class="pstrut"></span><span class="sizing reset-size6 size3
    /// mtight"><span style="margin-right:0.00773em;" class="mord mathdefault
    /// mtight">R</span></span></span></span><span class="vlist-s">​</span></span><span
    /// class="vlist-r"><span class="vlist"
    /// style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>
    /// and <span class="katex"><span aria-hidden="true" class="katex-html"><span class="base"><span
    /// style="height:1em;vertical-align:-0.25em;" class="strut"></span><span class="minner"><span
    /// class="mopen delimcenter" style="top:0em;">⌊</span><span class="mord"><span
    /// style="margin-right:0.05724em;" class="mord mathdefault">j</span><span class="msupsub"><span
    /// class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist"
    /// style="height:0.32833099999999993em;"><span
    /// style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span
    /// class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3
    /// mtight"><span class="mord mathdefault mtight">G</span></span></span></span><span
    /// class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist"
    /// style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace"
    /// style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span
    /// class="mspace" style="margin-right:0.2222222222222222em;"></span><span
    /// class="mord">0</span><span class="mord">.</span><span class="mord">5</span><span
    /// style="top:0em;" class="mclose delimcenter">⌋</span></span><span
    /// style="margin-right:0.2777777777777778em;" class="mspace"></span><span
    /// class="mrel">=</span><span class="mspace"
    /// style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span
    /// style="height:0.85396em;vertical-align:-0.19444em;" class="strut"></span><span
    /// class="mord"><span style="margin-right:0.05724em;" class="mord mathdefault">j</span><span
    /// class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span
    /// style="height:0.32833099999999993em;" class="vlist"><span
    /// style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span
    /// class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3
    /// mtight"><span class="mord mathdefault mtight"
    /// style="margin-right:0.05017em;">B</span></span></span></span><span
    /// class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist"
    /// style="height:0.15em;"><span></span></span></span></span></span></span><span
    /// style="margin-right:0.2777777777777778em;" class="mspace"></span><span
    /// class="mrel">=</span><span style="margin-right:0.2777777777777778em;"
    /// class="mspace"></span></span><span class="base"><span
    /// style="height:0.85396em;vertical-align:-0.19444em;" class="strut"></span><span
    /// class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span
    /// class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span
    /// style="height:0.32833099999999993em;" class="vlist"><span
    /// style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span
    /// style="height:2.7em;" class="pstrut"></span><span class="sizing reset-size6 size3
    /// mtight"><span class="mord mathdefault mtight"
    /// style="margin-right:0.00773em;">R</span></span></span></span><span
    /// class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist"
    /// style="height:0.15em;"><span></span></span></span></span></span></span></span></span></
    /// span>. The location of each plane when this image is in linear layout can be
    ///determined via [`GetImageSubresourceLayout`], using
    ///`VK_IMAGE_ASPECT_PLANE_0_BIT` for the G plane, and
    ///`VK_IMAGE_ASPECT_PLANE_1_BIT` for the BR plane.
    ///This format only supports images with a width and height that is a
    ///multiple of two.
    ///
    ///Provided by [`crate::vulkan1_1`]
    G12X4B12X4R12X42Plane420Unorm3Pack16 = 1000156023,
    ///[`G12X4B12X4R12X43Plane422Unorm3Pack16`] specifies an
    ///unsigned normalized *multi-planar format* that has a 12-bit G component
    ///in the top 12 bits of each 16-bit word of plane 0, a 12-bit B component
    ///in the top 12 bits of each 16-bit word of plane 1, and a 12-bit R
    ///component in the top 12 bits of each 16-bit word of plane 2, with the
    ///bottom 4 bits of each word unused.
    ///The horizontal dimension of the R and B plane is halved relative to the
    ///image dimensions, and each R and B value is shared with the G components
    ///for which <span class="katex"><span class="katex-html" aria-hidden="true"><span
    /// class="base"><span style="height:1em;vertical-align:-0.25em;" class="strut"></span><span
    /// class="minner"><span style="top:0em;" class="mopen delimcenter">⌊</span><span
    /// class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span
    /// class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist"
    /// style="height:0.32833099999999993em;"><span
    /// style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut"
    /// style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord
    /// mathdefault mtight">G</span></span></span></span><span class="vlist-s">​</span></span><span
    /// class="vlist-r"><span class="vlist"
    /// style="height:0.15em;"><span></span></span></span></span></span></span><span
    /// style="margin-right:0.2222222222222222em;" class="mspace"></span><span
    /// class="mbin">×</span><span style="margin-right:0.2222222222222222em;"
    /// class="mspace"></span><span class="mord">0</span><span class="mord">.</span><span
    /// class="mord">5</span><span class="mclose delimcenter" style="top:0em;">⌋</span></span><span
    /// class="mspace" style="margin-right:0.2777777777777778em;"></span><span
    /// class="mrel">=</span><span style="margin-right:0.2777777777777778em;"
    /// class="mspace"></span></span><span class="base"><span class="strut"
    /// style="height:0.80952em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord
    /// mathdefault">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span
    /// class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span
    /// style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut"
    /// style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span
    /// style="margin-right:0.05017em;" class="mord mathdefault
    /// mtight">B</span></span></span></span><span class="vlist-s">​</span></span><span
    /// class="vlist-r"><span class="vlist"
    /// style="height:0.15em;"><span></span></span></span></span></span></span><span
    /// style="margin-right:0.2777777777777778em;" class="mspace"></span><span
    /// class="mrel">=</span><span class="mspace"
    /// style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span
    /// class="strut" style="height:0.80952em;vertical-align:-0.15em;"></span><span
    /// class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span
    /// class="vlist-t vlist-t2"><span class="vlist-r"><span style="height:0.32833099999999993em;"
    /// class="vlist"><span
    /// style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut"
    /// style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord
    /// mathdefault mtight" style="margin-right:0.00773em;">R</span></span></span></span><span
    /// class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist"
    /// style="height:0.15em;"><span></span></span></span></span></span></span></span></span></
    /// span>. The location of each plane when this image is in linear layout can be
    ///determined via [`GetImageSubresourceLayout`], using
    ///`VK_IMAGE_ASPECT_PLANE_0_BIT` for the G plane,
    ///`VK_IMAGE_ASPECT_PLANE_1_BIT` for the B plane, and
    ///`VK_IMAGE_ASPECT_PLANE_2_BIT` for the R plane.
    ///This format only supports images with a width that is a multiple of two.
    ///
    ///Provided by [`crate::vulkan1_1`]
    G12X4B12X4R12X43Plane422Unorm3Pack16 = 1000156024,
    ///[`G12X4B12X4R12X42Plane422Unorm3Pack16`] specifies an
    ///unsigned normalized *multi-planar format* that has a 12-bit G component
    ///in the top 12 bits of each 16-bit word of plane 0, and a two-component,
    ///32-bit BR plane 1 consisting of a 12-bit B component in the top 12 bits
    ///of the word in bytes 0..1, and a 12-bit R component in the top 12 bits
    ///of the word in bytes 2..3, with the bottom 4 bits of each word unused.
    ///The horizontal dimension of the BR plane is halved relative to the image
    ///dimensions, and each R and B value is shared with the G components for
    ///which <span class="katex"><span aria-hidden="true" class="katex-html"><span
    /// class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span
    /// class="minner"><span style="top:0em;" class="mopen delimcenter">⌊</span><span
    /// class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span
    /// class="vlist-t vlist-t2"><span class="vlist-r"><span style="height:0.32833099999999993em;"
    /// class="vlist"><span
    /// style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut"
    /// style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord
    /// mathdefault mtight">G</span></span></span></span><span class="vlist-s">​</span></span><span
    /// class="vlist-r"><span style="height:0.15em;"
    /// class="vlist"><span></span></span></span></span></span></span><span
    /// style="margin-right:0.2222222222222222em;" class="mspace"></span><span
    /// class="mbin">×</span><span class="mspace"
    /// style="margin-right:0.2222222222222222em;"></span><span class="mord">0</span><span
    /// class="mord">.</span><span class="mord">5</span><span class="mclose delimcenter"
    /// style="top:0em;">⌋</span></span><span class="mspace"
    /// style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span
    /// style="margin-right:0.2777777777777778em;" class="mspace"></span></span><span
    /// class="base"><span style="height:0.80952em;vertical-align:-0.15em;"
    /// class="strut"></span><span class="mord"><span class="mord mathdefault">i</span><span
    /// class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist"
    /// style="height:0.32833099999999993em;"><span
    /// style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut"
    /// style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord
    /// mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span><span
    /// class="vlist-s">​</span></span><span class="vlist-r"><span style="height:0.15em;"
    /// class="vlist"><span></span></span></span></span></span></span><span class="mspace"
    /// style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span
    /// class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span
    /// class="base"><span style="height:0.80952em;vertical-align:-0.15em;"
    /// class="strut"></span><span class="mord"><span class="mord mathdefault">i</span><span
    /// class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span
    /// style="height:0.32833099999999993em;" class="vlist"><span
    /// style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span
    /// style="height:2.7em;" class="pstrut"></span><span class="sizing reset-size6 size3
    /// mtight"><span class="mord mathdefault mtight"
    /// style="margin-right:0.00773em;">R</span></span></span></span><span
    /// class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist"
    /// style="height:0.15em;"><span></span></span></span></span></span></span></span></span></
    /// span>. The location of each plane when this image is in linear layout can be
    ///determined via [`GetImageSubresourceLayout`], using
    ///`VK_IMAGE_ASPECT_PLANE_0_BIT` for the G plane, and
    ///`VK_IMAGE_ASPECT_PLANE_1_BIT` for the BR plane.
    ///This format only supports images with a width that is a multiple of two.
    ///
    ///Provided by [`crate::vulkan1_1`]
    G12X4B12X4R12X42Plane422Unorm3Pack16 = 1000156025,
    ///[`G12X4B12X4R12X43Plane444Unorm3Pack16`] specifies an
    ///unsigned normalized *multi-planar format* that has a 12-bit G component
    ///in the top 12 bits of each 16-bit word of plane 0, a 12-bit B component
    ///in the top 12 bits of each 16-bit word of plane 1, and a 12-bit R
    ///component in the top 12 bits of each 16-bit word of plane 2, with the
    ///bottom 4 bits of each word unused.
    ///Each plane has the same dimensions and each R, G and B component
    ///contributes to a single texel.
    ///The location of each plane when this image is in linear layout can be
    ///determined via [`GetImageSubresourceLayout`], using
    ///`VK_IMAGE_ASPECT_PLANE_0_BIT` for the G plane,
    ///`VK_IMAGE_ASPECT_PLANE_1_BIT` for the B plane, and
    ///`VK_IMAGE_ASPECT_PLANE_2_BIT` for the R plane.
    ///
    ///Provided by [`crate::vulkan1_1`]
    G12X4B12X4R12X43Plane444Unorm3Pack16 = 1000156026,
    ///[`G16B16G16R16422Unorm`] specifies a four-component,
    ///64-bit format containing a pair of G components, an R component, and a B
    ///component, collectively encoding a 2×1 rectangle of unsigned
    ///normalized RGB texel data.
    ///One G value is present at each *i* coordinate, with the B and R values
    ///shared across both G values and thus recorded at half the horizontal
    ///resolution of the image.
    ///This format has a 16-bit G component for the even *i* coordinate in the
    ///word in bytes 0..1, a 16-bit B component in the word in bytes 2..3, a
    ///16-bit G component for the odd *i* coordinate in the word in bytes 4..5,
    ///and a 16-bit R component in the word in bytes 6..7.
    ///This format only supports images with a width that is a multiple of two.
    ///For the purposes of the constraints on copy extents, this format is
    ///treated as a compressed format with a 2×1 compressed texel block.
    ///
    ///Provided by [`crate::vulkan1_1`]
    G16B16G16R16422Unorm = 1000156027,
    ///[`B16G16R16G16422Unorm`] specifies a four-component,
    ///64-bit format containing a pair of G components, an R component, and a B
    ///component, collectively encoding a 2×1 rectangle of unsigned
    ///normalized RGB texel data.
    ///One G value is present at each *i* coordinate, with the B and R values
    ///shared across both G values and thus recorded at half the horizontal
    ///resolution of the image.
    ///This format has a 16-bit B component in the word in bytes 0..1, a 16-bit
    ///G component for the even *i* coordinate in the word in bytes 2..3, a
    ///16-bit R component in the word in bytes 4..5, and a 16-bit G component
    ///for the odd *i* coordinate in the word in bytes 6..7.
    ///This format only supports images with a width that is a multiple of two.
    ///For the purposes of the constraints on copy extents, this format is
    ///treated as a compressed format with a 2×1 compressed texel block.
    ///
    ///Provided by [`crate::vulkan1_1`]
    B16G16R16G16422Unorm = 1000156028,
    ///[`G16B16R163Plane420Unorm`] specifies an unsigned
    ///normalized *multi-planar format* that has a 16-bit G component in each
    ///16-bit word of plane 0, a 16-bit B component in each 16-bit word of
    ///plane 1, and a 16-bit R component in each 16-bit word of plane 2.
    ///The horizontal and vertical dimensions of the R and B planes are halved
    ///relative to the image dimensions, and each R and B component is shared
    ///with the G components for which <span class="katex"><span aria-hidden="true"
    /// class="katex-html"><span class="base"><span style="height:1em;vertical-align:-0.25em;"
    /// class="strut"></span><span class="minner"><span class="mopen delimcenter"
    /// style="top:0em;">⌊</span><span class="mord"><span class="mord mathdefault">i</span><span
    /// class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span
    /// style="height:0.32833099999999993em;" class="vlist"><span
    /// style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span
    /// style="height:2.7em;" class="pstrut"></span><span class="sizing reset-size6 size3
    /// mtight"><span class="mord mathdefault mtight">G</span></span></span></span><span
    /// class="vlist-s">​</span></span><span class="vlist-r"><span style="height:0.15em;"
    /// class="vlist"><span></span></span></span></span></span></span><span class="mspace"
    /// style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span
    /// style="margin-right:0.2222222222222222em;" class="mspace"></span><span
    /// class="mord">0</span><span class="mord">.</span><span class="mord">5</span><span
    /// class="mclose delimcenter" style="top:0em;">⌋</span></span><span class="mspace"
    /// style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span
    /// style="margin-right:0.2777777777777778em;" class="mspace"></span></span><span
    /// class="base"><span class="strut"
    /// style="height:0.80952em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord
    /// mathdefault">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span
    /// class="vlist-r"><span style="height:0.32833099999999993em;" class="vlist"><span
    /// style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut"
    /// style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span
    /// style="margin-right:0.05017em;" class="mord mathdefault
    /// mtight">B</span></span></span></span><span class="vlist-s">​</span></span><span
    /// class="vlist-r"><span class="vlist"
    /// style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace"
    /// style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span
    /// class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span
    /// class="base"><span class="strut"
    /// style="height:0.80952em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord
    /// mathdefault">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span
    /// class="vlist-r"><span style="height:0.32833099999999993em;" class="vlist"><span
    /// style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut"
    /// style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span
    /// style="margin-right:0.00773em;" class="mord mathdefault
    /// mtight">R</span></span></span></span><span class="vlist-s">​</span></span><span
    /// class="vlist-r"><span class="vlist"
    /// style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>
    /// and <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span
    /// class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span
    /// class="mopen delimcenter" style="top:0em;">⌊</span><span class="mord"><span class="mord
    /// mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span
    /// class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist"
    /// style="height:0.32833099999999993em;"><span
    /// style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span
    /// style="height:2.7em;" class="pstrut"></span><span class="sizing reset-size6 size3
    /// mtight"><span class="mord mathdefault mtight">G</span></span></span></span><span
    /// class="vlist-s">​</span></span><span class="vlist-r"><span style="height:0.15em;"
    /// class="vlist"><span></span></span></span></span></span></span><span class="mspace"
    /// style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span
    /// style="margin-right:0.2222222222222222em;" class="mspace"></span><span
    /// class="mord">0</span><span class="mord">.</span><span class="mord">5</span><span
    /// class="mclose delimcenter" style="top:0em;">⌋</span></span><span class="mspace"
    /// style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span
    /// class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span
    /// class="base"><span class="strut"
    /// style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord"><span
    /// class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span
    /// class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist"
    /// style="height:0.32833099999999993em;"><span
    /// style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span
    /// class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3
    /// mtight"><span class="mord mathdefault mtight"
    /// style="margin-right:0.05017em;">B</span></span></span></span><span
    /// class="vlist-s">​</span></span><span class="vlist-r"><span style="height:0.15em;"
    /// class="vlist"><span></span></span></span></span></span></span><span
    /// style="margin-right:0.2777777777777778em;" class="mspace"></span><span
    /// class="mrel">=</span><span class="mspace"
    /// style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span
    /// class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span
    /// class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span
    /// class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span
    /// style="height:0.32833099999999993em;" class="vlist"><span
    /// style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span
    /// class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3
    /// mtight"><span style="margin-right:0.00773em;" class="mord mathdefault
    /// mtight">R</span></span></span></span><span class="vlist-s">​</span></span><span
    /// class="vlist-r"><span style="height:0.15em;"
    /// class="vlist"><span></span></span></span></span></span></span></span></span></span>. The
    /// location of each plane when this image is in linear layout can be determined via
    /// [`GetImageSubresourceLayout`], using `VK_IMAGE_ASPECT_PLANE_0_BIT` for the G plane,
    ///`VK_IMAGE_ASPECT_PLANE_1_BIT` for the B plane, and
    ///`VK_IMAGE_ASPECT_PLANE_2_BIT` for the R plane.
    ///This format only supports images with a width and height that is a
    ///multiple of two.
    ///
    ///Provided by [`crate::vulkan1_1`]
    G16B16R163Plane420Unorm = 1000156029,
    ///[`G16B16R162Plane420Unorm`] specifies an unsigned
    ///normalized *multi-planar format* that has a 16-bit G component in each
    ///16-bit word of plane 0, and a two-component, 32-bit BR plane 1
    ///consisting of a 16-bit B component in the word in bytes 0..1, and a
    ///16-bit R component in the word in bytes 2..3.
    ///The horizontal and vertical dimensions of the BR plane are halved
    ///relative to the image dimensions, and each R and B value is shared with
    ///the G components for which <span class="katex"><span aria-hidden="true"
    /// class="katex-html"><span class="base"><span class="strut"
    /// style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen
    /// delimcenter" style="top:0em;">⌊</span><span class="mord"><span class="mord
    /// mathdefault">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span
    /// class="vlist-r"><span style="height:0.32833099999999993em;" class="vlist"><span
    /// style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span
    /// style="height:2.7em;" class="pstrut"></span><span class="sizing reset-size6 size3
    /// mtight"><span class="mord mathdefault mtight">G</span></span></span></span><span
    /// class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist"
    /// style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace"
    /// style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span
    /// style="margin-right:0.2222222222222222em;" class="mspace"></span><span
    /// class="mord">0</span><span class="mord">.</span><span class="mord">5</span><span
    /// class="mclose delimcenter" style="top:0em;">⌋</span></span><span
    /// style="margin-right:0.2777777777777778em;" class="mspace"></span><span
    /// class="mrel">=</span><span class="mspace"
    /// style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span
    /// class="strut" style="height:0.80952em;vertical-align:-0.15em;"></span><span
    /// class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span
    /// class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist"
    /// style="height:0.32833099999999993em;"><span
    /// style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span
    /// style="height:2.7em;" class="pstrut"></span><span class="sizing reset-size6 size3
    /// mtight"><span class="mord mathdefault mtight"
    /// style="margin-right:0.05017em;">B</span></span></span></span><span
    /// class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist"
    /// style="height:0.15em;"><span></span></span></span></span></span></span><span
    /// style="margin-right:0.2777777777777778em;" class="mspace"></span><span
    /// class="mrel">=</span><span class="mspace"
    /// style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span
    /// style="height:0.80952em;vertical-align:-0.15em;" class="strut"></span><span
    /// class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span
    /// class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist"
    /// style="height:0.32833099999999993em;"><span
    /// style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span
    /// style="height:2.7em;" class="pstrut"></span><span class="sizing reset-size6 size3
    /// mtight"><span class="mord mathdefault mtight"
    /// style="margin-right:0.00773em;">R</span></span></span></span><span
    /// class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist"
    /// style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>
    /// and <span class="katex"><span aria-hidden="true" class="katex-html"><span class="base"><span
    /// style="height:1em;vertical-align:-0.25em;" class="strut"></span><span class="minner"><span
    /// style="top:0em;" class="mopen delimcenter">⌊</span><span class="mord"><span class="mord
    /// mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span
    /// class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist"
    /// style="height:0.32833099999999993em;"><span
    /// style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span
    /// class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3
    /// mtight"><span class="mord mathdefault mtight">G</span></span></span></span><span
    /// class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist"
    /// style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace"
    /// style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span
    /// class="mspace" style="margin-right:0.2222222222222222em;"></span><span
    /// class="mord">0</span><span class="mord">.</span><span class="mord">5</span><span
    /// style="top:0em;" class="mclose delimcenter">⌋</span></span><span class="mspace"
    /// style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span
    /// class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span
    /// class="base"><span style="height:0.85396em;vertical-align:-0.19444em;"
    /// class="strut"></span><span class="mord"><span class="mord mathdefault"
    /// style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t
    /// vlist-t2"><span class="vlist-r"><span style="height:0.32833099999999993em;"
    /// class="vlist"><span
    /// style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span
    /// style="height:2.7em;" class="pstrut"></span><span class="sizing reset-size6 size3
    /// mtight"><span style="margin-right:0.05017em;" class="mord mathdefault
    /// mtight">B</span></span></span></span><span class="vlist-s">​</span></span><span
    /// class="vlist-r"><span class="vlist"
    /// style="height:0.15em;"><span></span></span></span></span></span></span><span
    /// style="margin-right:0.2777777777777778em;" class="mspace"></span><span
    /// class="mrel">=</span><span class="mspace"
    /// style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span
    /// style="height:0.85396em;vertical-align:-0.19444em;" class="strut"></span><span
    /// class="mord"><span style="margin-right:0.05724em;" class="mord mathdefault">j</span><span
    /// class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span
    /// style="height:0.32833099999999993em;" class="vlist"><span
    /// style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span
    /// style="height:2.7em;" class="pstrut"></span><span class="sizing reset-size6 size3
    /// mtight"><span class="mord mathdefault mtight"
    /// style="margin-right:0.00773em;">R</span></span></span></span><span
    /// class="vlist-s">​</span></span><span class="vlist-r"><span style="height:0.15em;"
    /// class="vlist"><span></span></span></span></span></span></span></span></span></span>. The
    /// location of each plane when this image is in linear layout can be determined via
    /// [`GetImageSubresourceLayout`], using `VK_IMAGE_ASPECT_PLANE_0_BIT` for the G plane, and
    ///`VK_IMAGE_ASPECT_PLANE_1_BIT` for the BR plane.
    ///This format only supports images with a width and height that is a
    ///multiple of two.
    ///
    ///Provided by [`crate::vulkan1_1`]
    G16B16R162Plane420Unorm = 1000156030,
    ///[`G16B16R163Plane422Unorm`] specifies an unsigned
    ///normalized *multi-planar format* that has a 16-bit G component in each
    ///16-bit word of plane 0, a 16-bit B component in each 16-bit word of
    ///plane 1, and a 16-bit R component in each 16-bit word of plane 2.
    ///The horizontal dimension of the R and B plane is halved relative to the
    ///image dimensions, and each R and B value is shared with the G components
    ///for which <span class="katex"><span class="katex-html" aria-hidden="true"><span
    /// class="base"><span style="height:1em;vertical-align:-0.25em;" class="strut"></span><span
    /// class="minner"><span class="mopen delimcenter" style="top:0em;">⌊</span><span
    /// class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span
    /// class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist"
    /// style="height:0.32833099999999993em;"><span
    /// style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut"
    /// style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord
    /// mathdefault mtight">G</span></span></span></span><span class="vlist-s">​</span></span><span
    /// class="vlist-r"><span class="vlist"
    /// style="height:0.15em;"><span></span></span></span></span></span></span><span
    /// style="margin-right:0.2222222222222222em;" class="mspace"></span><span
    /// class="mbin">×</span><span class="mspace"
    /// style="margin-right:0.2222222222222222em;"></span><span class="mord">0</span><span
    /// class="mord">.</span><span class="mord">5</span><span style="top:0em;" class="mclose
    /// delimcenter">⌋</span></span><span style="margin-right:0.2777777777777778em;"
    /// class="mspace"></span><span class="mrel">=</span><span class="mspace"
    /// style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span
    /// class="strut" style="height:0.80952em;vertical-align:-0.15em;"></span><span
    /// class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span
    /// class="vlist-t vlist-t2"><span class="vlist-r"><span style="height:0.32833099999999993em;"
    /// class="vlist"><span
    /// style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut"
    /// style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord
    /// mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span><span
    /// class="vlist-s">​</span></span><span class="vlist-r"><span style="height:0.15em;"
    /// class="vlist"><span></span></span></span></span></span></span><span class="mspace"
    /// style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span
    /// class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span
    /// class="base"><span class="strut"
    /// style="height:0.80952em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord
    /// mathdefault">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span
    /// class="vlist-r"><span style="height:0.32833099999999993em;" class="vlist"><span
    /// style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut"
    /// style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span
    /// style="margin-right:0.00773em;" class="mord mathdefault
    /// mtight">R</span></span></span></span><span class="vlist-s">​</span></span><span
    /// class="vlist-r"><span style="height:0.15em;"
    /// class="vlist"><span></span></span></span></span></span></span></span></span></span>. The
    /// location of each plane when this image is in linear layout can be determined via
    /// [`GetImageSubresourceLayout`], using `VK_IMAGE_ASPECT_PLANE_0_BIT` for the G plane,
    ///`VK_IMAGE_ASPECT_PLANE_1_BIT` for the B plane, and
    ///`VK_IMAGE_ASPECT_PLANE_2_BIT` for the R plane.
    ///This format only supports images with a width that is a multiple of two.
    ///
    ///Provided by [`crate::vulkan1_1`]
    G16B16R163Plane422Unorm = 1000156031,
    ///[`G16B16R162Plane422Unorm`] specifies an unsigned
    ///normalized *multi-planar format* that has a 16-bit G component in each
    ///16-bit word of plane 0, and a two-component, 32-bit BR plane 1
    ///consisting of a 16-bit B component in the word in bytes 0..1, and a
    ///16-bit R component in the word in bytes 2..3.
    ///The horizontal dimension of the BR plane is halved relative to the image
    ///dimensions, and each R and B value is shared with the G components for
    ///which <span class="katex"><span class="katex-html" aria-hidden="true"><span
    /// class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span
    /// class="minner"><span style="top:0em;" class="mopen delimcenter">⌊</span><span
    /// class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span
    /// class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist"
    /// style="height:0.32833099999999993em;"><span
    /// style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut"
    /// style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord
    /// mathdefault mtight">G</span></span></span></span><span class="vlist-s">​</span></span><span
    /// class="vlist-r"><span style="height:0.15em;"
    /// class="vlist"><span></span></span></span></span></span></span><span class="mspace"
    /// style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span
    /// class="mspace" style="margin-right:0.2222222222222222em;"></span><span
    /// class="mord">0</span><span class="mord">.</span><span class="mord">5</span><span
    /// class="mclose delimcenter" style="top:0em;">⌋</span></span><span class="mspace"
    /// style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span
    /// class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span
    /// class="base"><span class="strut"
    /// style="height:0.80952em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord
    /// mathdefault">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span
    /// class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span
    /// style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut"
    /// style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span
    /// style="margin-right:0.05017em;" class="mord mathdefault
    /// mtight">B</span></span></span></span><span class="vlist-s">​</span></span><span
    /// class="vlist-r"><span class="vlist"
    /// style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace"
    /// style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span
    /// style="margin-right:0.2777777777777778em;" class="mspace"></span></span><span
    /// class="base"><span style="height:0.80952em;vertical-align:-0.15em;"
    /// class="strut"></span><span class="mord"><span class="mord mathdefault">i</span><span
    /// class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span
    /// style="height:0.32833099999999993em;" class="vlist"><span
    /// style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span
    /// style="height:2.7em;" class="pstrut"></span><span class="sizing reset-size6 size3
    /// mtight"><span class="mord mathdefault mtight"
    /// style="margin-right:0.00773em;">R</span></span></span></span><span
    /// class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist"
    /// style="height:0.15em;"><span></span></span></span></span></span></span></span></span></
    /// span>. The location of each plane when this image is in linear layout can be
    ///determined via [`GetImageSubresourceLayout`], using
    ///`VK_IMAGE_ASPECT_PLANE_0_BIT` for the G plane, and
    ///`VK_IMAGE_ASPECT_PLANE_1_BIT` for the BR plane.
    ///This format only supports images with a width that is a multiple of two.
    ///
    ///Provided by [`crate::vulkan1_1`]
    G16B16R162Plane422Unorm = 1000156032,
    ///[`G16B16R163Plane444Unorm`] specifies an unsigned
    ///normalized *multi-planar format* that has a 16-bit G component in each
    ///16-bit word of plane 0, a 16-bit B component in each 16-bit word of
    ///plane 1, and a 16-bit R component in each 16-bit word of plane 2.
    ///Each plane has the same dimensions and each R, G and B component
    ///contributes to a single texel.
    ///The location of each plane when this image is in linear layout can be
    ///determined via [`GetImageSubresourceLayout`], using
    ///`VK_IMAGE_ASPECT_PLANE_0_BIT` for the G plane,
    ///`VK_IMAGE_ASPECT_PLANE_1_BIT` for the B plane, and
    ///`VK_IMAGE_ASPECT_PLANE_2_BIT` for the R plane.
    ///
    ///Provided by [`crate::vulkan1_1`]
    G16B16R163Plane444Unorm = 1000156033,
    ///[`G8B8R82Plane444Unorm`] specifies an unsigned
    ///normalized *multi-planar format* that has an 8-bit G component in plane
    ///0, and a two-component, 16-bit BR plane 1 consisting of an 8-bit B
    ///component in byte 0 and an 8-bit R component in byte 1.
    ///Both planes have the same dimensions and each R, G and B component
    ///contributes to a single texel.
    ///The location of each plane when this image is in linear layout can be
    ///determined via [`GetImageSubresourceLayout`], using
    ///`VK_IMAGE_ASPECT_PLANE_0_BIT` for the G plane, and
    ///`VK_IMAGE_ASPECT_PLANE_1_BIT` for the BR plane.
    ///
    ///Provided by [`crate::vulkan1_3`]
    G8B8R82Plane444Unorm = 1000330000,
    ///[`G10X6B10X6R10X62Plane444Unorm3Pack16`] specifies an
    ///unsigned normalized *multi-planar format* that has a 10-bit G component
    ///in the top 10 bits of each 16-bit word of plane 0, and a two-component,
    ///32-bit BR plane 1 consisting of a 10-bit B component in the top 10 bits
    ///of the word in bytes 0..1, and a 10-bit R component in the top 10 bits
    ///of the word in bytes 2..3, the bottom 6 bits of each word unused.
    ///Both planes have the same dimensions and each R, G and B component
    ///contributes to a single texel.
    ///The location of each plane when this image is in linear layout can be
    ///determined via [`GetImageSubresourceLayout`], using
    ///`VK_IMAGE_ASPECT_PLANE_0_BIT` for the G plane, and
    ///`VK_IMAGE_ASPECT_PLANE_1_BIT` for the BR plane.
    ///
    ///Provided by [`crate::vulkan1_3`]
    G10X6B10X6R10X62Plane444Unorm3Pack16 = 1000330001,
    ///[`G12X4B12X4R12X42Plane444Unorm3Pack16`] specifies an
    ///unsigned normalized *multi-planar format* that has a 12-bit G component
    ///in the top 12 bits of each 16-bit word of plane 0, and a two-component,
    ///32-bit BR plane 1 consisting of a 12-bit B component in the top 12 bits
    ///of the word in bytes 0..1, and a 12-bit R component in the top 12 bits
    ///of the word in bytes 2..3, the bottom 4 bits of each word unused.
    ///Both planes have the same dimensions and each R, G and B component
    ///contributes to a single texel.
    ///The location of each plane when this image is in linear layout can be
    ///determined via [`GetImageSubresourceLayout`], using
    ///`VK_IMAGE_ASPECT_PLANE_0_BIT` for the G plane, and
    ///`VK_IMAGE_ASPECT_PLANE_1_BIT` for the BR plane.
    ///
    ///Provided by [`crate::vulkan1_3`]
    G12X4B12X4R12X42Plane444Unorm3Pack16 = 1000330002,
    ///[`G16B16R162Plane444Unorm`] specifies an unsigned
    ///normalized *multi-planar format* that has a 16-bit G component in each
    ///16-bit word of plane 0, and a two-component, 32-bit BR plane 1
    ///consisting of a 16-bit B component in the word in bytes 0..1, and a
    ///16-bit R component in the word in bytes 2..3.
    ///Both planes have the same dimensions and each R, G and B component
    ///contributes to a single texel.
    ///The location of each plane when this image is in linear layout can be
    ///determined via [`GetImageSubresourceLayout`], using
    ///`VK_IMAGE_ASPECT_PLANE_0_BIT` for the G plane, and
    ///`VK_IMAGE_ASPECT_PLANE_1_BIT` for the BR plane.
    ///
    ///Provided by [`crate::vulkan1_3`]
    G16B16R162Plane444Unorm = 1000330003,
    ///[`A4R4G4B4UnormPack16`] specifies a four-component, 16-bit
    ///packed unsigned normalized format that has a 4-bit A component in bits
    ///12..15, a 4-bit R component in bits 8..11, a 4-bit G component in bits
    ///4..7, and a 4-bit B component in bits 0..3.
    ///
    ///Provided by [`crate::vulkan1_3`]
    A4R4G4B4UnormPack16 = 1000340000,
    ///[`A4B4G4R4UnormPack16`] specifies a four-component, 16-bit
    ///packed unsigned normalized format that has a 4-bit A component in bits
    ///12..15, a 4-bit B component in bits 8..11, a 4-bit G component in bits
    ///4..7, and a 4-bit R component in bits 0..3.
    ///
    ///Provided by [`crate::vulkan1_3`]
    A4B4G4R4UnormPack16 = 1000340001,
    ///[`Astc4X4SfloatBlock`] specifies a four-component, ASTC
    ///compressed format where each 128-bit compressed texel block encodes a
    ///4×4 rectangle of signed floating-point RGBA texel data.
    ///
    ///Provided by [`crate::vulkan1_3`]
    Astc4X4SfloatBlock = 1000066000,
    ///[`Astc5X4SfloatBlock`] specifies a four-component, ASTC
    ///compressed format where each 128-bit compressed texel block encodes a
    ///5×4 rectangle of signed floating-point RGBA texel data.
    ///
    ///Provided by [`crate::vulkan1_3`]
    Astc5X4SfloatBlock = 1000066001,
    ///[`Astc5X5SfloatBlock`] specifies a four-component, ASTC
    ///compressed format where each 128-bit compressed texel block encodes a
    ///5×5 rectangle of signed floating-point RGBA texel data.
    ///
    ///Provided by [`crate::vulkan1_3`]
    Astc5X5SfloatBlock = 1000066002,
    ///[`Astc6X5SfloatBlock`] specifies a four-component, ASTC
    ///compressed format where each 128-bit compressed texel block encodes a
    ///6×5 rectangle of signed floating-point RGBA texel data.
    ///
    ///Provided by [`crate::vulkan1_3`]
    Astc6X5SfloatBlock = 1000066003,
    ///[`Astc6X6SfloatBlock`] specifies a four-component, ASTC
    ///compressed format where each 128-bit compressed texel block encodes a
    ///6×6 rectangle of signed floating-point RGBA texel data.
    ///
    ///Provided by [`crate::vulkan1_3`]
    Astc6X6SfloatBlock = 1000066004,
    ///[`Astc8X5SfloatBlock`] specifies a four-component, ASTC
    ///compressed format where each 128-bit compressed texel block encodes a
    ///8×5 rectangle of signed floating-point RGBA texel data.
    ///
    ///Provided by [`crate::vulkan1_3`]
    Astc8X5SfloatBlock = 1000066005,
    ///[`Astc8X6SfloatBlock`] specifies a four-component, ASTC
    ///compressed format where each 128-bit compressed texel block encodes a
    ///8×6 rectangle of signed floating-point RGBA texel data.
    ///
    ///Provided by [`crate::vulkan1_3`]
    Astc8X6SfloatBlock = 1000066006,
    ///[`Astc8X8SfloatBlock`] specifies a four-component, ASTC
    ///compressed format where each 128-bit compressed texel block encodes a
    ///8×8 rectangle of signed floating-point RGBA texel data.
    ///
    ///Provided by [`crate::vulkan1_3`]
    Astc8X8SfloatBlock = 1000066007,
    ///[`Astc10X5SfloatBlock`] specifies a four-component, ASTC
    ///compressed format where each 128-bit compressed texel block encodes a
    ///10×5 rectangle of signed floating-point RGBA texel data.
    ///
    ///Provided by [`crate::vulkan1_3`]
    Astc10X5SfloatBlock = 1000066008,
    ///[`Astc10X6SfloatBlock`] specifies a four-component, ASTC
    ///compressed format where each 128-bit compressed texel block encodes a
    ///10×6 rectangle of signed floating-point RGBA texel data.
    ///
    ///Provided by [`crate::vulkan1_3`]
    Astc10X6SfloatBlock = 1000066009,
    ///[`Astc10X8SfloatBlock`] specifies a four-component, ASTC
    ///compressed format where each 128-bit compressed texel block encodes a
    ///10×8 rectangle of signed floating-point RGBA texel data.
    ///
    ///Provided by [`crate::vulkan1_3`]
    Astc10X8SfloatBlock = 1000066010,
    ///[`Astc10X10SfloatBlock`] specifies a four-component, ASTC
    ///compressed format where each 128-bit compressed texel block encodes a
    ///10×10 rectangle of signed floating-point RGBA texel data.
    ///
    ///Provided by [`crate::vulkan1_3`]
    Astc10X10SfloatBlock = 1000066011,
    ///[`Astc12X10SfloatBlock`] specifies a four-component, ASTC
    ///compressed format where each 128-bit compressed texel block encodes a
    ///12×10 rectangle of signed floating-point RGBA texel data.
    ///
    ///Provided by [`crate::vulkan1_3`]
    Astc12X10SfloatBlock = 1000066012,
    ///[`Astc12X12SfloatBlock`] specifies a four-component, ASTC
    ///compressed format where each 128-bit compressed texel block encodes a
    ///12×12 rectangle of signed floating-point RGBA texel data.
    ///
    ///Provided by [`crate::vulkan1_3`]
    Astc12X12SfloatBlock = 1000066013,
    ///[`Pvrtc12BppUnormBlockImg`] specifies a four-component,
    ///PVRTC compressed format where each 64-bit compressed texel block encodes
    ///an 8×4 rectangle of unsigned normalized RGBA texel data.
    ///
    ///Provided by [`crate::extensions::img_format_pvrtc`]
    Pvrtc12BppUnormBlockImg = 1000054000,
    ///[`Pvrtc14BppUnormBlockImg`] specifies a four-component,
    ///PVRTC compressed format where each 64-bit compressed texel block encodes
    ///a 4×4 rectangle of unsigned normalized RGBA texel data.
    ///
    ///Provided by [`crate::extensions::img_format_pvrtc`]
    Pvrtc14BppUnormBlockImg = 1000054001,
    ///[`Pvrtc22BppUnormBlockImg`] specifies a four-component,
    ///PVRTC compressed format where each 64-bit compressed texel block encodes
    ///an 8×4 rectangle of unsigned normalized RGBA texel data.
    ///
    ///Provided by [`crate::extensions::img_format_pvrtc`]
    Pvrtc22BppUnormBlockImg = 1000054002,
    ///[`Pvrtc24BppUnormBlockImg`] specifies a four-component,
    ///PVRTC compressed format where each 64-bit compressed texel block encodes
    ///a 4×4 rectangle of unsigned normalized RGBA texel data.
    ///
    ///Provided by [`crate::extensions::img_format_pvrtc`]
    Pvrtc24BppUnormBlockImg = 1000054003,
    ///[`Pvrtc12BppSrgbBlockImg`] specifies a four-component,
    ///PVRTC compressed format where each 64-bit compressed texel block encodes
    ///an 8×4 rectangle of unsigned normalized RGBA texel data with sRGB
    ///nonlinear encoding applied to the RGB components.
    ///
    ///Provided by [`crate::extensions::img_format_pvrtc`]
    Pvrtc12BppSrgbBlockImg = 1000054004,
    ///[`Pvrtc14BppSrgbBlockImg`] specifies a four-component,
    ///PVRTC compressed format where each 64-bit compressed texel block encodes
    ///a 4×4 rectangle of unsigned normalized RGBA texel data with sRGB
    ///nonlinear encoding applied to the RGB components.
    ///
    ///Provided by [`crate::extensions::img_format_pvrtc`]
    Pvrtc14BppSrgbBlockImg = 1000054005,
    ///[`Pvrtc22BppSrgbBlockImg`] specifies a four-component,
    ///PVRTC compressed format where each 64-bit compressed texel block encodes
    ///an 8×4 rectangle of unsigned normalized RGBA texel data with sRGB
    ///nonlinear encoding applied to the RGB components.
    ///
    ///Provided by [`crate::extensions::img_format_pvrtc`]
    Pvrtc22BppSrgbBlockImg = 1000054006,
    ///[`Pvrtc24BppSrgbBlockImg`] specifies a four-component,
    ///PVRTC compressed format where each 64-bit compressed texel block encodes
    ///a 4×4 rectangle of unsigned normalized RGBA texel data with sRGB
    ///nonlinear encoding applied to the RGB components.
    ///
    ///Provided by [`crate::extensions::img_format_pvrtc`]
    Pvrtc24BppSrgbBlockImg = 1000054007,
}
impl const Default for Format {
    fn default() -> Self {
        Self::Undefined
    }
}
impl Format {
    ///Default empty value
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Gets the raw underlying value
    #[inline]
    pub const fn bits(&self) -> i32 {
        self as i32
    }
    ///Gets a value from a raw underlying value, unchecked and therefore unsafe
    #[inline]
    pub const unsafe fn from_bits(bits: i32) -> i32 {
        std::mem::transmute(bits)
    }
}
///[VkStructureType](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkStructureType.html) - Vulkan structure types (pname:sType)
///# C Specifications
///Each value corresponds to a particular structure with a `sType` member
///with a matching name.
///As a general rule, the name of each [`StructureType`] value is obtained
///by taking the name of the structure, stripping the leading `Vk`,
///prefixing each capital letter with `_`, converting the entire resulting
///string to upper case, and prefixing it with `VK_STRUCTURE_TYPE_`.
///For example, structures of type [`ImageCreateInfo`] correspond to a
///[`StructureType`] of [`ImageCreateInfo`], and thus
///its `sType` member  **must**  equal that when it is passed to the API.The values
/// [`LoaderInstanceCreateInfo`] and
///[`LoaderDeviceCreateInfo`] are reserved for internal
///use by the loader, and do not have corresponding Vulkan structures in this
///Specification.Structure types supported by the Vulkan API include:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkStructureType {
///    VK_STRUCTURE_TYPE_APPLICATION_INFO = 0,
///    VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO = 1,
///    VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO = 2,
///    VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO = 3,
///    VK_STRUCTURE_TYPE_SUBMIT_INFO = 4,
///    VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO = 5,
///    VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE = 6,
///    VK_STRUCTURE_TYPE_BIND_SPARSE_INFO = 7,
///    VK_STRUCTURE_TYPE_FENCE_CREATE_INFO = 8,
///    VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO = 9,
///    VK_STRUCTURE_TYPE_EVENT_CREATE_INFO = 10,
///    VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO = 11,
///    VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO = 12,
///    VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO = 13,
///    VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO = 14,
///    VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO = 15,
///    VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO = 16,
///    VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO = 17,
///    VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO = 18,
///    VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO = 19,
///    VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO = 20,
///    VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO = 21,
///    VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO = 22,
///    VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO = 23,
///    VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO = 24,
///    VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO = 25,
///    VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO = 26,
///    VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO = 27,
///    VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO = 28,
///    VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO = 29,
///    VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO = 30,
///    VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO = 31,
///    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO = 32,
///    VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO = 33,
///    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO = 34,
///    VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET = 35,
///    VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET = 36,
///    VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO = 37,
///    VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO = 38,
///    VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO = 39,
///    VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO = 40,
///    VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO = 41,
///    VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO = 42,
///    VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO = 43,
///    VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER = 44,
///    VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER = 45,
///    VK_STRUCTURE_TYPE_MEMORY_BARRIER = 46,
///    VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO = 47,
///    VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO = 48,
///  // Provided by VK_VERSION_1_1
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES = 1000094000,
///  // Provided by VK_VERSION_1_1
///    VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO = 1000157000,
///  // Provided by VK_VERSION_1_1
///    VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO = 1000157001,
///  // Provided by VK_VERSION_1_1
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES = 1000083000,
///  // Provided by VK_VERSION_1_1
///    VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS = 1000127000,
///  // Provided by VK_VERSION_1_1
///    VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO = 1000127001,
///  // Provided by VK_VERSION_1_1
///    VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO = 1000060000,
///  // Provided by VK_VERSION_1_1
///    VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO = 1000060003,
///  // Provided by VK_VERSION_1_1
///    VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO = 1000060004,
///  // Provided by VK_VERSION_1_1
///    VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO = 1000060005,
///  // Provided by VK_VERSION_1_1
///    VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO = 1000060006,
///  // Provided by VK_VERSION_1_1
///    VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO = 1000060013,
///  // Provided by VK_VERSION_1_1
///    VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO = 1000060014,
///  // Provided by VK_VERSION_1_1
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES = 1000070000,
///  // Provided by VK_VERSION_1_1
///    VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO = 1000070001,
///  // Provided by VK_VERSION_1_1
///    VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2 = 1000146000,
///  // Provided by VK_VERSION_1_1
///    VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2 = 1000146001,
///  // Provided by VK_VERSION_1_1
///    VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2 = 1000146002,
///  // Provided by VK_VERSION_1_1
///    VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2 = 1000146003,
///  // Provided by VK_VERSION_1_1
///    VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2 = 1000146004,
///  // Provided by VK_VERSION_1_1
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2 = 1000059000,
///  // Provided by VK_VERSION_1_1
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2 = 1000059001,
///  // Provided by VK_VERSION_1_1
///    VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2 = 1000059002,
///  // Provided by VK_VERSION_1_1
///    VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2 = 1000059003,
///  // Provided by VK_VERSION_1_1
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2 = 1000059004,
///  // Provided by VK_VERSION_1_1
///    VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2 = 1000059005,
///  // Provided by VK_VERSION_1_1
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2 = 1000059006,
///  // Provided by VK_VERSION_1_1
///    VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2 = 1000059007,
///  // Provided by VK_VERSION_1_1
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2 = 1000059008,
///  // Provided by VK_VERSION_1_1
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES = 1000117000,
///  // Provided by VK_VERSION_1_1
///    VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO = 1000117001,
///  // Provided by VK_VERSION_1_1
///    VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO = 1000117002,
///  // Provided by VK_VERSION_1_1
///    VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO = 1000117003,
///  // Provided by VK_VERSION_1_1
///    VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO = 1000053000,
///  // Provided by VK_VERSION_1_1
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES = 1000053001,
///  // Provided by VK_VERSION_1_1
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES = 1000053002,
///  // Provided by VK_VERSION_1_1
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES = 1000120000,
///  // Provided by VK_VERSION_1_1
///    VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO = 1000145000,
///  // Provided by VK_VERSION_1_1
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES = 1000145001,
///  // Provided by VK_VERSION_1_1
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES = 1000145002,
///  // Provided by VK_VERSION_1_1
///    VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2 = 1000145003,
///  // Provided by VK_VERSION_1_1
///    VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO = 1000156000,
///  // Provided by VK_VERSION_1_1
///    VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO = 1000156001,
///  // Provided by VK_VERSION_1_1
///    VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO = 1000156002,
///  // Provided by VK_VERSION_1_1
///    VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO = 1000156003,
///  // Provided by VK_VERSION_1_1
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES = 1000156004,
///  // Provided by VK_VERSION_1_1
///    VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES = 1000156005,
///  // Provided by VK_VERSION_1_1
///    VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO = 1000085000,
///  // Provided by VK_VERSION_1_1
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO = 1000071000,
///  // Provided by VK_VERSION_1_1
///    VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES = 1000071001,
///  // Provided by VK_VERSION_1_1
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO = 1000071002,
///  // Provided by VK_VERSION_1_1
///    VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES = 1000071003,
///  // Provided by VK_VERSION_1_1
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES = 1000071004,
///  // Provided by VK_VERSION_1_1
///    VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO = 1000072000,
///  // Provided by VK_VERSION_1_1
///    VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO = 1000072001,
///  // Provided by VK_VERSION_1_1
///    VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO = 1000072002,
///  // Provided by VK_VERSION_1_1
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO = 1000112000,
///  // Provided by VK_VERSION_1_1
///    VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES = 1000112001,
///  // Provided by VK_VERSION_1_1
///    VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO = 1000113000,
///  // Provided by VK_VERSION_1_1
///    VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO = 1000077000,
///  // Provided by VK_VERSION_1_1
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO = 1000076000,
///  // Provided by VK_VERSION_1_1
///    VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES = 1000076001,
///  // Provided by VK_VERSION_1_1
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES = 1000168000,
///  // Provided by VK_VERSION_1_1
///    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT = 1000168001,
///  // Provided by VK_VERSION_1_1
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES = 1000063000,
///  // Provided by VK_VERSION_1_2
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES = 49,
///  // Provided by VK_VERSION_1_2
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES = 50,
///  // Provided by VK_VERSION_1_2
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES = 51,
///  // Provided by VK_VERSION_1_2
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES = 52,
///  // Provided by VK_VERSION_1_2
///    VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO = 1000147000,
///  // Provided by VK_VERSION_1_2
///    VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2 = 1000109000,
///  // Provided by VK_VERSION_1_2
///    VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2 = 1000109001,
///  // Provided by VK_VERSION_1_2
///    VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2 = 1000109002,
///  // Provided by VK_VERSION_1_2
///    VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2 = 1000109003,
///  // Provided by VK_VERSION_1_2
///    VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2 = 1000109004,
///  // Provided by VK_VERSION_1_2
///    VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO = 1000109005,
///  // Provided by VK_VERSION_1_2
///    VK_STRUCTURE_TYPE_SUBPASS_END_INFO = 1000109006,
///  // Provided by VK_VERSION_1_2
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES = 1000177000,
///  // Provided by VK_VERSION_1_2
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES = 1000196000,
///  // Provided by VK_VERSION_1_2
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES = 1000180000,
///  // Provided by VK_VERSION_1_2
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES = 1000082000,
///  // Provided by VK_VERSION_1_2
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES = 1000197000,
///  // Provided by VK_VERSION_1_2
///    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO = 1000161000,
///  // Provided by VK_VERSION_1_2
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES = 1000161001,
///  // Provided by VK_VERSION_1_2
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES = 1000161002,
///  // Provided by VK_VERSION_1_2
///    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO = 1000161003,
///  // Provided by VK_VERSION_1_2
///    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT = 1000161004,
///  // Provided by VK_VERSION_1_2
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES = 1000199000,
///  // Provided by VK_VERSION_1_2
///    VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE = 1000199001,
///  // Provided by VK_VERSION_1_2
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES = 1000221000,
///  // Provided by VK_VERSION_1_2
///    VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO = 1000246000,
///  // Provided by VK_VERSION_1_2
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES = 1000130000,
///  // Provided by VK_VERSION_1_2
///    VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO = 1000130001,
///  // Provided by VK_VERSION_1_2
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES = 1000211000,
///  // Provided by VK_VERSION_1_2
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES = 1000108000,
///  // Provided by VK_VERSION_1_2
///    VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO = 1000108001,
///  // Provided by VK_VERSION_1_2
///    VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO = 1000108002,
///  // Provided by VK_VERSION_1_2
///    VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO = 1000108003,
///  // Provided by VK_VERSION_1_2
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES = 1000253000,
///  // Provided by VK_VERSION_1_2
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES = 1000175000,
///  // Provided by VK_VERSION_1_2
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES = 1000241000,
///  // Provided by VK_VERSION_1_2
///    VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT = 1000241001,
///  // Provided by VK_VERSION_1_2
///    VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT = 1000241002,
///  // Provided by VK_VERSION_1_2
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES = 1000261000,
///  // Provided by VK_VERSION_1_2
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES = 1000207000,
///  // Provided by VK_VERSION_1_2
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES = 1000207001,
///  // Provided by VK_VERSION_1_2
///    VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO = 1000207002,
///  // Provided by VK_VERSION_1_2
///    VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO = 1000207003,
///  // Provided by VK_VERSION_1_2
///    VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO = 1000207004,
///  // Provided by VK_VERSION_1_2
///    VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO = 1000207005,
///  // Provided by VK_VERSION_1_2
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES = 1000257000,
///  // Provided by VK_VERSION_1_2
///    VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO = 1000244001,
///  // Provided by VK_VERSION_1_2
///    VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO = 1000257002,
///  // Provided by VK_VERSION_1_2
///    VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO = 1000257003,
///  // Provided by VK_VERSION_1_2
///    VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO = 1000257004,
///  // Provided by VK_VERSION_1_3
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES = 53,
///  // Provided by VK_VERSION_1_3
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES = 54,
///  // Provided by VK_VERSION_1_3
///    VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO = 1000192000,
///  // Provided by VK_VERSION_1_3
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES = 1000215000,
///  // Provided by VK_VERSION_1_3
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES = 1000245000,
///  // Provided by VK_VERSION_1_3
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES = 1000276000,
///  // Provided by VK_VERSION_1_3
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES = 1000295000,
///  // Provided by VK_VERSION_1_3
///    VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO = 1000295001,
///  // Provided by VK_VERSION_1_3
///    VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO = 1000295002,
///  // Provided by VK_VERSION_1_3
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES = 1000297000,
///  // Provided by VK_VERSION_1_3
///    VK_STRUCTURE_TYPE_MEMORY_BARRIER_2 = 1000314000,
///  // Provided by VK_VERSION_1_3
///    VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2 = 1000314001,
///  // Provided by VK_VERSION_1_3
///    VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2 = 1000314002,
///  // Provided by VK_VERSION_1_3
///    VK_STRUCTURE_TYPE_DEPENDENCY_INFO = 1000314003,
///  // Provided by VK_VERSION_1_3
///    VK_STRUCTURE_TYPE_SUBMIT_INFO_2 = 1000314004,
///  // Provided by VK_VERSION_1_3
///    VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO = 1000314005,
///  // Provided by VK_VERSION_1_3
///    VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO = 1000314006,
///  // Provided by VK_VERSION_1_3
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES = 1000314007,
///  // Provided by VK_VERSION_1_3
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES = 1000325000,
///  // Provided by VK_VERSION_1_3
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES = 1000335000,
///  // Provided by VK_VERSION_1_3
///    VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2 = 1000337000,
///  // Provided by VK_VERSION_1_3
///    VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2 = 1000337001,
///  // Provided by VK_VERSION_1_3
///    VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2 = 1000337002,
///  // Provided by VK_VERSION_1_3
///    VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2 = 1000337003,
///  // Provided by VK_VERSION_1_3
///    VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2 = 1000337004,
///  // Provided by VK_VERSION_1_3
///    VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2 = 1000337005,
///  // Provided by VK_VERSION_1_3
///    VK_STRUCTURE_TYPE_BUFFER_COPY_2 = 1000337006,
///  // Provided by VK_VERSION_1_3
///    VK_STRUCTURE_TYPE_IMAGE_COPY_2 = 1000337007,
///  // Provided by VK_VERSION_1_3
///    VK_STRUCTURE_TYPE_IMAGE_BLIT_2 = 1000337008,
///  // Provided by VK_VERSION_1_3
///    VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2 = 1000337009,
///  // Provided by VK_VERSION_1_3
///    VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2 = 1000337010,
///  // Provided by VK_VERSION_1_3
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES = 1000225000,
///  // Provided by VK_VERSION_1_3
///    VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO = 1000225001,
///  // Provided by VK_VERSION_1_3
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES = 1000225002,
///  // Provided by VK_VERSION_1_3
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES = 1000138000,
///  // Provided by VK_VERSION_1_3
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES = 1000138001,
///  // Provided by VK_VERSION_1_3
///    VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK = 1000138002,
///  // Provided by VK_VERSION_1_3
///    VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO = 1000138003,
///  // Provided by VK_VERSION_1_3
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES = 1000066000,
///  // Provided by VK_VERSION_1_3
///    VK_STRUCTURE_TYPE_RENDERING_INFO = 1000044000,
///  // Provided by VK_VERSION_1_3
///    VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO = 1000044001,
///  // Provided by VK_VERSION_1_3
///    VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO = 1000044002,
///  // Provided by VK_VERSION_1_3
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES = 1000044003,
///  // Provided by VK_VERSION_1_3
///    VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO = 1000044004,
///  // Provided by VK_VERSION_1_3
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES = 1000280000,
///  // Provided by VK_VERSION_1_3
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES = 1000280001,
///  // Provided by VK_VERSION_1_3
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES = 1000281001,
///  // Provided by VK_VERSION_1_3
///    VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3 = 1000360000,
///  // Provided by VK_VERSION_1_3
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES = 1000413000,
///  // Provided by VK_VERSION_1_3
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES = 1000413001,
///  // Provided by VK_VERSION_1_3
///    VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS = 1000413002,
///  // Provided by VK_VERSION_1_3
///    VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS = 1000413003,
///  // Provided by VK_KHR_swapchain
///    VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR = 1000001000,
///  // Provided by VK_KHR_swapchain
///    VK_STRUCTURE_TYPE_PRESENT_INFO_KHR = 1000001001,
///  // Provided by VK_VERSION_1_1 with VK_KHR_swapchain, VK_KHR_device_group with VK_KHR_surface
///    VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR = 1000060007,
///  // Provided by VK_VERSION_1_1 with VK_KHR_swapchain, VK_KHR_device_group with VK_KHR_swapchain
///    VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR = 1000060008,
///  // Provided by VK_VERSION_1_1 with VK_KHR_swapchain, VK_KHR_device_group with VK_KHR_swapchain
///    VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR = 1000060009,
///  // Provided by VK_VERSION_1_1 with VK_KHR_swapchain, VK_KHR_device_group with VK_KHR_swapchain
///    VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR = 1000060010,
///  // Provided by VK_VERSION_1_1 with VK_KHR_swapchain, VK_KHR_device_group with VK_KHR_swapchain
///    VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR = 1000060011,
///  // Provided by VK_VERSION_1_1 with VK_KHR_swapchain, VK_KHR_device_group with VK_KHR_swapchain
///    VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR = 1000060012,
///  // Provided by VK_KHR_display
///    VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR = 1000002000,
///  // Provided by VK_KHR_display
///    VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR = 1000002001,
///  // Provided by VK_KHR_display_swapchain
///    VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR = 1000003000,
///  // Provided by VK_KHR_xlib_surface
///    VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR = 1000004000,
///  // Provided by VK_KHR_xcb_surface
///    VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR = 1000005000,
///  // Provided by VK_KHR_wayland_surface
///    VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR = 1000006000,
///  // Provided by VK_KHR_android_surface
///    VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR = 1000008000,
///  // Provided by VK_KHR_win32_surface
///    VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR = 1000009000,
///  // Provided by VK_EXT_debug_report
///    VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT = 1000011000,
///  // Provided by VK_AMD_rasterization_order
///    VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD = 1000018000,
///  // Provided by VK_EXT_debug_marker
///    VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT = 1000022000,
///  // Provided by VK_EXT_debug_marker
///    VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT = 1000022001,
///  // Provided by VK_EXT_debug_marker
///    VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT = 1000022002,
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_KHR_video_queue
///    VK_STRUCTURE_TYPE_VIDEO_PROFILE_KHR = 1000023000,
///#endif
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_KHR_video_queue
///    VK_STRUCTURE_TYPE_VIDEO_CAPABILITIES_KHR = 1000023001,
///#endif
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_KHR_video_queue
///    VK_STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_KHR = 1000023002,
///#endif
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_KHR_video_queue
///    VK_STRUCTURE_TYPE_VIDEO_GET_MEMORY_PROPERTIES_KHR = 1000023003,
///#endif
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_KHR_video_queue
///    VK_STRUCTURE_TYPE_VIDEO_BIND_MEMORY_KHR = 1000023004,
///#endif
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_KHR_video_queue
///    VK_STRUCTURE_TYPE_VIDEO_SESSION_CREATE_INFO_KHR = 1000023005,
///#endif
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_KHR_video_queue
///    VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_CREATE_INFO_KHR = 1000023006,
///#endif
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_KHR_video_queue
///    VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_UPDATE_INFO_KHR = 1000023007,
///#endif
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_KHR_video_queue
///    VK_STRUCTURE_TYPE_VIDEO_BEGIN_CODING_INFO_KHR = 1000023008,
///#endif
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_KHR_video_queue
///    VK_STRUCTURE_TYPE_VIDEO_END_CODING_INFO_KHR = 1000023009,
///#endif
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_KHR_video_queue
///    VK_STRUCTURE_TYPE_VIDEO_CODING_CONTROL_INFO_KHR = 1000023010,
///#endif
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_KHR_video_queue
///    VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_KHR = 1000023011,
///#endif
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_KHR_video_queue
///    VK_STRUCTURE_TYPE_VIDEO_QUEUE_FAMILY_PROPERTIES_2_KHR = 1000023012,
///#endif
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_KHR_video_queue
///    VK_STRUCTURE_TYPE_VIDEO_PROFILES_KHR = 1000023013,
///#endif
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_KHR_video_queue
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_FORMAT_INFO_KHR = 1000023014,
///#endif
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_KHR_video_queue
///    VK_STRUCTURE_TYPE_VIDEO_FORMAT_PROPERTIES_KHR = 1000023015,
///#endif
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_KHR_video_queue
///    VK_STRUCTURE_TYPE_QUEUE_FAMILY_QUERY_RESULT_STATUS_PROPERTIES_2_KHR = 1000023016,
///#endif
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_KHR_video_decode_queue
///    VK_STRUCTURE_TYPE_VIDEO_DECODE_INFO_KHR = 1000024000,
///#endif
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_KHR_video_decode_queue
///    VK_STRUCTURE_TYPE_VIDEO_DECODE_CAPABILITIES_KHR = 1000024001,
///#endif
///  // Provided by VK_NV_dedicated_allocation
///    VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV = 1000026000,
///  // Provided by VK_NV_dedicated_allocation
///    VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV = 1000026001,
///  // Provided by VK_NV_dedicated_allocation
///    VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV = 1000026002,
///  // Provided by VK_EXT_transform_feedback
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT = 1000028000,
///  // Provided by VK_EXT_transform_feedback
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT = 1000028001,
///  // Provided by VK_EXT_transform_feedback
///    VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT = 1000028002,
///  // Provided by VK_NVX_binary_import
///    VK_STRUCTURE_TYPE_CU_MODULE_CREATE_INFO_NVX = 1000029000,
///  // Provided by VK_NVX_binary_import
///    VK_STRUCTURE_TYPE_CU_FUNCTION_CREATE_INFO_NVX = 1000029001,
///  // Provided by VK_NVX_binary_import
///    VK_STRUCTURE_TYPE_CU_LAUNCH_INFO_NVX = 1000029002,
///  // Provided by VK_NVX_image_view_handle
///    VK_STRUCTURE_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX = 1000030000,
///  // Provided by VK_NVX_image_view_handle
///    VK_STRUCTURE_TYPE_IMAGE_VIEW_ADDRESS_PROPERTIES_NVX = 1000030001,
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_EXT_video_encode_h264
///    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_CAPABILITIES_EXT = 1000038000,
///#endif
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_EXT_video_encode_h264
///    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_CREATE_INFO_EXT = 1000038001,
///#endif
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_EXT_video_encode_h264
///    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_CREATE_INFO_EXT = 1000038002,
///#endif
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_EXT_video_encode_h264
///    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_ADD_INFO_EXT = 1000038003,
///#endif
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_EXT_video_encode_h264
///    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_VCL_FRAME_INFO_EXT = 1000038004,
///#endif
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_EXT_video_encode_h264
///    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_DPB_SLOT_INFO_EXT = 1000038005,
///#endif
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_EXT_video_encode_h264
///    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_NALU_SLICE_EXT = 1000038006,
///#endif
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_EXT_video_encode_h264
///    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_EMIT_PICTURE_PARAMETERS_EXT = 1000038007,
///#endif
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_EXT_video_encode_h264
///    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PROFILE_EXT = 1000038008,
///#endif
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_EXT_video_encode_h264
///    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_INFO_EXT = 1000038009,
///#endif
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_EXT_video_encode_h264
///    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_LAYER_INFO_EXT = 1000038010,
///#endif
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_EXT_video_encode_h264
///    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_REFERENCE_LISTS_EXT = 1000038011,
///#endif
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_EXT_video_encode_h265
///    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_CAPABILITIES_EXT = 1000039000,
///#endif
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_EXT_video_encode_h265
///    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_CREATE_INFO_EXT = 1000039001,
///#endif
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_EXT_video_encode_h265
///    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_CREATE_INFO_EXT = 1000039002,
///#endif
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_EXT_video_encode_h265
///    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_ADD_INFO_EXT = 1000039003,
///#endif
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_EXT_video_encode_h265
///    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_VCL_FRAME_INFO_EXT = 1000039004,
///#endif
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_EXT_video_encode_h265
///    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_DPB_SLOT_INFO_EXT = 1000039005,
///#endif
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_EXT_video_encode_h265
///    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_NALU_SLICE_SEGMENT_EXT = 1000039006,
///#endif
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_EXT_video_encode_h265
///    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_EMIT_PICTURE_PARAMETERS_EXT = 1000039007,
///#endif
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_EXT_video_encode_h265
///    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PROFILE_EXT = 1000039008,
///#endif
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_EXT_video_encode_h265
///    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_REFERENCE_LISTS_EXT = 1000039009,
///#endif
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_EXT_video_encode_h265
///    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_INFO_EXT = 1000039010,
///#endif
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_EXT_video_encode_h265
///    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_LAYER_INFO_EXT = 1000039011,
///#endif
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_EXT_video_decode_h264
///    VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_CAPABILITIES_EXT = 1000040000,
///#endif
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_EXT_video_decode_h264
///    VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_CREATE_INFO_EXT = 1000040001,
///#endif
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_EXT_video_decode_h264
///    VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PICTURE_INFO_EXT = 1000040002,
///#endif
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_EXT_video_decode_h264
///    VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_MVC_EXT = 1000040003,
///#endif
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_EXT_video_decode_h264
///    VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PROFILE_EXT = 1000040004,
///#endif
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_EXT_video_decode_h264
///    VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_CREATE_INFO_EXT = 1000040005,
///#endif
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_EXT_video_decode_h264
///    VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_ADD_INFO_EXT = 1000040006,
///#endif
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_EXT_video_decode_h264
///    VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_DPB_SLOT_INFO_EXT = 1000040007,
///#endif
///  // Provided by VK_AMD_texture_gather_bias_lod
///    VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD = 1000041000,
///  // Provided by VK_KHR_dynamic_rendering with VK_KHR_fragment_shading_rate
///    VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR = 1000044006,
///  // Provided by VK_KHR_dynamic_rendering with VK_EXT_fragment_density_map
///    VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT = 1000044007,
///  // Provided by VK_KHR_dynamic_rendering with VK_AMD_mixed_attachment_samples
///    VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD = 1000044008,
///  // Provided by VK_KHR_dynamic_rendering with VK_NVX_multiview_per_view_attributes
///    VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX = 1000044009,
///  // Provided by VK_GGP_stream_descriptor_surface
///    VK_STRUCTURE_TYPE_STREAM_DESCRIPTOR_SURFACE_CREATE_INFO_GGP = 1000049000,
///  // Provided by VK_NV_corner_sampled_image
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV = 1000050000,
///  // Provided by VK_NV_external_memory
///    VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV = 1000056000,
///  // Provided by VK_NV_external_memory
///    VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV = 1000056001,
///  // Provided by VK_NV_external_memory_win32
///    VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV = 1000057000,
///  // Provided by VK_NV_external_memory_win32
///    VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV = 1000057001,
///  // Provided by VK_NV_win32_keyed_mutex
///    VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV = 1000058000,
///  // Provided by VK_EXT_validation_flags
///    VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT = 1000061000,
///  // Provided by VK_NN_vi_surface
///    VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN = 1000062000,
///  // Provided by VK_EXT_astc_decode_mode
///    VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT = 1000067000,
///  // Provided by VK_EXT_astc_decode_mode
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT = 1000067001,
///  // Provided by VK_KHR_external_memory_win32
///    VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR = 1000073000,
///  // Provided by VK_KHR_external_memory_win32
///    VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR = 1000073001,
///  // Provided by VK_KHR_external_memory_win32
///    VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR = 1000073002,
///  // Provided by VK_KHR_external_memory_win32
///    VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR = 1000073003,
///  // Provided by VK_KHR_external_memory_fd
///    VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR = 1000074000,
///  // Provided by VK_KHR_external_memory_fd
///    VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR = 1000074001,
///  // Provided by VK_KHR_external_memory_fd
///    VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR = 1000074002,
///  // Provided by VK_KHR_win32_keyed_mutex
///    VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR = 1000075000,
///  // Provided by VK_KHR_external_semaphore_win32
///    VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR = 1000078000,
///  // Provided by VK_KHR_external_semaphore_win32
///    VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR = 1000078001,
///  // Provided by VK_KHR_external_semaphore_win32
///    VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR = 1000078002,
///  // Provided by VK_KHR_external_semaphore_win32
///    VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR = 1000078003,
///  // Provided by VK_KHR_external_semaphore_fd
///    VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR = 1000079000,
///  // Provided by VK_KHR_external_semaphore_fd
///    VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR = 1000079001,
///  // Provided by VK_KHR_push_descriptor
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR = 1000080000,
///  // Provided by VK_EXT_conditional_rendering
///    VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT = 1000081000,
///  // Provided by VK_EXT_conditional_rendering
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT = 1000081001,
///  // Provided by VK_EXT_conditional_rendering
///    VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT = 1000081002,
///  // Provided by VK_KHR_incremental_present
///    VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR = 1000084000,
///  // Provided by VK_NV_clip_space_w_scaling
///    VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV = 1000087000,
///  // Provided by VK_EXT_display_surface_counter
///    VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT = 1000090000,
///  // Provided by VK_EXT_display_control
///    VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT = 1000091000,
///  // Provided by VK_EXT_display_control
///    VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT = 1000091001,
///  // Provided by VK_EXT_display_control
///    VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT = 1000091002,
///  // Provided by VK_EXT_display_control
///    VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT = 1000091003,
///  // Provided by VK_GOOGLE_display_timing
///    VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE = 1000092000,
///  // Provided by VK_NVX_multiview_per_view_attributes
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX = 1000097000,
///  // Provided by VK_NV_viewport_swizzle
///    VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV = 1000098000,
///  // Provided by VK_EXT_discard_rectangles
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT = 1000099000,
///  // Provided by VK_EXT_discard_rectangles
///    VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT = 1000099001,
///  // Provided by VK_EXT_conservative_rasterization
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT = 1000101000,
///  // Provided by VK_EXT_conservative_rasterization
///    VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT = 1000101001,
///  // Provided by VK_EXT_depth_clip_enable
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT = 1000102000,
///  // Provided by VK_EXT_depth_clip_enable
///    VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT = 1000102001,
///  // Provided by VK_EXT_hdr_metadata
///    VK_STRUCTURE_TYPE_HDR_METADATA_EXT = 1000105000,
///  // Provided by VK_KHR_shared_presentable_image
///    VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR = 1000111000,
///  // Provided by VK_KHR_external_fence_win32
///    VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR = 1000114000,
///  // Provided by VK_KHR_external_fence_win32
///    VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR = 1000114001,
///  // Provided by VK_KHR_external_fence_win32
///    VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR = 1000114002,
///  // Provided by VK_KHR_external_fence_fd
///    VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR = 1000115000,
///  // Provided by VK_KHR_external_fence_fd
///    VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR = 1000115001,
///  // Provided by VK_KHR_performance_query
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR = 1000116000,
///  // Provided by VK_KHR_performance_query
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR = 1000116001,
///  // Provided by VK_KHR_performance_query
///    VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR = 1000116002,
///  // Provided by VK_KHR_performance_query
///    VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR = 1000116003,
///  // Provided by VK_KHR_performance_query
///    VK_STRUCTURE_TYPE_ACQUIRE_PROFILING_LOCK_INFO_KHR = 1000116004,
///  // Provided by VK_KHR_performance_query
///    VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_KHR = 1000116005,
///  // Provided by VK_KHR_performance_query
///    VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_KHR = 1000116006,
///  // Provided by VK_KHR_get_surface_capabilities2
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR = 1000119000,
///  // Provided by VK_KHR_get_surface_capabilities2
///    VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR = 1000119001,
///  // Provided by VK_KHR_get_surface_capabilities2
///    VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR = 1000119002,
///  // Provided by VK_KHR_get_display_properties2
///    VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR = 1000121000,
///  // Provided by VK_KHR_get_display_properties2
///    VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR = 1000121001,
///  // Provided by VK_KHR_get_display_properties2
///    VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR = 1000121002,
///  // Provided by VK_KHR_get_display_properties2
///    VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR = 1000121003,
///  // Provided by VK_KHR_get_display_properties2
///    VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR = 1000121004,
///  // Provided by VK_MVK_ios_surface
///    VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK = 1000122000,
///  // Provided by VK_MVK_macos_surface
///    VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK = 1000123000,
///  // Provided by VK_EXT_debug_utils
///    VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT = 1000128000,
///  // Provided by VK_EXT_debug_utils
///    VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT = 1000128001,
///  // Provided by VK_EXT_debug_utils
///    VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT = 1000128002,
///  // Provided by VK_EXT_debug_utils
///    VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT = 1000128003,
///  // Provided by VK_EXT_debug_utils
///    VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT = 1000128004,
///  // Provided by VK_ANDROID_external_memory_android_hardware_buffer
///    VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID = 1000129000,
///  // Provided by VK_ANDROID_external_memory_android_hardware_buffer
///    VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID = 1000129001,
///  // Provided by VK_ANDROID_external_memory_android_hardware_buffer
///    VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID = 1000129002,
///  // Provided by VK_ANDROID_external_memory_android_hardware_buffer
///    VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID = 1000129003,
///  // Provided by VK_ANDROID_external_memory_android_hardware_buffer
///    VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID = 1000129004,
///  // Provided by VK_ANDROID_external_memory_android_hardware_buffer
///    VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID = 1000129005,
///  // Provided by VK_KHR_format_feature_flags2 with
/// VK_ANDROID_external_memory_android_hardware_buffer
///    VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_2_ANDROID = 1000129006,
///  // Provided by VK_EXT_sample_locations
///    VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT = 1000143000,
///  // Provided by VK_EXT_sample_locations
///    VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT = 1000143001,
///  // Provided by VK_EXT_sample_locations
///    VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT = 1000143002,
///  // Provided by VK_EXT_sample_locations
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT = 1000143003,
///  // Provided by VK_EXT_sample_locations
///    VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT = 1000143004,
///  // Provided by VK_EXT_blend_operation_advanced
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT = 1000148000,
///  // Provided by VK_EXT_blend_operation_advanced
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT = 1000148001,
///  // Provided by VK_EXT_blend_operation_advanced
///    VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT = 1000148002,
///  // Provided by VK_NV_fragment_coverage_to_color
///    VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV = 1000149000,
///  // Provided by VK_KHR_acceleration_structure
///    VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR = 1000150007,
///  // Provided by VK_KHR_acceleration_structure
///    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR = 1000150000,
///  // Provided by VK_KHR_acceleration_structure
///    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR = 1000150002,
///  // Provided by VK_KHR_acceleration_structure
///    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR = 1000150003,
///  // Provided by VK_KHR_acceleration_structure
///    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR = 1000150004,
///  // Provided by VK_KHR_acceleration_structure
///    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR = 1000150005,
///  // Provided by VK_KHR_acceleration_structure
///    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR = 1000150006,
///  // Provided by VK_KHR_acceleration_structure
///    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_VERSION_INFO_KHR = 1000150009,
///  // Provided by VK_KHR_acceleration_structure
///    VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_INFO_KHR = 1000150010,
///  // Provided by VK_KHR_acceleration_structure
///    VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR = 1000150011,
///  // Provided by VK_KHR_acceleration_structure
///    VK_STRUCTURE_TYPE_COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR = 1000150012,
///  // Provided by VK_KHR_acceleration_structure
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR = 1000150013,
///  // Provided by VK_KHR_acceleration_structure
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR = 1000150014,
///  // Provided by VK_KHR_acceleration_structure
///    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR = 1000150017,
///  // Provided by VK_KHR_acceleration_structure
///    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR = 1000150020,
///  // Provided by VK_KHR_ray_tracing_pipeline
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR = 1000347000,
///  // Provided by VK_KHR_ray_tracing_pipeline
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR = 1000347001,
///  // Provided by VK_KHR_ray_tracing_pipeline
///    VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR = 1000150015,
///  // Provided by VK_KHR_ray_tracing_pipeline
///    VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR = 1000150016,
///  // Provided by VK_KHR_ray_tracing_pipeline
///    VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_INTERFACE_CREATE_INFO_KHR = 1000150018,
///  // Provided by VK_KHR_ray_query
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR = 1000348013,
///  // Provided by VK_NV_framebuffer_mixed_samples
///    VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV = 1000152000,
///  // Provided by VK_NV_shader_sm_builtins
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV = 1000154000,
///  // Provided by VK_NV_shader_sm_builtins
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV = 1000154001,
///  // Provided by VK_EXT_image_drm_format_modifier
///    VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT = 1000158000,
///  // Provided by VK_EXT_image_drm_format_modifier
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT = 1000158002,
///  // Provided by VK_EXT_image_drm_format_modifier
///    VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT = 1000158003,
///  // Provided by VK_EXT_image_drm_format_modifier
///    VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT = 1000158004,
///  // Provided by VK_EXT_image_drm_format_modifier
///    VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT = 1000158005,
///  // Provided by VK_KHR_format_feature_flags2 with VK_EXT_image_drm_format_modifier
///    VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT = 1000158006,
///  // Provided by VK_EXT_validation_cache
///    VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT = 1000160000,
///  // Provided by VK_EXT_validation_cache
///    VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT = 1000160001,
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_KHR_portability_subset
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR = 1000163000,
///#endif
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_KHR_portability_subset
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_PROPERTIES_KHR = 1000163001,
///#endif
///  // Provided by VK_NV_shading_rate_image
///    VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV = 1000164000,
///  // Provided by VK_NV_shading_rate_image
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV = 1000164001,
///  // Provided by VK_NV_shading_rate_image
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV = 1000164002,
///  // Provided by VK_NV_shading_rate_image
///    VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV = 1000164005,
///  // Provided by VK_NV_ray_tracing
///    VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV = 1000165000,
///  // Provided by VK_NV_ray_tracing
///    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV = 1000165001,
///  // Provided by VK_NV_ray_tracing
///    VK_STRUCTURE_TYPE_GEOMETRY_NV = 1000165003,
///  // Provided by VK_NV_ray_tracing
///    VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV = 1000165004,
///  // Provided by VK_NV_ray_tracing
///    VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV = 1000165005,
///  // Provided by VK_NV_ray_tracing
///    VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV = 1000165006,
///  // Provided by VK_NV_ray_tracing
///    VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV = 1000165007,
///  // Provided by VK_NV_ray_tracing
///    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV = 1000165008,
///  // Provided by VK_NV_ray_tracing
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV = 1000165009,
///  // Provided by VK_NV_ray_tracing
///    VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV = 1000165011,
///  // Provided by VK_NV_ray_tracing
///    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV = 1000165012,
///  // Provided by VK_NV_representative_fragment_test
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV = 1000166000,
///  // Provided by VK_NV_representative_fragment_test
///    VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV = 1000166001,
///  // Provided by VK_EXT_filter_cubic
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT = 1000170000,
///  // Provided by VK_EXT_filter_cubic
///    VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT = 1000170001,
///  // Provided by VK_EXT_external_memory_host
///    VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT = 1000178000,
///  // Provided by VK_EXT_external_memory_host
///    VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT = 1000178001,
///  // Provided by VK_EXT_external_memory_host
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT = 1000178002,
///  // Provided by VK_KHR_shader_clock
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR = 1000181000,
///  // Provided by VK_AMD_pipeline_compiler_control
///    VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD = 1000183000,
///  // Provided by VK_EXT_calibrated_timestamps
///    VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_EXT = 1000184000,
///  // Provided by VK_AMD_shader_core_properties
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD = 1000185000,
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_EXT_video_decode_h265
///    VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_CAPABILITIES_EXT = 1000187000,
///#endif
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_EXT_video_decode_h265
///    VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_CREATE_INFO_EXT = 1000187001,
///#endif
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_EXT_video_decode_h265
///    VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_CREATE_INFO_EXT = 1000187002,
///#endif
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_EXT_video_decode_h265
///    VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_ADD_INFO_EXT = 1000187003,
///#endif
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_EXT_video_decode_h265
///    VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PROFILE_EXT = 1000187004,
///#endif
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_EXT_video_decode_h265
///    VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PICTURE_INFO_EXT = 1000187005,
///#endif
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_EXT_video_decode_h265
///    VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_DPB_SLOT_INFO_EXT = 1000187006,
///#endif
///  // Provided by VK_KHR_global_priority
///    VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_KHR = 1000174000,
///  // Provided by VK_KHR_global_priority
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_KHR = 1000388000,
///  // Provided by VK_KHR_global_priority
///    VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_KHR = 1000388001,
///  // Provided by VK_AMD_memory_overallocation_behavior
///    VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD = 1000189000,
///  // Provided by VK_EXT_vertex_attribute_divisor
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT = 1000190000,
///  // Provided by VK_EXT_vertex_attribute_divisor
///    VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT = 1000190001,
///  // Provided by VK_EXT_vertex_attribute_divisor
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT = 1000190002,
///  // Provided by VK_GGP_frame_token
///    VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP = 1000191000,
///  // Provided by VK_NV_compute_shader_derivatives
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV = 1000201000,
///  // Provided by VK_NV_mesh_shader
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV = 1000202000,
///  // Provided by VK_NV_mesh_shader
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV = 1000202001,
///  // Provided by VK_NV_fragment_shader_barycentric
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_NV = 1000203000,
///  // Provided by VK_NV_shader_image_footprint
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV = 1000204000,
///  // Provided by VK_NV_scissor_exclusive
///    VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV = 1000205000,
///  // Provided by VK_NV_scissor_exclusive
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV = 1000205002,
///  // Provided by VK_NV_device_diagnostic_checkpoints
///    VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV = 1000206000,
///  // Provided by VK_NV_device_diagnostic_checkpoints
///    VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV = 1000206001,
///  // Provided by VK_INTEL_shader_integer_functions2
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL = 1000209000,
///  // Provided by VK_INTEL_performance_query
///    VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL = 1000210000,
///  // Provided by VK_INTEL_performance_query
///    VK_STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL = 1000210001,
///  // Provided by VK_INTEL_performance_query
///    VK_STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL = 1000210002,
///  // Provided by VK_INTEL_performance_query
///    VK_STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL = 1000210003,
///  // Provided by VK_INTEL_performance_query
///    VK_STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL = 1000210004,
///  // Provided by VK_INTEL_performance_query
///    VK_STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL = 1000210005,
///  // Provided by VK_EXT_pci_bus_info
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT = 1000212000,
///  // Provided by VK_AMD_display_native_hdr
///    VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD = 1000213000,
///  // Provided by VK_AMD_display_native_hdr
///    VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD = 1000213001,
///  // Provided by VK_FUCHSIA_imagepipe_surface
///    VK_STRUCTURE_TYPE_IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA = 1000214000,
///  // Provided by VK_EXT_metal_surface
///    VK_STRUCTURE_TYPE_METAL_SURFACE_CREATE_INFO_EXT = 1000217000,
///  // Provided by VK_EXT_fragment_density_map
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT = 1000218000,
///  // Provided by VK_EXT_fragment_density_map
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT = 1000218001,
///  // Provided by VK_EXT_fragment_density_map
///    VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT = 1000218002,
///  // Provided by VK_KHR_fragment_shading_rate
///    VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR = 1000226000,
///  // Provided by VK_KHR_fragment_shading_rate
///    VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR = 1000226001,
///  // Provided by VK_KHR_fragment_shading_rate
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR = 1000226002,
///  // Provided by VK_KHR_fragment_shading_rate
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR = 1000226003,
///  // Provided by VK_KHR_fragment_shading_rate
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR = 1000226004,
///  // Provided by VK_AMD_shader_core_properties2
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD = 1000227000,
///  // Provided by VK_AMD_device_coherent_memory
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD = 1000229000,
///  // Provided by VK_EXT_shader_image_atomic_int64
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT = 1000234000,
///  // Provided by VK_EXT_memory_budget
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT = 1000237000,
///  // Provided by VK_EXT_memory_priority
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT = 1000238000,
///  // Provided by VK_EXT_memory_priority
///    VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT = 1000238001,
///  // Provided by VK_KHR_surface_protected_capabilities
///    VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR = 1000239000,
///  // Provided by VK_NV_dedicated_allocation_image_aliasing
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV =
/// 1000240000,
///  // Provided by VK_EXT_buffer_device_address
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT = 1000244000,
///  // Provided by VK_EXT_buffer_device_address
///    VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT = 1000244002,
///  // Provided by VK_EXT_validation_features
///    VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT = 1000247000,
///  // Provided by VK_KHR_present_wait
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR = 1000248000,
///  // Provided by VK_NV_cooperative_matrix
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV = 1000249000,
///  // Provided by VK_NV_cooperative_matrix
///    VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV = 1000249001,
///  // Provided by VK_NV_cooperative_matrix
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV = 1000249002,
///  // Provided by VK_NV_coverage_reduction_mode
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV = 1000250000,
///  // Provided by VK_NV_coverage_reduction_mode
///    VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV = 1000250001,
///  // Provided by VK_NV_coverage_reduction_mode
///    VK_STRUCTURE_TYPE_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV = 1000250002,
///  // Provided by VK_EXT_fragment_shader_interlock
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT = 1000251000,
///  // Provided by VK_EXT_ycbcr_image_arrays
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT = 1000252000,
///  // Provided by VK_EXT_provoking_vertex
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT = 1000254000,
///  // Provided by VK_EXT_provoking_vertex
///    VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT = 1000254001,
///  // Provided by VK_EXT_provoking_vertex
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT = 1000254002,
///  // Provided by VK_EXT_full_screen_exclusive
///    VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT = 1000255000,
///  // Provided by VK_EXT_full_screen_exclusive
///    VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT = 1000255002,
///  // Provided by VK_KHR_win32_surface with VK_EXT_full_screen_exclusive
///    VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT = 1000255001,
///  // Provided by VK_EXT_headless_surface
///    VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT = 1000256000,
///  // Provided by VK_EXT_line_rasterization
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT = 1000259000,
///  // Provided by VK_EXT_line_rasterization
///    VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT = 1000259001,
///  // Provided by VK_EXT_line_rasterization
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT = 1000259002,
///  // Provided by VK_EXT_shader_atomic_float
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT = 1000260000,
///  // Provided by VK_EXT_index_type_uint8
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT = 1000265000,
///  // Provided by VK_EXT_extended_dynamic_state
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT = 1000267000,
///  // Provided by VK_KHR_pipeline_executable_properties
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR = 1000269000,
///  // Provided by VK_KHR_pipeline_executable_properties
///    VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR = 1000269001,
///  // Provided by VK_KHR_pipeline_executable_properties
///    VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR = 1000269002,
///  // Provided by VK_KHR_pipeline_executable_properties
///    VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR = 1000269003,
///  // Provided by VK_KHR_pipeline_executable_properties
///    VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR = 1000269004,
///  // Provided by VK_KHR_pipeline_executable_properties
///    VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR = 1000269005,
///  // Provided by VK_EXT_shader_atomic_float2
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT = 1000273000,
///  // Provided by VK_NV_device_generated_commands
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV = 1000277000,
///  // Provided by VK_NV_device_generated_commands
///    VK_STRUCTURE_TYPE_GRAPHICS_SHADER_GROUP_CREATE_INFO_NV = 1000277001,
///  // Provided by VK_NV_device_generated_commands
///    VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV = 1000277002,
///  // Provided by VK_NV_device_generated_commands
///    VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_NV = 1000277003,
///  // Provided by VK_NV_device_generated_commands
///    VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NV = 1000277004,
///  // Provided by VK_NV_device_generated_commands
///    VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_NV = 1000277005,
///  // Provided by VK_NV_device_generated_commands
///    VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_NV = 1000277006,
///  // Provided by VK_NV_device_generated_commands
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV = 1000277007,
///  // Provided by VK_NV_inherited_viewport_scissor
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV = 1000278000,
///  // Provided by VK_NV_inherited_viewport_scissor
///    VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV = 1000278001,
///  // Provided by VK_EXT_texel_buffer_alignment
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT = 1000281000,
///  // Provided by VK_QCOM_render_pass_transform
///    VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM = 1000282000,
///  // Provided by VK_QCOM_render_pass_transform
///    VK_STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM = 1000282001,
///  // Provided by VK_EXT_device_memory_report
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT = 1000284000,
///  // Provided by VK_EXT_device_memory_report
///    VK_STRUCTURE_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT = 1000284001,
///  // Provided by VK_EXT_device_memory_report
///    VK_STRUCTURE_TYPE_DEVICE_MEMORY_REPORT_CALLBACK_DATA_EXT = 1000284002,
///  // Provided by VK_EXT_robustness2
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT = 1000286000,
///  // Provided by VK_EXT_robustness2
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_EXT = 1000286001,
///  // Provided by VK_EXT_custom_border_color
///    VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT = 1000287000,
///  // Provided by VK_EXT_custom_border_color
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT = 1000287001,
///  // Provided by VK_EXT_custom_border_color
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT = 1000287002,
///  // Provided by VK_KHR_pipeline_library
///    VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR = 1000290000,
///  // Provided by VK_KHR_present_id
///    VK_STRUCTURE_TYPE_PRESENT_ID_KHR = 1000294000,
///  // Provided by VK_KHR_present_id
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR = 1000294001,
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_KHR_video_encode_queue
///    VK_STRUCTURE_TYPE_VIDEO_ENCODE_INFO_KHR = 1000299000,
///#endif
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_KHR_video_encode_queue
///    VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_INFO_KHR = 1000299001,
///#endif
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_KHR_video_encode_queue
///    VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_LAYER_INFO_KHR = 1000299002,
///#endif
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_KHR_video_encode_queue
///    VK_STRUCTURE_TYPE_VIDEO_ENCODE_CAPABILITIES_KHR = 1000299003,
///#endif
///  // Provided by VK_NV_device_diagnostics_config
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV = 1000300000,
///  // Provided by VK_NV_device_diagnostics_config
///    VK_STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV = 1000300001,
///  // Provided by VK_KHR_synchronization2 with VK_NV_device_diagnostic_checkpoints
///    VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV = 1000314008,
///  // Provided by VK_KHR_synchronization2 with VK_NV_device_diagnostic_checkpoints
///    VK_STRUCTURE_TYPE_CHECKPOINT_DATA_2_NV = 1000314009,
///  // Provided by VK_KHR_shader_subgroup_uniform_control_flow
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR =
/// 1000323000,
///  // Provided by VK_NV_fragment_shading_rate_enums
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV = 1000326000,
///  // Provided by VK_NV_fragment_shading_rate_enums
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV = 1000326001,
///  // Provided by VK_NV_fragment_shading_rate_enums
///    VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV = 1000326002,
///  // Provided by VK_NV_ray_tracing_motion_blur
///    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_MOTION_TRIANGLES_DATA_NV = 1000327000,
///  // Provided by VK_NV_ray_tracing_motion_blur
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV = 1000327001,
///  // Provided by VK_NV_ray_tracing_motion_blur
///    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MOTION_INFO_NV = 1000327002,
///  // Provided by VK_EXT_ycbcr_2plane_444_formats
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT = 1000330000,
///  // Provided by VK_EXT_fragment_density_map2
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT = 1000332000,
///  // Provided by VK_EXT_fragment_density_map2
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT = 1000332001,
///  // Provided by VK_QCOM_rotated_copy_commands
///    VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM = 1000333000,
///  // Provided by VK_KHR_workgroup_memory_explicit_layout
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR = 1000336000,
///  // Provided by VK_EXT_4444_formats
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT = 1000340000,
///  // Provided by VK_ARM_rasterization_order_attachment_access
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_ARM =
/// 1000342000,
///  // Provided by VK_EXT_rgba10x6_formats
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT = 1000344000,
///  // Provided by VK_EXT_directfb_surface
///    VK_STRUCTURE_TYPE_DIRECTFB_SURFACE_CREATE_INFO_EXT = 1000346000,
///  // Provided by VK_VALVE_mutable_descriptor_type
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_VALVE = 1000351000,
///  // Provided by VK_VALVE_mutable_descriptor_type
///    VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_VALVE = 1000351002,
///  // Provided by VK_EXT_vertex_input_dynamic_state
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT = 1000352000,
///  // Provided by VK_EXT_vertex_input_dynamic_state
///    VK_STRUCTURE_TYPE_VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT = 1000352001,
///  // Provided by VK_EXT_vertex_input_dynamic_state
///    VK_STRUCTURE_TYPE_VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT = 1000352002,
///  // Provided by VK_EXT_physical_device_drm
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRM_PROPERTIES_EXT = 1000353000,
///  // Provided by VK_EXT_depth_clip_control
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT = 1000355000,
///  // Provided by VK_EXT_depth_clip_control
///    VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_EXT = 1000355001,
///  // Provided by VK_EXT_primitive_topology_list_restart
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT = 1000356000,
///  // Provided by VK_FUCHSIA_external_memory
///    VK_STRUCTURE_TYPE_IMPORT_MEMORY_ZIRCON_HANDLE_INFO_FUCHSIA = 1000364000,
///  // Provided by VK_FUCHSIA_external_memory
///    VK_STRUCTURE_TYPE_MEMORY_ZIRCON_HANDLE_PROPERTIES_FUCHSIA = 1000364001,
///  // Provided by VK_FUCHSIA_external_memory
///    VK_STRUCTURE_TYPE_MEMORY_GET_ZIRCON_HANDLE_INFO_FUCHSIA = 1000364002,
///  // Provided by VK_FUCHSIA_external_semaphore
///    VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_ZIRCON_HANDLE_INFO_FUCHSIA = 1000365000,
///  // Provided by VK_FUCHSIA_external_semaphore
///    VK_STRUCTURE_TYPE_SEMAPHORE_GET_ZIRCON_HANDLE_INFO_FUCHSIA = 1000365001,
///  // Provided by VK_FUCHSIA_buffer_collection
///    VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CREATE_INFO_FUCHSIA = 1000366000,
///  // Provided by VK_FUCHSIA_buffer_collection
///    VK_STRUCTURE_TYPE_IMPORT_MEMORY_BUFFER_COLLECTION_FUCHSIA = 1000366001,
///  // Provided by VK_FUCHSIA_buffer_collection
///    VK_STRUCTURE_TYPE_BUFFER_COLLECTION_IMAGE_CREATE_INFO_FUCHSIA = 1000366002,
///  // Provided by VK_FUCHSIA_buffer_collection
///    VK_STRUCTURE_TYPE_BUFFER_COLLECTION_PROPERTIES_FUCHSIA = 1000366003,
///  // Provided by VK_FUCHSIA_buffer_collection
///    VK_STRUCTURE_TYPE_BUFFER_CONSTRAINTS_INFO_FUCHSIA = 1000366004,
///  // Provided by VK_FUCHSIA_buffer_collection
///    VK_STRUCTURE_TYPE_BUFFER_COLLECTION_BUFFER_CREATE_INFO_FUCHSIA = 1000366005,
///  // Provided by VK_FUCHSIA_buffer_collection
///    VK_STRUCTURE_TYPE_IMAGE_CONSTRAINTS_INFO_FUCHSIA = 1000366006,
///  // Provided by VK_FUCHSIA_buffer_collection
///    VK_STRUCTURE_TYPE_IMAGE_FORMAT_CONSTRAINTS_INFO_FUCHSIA = 1000366007,
///  // Provided by VK_FUCHSIA_buffer_collection
///    VK_STRUCTURE_TYPE_SYSMEM_COLOR_SPACE_FUCHSIA = 1000366008,
///  // Provided by VK_FUCHSIA_buffer_collection
///    VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CONSTRAINTS_INFO_FUCHSIA = 1000366009,
///  // Provided by VK_HUAWEI_subpass_shading
///    VK_STRUCTURE_TYPE_SUBPASS_SHADING_PIPELINE_CREATE_INFO_HUAWEI = 1000369000,
///  // Provided by VK_HUAWEI_subpass_shading
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI = 1000369001,
///  // Provided by VK_HUAWEI_subpass_shading
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI = 1000369002,
///  // Provided by VK_HUAWEI_invocation_mask
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI = 1000370000,
///  // Provided by VK_NV_external_memory_rdma
///    VK_STRUCTURE_TYPE_MEMORY_GET_REMOTE_ADDRESS_INFO_NV = 1000371000,
///  // Provided by VK_NV_external_memory_rdma
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_RDMA_FEATURES_NV = 1000371001,
///  // Provided by VK_EXT_extended_dynamic_state2
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT = 1000377000,
///  // Provided by VK_QNX_screen_surface
///    VK_STRUCTURE_TYPE_SCREEN_SURFACE_CREATE_INFO_QNX = 1000378000,
///  // Provided by VK_EXT_color_write_enable
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT = 1000381000,
///  // Provided by VK_EXT_color_write_enable
///    VK_STRUCTURE_TYPE_PIPELINE_COLOR_WRITE_CREATE_INFO_EXT = 1000381001,
///  // Provided by VK_EXT_image_view_min_lod
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT = 1000391000,
///  // Provided by VK_EXT_image_view_min_lod
///    VK_STRUCTURE_TYPE_IMAGE_VIEW_MIN_LOD_CREATE_INFO_EXT = 1000391001,
///  // Provided by VK_EXT_multi_draw
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT = 1000392000,
///  // Provided by VK_EXT_multi_draw
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT = 1000392001,
///  // Provided by VK_EXT_border_color_swizzle
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT = 1000411000,
///  // Provided by VK_EXT_border_color_swizzle
///    VK_STRUCTURE_TYPE_SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT = 1000411001,
///  // Provided by VK_EXT_pageable_device_local_memory
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT = 1000412000,
///  // Provided by VK_VALVE_descriptor_set_host_mapping
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE = 1000420000,
///  // Provided by VK_VALVE_descriptor_set_host_mapping
///    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_BINDING_REFERENCE_VALVE = 1000420001,
///  // Provided by VK_VALVE_descriptor_set_host_mapping
///    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_HOST_MAPPING_INFO_VALVE = 1000420002,
///  // Provided by VK_QCOM_fragment_density_map_offset
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_QCOM = 1000425000,
///  // Provided by VK_QCOM_fragment_density_map_offset
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_QCOM = 1000425001,
///  // Provided by VK_QCOM_fragment_density_map_offset
///    VK_STRUCTURE_TYPE_SUBPASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_QCOM = 1000425002,
///  // Provided by VK_NV_linear_color_attachment
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV = 1000430000,
///  // Provided by VK_VERSION_1_1
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES =
/// VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES,
///  // Provided by VK_VERSION_1_1
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES =
/// VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES,
///  // Provided by VK_EXT_debug_report
///    VK_STRUCTURE_TYPE_DEBUG_REPORT_CREATE_INFO_EXT =
/// VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT,
///  // Provided by VK_KHR_dynamic_rendering
///    VK_STRUCTURE_TYPE_RENDERING_INFO_KHR = VK_STRUCTURE_TYPE_RENDERING_INFO,
///  // Provided by VK_KHR_dynamic_rendering
///    VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO_KHR =
/// VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO,
///  // Provided by VK_KHR_dynamic_rendering
///    VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO_KHR =
/// VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO,
///  // Provided by VK_KHR_dynamic_rendering
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES_KHR =
/// VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES,
///  // Provided by VK_KHR_dynamic_rendering
///    VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO_KHR =
/// VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO,
///  // Provided by VK_KHR_dynamic_rendering with VK_NV_framebuffer_mixed_samples
///    VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_NV =
/// VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD,
///  // Provided by VK_KHR_multiview
///    VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO_KHR =
/// VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO,
///  // Provided by VK_KHR_multiview
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES_KHR =
/// VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES,
///  // Provided by VK_KHR_multiview
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES_KHR =
/// VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES,
///  // Provided by VK_KHR_get_physical_device_properties2
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2_KHR =
/// VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
///  // Provided by VK_KHR_get_physical_device_properties2
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2_KHR =
/// VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
///  // Provided by VK_KHR_get_physical_device_properties2
///    VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2_KHR = VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2,
///  // Provided by VK_KHR_get_physical_device_properties2
///    VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2_KHR =
/// VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2,
///  // Provided by VK_KHR_get_physical_device_properties2
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2_KHR =
/// VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2,
///  // Provided by VK_KHR_get_physical_device_properties2
///    VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2_KHR =
/// VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2,
///  // Provided by VK_KHR_get_physical_device_properties2
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2_KHR =
/// VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2,
///  // Provided by VK_KHR_get_physical_device_properties2
///    VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2_KHR =
/// VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2,
///  // Provided by VK_KHR_get_physical_device_properties2
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2_KHR =
/// VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2,
///  // Provided by VK_KHR_device_group
///    VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO_KHR =
/// VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO,
///  // Provided by VK_KHR_device_group
///    VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO_KHR =
/// VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO,
///  // Provided by VK_KHR_device_group
///    VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO_KHR =
/// VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO,
///  // Provided by VK_KHR_device_group
///    VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO_KHR = VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO,
///  // Provided by VK_KHR_device_group
///    VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO_KHR =
/// VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO,
///  // Provided by VK_KHR_bind_memory2 with VK_KHR_device_group
///    VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO_KHR =
/// VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO,
///  // Provided by VK_KHR_bind_memory2 with VK_KHR_device_group
///    VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO_KHR =
/// VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO,
///  // Provided by VK_EXT_texture_compression_astc_hdr
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES_EXT =
/// VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES,
///  // Provided by VK_KHR_device_group_creation
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES_KHR =
/// VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES,
///  // Provided by VK_KHR_device_group_creation
///    VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO_KHR =
/// VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO,
///  // Provided by VK_KHR_external_memory_capabilities
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO_KHR =
/// VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO,
///  // Provided by VK_KHR_external_memory_capabilities
///    VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES_KHR =
/// VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES,
///  // Provided by VK_KHR_external_memory_capabilities
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO_KHR =
/// VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO,
///  // Provided by VK_KHR_external_memory_capabilities
///    VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES_KHR =
/// VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES,
///  // Provided by VK_KHR_external_fence_capabilities, VK_KHR_external_memory_capabilities,
/// VK_KHR_external_semaphore_capabilities
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES_KHR =
/// VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES,
///  // Provided by VK_KHR_external_memory
///    VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO_KHR =
/// VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO,
///  // Provided by VK_KHR_external_memory
///    VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_KHR =
/// VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO,
///  // Provided by VK_KHR_external_memory
///    VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_KHR =
/// VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO,
///  // Provided by VK_KHR_external_semaphore_capabilities
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO_KHR =
/// VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO,
///  // Provided by VK_KHR_external_semaphore_capabilities
///    VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES_KHR =
/// VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES,
///  // Provided by VK_KHR_external_semaphore
///    VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO_KHR =
/// VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO,
///  // Provided by VK_KHR_shader_float16_int8
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES_KHR =
/// VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES,
///  // Provided by VK_KHR_shader_float16_int8
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT16_INT8_FEATURES_KHR =
/// VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES,
///  // Provided by VK_KHR_16bit_storage
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES_KHR =
/// VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES,
///  // Provided by VK_KHR_descriptor_update_template
///    VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO_KHR =
/// VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO,
///  // Provided by VK_EXT_display_surface_counter
///    VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES2_EXT = VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT,
///  // Provided by VK_KHR_imageless_framebuffer
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES_KHR =
/// VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES,
///  // Provided by VK_KHR_imageless_framebuffer
///    VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO_KHR =
/// VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO,
///  // Provided by VK_KHR_imageless_framebuffer
///    VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO_KHR =
/// VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO,
///  // Provided by VK_KHR_imageless_framebuffer
///    VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO_KHR =
/// VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO,
///  // Provided by VK_KHR_create_renderpass2
///    VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2_KHR = VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2,
///  // Provided by VK_KHR_create_renderpass2
///    VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2_KHR = VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2,
///  // Provided by VK_KHR_create_renderpass2
///    VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2_KHR = VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2,
///  // Provided by VK_KHR_create_renderpass2
///    VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2_KHR = VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2,
///  // Provided by VK_KHR_create_renderpass2
///    VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2_KHR =
/// VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2,
///  // Provided by VK_KHR_create_renderpass2
///    VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO_KHR = VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO,
///  // Provided by VK_KHR_create_renderpass2
///    VK_STRUCTURE_TYPE_SUBPASS_END_INFO_KHR = VK_STRUCTURE_TYPE_SUBPASS_END_INFO,
///  // Provided by VK_KHR_external_fence_capabilities
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO_KHR =
/// VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO,
///  // Provided by VK_KHR_external_fence_capabilities
///    VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES_KHR =
/// VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES,
///  // Provided by VK_KHR_external_fence
///    VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO,
///  // Provided by VK_KHR_maintenance2
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES_KHR =
/// VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES,
///  // Provided by VK_KHR_maintenance2
///    VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO_KHR =
/// VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO,
///  // Provided by VK_KHR_maintenance2
///    VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO_KHR =
/// VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO,
///  // Provided by VK_KHR_maintenance2
///    VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO_KHR =
/// VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO,
///  // Provided by VK_KHR_variable_pointers
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES_KHR =
/// VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES,
///  // Provided by VK_KHR_variable_pointers
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES_KHR =
/// VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES_KHR,
///  // Provided by VK_KHR_dedicated_allocation
///    VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS_KHR =
/// VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS,
///  // Provided by VK_KHR_dedicated_allocation
///    VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_KHR =
/// VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO,
///  // Provided by VK_EXT_sampler_filter_minmax
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT =
/// VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES,
///  // Provided by VK_EXT_sampler_filter_minmax
///    VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT =
/// VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO,
///  // Provided by VK_EXT_inline_uniform_block
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT =
/// VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES,
///  // Provided by VK_EXT_inline_uniform_block
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES_EXT =
/// VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES,
///  // Provided by VK_EXT_inline_uniform_block
///    VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT =
/// VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK,
///  // Provided by VK_EXT_inline_uniform_block
///    VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO_EXT =
/// VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO,
///  // Provided by VK_KHR_get_memory_requirements2
///    VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2_KHR =
/// VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2,
///  // Provided by VK_KHR_get_memory_requirements2
///    VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2_KHR =
/// VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2,
///  // Provided by VK_KHR_get_memory_requirements2
///    VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2_KHR =
/// VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2,
///  // Provided by VK_KHR_get_memory_requirements2
///    VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2_KHR = VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2,
///  // Provided by VK_KHR_get_memory_requirements2
///    VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2_KHR =
/// VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2,
///  // Provided by VK_KHR_image_format_list
///    VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR =
/// VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO,
///  // Provided by VK_KHR_sampler_ycbcr_conversion
///    VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO_KHR =
/// VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO,
///  // Provided by VK_KHR_sampler_ycbcr_conversion
///    VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO_KHR =
/// VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO,
///  // Provided by VK_KHR_sampler_ycbcr_conversion
///    VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO_KHR =
/// VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO,
///  // Provided by VK_KHR_sampler_ycbcr_conversion
///    VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO_KHR =
/// VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO,
///  // Provided by VK_KHR_sampler_ycbcr_conversion
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES_KHR =
/// VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES,
///  // Provided by VK_KHR_sampler_ycbcr_conversion
///    VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES_KHR =
/// VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES,
///  // Provided by VK_KHR_bind_memory2
///    VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO_KHR = VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO,
///  // Provided by VK_KHR_bind_memory2
///    VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO_KHR = VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO,
///  // Provided by VK_EXT_descriptor_indexing
///    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT =
/// VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO,
///  // Provided by VK_EXT_descriptor_indexing
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT =
/// VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES,
///  // Provided by VK_EXT_descriptor_indexing
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT =
/// VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES,
///  // Provided by VK_EXT_descriptor_indexing
///    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT =
/// VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO,
///  // Provided by VK_EXT_descriptor_indexing
///    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT =
/// VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT,
///  // Provided by VK_KHR_maintenance3
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES_KHR =
/// VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES,
///  // Provided by VK_KHR_maintenance3
///    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT_KHR =
/// VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT,
///  // Provided by VK_EXT_global_priority
///    VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT =
/// VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_KHR,
///  // Provided by VK_KHR_shader_subgroup_extended_types
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES_KHR =
/// VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES,
///  // Provided by VK_KHR_8bit_storage
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR =
/// VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES,
///  // Provided by VK_KHR_shader_atomic_int64
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES_KHR =
/// VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES,
///  // Provided by VK_EXT_pipeline_creation_feedback
///    VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO_EXT =
/// VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO,
///  // Provided by VK_KHR_driver_properties
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES_KHR =
/// VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES,
///  // Provided by VK_KHR_shader_float_controls
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES_KHR =
/// VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES,
///  // Provided by VK_KHR_depth_stencil_resolve
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES_KHR =
/// VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES,
///  // Provided by VK_KHR_depth_stencil_resolve
///    VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE_KHR =
/// VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE,
///  // Provided by VK_KHR_timeline_semaphore
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES_KHR =
/// VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES,
///  // Provided by VK_KHR_timeline_semaphore
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES_KHR =
/// VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES,
///  // Provided by VK_KHR_timeline_semaphore
///    VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO_KHR =
/// VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO,
///  // Provided by VK_KHR_timeline_semaphore
///    VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO_KHR =
/// VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO,
///  // Provided by VK_KHR_timeline_semaphore
///    VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO_KHR = VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO,
///  // Provided by VK_KHR_timeline_semaphore
///    VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO_KHR = VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO,
///  // Provided by VK_INTEL_performance_query
///    VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO_INTEL =
/// VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL,
///  // Provided by VK_KHR_vulkan_memory_model
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES_KHR =
/// VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES,
///  // Provided by VK_KHR_shader_terminate_invocation
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES_KHR =
/// VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES,
///  // Provided by VK_EXT_scalar_block_layout
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES_EXT =
/// VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES,
///  // Provided by VK_EXT_subgroup_size_control
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES_EXT =
/// VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES,
///  // Provided by VK_EXT_subgroup_size_control
///    VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO_EXT =
/// VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO,
///  // Provided by VK_EXT_subgroup_size_control
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES_EXT =
/// VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES,
///  // Provided by VK_KHR_separate_depth_stencil_layouts
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES_KHR =
/// VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES,
///  // Provided by VK_KHR_separate_depth_stencil_layouts
///    VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT_KHR =
/// VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT,
///  // Provided by VK_KHR_separate_depth_stencil_layouts
///    VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT_KHR =
/// VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT,
///  // Provided by VK_EXT_buffer_device_address
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_ADDRESS_FEATURES_EXT =
/// VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT,
///  // Provided by VK_EXT_buffer_device_address
///    VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_EXT =
/// VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO,
///  // Provided by VK_EXT_tooling_info
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES_EXT =
/// VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES,
///  // Provided by VK_EXT_separate_stencil_usage
///    VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO_EXT =
/// VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO,
///  // Provided by VK_KHR_uniform_buffer_standard_layout
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES_KHR =
/// VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES,
///  // Provided by VK_KHR_buffer_device_address
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_KHR =
/// VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES,
///  // Provided by VK_KHR_buffer_device_address
///    VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_KHR =
/// VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO,
///  // Provided by VK_KHR_buffer_device_address
///    VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO_KHR =
/// VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO,
///  // Provided by VK_KHR_buffer_device_address
///    VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO_KHR =
/// VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO,
///  // Provided by VK_KHR_buffer_device_address
///    VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO_KHR =
/// VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO,
///  // Provided by VK_EXT_host_query_reset
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES_EXT =
/// VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES,
///  // Provided by VK_EXT_shader_demote_to_helper_invocation
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES_EXT =
/// VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES,
///  // Provided by VK_KHR_shader_integer_dot_product
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES_KHR =
/// VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES,
///  // Provided by VK_KHR_shader_integer_dot_product
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES_KHR =
/// VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES,
///  // Provided by VK_EXT_texel_buffer_alignment
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES_EXT =
/// VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES,
///  // Provided by VK_EXT_private_data
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES_EXT =
/// VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES,
///  // Provided by VK_EXT_private_data
///    VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO_EXT =
/// VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO,
///  // Provided by VK_EXT_private_data
///    VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO_EXT =
/// VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO,
///  // Provided by VK_EXT_pipeline_creation_cache_control
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES_EXT =
/// VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES,
///  // Provided by VK_KHR_synchronization2
///    VK_STRUCTURE_TYPE_MEMORY_BARRIER_2_KHR = VK_STRUCTURE_TYPE_MEMORY_BARRIER_2,
///  // Provided by VK_KHR_synchronization2
///    VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2_KHR = VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2,
///  // Provided by VK_KHR_synchronization2
///    VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2_KHR = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2,
///  // Provided by VK_KHR_synchronization2
///    VK_STRUCTURE_TYPE_DEPENDENCY_INFO_KHR = VK_STRUCTURE_TYPE_DEPENDENCY_INFO,
///  // Provided by VK_KHR_synchronization2
///    VK_STRUCTURE_TYPE_SUBMIT_INFO_2_KHR = VK_STRUCTURE_TYPE_SUBMIT_INFO_2,
///  // Provided by VK_KHR_synchronization2
///    VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO_KHR = VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO,
///  // Provided by VK_KHR_synchronization2
///    VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO_KHR =
/// VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO,
///  // Provided by VK_KHR_synchronization2
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES_KHR =
/// VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES,
///  // Provided by VK_KHR_zero_initialize_workgroup_memory
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES_KHR =
/// VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES,
///  // Provided by VK_EXT_image_robustness
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES_EXT =
/// VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES,
///  // Provided by VK_KHR_copy_commands2
///    VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2_KHR = VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2,
///  // Provided by VK_KHR_copy_commands2
///    VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2_KHR = VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2,
///  // Provided by VK_KHR_copy_commands2
///    VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2_KHR =
/// VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2,
///  // Provided by VK_KHR_copy_commands2
///    VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2_KHR =
/// VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2,
///  // Provided by VK_KHR_copy_commands2
///    VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2_KHR = VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2,
///  // Provided by VK_KHR_copy_commands2
///    VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2_KHR = VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2,
///  // Provided by VK_KHR_copy_commands2
///    VK_STRUCTURE_TYPE_BUFFER_COPY_2_KHR = VK_STRUCTURE_TYPE_BUFFER_COPY_2,
///  // Provided by VK_KHR_copy_commands2
///    VK_STRUCTURE_TYPE_IMAGE_COPY_2_KHR = VK_STRUCTURE_TYPE_IMAGE_COPY_2,
///  // Provided by VK_KHR_copy_commands2
///    VK_STRUCTURE_TYPE_IMAGE_BLIT_2_KHR = VK_STRUCTURE_TYPE_IMAGE_BLIT_2,
///  // Provided by VK_KHR_copy_commands2
///    VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2_KHR = VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2,
///  // Provided by VK_KHR_copy_commands2
///    VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2_KHR = VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2,
///  // Provided by VK_KHR_format_feature_flags2
///    VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3_KHR = VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3,
///  // Provided by VK_EXT_global_priority_query
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_EXT =
/// VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_KHR,
///  // Provided by VK_EXT_global_priority_query
///    VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_EXT =
/// VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_KHR,
///  // Provided by VK_KHR_maintenance4
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES_KHR =
/// VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES,
///  // Provided by VK_KHR_maintenance4
///    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES_KHR =
/// VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES,
///  // Provided by VK_KHR_maintenance4
///    VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS_KHR =
/// VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS,
///  // Provided by VK_KHR_maintenance4
///    VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS_KHR =
/// VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS,
///} VkStructureType;
///```
///# Related
/// - [`crate::vulkan1_0`]
/// - [`AccelerationStructureBuildGeometryInfoKHR`]
/// - [`AccelerationStructureBuildSizesInfoKHR`]
/// - [`AccelerationStructureCreateInfoKHR`]
/// - [`AccelerationStructureCreateInfoNV`]
/// - [`AccelerationStructureDeviceAddressInfoKHR`]
/// - [`AccelerationStructureGeometryAabbsDataKHR`]
/// - [`AccelerationStructureGeometryInstancesDataKHR`]
/// - [`AccelerationStructureGeometryKHR`]
/// - [`AccelerationStructureGeometryMotionTrianglesDataNV`]
/// - [`AccelerationStructureGeometryTrianglesDataKHR`]
/// - [`AccelerationStructureInfoNV`]
/// - [`AccelerationStructureMemoryRequirementsInfoNV`]
/// - [`AccelerationStructureMotionInfoNV`]
/// - [`AccelerationStructureVersionInfoKHR`]
/// - [`AcquireNextImageInfoKHR`]
/// - [`AcquireProfilingLockInfoKHR`]
/// - [`AndroidHardwareBufferFormatProperties2ANDROID`]
/// - [`AndroidHardwareBufferFormatPropertiesANDROID`]
/// - [`AndroidHardwareBufferPropertiesANDROID`]
/// - [`AndroidHardwareBufferUsageANDROID`]
/// - [`AndroidSurfaceCreateInfoKHR`]
/// - [`ApplicationInfo`]
/// - [`AttachmentDescription2`]
/// - [`AttachmentDescriptionStencilLayout`]
/// - [`AttachmentReference2`]
/// - [`AttachmentReferenceStencilLayout`]
/// - [`AttachmentSampleCountInfoAMD`]
/// - [`BaseInStructure`]
/// - [`BaseOutStructure`]
/// - [`BindAccelerationStructureMemoryInfoNV`]
/// - [`BindBufferMemoryDeviceGroupInfo`]
/// - [`BindBufferMemoryInfo`]
/// - [`BindImageMemoryDeviceGroupInfo`]
/// - [`BindImageMemoryInfo`]
/// - [`BindImageMemorySwapchainInfoKHR`]
/// - [`BindImagePlaneMemoryInfo`]
/// - [`BindSparseInfo`]
/// - [`BlitImageInfo2`]
/// - [`BufferCollectionBufferCreateInfoFUCHSIA`]
/// - [`BufferCollectionConstraintsInfoFUCHSIA`]
/// - [`BufferCollectionCreateInfoFUCHSIA`]
/// - [`BufferCollectionImageCreateInfoFUCHSIA`]
/// - [`BufferCollectionPropertiesFUCHSIA`]
/// - [`BufferConstraintsInfoFUCHSIA`]
/// - [`BufferCopy2`]
/// - [`BufferCreateInfo`]
/// - [`BufferDeviceAddressCreateInfoEXT`]
/// - [`BufferDeviceAddressInfo`]
/// - [`BufferImageCopy2`]
/// - [`BufferMemoryBarrier`]
/// - [`BufferMemoryBarrier2`]
/// - [`BufferMemoryRequirementsInfo2`]
/// - [`BufferOpaqueCaptureAddressCreateInfo`]
/// - [`BufferViewCreateInfo`]
/// - [`CalibratedTimestampInfoEXT`]
/// - [`CheckpointData2NV`]
/// - [`CheckpointDataNV`]
/// - [`CommandBufferAllocateInfo`]
/// - [`CommandBufferBeginInfo`]
/// - [`CommandBufferInheritanceConditionalRenderingInfoEXT`]
/// - [`CommandBufferInheritanceInfo`]
/// - [`CommandBufferInheritanceRenderPassTransformInfoQCOM`]
/// - [`CommandBufferInheritanceRenderingInfo`]
/// - [`CommandBufferInheritanceViewportScissorInfoNV`]
/// - [`CommandBufferSubmitInfo`]
/// - [`CommandPoolCreateInfo`]
/// - [`ComputePipelineCreateInfo`]
/// - [`ConditionalRenderingBeginInfoEXT`]
/// - [`CooperativeMatrixPropertiesNV`]
/// - [`CopyAccelerationStructureInfoKHR`]
/// - [`CopyAccelerationStructureToMemoryInfoKHR`]
/// - [`CopyBufferInfo2`]
/// - [`CopyBufferToImageInfo2`]
/// - [`CopyCommandTransformInfoQCOM`]
/// - [`CopyDescriptorSet`]
/// - [`CopyImageInfo2`]
/// - [`CopyImageToBufferInfo2`]
/// - [`CopyMemoryToAccelerationStructureInfoKHR`]
/// - [`CuFunctionCreateInfoNVX`]
/// - [`CuLaunchInfoNVX`]
/// - [`CuModuleCreateInfoNVX`]
/// - [`D3D12FenceSubmitInfoKHR`]
/// - [`DebugMarkerMarkerInfoEXT`]
/// - [`DebugMarkerObjectNameInfoEXT`]
/// - [`DebugMarkerObjectTagInfoEXT`]
/// - [`DebugReportCallbackCreateInfoEXT`]
/// - [`DebugUtilsLabelEXT`]
/// - [`DebugUtilsMessengerCallbackDataEXT`]
/// - [`DebugUtilsMessengerCreateInfoEXT`]
/// - [`DebugUtilsObjectNameInfoEXT`]
/// - [`DebugUtilsObjectTagInfoEXT`]
/// - [`DedicatedAllocationBufferCreateInfoNV`]
/// - [`DedicatedAllocationImageCreateInfoNV`]
/// - [`DedicatedAllocationMemoryAllocateInfoNV`]
/// - [`DependencyInfo`]
/// - [`DescriptorPoolCreateInfo`]
/// - [`DescriptorPoolInlineUniformBlockCreateInfo`]
/// - [`DescriptorSetAllocateInfo`]
/// - [`DescriptorSetBindingReferenceVALVE`]
/// - [`DescriptorSetLayoutBindingFlagsCreateInfo`]
/// - [`DescriptorSetLayoutCreateInfo`]
/// - [`DescriptorSetLayoutHostMappingInfoVALVE`]
/// - [`DescriptorSetLayoutSupport`]
/// - [`DescriptorSetVariableDescriptorCountAllocateInfo`]
/// - [`DescriptorSetVariableDescriptorCountLayoutSupport`]
/// - [`DescriptorUpdateTemplateCreateInfo`]
/// - [`DeviceBufferMemoryRequirements`]
/// - [`DeviceCreateInfo`]
/// - [`DeviceDeviceMemoryReportCreateInfoEXT`]
/// - [`DeviceDiagnosticsConfigCreateInfoNV`]
/// - [`DeviceEventInfoEXT`]
/// - [`DeviceGroupBindSparseInfo`]
/// - [`DeviceGroupCommandBufferBeginInfo`]
/// - [`DeviceGroupDeviceCreateInfo`]
/// - [`DeviceGroupPresentCapabilitiesKHR`]
/// - [`DeviceGroupPresentInfoKHR`]
/// - [`DeviceGroupRenderPassBeginInfo`]
/// - [`DeviceGroupSubmitInfo`]
/// - [`DeviceGroupSwapchainCreateInfoKHR`]
/// - [`DeviceImageMemoryRequirements`]
/// - [`DeviceMemoryOpaqueCaptureAddressInfo`]
/// - [`DeviceMemoryOverallocationCreateInfoAMD`]
/// - [`DeviceMemoryReportCallbackDataEXT`]
/// - [`DevicePrivateDataCreateInfo`]
/// - [`DeviceQueueCreateInfo`]
/// - [`DeviceQueueGlobalPriorityCreateInfoKHR`]
/// - [`DeviceQueueInfo2`]
/// - [`DirectFBSurfaceCreateInfoEXT`]
/// - [`DisplayEventInfoEXT`]
/// - [`DisplayModeCreateInfoKHR`]
/// - [`DisplayModeProperties2KHR`]
/// - [`DisplayNativeHdrSurfaceCapabilitiesAMD`]
/// - [`DisplayPlaneCapabilities2KHR`]
/// - [`DisplayPlaneInfo2KHR`]
/// - [`DisplayPlaneProperties2KHR`]
/// - [`DisplayPowerInfoEXT`]
/// - [`DisplayPresentInfoKHR`]
/// - [`DisplayProperties2KHR`]
/// - [`DisplaySurfaceCreateInfoKHR`]
/// - [`DrmFormatModifierPropertiesList2EXT`]
/// - [`DrmFormatModifierPropertiesListEXT`]
/// - [`EventCreateInfo`]
/// - [`ExportFenceCreateInfo`]
/// - [`ExportFenceWin32HandleInfoKHR`]
/// - [`ExportMemoryAllocateInfo`]
/// - [`ExportMemoryAllocateInfoNV`]
/// - [`ExportMemoryWin32HandleInfoKHR`]
/// - [`ExportMemoryWin32HandleInfoNV`]
/// - [`ExportSemaphoreCreateInfo`]
/// - [`ExportSemaphoreWin32HandleInfoKHR`]
/// - [`ExternalBufferProperties`]
/// - [`ExternalFenceProperties`]
/// - [`ExternalFormatANDROID`]
/// - [`ExternalImageFormatProperties`]
/// - [`ExternalMemoryBufferCreateInfo`]
/// - [`ExternalMemoryImageCreateInfo`]
/// - [`ExternalMemoryImageCreateInfoNV`]
/// - [`ExternalSemaphoreProperties`]
/// - [`FenceCreateInfo`]
/// - [`FenceGetFdInfoKHR`]
/// - [`FenceGetWin32HandleInfoKHR`]
/// - [`FilterCubicImageViewImageFormatPropertiesEXT`]
/// - [`FormatProperties2`]
/// - [`FormatProperties3`]
/// - [`FragmentShadingRateAttachmentInfoKHR`]
/// - [`FramebufferAttachmentImageInfo`]
/// - [`FramebufferAttachmentsCreateInfo`]
/// - [`FramebufferCreateInfo`]
/// - [`FramebufferMixedSamplesCombinationNV`]
/// - [`GeneratedCommandsInfoNV`]
/// - [`GeneratedCommandsMemoryRequirementsInfoNV`]
/// - [`GeometryAabbNV`]
/// - [`GeometryNV`]
/// - [`GeometryTrianglesNV`]
/// - [`GraphicsPipelineCreateInfo`]
/// - [`GraphicsPipelineShaderGroupsCreateInfoNV`]
/// - [`GraphicsShaderGroupCreateInfoNV`]
/// - [`HdrMetadataEXT`]
/// - [`HeadlessSurfaceCreateInfoEXT`]
/// - [`IosSurfaceCreateInfoMVK`]
/// - [`ImageBlit2`]
/// - [`ImageConstraintsInfoFUCHSIA`]
/// - [`ImageCopy2`]
/// - [`ImageCreateInfo`]
/// - [`ImageDrmFormatModifierExplicitCreateInfoEXT`]
/// - [`ImageDrmFormatModifierListCreateInfoEXT`]
/// - [`ImageDrmFormatModifierPropertiesEXT`]
/// - [`ImageFormatConstraintsInfoFUCHSIA`]
/// - [`ImageFormatListCreateInfo`]
/// - [`ImageFormatProperties2`]
/// - [`ImageMemoryBarrier`]
/// - [`ImageMemoryBarrier2`]
/// - [`ImageMemoryRequirementsInfo2`]
/// - [`ImagePipeSurfaceCreateInfoFUCHSIA`]
/// - [`ImagePlaneMemoryRequirementsInfo`]
/// - [`ImageResolve2`]
/// - [`ImageSparseMemoryRequirementsInfo2`]
/// - [`ImageStencilUsageCreateInfo`]
/// - [`ImageSwapchainCreateInfoKHR`]
/// - [`ImageViewAstcDecodeModeEXT`]
/// - [`ImageViewAddressPropertiesNVX`]
/// - [`ImageViewCreateInfo`]
/// - [`ImageViewHandleInfoNVX`]
/// - [`ImageViewMinLodCreateInfoEXT`]
/// - [`ImageViewUsageCreateInfo`]
/// - [`ImportAndroidHardwareBufferInfoANDROID`]
/// - [`ImportFenceFdInfoKHR`]
/// - [`ImportFenceWin32HandleInfoKHR`]
/// - [`ImportMemoryBufferCollectionFUCHSIA`]
/// - [`ImportMemoryFdInfoKHR`]
/// - [`ImportMemoryHostPointerInfoEXT`]
/// - [`ImportMemoryWin32HandleInfoKHR`]
/// - [`ImportMemoryWin32HandleInfoNV`]
/// - [`ImportMemoryZirconHandleInfoFUCHSIA`]
/// - [`ImportSemaphoreFdInfoKHR`]
/// - [`ImportSemaphoreWin32HandleInfoKHR`]
/// - [`ImportSemaphoreZirconHandleInfoFUCHSIA`]
/// - [`IndirectCommandsLayoutCreateInfoNV`]
/// - [`IndirectCommandsLayoutTokenNV`]
/// - [`InitializePerformanceApiInfoINTEL`]
/// - [`InstanceCreateInfo`]
/// - [`MacOsSurfaceCreateInfoMVK`]
/// - [`MappedMemoryRange`]
/// - [`MemoryAllocateFlagsInfo`]
/// - [`MemoryAllocateInfo`]
/// - [`MemoryBarrier`]
/// - [`MemoryBarrier2`]
/// - [`MemoryDedicatedAllocateInfo`]
/// - [`MemoryDedicatedRequirements`]
/// - [`MemoryFdPropertiesKHR`]
/// - [`MemoryGetAndroidHardwareBufferInfoANDROID`]
/// - [`MemoryGetFdInfoKHR`]
/// - [`MemoryGetRemoteAddressInfoNV`]
/// - [`MemoryGetWin32HandleInfoKHR`]
/// - [`MemoryGetZirconHandleInfoFUCHSIA`]
/// - [`MemoryHostPointerPropertiesEXT`]
/// - [`MemoryOpaqueCaptureAddressAllocateInfo`]
/// - [`MemoryPriorityAllocateInfoEXT`]
/// - [`MemoryRequirements2`]
/// - [`MemoryWin32HandlePropertiesKHR`]
/// - [`MemoryZirconHandlePropertiesFUCHSIA`]
/// - [`MetalSurfaceCreateInfoEXT`]
/// - [`MultisamplePropertiesEXT`]
/// - [`MultiviewPerViewAttributesInfoNVX`]
/// - [`MutableDescriptorTypeCreateInfoVALVE`]
/// - [`PerformanceConfigurationAcquireInfoINTEL`]
/// - [`PerformanceCounterDescriptionKHR`]
/// - [`PerformanceCounterKHR`]
/// - [`PerformanceMarkerInfoINTEL`]
/// - [`PerformanceOverrideInfoINTEL`]
/// - [`PerformanceQuerySubmitInfoKHR`]
/// - [`PerformanceStreamMarkerInfoINTEL`]
/// - [`PhysicalDevice16BitStorageFeatures`]
/// - [`PhysicalDevice4444FormatsFeaturesEXT`]
/// - [`PhysicalDevice8BitStorageFeatures`]
/// - [`PhysicalDeviceAstcDecodeFeaturesEXT`]
/// - [`PhysicalDeviceAccelerationStructureFeaturesKHR`]
/// - [`PhysicalDeviceAccelerationStructurePropertiesKHR`]
/// - [`PhysicalDeviceBlendOperationAdvancedFeaturesEXT`]
/// - [`PhysicalDeviceBlendOperationAdvancedPropertiesEXT`]
/// - [`PhysicalDeviceBorderColorSwizzleFeaturesEXT`]
/// - [`PhysicalDeviceBufferDeviceAddressFeatures`]
/// - [`PhysicalDeviceBufferDeviceAddressFeaturesEXT`]
/// - [`PhysicalDeviceCoherentMemoryFeaturesAMD`]
/// - [`PhysicalDeviceColorWriteEnableFeaturesEXT`]
/// - [`PhysicalDeviceComputeShaderDerivativesFeaturesNV`]
/// - [`PhysicalDeviceConditionalRenderingFeaturesEXT`]
/// - [`PhysicalDeviceConservativeRasterizationPropertiesEXT`]
/// - [`PhysicalDeviceCooperativeMatrixFeaturesNV`]
/// - [`PhysicalDeviceCooperativeMatrixPropertiesNV`]
/// - [`PhysicalDeviceCornerSampledImageFeaturesNV`]
/// - [`PhysicalDeviceCoverageReductionModeFeaturesNV`]
/// - [`PhysicalDeviceCustomBorderColorFeaturesEXT`]
/// - [`PhysicalDeviceCustomBorderColorPropertiesEXT`]
/// - [`PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV`]
/// - [`PhysicalDeviceDepthClipControlFeaturesEXT`]
/// - [`PhysicalDeviceDepthClipEnableFeaturesEXT`]
/// - [`PhysicalDeviceDepthStencilResolveProperties`]
/// - [`PhysicalDeviceDescriptorIndexingFeatures`]
/// - [`PhysicalDeviceDescriptorIndexingProperties`]
/// - [`PhysicalDeviceDescriptorSetHostMappingFeaturesVALVE`]
/// - [`PhysicalDeviceDeviceGeneratedCommandsFeaturesNV`]
/// - [`PhysicalDeviceDeviceGeneratedCommandsPropertiesNV`]
/// - [`PhysicalDeviceDeviceMemoryReportFeaturesEXT`]
/// - [`PhysicalDeviceDiagnosticsConfigFeaturesNV`]
/// - [`PhysicalDeviceDiscardRectanglePropertiesEXT`]
/// - [`PhysicalDeviceDriverProperties`]
/// - [`PhysicalDeviceDrmPropertiesEXT`]
/// - [`PhysicalDeviceDynamicRenderingFeatures`]
/// - [`PhysicalDeviceExclusiveScissorFeaturesNV`]
/// - [`PhysicalDeviceExtendedDynamicState2FeaturesEXT`]
/// - [`PhysicalDeviceExtendedDynamicStateFeaturesEXT`]
/// - [`PhysicalDeviceExternalBufferInfo`]
/// - [`PhysicalDeviceExternalFenceInfo`]
/// - [`PhysicalDeviceExternalImageFormatInfo`]
/// - [`PhysicalDeviceExternalMemoryHostPropertiesEXT`]
/// - [`PhysicalDeviceExternalMemoryRdmaFeaturesNV`]
/// - [`PhysicalDeviceExternalSemaphoreInfo`]
/// - [`PhysicalDeviceFeatures2`]
/// - [`PhysicalDeviceFloatControlsProperties`]
/// - [`PhysicalDeviceFragmentDensityMap2FeaturesEXT`]
/// - [`PhysicalDeviceFragmentDensityMap2PropertiesEXT`]
/// - [`PhysicalDeviceFragmentDensityMapFeaturesEXT`]
/// - [`PhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM`]
/// - [`PhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM`]
/// - [`PhysicalDeviceFragmentDensityMapPropertiesEXT`]
/// - [`PhysicalDeviceFragmentShaderBarycentricFeaturesNV`]
/// - [`PhysicalDeviceFragmentShaderInterlockFeaturesEXT`]
/// - [`PhysicalDeviceFragmentShadingRateEnumsFeaturesNV`]
/// - [`PhysicalDeviceFragmentShadingRateEnumsPropertiesNV`]
/// - [`PhysicalDeviceFragmentShadingRateFeaturesKHR`]
/// - [`PhysicalDeviceFragmentShadingRateKHR`]
/// - [`PhysicalDeviceFragmentShadingRatePropertiesKHR`]
/// - [`PhysicalDeviceGlobalPriorityQueryFeaturesKHR`]
/// - [`PhysicalDeviceGroupProperties`]
/// - [`PhysicalDeviceHostQueryResetFeatures`]
/// - [`PhysicalDeviceIdProperties`]
/// - [`PhysicalDeviceImageDrmFormatModifierInfoEXT`]
/// - [`PhysicalDeviceImageFormatInfo2`]
/// - [`PhysicalDeviceImageRobustnessFeatures`]
/// - [`PhysicalDeviceImageViewImageFormatInfoEXT`]
/// - [`PhysicalDeviceImageViewMinLodFeaturesEXT`]
/// - [`PhysicalDeviceImagelessFramebufferFeatures`]
/// - [`PhysicalDeviceIndexTypeUint8FeaturesEXT`]
/// - [`PhysicalDeviceInheritedViewportScissorFeaturesNV`]
/// - [`PhysicalDeviceInlineUniformBlockFeatures`]
/// - [`PhysicalDeviceInlineUniformBlockProperties`]
/// - [`PhysicalDeviceInvocationMaskFeaturesHUAWEI`]
/// - [`PhysicalDeviceLineRasterizationFeaturesEXT`]
/// - [`PhysicalDeviceLineRasterizationPropertiesEXT`]
/// - [`PhysicalDeviceLinearColorAttachmentFeaturesNV`]
/// - [`PhysicalDeviceMaintenance3Properties`]
/// - [`PhysicalDeviceMaintenance4Features`]
/// - [`PhysicalDeviceMaintenance4Properties`]
/// - [`PhysicalDeviceMemoryBudgetPropertiesEXT`]
/// - [`PhysicalDeviceMemoryPriorityFeaturesEXT`]
/// - [`PhysicalDeviceMemoryProperties2`]
/// - [`PhysicalDeviceMeshShaderFeaturesNV`]
/// - [`PhysicalDeviceMeshShaderPropertiesNV`]
/// - [`PhysicalDeviceMultiDrawFeaturesEXT`]
/// - [`PhysicalDeviceMultiDrawPropertiesEXT`]
/// - [`PhysicalDeviceMultiviewFeatures`]
/// - [`PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX`]
/// - [`PhysicalDeviceMultiviewProperties`]
/// - [`PhysicalDeviceMutableDescriptorTypeFeaturesVALVE`]
/// - [`PhysicalDevicePciBusInfoPropertiesEXT`]
/// - [`PhysicalDevicePageableDeviceLocalMemoryFeaturesEXT`]
/// - [`PhysicalDevicePerformanceQueryFeaturesKHR`]
/// - [`PhysicalDevicePerformanceQueryPropertiesKHR`]
/// - [`PhysicalDevicePipelineCreationCacheControlFeatures`]
/// - [`PhysicalDevicePipelineExecutablePropertiesFeaturesKHR`]
/// - [`PhysicalDevicePointClippingProperties`]
/// - [`PhysicalDevicePortabilitySubsetFeaturesKHR`]
/// - [`PhysicalDevicePortabilitySubsetPropertiesKHR`]
/// - [`PhysicalDevicePresentIdFeaturesKHR`]
/// - [`PhysicalDevicePresentWaitFeaturesKHR`]
/// - [`PhysicalDevicePrimitiveTopologyListRestartFeaturesEXT`]
/// - [`PhysicalDevicePrivateDataFeatures`]
/// - [`PhysicalDeviceProperties2`]
/// - [`PhysicalDeviceProtectedMemoryFeatures`]
/// - [`PhysicalDeviceProtectedMemoryProperties`]
/// - [`PhysicalDeviceProvokingVertexFeaturesEXT`]
/// - [`PhysicalDeviceProvokingVertexPropertiesEXT`]
/// - [`PhysicalDevicePushDescriptorPropertiesKHR`]
/// - [`PhysicalDeviceRgba10X6FormatsFeaturesEXT`]
/// - [`PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesARM`]
/// - [`PhysicalDeviceRayQueryFeaturesKHR`]
/// - [`PhysicalDeviceRayTracingMotionBlurFeaturesNV`]
/// - [`PhysicalDeviceRayTracingPipelineFeaturesKHR`]
/// - [`PhysicalDeviceRayTracingPipelinePropertiesKHR`]
/// - [`PhysicalDeviceRayTracingPropertiesNV`]
/// - [`PhysicalDeviceRepresentativeFragmentTestFeaturesNV`]
/// - [`PhysicalDeviceRobustness2FeaturesEXT`]
/// - [`PhysicalDeviceRobustness2PropertiesEXT`]
/// - [`PhysicalDeviceSampleLocationsPropertiesEXT`]
/// - [`PhysicalDeviceSamplerFilterMinmaxProperties`]
/// - [`PhysicalDeviceSamplerYcbcrConversionFeatures`]
/// - [`PhysicalDeviceScalarBlockLayoutFeatures`]
/// - [`PhysicalDeviceSeparateDepthStencilLayoutsFeatures`]
/// - [`PhysicalDeviceShaderAtomicFloat2FeaturesEXT`]
/// - [`PhysicalDeviceShaderAtomicFloatFeaturesEXT`]
/// - [`PhysicalDeviceShaderAtomicInt64Features`]
/// - [`PhysicalDeviceShaderClockFeaturesKHR`]
/// - [`PhysicalDeviceShaderCoreProperties2AMD`]
/// - [`PhysicalDeviceShaderCorePropertiesAMD`]
/// - [`PhysicalDeviceShaderDemoteToHelperInvocationFeatures`]
/// - [`PhysicalDeviceShaderDrawParametersFeatures`]
/// - [`PhysicalDeviceShaderFloat16Int8Features`]
/// - [`PhysicalDeviceShaderImageAtomicInt64FeaturesEXT`]
/// - [`PhysicalDeviceShaderImageFootprintFeaturesNV`]
/// - [`PhysicalDeviceShaderIntegerDotProductFeatures`]
/// - [`PhysicalDeviceShaderIntegerDotProductProperties`]
/// - [`PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL`]
/// - [`PhysicalDeviceShaderSmBuiltinsFeaturesNV`]
/// - [`PhysicalDeviceShaderSmBuiltinsPropertiesNV`]
/// - [`PhysicalDeviceShaderSubgroupExtendedTypesFeatures`]
/// - [`PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR`]
/// - [`PhysicalDeviceShaderTerminateInvocationFeatures`]
/// - [`PhysicalDeviceShadingRateImageFeaturesNV`]
/// - [`PhysicalDeviceShadingRateImagePropertiesNV`]
/// - [`PhysicalDeviceSparseImageFormatInfo2`]
/// - [`PhysicalDeviceSubgroupProperties`]
/// - [`PhysicalDeviceSubgroupSizeControlFeatures`]
/// - [`PhysicalDeviceSubgroupSizeControlProperties`]
/// - [`PhysicalDeviceSubpassShadingFeaturesHUAWEI`]
/// - [`PhysicalDeviceSubpassShadingPropertiesHUAWEI`]
/// - [`PhysicalDeviceSurfaceInfo2KHR`]
/// - [`PhysicalDeviceSynchronization2Features`]
/// - [`PhysicalDeviceTexelBufferAlignmentFeaturesEXT`]
/// - [`PhysicalDeviceTexelBufferAlignmentProperties`]
/// - [`PhysicalDeviceTextureCompressionAstchdrFeatures`]
/// - [`PhysicalDeviceTimelineSemaphoreFeatures`]
/// - [`PhysicalDeviceTimelineSemaphoreProperties`]
/// - [`PhysicalDeviceToolProperties`]
/// - [`PhysicalDeviceTransformFeedbackFeaturesEXT`]
/// - [`PhysicalDeviceTransformFeedbackPropertiesEXT`]
/// - [`PhysicalDeviceUniformBufferStandardLayoutFeatures`]
/// - [`PhysicalDeviceVariablePointersFeatures`]
/// - [`PhysicalDeviceVertexAttributeDivisorFeaturesEXT`]
/// - [`PhysicalDeviceVertexAttributeDivisorPropertiesEXT`]
/// - [`PhysicalDeviceVertexInputDynamicStateFeaturesEXT`]
/// - [`PhysicalDeviceVideoFormatInfoKHR`]
/// - [`PhysicalDeviceVulkan11Features`]
/// - [`PhysicalDeviceVulkan11Properties`]
/// - [`PhysicalDeviceVulkan12Features`]
/// - [`PhysicalDeviceVulkan12Properties`]
/// - [`PhysicalDeviceVulkan13Features`]
/// - [`PhysicalDeviceVulkan13Properties`]
/// - [`PhysicalDeviceVulkanMemoryModelFeatures`]
/// - [`PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR`]
/// - [`PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT`]
/// - [`PhysicalDeviceYcbcrImageArraysFeaturesEXT`]
/// - [`PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures`]
/// - [`PipelineCacheCreateInfo`]
/// - [`PipelineColorBlendAdvancedStateCreateInfoEXT`]
/// - [`PipelineColorBlendStateCreateInfo`]
/// - [`PipelineColorWriteCreateInfoEXT`]
/// - [`PipelineCompilerControlCreateInfoAMD`]
/// - [`PipelineCoverageModulationStateCreateInfoNV`]
/// - [`PipelineCoverageReductionStateCreateInfoNV`]
/// - [`PipelineCoverageToColorStateCreateInfoNV`]
/// - [`PipelineCreationFeedbackCreateInfo`]
/// - [`PipelineDepthStencilStateCreateInfo`]
/// - [`PipelineDiscardRectangleStateCreateInfoEXT`]
/// - [`PipelineDynamicStateCreateInfo`]
/// - [`PipelineExecutableInfoKHR`]
/// - [`PipelineExecutableInternalRepresentationKHR`]
/// - [`PipelineExecutablePropertiesKHR`]
/// - [`PipelineExecutableStatisticKHR`]
/// - [`PipelineFragmentShadingRateEnumStateCreateInfoNV`]
/// - [`PipelineFragmentShadingRateStateCreateInfoKHR`]
/// - [`PipelineInfoKHR`]
/// - [`PipelineInputAssemblyStateCreateInfo`]
/// - [`PipelineLayoutCreateInfo`]
/// - [`PipelineLibraryCreateInfoKHR`]
/// - [`PipelineMultisampleStateCreateInfo`]
/// - [`PipelineRasterizationConservativeStateCreateInfoEXT`]
/// - [`PipelineRasterizationDepthClipStateCreateInfoEXT`]
/// - [`PipelineRasterizationLineStateCreateInfoEXT`]
/// - [`PipelineRasterizationProvokingVertexStateCreateInfoEXT`]
/// - [`PipelineRasterizationStateCreateInfo`]
/// - [`PipelineRasterizationStateRasterizationOrderAMD`]
/// - [`PipelineRasterizationStateStreamCreateInfoEXT`]
/// - [`PipelineRenderingCreateInfo`]
/// - [`PipelineRepresentativeFragmentTestStateCreateInfoNV`]
/// - [`PipelineSampleLocationsStateCreateInfoEXT`]
/// - [`PipelineShaderStageCreateInfo`]
/// - [`PipelineShaderStageRequiredSubgroupSizeCreateInfo`]
/// - [`PipelineTessellationDomainOriginStateCreateInfo`]
/// - [`PipelineTessellationStateCreateInfo`]
/// - [`PipelineVertexInputDivisorStateCreateInfoEXT`]
/// - [`PipelineVertexInputStateCreateInfo`]
/// - [`PipelineViewportCoarseSampleOrderStateCreateInfoNV`]
/// - [`PipelineViewportDepthClipControlCreateInfoEXT`]
/// - [`PipelineViewportExclusiveScissorStateCreateInfoNV`]
/// - [`PipelineViewportShadingRateImageStateCreateInfoNV`]
/// - [`PipelineViewportStateCreateInfo`]
/// - [`PipelineViewportSwizzleStateCreateInfoNV`]
/// - [`PipelineViewportWScalingStateCreateInfoNV`]
/// - [`PresentFrameTokenGGP`]
/// - [`PresentIdKHR`]
/// - [`PresentInfoKHR`]
/// - [`PresentRegionsKHR`]
/// - [`PresentTimesInfoGOOGLE`]
/// - [`PrivateDataSlotCreateInfo`]
/// - [`ProtectedSubmitInfo`]
/// - [`QueryPoolCreateInfo`]
/// - [`QueryPoolPerformanceCreateInfoKHR`]
/// - [`QueryPoolPerformanceQueryCreateInfoINTEL`]
/// - [`QueueFamilyCheckpointProperties2NV`]
/// - [`QueueFamilyCheckpointPropertiesNV`]
/// - [`QueueFamilyGlobalPriorityPropertiesKHR`]
/// - [`QueueFamilyProperties2`]
/// - [`QueueFamilyQueryResultStatusProperties2KHR`]
/// - [`RayTracingPipelineCreateInfoKHR`]
/// - [`RayTracingPipelineCreateInfoNV`]
/// - [`RayTracingPipelineInterfaceCreateInfoKHR`]
/// - [`RayTracingShaderGroupCreateInfoKHR`]
/// - [`RayTracingShaderGroupCreateInfoNV`]
/// - [`RenderPassAttachmentBeginInfo`]
/// - [`RenderPassBeginInfo`]
/// - [`RenderPassCreateInfo`]
/// - [`RenderPassCreateInfo2`]
/// - [`RenderPassFragmentDensityMapCreateInfoEXT`]
/// - [`RenderPassInputAttachmentAspectCreateInfo`]
/// - [`RenderPassMultiviewCreateInfo`]
/// - [`RenderPassSampleLocationsBeginInfoEXT`]
/// - [`RenderPassTransformBeginInfoQCOM`]
/// - [`RenderingAttachmentInfo`]
/// - [`RenderingFragmentDensityMapAttachmentInfoEXT`]
/// - [`RenderingFragmentShadingRateAttachmentInfoKHR`]
/// - [`RenderingInfo`]
/// - [`ResolveImageInfo2`]
/// - [`SampleLocationsInfoEXT`]
/// - [`SamplerBorderColorComponentMappingCreateInfoEXT`]
/// - [`SamplerCreateInfo`]
/// - [`SamplerCustomBorderColorCreateInfoEXT`]
/// - [`SamplerReductionModeCreateInfo`]
/// - [`SamplerYcbcrConversionCreateInfo`]
/// - [`SamplerYcbcrConversionImageFormatProperties`]
/// - [`SamplerYcbcrConversionInfo`]
/// - [`ScreenSurfaceCreateInfoQNX`]
/// - [`SemaphoreCreateInfo`]
/// - [`SemaphoreGetFdInfoKHR`]
/// - [`SemaphoreGetWin32HandleInfoKHR`]
/// - [`SemaphoreGetZirconHandleInfoFUCHSIA`]
/// - [`SemaphoreSignalInfo`]
/// - [`SemaphoreSubmitInfo`]
/// - [`SemaphoreTypeCreateInfo`]
/// - [`SemaphoreWaitInfo`]
/// - [`ShaderModuleCreateInfo`]
/// - [`ShaderModuleValidationCacheCreateInfoEXT`]
/// - [`SharedPresentSurfaceCapabilitiesKHR`]
/// - [`SparseImageFormatProperties2`]
/// - [`SparseImageMemoryRequirements2`]
/// - [`StreamDescriptorSurfaceCreateInfoGGP`]
/// - [`SubmitInfo`]
/// - [`SubmitInfo2`]
/// - [`SubpassBeginInfo`]
/// - [`SubpassDependency2`]
/// - [`SubpassDescription2`]
/// - [`SubpassDescriptionDepthStencilResolve`]
/// - [`SubpassEndInfo`]
/// - [`SubpassFragmentDensityMapOffsetEndInfoQCOM`]
/// - [`SubpassShadingPipelineCreateInfoHUAWEI`]
/// - [`SurfaceCapabilities2EXT`]
/// - [`SurfaceCapabilities2KHR`]
/// - [`SurfaceCapabilitiesFullScreenExclusiveEXT`]
/// - [`SurfaceFormat2KHR`]
/// - [`SurfaceFullScreenExclusiveInfoEXT`]
/// - [`SurfaceFullScreenExclusiveWin32InfoEXT`]
/// - [`SurfaceProtectedCapabilitiesKHR`]
/// - [`SwapchainCounterCreateInfoEXT`]
/// - [`SwapchainCreateInfoKHR`]
/// - [`SwapchainDisplayNativeHdrCreateInfoAMD`]
/// - [`SysmemColorSpaceFUCHSIA`]
/// - [`TextureLodGatherFormatPropertiesAMD`]
/// - [`TimelineSemaphoreSubmitInfo`]
/// - [`ValidationCacheCreateInfoEXT`]
/// - [`ValidationFeaturesEXT`]
/// - [`ValidationFlagsEXT`]
/// - [`VertexInputAttributeDescription2EXT`]
/// - [`VertexInputBindingDescription2EXT`]
/// - [`ViSurfaceCreateInfoNN`]
/// - [`VideoBeginCodingInfoKHR`]
/// - [`VideoBindMemoryKHR`]
/// - [`VideoCapabilitiesKHR`]
/// - [`VideoCodingControlInfoKHR`]
/// - [`VideoDecodeCapabilitiesKHR`]
/// - [`VideoDecodeH264CapabilitiesEXT`]
/// - [`VideoDecodeH264DpbSlotInfoEXT`]
/// - [`VideoDecodeH264MvcEXT`]
/// - [`VideoDecodeH264PictureInfoEXT`]
/// - [`VideoDecodeH264ProfileEXT`]
/// - [`VideoDecodeH264SessionCreateInfoEXT`]
/// - [`VideoDecodeH264SessionParametersAddInfoEXT`]
/// - [`VideoDecodeH264SessionParametersCreateInfoEXT`]
/// - [`VideoDecodeH265CapabilitiesEXT`]
/// - [`VideoDecodeH265DpbSlotInfoEXT`]
/// - [`VideoDecodeH265PictureInfoEXT`]
/// - [`VideoDecodeH265ProfileEXT`]
/// - [`VideoDecodeH265SessionCreateInfoEXT`]
/// - [`VideoDecodeH265SessionParametersAddInfoEXT`]
/// - [`VideoDecodeH265SessionParametersCreateInfoEXT`]
/// - [`VideoDecodeInfoKHR`]
/// - [`VideoEncodeCapabilitiesKHR`]
/// - [`VideoEncodeH264CapabilitiesEXT`]
/// - [`VideoEncodeH264DpbSlotInfoEXT`]
/// - [`VideoEncodeH264EmitPictureParametersEXT`]
/// - [`VideoEncodeH264NaluSliceEXT`]
/// - [`VideoEncodeH264ProfileEXT`]
/// - [`VideoEncodeH264RateControlInfoEXT`]
/// - [`VideoEncodeH264RateControlLayerInfoEXT`]
/// - [`VideoEncodeH264ReferenceListsEXT`]
/// - [`VideoEncodeH264SessionCreateInfoEXT`]
/// - [`VideoEncodeH264SessionParametersAddInfoEXT`]
/// - [`VideoEncodeH264SessionParametersCreateInfoEXT`]
/// - [`VideoEncodeH264VclFrameInfoEXT`]
/// - [`VideoEncodeH265CapabilitiesEXT`]
/// - [`VideoEncodeH265DpbSlotInfoEXT`]
/// - [`VideoEncodeH265EmitPictureParametersEXT`]
/// - [`VideoEncodeH265NaluSliceSegmentEXT`]
/// - [`VideoEncodeH265ProfileEXT`]
/// - [`VideoEncodeH265RateControlInfoEXT`]
/// - [`VideoEncodeH265RateControlLayerInfoEXT`]
/// - [`VideoEncodeH265ReferenceListsEXT`]
/// - [`VideoEncodeH265SessionCreateInfoEXT`]
/// - [`VideoEncodeH265SessionParametersAddInfoEXT`]
/// - [`VideoEncodeH265SessionParametersCreateInfoEXT`]
/// - [`VideoEncodeH265VclFrameInfoEXT`]
/// - [`VideoEncodeInfoKHR`]
/// - [`VideoEncodeRateControlInfoKHR`]
/// - [`VideoEncodeRateControlLayerInfoKHR`]
/// - [`VideoEndCodingInfoKHR`]
/// - [`VideoFormatPropertiesKHR`]
/// - [`VideoGetMemoryPropertiesKHR`]
/// - [`VideoPictureResourceKHR`]
/// - [`VideoProfileKHR`]
/// - [`VideoProfilesKHR`]
/// - [`VideoQueueFamilyProperties2KHR`]
/// - [`VideoReferenceSlotKHR`]
/// - [`VideoSessionCreateInfoKHR`]
/// - [`VideoSessionParametersCreateInfoKHR`]
/// - [`VideoSessionParametersUpdateInfoKHR`]
/// - [`WaylandSurfaceCreateInfoKHR`]
/// - [`Win32KeyedMutexAcquireReleaseInfoKHR`]
/// - [`Win32KeyedMutexAcquireReleaseInfoNV`]
/// - [`Win32SurfaceCreateInfoKHR`]
/// - [`WriteDescriptorSet`]
/// - [`WriteDescriptorSetAccelerationStructureKHR`]
/// - [`WriteDescriptorSetAccelerationStructureNV`]
/// - [`WriteDescriptorSetInlineUniformBlock`]
/// - [`XcbSurfaceCreateInfoKHR`]
/// - [`XlibSurfaceCreateInfoKHR`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkStructureType")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
#[repr(i32)]
pub enum StructureType {
    ///No documentation found
    ApplicationInfo = 0,
    ///No documentation found
    InstanceCreateInfo = 1,
    ///No documentation found
    DeviceQueueCreateInfo = 2,
    ///No documentation found
    DeviceCreateInfo = 3,
    ///No documentation found
    SubmitInfo = 4,
    ///No documentation found
    MemoryAllocateInfo = 5,
    ///No documentation found
    MappedMemoryRange = 6,
    ///No documentation found
    BindSparseInfo = 7,
    ///No documentation found
    FenceCreateInfo = 8,
    ///No documentation found
    SemaphoreCreateInfo = 9,
    ///No documentation found
    EventCreateInfo = 10,
    ///No documentation found
    QueryPoolCreateInfo = 11,
    ///No documentation found
    BufferCreateInfo = 12,
    ///No documentation found
    BufferViewCreateInfo = 13,
    ///No documentation found
    ImageCreateInfo = 14,
    ///No documentation found
    ImageViewCreateInfo = 15,
    ///No documentation found
    ShaderModuleCreateInfo = 16,
    ///No documentation found
    PipelineCacheCreateInfo = 17,
    ///No documentation found
    PipelineShaderStageCreateInfo = 18,
    ///No documentation found
    PipelineVertexInputStateCreateInfo = 19,
    ///No documentation found
    PipelineInputAssemblyStateCreateInfo = 20,
    ///No documentation found
    PipelineTessellationStateCreateInfo = 21,
    ///No documentation found
    PipelineViewportStateCreateInfo = 22,
    ///No documentation found
    PipelineRasterizationStateCreateInfo = 23,
    ///No documentation found
    PipelineMultisampleStateCreateInfo = 24,
    ///No documentation found
    PipelineDepthStencilStateCreateInfo = 25,
    ///No documentation found
    PipelineColorBlendStateCreateInfo = 26,
    ///No documentation found
    PipelineDynamicStateCreateInfo = 27,
    ///No documentation found
    GraphicsPipelineCreateInfo = 28,
    ///No documentation found
    ComputePipelineCreateInfo = 29,
    ///No documentation found
    PipelineLayoutCreateInfo = 30,
    ///No documentation found
    SamplerCreateInfo = 31,
    ///No documentation found
    DescriptorSetLayoutCreateInfo = 32,
    ///No documentation found
    DescriptorPoolCreateInfo = 33,
    ///No documentation found
    DescriptorSetAllocateInfo = 34,
    ///No documentation found
    WriteDescriptorSet = 35,
    ///No documentation found
    CopyDescriptorSet = 36,
    ///No documentation found
    FramebufferCreateInfo = 37,
    ///No documentation found
    RenderPassCreateInfo = 38,
    ///No documentation found
    CommandPoolCreateInfo = 39,
    ///No documentation found
    CommandBufferAllocateInfo = 40,
    ///No documentation found
    CommandBufferInheritanceInfo = 41,
    ///No documentation found
    CommandBufferBeginInfo = 42,
    ///No documentation found
    RenderPassBeginInfo = 43,
    ///No documentation found
    BufferMemoryBarrier = 44,
    ///No documentation found
    ImageMemoryBarrier = 45,
    ///No documentation found
    MemoryBarrier = 46,
    ///No documentation found
    LoaderInstanceCreateInfo = 47,
    ///No documentation found
    LoaderDeviceCreateInfo = 48,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_1`]
    PhysicalDeviceSubgroupProperties = 1000094000,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_1`]
    BindBufferMemoryInfo = 1000157000,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_1`]
    BindImageMemoryInfo = 1000157001,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_1`]
    PhysicalDevice16BitStorageFeatures = 1000083000,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_1`]
    MemoryDedicatedRequirements = 1000127000,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_1`]
    MemoryDedicatedAllocateInfo = 1000127001,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_1`]
    MemoryAllocateFlagsInfo = 1000060000,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_1`]
    DeviceGroupRenderPassBeginInfo = 1000060003,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_1`]
    DeviceGroupCommandBufferBeginInfo = 1000060004,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_1`]
    DeviceGroupSubmitInfo = 1000060005,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_1`]
    DeviceGroupBindSparseInfo = 1000060006,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_1`]
    BindBufferMemoryDeviceGroupInfo = 1000060013,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_1`]
    BindImageMemoryDeviceGroupInfo = 1000060014,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_1`]
    PhysicalDeviceGroupProperties = 1000070000,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_1`]
    DeviceGroupDeviceCreateInfo = 1000070001,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_1`]
    BufferMemoryRequirementsInfo2 = 1000146000,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_1`]
    ImageMemoryRequirementsInfo2 = 1000146001,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_1`]
    ImageSparseMemoryRequirementsInfo2 = 1000146002,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_1`]
    MemoryRequirements2 = 1000146003,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_1`]
    SparseImageMemoryRequirements2 = 1000146004,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_1`]
    PhysicalDeviceFeatures2 = 1000059000,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_1`]
    PhysicalDeviceProperties2 = 1000059001,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_1`]
    FormatProperties2 = 1000059002,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_1`]
    ImageFormatProperties2 = 1000059003,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_1`]
    PhysicalDeviceImageFormatInfo2 = 1000059004,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_1`]
    QueueFamilyProperties2 = 1000059005,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_1`]
    PhysicalDeviceMemoryProperties2 = 1000059006,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_1`]
    SparseImageFormatProperties2 = 1000059007,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_1`]
    PhysicalDeviceSparseImageFormatInfo2 = 1000059008,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_1`]
    PhysicalDevicePointClippingProperties = 1000117000,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_1`]
    RenderPassInputAttachmentAspectCreateInfo = 1000117001,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_1`]
    ImageViewUsageCreateInfo = 1000117002,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_1`]
    PipelineTessellationDomainOriginStateCreateInfo = 1000117003,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_1`]
    RenderPassMultiviewCreateInfo = 1000053000,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_1`]
    PhysicalDeviceMultiviewFeatures = 1000053001,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_1`]
    PhysicalDeviceMultiviewProperties = 1000053002,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_1`]
    PhysicalDeviceVariablePointersFeatures = 1000120000,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_1`]
    ProtectedSubmitInfo = 1000145000,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_1`]
    PhysicalDeviceProtectedMemoryFeatures = 1000145001,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_1`]
    PhysicalDeviceProtectedMemoryProperties = 1000145002,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_1`]
    DeviceQueueInfo2 = 1000145003,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_1`]
    SamplerYcbcrConversionCreateInfo = 1000156000,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_1`]
    SamplerYcbcrConversionInfo = 1000156001,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_1`]
    BindImagePlaneMemoryInfo = 1000156002,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_1`]
    ImagePlaneMemoryRequirementsInfo = 1000156003,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_1`]
    PhysicalDeviceSamplerYcbcrConversionFeatures = 1000156004,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_1`]
    SamplerYcbcrConversionImageFormatProperties = 1000156005,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_1`]
    DescriptorUpdateTemplateCreateInfo = 1000085000,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_1`]
    PhysicalDeviceExternalImageFormatInfo = 1000071000,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_1`]
    ExternalImageFormatProperties = 1000071001,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_1`]
    PhysicalDeviceExternalBufferInfo = 1000071002,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_1`]
    ExternalBufferProperties = 1000071003,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_1`]
    PhysicalDeviceIdProperties = 1000071004,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_1`]
    ExternalMemoryBufferCreateInfo = 1000072000,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_1`]
    ExternalMemoryImageCreateInfo = 1000072001,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_1`]
    ExportMemoryAllocateInfo = 1000072002,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_1`]
    PhysicalDeviceExternalFenceInfo = 1000112000,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_1`]
    ExternalFenceProperties = 1000112001,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_1`]
    ExportFenceCreateInfo = 1000113000,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_1`]
    ExportSemaphoreCreateInfo = 1000077000,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_1`]
    PhysicalDeviceExternalSemaphoreInfo = 1000076000,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_1`]
    ExternalSemaphoreProperties = 1000076001,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_1`]
    PhysicalDeviceMaintenance3Properties = 1000168000,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_1`]
    DescriptorSetLayoutSupport = 1000168001,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_1`]
    PhysicalDeviceShaderDrawParametersFeatures = 1000063000,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_2`]
    PhysicalDeviceVulkan11Features = 49,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_2`]
    PhysicalDeviceVulkan11Properties = 50,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_2`]
    PhysicalDeviceVulkan12Features = 51,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_2`]
    PhysicalDeviceVulkan12Properties = 52,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_2`]
    ImageFormatListCreateInfo = 1000147000,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_2`]
    AttachmentDescription2 = 1000109000,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_2`]
    AttachmentReference2 = 1000109001,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_2`]
    SubpassDescription2 = 1000109002,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_2`]
    SubpassDependency2 = 1000109003,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_2`]
    RenderPassCreateInfo2 = 1000109004,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_2`]
    SubpassBeginInfo = 1000109005,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_2`]
    SubpassEndInfo = 1000109006,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_2`]
    PhysicalDevice8BitStorageFeatures = 1000177000,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_2`]
    PhysicalDeviceDriverProperties = 1000196000,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_2`]
    PhysicalDeviceShaderAtomicInt64Features = 1000180000,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_2`]
    PhysicalDeviceShaderFloat16Int8Features = 1000082000,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_2`]
    PhysicalDeviceFloatControlsProperties = 1000197000,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_2`]
    DescriptorSetLayoutBindingFlagsCreateInfo = 1000161000,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_2`]
    PhysicalDeviceDescriptorIndexingFeatures = 1000161001,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_2`]
    PhysicalDeviceDescriptorIndexingProperties = 1000161002,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_2`]
    DescriptorSetVariableDescriptorCountAllocateInfo = 1000161003,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_2`]
    DescriptorSetVariableDescriptorCountLayoutSupport = 1000161004,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_2`]
    PhysicalDeviceDepthStencilResolveProperties = 1000199000,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_2`]
    SubpassDescriptionDepthStencilResolve = 1000199001,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_2`]
    PhysicalDeviceScalarBlockLayoutFeatures = 1000221000,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_2`]
    ImageStencilUsageCreateInfo = 1000246000,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_2`]
    PhysicalDeviceSamplerFilterMinmaxProperties = 1000130000,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_2`]
    SamplerReductionModeCreateInfo = 1000130001,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_2`]
    PhysicalDeviceVulkanMemoryModelFeatures = 1000211000,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_2`]
    PhysicalDeviceImagelessFramebufferFeatures = 1000108000,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_2`]
    FramebufferAttachmentsCreateInfo = 1000108001,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_2`]
    FramebufferAttachmentImageInfo = 1000108002,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_2`]
    RenderPassAttachmentBeginInfo = 1000108003,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_2`]
    PhysicalDeviceUniformBufferStandardLayoutFeatures = 1000253000,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_2`]
    PhysicalDeviceShaderSubgroupExtendedTypesFeatures = 1000175000,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_2`]
    PhysicalDeviceSeparateDepthStencilLayoutsFeatures = 1000241000,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_2`]
    AttachmentReferenceStencilLayout = 1000241001,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_2`]
    AttachmentDescriptionStencilLayout = 1000241002,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_2`]
    PhysicalDeviceHostQueryResetFeatures = 1000261000,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_2`]
    PhysicalDeviceTimelineSemaphoreFeatures = 1000207000,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_2`]
    PhysicalDeviceTimelineSemaphoreProperties = 1000207001,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_2`]
    SemaphoreTypeCreateInfo = 1000207002,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_2`]
    TimelineSemaphoreSubmitInfo = 1000207003,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_2`]
    SemaphoreWaitInfo = 1000207004,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_2`]
    SemaphoreSignalInfo = 1000207005,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_2`]
    PhysicalDeviceBufferDeviceAddressFeatures = 1000257000,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_2`]
    BufferDeviceAddressInfo = 1000244001,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_2`]
    BufferOpaqueCaptureAddressCreateInfo = 1000257002,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_2`]
    MemoryOpaqueCaptureAddressAllocateInfo = 1000257003,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_2`]
    DeviceMemoryOpaqueCaptureAddressInfo = 1000257004,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_3`]
    PhysicalDeviceVulkan13Features = 53,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_3`]
    PhysicalDeviceVulkan13Properties = 54,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_3`]
    PipelineCreationFeedbackCreateInfo = 1000192000,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_3`]
    PhysicalDeviceShaderTerminateInvocationFeatures = 1000215000,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_3`]
    PhysicalDeviceToolProperties = 1000245000,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_3`]
    PhysicalDeviceShaderDemoteToHelperInvocationFeatures = 1000276000,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_3`]
    PhysicalDevicePrivateDataFeatures = 1000295000,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_3`]
    DevicePrivateDataCreateInfo = 1000295001,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_3`]
    PrivateDataSlotCreateInfo = 1000295002,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_3`]
    PhysicalDevicePipelineCreationCacheControlFeatures = 1000297000,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_3`]
    MemoryBarrier2 = 1000314000,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_3`]
    BufferMemoryBarrier2 = 1000314001,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_3`]
    ImageMemoryBarrier2 = 1000314002,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_3`]
    DependencyInfo = 1000314003,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_3`]
    SubmitInfo2 = 1000314004,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_3`]
    SemaphoreSubmitInfo = 1000314005,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_3`]
    CommandBufferSubmitInfo = 1000314006,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_3`]
    PhysicalDeviceSynchronization2Features = 1000314007,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_3`]
    PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures = 1000325000,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_3`]
    PhysicalDeviceImageRobustnessFeatures = 1000335000,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_3`]
    CopyBufferInfo2 = 1000337000,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_3`]
    CopyImageInfo2 = 1000337001,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_3`]
    CopyBufferToImageInfo2 = 1000337002,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_3`]
    CopyImageToBufferInfo2 = 1000337003,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_3`]
    BlitImageInfo2 = 1000337004,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_3`]
    ResolveImageInfo2 = 1000337005,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_3`]
    BufferCopy2 = 1000337006,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_3`]
    ImageCopy2 = 1000337007,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_3`]
    ImageBlit2 = 1000337008,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_3`]
    BufferImageCopy2 = 1000337009,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_3`]
    ImageResolve2 = 1000337010,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_3`]
    PhysicalDeviceSubgroupSizeControlProperties = 1000225000,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_3`]
    PipelineShaderStageRequiredSubgroupSizeCreateInfo = 1000225001,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_3`]
    PhysicalDeviceSubgroupSizeControlFeatures = 1000225002,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_3`]
    PhysicalDeviceInlineUniformBlockFeatures = 1000138000,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_3`]
    PhysicalDeviceInlineUniformBlockProperties = 1000138001,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_3`]
    WriteDescriptorSetInlineUniformBlock = 1000138002,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_3`]
    DescriptorPoolInlineUniformBlockCreateInfo = 1000138003,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_3`]
    PhysicalDeviceTextureCompressionAstcHdrFeatures = 1000066000,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_3`]
    RenderingInfo = 1000044000,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_3`]
    RenderingAttachmentInfo = 1000044001,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_3`]
    PipelineRenderingCreateInfo = 1000044002,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_3`]
    PhysicalDeviceDynamicRenderingFeatures = 1000044003,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_3`]
    CommandBufferInheritanceRenderingInfo = 1000044004,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_3`]
    PhysicalDeviceShaderIntegerDotProductFeatures = 1000280000,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_3`]
    PhysicalDeviceShaderIntegerDotProductProperties = 1000280001,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_3`]
    PhysicalDeviceTexelBufferAlignmentProperties = 1000281001,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_3`]
    FormatProperties3 = 1000360000,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_3`]
    PhysicalDeviceMaintenance4Features = 1000413000,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_3`]
    PhysicalDeviceMaintenance4Properties = 1000413001,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_3`]
    DeviceBufferMemoryRequirements = 1000413002,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_3`]
    DeviceImageMemoryRequirements = 1000413003,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_swapchain`]
    SwapchainCreateInfoKhr = 1000001000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_swapchain`]
    PresentInfoKhr = 1000001001,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_device_group`]
    DeviceGroupPresentCapabilitiesKhr = 1000060007,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_device_group`]
    ImageSwapchainCreateInfoKhr = 1000060008,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_device_group`]
    BindImageMemorySwapchainInfoKhr = 1000060009,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_device_group`]
    AcquireNextImageInfoKhr = 1000060010,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_device_group`]
    DeviceGroupPresentInfoKhr = 1000060011,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_device_group`]
    DeviceGroupSwapchainCreateInfoKhr = 1000060012,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_display`]
    DisplayModeCreateInfoKhr = 1000002000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_display`]
    DisplaySurfaceCreateInfoKhr = 1000002001,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_display_swapchain`]
    DisplayPresentInfoKhr = 1000003000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_xlib_surface`]
    XlibSurfaceCreateInfoKhr = 1000004000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_xcb_surface`]
    XcbSurfaceCreateInfoKhr = 1000005000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_wayland_surface`]
    WaylandSurfaceCreateInfoKhr = 1000006000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_android_surface`]
    AndroidSurfaceCreateInfoKhr = 1000008000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_win_32_surface`]
    Win32SurfaceCreateInfoKhr = 1000009000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_debug_report`]
    DebugReportCallbackCreateInfoExt = 1000011000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::amd_rasterization_order`]
    PipelineRasterizationStateRasterizationOrderAmd = 1000018000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_debug_marker`]
    DebugMarkerObjectNameInfoExt = 1000022000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_debug_marker`]
    DebugMarkerObjectTagInfoExt = 1000022001,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_debug_marker`]
    DebugMarkerMarkerInfoExt = 1000022002,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_video_queue`]
    VideoProfileKhr = 1000023000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_video_queue`]
    VideoCapabilitiesKhr = 1000023001,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_video_queue`]
    VideoPictureResourceKhr = 1000023002,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_video_queue`]
    VideoGetMemoryPropertiesKhr = 1000023003,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_video_queue`]
    VideoBindMemoryKhr = 1000023004,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_video_queue`]
    VideoSessionCreateInfoKhr = 1000023005,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_video_queue`]
    VideoSessionParametersCreateInfoKhr = 1000023006,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_video_queue`]
    VideoSessionParametersUpdateInfoKhr = 1000023007,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_video_queue`]
    VideoBeginCodingInfoKhr = 1000023008,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_video_queue`]
    VideoEndCodingInfoKhr = 1000023009,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_video_queue`]
    VideoCodingControlInfoKhr = 1000023010,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_video_queue`]
    VideoReferenceSlotKhr = 1000023011,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_video_queue`]
    VideoQueueFamilyProperties2Khr = 1000023012,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_video_queue`]
    VideoProfilesKhr = 1000023013,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_video_queue`]
    PhysicalDeviceVideoFormatInfoKhr = 1000023014,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_video_queue`]
    VideoFormatPropertiesKhr = 1000023015,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_video_queue`]
    QueueFamilyQueryResultStatusProperties2Khr = 1000023016,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_video_decode_queue`]
    VideoDecodeInfoKhr = 1000024000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_video_decode_queue`]
    VideoDecodeCapabilitiesKhr = 1000024001,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::nv_dedicated_allocation`]
    DedicatedAllocationImageCreateInfoNv = 1000026000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::nv_dedicated_allocation`]
    DedicatedAllocationBufferCreateInfoNv = 1000026001,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::nv_dedicated_allocation`]
    DedicatedAllocationMemoryAllocateInfoNv = 1000026002,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_transform_feedback`]
    PhysicalDeviceTransformFeedbackFeaturesExt = 1000028000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_transform_feedback`]
    PhysicalDeviceTransformFeedbackPropertiesExt = 1000028001,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_transform_feedback`]
    PipelineRasterizationStateStreamCreateInfoExt = 1000028002,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::nvx_binary_import`]
    CuModuleCreateInfoNvx = 1000029000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::nvx_binary_import`]
    CuFunctionCreateInfoNvx = 1000029001,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::nvx_binary_import`]
    CuLaunchInfoNvx = 1000029002,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::nvx_image_view_handle`]
    ImageViewHandleInfoNvx = 1000030000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::nvx_image_view_handle`]
    ImageViewAddressPropertiesNvx = 1000030001,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_video_encode_h_264`]
    VideoEncodeH264CapabilitiesExt = 1000038000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_video_encode_h_264`]
    VideoEncodeH264SessionCreateInfoExt = 1000038001,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_video_encode_h_264`]
    VideoEncodeH264SessionParametersCreateInfoExt = 1000038002,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_video_encode_h_264`]
    VideoEncodeH264SessionParametersAddInfoExt = 1000038003,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_video_encode_h_264`]
    VideoEncodeH264VclFrameInfoExt = 1000038004,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_video_encode_h_264`]
    VideoEncodeH264DpbSlotInfoExt = 1000038005,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_video_encode_h_264`]
    VideoEncodeH264NaluSliceExt = 1000038006,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_video_encode_h_264`]
    VideoEncodeH264EmitPictureParametersExt = 1000038007,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_video_encode_h_264`]
    VideoEncodeH264ProfileExt = 1000038008,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_video_encode_h_264`]
    VideoEncodeH264RateControlInfoExt = 1000038009,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_video_encode_h_264`]
    VideoEncodeH264RateControlLayerInfoExt = 1000038010,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_video_encode_h_264`]
    VideoEncodeH264ReferenceListsExt = 1000038011,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_video_encode_h_265`]
    VideoEncodeH265CapabilitiesExt = 1000039000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_video_encode_h_265`]
    VideoEncodeH265SessionCreateInfoExt = 1000039001,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_video_encode_h_265`]
    VideoEncodeH265SessionParametersCreateInfoExt = 1000039002,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_video_encode_h_265`]
    VideoEncodeH265SessionParametersAddInfoExt = 1000039003,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_video_encode_h_265`]
    VideoEncodeH265VclFrameInfoExt = 1000039004,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_video_encode_h_265`]
    VideoEncodeH265DpbSlotInfoExt = 1000039005,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_video_encode_h_265`]
    VideoEncodeH265NaluSliceSegmentExt = 1000039006,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_video_encode_h_265`]
    VideoEncodeH265EmitPictureParametersExt = 1000039007,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_video_encode_h_265`]
    VideoEncodeH265ProfileExt = 1000039008,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_video_encode_h_265`]
    VideoEncodeH265ReferenceListsExt = 1000039009,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_video_encode_h_265`]
    VideoEncodeH265RateControlInfoExt = 1000039010,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_video_encode_h_265`]
    VideoEncodeH265RateControlLayerInfoExt = 1000039011,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_video_decode_h_264`]
    VideoDecodeH264CapabilitiesExt = 1000040000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_video_decode_h_264`]
    VideoDecodeH264SessionCreateInfoExt = 1000040001,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_video_decode_h_264`]
    VideoDecodeH264PictureInfoExt = 1000040002,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_video_decode_h_264`]
    VideoDecodeH264MvcExt = 1000040003,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_video_decode_h_264`]
    VideoDecodeH264ProfileExt = 1000040004,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_video_decode_h_264`]
    VideoDecodeH264SessionParametersCreateInfoExt = 1000040005,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_video_decode_h_264`]
    VideoDecodeH264SessionParametersAddInfoExt = 1000040006,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_video_decode_h_264`]
    VideoDecodeH264DpbSlotInfoExt = 1000040007,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::amd_texture_gather_bias_lod`]
    TextureLodGatherFormatPropertiesAmd = 1000041000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_dynamic_rendering`]
    RenderingFragmentShadingRateAttachmentInfoKhr = 1000044006,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_dynamic_rendering`]
    RenderingFragmentDensityMapAttachmentInfoExt = 1000044007,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_dynamic_rendering`]
    AttachmentSampleCountInfoAmd = 1000044008,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_dynamic_rendering`]
    MultiviewPerViewAttributesInfoNvx = 1000044009,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ggp_stream_descriptor_surface`]
    StreamDescriptorSurfaceCreateInfoGgp = 1000049000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::nv_corner_sampled_image`]
    PhysicalDeviceCornerSampledImageFeaturesNv = 1000050000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::nv_external_memory`]
    ExternalMemoryImageCreateInfoNv = 1000056000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::nv_external_memory`]
    ExportMemoryAllocateInfoNv = 1000056001,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::nv_external_memory_win_32`]
    ImportMemoryWin32HandleInfoNv = 1000057000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::nv_external_memory_win_32`]
    ExportMemoryWin32HandleInfoNv = 1000057001,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::nv_win_32_keyed_mutex`]
    Win32KeyedMutexAcquireReleaseInfoNv = 1000058000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_validation_flags`]
    ValidationFlagsExt = 1000061000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::nn_vi_surface`]
    ViSurfaceCreateInfoNn = 1000062000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_astc_decode_mode`]
    ImageViewAstcDecodeModeExt = 1000067000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_astc_decode_mode`]
    PhysicalDeviceAstcDecodeFeaturesExt = 1000067001,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_external_memory_win_32`]
    ImportMemoryWin32HandleInfoKhr = 1000073000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_external_memory_win_32`]
    ExportMemoryWin32HandleInfoKhr = 1000073001,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_external_memory_win_32`]
    MemoryWin32HandlePropertiesKhr = 1000073002,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_external_memory_win_32`]
    MemoryGetWin32HandleInfoKhr = 1000073003,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_external_memory_fd`]
    ImportMemoryFdInfoKhr = 1000074000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_external_memory_fd`]
    MemoryFdPropertiesKhr = 1000074001,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_external_memory_fd`]
    MemoryGetFdInfoKhr = 1000074002,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_win_32_keyed_mutex`]
    Win32KeyedMutexAcquireReleaseInfoKhr = 1000075000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_external_semaphore_win_32`]
    ImportSemaphoreWin32HandleInfoKhr = 1000078000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_external_semaphore_win_32`]
    ExportSemaphoreWin32HandleInfoKhr = 1000078001,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_external_semaphore_win_32`]
    D3D12FenceSubmitInfoKhr = 1000078002,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_external_semaphore_win_32`]
    SemaphoreGetWin32HandleInfoKhr = 1000078003,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_external_semaphore_fd`]
    ImportSemaphoreFdInfoKhr = 1000079000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_external_semaphore_fd`]
    SemaphoreGetFdInfoKhr = 1000079001,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_push_descriptor`]
    PhysicalDevicePushDescriptorPropertiesKhr = 1000080000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_conditional_rendering`]
    CommandBufferInheritanceConditionalRenderingInfoExt = 1000081000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_conditional_rendering`]
    PhysicalDeviceConditionalRenderingFeaturesExt = 1000081001,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_conditional_rendering`]
    ConditionalRenderingBeginInfoExt = 1000081002,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_incremental_present`]
    PresentRegionsKhr = 1000084000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::nv_clip_space_w_scaling`]
    PipelineViewportWScalingStateCreateInfoNv = 1000087000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_display_surface_counter`]
    SurfaceCapabilities2Ext = 1000090000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_display_control`]
    DisplayPowerInfoExt = 1000091000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_display_control`]
    DeviceEventInfoExt = 1000091001,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_display_control`]
    DisplayEventInfoExt = 1000091002,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_display_control`]
    SwapchainCounterCreateInfoExt = 1000091003,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::google_display_timing`]
    PresentTimesInfoGoogle = 1000092000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::nvx_multiview_per_view_attributes`]
    PhysicalDeviceMultiviewPerViewAttributesPropertiesNvx = 1000097000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::nv_viewport_swizzle`]
    PipelineViewportSwizzleStateCreateInfoNv = 1000098000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_discard_rectangles`]
    PhysicalDeviceDiscardRectanglePropertiesExt = 1000099000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_discard_rectangles`]
    PipelineDiscardRectangleStateCreateInfoExt = 1000099001,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_conservative_rasterization`]
    PhysicalDeviceConservativeRasterizationPropertiesExt = 1000101000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_conservative_rasterization`]
    PipelineRasterizationConservativeStateCreateInfoExt = 1000101001,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_depth_clip_enable`]
    PhysicalDeviceDepthClipEnableFeaturesExt = 1000102000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_depth_clip_enable`]
    PipelineRasterizationDepthClipStateCreateInfoExt = 1000102001,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_hdr_metadata`]
    HdrMetadataExt = 1000105000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_shared_presentable_image`]
    SharedPresentSurfaceCapabilitiesKhr = 1000111000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_external_fence_win_32`]
    ImportFenceWin32HandleInfoKhr = 1000114000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_external_fence_win_32`]
    ExportFenceWin32HandleInfoKhr = 1000114001,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_external_fence_win_32`]
    FenceGetWin32HandleInfoKhr = 1000114002,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_external_fence_fd`]
    ImportFenceFdInfoKhr = 1000115000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_external_fence_fd`]
    FenceGetFdInfoKhr = 1000115001,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_performance_query`]
    PhysicalDevicePerformanceQueryFeaturesKhr = 1000116000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_performance_query`]
    PhysicalDevicePerformanceQueryPropertiesKhr = 1000116001,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_performance_query`]
    QueryPoolPerformanceCreateInfoKhr = 1000116002,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_performance_query`]
    PerformanceQuerySubmitInfoKhr = 1000116003,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_performance_query`]
    AcquireProfilingLockInfoKhr = 1000116004,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_performance_query`]
    PerformanceCounterKhr = 1000116005,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_performance_query`]
    PerformanceCounterDescriptionKhr = 1000116006,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_get_surface_capabilities_2`]
    PhysicalDeviceSurfaceInfo2Khr = 1000119000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_get_surface_capabilities_2`]
    SurfaceCapabilities2Khr = 1000119001,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_get_surface_capabilities_2`]
    SurfaceFormat2Khr = 1000119002,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_get_display_properties_2`]
    DisplayProperties2Khr = 1000121000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_get_display_properties_2`]
    DisplayPlaneProperties2Khr = 1000121001,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_get_display_properties_2`]
    DisplayModeProperties2Khr = 1000121002,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_get_display_properties_2`]
    DisplayPlaneInfo2Khr = 1000121003,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_get_display_properties_2`]
    DisplayPlaneCapabilities2Khr = 1000121004,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::mvk_ios_surface`]
    IosSurfaceCreateInfoMvk = 1000122000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::mvk_macos_surface`]
    MacosSurfaceCreateInfoMvk = 1000123000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_debug_utils`]
    DebugUtilsObjectNameInfoExt = 1000128000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_debug_utils`]
    DebugUtilsObjectTagInfoExt = 1000128001,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_debug_utils`]
    DebugUtilsLabelExt = 1000128002,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_debug_utils`]
    DebugUtilsMessengerCallbackDataExt = 1000128003,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_debug_utils`]
    DebugUtilsMessengerCreateInfoExt = 1000128004,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::android_external_memory_android_hardware_buffer`]
    AndroidHardwareBufferUsageAndroid = 1000129000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::android_external_memory_android_hardware_buffer`]
    AndroidHardwareBufferPropertiesAndroid = 1000129001,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::android_external_memory_android_hardware_buffer`]
    AndroidHardwareBufferFormatPropertiesAndroid = 1000129002,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::android_external_memory_android_hardware_buffer`]
    ImportAndroidHardwareBufferInfoAndroid = 1000129003,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::android_external_memory_android_hardware_buffer`]
    MemoryGetAndroidHardwareBufferInfoAndroid = 1000129004,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::android_external_memory_android_hardware_buffer`]
    ExternalFormatAndroid = 1000129005,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::android_external_memory_android_hardware_buffer`]
    AndroidHardwareBufferFormatProperties2Android = 1000129006,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_sample_locations`]
    SampleLocationsInfoExt = 1000143000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_sample_locations`]
    RenderPassSampleLocationsBeginInfoExt = 1000143001,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_sample_locations`]
    PipelineSampleLocationsStateCreateInfoExt = 1000143002,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_sample_locations`]
    PhysicalDeviceSampleLocationsPropertiesExt = 1000143003,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_sample_locations`]
    MultisamplePropertiesExt = 1000143004,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_blend_operation_advanced`]
    PhysicalDeviceBlendOperationAdvancedFeaturesExt = 1000148000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_blend_operation_advanced`]
    PhysicalDeviceBlendOperationAdvancedPropertiesExt = 1000148001,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_blend_operation_advanced`]
    PipelineColorBlendAdvancedStateCreateInfoExt = 1000148002,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::nv_fragment_coverage_to_color`]
    PipelineCoverageToColorStateCreateInfoNv = 1000149000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_acceleration_structure`]
    WriteDescriptorSetAccelerationStructureKhr = 1000150007,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_acceleration_structure`]
    AccelerationStructureBuildGeometryInfoKhr = 1000150000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_acceleration_structure`]
    AccelerationStructureDeviceAddressInfoKhr = 1000150002,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_acceleration_structure`]
    AccelerationStructureGeometryAabbsDataKhr = 1000150003,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_acceleration_structure`]
    AccelerationStructureGeometryInstancesDataKhr = 1000150004,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_acceleration_structure`]
    AccelerationStructureGeometryTrianglesDataKhr = 1000150005,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_acceleration_structure`]
    AccelerationStructureGeometryKhr = 1000150006,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_acceleration_structure`]
    AccelerationStructureVersionInfoKhr = 1000150009,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_acceleration_structure`]
    CopyAccelerationStructureInfoKhr = 1000150010,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_acceleration_structure`]
    CopyAccelerationStructureToMemoryInfoKhr = 1000150011,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_acceleration_structure`]
    CopyMemoryToAccelerationStructureInfoKhr = 1000150012,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_acceleration_structure`]
    PhysicalDeviceAccelerationStructureFeaturesKhr = 1000150013,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_acceleration_structure`]
    PhysicalDeviceAccelerationStructurePropertiesKhr = 1000150014,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_acceleration_structure`]
    AccelerationStructureCreateInfoKhr = 1000150017,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_acceleration_structure`]
    AccelerationStructureBuildSizesInfoKhr = 1000150020,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_ray_tracing_pipeline`]
    PhysicalDeviceRayTracingPipelineFeaturesKhr = 1000347000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_ray_tracing_pipeline`]
    PhysicalDeviceRayTracingPipelinePropertiesKhr = 1000347001,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_ray_tracing_pipeline`]
    RayTracingPipelineCreateInfoKhr = 1000150015,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_ray_tracing_pipeline`]
    RayTracingShaderGroupCreateInfoKhr = 1000150016,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_ray_tracing_pipeline`]
    RayTracingPipelineInterfaceCreateInfoKhr = 1000150018,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_ray_query`]
    PhysicalDeviceRayQueryFeaturesKhr = 1000348013,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::nv_framebuffer_mixed_samples`]
    PipelineCoverageModulationStateCreateInfoNv = 1000152000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::nv_shader_sm_builtins`]
    PhysicalDeviceShaderSmBuiltinsFeaturesNv = 1000154000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::nv_shader_sm_builtins`]
    PhysicalDeviceShaderSmBuiltinsPropertiesNv = 1000154001,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_image_drm_format_modifier`]
    DrmFormatModifierPropertiesListExt = 1000158000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_image_drm_format_modifier`]
    PhysicalDeviceImageDrmFormatModifierInfoExt = 1000158002,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_image_drm_format_modifier`]
    ImageDrmFormatModifierListCreateInfoExt = 1000158003,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_image_drm_format_modifier`]
    ImageDrmFormatModifierExplicitCreateInfoExt = 1000158004,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_image_drm_format_modifier`]
    ImageDrmFormatModifierPropertiesExt = 1000158005,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_image_drm_format_modifier`]
    DrmFormatModifierPropertiesList2Ext = 1000158006,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_validation_cache`]
    ValidationCacheCreateInfoExt = 1000160000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_validation_cache`]
    ShaderModuleValidationCacheCreateInfoExt = 1000160001,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_portability_subset`]
    PhysicalDevicePortabilitySubsetFeaturesKhr = 1000163000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_portability_subset`]
    PhysicalDevicePortabilitySubsetPropertiesKhr = 1000163001,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::nv_shading_rate_image`]
    PipelineViewportShadingRateImageStateCreateInfoNv = 1000164000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::nv_shading_rate_image`]
    PhysicalDeviceShadingRateImageFeaturesNv = 1000164001,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::nv_shading_rate_image`]
    PhysicalDeviceShadingRateImagePropertiesNv = 1000164002,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::nv_shading_rate_image`]
    PipelineViewportCoarseSampleOrderStateCreateInfoNv = 1000164005,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::nv_ray_tracing`]
    RayTracingPipelineCreateInfoNv = 1000165000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::nv_ray_tracing`]
    AccelerationStructureCreateInfoNv = 1000165001,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::nv_ray_tracing`]
    GeometryNv = 1000165003,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::nv_ray_tracing`]
    GeometryTrianglesNv = 1000165004,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::nv_ray_tracing`]
    GeometryAabbNv = 1000165005,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::nv_ray_tracing`]
    BindAccelerationStructureMemoryInfoNv = 1000165006,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::nv_ray_tracing`]
    WriteDescriptorSetAccelerationStructureNv = 1000165007,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::nv_ray_tracing`]
    AccelerationStructureMemoryRequirementsInfoNv = 1000165008,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::nv_ray_tracing`]
    PhysicalDeviceRayTracingPropertiesNv = 1000165009,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::nv_ray_tracing`]
    RayTracingShaderGroupCreateInfoNv = 1000165011,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::nv_ray_tracing`]
    AccelerationStructureInfoNv = 1000165012,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::nv_representative_fragment_test`]
    PhysicalDeviceRepresentativeFragmentTestFeaturesNv = 1000166000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::nv_representative_fragment_test`]
    PipelineRepresentativeFragmentTestStateCreateInfoNv = 1000166001,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_filter_cubic`]
    PhysicalDeviceImageViewImageFormatInfoExt = 1000170000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_filter_cubic`]
    FilterCubicImageViewImageFormatPropertiesExt = 1000170001,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_external_memory_host`]
    ImportMemoryHostPointerInfoExt = 1000178000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_external_memory_host`]
    MemoryHostPointerPropertiesExt = 1000178001,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_external_memory_host`]
    PhysicalDeviceExternalMemoryHostPropertiesExt = 1000178002,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_shader_clock`]
    PhysicalDeviceShaderClockFeaturesKhr = 1000181000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::amd_pipeline_compiler_control`]
    PipelineCompilerControlCreateInfoAmd = 1000183000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_calibrated_timestamps`]
    CalibratedTimestampInfoExt = 1000184000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::amd_shader_core_properties`]
    PhysicalDeviceShaderCorePropertiesAmd = 1000185000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_video_decode_h_265`]
    VideoDecodeH265CapabilitiesExt = 1000187000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_video_decode_h_265`]
    VideoDecodeH265SessionCreateInfoExt = 1000187001,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_video_decode_h_265`]
    VideoDecodeH265SessionParametersCreateInfoExt = 1000187002,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_video_decode_h_265`]
    VideoDecodeH265SessionParametersAddInfoExt = 1000187003,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_video_decode_h_265`]
    VideoDecodeH265ProfileExt = 1000187004,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_video_decode_h_265`]
    VideoDecodeH265PictureInfoExt = 1000187005,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_video_decode_h_265`]
    VideoDecodeH265DpbSlotInfoExt = 1000187006,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_global_priority`]
    DeviceQueueGlobalPriorityCreateInfoKhr = 1000174000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_global_priority`]
    PhysicalDeviceGlobalPriorityQueryFeaturesKhr = 1000388000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_global_priority`]
    QueueFamilyGlobalPriorityPropertiesKhr = 1000388001,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::amd_memory_overallocation_behavior`]
    DeviceMemoryOverallocationCreateInfoAmd = 1000189000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_vertex_attribute_divisor`]
    PhysicalDeviceVertexAttributeDivisorPropertiesExt = 1000190000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_vertex_attribute_divisor`]
    PipelineVertexInputDivisorStateCreateInfoExt = 1000190001,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_vertex_attribute_divisor`]
    PhysicalDeviceVertexAttributeDivisorFeaturesExt = 1000190002,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ggp_frame_token`]
    PresentFrameTokenGgp = 1000191000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::nv_compute_shader_derivatives`]
    PhysicalDeviceComputeShaderDerivativesFeaturesNv = 1000201000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::nv_mesh_shader`]
    PhysicalDeviceMeshShaderFeaturesNv = 1000202000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::nv_mesh_shader`]
    PhysicalDeviceMeshShaderPropertiesNv = 1000202001,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::nv_fragment_shader_barycentric`]
    PhysicalDeviceFragmentShaderBarycentricFeaturesNv = 1000203000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::nv_shader_image_footprint`]
    PhysicalDeviceShaderImageFootprintFeaturesNv = 1000204000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::nv_scissor_exclusive`]
    PipelineViewportExclusiveScissorStateCreateInfoNv = 1000205000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::nv_scissor_exclusive`]
    PhysicalDeviceExclusiveScissorFeaturesNv = 1000205002,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::nv_device_diagnostic_checkpoints`]
    CheckpointDataNv = 1000206000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::nv_device_diagnostic_checkpoints`]
    QueueFamilyCheckpointPropertiesNv = 1000206001,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::intel_shader_integer_functions_2`]
    PhysicalDeviceShaderIntegerFunctions2FeaturesIntel = 1000209000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::intel_performance_query`]
    QueryPoolPerformanceQueryCreateInfoIntel = 1000210000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::intel_performance_query`]
    InitializePerformanceApiInfoIntel = 1000210001,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::intel_performance_query`]
    PerformanceMarkerInfoIntel = 1000210002,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::intel_performance_query`]
    PerformanceStreamMarkerInfoIntel = 1000210003,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::intel_performance_query`]
    PerformanceOverrideInfoIntel = 1000210004,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::intel_performance_query`]
    PerformanceConfigurationAcquireInfoIntel = 1000210005,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_pci_bus_info`]
    PhysicalDevicePciBusInfoPropertiesExt = 1000212000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::amd_display_native_hdr`]
    DisplayNativeHdrSurfaceCapabilitiesAmd = 1000213000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::amd_display_native_hdr`]
    SwapchainDisplayNativeHdrCreateInfoAmd = 1000213001,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::fuchsia_imagepipe_surface`]
    ImagepipeSurfaceCreateInfoFuchsia = 1000214000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_metal_surface`]
    MetalSurfaceCreateInfoExt = 1000217000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_fragment_density_map`]
    PhysicalDeviceFragmentDensityMapFeaturesExt = 1000218000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_fragment_density_map`]
    PhysicalDeviceFragmentDensityMapPropertiesExt = 1000218001,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_fragment_density_map`]
    RenderPassFragmentDensityMapCreateInfoExt = 1000218002,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_fragment_shading_rate`]
    FragmentShadingRateAttachmentInfoKhr = 1000226000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_fragment_shading_rate`]
    PipelineFragmentShadingRateStateCreateInfoKhr = 1000226001,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_fragment_shading_rate`]
    PhysicalDeviceFragmentShadingRatePropertiesKhr = 1000226002,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_fragment_shading_rate`]
    PhysicalDeviceFragmentShadingRateFeaturesKhr = 1000226003,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_fragment_shading_rate`]
    PhysicalDeviceFragmentShadingRateKhr = 1000226004,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::amd_shader_core_properties_2`]
    PhysicalDeviceShaderCoreProperties2Amd = 1000227000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::amd_device_coherent_memory`]
    PhysicalDeviceCoherentMemoryFeaturesAmd = 1000229000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_shader_image_atomic_int_64`]
    PhysicalDeviceShaderImageAtomicInt64FeaturesExt = 1000234000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_memory_budget`]
    PhysicalDeviceMemoryBudgetPropertiesExt = 1000237000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_memory_priority`]
    PhysicalDeviceMemoryPriorityFeaturesExt = 1000238000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_memory_priority`]
    MemoryPriorityAllocateInfoExt = 1000238001,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_surface_protected_capabilities`]
    SurfaceProtectedCapabilitiesKhr = 1000239000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::nv_dedicated_allocation_image_aliasing`]
    PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNv = 1000240000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_buffer_device_address`]
    PhysicalDeviceBufferDeviceAddressFeaturesExt = 1000244000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_buffer_device_address`]
    BufferDeviceAddressCreateInfoExt = 1000244002,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_validation_features`]
    ValidationFeaturesExt = 1000247000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_present_wait`]
    PhysicalDevicePresentWaitFeaturesKhr = 1000248000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::nv_cooperative_matrix`]
    PhysicalDeviceCooperativeMatrixFeaturesNv = 1000249000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::nv_cooperative_matrix`]
    CooperativeMatrixPropertiesNv = 1000249001,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::nv_cooperative_matrix`]
    PhysicalDeviceCooperativeMatrixPropertiesNv = 1000249002,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::nv_coverage_reduction_mode`]
    PhysicalDeviceCoverageReductionModeFeaturesNv = 1000250000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::nv_coverage_reduction_mode`]
    PipelineCoverageReductionStateCreateInfoNv = 1000250001,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::nv_coverage_reduction_mode`]
    FramebufferMixedSamplesCombinationNv = 1000250002,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_fragment_shader_interlock`]
    PhysicalDeviceFragmentShaderInterlockFeaturesExt = 1000251000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_ycbcr_image_arrays`]
    PhysicalDeviceYcbcrImageArraysFeaturesExt = 1000252000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_provoking_vertex`]
    PhysicalDeviceProvokingVertexFeaturesExt = 1000254000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_provoking_vertex`]
    PipelineRasterizationProvokingVertexStateCreateInfoExt = 1000254001,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_provoking_vertex`]
    PhysicalDeviceProvokingVertexPropertiesExt = 1000254002,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_full_screen_exclusive`]
    SurfaceFullScreenExclusiveInfoExt = 1000255000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_full_screen_exclusive`]
    SurfaceCapabilitiesFullScreenExclusiveExt = 1000255002,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_full_screen_exclusive`]
    SurfaceFullScreenExclusiveWin32InfoExt = 1000255001,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_headless_surface`]
    HeadlessSurfaceCreateInfoExt = 1000256000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_line_rasterization`]
    PhysicalDeviceLineRasterizationFeaturesExt = 1000259000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_line_rasterization`]
    PipelineRasterizationLineStateCreateInfoExt = 1000259001,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_line_rasterization`]
    PhysicalDeviceLineRasterizationPropertiesExt = 1000259002,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_shader_atomic_float`]
    PhysicalDeviceShaderAtomicFloatFeaturesExt = 1000260000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_index_type_uint_8`]
    PhysicalDeviceIndexTypeUint8FeaturesExt = 1000265000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_extended_dynamic_state`]
    PhysicalDeviceExtendedDynamicStateFeaturesExt = 1000267000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_pipeline_executable_properties`]
    PhysicalDevicePipelineExecutablePropertiesFeaturesKhr = 1000269000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_pipeline_executable_properties`]
    PipelineInfoKhr = 1000269001,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_pipeline_executable_properties`]
    PipelineExecutablePropertiesKhr = 1000269002,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_pipeline_executable_properties`]
    PipelineExecutableInfoKhr = 1000269003,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_pipeline_executable_properties`]
    PipelineExecutableStatisticKhr = 1000269004,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_pipeline_executable_properties`]
    PipelineExecutableInternalRepresentationKhr = 1000269005,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_shader_atomic_float_2`]
    PhysicalDeviceShaderAtomicFloat2FeaturesExt = 1000273000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::nv_device_generated_commands`]
    PhysicalDeviceDeviceGeneratedCommandsPropertiesNv = 1000277000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::nv_device_generated_commands`]
    GraphicsShaderGroupCreateInfoNv = 1000277001,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::nv_device_generated_commands`]
    GraphicsPipelineShaderGroupsCreateInfoNv = 1000277002,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::nv_device_generated_commands`]
    IndirectCommandsLayoutTokenNv = 1000277003,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::nv_device_generated_commands`]
    IndirectCommandsLayoutCreateInfoNv = 1000277004,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::nv_device_generated_commands`]
    GeneratedCommandsInfoNv = 1000277005,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::nv_device_generated_commands`]
    GeneratedCommandsMemoryRequirementsInfoNv = 1000277006,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::nv_device_generated_commands`]
    PhysicalDeviceDeviceGeneratedCommandsFeaturesNv = 1000277007,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::nv_inherited_viewport_scissor`]
    PhysicalDeviceInheritedViewportScissorFeaturesNv = 1000278000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::nv_inherited_viewport_scissor`]
    CommandBufferInheritanceViewportScissorInfoNv = 1000278001,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_texel_buffer_alignment`]
    PhysicalDeviceTexelBufferAlignmentFeaturesExt = 1000281000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::qcom_render_pass_transform`]
    CommandBufferInheritanceRenderPassTransformInfoQcom = 1000282000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::qcom_render_pass_transform`]
    RenderPassTransformBeginInfoQcom = 1000282001,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_device_memory_report`]
    PhysicalDeviceDeviceMemoryReportFeaturesExt = 1000284000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_device_memory_report`]
    DeviceDeviceMemoryReportCreateInfoExt = 1000284001,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_device_memory_report`]
    DeviceMemoryReportCallbackDataExt = 1000284002,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_robustness_2`]
    PhysicalDeviceRobustness2FeaturesExt = 1000286000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_robustness_2`]
    PhysicalDeviceRobustness2PropertiesExt = 1000286001,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_custom_border_color`]
    SamplerCustomBorderColorCreateInfoExt = 1000287000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_custom_border_color`]
    PhysicalDeviceCustomBorderColorPropertiesExt = 1000287001,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_custom_border_color`]
    PhysicalDeviceCustomBorderColorFeaturesExt = 1000287002,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_pipeline_library`]
    PipelineLibraryCreateInfoKhr = 1000290000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_present_id`]
    PresentIdKhr = 1000294000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_present_id`]
    PhysicalDevicePresentIdFeaturesKhr = 1000294001,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_video_encode_queue`]
    VideoEncodeInfoKhr = 1000299000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_video_encode_queue`]
    VideoEncodeRateControlInfoKhr = 1000299001,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_video_encode_queue`]
    VideoEncodeRateControlLayerInfoKhr = 1000299002,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_video_encode_queue`]
    VideoEncodeCapabilitiesKhr = 1000299003,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::nv_device_diagnostics_config`]
    PhysicalDeviceDiagnosticsConfigFeaturesNv = 1000300000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::nv_device_diagnostics_config`]
    DeviceDiagnosticsConfigCreateInfoNv = 1000300001,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_synchronization_2`]
    QueueFamilyCheckpointProperties2Nv = 1000314008,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_synchronization_2`]
    CheckpointData2Nv = 1000314009,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_shader_subgroup_uniform_control_flow`]
    PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKhr = 1000323000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::nv_fragment_shading_rate_enums`]
    PhysicalDeviceFragmentShadingRateEnumsPropertiesNv = 1000326000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::nv_fragment_shading_rate_enums`]
    PhysicalDeviceFragmentShadingRateEnumsFeaturesNv = 1000326001,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::nv_fragment_shading_rate_enums`]
    PipelineFragmentShadingRateEnumStateCreateInfoNv = 1000326002,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::nv_ray_tracing_motion_blur`]
    AccelerationStructureGeometryMotionTrianglesDataNv = 1000327000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::nv_ray_tracing_motion_blur`]
    PhysicalDeviceRayTracingMotionBlurFeaturesNv = 1000327001,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::nv_ray_tracing_motion_blur`]
    AccelerationStructureMotionInfoNv = 1000327002,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_ycbcr_2_plane_444_formats`]
    PhysicalDeviceYcbcr2Plane444FormatsFeaturesExt = 1000330000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_fragment_density_map_2`]
    PhysicalDeviceFragmentDensityMap2FeaturesExt = 1000332000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_fragment_density_map_2`]
    PhysicalDeviceFragmentDensityMap2PropertiesExt = 1000332001,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::qcom_rotated_copy_commands`]
    CopyCommandTransformInfoQcom = 1000333000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_workgroup_memory_explicit_layout`]
    PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKhr = 1000336000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_4444_formats`]
    PhysicalDevice4444FormatsFeaturesExt = 1000340000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::arm_rasterization_order_attachment_access`]
    PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesArm = 1000342000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_rgba_10_x_6_formats`]
    PhysicalDeviceRgba10X6FormatsFeaturesExt = 1000344000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_directfb_surface`]
    DirectfbSurfaceCreateInfoExt = 1000346000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::valve_mutable_descriptor_type`]
    PhysicalDeviceMutableDescriptorTypeFeaturesValve = 1000351000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::valve_mutable_descriptor_type`]
    MutableDescriptorTypeCreateInfoValve = 1000351002,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_vertex_input_dynamic_state`]
    PhysicalDeviceVertexInputDynamicStateFeaturesExt = 1000352000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_vertex_input_dynamic_state`]
    VertexInputBindingDescription2Ext = 1000352001,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_vertex_input_dynamic_state`]
    VertexInputAttributeDescription2Ext = 1000352002,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_physical_device_drm`]
    PhysicalDeviceDrmPropertiesExt = 1000353000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_depth_clip_control`]
    PhysicalDeviceDepthClipControlFeaturesExt = 1000355000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_depth_clip_control`]
    PipelineViewportDepthClipControlCreateInfoExt = 1000355001,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_primitive_topology_list_restart`]
    PhysicalDevicePrimitiveTopologyListRestartFeaturesExt = 1000356000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::fuchsia_external_memory`]
    ImportMemoryZirconHandleInfoFuchsia = 1000364000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::fuchsia_external_memory`]
    MemoryZirconHandlePropertiesFuchsia = 1000364001,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::fuchsia_external_memory`]
    MemoryGetZirconHandleInfoFuchsia = 1000364002,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::fuchsia_external_semaphore`]
    ImportSemaphoreZirconHandleInfoFuchsia = 1000365000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::fuchsia_external_semaphore`]
    SemaphoreGetZirconHandleInfoFuchsia = 1000365001,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::fuchsia_buffer_collection`]
    BufferCollectionCreateInfoFuchsia = 1000366000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::fuchsia_buffer_collection`]
    ImportMemoryBufferCollectionFuchsia = 1000366001,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::fuchsia_buffer_collection`]
    BufferCollectionImageCreateInfoFuchsia = 1000366002,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::fuchsia_buffer_collection`]
    BufferCollectionPropertiesFuchsia = 1000366003,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::fuchsia_buffer_collection`]
    BufferConstraintsInfoFuchsia = 1000366004,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::fuchsia_buffer_collection`]
    BufferCollectionBufferCreateInfoFuchsia = 1000366005,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::fuchsia_buffer_collection`]
    ImageConstraintsInfoFuchsia = 1000366006,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::fuchsia_buffer_collection`]
    ImageFormatConstraintsInfoFuchsia = 1000366007,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::fuchsia_buffer_collection`]
    SysmemColorSpaceFuchsia = 1000366008,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::fuchsia_buffer_collection`]
    BufferCollectionConstraintsInfoFuchsia = 1000366009,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::huawei_subpass_shading`]
    SubpassShadingPipelineCreateInfoHuawei = 1000369000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::huawei_subpass_shading`]
    PhysicalDeviceSubpassShadingFeaturesHuawei = 1000369001,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::huawei_subpass_shading`]
    PhysicalDeviceSubpassShadingPropertiesHuawei = 1000369002,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::huawei_invocation_mask`]
    PhysicalDeviceInvocationMaskFeaturesHuawei = 1000370000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::nv_external_memory_rdma`]
    MemoryGetRemoteAddressInfoNv = 1000371000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::nv_external_memory_rdma`]
    PhysicalDeviceExternalMemoryRdmaFeaturesNv = 1000371001,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_extended_dynamic_state_2`]
    PhysicalDeviceExtendedDynamicState2FeaturesExt = 1000377000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::qnx_screen_surface`]
    ScreenSurfaceCreateInfoQnx = 1000378000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_color_write_enable`]
    PhysicalDeviceColorWriteEnableFeaturesExt = 1000381000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_color_write_enable`]
    PipelineColorWriteCreateInfoExt = 1000381001,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_image_view_min_lod`]
    PhysicalDeviceImageViewMinLodFeaturesExt = 1000391000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_image_view_min_lod`]
    ImageViewMinLodCreateInfoExt = 1000391001,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_multi_draw`]
    PhysicalDeviceMultiDrawFeaturesExt = 1000392000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_multi_draw`]
    PhysicalDeviceMultiDrawPropertiesExt = 1000392001,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_border_color_swizzle`]
    PhysicalDeviceBorderColorSwizzleFeaturesExt = 1000411000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_border_color_swizzle`]
    SamplerBorderColorComponentMappingCreateInfoExt = 1000411001,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_pageable_device_local_memory`]
    PhysicalDevicePageableDeviceLocalMemoryFeaturesExt = 1000412000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::valve_descriptor_set_host_mapping`]
    PhysicalDeviceDescriptorSetHostMappingFeaturesValve = 1000420000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::valve_descriptor_set_host_mapping`]
    DescriptorSetBindingReferenceValve = 1000420001,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::valve_descriptor_set_host_mapping`]
    DescriptorSetLayoutHostMappingInfoValve = 1000420002,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::qcom_fragment_density_map_offset`]
    PhysicalDeviceFragmentDensityMapOffsetFeaturesQcom = 1000425000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::qcom_fragment_density_map_offset`]
    PhysicalDeviceFragmentDensityMapOffsetPropertiesQcom = 1000425001,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::qcom_fragment_density_map_offset`]
    SubpassFragmentDensityMapOffsetEndInfoQcom = 1000425002,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::nv_linear_color_attachment`]
    PhysicalDeviceLinearColorAttachmentFeaturesNv = 1000430000,
}
impl const Default for StructureType {
    fn default() -> Self {
        Self::ApplicationInfo
    }
}
impl StructureType {
    ///Default empty value
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Gets the raw underlying value
    #[inline]
    pub const fn bits(&self) -> i32 {
        self as i32
    }
    ///Gets a value from a raw underlying value, unchecked and therefore unsafe
    #[inline]
    pub const unsafe fn from_bits(bits: i32) -> i32 {
        std::mem::transmute(bits)
    }
}
///[VkSubpassContents](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSubpassContents.html) - Specify how commands in the first subpass of a render pass are provided
///# C Specifications
///Possible values of [`CmdBeginRenderPass`]`::contents`, specifying
///how the commands in the first subpass will be provided, are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkSubpassContents {
///    VK_SUBPASS_CONTENTS_INLINE = 0,
///    VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS = 1,
///} VkSubpassContents;
///```
///# Description
/// - [`Inline`] specifies that the contents of the subpass will be recorded inline in the primary
///   command buffer, and secondary command buffers  **must**  not be executed within the subpass.
/// - [`SecondaryCommandBuffers`] specifies that the contents are recorded in secondary command
///   buffers that will be called from the primary command buffer, and [`CmdExecuteCommands`] is the
///   only valid command on the command buffer until [`CmdNextSubpass`] or [`CmdEndRenderPass`].
///# Related
/// - [`crate::vulkan1_0`]
/// - [`SubpassBeginInfo`]
/// - [`CmdBeginRenderPass`]
/// - [`CmdNextSubpass`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkSubpassContents")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
#[repr(i32)]
pub enum SubpassContents {
    ///[`Inline`] specifies that the contents of the
    ///subpass will be recorded inline in the primary command buffer, and
    ///secondary command buffers  **must**  not be executed within the subpass.
    Inline = 0,
    ///[`SecondaryCommandBuffers`] specifies that the
    ///contents are recorded in secondary command buffers that will be called
    ///from the primary command buffer, and [`CmdExecuteCommands`] is the
    ///only valid command on the command buffer until [`CmdNextSubpass`] or
    ///[`CmdEndRenderPass`].
    SecondaryCommandBuffers = 1,
}
impl const Default for SubpassContents {
    fn default() -> Self {
        Self::Inline
    }
}
impl SubpassContents {
    ///Default empty value
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Gets the raw underlying value
    #[inline]
    pub const fn bits(&self) -> i32 {
        self as i32
    }
    ///Gets a value from a raw underlying value, unchecked and therefore unsafe
    #[inline]
    pub const unsafe fn from_bits(bits: i32) -> i32 {
        std::mem::transmute(bits)
    }
}
///[VkResult](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkResult.html) - Vulkan command return codes
///# C Specifications
///While the core Vulkan API is not designed to capture incorrect usage, some
///circumstances still require return codes.
///Commands in Vulkan return their status via return codes that are in one of
///two categories:
/// - Successful completion codes are returned when a command needs to communicate success or status
///   information. All successful completion codes are non-negative values.
/// - Run time error codes are returned when a command needs to communicate a failure that could
///   only be detected at runtime. All runtime error codes are negative values.
///All return codes in Vulkan are reported via [`VulkanResultCodes`] return values.
///The possible codes are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkResult {
///    VK_SUCCESS = 0,
///    VK_NOT_READY = 1,
///    VK_TIMEOUT = 2,
///    VK_EVENT_SET = 3,
///    VK_EVENT_RESET = 4,
///    VK_INCOMPLETE = 5,
///    VK_ERROR_OUT_OF_HOST_MEMORY = -1,
///    VK_ERROR_OUT_OF_DEVICE_MEMORY = -2,
///    VK_ERROR_INITIALIZATION_FAILED = -3,
///    VK_ERROR_DEVICE_LOST = -4,
///    VK_ERROR_MEMORY_MAP_FAILED = -5,
///    VK_ERROR_LAYER_NOT_PRESENT = -6,
///    VK_ERROR_EXTENSION_NOT_PRESENT = -7,
///    VK_ERROR_FEATURE_NOT_PRESENT = -8,
///    VK_ERROR_INCOMPATIBLE_DRIVER = -9,
///    VK_ERROR_TOO_MANY_OBJECTS = -10,
///    VK_ERROR_FORMAT_NOT_SUPPORTED = -11,
///    VK_ERROR_FRAGMENTED_POOL = -12,
///    VK_ERROR_UNKNOWN = -13,
///  // Provided by VK_VERSION_1_1
///    VK_ERROR_OUT_OF_POOL_MEMORY = -1000069000,
///  // Provided by VK_VERSION_1_1
///    VK_ERROR_INVALID_EXTERNAL_HANDLE = -1000072003,
///  // Provided by VK_VERSION_1_2
///    VK_ERROR_FRAGMENTATION = -1000161000,
///  // Provided by VK_VERSION_1_2
///    VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS = -1000257000,
///  // Provided by VK_VERSION_1_3
///    VK_PIPELINE_COMPILE_REQUIRED = 1000297000,
///  // Provided by VK_KHR_surface
///    VK_ERROR_SURFACE_LOST_KHR = -1000000000,
///  // Provided by VK_KHR_surface
///    VK_ERROR_NATIVE_WINDOW_IN_USE_KHR = -1000000001,
///  // Provided by VK_KHR_swapchain
///    VK_SUBOPTIMAL_KHR = 1000001003,
///  // Provided by VK_KHR_swapchain
///    VK_ERROR_OUT_OF_DATE_KHR = -1000001004,
///  // Provided by VK_KHR_display_swapchain
///    VK_ERROR_INCOMPATIBLE_DISPLAY_KHR = -1000003001,
///  // Provided by VK_EXT_debug_report
///    VK_ERROR_VALIDATION_FAILED_EXT = -1000011001,
///  // Provided by VK_NV_glsl_shader
///    VK_ERROR_INVALID_SHADER_NV = -1000012000,
///  // Provided by VK_EXT_image_drm_format_modifier
///    VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT = -1000158000,
///  // Provided by VK_KHR_global_priority
///    VK_ERROR_NOT_PERMITTED_KHR = -1000174001,
///  // Provided by VK_EXT_full_screen_exclusive
///    VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT = -1000255000,
///  // Provided by VK_KHR_deferred_host_operations
///    VK_THREAD_IDLE_KHR = 1000268000,
///  // Provided by VK_KHR_deferred_host_operations
///    VK_THREAD_DONE_KHR = 1000268001,
///  // Provided by VK_KHR_deferred_host_operations
///    VK_OPERATION_DEFERRED_KHR = 1000268002,
///  // Provided by VK_KHR_deferred_host_operations
///    VK_OPERATION_NOT_DEFERRED_KHR = 1000268003,
///  // Provided by VK_KHR_maintenance1
///    VK_ERROR_OUT_OF_POOL_MEMORY_KHR = VK_ERROR_OUT_OF_POOL_MEMORY,
///  // Provided by VK_KHR_external_memory
///    VK_ERROR_INVALID_EXTERNAL_HANDLE_KHR = VK_ERROR_INVALID_EXTERNAL_HANDLE,
///  // Provided by VK_EXT_descriptor_indexing
///    VK_ERROR_FRAGMENTATION_EXT = VK_ERROR_FRAGMENTATION,
///  // Provided by VK_EXT_global_priority
///    VK_ERROR_NOT_PERMITTED_EXT = VK_ERROR_NOT_PERMITTED_KHR,
///  // Provided by VK_EXT_buffer_device_address
///    VK_ERROR_INVALID_DEVICE_ADDRESS_EXT = VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS,
///  // Provided by VK_KHR_buffer_device_address
///    VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS_KHR = VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS,
///  // Provided by VK_EXT_pipeline_creation_cache_control
///    VK_PIPELINE_COMPILE_REQUIRED_EXT = VK_PIPELINE_COMPILE_REQUIRED,
///  // Provided by VK_EXT_pipeline_creation_cache_control
///    VK_ERROR_PIPELINE_COMPILE_REQUIRED_EXT = VK_PIPELINE_COMPILE_REQUIRED,
///} VkResult;
///```
///# Description
/// - [`Success`] Command successfully completed
/// - [`NotReady`] A fence or query has not yet completed
/// - [`Timeout`] A wait operation has not completed in the specified time
/// - [`EventSet`] An event is signaled
/// - [`EventReset`] An event is unsignaled
/// - [`Incomplete`] A return array was too small for the result
/// - [`SuboptimalKhr`] A swapchain no longer matches the surface properties exactly, but  **can**
///   still be used to present to the surface successfully.
/// - [`ThreadIdleKhr`] A deferred operation is not complete but there is currently no work for this
///   thread to do at the time of this call.
/// - [`ThreadDoneKhr`] A deferred operation is not complete but there is no work remaining to
///   assign to additional threads.
/// - [`OperationDeferredKhr`] A deferred operation was requested and at least some of the work was
///   deferred.
/// - [`OperationNotDeferredKhr`] A deferred operation was requested and no operations were
///   deferred.
/// - [`PipelineCompileRequired`] A requested pipeline creation would have required compilation, but
///   the application requested compilation to not be performed.
///
/// - [`ErrorOutOfHostMemory`] A host memory allocation has failed.
/// - [`ErrorOutOfDeviceMemory`] A device memory allocation has failed.
/// - [`ErrorInitializationFailed`] Initialization of an object could not be completed for
///   implementation-specific reasons.
/// - [`ErrorDeviceLost`] The logical or physical device has been lost. See [Lost Device](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#devsandqueues-lost-device)
/// - [`ErrorMemoryMapFailed`] Mapping of a memory object has failed.
/// - [`ErrorLayerNotPresent`] A requested layer is not present or could not be loaded.
/// - [`ErrorExtensionNotPresent`] A requested extension is not supported.
/// - [`ErrorFeatureNotPresent`] A requested feature is not supported.
/// - [`ErrorIncompatibleDriver`] The requested version of Vulkan is not supported by the driver or
///   is otherwise incompatible for implementation-specific reasons.
/// - [`ErrorTooManyObjects`] Too many objects of the type have already been created.
/// - [`ErrorFormatNotSupported`] A requested format is not supported on this device.
/// - [`ErrorFragmentedPool`] A pool allocation has failed due to fragmentation of the pool’s
///   memory. This  **must**  only be returned if no attempt to allocate host or device memory was
///   made to accommodate the new allocation. This  **should**  be returned in preference to
///   [`ErrorOutOfPoolMemory`], but only if the implementation is certain that the pool allocation
///   failure was due to fragmentation.
/// - [`ErrorSurfaceLostKhr`] A surface is no longer available.
/// - [`ErrorNativeWindowInUseKhr`] The requested window is already in use by Vulkan or another API
///   in a manner which prevents it from being used again.
/// - [`ErrorOutOfDateKhr`] A surface has changed in such a way that it is no longer compatible with
///   the swapchain, and further presentation requests using the swapchain will fail. Applications
///   **must**  query the new surface properties and recreate their swapchain if they wish to
///   continue presenting to the surface.
/// - [`ErrorIncompatibleDisplayKhr`] The display used by a swapchain does not use the same
///   presentable image layout, or is incompatible in a way that prevents sharing an image.
/// - [`ErrorInvalidShaderNv`] One or more shaders failed to compile or link. More details are
///   reported back to the application via `[`VK_EXT_debug_report`]` if enabled.
/// - [`ErrorOutOfPoolMemory`] A pool memory allocation has failed. This  **must**  only be returned
///   if no attempt to allocate host or device memory was made to accommodate the new allocation. If
///   the failure was definitely due to fragmentation of the pool, [`ErrorFragmentedPool`]
///   **should**  be returned instead.
/// - [`ErrorInvalidExternalHandle`] An external handle is not a valid handle of the specified type.
/// - [`ErrorFragmentation`] A descriptor pool creation has failed due to fragmentation.
/// - [`ErrorInvalidDeviceAddressExt`] A buffer creation failed because the requested address is not
///   available.
/// - [`ErrorInvalidOpaqueCaptureAddress`] A buffer creation or memory allocation failed because the
///   requested address is not available. A shader group handle assignment failed because the
///   requested shader group handle information is no longer valid.
/// - [`ErrorFullScreenExclusiveModeLostExt`] An operation on a swapchain created with
///   `VK_FULL_SCREEN_EXCLUSIVE_APPLICATION_CONTROLLED_EXT` failed as it did not have exlusive
///   full-screen access. This  **may**  occur due to implementation-dependent reasons, outside of
///   the application’s control.
/// - [`ErrorUnknown`] An unknown error has occurred; either the application has provided invalid
///   input, or an implementation failure has occurred.
///If a command returns a runtime error, unless otherwise specified any output
///parameters will have undefined contents, except that if the output
///parameter is a structure with `sType` and `pNext` fields, those
///fields will be unmodified.
///Any structures chained from `pNext` will also have undefined contents,
///except that `sType` and `pNext` will be unmodified.`VK_ERROR_OUT_OF_*_MEMORY` errors do not
/// modify any currently existing
///Vulkan objects.
///Objects that have already been successfully created  **can**  still be used by
///the application.[`ErrorUnknown`] will be returned by an implementation when an
///unexpected error occurs that cannot be attributed to valid behavior of the
///application and implementation.
///Under these conditions, it  **may**  be returned from any command returning a
///[`VulkanResultCodes`].Performance-critical commands generally do not have return codes.
///If a runtime error occurs in such commands, the implementation will defer
///reporting the error until a specified point.
///For commands that record into command buffers (`vkCmd*`) runtime errors
///are reported by [`EndCommandBuffer`].
///# Related
/// - [`crate::vulkan1_0`]
/// - [`PresentInfoKHR`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkResult")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
#[repr(i32)]
pub enum VulkanResultCodes {
    ///[`Success`] Command successfully completed
    Success = 0,
    ///[`NotReady`] A fence or query has not yet completed
    NotReady = 1,
    ///[`Timeout`] A wait operation has not completed in the specified
    ///time
    Timeout = 2,
    ///[`EventSet`] An event is signaled
    EventSet = 3,
    ///[`EventReset`] An event is unsignaled
    EventReset = 4,
    ///[`Incomplete`] A return array was too small for the result
    Incomplete = 5,
    ///[`ErrorOutOfHostMemory`] A host memory allocation has failed.
    ErrorOutOfHostMemory = -1,
    ///[`ErrorOutOfDeviceMemory`] A device memory allocation has
    ///failed.
    ErrorOutOfDeviceMemory = -2,
    ///[`ErrorInitializationFailed`] Initialization of an object could
    ///not be completed for implementation-specific reasons.
    ErrorInitializationFailed = -3,
    ///[`ErrorDeviceLost`] The logical or physical device has been lost.
    ///See [Lost Device](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#devsandqueues-lost-device)
    ErrorDeviceLost = -4,
    ///[`ErrorMemoryMapFailed`] Mapping of a memory object has failed.
    ErrorMemoryMapFailed = -5,
    ///[`ErrorLayerNotPresent`] A requested layer is not present or
    ///could not be loaded.
    ErrorLayerNotPresent = -6,
    ///[`ErrorExtensionNotPresent`] A requested extension is not
    ///supported.
    ErrorExtensionNotPresent = -7,
    ///[`ErrorFeatureNotPresent`] A requested feature is not supported.
    ErrorFeatureNotPresent = -8,
    ///[`ErrorIncompatibleDriver`] The requested version of Vulkan is
    ///not supported by the driver or is otherwise incompatible for
    ///implementation-specific reasons.
    ErrorIncompatibleDriver = -9,
    ///[`ErrorTooManyObjects`] Too many objects of the type have
    ///already been created.
    ErrorTooManyObjects = -10,
    ///[`ErrorFormatNotSupported`] A requested format is not supported
    ///on this device.
    ErrorFormatNotSupported = -11,
    ///[`ErrorFragmentedPool`] A pool allocation has failed due to
    ///fragmentation of the pool’s memory.
    ///This  **must**  only be returned if no attempt to allocate host or device
    ///memory was made to accommodate the new allocation.
    ///This  **should**  be returned in preference to
    ///[`ErrorOutOfPoolMemory`], but only if the implementation is
    ///certain that the pool allocation failure was due to fragmentation.
    ErrorFragmentedPool = -12,
    ///[`ErrorUnknown`] An unknown error has occurred; either the
    ///application has provided invalid input, or an implementation failure has
    ///occurred.
    ErrorUnknown = -13,
    ///[`ErrorOutOfPoolMemory`] A pool memory allocation has failed.
    ///This  **must**  only be returned if no attempt to allocate host or device
    ///memory was made to accommodate the new allocation.
    ///If the failure was definitely due to fragmentation of the pool,
    ///[`ErrorFragmentedPool`] **should**  be returned instead.
    ///
    ///Provided by [`crate::vulkan1_1`]
    ErrorOutOfPoolMemory = -1000069000,
    ///[`ErrorInvalidExternalHandle`] An external handle is not a valid
    ///handle of the specified type.
    ///
    ///Provided by [`crate::vulkan1_1`]
    ErrorInvalidExternalHandle = -1000072003,
    ///[`ErrorFragmentation`] A descriptor pool creation has failed due
    ///to fragmentation.
    ///
    ///Provided by [`crate::vulkan1_2`]
    ErrorFragmentation = -1000161000,
    ///[`ErrorInvalidOpaqueCaptureAddress`] A buffer creation
    ///or memory allocation
    ///failed because the requested address is not available.
    ///A shader group handle assignment failed because the requested shader
    ///group handle information is no longer valid.
    ///
    ///Provided by [`crate::vulkan1_2`]
    ErrorInvalidOpaqueCaptureAddress = -1000257000,
    ///[`PipelineCompileRequired`] A requested pipeline creation would
    ///have required compilation, but the application requested compilation to
    ///not be performed.
    ///
    ///Provided by [`crate::vulkan1_3`]
    PipelineCompileRequired = 1000297000,
    ///[`ErrorSurfaceLostKhr`] A surface is no longer available.
    ///
    ///Provided by [`crate::extensions::khr_surface`]
    ErrorSurfaceLostKhr = -1000000000,
    ///[`ErrorNativeWindowInUseKhr`] The requested window is already
    ///in use by Vulkan or another API in a manner which prevents it from being
    ///used again.
    ///
    ///Provided by [`crate::extensions::khr_surface`]
    ErrorNativeWindowInUseKhr = -1000000001,
    ///[`SuboptimalKhr`] A swapchain no longer matches the surface
    ///properties exactly, but  **can**  still be used to present to the surface
    ///successfully.
    ///
    ///Provided by [`crate::extensions::khr_swapchain`]
    SuboptimalKhr = 1000001003,
    ///[`ErrorOutOfDateKhr`] A surface has changed in such a way that
    ///it is no longer compatible with the swapchain, and further presentation
    ///requests using the swapchain will fail.
    ///Applications  **must**  query the new surface properties and recreate their
    ///swapchain if they wish to continue presenting to the surface.
    ///
    ///Provided by [`crate::extensions::khr_swapchain`]
    ErrorOutOfDateKhr = -1000001004,
    ///[`ErrorIncompatibleDisplayKhr`] The display used by a swapchain
    ///does not use the same presentable image layout, or is incompatible in a
    ///way that prevents sharing an image.
    ///
    ///Provided by [`crate::extensions::khr_display_swapchain`]
    ErrorIncompatibleDisplayKhr = -1000003001,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_debug_report`]
    ErrorValidationFailedExt = -1000011001,
    ///[`ErrorInvalidShaderNv`] One or more shaders failed to compile
    ///or link.
    ///More details are reported back to the application via
    ///`[`VK_EXT_debug_report`]` if enabled.
    ///
    ///Provided by [`crate::extensions::nv_glsl_shader`]
    ErrorInvalidShaderNv = -1000012000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_image_drm_format_modifier`]
    ErrorInvalidDrmFormatModifierPlaneLayoutExt = -1000158000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_global_priority`]
    ErrorNotPermittedKhr = -1000174001,
    ///[`ErrorFullScreenExclusiveModeLostExt`] An operation on a
    ///swapchain created with
    ///`VK_FULL_SCREEN_EXCLUSIVE_APPLICATION_CONTROLLED_EXT` failed as it
    ///did not have exlusive full-screen access.
    ///This  **may**  occur due to implementation-dependent reasons, outside of the
    ///application’s control.
    ///
    ///Provided by [`crate::extensions::ext_full_screen_exclusive`]
    ErrorFullScreenExclusiveModeLostExt = -1000255000,
    ///[`ThreadIdleKhr`] A deferred operation is not complete but there
    ///is currently no work for this thread to do at the time of this call.
    ///
    ///Provided by [`crate::extensions::khr_deferred_host_operations`]
    ThreadIdleKhr = 1000268000,
    ///[`ThreadDoneKhr`] A deferred operation is not complete but there
    ///is no work remaining to assign to additional threads.
    ///
    ///Provided by [`crate::extensions::khr_deferred_host_operations`]
    ThreadDoneKhr = 1000268001,
    ///[`OperationDeferredKhr`] A deferred operation was requested and
    ///at least some of the work was deferred.
    ///
    ///Provided by [`crate::extensions::khr_deferred_host_operations`]
    OperationDeferredKhr = 1000268002,
    ///[`OperationNotDeferredKhr`] A deferred operation was requested
    ///and no operations were deferred.
    ///
    ///Provided by [`crate::extensions::khr_deferred_host_operations`]
    OperationNotDeferredKhr = 1000268003,
}
impl const Default for VulkanResultCodes {
    fn default() -> Self {
        Self::Success
    }
}
impl VulkanResultCodes {
    ///Default empty value
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Gets the raw underlying value
    #[inline]
    pub const fn bits(&self) -> i32 {
        self as i32
    }
    ///Gets a value from a raw underlying value, unchecked and therefore unsafe
    #[inline]
    pub const unsafe fn from_bits(bits: i32) -> i32 {
        std::mem::transmute(bits)
    }
}
///[VkDynamicState](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDynamicState.html) - Indicate which dynamic state is taken from dynamic state commands
///# C Specifications
///The source of different pieces of dynamic state is specified by the
///[`PipelineDynamicStateCreateInfo::dynamic_states`] property of the
///currently active pipeline, each of whose elements  **must**  be one of the
///values:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkDynamicState {
///    VK_DYNAMIC_STATE_VIEWPORT = 0,
///    VK_DYNAMIC_STATE_SCISSOR = 1,
///    VK_DYNAMIC_STATE_LINE_WIDTH = 2,
///    VK_DYNAMIC_STATE_DEPTH_BIAS = 3,
///    VK_DYNAMIC_STATE_BLEND_CONSTANTS = 4,
///    VK_DYNAMIC_STATE_DEPTH_BOUNDS = 5,
///    VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK = 6,
///    VK_DYNAMIC_STATE_STENCIL_WRITE_MASK = 7,
///    VK_DYNAMIC_STATE_STENCIL_REFERENCE = 8,
///  // Provided by VK_VERSION_1_3
///    VK_DYNAMIC_STATE_CULL_MODE = 1000267000,
///  // Provided by VK_VERSION_1_3
///    VK_DYNAMIC_STATE_FRONT_FACE = 1000267001,
///  // Provided by VK_VERSION_1_3
///    VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY = 1000267002,
///  // Provided by VK_VERSION_1_3
///    VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT = 1000267003,
///  // Provided by VK_VERSION_1_3
///    VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT = 1000267004,
///  // Provided by VK_VERSION_1_3
///    VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE = 1000267005,
///  // Provided by VK_VERSION_1_3
///    VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE = 1000267006,
///  // Provided by VK_VERSION_1_3
///    VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE = 1000267007,
///  // Provided by VK_VERSION_1_3
///    VK_DYNAMIC_STATE_DEPTH_COMPARE_OP = 1000267008,
///  // Provided by VK_VERSION_1_3
///    VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE = 1000267009,
///  // Provided by VK_VERSION_1_3
///    VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE = 1000267010,
///  // Provided by VK_VERSION_1_3
///    VK_DYNAMIC_STATE_STENCIL_OP = 1000267011,
///  // Provided by VK_VERSION_1_3
///    VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE = 1000377001,
///  // Provided by VK_VERSION_1_3
///    VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE = 1000377002,
///  // Provided by VK_VERSION_1_3
///    VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE = 1000377004,
///  // Provided by VK_NV_clip_space_w_scaling
///    VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV = 1000087000,
///  // Provided by VK_EXT_discard_rectangles
///    VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT = 1000099000,
///  // Provided by VK_EXT_sample_locations
///    VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT = 1000143000,
///  // Provided by VK_KHR_ray_tracing_pipeline
///    VK_DYNAMIC_STATE_RAY_TRACING_PIPELINE_STACK_SIZE_KHR = 1000347000,
///  // Provided by VK_NV_shading_rate_image
///    VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV = 1000164004,
///  // Provided by VK_NV_shading_rate_image
///    VK_DYNAMIC_STATE_VIEWPORT_COARSE_SAMPLE_ORDER_NV = 1000164006,
///  // Provided by VK_NV_scissor_exclusive
///    VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_NV = 1000205001,
///  // Provided by VK_KHR_fragment_shading_rate
///    VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR = 1000226000,
///  // Provided by VK_EXT_line_rasterization
///    VK_DYNAMIC_STATE_LINE_STIPPLE_EXT = 1000259000,
///  // Provided by VK_EXT_vertex_input_dynamic_state
///    VK_DYNAMIC_STATE_VERTEX_INPUT_EXT = 1000352000,
///  // Provided by VK_EXT_extended_dynamic_state2
///    VK_DYNAMIC_STATE_PATCH_CONTROL_POINTS_EXT = 1000377000,
///  // Provided by VK_EXT_extended_dynamic_state2
///    VK_DYNAMIC_STATE_LOGIC_OP_EXT = 1000377003,
///  // Provided by VK_EXT_color_write_enable
///    VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT = 1000381000,
///  // Provided by VK_EXT_extended_dynamic_state
///    VK_DYNAMIC_STATE_CULL_MODE_EXT = VK_DYNAMIC_STATE_CULL_MODE,
///  // Provided by VK_EXT_extended_dynamic_state
///    VK_DYNAMIC_STATE_FRONT_FACE_EXT = VK_DYNAMIC_STATE_FRONT_FACE,
///  // Provided by VK_EXT_extended_dynamic_state
///    VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY_EXT = VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY,
///  // Provided by VK_EXT_extended_dynamic_state
///    VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT_EXT = VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT,
///  // Provided by VK_EXT_extended_dynamic_state
///    VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT_EXT = VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT,
///  // Provided by VK_EXT_extended_dynamic_state
///    VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE_EXT =
/// VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE,
///  // Provided by VK_EXT_extended_dynamic_state
///    VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE_EXT = VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE,
///  // Provided by VK_EXT_extended_dynamic_state
///    VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE_EXT = VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE,
///  // Provided by VK_EXT_extended_dynamic_state
///    VK_DYNAMIC_STATE_DEPTH_COMPARE_OP_EXT = VK_DYNAMIC_STATE_DEPTH_COMPARE_OP,
///  // Provided by VK_EXT_extended_dynamic_state
///    VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE_EXT = VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE,
///  // Provided by VK_EXT_extended_dynamic_state
///    VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE_EXT = VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE,
///  // Provided by VK_EXT_extended_dynamic_state
///    VK_DYNAMIC_STATE_STENCIL_OP_EXT = VK_DYNAMIC_STATE_STENCIL_OP,
///  // Provided by VK_EXT_extended_dynamic_state2
///    VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE_EXT = VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE,
///  // Provided by VK_EXT_extended_dynamic_state2
///    VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE_EXT = VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE,
///  // Provided by VK_EXT_extended_dynamic_state2
///    VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE_EXT = VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE,
///} VkDynamicState;
///```
///# Description
/// - [`Viewport`] specifies that the `pViewports` state in [`PipelineViewportStateCreateInfo`] will
///   be ignored and  **must**  be set dynamically with [`CmdSetViewport`] before any drawing
///   commands. The number of viewports used by a pipeline is still specified by the `viewportCount`
///   member of [`PipelineViewportStateCreateInfo`].
/// - [`Scissor`] specifies that the `pScissors` state in [`PipelineViewportStateCreateInfo`] will
///   be ignored and  **must**  be set dynamically with [`CmdSetScissor`] before any drawing
///   commands. The number of scissor rectangles used by a pipeline is still specified by the
///   `scissorCount` member of [`PipelineViewportStateCreateInfo`].
/// - [`LineWidth`] specifies that the `lineWidth` state in [`PipelineRasterizationStateCreateInfo`]
///   will be ignored and  **must**  be set dynamically with [`CmdSetLineWidth`] before any drawing
///   commands that generate line primitives for the rasterizer.
/// - [`DepthBias`] specifies that the `depthBiasConstantFactor`, `depthBiasClamp` and
///   `depthBiasSlopeFactor` states in [`PipelineRasterizationStateCreateInfo`] will be ignored and
///   **must**  be set dynamically with [`CmdSetDepthBias`] before any draws are performed with
///   `depthBiasEnable` in [`PipelineRasterizationStateCreateInfo`] set to [`TRUE`].
/// - [`BlendConstants`] specifies that the `blendConstants` state in
///   [`PipelineColorBlendStateCreateInfo`] will be ignored and  **must**  be set dynamically with
///   [`CmdSetBlendConstants`] before any draws are performed with a pipeline state with
///   [`PipelineColorBlendAttachmentState`] member `blendEnable` set to [`TRUE`] and any of the
///   blend functions using a constant blend color.
/// - [`DepthBounds`] specifies that the `minDepthBounds` and `maxDepthBounds` states of
///   [`PipelineDepthStencilStateCreateInfo`] will be ignored and  **must**  be set dynamically with
///   [`CmdSetDepthBounds`] before any draws are performed with a pipeline state with
///   [`PipelineDepthStencilStateCreateInfo`] member `depthBoundsTestEnable` set to [`TRUE`].
/// - [`StencilCompareMask`] specifies that the `compareMask` state in
///   [`PipelineDepthStencilStateCreateInfo`] for both `front` and `back` will be ignored and
///   **must**  be set dynamically with [`CmdSetStencilCompareMask`] before any draws are performed
///   with a pipeline state with [`PipelineDepthStencilStateCreateInfo`] member `stencilTestEnable`
///   set to [`TRUE`]
/// - [`StencilWriteMask`] specifies that the `writeMask` state in
///   [`PipelineDepthStencilStateCreateInfo`] for both `front` and `back` will be ignored and
///   **must**  be set dynamically with [`CmdSetStencilWriteMask`] before any draws are performed
///   with a pipeline state with [`PipelineDepthStencilStateCreateInfo`] member `stencilTestEnable`
///   set to [`TRUE`]
/// - [`StencilReference`] specifies that the `reference` state in
///   [`PipelineDepthStencilStateCreateInfo`] for both `front` and `back` will be ignored and
///   **must**  be set dynamically with [`CmdSetStencilReference`] before any draws are performed
///   with a pipeline state with [`PipelineDepthStencilStateCreateInfo`] member `stencilTestEnable`
///   set to [`TRUE`]
/// - [`ViewportWScalingNv`] specifies that the `pViewportScalings` state in
///   [`PipelineViewportWScalingStateCreateInfoNV`] will be ignored and  **must**  be set
///   dynamically with [`CmdSetViewportWScalingNV`] before any draws are performed with a pipeline
///   state with [`PipelineViewportWScalingStateCreateInfoNV`] member `viewportScalingEnable` set to
///   [`TRUE`]
/// - [`DiscardRectangleExt`] specifies that the `pDiscardRectangles` state in
///   [`PipelineDiscardRectangleStateCreateInfoEXT`] will be ignored and  **must**  be set
///   dynamically with [`CmdSetDiscardRectangleEXT`] before any draw or clear commands. The
///   [`DiscardRectangleModeEXT`] and the number of active discard rectangles is still specified by
///   the `discardRectangleMode` and `discardRectangleCount` members of
///   [`PipelineDiscardRectangleStateCreateInfoEXT`].
/// - [`SampleLocationsExt`] specifies that the `sampleLocationsInfo` state in
///   [`PipelineSampleLocationsStateCreateInfoEXT`] will be ignored and  **must**  be set
///   dynamically with [`CmdSetSampleLocationsEXT`] before any draw or clear commands. Enabling
///   custom sample locations is still indicated by the `sampleLocationsEnable` member of
///   [`PipelineSampleLocationsStateCreateInfoEXT`].
/// - [`ExclusiveScissorNv`] specifies that the `pExclusiveScissors` state in
///   [`PipelineViewportExclusiveScissorStateCreateInfoNV`] will be ignored and  **must**  be set
///   dynamically with [`CmdSetExclusiveScissorNV`] before any drawing commands. The number of
///   exclusive scissor rectangles used by a pipeline is still specified by the
///   `exclusiveScissorCount` member of [`PipelineViewportExclusiveScissorStateCreateInfoNV`].
/// - [`ViewportShadingRatePaletteNv`] specifies that the `pShadingRatePalettes` state in
///   [`PipelineViewportShadingRateImageStateCreateInfoNV`] will be ignored and  **must**  be set
///   dynamically with [`CmdSetViewportShadingRatePaletteNV`] before any drawing commands.
/// - [`ViewportCoarseSampleOrderNv`] specifies that the coarse sample order state in
///   [`PipelineViewportCoarseSampleOrderStateCreateInfoNV`] will be ignored and  **must**  be set
///   dynamically with [`CmdSetCoarseSampleOrderNV`] before any drawing commands.
/// - [`LineStippleExt`] specifies that the `lineStippleFactor` and `lineStipplePattern` state in
///   [`PipelineRasterizationLineStateCreateInfoEXT`] will be ignored and  **must**  be set
///   dynamically with [`CmdSetLineStippleEXT`] before any draws are performed with a pipeline state
///   with [`PipelineRasterizationLineStateCreateInfoEXT`] member `stippledLineEnable` set to
///   [`TRUE`].
/// - [`CullMode`] specifies that the `cullMode` state in [`PipelineRasterizationStateCreateInfo`]
///   will be ignored and  **must**  be set dynamically with [`CmdSetCullMode`] before any drawing
///   commands.
/// - [`FrontFace`] specifies that the `frontFace` state in [`PipelineRasterizationStateCreateInfo`]
///   will be ignored and  **must**  be set dynamically with [`CmdSetFrontFace`] before any drawing
///   commands.
/// - [`PrimitiveTopology`] specifies that the `topology` state in [`PipelineInputAssemblyStateCreateInfo`] only specifies the [topology class](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#drawing-primitive-topology-class), and the specific topology order and adjacency  **must**  be set dynamically with [`CmdSetPrimitiveTopology`] before any drawing commands.
/// - [`ViewportWithCount`] specifies that the `viewportCount` and `pViewports` state in
///   [`PipelineViewportStateCreateInfo`] will be ignored and  **must**  be set dynamically with
///   [`CmdSetViewportWithCount`] before any draw call.
/// - [`ScissorWithCount`] specifies that the `scissorCount` and `pScissors` state in
///   [`PipelineViewportStateCreateInfo`] will be ignored and  **must**  be set dynamically with
///   [`CmdSetScissorWithCount`] before any draw call.
/// - [`VertexInputBindingStride`] specifies that the `stride` state in
///   [`VertexInputBindingDescription`] will be ignored and  **must**  be set dynamically with
///   [`CmdBindVertexBuffers2`] before any draw call.
/// - [`DepthTestEnable`] specifies that the `depthTestEnable` state in
///   [`PipelineDepthStencilStateCreateInfo`] will be ignored and  **must**  be set dynamically with
///   [`CmdSetDepthTestEnable`] before any draw call.
/// - [`DepthWriteEnable`] specifies that the `depthWriteEnable` state in
///   [`PipelineDepthStencilStateCreateInfo`] will be ignored and  **must**  be set dynamically with
///   [`CmdSetDepthWriteEnable`] before any draw call.
/// - [`DepthCompareOp`] specifies that the `depthCompareOp` state in
///   [`PipelineDepthStencilStateCreateInfo`] will be ignored and  **must**  be set dynamically with
///   [`CmdSetDepthCompareOp`] before any draw call.
/// - [`DepthBoundsTestEnable`] specifies that the `depthBoundsTestEnable` state in
///   [`PipelineDepthStencilStateCreateInfo`] will be ignored and  **must**  be set dynamically with
///   [`CmdSetDepthBoundsTestEnable`] before any draw call.
/// - [`StencilTestEnable`] specifies that the `stencilTestEnable` state in
///   [`PipelineDepthStencilStateCreateInfo`] will be ignored and  **must**  be set dynamically with
///   [`CmdSetStencilTestEnable`] before any draw call.
/// - [`StencilOp`] specifies that the `failOp`, `passOp`, `depthFailOp`, and `compareOp` states in
///   [`PipelineDepthStencilStateCreateInfo`] for both `front` and `back` will be ignored and
///   **must**  be set dynamically with [`CmdSetStencilOp`] before any draws are performed with a
///   pipeline state with [`PipelineDepthStencilStateCreateInfo`] member `stencilTestEnable` set to
///   [`TRUE`]
/// - [`PatchControlPointsExt`] specifies that the `patchControlPoints` state in
///   [`PipelineTessellationStateCreateInfo`] will be ignored and  **must**  be set dynamically with
///   [`CmdSetPatchControlPointsEXT`] before any drawing commands.
/// - [`RasterizerDiscardEnable`] specifies that the `rasterizerDiscardEnable` state in
///   [`PipelineRasterizationStateCreateInfo`] will be ignored and  **must**  be set dynamically
///   with [`CmdSetRasterizerDiscardEnable`] before any drawing commands.
/// - [`DepthBiasEnable`] specifies that the `depthBiasEnable` state in
///   [`PipelineRasterizationStateCreateInfo`] will be ignored and  **must**  be set dynamically
///   with [`CmdSetDepthBiasEnable`] before any drawing commands.
/// - [`LogicOpExt`] specifies that the `logicOp` state in [`PipelineColorBlendStateCreateInfo`]
///   will be ignored and  **must**  be set dynamically with [`CmdSetLogicOpEXT`] before any drawing
///   commands.
/// - [`PrimitiveRestartEnable`] specifies that the `primitiveRestartEnable` state in
///   [`PipelineInputAssemblyStateCreateInfo`] will be ignored and  **must**  be set dynamically
///   with [`CmdSetPrimitiveRestartEnable`] before any drawing commands.
/// - [`FragmentShadingRateKhr`] specifies that state in
///   [`PipelineFragmentShadingRateStateCreateInfoKHR`] and
///   [`PipelineFragmentShadingRateEnumStateCreateInfoNV`] will be ignored and  **must**  be set
///   dynamically with [`CmdSetFragmentShadingRateKHR`] or [`CmdSetFragmentShadingRateEnumNV`]
///   before any drawing commands.
/// - [`RayTracingPipelineStackSizeKhr`] specifies that the default stack size computation for the
///   pipeline will be ignored and  **must**  be set dynamically with
///   [`CmdSetRayTracingPipelineStackSizeKHR`] before any ray tracing calls are performed.
/// - [`VertexInputExt`] specifies that the `pVertexInputState` state will be ignored and  **must**
///   be set dynamically with [`CmdSetVertexInputEXT`] before any drawing commands
/// - [`ColorWriteEnableExt`] specifies that the `pColorWriteEnables` state in
///   [`PipelineColorWriteCreateInfoEXT`] will be ignored and  **must**  be set dynamically with
///   [`CmdSetColorWriteEnableEXT`] before any draw call.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`PipelineDynamicStateCreateInfo`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkDynamicState")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
#[repr(i32)]
pub enum DynamicState {
    ///[`Viewport`] specifies that the `pViewports`
    ///state in [`PipelineViewportStateCreateInfo`] will be ignored and
    /// **must**  be set dynamically with [`CmdSetViewport`] before any drawing
    ///commands.
    ///The number of viewports used by a pipeline is still specified by the
    ///`viewportCount` member of [`PipelineViewportStateCreateInfo`].
    Viewport = 0,
    ///[`Scissor`] specifies that the `pScissors` state
    ///in [`PipelineViewportStateCreateInfo`] will be ignored and  **must**  be
    ///set dynamically with [`CmdSetScissor`] before any drawing commands.
    ///The number of scissor rectangles used by a pipeline is still specified
    ///by the `scissorCount` member of
    ///[`PipelineViewportStateCreateInfo`].
    Scissor = 1,
    ///[`LineWidth`] specifies that the `lineWidth`
    ///state in [`PipelineRasterizationStateCreateInfo`] will be ignored
    ///and  **must**  be set dynamically with [`CmdSetLineWidth`] before any
    ///drawing commands that generate line primitives for the rasterizer.
    LineWidth = 2,
    ///[`DepthBias`] specifies that the
    ///`depthBiasConstantFactor`, `depthBiasClamp` and
    ///`depthBiasSlopeFactor` states in
    ///[`PipelineRasterizationStateCreateInfo`] will be ignored and  **must**
    ///be set dynamically with [`CmdSetDepthBias`] before any draws are
    ///performed with `depthBiasEnable` in
    ///[`PipelineRasterizationStateCreateInfo`] set to [`TRUE`].
    DepthBias = 3,
    ///[`BlendConstants`] specifies that the
    ///`blendConstants` state in [`PipelineColorBlendStateCreateInfo`]
    ///will be ignored and  **must**  be set dynamically with
    ///[`CmdSetBlendConstants`] before any draws are performed with a
    ///pipeline state with [`PipelineColorBlendAttachmentState`] member
    ///`blendEnable` set to [`TRUE`] and any of the blend functions
    ///using a constant blend color.
    BlendConstants = 4,
    ///[`DepthBounds`] specifies that the
    ///`minDepthBounds` and `maxDepthBounds` states of
    ///[`PipelineDepthStencilStateCreateInfo`] will be ignored and  **must**  be
    ///set dynamically with [`CmdSetDepthBounds`] before any draws are
    ///performed with a pipeline state with
    ///[`PipelineDepthStencilStateCreateInfo`] member
    ///`depthBoundsTestEnable` set to [`TRUE`].
    DepthBounds = 5,
    ///[`StencilCompareMask`] specifies that the
    ///`compareMask` state in [`PipelineDepthStencilStateCreateInfo`]
    ///for both `front` and `back` will be ignored and  **must**  be set
    ///dynamically with [`CmdSetStencilCompareMask`] before any draws are
    ///performed with a pipeline state with
    ///[`PipelineDepthStencilStateCreateInfo`] member
    ///`stencilTestEnable` set to [`TRUE`]
    StencilCompareMask = 6,
    ///[`StencilWriteMask`] specifies that the
    ///`writeMask` state in [`PipelineDepthStencilStateCreateInfo`] for
    ///both `front` and `back` will be ignored and  **must**  be set
    ///dynamically with [`CmdSetStencilWriteMask`] before any draws are
    ///performed with a pipeline state with
    ///[`PipelineDepthStencilStateCreateInfo`] member
    ///`stencilTestEnable` set to [`TRUE`]
    StencilWriteMask = 7,
    ///[`StencilReference`] specifies that the
    ///`reference` state in [`PipelineDepthStencilStateCreateInfo`] for
    ///both `front` and `back` will be ignored and  **must**  be set
    ///dynamically with [`CmdSetStencilReference`] before any draws are
    ///performed with a pipeline state with
    ///[`PipelineDepthStencilStateCreateInfo`] member
    ///`stencilTestEnable` set to [`TRUE`]
    StencilReference = 8,
    ///[`CullMode`] specifies that the `cullMode` state
    ///in [`PipelineRasterizationStateCreateInfo`] will be ignored and
    /// **must**  be set dynamically with [`CmdSetCullMode`] before any drawing
    ///commands.
    ///
    ///Provided by [`crate::vulkan1_3`]
    CullMode = 1000267000,
    ///[`FrontFace`] specifies that the `frontFace`
    ///state in [`PipelineRasterizationStateCreateInfo`] will be ignored
    ///and  **must**  be set dynamically with [`CmdSetFrontFace`] before any
    ///drawing commands.
    ///
    ///Provided by [`crate::vulkan1_3`]
    FrontFace = 1000267001,
    ///[`PrimitiveTopology`] specifies that the
    ///`topology` state in [`PipelineInputAssemblyStateCreateInfo`]
    ///only specifies the [topology class](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#drawing-primitive-topology-class),
    ///and the specific topology order and adjacency  **must**  be set dynamically
    ///with [`CmdSetPrimitiveTopology`] before any drawing commands.
    ///
    ///Provided by [`crate::vulkan1_3`]
    PrimitiveTopology = 1000267002,
    ///[`ViewportWithCount`] specifies that the
    ///`viewportCount` and `pViewports` state in
    ///[`PipelineViewportStateCreateInfo`] will be ignored and  **must**  be set
    ///dynamically with [`CmdSetViewportWithCount`] before any draw call.
    ///
    ///Provided by [`crate::vulkan1_3`]
    ViewportWithCount = 1000267003,
    ///[`ScissorWithCount`] specifies that the
    ///`scissorCount` and `pScissors` state in
    ///[`PipelineViewportStateCreateInfo`] will be ignored and  **must**  be set
    ///dynamically with [`CmdSetScissorWithCount`] before any draw call.
    ///
    ///Provided by [`crate::vulkan1_3`]
    ScissorWithCount = 1000267004,
    ///[`VertexInputBindingStride`] specifies that the
    ///`stride` state in [`VertexInputBindingDescription`] will be
    ///ignored and  **must**  be set dynamically with [`CmdBindVertexBuffers2`]
    ///before any draw call.
    ///
    ///Provided by [`crate::vulkan1_3`]
    VertexInputBindingStride = 1000267005,
    ///[`DepthTestEnable`] specifies that the
    ///`depthTestEnable` state in
    ///[`PipelineDepthStencilStateCreateInfo`] will be ignored and  **must**  be
    ///set dynamically with [`CmdSetDepthTestEnable`] before any draw call.
    ///
    ///Provided by [`crate::vulkan1_3`]
    DepthTestEnable = 1000267006,
    ///[`DepthWriteEnable`] specifies that the
    ///`depthWriteEnable` state in
    ///[`PipelineDepthStencilStateCreateInfo`] will be ignored and  **must**  be
    ///set dynamically with [`CmdSetDepthWriteEnable`] before any draw
    ///call.
    ///
    ///Provided by [`crate::vulkan1_3`]
    DepthWriteEnable = 1000267007,
    ///[`DepthCompareOp`] specifies that the
    ///`depthCompareOp` state in
    ///[`PipelineDepthStencilStateCreateInfo`] will be ignored and  **must**  be
    ///set dynamically with [`CmdSetDepthCompareOp`] before any draw call.
    ///
    ///Provided by [`crate::vulkan1_3`]
    DepthCompareOp = 1000267008,
    ///[`DepthBoundsTestEnable`] specifies that the
    ///`depthBoundsTestEnable` state in
    ///[`PipelineDepthStencilStateCreateInfo`] will be ignored and  **must**  be
    ///set dynamically with [`CmdSetDepthBoundsTestEnable`] before any draw
    ///call.
    ///
    ///Provided by [`crate::vulkan1_3`]
    DepthBoundsTestEnable = 1000267009,
    ///[`StencilTestEnable`] specifies that the
    ///`stencilTestEnable` state in
    ///[`PipelineDepthStencilStateCreateInfo`] will be ignored and  **must**  be
    ///set dynamically with [`CmdSetStencilTestEnable`] before any draw
    ///call.
    ///
    ///Provided by [`crate::vulkan1_3`]
    StencilTestEnable = 1000267010,
    ///[`StencilOp`] specifies that the `failOp`,
    ///`passOp`, `depthFailOp`, and `compareOp` states in
    ///[`PipelineDepthStencilStateCreateInfo`] for both `front` and
    ///`back` will be ignored and  **must**  be set dynamically with
    ///[`CmdSetStencilOp`] before any draws are performed with a pipeline
    ///state with [`PipelineDepthStencilStateCreateInfo`] member
    ///`stencilTestEnable` set to [`TRUE`]
    ///
    ///Provided by [`crate::vulkan1_3`]
    StencilOp = 1000267011,
    ///[`RasterizerDiscardEnable`] specifies that the
    ///`rasterizerDiscardEnable` state in
    ///[`PipelineRasterizationStateCreateInfo`] will be ignored and  **must**
    ///be set dynamically with [`CmdSetRasterizerDiscardEnable`] before any
    ///drawing commands.
    ///
    ///Provided by [`crate::vulkan1_3`]
    RasterizerDiscardEnable = 1000377001,
    ///[`DepthBiasEnable`] specifies that the
    ///`depthBiasEnable` state in
    ///[`PipelineRasterizationStateCreateInfo`] will be ignored and  **must**
    ///be set dynamically with [`CmdSetDepthBiasEnable`] before any drawing
    ///commands.
    ///
    ///Provided by [`crate::vulkan1_3`]
    DepthBiasEnable = 1000377002,
    ///[`PrimitiveRestartEnable`] specifies that the
    ///`primitiveRestartEnable` state in
    ///[`PipelineInputAssemblyStateCreateInfo`] will be ignored and  **must**
    ///be set dynamically with [`CmdSetPrimitiveRestartEnable`] before any
    ///drawing commands.
    ///
    ///Provided by [`crate::vulkan1_3`]
    PrimitiveRestartEnable = 1000377004,
    ///[`ViewportWScalingNv`] specifies that the
    ///`pViewportScalings` state in
    ///[`PipelineViewportWScalingStateCreateInfoNV`] will be ignored and
    /// **must**  be set dynamically with [`CmdSetViewportWScalingNV`] before
    ///any draws are performed with a pipeline state with
    ///[`PipelineViewportWScalingStateCreateInfoNV`] member
    ///`viewportScalingEnable` set to [`TRUE`]
    ///
    ///Provided by [`crate::extensions::nv_clip_space_w_scaling`]
    ViewportWScalingNv = 1000087000,
    ///[`DiscardRectangleExt`] specifies that the
    ///`pDiscardRectangles` state in
    ///[`PipelineDiscardRectangleStateCreateInfoEXT`] will be ignored and
    /// **must**  be set dynamically with [`CmdSetDiscardRectangleEXT`] before
    ///any draw or clear commands.
    ///The [`DiscardRectangleModeEXT`] and the number of active discard
    ///rectangles is still specified by the `discardRectangleMode` and
    ///`discardRectangleCount` members of
    ///[`PipelineDiscardRectangleStateCreateInfoEXT`].
    ///
    ///Provided by [`crate::extensions::ext_discard_rectangles`]
    DiscardRectangleExt = 1000099000,
    ///[`SampleLocationsExt`] specifies that the
    ///`sampleLocationsInfo` state in
    ///[`PipelineSampleLocationsStateCreateInfoEXT`] will be ignored and
    /// **must**  be set dynamically with [`CmdSetSampleLocationsEXT`] before
    ///any draw or clear commands.
    ///Enabling custom sample locations is still indicated by the
    ///`sampleLocationsEnable` member of
    ///[`PipelineSampleLocationsStateCreateInfoEXT`].
    ///
    ///Provided by [`crate::extensions::ext_sample_locations`]
    SampleLocationsExt = 1000143000,
    ///[`RayTracingPipelineStackSizeKhr`] specifies
    ///that the default stack size computation for the pipeline will be ignored
    ///and  **must**  be set dynamically with
    ///[`CmdSetRayTracingPipelineStackSizeKHR`] before any ray tracing
    ///calls are performed.
    ///
    ///Provided by [`crate::extensions::khr_ray_tracing_pipeline`]
    RayTracingPipelineStackSizeKhr = 1000347000,
    ///[`ViewportShadingRatePaletteNv`] specifies that
    ///the `pShadingRatePalettes` state in
    ///[`PipelineViewportShadingRateImageStateCreateInfoNV`] will be
    ///ignored and  **must**  be set dynamically with
    ///[`CmdSetViewportShadingRatePaletteNV`] before any drawing commands.
    ///
    ///Provided by [`crate::extensions::nv_shading_rate_image`]
    ViewportShadingRatePaletteNv = 1000164004,
    ///[`ViewportCoarseSampleOrderNv`] specifies that
    ///the coarse sample order state in
    ///[`PipelineViewportCoarseSampleOrderStateCreateInfoNV`] will be
    ///ignored and  **must**  be set dynamically with
    ///[`CmdSetCoarseSampleOrderNV`] before any drawing commands.
    ///
    ///Provided by [`crate::extensions::nv_shading_rate_image`]
    ViewportCoarseSampleOrderNv = 1000164006,
    ///[`ExclusiveScissorNv`] specifies that the
    ///`pExclusiveScissors` state in
    ///[`PipelineViewportExclusiveScissorStateCreateInfoNV`] will be
    ///ignored and  **must**  be set dynamically with
    ///[`CmdSetExclusiveScissorNV`] before any drawing commands.
    ///The number of exclusive scissor rectangles used by a pipeline is still
    ///specified by the `exclusiveScissorCount` member of
    ///[`PipelineViewportExclusiveScissorStateCreateInfoNV`].
    ///
    ///Provided by [`crate::extensions::nv_scissor_exclusive`]
    ExclusiveScissorNv = 1000205001,
    ///[`FragmentShadingRateKhr`] specifies that state in
    ///[`PipelineFragmentShadingRateStateCreateInfoKHR`]
    ///and [`PipelineFragmentShadingRateEnumStateCreateInfoNV`]
    ///will be ignored and  **must**  be set dynamically with
    ///[`CmdSetFragmentShadingRateKHR`]
    ///or [`CmdSetFragmentShadingRateEnumNV`]
    ///before any drawing commands.
    ///
    ///Provided by [`crate::extensions::khr_fragment_shading_rate`]
    FragmentShadingRateKhr = 1000226000,
    ///[`LineStippleExt`] specifies that the
    ///`lineStippleFactor` and `lineStipplePattern` state in
    ///[`PipelineRasterizationLineStateCreateInfoEXT`] will be ignored and
    /// **must**  be set dynamically with [`CmdSetLineStippleEXT`] before any
    ///draws are performed with a pipeline state with
    ///[`PipelineRasterizationLineStateCreateInfoEXT`] member
    ///`stippledLineEnable` set to [`TRUE`].
    ///
    ///Provided by [`crate::extensions::ext_line_rasterization`]
    LineStippleExt = 1000259000,
    ///[`VertexInputExt`] specifies that the
    ///`pVertexInputState` state will be ignored and  **must**  be set
    ///dynamically with [`CmdSetVertexInputEXT`] before any drawing
    ///commands
    ///
    ///Provided by [`crate::extensions::ext_vertex_input_dynamic_state`]
    VertexInputExt = 1000352000,
    ///[`PatchControlPointsExt`] specifies that the
    ///`patchControlPoints` state in
    ///[`PipelineTessellationStateCreateInfo`] will be ignored and  **must**  be
    ///set dynamically with [`CmdSetPatchControlPointsEXT`] before any
    ///drawing commands.
    ///
    ///Provided by [`crate::extensions::ext_extended_dynamic_state_2`]
    PatchControlPointsExt = 1000377000,
    ///[`LogicOpExt`] specifies that the `logicOp`
    ///state in [`PipelineColorBlendStateCreateInfo`] will be ignored and
    /// **must**  be set dynamically with [`CmdSetLogicOpEXT`] before any
    ///drawing commands.
    ///
    ///Provided by [`crate::extensions::ext_extended_dynamic_state_2`]
    LogicOpExt = 1000377003,
    ///[`ColorWriteEnableExt`] specifies that the
    ///`pColorWriteEnables` state in
    ///[`PipelineColorWriteCreateInfoEXT`] will be ignored and  **must**  be set
    ///dynamically with [`CmdSetColorWriteEnableEXT`] before any draw call.
    ///
    ///Provided by [`crate::extensions::ext_color_write_enable`]
    ColorWriteEnableExt = 1000381000,
}
impl const Default for DynamicState {
    fn default() -> Self {
        Self::Viewport
    }
}
impl DynamicState {
    ///Default empty value
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Gets the raw underlying value
    #[inline]
    pub const fn bits(&self) -> i32 {
        self as i32
    }
    ///Gets a value from a raw underlying value, unchecked and therefore unsafe
    #[inline]
    pub const unsafe fn from_bits(bits: i32) -> i32 {
        std::mem::transmute(bits)
    }
}
///[VkObjectType](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkObjectType.html) - Specify an enumeration to track object handle types
///# C Specifications
///The [`ObjectType`] enumeration defines values, each of which corresponds
///to a specific Vulkan handle type.
///These values  **can**  be used to associate debug information with a particular
///type of object through one or more extensions.
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkObjectType {
///    VK_OBJECT_TYPE_UNKNOWN = 0,
///    VK_OBJECT_TYPE_INSTANCE = 1,
///    VK_OBJECT_TYPE_PHYSICAL_DEVICE = 2,
///    VK_OBJECT_TYPE_DEVICE = 3,
///    VK_OBJECT_TYPE_QUEUE = 4,
///    VK_OBJECT_TYPE_SEMAPHORE = 5,
///    VK_OBJECT_TYPE_COMMAND_BUFFER = 6,
///    VK_OBJECT_TYPE_FENCE = 7,
///    VK_OBJECT_TYPE_DEVICE_MEMORY = 8,
///    VK_OBJECT_TYPE_BUFFER = 9,
///    VK_OBJECT_TYPE_IMAGE = 10,
///    VK_OBJECT_TYPE_EVENT = 11,
///    VK_OBJECT_TYPE_QUERY_POOL = 12,
///    VK_OBJECT_TYPE_BUFFER_VIEW = 13,
///    VK_OBJECT_TYPE_IMAGE_VIEW = 14,
///    VK_OBJECT_TYPE_SHADER_MODULE = 15,
///    VK_OBJECT_TYPE_PIPELINE_CACHE = 16,
///    VK_OBJECT_TYPE_PIPELINE_LAYOUT = 17,
///    VK_OBJECT_TYPE_RENDER_PASS = 18,
///    VK_OBJECT_TYPE_PIPELINE = 19,
///    VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT = 20,
///    VK_OBJECT_TYPE_SAMPLER = 21,
///    VK_OBJECT_TYPE_DESCRIPTOR_POOL = 22,
///    VK_OBJECT_TYPE_DESCRIPTOR_SET = 23,
///    VK_OBJECT_TYPE_FRAMEBUFFER = 24,
///    VK_OBJECT_TYPE_COMMAND_POOL = 25,
///  // Provided by VK_VERSION_1_1
///    VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION = 1000156000,
///  // Provided by VK_VERSION_1_1
///    VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE = 1000085000,
///  // Provided by VK_VERSION_1_3
///    VK_OBJECT_TYPE_PRIVATE_DATA_SLOT = 1000295000,
///  // Provided by VK_KHR_surface
///    VK_OBJECT_TYPE_SURFACE_KHR = 1000000000,
///  // Provided by VK_KHR_swapchain
///    VK_OBJECT_TYPE_SWAPCHAIN_KHR = 1000001000,
///  // Provided by VK_KHR_display
///    VK_OBJECT_TYPE_DISPLAY_KHR = 1000002000,
///  // Provided by VK_KHR_display
///    VK_OBJECT_TYPE_DISPLAY_MODE_KHR = 1000002001,
///  // Provided by VK_EXT_debug_report
///    VK_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT = 1000011000,
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_KHR_video_queue
///    VK_OBJECT_TYPE_VIDEO_SESSION_KHR = 1000023000,
///#endif
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_KHR_video_queue
///    VK_OBJECT_TYPE_VIDEO_SESSION_PARAMETERS_KHR = 1000023001,
///#endif
///  // Provided by VK_NVX_binary_import
///    VK_OBJECT_TYPE_CU_MODULE_NVX = 1000029000,
///  // Provided by VK_NVX_binary_import
///    VK_OBJECT_TYPE_CU_FUNCTION_NVX = 1000029001,
///  // Provided by VK_EXT_debug_utils
///    VK_OBJECT_TYPE_DEBUG_UTILS_MESSENGER_EXT = 1000128000,
///  // Provided by VK_KHR_acceleration_structure
///    VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR = 1000150000,
///  // Provided by VK_EXT_validation_cache
///    VK_OBJECT_TYPE_VALIDATION_CACHE_EXT = 1000160000,
///  // Provided by VK_NV_ray_tracing
///    VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV = 1000165000,
///  // Provided by VK_INTEL_performance_query
///    VK_OBJECT_TYPE_PERFORMANCE_CONFIGURATION_INTEL = 1000210000,
///  // Provided by VK_KHR_deferred_host_operations
///    VK_OBJECT_TYPE_DEFERRED_OPERATION_KHR = 1000268000,
///  // Provided by VK_NV_device_generated_commands
///    VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NV = 1000277000,
///  // Provided by VK_FUCHSIA_buffer_collection
///    VK_OBJECT_TYPE_BUFFER_COLLECTION_FUCHSIA = 1000366000,
///  // Provided by VK_KHR_descriptor_update_template
///    VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR = VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE,
///  // Provided by VK_KHR_sampler_ycbcr_conversion
///    VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR = VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION,
///  // Provided by VK_EXT_private_data
///    VK_OBJECT_TYPE_PRIVATE_DATA_SLOT_EXT = VK_OBJECT_TYPE_PRIVATE_DATA_SLOT,
///} VkObjectType;
///```
///# Related
/// - [`crate::vulkan1_0`]
/// - [`DebugUtilsObjectNameInfoEXT`]
/// - [`DebugUtilsObjectTagInfoEXT`]
/// - [`DeviceMemoryReportCallbackDataEXT`]
/// - [`GetPrivateData`]
/// - [`GetPrivateDataEXT`]
/// - [`SetPrivateData`]
/// - [`SetPrivateDataEXT`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkObjectType")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
#[repr(i32)]
pub enum ObjectType {
    ///No documentation found
    Unknown = 0,
    ///No documentation found
    Instance = 1,
    ///No documentation found
    PhysicalDevice = 2,
    ///No documentation found
    Device = 3,
    ///No documentation found
    Queue = 4,
    ///No documentation found
    Semaphore = 5,
    ///No documentation found
    CommandBuffer = 6,
    ///No documentation found
    Fence = 7,
    ///No documentation found
    DeviceMemory = 8,
    ///No documentation found
    Buffer = 9,
    ///No documentation found
    Image = 10,
    ///No documentation found
    Event = 11,
    ///No documentation found
    QueryPool = 12,
    ///No documentation found
    BufferView = 13,
    ///No documentation found
    ImageView = 14,
    ///No documentation found
    ShaderModule = 15,
    ///No documentation found
    PipelineCache = 16,
    ///No documentation found
    PipelineLayout = 17,
    ///No documentation found
    RenderPass = 18,
    ///No documentation found
    Pipeline = 19,
    ///No documentation found
    DescriptorSetLayout = 20,
    ///No documentation found
    Sampler = 21,
    ///No documentation found
    DescriptorPool = 22,
    ///No documentation found
    DescriptorSet = 23,
    ///No documentation found
    Framebuffer = 24,
    ///No documentation found
    CommandPool = 25,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_1`]
    SamplerYcbcrConversion = 1000156000,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_1`]
    DescriptorUpdateTemplate = 1000085000,
    ///No documentation found
    ///
    ///Provided by [`crate::vulkan1_3`]
    PrivateDataSlot = 1000295000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_surface`]
    SurfaceKhr = 1000000000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_swapchain`]
    SwapchainKhr = 1000001000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_display`]
    DisplayKhr = 1000002000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_display`]
    DisplayModeKhr = 1000002001,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_debug_report`]
    DebugReportCallbackExt = 1000011000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_video_queue`]
    VideoSessionKhr = 1000023000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_video_queue`]
    VideoSessionParametersKhr = 1000023001,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::nvx_binary_import`]
    CuModuleNvx = 1000029000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::nvx_binary_import`]
    CuFunctionNvx = 1000029001,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_debug_utils`]
    DebugUtilsMessengerExt = 1000128000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_acceleration_structure`]
    AccelerationStructureKhr = 1000150000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_validation_cache`]
    ValidationCacheExt = 1000160000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::nv_ray_tracing`]
    AccelerationStructureNv = 1000165000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::intel_performance_query`]
    PerformanceConfigurationIntel = 1000210000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_deferred_host_operations`]
    DeferredOperationKhr = 1000268000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::nv_device_generated_commands`]
    IndirectCommandsLayoutNv = 1000277000,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::fuchsia_buffer_collection`]
    BufferCollectionFuchsia = 1000366000,
}
impl const Default for ObjectType {
    fn default() -> Self {
        Self::Unknown
    }
}
impl ObjectType {
    ///Default empty value
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Gets the raw underlying value
    #[inline]
    pub const fn bits(&self) -> i32 {
        self as i32
    }
    ///Gets a value from a raw underlying value, unchecked and therefore unsafe
    #[inline]
    pub const unsafe fn from_bits(bits: i32) -> i32 {
        std::mem::transmute(bits)
    }
}
///[VkVendorId](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVendorId.html) - Khronos vendor IDs
///# C Specifications
///Khronos vendor IDs which  **may**  be returned in
///[`PhysicalDeviceProperties::vendor_id`] are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkVendorId {
///    VK_VENDOR_ID_VIV = 0x10001,
///    VK_VENDOR_ID_VSI = 0x10002,
///    VK_VENDOR_ID_KAZAN = 0x10003,
///    VK_VENDOR_ID_CODEPLAY = 0x10004,
///    VK_VENDOR_ID_MESA = 0x10005,
///    VK_VENDOR_ID_POCL = 0x10006,
///} VkVendorId;
///```
///# Related
/// - [`crate::vulkan1_0`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkVendorId")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
#[repr(i32)]
pub enum VendorId {
    #[doc(hidden)]
    Empty = 0,
    ///No documentation found
    Viv = 65537,
    ///No documentation found
    Vsi = 65538,
    ///No documentation found
    Kazan = 65539,
    ///No documentation found
    Codeplay = 65540,
    ///No documentation found
    Mesa = 65541,
    ///No documentation found
    Pocl = 65542,
}
impl const Default for VendorId {
    fn default() -> Self {
        Self::Empty
    }
}
impl VendorId {
    ///Default empty value
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Gets the raw underlying value
    #[inline]
    pub const fn bits(&self) -> i32 {
        self as i32
    }
    ///Gets a value from a raw underlying value, unchecked and therefore unsafe
    #[inline]
    pub const unsafe fn from_bits(bits: i32) -> i32 {
        std::mem::transmute(bits)
    }
}
///[VkQueueFlagBits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkQueueFlagBits.html) - Bitmask specifying capabilities of queues in a queue family
///# C Specifications
///Bits which  **may**  be set in [`QueueFamilyProperties::queue_flags`],
///indicating capabilities of queues in a queue family are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkQueueFlagBits {
///    VK_QUEUE_GRAPHICS_BIT = 0x00000001,
///    VK_QUEUE_COMPUTE_BIT = 0x00000002,
///    VK_QUEUE_TRANSFER_BIT = 0x00000004,
///    VK_QUEUE_SPARSE_BINDING_BIT = 0x00000008,
///  // Provided by VK_VERSION_1_1
///    VK_QUEUE_PROTECTED_BIT = 0x00000010,
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_KHR_video_decode_queue
///    VK_QUEUE_VIDEO_DECODE_BIT_KHR = 0x00000020,
///#endif
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_KHR_video_encode_queue
///    VK_QUEUE_VIDEO_ENCODE_BIT_KHR = 0x00000040,
///#endif
///} VkQueueFlagBits;
///```
///# Description
/// - [`QueueGraphics`] specifies that queues in this queue family support graphics operations.
/// - [`QueueCompute`] specifies that queues in this queue family support compute operations.
/// - [`QueueTransfer`] specifies that queues in this queue family support transfer operations.
/// - [`QueueSparseBinding`] specifies that queues in this queue family support sparse memory management operations (see [Sparse Resources](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#sparsememory)). If any of the sparse resource features are enabled, then at least one queue family  **must**  support this bit.
/// - [`VideoDecodeKhr`] specifies that queues in this queue family support Video Decode operations.
/// - [`VideoEncodeKhr`] specifies that queues in this queue family support Video Encode operations.
/// - [`Protected`] specifies that queues in this queue family support the `VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT` bit. (see [Protected Memory](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#memory-protected-memory)). If the physical device supports the `protectedMemory` feature, at least one of its queue families  **must**  support this bit.
///If an implementation exposes any queue family that supports graphics
///operations, at least one queue family of at least one physical device
///exposed by the implementation  **must**  support both graphics and compute
///operations.Furthermore, if the protected memory physical device feature is supported,
///then at least one queue family of at least one physical device exposed by
///the implementation  **must**  support graphics operations, compute operations,
///and protected memory operations.For further details see [Queues](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#devsandqueues-queues).
///# Related
/// - [`crate::vulkan1_0`]
/// - [`QueueFlags`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkQueueFlagBits")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
#[repr(u32)]
pub enum QueueFlagBits {
    #[doc(hidden)]
    Empty = 0,
    ///[`QueueGraphics`] specifies that queues in this queue family
    ///support graphics operations.
    QueueGraphics = 1,
    ///[`QueueCompute`] specifies that queues in this queue family
    ///support compute operations.
    QueueCompute = 2,
    ///[`QueueTransfer`] specifies that queues in this queue family
    ///support transfer operations.
    QueueTransfer = 4,
    ///[`QueueSparseBinding`] specifies that queues in this queue
    ///family support sparse memory management operations (see
    ///[Sparse Resources](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#sparsememory)).
    ///If any of the sparse resource features are enabled, then at least one
    ///queue family  **must**  support this bit.
    QueueSparseBinding = 8,
    ///[`Protected`] specifies that queues in this queue family
    ///support the `VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT` bit.
    ///(see [Protected Memory](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#memory-protected-memory)).
    ///If the physical device supports the `protectedMemory` feature, at
    ///least one of its queue families  **must**  support this bit.
    ///
    ///Provided by [`crate::vulkan1_1`]
    Protected = 16,
    ///[`VideoDecodeKhr`] specifies that queues in this queue
    ///family support Video Decode operations.
    ///
    ///Provided by [`crate::extensions::khr_video_decode_queue`]
    VideoDecodeKhr = 32,
    ///[`VideoEncodeKhr`] specifies that queues in this queue
    ///family support Video Encode operations.
    ///
    ///Provided by [`crate::extensions::khr_video_encode_queue`]
    VideoEncodeKhr = 64,
}
impl const Default for QueueFlagBits {
    fn default() -> Self {
        Self::Empty
    }
}
impl QueueFlagBits {
    ///Default empty value
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Gets the raw underlying value
    #[inline]
    pub const fn bits(&self) -> u32 {
        self as u32
    }
    ///Gets a value from a raw underlying value, unchecked and therefore unsafe
    #[inline]
    pub const unsafe fn from_bits(bits: u32) -> u32 {
        std::mem::transmute(bits)
    }
}
///[VkCullModeFlagBits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCullModeFlagBits.html) - Bitmask controlling triangle culling
///# C Specifications
///Once the orientation of triangles is determined, they are culled according
///to the [`PipelineRasterizationStateCreateInfo::cull_mode`] property
///of the currently active pipeline.
///Possible values are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkCullModeFlagBits {
///    VK_CULL_MODE_NONE = 0,
///    VK_CULL_MODE_FRONT_BIT = 0x00000001,
///    VK_CULL_MODE_BACK_BIT = 0x00000002,
///    VK_CULL_MODE_FRONT_AND_BACK = 0x00000003,
///} VkCullModeFlagBits;
///```
///# Description
/// - [`CullModeNone`] specifies that no triangles are discarded
/// - [`CullModeFront`] specifies that front-facing triangles are discarded
/// - [`CullModeBack`] specifies that back-facing triangles are discarded
/// - [`CullModeFrontAndBack`] specifies that all triangles are discarded.
///Following culling, fragments are produced for any triangles which have not
///been discarded.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`CullModeFlags`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkCullModeFlagBits")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
#[repr(u32)]
pub enum CullModeFlagBits {
    ///[`CullModeNone`] specifies that no triangles are discarded
    CullModeNone = 0,
    ///[`CullModeFront`] specifies that front-facing triangles are
    ///discarded
    CullModeFront = 1,
    ///[`CullModeBack`] specifies that back-facing triangles are
    ///discarded
    CullModeBack = 2,
    ///[`CullModeFrontAndBack`] specifies that all triangles are
    ///discarded.
    CullModeFrontAndBack = 3,
}
impl const Default for CullModeFlagBits {
    fn default() -> Self {
        Self::CullModeNone
    }
}
impl CullModeFlagBits {
    ///Default empty value
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Gets the raw underlying value
    #[inline]
    pub const fn bits(&self) -> u32 {
        self as u32
    }
    ///Gets a value from a raw underlying value, unchecked and therefore unsafe
    #[inline]
    pub const unsafe fn from_bits(bits: u32) -> u32 {
        std::mem::transmute(bits)
    }
}
///[VkRenderPassCreateFlagBits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderPassCreateFlagBits.html) - Bitmask specifying additional properties of a render pass
///# C Specifications
///Bits which  **can**  be set in [`RenderPassCreateInfo::flags`],
///describing additional properties of the render pass, are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkRenderPassCreateFlagBits {
///  // Provided by VK_QCOM_render_pass_transform
///    VK_RENDER_PASS_CREATE_TRANSFORM_BIT_QCOM = 0x00000002,
///} VkRenderPassCreateFlagBits;
///```
///# Description
/// - [`TransformQcom`] specifies that the created render pass is compatible with [render pass transform](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#vertexpostproc-renderpass-transform).
///# Related
/// - [`crate::vulkan1_0`]
/// - [`RenderPassCreateFlags`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkRenderPassCreateFlagBits")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
#[repr(u32)]
pub enum RenderPassCreateFlagBits {
    #[doc(hidden)]
    Empty = 0,
    ///[`TransformQcom`] specifies that the
    ///created render pass is compatible with
    ///[render pass transform](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#vertexpostproc-renderpass-transform).
    ///
    ///Provided by [`crate::extensions::qcom_render_pass_transform`]
    TransformQcom = 2,
}
impl const Default for RenderPassCreateFlagBits {
    fn default() -> Self {
        Self::Empty
    }
}
impl RenderPassCreateFlagBits {
    ///Default empty value
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Gets the raw underlying value
    #[inline]
    pub const fn bits(&self) -> u32 {
        self as u32
    }
    ///Gets a value from a raw underlying value, unchecked and therefore unsafe
    #[inline]
    pub const unsafe fn from_bits(bits: u32) -> u32 {
        std::mem::transmute(bits)
    }
}
///[VkMemoryPropertyFlagBits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryPropertyFlagBits.html) - Bitmask specifying properties for a memory type
///# C Specifications
///Bits which  **may**  be set in [`MemoryType::property_flags`],
///indicating properties of a memory heap, are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkMemoryPropertyFlagBits {
///    VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT = 0x00000001,
///    VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT = 0x00000002,
///    VK_MEMORY_PROPERTY_HOST_COHERENT_BIT = 0x00000004,
///    VK_MEMORY_PROPERTY_HOST_CACHED_BIT = 0x00000008,
///    VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT = 0x00000010,
///  // Provided by VK_VERSION_1_1
///    VK_MEMORY_PROPERTY_PROTECTED_BIT = 0x00000020,
///  // Provided by VK_AMD_device_coherent_memory
///    VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD = 0x00000040,
///  // Provided by VK_AMD_device_coherent_memory
///    VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD = 0x00000080,
///  // Provided by VK_NV_external_memory_rdma
///    VK_MEMORY_PROPERTY_RDMA_CAPABLE_BIT_NV = 0x00000100,
///} VkMemoryPropertyFlagBits;
///```
///# Description
/// - [`MemoryPropertyDeviceLocal`] bit specifies that memory allocated with this type is the most
///   efficient for device access. This property will be set if and only if the memory type belongs
///   to a heap with the `VK_MEMORY_HEAP_DEVICE_LOCAL_BIT` set.
/// - [`MemoryPropertyHostVisible`] bit specifies that memory allocated with this type  **can**  be
///   mapped for host access using [`MapMemory`].
/// - [`MemoryPropertyHostCoherent`] bit specifies that the host cache management commands
///   [`FlushMappedMemoryRanges`] and [`InvalidateMappedMemoryRanges`] are not needed to flush host
///   writes to the device or make device writes visible to the host, respectively.
/// - [`MemoryPropertyHostCached`] bit specifies that memory allocated with this type is cached on
///   the host. Host memory accesses to uncached memory are slower than to cached memory, however
///   uncached memory is always host coherent.
/// - [`MemoryPropertyLazilyAllocated`] bit specifies that the memory type only allows device access
///   to the memory. Memory types  **must**  not have both [`MemoryPropertyLazilyAllocated`] and [`MemoryPropertyHostVisible`]
///   set. Additionally, the object’s backing memory  **may**  be provided by the implementation lazily
///   as specified in [Lazily Allocated Memory](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#memory-device-lazy_allocation).
/// - [`Protected`] bit specifies that the memory type only allows device access to the memory, and
///   allows protected queue operations to access the memory. Memory types  **must**  not have
///   [`Protected`] set and any of [`MemoryPropertyHostVisible`] set, or
///   [`MemoryPropertyHostCoherent`] set, or [`MemoryPropertyHostCached`] set.
/// - [`DeviceCoherentAmd`] bit specifies that device accesses to allocations of this memory type
///   are automatically made available and visible.
/// - [`DeviceUncachedAmd`] bit specifies that memory allocated with this type is not cached on the
///   device. Uncached device memory is always device coherent.
/// - [`RdmaCapableNv`] bit specifies that external devices can access this memory directly.
///For any memory allocated with both the
///[`MemoryPropertyHostCoherent`] and the
///[`DeviceCoherentAmd`], host or device accesses
///also perform automatic memory domain transfer operations, such that writes
///are always automatically available and visible to both host and device
///memory domains.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`MemoryPropertyFlags`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkMemoryPropertyFlagBits")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
#[repr(u32)]
pub enum MemoryPropertyFlagBits {
    #[doc(hidden)]
    Empty = 0,
    ///[`MemoryPropertyDeviceLocal`] bit specifies that memory
    ///allocated with this type is the most efficient for device access.
    ///This property will be set if and only if the memory type belongs to a
    ///heap with the `VK_MEMORY_HEAP_DEVICE_LOCAL_BIT` set.
    MemoryPropertyDeviceLocal = 1,
    ///[`MemoryPropertyHostVisible`] bit specifies that memory
    ///allocated with this type  **can**  be mapped for host access using
    ///[`MapMemory`].
    MemoryPropertyHostVisible = 2,
    ///[`MemoryPropertyHostCoherent`] bit specifies that the host
    ///cache management commands [`FlushMappedMemoryRanges`] and
    ///[`InvalidateMappedMemoryRanges`] are not needed to flush host writes
    ///to the device or make device writes visible to the host, respectively.
    MemoryPropertyHostCoherent = 4,
    ///[`MemoryPropertyHostCached`] bit specifies that memory
    ///allocated with this type is cached on the host.
    ///Host memory accesses to uncached memory are slower than to cached
    ///memory, however uncached memory is always host coherent.
    MemoryPropertyHostCached = 8,
    ///[`MemoryPropertyLazilyAllocated`] bit specifies that the
    ///memory type only allows device access to the memory.
    ///Memory types  **must**  not have both
    ///[`MemoryPropertyLazilyAllocated`] and
    ///[`MemoryPropertyHostVisible`] set.
    ///Additionally, the object’s backing memory  **may**  be provided by the
    ///implementation lazily as specified in [Lazily Allocated Memory](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#memory-device-lazy_allocation).
    MemoryPropertyLazilyAllocated = 16,
    ///[`Protected`] bit specifies that the memory
    ///type only allows device access to the memory, and allows protected queue
    ///operations to access the memory.
    ///Memory types  **must**  not have [`Protected`] set
    ///and any of [`MemoryPropertyHostVisible`] set, or
    ///[`MemoryPropertyHostCoherent`] set, or
    ///[`MemoryPropertyHostCached`] set.
    ///
    ///Provided by [`crate::vulkan1_1`]
    Protected = 32,
    ///[`DeviceCoherentAmd`] bit specifies that
    ///device accesses to allocations of this memory type are automatically
    ///made available and visible.
    ///
    ///Provided by [`crate::extensions::amd_device_coherent_memory`]
    DeviceCoherentAmd = 64,
    ///[`DeviceUncachedAmd`] bit specifies that
    ///memory allocated with this type is not cached on the device.
    ///Uncached device memory is always device coherent.
    ///
    ///Provided by [`crate::extensions::amd_device_coherent_memory`]
    DeviceUncachedAmd = 128,
    ///[`RdmaCapableNv`] bit specifies that external
    ///devices can access this memory directly.
    ///
    ///Provided by [`crate::extensions::nv_external_memory_rdma`]
    RdmaCapableNv = 256,
}
impl const Default for MemoryPropertyFlagBits {
    fn default() -> Self {
        Self::Empty
    }
}
impl MemoryPropertyFlagBits {
    ///Default empty value
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Gets the raw underlying value
    #[inline]
    pub const fn bits(&self) -> u32 {
        self as u32
    }
    ///Gets a value from a raw underlying value, unchecked and therefore unsafe
    #[inline]
    pub const unsafe fn from_bits(bits: u32) -> u32 {
        std::mem::transmute(bits)
    }
}
///[VkMemoryHeapFlagBits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryHeapFlagBits.html) - Bitmask specifying attribute flags for a heap
///# C Specifications
///Bits which  **may**  be set in [`MemoryHeap::flags`], indicating
///attribute flags for the heap, are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkMemoryHeapFlagBits {
///    VK_MEMORY_HEAP_DEVICE_LOCAL_BIT = 0x00000001,
///  // Provided by VK_VERSION_1_1
///    VK_MEMORY_HEAP_MULTI_INSTANCE_BIT = 0x00000002,
///  // Provided by VK_KHR_device_group_creation
///    VK_MEMORY_HEAP_MULTI_INSTANCE_BIT_KHR = VK_MEMORY_HEAP_MULTI_INSTANCE_BIT,
///} VkMemoryHeapFlagBits;
///```
///# Description
/// - [`MemoryHeapDeviceLocal`] specifies that the heap corresponds to device-local memory.
///   Device-local memory  **may**  have different performance characteristics than host-local
///   memory, and  **may**  support different memory property flags.
/// - [`MultiInstance`] specifies that in a logical device representing more than one physical
///   device, there is a per-physical device instance of the heap memory. By default, an allocation
///   from such a heap will be replicated to each physical device’s instance of the heap.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`MemoryHeapFlags`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkMemoryHeapFlagBits")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
#[repr(u32)]
pub enum MemoryHeapFlagBits {
    #[doc(hidden)]
    Empty = 0,
    ///[`MemoryHeapDeviceLocal`] specifies that the heap
    ///corresponds to device-local memory.
    ///Device-local memory  **may**  have different performance characteristics than
    ///host-local memory, and  **may**  support different memory property flags.
    MemoryHeapDeviceLocal = 1,
    ///[`MultiInstance`] specifies that in a logical
    ///device representing more than one physical device, there is a
    ///per-physical device instance of the heap memory.
    ///By default, an allocation from such a heap will be replicated to each
    ///physical device’s instance of the heap.
    ///
    ///Provided by [`crate::vulkan1_1`]
    MultiInstance = 2,
}
impl const Default for MemoryHeapFlagBits {
    fn default() -> Self {
        Self::Empty
    }
}
impl MemoryHeapFlagBits {
    ///Default empty value
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Gets the raw underlying value
    #[inline]
    pub const fn bits(&self) -> u32 {
        self as u32
    }
    ///Gets a value from a raw underlying value, unchecked and therefore unsafe
    #[inline]
    pub const unsafe fn from_bits(bits: u32) -> u32 {
        std::mem::transmute(bits)
    }
}
///[VkAccessFlagBits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAccessFlagBits.html) - Bitmask specifying memory access types that will participate in a memory dependency
///# C Specifications
///Bits which  **can**  be set in the `srcAccessMask` and `dstAccessMask`
///members of [`SubpassDependency`],
///[`SubpassDependency2`],
///[`MemoryBarrier`], [`BufferMemoryBarrier`], and
///[`ImageMemoryBarrier`], specifying access behavior, are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkAccessFlagBits {
///    VK_ACCESS_INDIRECT_COMMAND_READ_BIT = 0x00000001,
///    VK_ACCESS_INDEX_READ_BIT = 0x00000002,
///    VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT = 0x00000004,
///    VK_ACCESS_UNIFORM_READ_BIT = 0x00000008,
///    VK_ACCESS_INPUT_ATTACHMENT_READ_BIT = 0x00000010,
///    VK_ACCESS_SHADER_READ_BIT = 0x00000020,
///    VK_ACCESS_SHADER_WRITE_BIT = 0x00000040,
///    VK_ACCESS_COLOR_ATTACHMENT_READ_BIT = 0x00000080,
///    VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT = 0x00000100,
///    VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT = 0x00000200,
///    VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT = 0x00000400,
///    VK_ACCESS_TRANSFER_READ_BIT = 0x00000800,
///    VK_ACCESS_TRANSFER_WRITE_BIT = 0x00001000,
///    VK_ACCESS_HOST_READ_BIT = 0x00002000,
///    VK_ACCESS_HOST_WRITE_BIT = 0x00004000,
///    VK_ACCESS_MEMORY_READ_BIT = 0x00008000,
///    VK_ACCESS_MEMORY_WRITE_BIT = 0x00010000,
///  // Provided by VK_VERSION_1_3
///    VK_ACCESS_NONE = 0,
///  // Provided by VK_EXT_transform_feedback
///    VK_ACCESS_TRANSFORM_FEEDBACK_WRITE_BIT_EXT = 0x02000000,
///  // Provided by VK_EXT_transform_feedback
///    VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT = 0x04000000,
///  // Provided by VK_EXT_transform_feedback
///    VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT = 0x08000000,
///  // Provided by VK_EXT_conditional_rendering
///    VK_ACCESS_CONDITIONAL_RENDERING_READ_BIT_EXT = 0x00100000,
///  // Provided by VK_EXT_blend_operation_advanced
///    VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT = 0x00080000,
///  // Provided by VK_KHR_acceleration_structure
///    VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR = 0x00200000,
///  // Provided by VK_KHR_acceleration_structure
///    VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR = 0x00400000,
///  // Provided by VK_EXT_fragment_density_map
///    VK_ACCESS_FRAGMENT_DENSITY_MAP_READ_BIT_EXT = 0x01000000,
///  // Provided by VK_KHR_fragment_shading_rate
///    VK_ACCESS_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR = 0x00800000,
///  // Provided by VK_NV_device_generated_commands
///    VK_ACCESS_COMMAND_PREPROCESS_READ_BIT_NV = 0x00020000,
///  // Provided by VK_NV_device_generated_commands
///    VK_ACCESS_COMMAND_PREPROCESS_WRITE_BIT_NV = 0x00040000,
///  // Provided by VK_NV_shading_rate_image
///    VK_ACCESS_SHADING_RATE_IMAGE_READ_BIT_NV =
/// VK_ACCESS_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR,
///  // Provided by VK_NV_ray_tracing
///    VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_NV = VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR,
///  // Provided by VK_NV_ray_tracing
///    VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_NV =
/// VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR,
///  // Provided by VK_KHR_synchronization2
///    VK_ACCESS_NONE_KHR = VK_ACCESS_NONE,
///} VkAccessFlagBits;
///```
///# Description
///These values all have the same meaning as the equivalently named values for
///[`AccessFlags2`].
/// - [`None`] specifies no accesses.
/// - [`AccessMemoryRead`] specifies all read accesses. It is always valid in any access mask, and
///   is treated as equivalent to setting all `READ` access flags that are valid where it is used.
/// - [`AccessMemoryWrite`] specifies all write accesses. It is always valid in any access mask, and
///   is treated as equivalent to setting all `WRITE` access flags that are valid where it is used.
/// - [`AccessIndirectCommandRead`] specifies read access to     indirect command data read as part
///   of an indirect build, trace,     drawing or dispatching command.     Such access occurs in the
///   `VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT`     pipeline stage.
/// - [`AccessIndexRead`] specifies read access to an index buffer as part of an indexed drawing
///   command, bound by [`CmdBindIndexBuffer`]. Such access occurs in the
///   `VK_PIPELINE_STAGE_VERTEX_INPUT_BIT` pipeline stage.
/// - [`AccessVertexAttributeRead`] specifies read access to a vertex buffer as part of a drawing
///   command, bound by [`CmdBindVertexBuffers`]. Such access occurs in the
///   `VK_PIPELINE_STAGE_VERTEX_INPUT_BIT` pipeline stage.
/// - [`AccessUniformRead`] specifies read access to a [uniform buffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-uniformbuffer)
///   in any shader pipeline stage.
/// - [`AccessInputAttachmentRead`] specifies read access to an [input attachment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass)
///   within a render pass during subpass shading or fragment shading. Such access occurs in the
///   `VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI` or `VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT`
///   pipeline stage.
/// - [`AccessShaderRead`] specifies read access to a [uniform buffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-uniformbuffer),
///   [uniform texel buffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-uniformtexelbuffer),
///   [sampled image](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-sampledimage),
///   [storage buffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storagebuffer),
///   [physical storage buffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-physical-storage-buffer),
///   [shader binding table](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#shader-binding-table),
///   [storage texel buffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storagetexelbuffer),
///   or [storage image](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storageimage)
///   in any shader pipeline stage.
/// - [`AccessShaderWrite`] specifies write access to a [storage buffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storagebuffer),
///   [physical storage buffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-physical-storage-buffer),
///   [storage texel buffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storagetexelbuffer),
///   or [storage image](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storageimage)
///   in any shader pipeline stage.
/// - [`AccessColorAttachmentRead`] specifies read access to a [color attachment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass),
///   such as via [blending](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#framebuffer-blending),
///   [logic operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#framebuffer-logicop),
///   or via certain [subpass load operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-load-store-ops).
///   It does not include [advanced blend operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#framebuffer-blend-advanced).
///   Such access occurs in the `VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT` pipeline stage.
/// - [`AccessColorAttachmentWrite`] specifies write access to a [color, resolve, or depth/stencil resolve attachment](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#renderpass) during a [render pass](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass) or via certain [subpass load and store operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-load-store-ops). Such access occurs in the `VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT` pipeline stage.
/// - [`AccessDepthStencilAttachmentRead`] specifies read access to a [depth/stencil attachment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass),
///   via [depth or stencil operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fragops-ds-state)
///   or via certain [subpass load operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-load-store-ops).
///   Such access occurs in the `VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT` or
///   `VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT` pipeline stages.
/// - [`AccessDepthStencilAttachmentWrite`] specifies write access to a [depth/stencil attachment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass),
///   via [depth or stencil operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fragops-ds-state)
///   or via certain [subpass load and store operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-load-store-ops).
///   Such access occurs in the `VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT` or
///   `VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT` pipeline stages.
/// - [`AccessTransferRead`] specifies read access to an image or buffer in a [copy](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#copies)
///   operation. Such access occurs in the `VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT` pipeline stage.
/// - [`AccessTransferWrite`] specifies write access to an image or buffer in a [clear](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#clears)
///   or [copy](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#copies)
///   operation. Such access occurs in the `VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT` pipeline stage.
/// - [`AccessHostRead`] specifies read access by a host operation. Accesses of this type are not
///   performed through a resource, but directly on memory. Such access occurs in the
///   `VK_PIPELINE_STAGE_HOST_BIT` pipeline stage.
/// - [`AccessHostWrite`] specifies write access by a host operation. Accesses of this type are not
///   performed through a resource, but directly on memory. Such access occurs in the
///   `VK_PIPELINE_STAGE_HOST_BIT` pipeline stage.
/// - [`ConditionalRenderingReadExt`] specifies read access to a predicate as part of conditional
///   rendering. Such access occurs in the `VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT`
///   pipeline stage.
/// - [`TransformFeedbackWriteExt`] specifies write access to a transform feedback buffer made when
///   transform feedback is active. Such access occurs in the
///   `VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT` pipeline stage.
/// - [`TransformFeedbackCounterReadExt`] specifies read access to a transform feedback counter
///   buffer which is read when [`CmdBeginTransformFeedbackEXT`] executes. Such access occurs in the
///   `VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT` pipeline stage.
/// - [`TransformFeedbackCounterWriteExt`] specifies write access to a transform feedback counter
///   buffer which is written when [`CmdEndTransformFeedbackEXT`] executes. Such access occurs in
///   the `VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT` pipeline stage.
/// - [`CommandPreprocessReadNv`] specifies reads from buffer inputs to
///   [`CmdPreprocessGeneratedCommandsNV`]. Such access occurs in the
///   `VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_NV` pipeline stage.
/// - [`CommandPreprocessWriteNv`] specifies writes to the target command buffer:VkBuffer preprocess
///   outputs in [`CmdPreprocessGeneratedCommandsNV`]. Such access occurs in the
///   `VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_NV` pipeline stage.
/// - [`ColorAttachmentReadNoncoherentExt`] specifies read access to [color attachments](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass),
///   including [advanced blend operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#framebuffer-blend-advanced).
///   Such access occurs in the `VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT` pipeline stage.
/// - `VK_ACCESS_2_INVOCATION_MASK_READ_BIT_HUAWEI` specifies read access to a invocation mask image
///   in the `VK_PIPELINE_STAGE_2_INVOCATION_MASK_BIT_HUAWEI` pipeline stage.
/// - [`AccelerationStructureReadKhr`] specifies read access to an acceleration structure as part of
///   a trace, build, or copy command, or to an [acceleration structure scratch buffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#acceleration-structure-scratch)
///   as part of a build command. Such access occurs in the
///   `VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_KHR` pipeline stage or
///   `VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR` pipeline stage.
/// - [`AccelerationStructureWriteKhr`] specifies write access to an acceleration structure or [acceleration structure scratch buffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#acceleration-structure-scratch) as part of a build or copy command. Such access occurs in the `VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR` pipeline stage.
/// - [`FragmentDensityMapReadExt`] specifies read access to a [fragment density map attachment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-fragmentdensitymapattachment)
///   during dynamic [fragment density map operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fragmentdensitymapops)
///   Such access occurs in the `VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT` pipeline stage.
/// - [`FragmentShadingRateAttachmentReadKhr`] specifies read access to a fragment shading rate
///   attachment during rasterization. Such access occurs in the
///   `VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR` pipeline stage.
/// - [`ShadingRateImageReadNv`] specifies read access to a shading rate image during rasterization.
///   Such access occurs in the `VK_PIPELINE_STAGE_SHADING_RATE_IMAGE_BIT_NV` pipeline stage. It is
///   equivalent to `VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR`.
///Certain access types are only performed by a subset of pipeline stages.
///Any synchronization command that takes both stage masks and access masks
///uses both to define the [access
///scopes](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-dependencies-access-scopes) - only the specified access types performed by the specified stages
///are included in the access scope.
///An application  **must**  not specify an access flag in a synchronization command
///if it does not include a pipeline stage in the corresponding stage mask that
///is able to perform accesses of that type.
///The following table lists, for each access flag, which pipeline stages  **can**
///perform that type of access.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`AccessFlags`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkAccessFlagBits")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
#[repr(u32)]
pub enum AccessFlagBits {
    ///[`AccessIndirectCommandRead`] specifies read access to
    ///    indirect command data read as part of an indirect
    ///build,
    ///trace,
    ///    drawing or dispatching command.
    ///    Such access occurs in the `VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT`
    ///    pipeline stage.
    AccessIndirectCommandRead = 1,
    ///[`AccessIndexRead`] specifies read access to an index buffer
    ///as part of an indexed drawing command, bound by
    ///[`CmdBindIndexBuffer`].
    ///Such access occurs in the `VK_PIPELINE_STAGE_VERTEX_INPUT_BIT`
    ///pipeline stage.
    AccessIndexRead = 2,
    ///[`AccessVertexAttributeRead`] specifies read access to a
    ///vertex buffer as part of a drawing command, bound by
    ///[`CmdBindVertexBuffers`].
    ///Such access occurs in the `VK_PIPELINE_STAGE_VERTEX_INPUT_BIT`
    ///pipeline stage.
    AccessVertexAttributeRead = 4,
    ///[`AccessUniformRead`] specifies read access to a
    ///[uniform buffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-uniformbuffer) in any shader pipeline
    ///stage.
    AccessUniformRead = 8,
    ///[`AccessInputAttachmentRead`] specifies read access to an
    ///[input attachment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass) within a render pass during
    ///subpass shading or
    ///fragment shading.
    ///Such access occurs in the
    ///`VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI` or
    ///`VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT` pipeline stage.
    AccessInputAttachmentRead = 16,
    ///[`AccessShaderRead`] specifies read access to a
    ///[uniform buffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-uniformbuffer),
    ///[uniform texel buffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-uniformtexelbuffer),
    ///[sampled image](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-sampledimage),
    ///[storage buffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storagebuffer),
    ///[physical storage buffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-physical-storage-buffer),
    ///[shader binding table](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#shader-binding-table),
    ///[storage texel buffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storagetexelbuffer), or
    ///[storage image](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storageimage) in any shader pipeline
    ///stage.
    AccessShaderRead = 32,
    ///[`AccessShaderWrite`] specifies write access to a
    ///[storage buffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storagebuffer),
    ///[physical storage buffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-physical-storage-buffer),
    ///[storage texel buffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storagetexelbuffer), or
    ///[storage image](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storageimage) in any shader pipeline
    ///stage.
    AccessShaderWrite = 64,
    ///[`AccessColorAttachmentRead`] specifies read access to a
    ///[color attachment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass), such as via [blending](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#framebuffer-blending), [logic operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#framebuffer-logicop), or via certain
    ///[subpass load operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-load-store-ops).
    ///It does not include [advanced blend
    ///operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#framebuffer-blend-advanced).
    ///Such access occurs in the
    ///`VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT` pipeline stage.
    AccessColorAttachmentRead = 128,
    ///[`AccessColorAttachmentWrite`] specifies write access to a
    ///[color, resolve, or depth/stencil resolve attachment](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#renderpass)
    ///during a [render pass](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass) or via certain
    ///[subpass load and store operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-load-store-ops).
    ///Such access occurs in the
    ///`VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT` pipeline stage.
    AccessColorAttachmentWrite = 256,
    ///[`AccessDepthStencilAttachmentRead`] specifies read access
    ///to a [depth/stencil attachment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass), via [depth or stencil operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fragops-ds-state) or via certain
    ///[subpass load operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-load-store-ops).
    ///Such access occurs in the
    ///`VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT` or
    ///`VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT` pipeline stages.
    AccessDepthStencilAttachmentRead = 512,
    ///[`AccessDepthStencilAttachmentWrite`] specifies write
    ///access to a [depth/stencil attachment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass), via
    ///[depth or stencil operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fragops-ds-state) or via certain
    ///[subpass load and store operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-load-store-ops).
    ///Such access occurs in the
    ///`VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT` or
    ///`VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT` pipeline stages.
    AccessDepthStencilAttachmentWrite = 1024,
    ///[`AccessTransferRead`] specifies read access to an image or
    ///buffer in a [copy](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#copies) operation.
    ///Such access occurs in the `VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT`
    ///pipeline stage.
    AccessTransferRead = 2048,
    ///[`AccessTransferWrite`] specifies write access to an image or
    ///buffer in a [clear](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#clears) or [copy](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#copies) operation.
    ///Such access occurs in the `VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT`
    ///pipeline stage.
    AccessTransferWrite = 4096,
    ///[`AccessHostRead`] specifies read access by a host operation.
    ///Accesses of this type are not performed through a resource, but directly
    ///on memory.
    ///Such access occurs in the `VK_PIPELINE_STAGE_HOST_BIT` pipeline
    ///stage.
    AccessHostRead = 8192,
    ///[`AccessHostWrite`] specifies write access by a host
    ///operation.
    ///Accesses of this type are not performed through a resource, but directly
    ///on memory.
    ///Such access occurs in the `VK_PIPELINE_STAGE_HOST_BIT` pipeline
    ///stage.
    AccessHostWrite = 16384,
    ///[`AccessMemoryRead`] specifies all read accesses.
    ///It is always valid in any access mask, and is treated as equivalent to
    ///setting all `READ` access flags that are valid where it is used.
    AccessMemoryRead = 32768,
    ///[`AccessMemoryWrite`] specifies all write accesses.
    ///It is always valid in any access mask, and is treated as equivalent to
    ///setting all `WRITE` access flags that are valid where it is used.
    AccessMemoryWrite = 65536,
    ///[`None`] specifies no accesses.
    ///
    ///Provided by [`crate::vulkan1_3`]
    None = 0,
    ///[`TransformFeedbackWriteExt`] specifies write access
    ///to a transform feedback buffer made when transform feedback is active.
    ///Such access occurs in the
    ///`VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT` pipeline stage.
    ///
    ///Provided by [`crate::extensions::ext_transform_feedback`]
    TransformFeedbackWriteExt = 33554432,
    ///[`TransformFeedbackCounterReadExt`] specifies read
    ///access to a transform feedback counter buffer which is read when
    ///[`CmdBeginTransformFeedbackEXT`] executes.
    ///Such access occurs in the
    ///`VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT` pipeline stage.
    ///
    ///Provided by [`crate::extensions::ext_transform_feedback`]
    TransformFeedbackCounterReadExt = 67108864,
    ///[`TransformFeedbackCounterWriteExt`] specifies write
    ///access to a transform feedback counter buffer which is written when
    ///[`CmdEndTransformFeedbackEXT`] executes.
    ///Such access occurs in the
    ///`VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT` pipeline stage.
    ///
    ///Provided by [`crate::extensions::ext_transform_feedback`]
    TransformFeedbackCounterWriteExt = 134217728,
    ///[`ConditionalRenderingReadExt`] specifies read access
    ///to a predicate as part of conditional rendering.
    ///Such access occurs in the
    ///`VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT` pipeline stage.
    ///
    ///Provided by [`crate::extensions::ext_conditional_rendering`]
    ConditionalRenderingReadExt = 1048576,
    ///[`ColorAttachmentReadNoncoherentExt`] specifies read
    ///access to [color attachments](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass), including
    ///[advanced blend operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#framebuffer-blend-advanced).
    ///Such access occurs in the
    ///`VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT` pipeline stage.
    ///
    ///Provided by [`crate::extensions::ext_blend_operation_advanced`]
    ColorAttachmentReadNoncoherentExt = 524288,
    ///[`AccelerationStructureReadKhr`] specifies read
    ///access to an acceleration structure as part of a trace, build, or copy
    ///command, or to an [acceleration
    ///structure scratch buffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#acceleration-structure-scratch) as part of a build command.
    ///Such access occurs in the
    ///`VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_KHR` pipeline stage or
    ///`VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR` pipeline
    ///stage.
    ///
    ///Provided by [`crate::extensions::khr_acceleration_structure`]
    AccelerationStructureReadKhr = 2097152,
    ///[`AccelerationStructureWriteKhr`] specifies write
    ///access to an acceleration structure or [acceleration structure scratch buffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#acceleration-structure-scratch) as part of a build or copy
    ///command.
    ///Such access occurs in the
    ///`VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR` pipeline
    ///stage.
    ///
    ///Provided by [`crate::extensions::khr_acceleration_structure`]
    AccelerationStructureWriteKhr = 4194304,
    ///[`FragmentDensityMapReadExt`] specifies read access
    ///to a [fragment density map
    ///attachment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-fragmentdensitymapattachment) during dynamic [fragment density
    ///map operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fragmentdensitymapops) Such access occurs in the
    ///`VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT` pipeline stage.
    ///
    ///Provided by [`crate::extensions::ext_fragment_density_map`]
    FragmentDensityMapReadExt = 16777216,
    ///[`FragmentShadingRateAttachmentReadKhr`] specifies
    ///read access to a fragment shading rate attachment during rasterization.
    ///Such access occurs in the
    ///`VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR`
    ///pipeline stage.
    ///
    ///Provided by [`crate::extensions::khr_fragment_shading_rate`]
    FragmentShadingRateAttachmentReadKhr = 8388608,
    ///[`CommandPreprocessReadNv`] specifies reads from
    ///buffer inputs to [`CmdPreprocessGeneratedCommandsNV`].
    ///Such access occurs in the
    ///`VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_NV` pipeline stage.
    ///
    ///Provided by [`crate::extensions::nv_device_generated_commands`]
    CommandPreprocessReadNv = 131072,
    ///[`CommandPreprocessWriteNv`] specifies writes to the
    ///target command buffer:VkBuffer preprocess outputs in
    ///[`CmdPreprocessGeneratedCommandsNV`].
    ///Such access occurs in the
    ///`VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_NV` pipeline stage.
    ///
    ///Provided by [`crate::extensions::nv_device_generated_commands`]
    CommandPreprocessWriteNv = 262144,
}
impl const Default for AccessFlagBits {
    fn default() -> Self {
        Self::None
    }
}
impl AccessFlagBits {
    ///Default empty value
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Gets the raw underlying value
    #[inline]
    pub const fn bits(&self) -> u32 {
        self as u32
    }
    ///Gets a value from a raw underlying value, unchecked and therefore unsafe
    #[inline]
    pub const unsafe fn from_bits(bits: u32) -> u32 {
        std::mem::transmute(bits)
    }
}
///[VkBufferUsageFlagBits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferUsageFlagBits.html) - Bitmask specifying allowed usage of a buffer
///# C Specifications
///Bits which  **can**  be set in [`BufferCreateInfo::usage`], specifying
///usage behavior of a buffer, are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkBufferUsageFlagBits {
///    VK_BUFFER_USAGE_TRANSFER_SRC_BIT = 0x00000001,
///    VK_BUFFER_USAGE_TRANSFER_DST_BIT = 0x00000002,
///    VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT = 0x00000004,
///    VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT = 0x00000008,
///    VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT = 0x00000010,
///    VK_BUFFER_USAGE_STORAGE_BUFFER_BIT = 0x00000020,
///    VK_BUFFER_USAGE_INDEX_BUFFER_BIT = 0x00000040,
///    VK_BUFFER_USAGE_VERTEX_BUFFER_BIT = 0x00000080,
///    VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT = 0x00000100,
///  // Provided by VK_VERSION_1_2
///    VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT = 0x00020000,
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_KHR_video_decode_queue
///    VK_BUFFER_USAGE_VIDEO_DECODE_SRC_BIT_KHR = 0x00002000,
///#endif
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_KHR_video_decode_queue
///    VK_BUFFER_USAGE_VIDEO_DECODE_DST_BIT_KHR = 0x00004000,
///#endif
///  // Provided by VK_EXT_transform_feedback
///    VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT = 0x00000800,
///  // Provided by VK_EXT_transform_feedback
///    VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT = 0x00001000,
///  // Provided by VK_EXT_conditional_rendering
///    VK_BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT = 0x00000200,
///  // Provided by VK_KHR_acceleration_structure
///    VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR = 0x00080000,
///  // Provided by VK_KHR_acceleration_structure
///    VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR = 0x00100000,
///  // Provided by VK_KHR_ray_tracing_pipeline
///    VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR = 0x00000400,
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_KHR_video_encode_queue
///    VK_BUFFER_USAGE_VIDEO_ENCODE_DST_BIT_KHR = 0x00008000,
///#endif
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_KHR_video_encode_queue
///    VK_BUFFER_USAGE_VIDEO_ENCODE_SRC_BIT_KHR = 0x00010000,
///#endif
///  // Provided by VK_NV_ray_tracing
///    VK_BUFFER_USAGE_RAY_TRACING_BIT_NV = VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR,
///  // Provided by VK_EXT_buffer_device_address
///    VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_EXT = VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT,
///  // Provided by VK_KHR_buffer_device_address
///    VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_KHR = VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT,
///} VkBufferUsageFlagBits;
///```
///# Description
/// - [`BufferUsageTransferSrc`] specifies that the buffer  **can**  be used as the source of a *transfer command* (see the definition of [`VK_PIPELINE_STAGE_TRANSFER_BIT`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-pipeline-stages-transfer)).
/// - [`BufferUsageTransferDst`] specifies that the buffer  **can**  be used as the destination of a
///   transfer command.
/// - [`BufferUsageUniformTexelBuffer`] specifies that the buffer  **can**  be used to create a
///   [`BufferView`] suitable for occupying a [`DescriptorSet`] slot of type
///   `VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER`.
/// - [`BufferUsageStorageTexelBuffer`] specifies that the buffer  **can**  be used to create a
///   [`BufferView`] suitable for occupying a [`DescriptorSet`] slot of type
///   `VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER`.
/// - [`BufferUsageUniformBuffer`] specifies that the buffer  **can**  be used in a
///   [`DescriptorBufferInfo`] suitable for occupying a [`DescriptorSet`] slot either of type
///   `VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER` or `VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC`.
/// - [`BufferUsageStorageBuffer`] specifies that the buffer  **can**  be used in a
///   [`DescriptorBufferInfo`] suitable for occupying a [`DescriptorSet`] slot either of type
///   `VK_DESCRIPTOR_TYPE_STORAGE_BUFFER` or `VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC`.
/// - [`BufferUsageIndexBuffer`] specifies that the buffer is suitable for passing as the `buffer`
///   parameter to [`CmdBindIndexBuffer`].
/// - [`BufferUsageVertexBuffer`] specifies that the buffer is suitable for passing as an element of
///   the `pBuffers` array to [`CmdBindVertexBuffers`].
/// - [`BufferUsageIndirectBuffer`] specifies that the buffer is suitable for passing as the
///   `buffer` parameter to [`CmdDrawIndirect`], [`CmdDrawIndexedIndirect`],
///   [`CmdDrawMeshTasksIndirectNV`], [`CmdDrawMeshTasksIndirectCountNV`], or
///   [`CmdDispatchIndirect`]. It is also suitable for passing as the `buffer` member of
///   [`IndirectCommandsStreamNV`], or `sequencesCountBuffer` or `sequencesIndexBuffer` or
///   `preprocessedBuffer` member of [`GeneratedCommandsInfoNV`]
/// - [`ConditionalRenderingExt`] specifies that the buffer is suitable for passing as the `buffer`
///   parameter to [`CmdBeginConditionalRenderingEXT`].
/// - [`TransformFeedbackBufferExt`] specifies that the buffer is suitable for using for binding as
///   a transform feedback buffer with [`CmdBindTransformFeedbackBuffersEXT`].
/// - [`TransformFeedbackCounterBufferExt`] specifies that the buffer is suitable for using as a
///   counter buffer with [`CmdBeginTransformFeedbackEXT`] and [`CmdEndTransformFeedbackEXT`].
/// - [`RayTracingNv`] specifies that the buffer is suitable for use in [`CmdTraceRaysNV`].
/// - [`ShaderBindingTableKhr`] specifies that the buffer is suitable for use as a [Shader Binding Table](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#shader-binding-table).
/// - [`AccelerationStructureBuildInputReadOnlyKhr`] specifies that the buffer is suitable for use as a read-only input to an [acceleration structure build](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#acceleration-structure-building).
/// - [`AccelerationStructureStorageKhr`] specifies that the buffer is suitable for storage space
///   for a [`AccelerationStructureKHR`].
/// - [`ShaderDeviceAddress`] specifies that the buffer  **can**  be used to retrieve a buffer
///   device address via [`GetBufferDeviceAddress`] and use that address to access the buffer’s
///   memory from a shader.
/// - [`VideoDecodeSrcKhr`] specifies that the buffer  **can**  be used as the source bitstream buffer in a [video decode operation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-decode-operations).
/// - [`VideoDecodeDstKhr`] specifies that the buffer  **can**  be used as the destination status buffer in a [video decode operation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-decode-operations).
/// - [`VideoEncodeDstKhr`] specifies that the buffer  **can**  be used as the destination bitstream
///   buffer in a [video encode operation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-encode-operations).
/// - [`VideoEncodeDstKhr`] specifies that the buffer  **can**  be used as the destination status buffer in a [video encode operation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-encode-operations).
///# Related
/// - [`crate::vulkan1_0`]
/// - [`BufferUsageFlags`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkBufferUsageFlagBits")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
#[repr(u32)]
pub enum BufferUsageFlagBits {
    #[doc(hidden)]
    Empty = 0,
    ///[`BufferUsageTransferSrc`] specifies that the buffer  **can**  be
    ///used as the source of a *transfer command* (see the definition of
    ///[`VK_PIPELINE_STAGE_TRANSFER_BIT`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-pipeline-stages-transfer)).
    BufferUsageTransferSrc = 1,
    ///[`BufferUsageTransferDst`] specifies that the buffer  **can**  be
    ///used as the destination of a transfer command.
    BufferUsageTransferDst = 2,
    ///[`BufferUsageUniformTexelBuffer`] specifies that the buffer
    /// **can**  be used to create a [`BufferView`] suitable for occupying a
    ///[`DescriptorSet`] slot of type
    ///`VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER`.
    BufferUsageUniformTexelBuffer = 4,
    ///[`BufferUsageStorageTexelBuffer`] specifies that the buffer
    /// **can**  be used to create a [`BufferView`] suitable for occupying a
    ///[`DescriptorSet`] slot of type
    ///`VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER`.
    BufferUsageStorageTexelBuffer = 8,
    ///[`BufferUsageUniformBuffer`] specifies that the buffer  **can**
    ///be used in a [`DescriptorBufferInfo`] suitable for occupying a
    ///[`DescriptorSet`] slot either of type
    ///`VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER` or
    ///`VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC`.
    BufferUsageUniformBuffer = 16,
    ///[`BufferUsageStorageBuffer`] specifies that the buffer  **can**
    ///be used in a [`DescriptorBufferInfo`] suitable for occupying a
    ///[`DescriptorSet`] slot either of type
    ///`VK_DESCRIPTOR_TYPE_STORAGE_BUFFER` or
    ///`VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC`.
    BufferUsageStorageBuffer = 32,
    ///[`BufferUsageIndexBuffer`] specifies that the buffer is
    ///suitable for passing as the `buffer` parameter to
    ///[`CmdBindIndexBuffer`].
    BufferUsageIndexBuffer = 64,
    ///[`BufferUsageVertexBuffer`] specifies that the buffer is
    ///suitable for passing as an element of the `pBuffers` array to
    ///[`CmdBindVertexBuffers`].
    BufferUsageVertexBuffer = 128,
    ///[`BufferUsageIndirectBuffer`] specifies that the buffer is
    ///suitable for passing as the `buffer` parameter to
    ///[`CmdDrawIndirect`], [`CmdDrawIndexedIndirect`],
    ///[`CmdDrawMeshTasksIndirectNV`],
    ///[`CmdDrawMeshTasksIndirectCountNV`],
    ///or [`CmdDispatchIndirect`].
    ///It is also suitable for passing as the `buffer` member of
    ///[`IndirectCommandsStreamNV`], or `sequencesCountBuffer` or
    ///`sequencesIndexBuffer` or `preprocessedBuffer` member of
    ///[`GeneratedCommandsInfoNV`]
    BufferUsageIndirectBuffer = 256,
    ///[`ShaderDeviceAddress`] specifies that the
    ///buffer  **can**  be used to retrieve a buffer device address via
    ///[`GetBufferDeviceAddress`] and use that address to access the
    ///buffer’s memory from a shader.
    ///
    ///Provided by [`crate::vulkan1_2`]
    ShaderDeviceAddress = 131072,
    ///[`VideoDecodeSrcKhr`] specifies that the buffer
    /// **can**  be used as the source bitstream buffer in a
    ///[video decode operation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-decode-operations).
    ///
    ///Provided by [`crate::extensions::khr_video_decode_queue`]
    VideoDecodeSrcKhr = 8192,
    ///[`VideoDecodeDstKhr`] specifies that the buffer
    /// **can**  be used as the destination status buffer in a
    ///[video decode operation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-decode-operations).
    ///
    ///Provided by [`crate::extensions::khr_video_decode_queue`]
    VideoDecodeDstKhr = 16384,
    ///[`TransformFeedbackBufferExt`] specifies that
    ///the buffer is suitable for using for binding as a transform feedback
    ///buffer with [`CmdBindTransformFeedbackBuffersEXT`].
    ///
    ///Provided by [`crate::extensions::ext_transform_feedback`]
    TransformFeedbackBufferExt = 2048,
    ///[`TransformFeedbackCounterBufferExt`]
    ///specifies that the buffer is suitable for using as a counter buffer with
    ///[`CmdBeginTransformFeedbackEXT`] and
    ///[`CmdEndTransformFeedbackEXT`].
    ///
    ///Provided by [`crate::extensions::ext_transform_feedback`]
    TransformFeedbackCounterBufferExt = 4096,
    ///[`ConditionalRenderingExt`] specifies that the
    ///buffer is suitable for passing as the `buffer` parameter to
    ///[`CmdBeginConditionalRenderingEXT`].
    ///
    ///Provided by [`crate::extensions::ext_conditional_rendering`]
    ConditionalRenderingExt = 512,
    ///[`AccelerationStructureBuildInputReadOnlyKhr`]
    ///specifies that the buffer is suitable for use as a read-only input to an
    ///[acceleration structure build](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#acceleration-structure-building).
    ///
    ///Provided by [`crate::extensions::khr_acceleration_structure`]
    AccelerationStructureBuildInputReadOnlyKhr = 524288,
    ///[`AccelerationStructureStorageKhr`] specifies
    ///that the buffer is suitable for storage space for a
    ///[`AccelerationStructureKHR`].
    ///
    ///Provided by [`crate::extensions::khr_acceleration_structure`]
    AccelerationStructureStorageKhr = 1048576,
    ///[`ShaderBindingTableKhr`] specifies that the
    ///buffer is suitable for use as a [Shader Binding
    ///Table](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#shader-binding-table).
    ///
    ///Provided by [`crate::extensions::khr_ray_tracing_pipeline`]
    ShaderBindingTableKhr = 1024,
    ///[`VideoEncodeDstKhr`] specifies that the buffer
    /// **can**  be used as the destination bitstream buffer in a
    ///[video encode operation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-encode-operations).
    ///
    ///Provided by [`crate::extensions::khr_video_encode_queue`]
    VideoEncodeDstKhr = 32768,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_video_encode_queue`]
    VideoEncodeSrcKhr = 65536,
}
impl const Default for BufferUsageFlagBits {
    fn default() -> Self {
        Self::Empty
    }
}
impl BufferUsageFlagBits {
    ///Default empty value
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Gets the raw underlying value
    #[inline]
    pub const fn bits(&self) -> u32 {
        self as u32
    }
    ///Gets a value from a raw underlying value, unchecked and therefore unsafe
    #[inline]
    pub const unsafe fn from_bits(bits: u32) -> u32 {
        std::mem::transmute(bits)
    }
}
///[VkBufferCreateFlagBits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferCreateFlagBits.html) - Bitmask specifying additional parameters of a buffer
///# C Specifications
///Bits which  **can**  be set in [`BufferCreateInfo::flags`], specifying
///additional parameters of a buffer, are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkBufferCreateFlagBits {
///    VK_BUFFER_CREATE_SPARSE_BINDING_BIT = 0x00000001,
///    VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT = 0x00000002,
///    VK_BUFFER_CREATE_SPARSE_ALIASED_BIT = 0x00000004,
///  // Provided by VK_VERSION_1_1
///    VK_BUFFER_CREATE_PROTECTED_BIT = 0x00000008,
///  // Provided by VK_VERSION_1_2
///    VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT = 0x00000010,
///  // Provided by VK_EXT_buffer_device_address
///    VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT =
/// VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT,
///  // Provided by VK_KHR_buffer_device_address
///    VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR =
/// VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT,
///} VkBufferCreateFlagBits;
///```
///# Description
/// - [`BufferCreateSparseBinding`] specifies that the buffer will be backed using sparse memory
///   binding.
/// - [`BufferCreateSparseResidency`] specifies that the buffer  **can**  be partially backed using
///   sparse memory binding. Buffers created with this flag  **must**  also be created with the
///   [`BufferCreateSparseBinding`] flag.
/// - [`BufferCreateSparseAliased`] specifies that the buffer will be backed using sparse memory
///   binding with memory ranges that might also simultaneously be backing another buffer (or
///   another portion of the same buffer). Buffers created with this flag  **must**  also be created
///   with the [`BufferCreateSparseBinding`] flag.
/// - [`Protected`] specifies that the buffer is a protected buffer.
/// - [`DeviceAddressCaptureReplay`] specifies that the buffer’s address  **can**  be saved and
///   reused on a subsequent run (e.g. for trace capture and replay), see
///   [`BufferOpaqueCaptureAddressCreateInfo`] for more detail.
///See [Sparse Resource Features](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#sparsememory-sparseresourcefeatures) and
///[Physical Device Features](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features) for details of the sparse memory
///features supported on a device.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`BufferCreateFlags`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkBufferCreateFlagBits")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
#[repr(u32)]
pub enum BufferCreateFlagBits {
    #[doc(hidden)]
    Empty = 0,
    ///[`BufferCreateSparseBinding`] specifies that the buffer will
    ///be backed using sparse memory binding.
    BufferCreateSparseBinding = 1,
    ///[`BufferCreateSparseResidency`] specifies that the buffer
    /// **can**  be partially backed using sparse memory binding.
    ///Buffers created with this flag  **must**  also be created with the
    ///[`BufferCreateSparseBinding`] flag.
    BufferCreateSparseResidency = 2,
    ///[`BufferCreateSparseAliased`] specifies that the buffer will
    ///be backed using sparse memory binding with memory ranges that might also
    ///simultaneously be backing another buffer (or another portion of the same
    ///buffer).
    ///Buffers created with this flag  **must**  also be created with the
    ///[`BufferCreateSparseBinding`] flag.
    BufferCreateSparseAliased = 4,
    ///[`Protected`] specifies that the buffer is a
    ///protected buffer.
    ///
    ///Provided by [`crate::vulkan1_1`]
    Protected = 8,
    ///[`DeviceAddressCaptureReplay`] specifies that
    ///the buffer’s address  **can**  be saved and reused on a subsequent run (e.g.
    ///for trace capture and replay), see
    ///[`BufferOpaqueCaptureAddressCreateInfo`] for more detail.
    ///
    ///Provided by [`crate::vulkan1_2`]
    DeviceAddressCaptureReplay = 16,
}
impl const Default for BufferCreateFlagBits {
    fn default() -> Self {
        Self::Empty
    }
}
impl BufferCreateFlagBits {
    ///Default empty value
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Gets the raw underlying value
    #[inline]
    pub const fn bits(&self) -> u32 {
        self as u32
    }
    ///Gets a value from a raw underlying value, unchecked and therefore unsafe
    #[inline]
    pub const unsafe fn from_bits(bits: u32) -> u32 {
        std::mem::transmute(bits)
    }
}
///[VkShaderStageFlagBits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkShaderStageFlagBits.html) - Bitmask specifying a pipeline stage
///# C Specifications
///Bits which  **can**  be set by commands and structures, specifying one or more
///shader stages, are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkShaderStageFlagBits {
///    VK_SHADER_STAGE_VERTEX_BIT = 0x00000001,
///    VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT = 0x00000002,
///    VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT = 0x00000004,
///    VK_SHADER_STAGE_GEOMETRY_BIT = 0x00000008,
///    VK_SHADER_STAGE_FRAGMENT_BIT = 0x00000010,
///    VK_SHADER_STAGE_COMPUTE_BIT = 0x00000020,
///    VK_SHADER_STAGE_ALL_GRAPHICS = 0x0000001F,
///    VK_SHADER_STAGE_ALL = 0x7FFFFFFF,
///  // Provided by VK_KHR_ray_tracing_pipeline
///    VK_SHADER_STAGE_RAYGEN_BIT_KHR = 0x00000100,
///  // Provided by VK_KHR_ray_tracing_pipeline
///    VK_SHADER_STAGE_ANY_HIT_BIT_KHR = 0x00000200,
///  // Provided by VK_KHR_ray_tracing_pipeline
///    VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR = 0x00000400,
///  // Provided by VK_KHR_ray_tracing_pipeline
///    VK_SHADER_STAGE_MISS_BIT_KHR = 0x00000800,
///  // Provided by VK_KHR_ray_tracing_pipeline
///    VK_SHADER_STAGE_INTERSECTION_BIT_KHR = 0x00001000,
///  // Provided by VK_KHR_ray_tracing_pipeline
///    VK_SHADER_STAGE_CALLABLE_BIT_KHR = 0x00002000,
///  // Provided by VK_NV_mesh_shader
///    VK_SHADER_STAGE_TASK_BIT_NV = 0x00000040,
///  // Provided by VK_NV_mesh_shader
///    VK_SHADER_STAGE_MESH_BIT_NV = 0x00000080,
///  // Provided by VK_HUAWEI_subpass_shading
///    VK_SHADER_STAGE_SUBPASS_SHADING_BIT_HUAWEI = 0x00004000,
///  // Provided by VK_NV_ray_tracing
///    VK_SHADER_STAGE_RAYGEN_BIT_NV = VK_SHADER_STAGE_RAYGEN_BIT_KHR,
///  // Provided by VK_NV_ray_tracing
///    VK_SHADER_STAGE_ANY_HIT_BIT_NV = VK_SHADER_STAGE_ANY_HIT_BIT_KHR,
///  // Provided by VK_NV_ray_tracing
///    VK_SHADER_STAGE_CLOSEST_HIT_BIT_NV = VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR,
///  // Provided by VK_NV_ray_tracing
///    VK_SHADER_STAGE_MISS_BIT_NV = VK_SHADER_STAGE_MISS_BIT_KHR,
///  // Provided by VK_NV_ray_tracing
///    VK_SHADER_STAGE_INTERSECTION_BIT_NV = VK_SHADER_STAGE_INTERSECTION_BIT_KHR,
///  // Provided by VK_NV_ray_tracing
///    VK_SHADER_STAGE_CALLABLE_BIT_NV = VK_SHADER_STAGE_CALLABLE_BIT_KHR,
///} VkShaderStageFlagBits;
///```
///# Description
/// - [`ShaderStageVertex`] specifies the vertex stage.
/// - [`ShaderStageTessellationControl`] specifies the tessellation control stage.
/// - [`ShaderStageTessellationEvaluation`] specifies the tessellation evaluation stage.
/// - [`ShaderStageGeometry`] specifies the geometry stage.
/// - [`ShaderStageFragment`] specifies the fragment stage.
/// - [`ShaderStageCompute`] specifies the compute stage.
/// - [`ShaderStageAllGraphics`] is a combination of bits used as shorthand to specify all graphics
///   stages defined above (excluding the compute stage).
/// - [`ShaderStageAll`] is a combination of bits used as shorthand to specify all shader stages
///   supported by the device, including all additional stages which are introduced by extensions.
/// - [`TaskNv`] specifies the task stage.
/// - [`MeshNv`] specifies the mesh stage.
/// - [`RaygenKhr`] specifies the ray generation stage.
/// - [`AnyHitKhr`] specifies the any-hit stage.
/// - [`ClosestHitKhr`] specifies the closest hit stage.
/// - [`MissKhr`] specifies the miss stage.
/// - [`IntersectionKhr`] specifies the intersection stage.
/// - [`CallableKhr`] specifies the callable stage.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`PipelineShaderStageCreateInfo`]
/// - [`ShaderStageFlags`]
/// - [`GetShaderInfoAMD`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkShaderStageFlagBits")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
#[repr(u32)]
pub enum ShaderStageFlagBits {
    #[doc(hidden)]
    Empty = 0,
    ///[`ShaderStageVertex`] specifies the vertex stage.
    ShaderStageVertex = 1,
    ///[`ShaderStageTessellationControl`] specifies the
    ///tessellation control stage.
    ShaderStageTessellationControl = 2,
    ///[`ShaderStageTessellationEvaluation`] specifies the
    ///tessellation evaluation stage.
    ShaderStageTessellationEvaluation = 4,
    ///[`ShaderStageGeometry`] specifies the geometry stage.
    ShaderStageGeometry = 8,
    ///[`ShaderStageFragment`] specifies the fragment stage.
    ShaderStageFragment = 16,
    ///[`ShaderStageCompute`] specifies the compute stage.
    ShaderStageCompute = 32,
    ///[`ShaderStageAllGraphics`] is a combination of bits used as
    ///shorthand to specify all graphics stages defined above (excluding the
    ///compute stage).
    ShaderStageAllGraphics = 31,
    ///[`ShaderStageAll`] is a combination of bits used as shorthand to
    ///specify all shader stages supported by the device, including all
    ///additional stages which are introduced by extensions.
    ShaderStageAll = 2147483647,
    ///[`RaygenKhr`] specifies the ray generation stage.
    ///
    ///Provided by [`crate::extensions::khr_ray_tracing_pipeline`]
    RaygenKhr = 256,
    ///[`AnyHitKhr`] specifies the any-hit stage.
    ///
    ///Provided by [`crate::extensions::khr_ray_tracing_pipeline`]
    AnyHitKhr = 512,
    ///[`ClosestHitKhr`] specifies the closest hit
    ///stage.
    ///
    ///Provided by [`crate::extensions::khr_ray_tracing_pipeline`]
    ClosestHitKhr = 1024,
    ///[`MissKhr`] specifies the miss stage.
    ///
    ///Provided by [`crate::extensions::khr_ray_tracing_pipeline`]
    MissKhr = 2048,
    ///[`IntersectionKhr`] specifies the intersection
    ///stage.
    ///
    ///Provided by [`crate::extensions::khr_ray_tracing_pipeline`]
    IntersectionKhr = 4096,
    ///[`CallableKhr`] specifies the callable stage.
    ///
    ///Provided by [`crate::extensions::khr_ray_tracing_pipeline`]
    CallableKhr = 8192,
    ///[`TaskNv`] specifies the task stage.
    ///
    ///Provided by [`crate::extensions::nv_mesh_shader`]
    TaskNv = 64,
    ///[`MeshNv`] specifies the mesh stage.
    ///
    ///Provided by [`crate::extensions::nv_mesh_shader`]
    MeshNv = 128,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::huawei_subpass_shading`]
    SubpassShadingHuawei = 16384,
}
impl const Default for ShaderStageFlagBits {
    fn default() -> Self {
        Self::Empty
    }
}
impl ShaderStageFlagBits {
    ///Default empty value
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Gets the raw underlying value
    #[inline]
    pub const fn bits(&self) -> u32 {
        self as u32
    }
    ///Gets a value from a raw underlying value, unchecked and therefore unsafe
    #[inline]
    pub const unsafe fn from_bits(bits: u32) -> u32 {
        std::mem::transmute(bits)
    }
}
///[VkImageUsageFlagBits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageUsageFlagBits.html) - Bitmask specifying intended usage of an image
///# C Specifications
///Bits which  **can**  be set in
///  * [`ImageViewUsageCreateInfo::usage`]
///  * [`ImageStencilUsageCreateInfo::stencil_usage`]
///  * [`ImageCreateInfo::usage`]
///specify intended usage of an image, and are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkImageUsageFlagBits {
///    VK_IMAGE_USAGE_TRANSFER_SRC_BIT = 0x00000001,
///    VK_IMAGE_USAGE_TRANSFER_DST_BIT = 0x00000002,
///    VK_IMAGE_USAGE_SAMPLED_BIT = 0x00000004,
///    VK_IMAGE_USAGE_STORAGE_BIT = 0x00000008,
///    VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT = 0x00000010,
///    VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT = 0x00000020,
///    VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT = 0x00000040,
///    VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT = 0x00000080,
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_KHR_video_decode_queue
///    VK_IMAGE_USAGE_VIDEO_DECODE_DST_BIT_KHR = 0x00000400,
///#endif
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_KHR_video_decode_queue
///    VK_IMAGE_USAGE_VIDEO_DECODE_SRC_BIT_KHR = 0x00000800,
///#endif
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_KHR_video_decode_queue
///    VK_IMAGE_USAGE_VIDEO_DECODE_DPB_BIT_KHR = 0x00001000,
///#endif
///  // Provided by VK_EXT_fragment_density_map
///    VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT = 0x00000200,
///  // Provided by VK_KHR_fragment_shading_rate
///    VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = 0x00000100,
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_KHR_video_encode_queue
///    VK_IMAGE_USAGE_VIDEO_ENCODE_DST_BIT_KHR = 0x00002000,
///#endif
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_KHR_video_encode_queue
///    VK_IMAGE_USAGE_VIDEO_ENCODE_SRC_BIT_KHR = 0x00004000,
///#endif
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_KHR_video_encode_queue
///    VK_IMAGE_USAGE_VIDEO_ENCODE_DPB_BIT_KHR = 0x00008000,
///#endif
///  // Provided by VK_HUAWEI_invocation_mask
///    VK_IMAGE_USAGE_INVOCATION_MASK_BIT_HUAWEI = 0x00040000,
///  // Provided by VK_NV_shading_rate_image
///    VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV =
/// VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR,
///} VkImageUsageFlagBits;
///```
///# Description
/// - [`ImageUsageTransferSrc`] specifies that the image  **can**  be used as the source of a
///   transfer command.
/// - [`ImageUsageTransferDst`] specifies that the image  **can**  be used as the destination of a
///   transfer command.
/// - [`ImageUsageSampled`] specifies that the image  **can**  be used to create a [`ImageView`]
///   suitable for occupying a [`DescriptorSet`] slot either of type
///   `VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE` or `VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER`, and be
///   sampled by a shader.
/// - [`ImageUsageStorage`] specifies that the image  **can**  be used to create a [`ImageView`]
///   suitable for occupying a [`DescriptorSet`] slot of type `VK_DESCRIPTOR_TYPE_STORAGE_IMAGE`.
/// - [`ImageUsageColorAttachment`] specifies that the image  **can**  be used to create a
///   [`ImageView`] suitable for use as a color or resolve attachment in a [`Framebuffer`].
/// - [`ImageUsageDepthStencilAttachment`] specifies that the image  **can**  be used to create a
///   [`ImageView`] suitable for use as a depth/stencil or depth/stencil resolve attachment in a
///   [`Framebuffer`].
/// - [`ImageUsageTransientAttachment`] specifies that implementations  **may**  support using [memory allocations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#memory) with the `VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT` to back an image with this usage. This bit  **can**  be set for any image that  **can**  be used to create a [`ImageView`] suitable for use as a color, resolve, depth/stencil, or input attachment.
/// - [`ImageUsageInputAttachment`] specifies that the image  **can**  be used to create a
///   [`ImageView`] suitable for occupying [`DescriptorSet`] slot of type
///   `VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT`; be read from a shader as an input attachment; and be
///   used as an input attachment in a framebuffer.
/// - [`FragmentDensityMapExt`] specifies that the image  **can**  be used to create a [`ImageView`]
///   suitable for use as a [fragment density map image](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fragmentdensitymapops).
/// - [`FragmentShadingRateAttachmentKhr`] specifies     that the image  **can**  be used to create a [`ImageView`] suitable for     use as a     [fragment shading rate     attachment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#primsrast-fragment-shading-rate-attachment) or     [shading rate image](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#primsrast-shading-rate-image)
/// - [`VideoDecodeDstKhr`] specifies that [video decode operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-decode-operations)
///   **can**  use the image as an output picture for video decode operations.
/// - [`VideoDecodeSrcKhr`] is reserved for future use.
/// - [`VideoDecodeDpbKhr`] specifies that [video decode operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-decode-operations) **can**  use the image as a [DPB Video Picture Resource](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-picture-resources), representing a [reference picture](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#reference-picture). If an implementation requires separate allocations for DPB and decode output, indicating this by returning `VK_ERROR_FORMAT_NOT_SUPPORTED` to any [`GetPhysicalDeviceVideoFormatPropertiesKHR`] call with both [`VideoDecodeDpbKhr`] and [`VideoDecodeDstKhr`] usage bits, then [`VideoDecodeDpbKhr`] **must**  not be combined with any other VK_IMAGE_USAGE_* flags. Otherwise, [`VideoDecodeDpbKhr`] **must**  be combined with [`VideoDecodeDstKhr`], if the DPB image is required to coincide with the decoded output picture. In the case where DPB coincides with the decoded output picture, image resources  **can**  be used as [reference pictures](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#reference-picture) only after acting as targets for video decode operations, where its image view  **must**  be set to both [`VideoDecodeInfoKHR`]::`pSetupReferenceSlot->pPictureResource->imageViewBinding` and [`VideoDecodeInfoKHR`]::`dstPictureResource.imageViewBinding`.
/// - [`VideoEncodeSrcKhr`] specifies that the image  **can**  be used as an [input picture](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#input-encode-picture)
///   for [video encode operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-encode-operations).
/// - [`VideoEncodeDstKhr`] is reserved for future use.
/// - [`VideoEncodeDpbKhr`] specifies that [video encode operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-encode-operations)
///   **can**  use the image as an output to hold a [reconstructed picture](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-picture-resources)
///   that can subsequently act as an input [reference picture](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#reference-picture).
///# Related
/// - [`crate::vulkan1_0`]
/// - [`ImageUsageFlags`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkImageUsageFlagBits")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
#[repr(u32)]
pub enum ImageUsageFlagBits {
    #[doc(hidden)]
    Empty = 0,
    ///[`ImageUsageTransferSrc`] specifies that the image  **can**  be
    ///used as the source of a transfer command.
    ImageUsageTransferSrc = 1,
    ///[`ImageUsageTransferDst`] specifies that the image  **can**  be
    ///used as the destination of a transfer command.
    ImageUsageTransferDst = 2,
    ///[`ImageUsageSampled`] specifies that the image  **can**  be used
    ///to create a [`ImageView`] suitable for occupying a
    ///[`DescriptorSet`] slot either of type
    ///`VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE` or
    ///`VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER`, and be sampled by a
    ///shader.
    ImageUsageSampled = 4,
    ///[`ImageUsageStorage`] specifies that the image  **can**  be used
    ///to create a [`ImageView`] suitable for occupying a
    ///[`DescriptorSet`] slot of type
    ///`VK_DESCRIPTOR_TYPE_STORAGE_IMAGE`.
    ImageUsageStorage = 8,
    ///[`ImageUsageColorAttachment`] specifies that the image  **can**
    ///be used to create a [`ImageView`] suitable for use as a color or
    ///resolve attachment in a [`Framebuffer`].
    ImageUsageColorAttachment = 16,
    ///[`ImageUsageDepthStencilAttachment`] specifies that the
    ///image  **can**  be used to create a [`ImageView`] suitable for use as a
    ///depth/stencil
    ///or depth/stencil resolve
    ///attachment in a [`Framebuffer`].
    ImageUsageDepthStencilAttachment = 32,
    ///[`ImageUsageTransientAttachment`] specifies that
    ///implementations  **may**  support using [memory allocations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#memory) with
    ///the `VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT` to back an image with
    ///this usage.
    ///This bit  **can**  be set for any image that  **can**  be used to create a
    ///[`ImageView`] suitable for use as a color, resolve, depth/stencil,
    ///or input attachment.
    ImageUsageTransientAttachment = 64,
    ///[`ImageUsageInputAttachment`] specifies that the image  **can**
    ///be used to create a [`ImageView`] suitable for occupying
    ///[`DescriptorSet`] slot of type
    ///`VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT`; be read from a shader as an
    ///input attachment; and be used as an input attachment in a framebuffer.
    ImageUsageInputAttachment = 128,
    ///[`VideoDecodeDstKhr`] specifies that
    ///[video decode operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-decode-operations) **can**  use the image
    ///as an output picture for video decode operations.
    ///
    ///Provided by [`crate::extensions::khr_video_decode_queue`]
    VideoDecodeDstKhr = 1024,
    ///[`VideoDecodeSrcKhr`] is reserved for future
    ///use.
    ///
    ///Provided by [`crate::extensions::khr_video_decode_queue`]
    VideoDecodeSrcKhr = 2048,
    ///[`VideoDecodeDpbKhr`] specifies that
    ///[video decode operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-decode-operations) **can**  use the image
    ///as a [DPB Video Picture Resource](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-picture-resources),
    ///representing a [reference picture](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#reference-picture).
    ///If an implementation requires separate allocations for DPB and decode
    ///output, indicating this by returning `VK_ERROR_FORMAT_NOT_SUPPORTED`
    ///to any [`GetPhysicalDeviceVideoFormatPropertiesKHR`] call with both
    ///[`VideoDecodeDpbKhr`] and
    ///[`VideoDecodeDstKhr`] usage bits, then
    ///[`VideoDecodeDpbKhr`] **must**  not be combined with
    ///any other VK_IMAGE_USAGE_* flags.
    ///Otherwise, [`VideoDecodeDpbKhr`] **must**  be
    ///combined with [`VideoDecodeDstKhr`], if the DPB
    ///image is required to coincide with the decoded output picture.
    ///In the case where DPB coincides with the decoded output picture, image
    ///resources  **can**  be used as [reference pictures](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#reference-picture) only
    ///after acting as targets for video decode operations, where its image
    ///view  **must**  be set to both
    ///[`VideoDecodeInfoKHR`]::`pSetupReferenceSlot->pPictureResource->imageViewBinding`
    ///and
    ///[`VideoDecodeInfoKHR`]::`dstPictureResource.imageViewBinding`.
    ///
    ///Provided by [`crate::extensions::khr_video_decode_queue`]
    VideoDecodeDpbKhr = 4096,
    ///[`FragmentDensityMapExt`] specifies that the
    ///image  **can**  be used to create a [`ImageView`] suitable for use as a
    ///[fragment density map image](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fragmentdensitymapops).
    ///
    ///Provided by [`crate::extensions::ext_fragment_density_map`]
    FragmentDensityMapExt = 512,
    ///[`FragmentShadingRateAttachmentKhr`] specifies
    ///    that the image  **can**  be used to create a [`ImageView`] suitable for
    ///    use as a
    ///    [fragment shading rate
    ///    attachment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#primsrast-fragment-shading-rate-attachment)
    ///or
    ///    [shading rate image](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#primsrast-shading-rate-image)
    ///
    ///Provided by [`crate::extensions::khr_fragment_shading_rate`]
    FragmentShadingRateAttachmentKhr = 256,
    ///[`VideoEncodeDstKhr`] is reserved for future
    ///use.
    ///
    ///Provided by [`crate::extensions::khr_video_encode_queue`]
    VideoEncodeDstKhr = 8192,
    ///[`VideoEncodeSrcKhr`] specifies that the image
    /// **can**  be used as an [input picture](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#input-encode-picture) for
    ///[video encode operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-encode-operations).
    ///
    ///Provided by [`crate::extensions::khr_video_encode_queue`]
    VideoEncodeSrcKhr = 16384,
    ///[`VideoEncodeDpbKhr`] specifies that
    ///[video encode operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-encode-operations) **can**  use the image
    ///as an output to hold a [reconstructed picture](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-picture-resources)
    ///that can subsequently act as an input [reference
    ///picture](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#reference-picture).
    ///
    ///Provided by [`crate::extensions::khr_video_encode_queue`]
    VideoEncodeDpbKhr = 32768,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::huawei_invocation_mask`]
    InvocationMaskHuawei = 262144,
}
impl const Default for ImageUsageFlagBits {
    fn default() -> Self {
        Self::Empty
    }
}
impl ImageUsageFlagBits {
    ///Default empty value
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Gets the raw underlying value
    #[inline]
    pub const fn bits(&self) -> u32 {
        self as u32
    }
    ///Gets a value from a raw underlying value, unchecked and therefore unsafe
    #[inline]
    pub const unsafe fn from_bits(bits: u32) -> u32 {
        std::mem::transmute(bits)
    }
}
///[VkImageCreateFlagBits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageCreateFlagBits.html) - Bitmask specifying additional parameters of an image
///# C Specifications
///Bits which  **can**  be set in [`ImageCreateInfo::flags`], specifying
///additional parameters of an image, are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkImageCreateFlagBits {
///    VK_IMAGE_CREATE_SPARSE_BINDING_BIT = 0x00000001,
///    VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT = 0x00000002,
///    VK_IMAGE_CREATE_SPARSE_ALIASED_BIT = 0x00000004,
///    VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT = 0x00000008,
///    VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT = 0x00000010,
///  // Provided by VK_VERSION_1_1
///    VK_IMAGE_CREATE_ALIAS_BIT = 0x00000400,
///  // Provided by VK_VERSION_1_1
///    VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT = 0x00000040,
///  // Provided by VK_VERSION_1_1
///    VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT = 0x00000020,
///  // Provided by VK_VERSION_1_1
///    VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT = 0x00000080,
///  // Provided by VK_VERSION_1_1
///    VK_IMAGE_CREATE_EXTENDED_USAGE_BIT = 0x00000100,
///  // Provided by VK_VERSION_1_1
///    VK_IMAGE_CREATE_PROTECTED_BIT = 0x00000800,
///  // Provided by VK_VERSION_1_1
///    VK_IMAGE_CREATE_DISJOINT_BIT = 0x00000200,
///  // Provided by VK_NV_corner_sampled_image
///    VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV = 0x00002000,
///  // Provided by VK_EXT_sample_locations
///    VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT = 0x00001000,
///  // Provided by VK_EXT_fragment_density_map
///    VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT = 0x00004000,
///  // Provided by VK_QCOM_fragment_density_map_offset
///    VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_QCOM = 0x00008000,
///  // Provided by VK_KHR_bind_memory2 with VK_KHR_device_group
///    VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR =
/// VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT,
///  // Provided by VK_KHR_maintenance1
///    VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT_KHR = VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT,
///  // Provided by VK_KHR_maintenance2
///    VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT_KHR =
/// VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT,
///  // Provided by VK_KHR_maintenance2
///    VK_IMAGE_CREATE_EXTENDED_USAGE_BIT_KHR = VK_IMAGE_CREATE_EXTENDED_USAGE_BIT,
///  // Provided by VK_KHR_sampler_ycbcr_conversion
///    VK_IMAGE_CREATE_DISJOINT_BIT_KHR = VK_IMAGE_CREATE_DISJOINT_BIT,
///  // Provided by VK_KHR_bind_memory2
///    VK_IMAGE_CREATE_ALIAS_BIT_KHR = VK_IMAGE_CREATE_ALIAS_BIT,
///} VkImageCreateFlagBits;
///```
///# Description
/// - [`ImageCreateSparseBinding`] specifies that the image will be backed using sparse memory
///   binding.
/// - [`ImageCreateSparseResidency`] specifies that the image  **can**  be partially backed using
///   sparse memory binding. Images created with this flag  **must**  also be created with the
///   [`ImageCreateSparseBinding`] flag.
/// - [`ImageCreateSparseAliased`] specifies that the image will be backed using sparse memory
///   binding with memory ranges that might also simultaneously be backing another image (or another
///   portion of the same image). Images created with this flag  **must**  also be created with the
///   [`ImageCreateSparseBinding`] flag.
/// - [`ImageCreateMutableFormat`] specifies that the image  **can**  be used to create a [`ImageView`] with a different format from the image. For [multi-planar](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#formats-requiring-sampler-ycbcr-conversion) formats, [`ImageCreateMutableFormat`] specifies that a [`ImageView`] can be created of a *plane* of the image.
/// - [`ImageCreateCubeCompatible`] specifies that the image  **can**  be used to create a
///   [`ImageView`] of type `VK_IMAGE_VIEW_TYPE_CUBE` or `VK_IMAGE_VIEW_TYPE_CUBE_ARRAY`.
/// - [`2DArrayCompatible`] specifies that the image  **can**  be used to create a [`ImageView`] of
///   type `VK_IMAGE_VIEW_TYPE_2D` or `VK_IMAGE_VIEW_TYPE_2D_ARRAY`.
/// - [`Protected`] specifies that the image is a protected image.
/// - [`SplitInstanceBindRegions`] specifies that the image  **can**  be used with a non-zero value
///   of the `splitInstanceBindRegionCount` member of a [`BindImageMemoryDeviceGroupInfo`] structure
///   passed into [`BindImageMemory2`]. This flag also has the effect of making the image use the
///   standard sparse image block dimensions.
/// - [`BlockTexelViewCompatible`] specifies that the image having a compressed format  **can**  be
///   used to create a [`ImageView`] with an uncompressed format where each texel in the image view
///   corresponds to a compressed texel block of the image.
/// - [`ExtendedUsage`] specifies that the image  **can**  be created with usage flags that are not
///   supported for the format the image is created with but are supported for at least one format a
///   [`ImageView`] created from the image  **can**  have.
/// - [`Disjoint`] specifies that an image with a [multi-planar format](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#formats-requiring-sampler-ycbcr-conversion)
///   **must**  have each plane separately bound to memory, rather than having a single memory
///   binding for the whole image; the presence of this bit distinguishes a *disjoint image* from an
///   image without this bit set.
/// - [`Alias`] specifies that two images created with     the same creation parameters and aliased to the same memory  **can**      interpret the contents of the memory consistently with each other,     subject to the rules described in the [Memory     Aliasing](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#resources-memory-aliasing) section.     This flag further specifies that each plane of a *disjoint* image  **can**      share an in-memory non-linear representation with single-plane images,     and that a single-plane image  **can**  share an in-memory non-linear     representation with a plane of a multi-planar disjoint image, according     to the rules in [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#formats-compatible-planes](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#formats-compatible-planes).     If the `pNext` chain includes a [`ExternalMemoryImageCreateInfo`] or [`ExternalMemoryImageCreateInfoNV`]     structure whose `handleTypes` member is not `0`, it is as if     [`Alias`] is set.
/// - [`SampleLocationsCompatibleDepthExt`] specifies that an image with a depth or depth/stencil
///   format  **can**  be used with custom sample locations when used as a depth/stencil attachment.
/// - [`CornerSampledNv`] specifies that the image is a [corner-sampled image](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#resources-images-corner-sampled).
/// - [`SubsampledExt`] specifies that an image  **can**  be in a subsampled format which  **may**  be more optimal when written as an attachment by a render pass that has a fragment density map attachment. Accessing a subsampled image has additional considerations:  - Image data read as an image sampler will have undefined values if the sampler was not created with `flags` containing `VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT` or was not sampled through the use of a combined image sampler with an immutable sampler in [`DescriptorSetLayoutBinding`].  - Image data read with an input attachment will have undefined values if the contents were not written as an attachment in an earlier subpass of the same render pass.  - Image data read as an image sampler in the fragment shader will be additionally be read by the device during `VK_PIPELINE_STAGE_VERTEX_SHADER_BIT` if [[`PhysicalDeviceFragmentDensityMap2PropertiesEXT::subsampled_coarse_reconstruction_early_access`]](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#limits-subsampledCoarseReconstructionEarlyAccess) is [`TRUE`] and the sampler was created with `flags` containing `VK_SAMPLER_CREATE_SUBSAMPLED_COARSE_RECONSTRUCTION_BIT_EXT`.  - Image data read with load operations are resampled to the fragment density of the render pass if [[`PhysicalDeviceFragmentDensityMap2PropertiesEXT::subsampled_loads`]](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#limits-subsampledLoads) is [`TRUE`]. Otherwise, values of image data are undefined.  - Image contents outside of the render area take on undefined values if the image is stored as a render pass attachment.
/// - [`FragmentDensityMapOffsetQcom`] specifies that an image  **can**  be used in a render pass with non-zero [fragment density map offsets](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-fragmentdensitymapoffsets). In a renderpass with non-zero offsets, fragment density map attachments, input attachments, color attachments, depth/stencil attachment, resolve attachments, and preserve attachments  **must**  be created with VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_QCOM.
///See [Sparse Resource Features](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#sparsememory-sparseresourcefeatures) and
///[Sparse Physical Device Features](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#sparsememory-physicalfeatures) for more
///details.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`ImageCreateFlags`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkImageCreateFlagBits")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
#[repr(u32)]
pub enum ImageCreateFlagBits {
    #[doc(hidden)]
    Empty = 0,
    ///[`ImageCreateSparseBinding`] specifies that the image will
    ///be backed using sparse memory binding.
    ImageCreateSparseBinding = 1,
    ///[`ImageCreateSparseResidency`] specifies that the image  **can**
    ///be partially backed using sparse memory binding.
    ///Images created with this flag  **must**  also be created with the
    ///[`ImageCreateSparseBinding`] flag.
    ImageCreateSparseResidency = 2,
    ///[`ImageCreateSparseAliased`] specifies that the image will
    ///be backed using sparse memory binding with memory ranges that might also
    ///simultaneously be backing another image (or another portion of the same
    ///image).
    ///Images created with this flag  **must**  also be created with the
    ///[`ImageCreateSparseBinding`] flag.
    ImageCreateSparseAliased = 4,
    ///[`ImageCreateMutableFormat`] specifies that the image  **can**
    ///be used to create a [`ImageView`] with a different format from the
    ///image.
    ///For [multi-planar](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#formats-requiring-sampler-ycbcr-conversion) formats,
    ///[`ImageCreateMutableFormat`] specifies that a
    ///[`ImageView`] can be created of a *plane* of the image.
    ImageCreateMutableFormat = 8,
    ///[`ImageCreateCubeCompatible`] specifies that the image  **can**
    ///be used to create a [`ImageView`] of type
    ///`VK_IMAGE_VIEW_TYPE_CUBE` or `VK_IMAGE_VIEW_TYPE_CUBE_ARRAY`.
    ImageCreateCubeCompatible = 16,
    ///[`Alias`] specifies that two images created with
    ///    the same creation parameters and aliased to the same memory  **can**
    ///    interpret the contents of the memory consistently with each other,
    ///    subject to the rules described in the [Memory
    ///    Aliasing](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#resources-memory-aliasing) section.
    ///    This flag further specifies that each plane of a *disjoint* image  **can**
    ///    share an in-memory non-linear representation with single-plane images,
    ///    and that a single-plane image  **can**  share an in-memory non-linear
    ///    representation with a plane of a multi-planar disjoint image, according
    ///    to the rules in [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#formats-compatible-planes](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#formats-compatible-planes).
    ///    If the `pNext` chain includes a
    ///[`ExternalMemoryImageCreateInfo`]
    ///or
    ///[`ExternalMemoryImageCreateInfoNV`]
    ///    structure whose `handleTypes` member is not `0`, it is as if
    ///    [`Alias`] is set.
    ///
    ///Provided by [`crate::vulkan1_1`]
    Alias = 1024,
    ///[`SplitInstanceBindRegions`] specifies that the
    ///image  **can**  be used with a non-zero value of the
    ///`splitInstanceBindRegionCount` member of a
    ///[`BindImageMemoryDeviceGroupInfo`] structure passed into
    ///[`BindImageMemory2`].
    ///This flag also has the effect of making the image use the standard
    ///sparse image block dimensions.
    ///
    ///Provided by [`crate::vulkan1_1`]
    SplitInstanceBindRegions = 64,
    ///[`2DArrayCompatible`] specifies that the image
    /// **can**  be used to create a [`ImageView`] of type
    ///`VK_IMAGE_VIEW_TYPE_2D` or `VK_IMAGE_VIEW_TYPE_2D_ARRAY`.
    ///
    ///Provided by [`crate::vulkan1_1`]
    _2DArrayCompatible = 32,
    ///[`BlockTexelViewCompatible`] specifies that the
    ///image having a compressed format  **can**  be used to create a
    ///[`ImageView`] with an uncompressed format where each texel in the
    ///image view corresponds to a compressed texel block of the image.
    ///
    ///Provided by [`crate::vulkan1_1`]
    BlockTexelViewCompatible = 128,
    ///[`ExtendedUsage`] specifies that the image  **can**
    ///be created with usage flags that are not supported for the format the
    ///image is created with but are supported for at least one format a
    ///[`ImageView`] created from the image  **can**  have.
    ///
    ///Provided by [`crate::vulkan1_1`]
    ExtendedUsage = 256,
    ///[`Protected`] specifies that the image is a
    ///protected image.
    ///
    ///Provided by [`crate::vulkan1_1`]
    Protected = 2048,
    ///[`Disjoint`] specifies that an image with a
    ///[multi-planar format](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#formats-requiring-sampler-ycbcr-conversion) **must**
    ///have each plane separately bound to memory, rather than having a single
    ///memory binding for the whole image; the presence of this bit
    ///distinguishes a *disjoint image* from an image without this bit set.
    ///
    ///Provided by [`crate::vulkan1_1`]
    Disjoint = 512,
    ///[`CornerSampledNv`] specifies that the image is
    ///a [corner-sampled image](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#resources-images-corner-sampled).
    ///
    ///Provided by [`crate::extensions::nv_corner_sampled_image`]
    CornerSampledNv = 8192,
    ///[`SampleLocationsCompatibleDepthExt`]
    ///specifies that an image with a depth or depth/stencil format  **can**  be
    ///used with custom sample locations when used as a depth/stencil
    ///attachment.
    ///
    ///Provided by [`crate::extensions::ext_sample_locations`]
    SampleLocationsCompatibleDepthExt = 4096,
    ///[`SubsampledExt`] specifies that an image  **can**  be
    ///in a subsampled format which  **may**  be more optimal when written as an
    ///attachment by a render pass that has a fragment density map attachment.
    ///Accessing a subsampled image has additional considerations:
    /// - Image data read as an image sampler will have undefined values if the sampler was not
    ///   created with `flags` containing `VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT` or was not sampled
    ///   through the use of a combined image sampler with an immutable sampler in
    ///   [`DescriptorSetLayoutBinding`].
    /// - Image data read with an input attachment will have undefined values if the contents were
    ///   not written as an attachment in an earlier subpass of the same render pass.
    /// - Image data read as an image sampler in the fragment shader will be additionally be read by
    ///   the device during `VK_PIPELINE_STAGE_VERTEX_SHADER_BIT` if [[`PhysicalDeviceFragmentDensityMap2PropertiesEXT`]::`subsampledCoarseReconstructionEarlyAccess`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#limits-subsampledCoarseReconstructionEarlyAccess)
    ///   is [`TRUE`] and the sampler was created with `flags` containing
    ///   `VK_SAMPLER_CREATE_SUBSAMPLED_COARSE_RECONSTRUCTION_BIT_EXT`.
    /// - Image data read with load operations are resampled to the fragment density of the render pass if [[`PhysicalDeviceFragmentDensityMap2PropertiesEXT`]::`subsampledLoads`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#limits-subsampledLoads) is [`TRUE`]. Otherwise, values of image data are undefined.
    /// - Image contents outside of the render area take on undefined values if the image is stored
    ///   as a render pass attachment.
    ///
    ///Provided by [`crate::extensions::ext_fragment_density_map`]
    SubsampledExt = 16384,
    ///[`FragmentDensityMapOffsetQcom`] specifies
    ///that an image  **can**  be used in a render pass with non-zero
    ///[fragment density map offsets](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-fragmentdensitymapoffsets).
    ///In a renderpass with non-zero offsets, fragment density map attachments,
    ///input attachments, color attachments, depth/stencil attachment, resolve
    ///attachments, and preserve attachments  **must**  be created with
    ///VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_QCOM.
    ///
    ///Provided by [`crate::extensions::qcom_fragment_density_map_offset`]
    FragmentDensityMapOffsetQcom = 32768,
}
impl const Default for ImageCreateFlagBits {
    fn default() -> Self {
        Self::Empty
    }
}
impl ImageCreateFlagBits {
    ///Default empty value
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Gets the raw underlying value
    #[inline]
    pub const fn bits(&self) -> u32 {
        self as u32
    }
    ///Gets a value from a raw underlying value, unchecked and therefore unsafe
    #[inline]
    pub const unsafe fn from_bits(bits: u32) -> u32 {
        std::mem::transmute(bits)
    }
}
///[VkImageViewCreateFlagBits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageViewCreateFlagBits.html) - Bitmask specifying additional parameters of an image view
///# C Specifications
///Bits which  **can**  be set in [`ImageViewCreateInfo::flags`],
///specifying additional parameters of an image view, are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkImageViewCreateFlagBits {
///  // Provided by VK_EXT_fragment_density_map
///    VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT = 0x00000001,
///  // Provided by VK_EXT_fragment_density_map2
///    VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DEFERRED_BIT_EXT = 0x00000002,
///} VkImageViewCreateFlagBits;
///```
///# Description
/// - [`FragmentDensityMapDynamicExt`] specifies that the fragment density map will be read by
///   device during `VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT`
/// - [`FragmentDensityMapDeferredExt`] specifies that the fragment density map will be read by the
///   host during [`EndCommandBuffer`] for the primary command buffer that the render pass is
///   recorded into
///# Related
/// - [`crate::vulkan1_0`]
/// - [`ImageViewCreateFlags`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkImageViewCreateFlagBits")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
#[repr(u32)]
pub enum ImageViewCreateFlagBits {
    #[doc(hidden)]
    Empty = 0,
    ///[`FragmentDensityMapDynamicExt`]
    ///specifies that the fragment density map will be read by device during
    ///`VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT`
    ///
    ///Provided by [`crate::extensions::ext_fragment_density_map`]
    FragmentDensityMapDynamicExt = 1,
    ///[`FragmentDensityMapDeferredExt`]
    ///specifies that the fragment density map will be read by the host during
    ///[`EndCommandBuffer`] for the primary command buffer that the render
    ///pass is recorded into
    ///
    ///Provided by [`crate::extensions::ext_fragment_density_map_2`]
    FragmentDensityMapDeferredExt = 2,
}
impl const Default for ImageViewCreateFlagBits {
    fn default() -> Self {
        Self::Empty
    }
}
impl ImageViewCreateFlagBits {
    ///Default empty value
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Gets the raw underlying value
    #[inline]
    pub const fn bits(&self) -> u32 {
        self as u32
    }
    ///Gets a value from a raw underlying value, unchecked and therefore unsafe
    #[inline]
    pub const unsafe fn from_bits(bits: u32) -> u32 {
        std::mem::transmute(bits)
    }
}
///[VkSamplerCreateFlagBits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSamplerCreateFlagBits.html) - Bitmask specifying additional parameters of sampler
///# C Specifications
///Bits which  **can**  be set in [`SamplerCreateInfo::flags`], specifying
///additional parameters of a sampler, are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkSamplerCreateFlagBits {
///  // Provided by VK_EXT_fragment_density_map
///    VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT = 0x00000001,
///  // Provided by VK_EXT_fragment_density_map
///    VK_SAMPLER_CREATE_SUBSAMPLED_COARSE_RECONSTRUCTION_BIT_EXT = 0x00000002,
///} VkSamplerCreateFlagBits;
///```
///# Description
/// - [`SubsampledExt`] specifies that the sampler will read from an image created with `flags`
///   containing `VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT`.
/// - [`SubsampledCoarseReconstructionExt`] specifies that the implementation  **may**  use
///   approximations when reconstructing a full color value for texture access from a subsampled
///   image.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`SamplerCreateFlags`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkSamplerCreateFlagBits")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
#[repr(u32)]
pub enum SamplerCreateFlagBits {
    #[doc(hidden)]
    Empty = 0,
    ///[`SubsampledExt`]
    ///specifies that the sampler will read from an image created with
    ///`flags` containing `VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT`.
    ///
    ///Provided by [`crate::extensions::ext_fragment_density_map`]
    SubsampledExt = 1,
    ///[`SubsampledCoarseReconstructionExt`]
    ///specifies that the implementation  **may**  use approximations when
    ///reconstructing a full color value for texture access from a subsampled
    ///image.
    ///
    ///Provided by [`crate::extensions::ext_fragment_density_map`]
    SubsampledCoarseReconstructionExt = 2,
}
impl const Default for SamplerCreateFlagBits {
    fn default() -> Self {
        Self::Empty
    }
}
impl SamplerCreateFlagBits {
    ///Default empty value
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Gets the raw underlying value
    #[inline]
    pub const fn bits(&self) -> u32 {
        self as u32
    }
    ///Gets a value from a raw underlying value, unchecked and therefore unsafe
    #[inline]
    pub const unsafe fn from_bits(bits: u32) -> u32 {
        std::mem::transmute(bits)
    }
}
///[VkPipelineCreateFlagBits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineCreateFlagBits.html) - Bitmask controlling how a pipeline is created
///# C Specifications
///Bits which  **can**  be set in
///  * [`GraphicsPipelineCreateInfo::flags`]
///  * [`ComputePipelineCreateInfo::flags`]
///  * [`RayTracingPipelineCreateInfoKHR::flags`]
///  * [`RayTracingPipelineCreateInfoNV::flags`]
///specify how a pipeline is created, and are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkPipelineCreateFlagBits {
///    VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT = 0x00000001,
///    VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT = 0x00000002,
///    VK_PIPELINE_CREATE_DERIVATIVE_BIT = 0x00000004,
///  // Provided by VK_VERSION_1_1
///    VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT = 0x00000008,
///  // Provided by VK_VERSION_1_1
///    VK_PIPELINE_CREATE_DISPATCH_BASE_BIT = 0x00000010,
///  // Provided by VK_VERSION_1_3
///    VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT = 0x00000100,
///  // Provided by VK_VERSION_1_3
///    VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT = 0x00000200,
///  // Provided by VK_KHR_dynamic_rendering with VK_KHR_fragment_shading_rate
///    VK_PIPELINE_CREATE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = 0x00200000,
///  // Provided by VK_KHR_dynamic_rendering with VK_EXT_fragment_density_map
///    VK_PIPELINE_CREATE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT = 0x00400000,
///  // Provided by VK_KHR_ray_tracing_pipeline
///    VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR = 0x00004000,
///  // Provided by VK_KHR_ray_tracing_pipeline
///    VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR = 0x00008000,
///  // Provided by VK_KHR_ray_tracing_pipeline
///    VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR = 0x00010000,
///  // Provided by VK_KHR_ray_tracing_pipeline
///    VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR = 0x00020000,
///  // Provided by VK_KHR_ray_tracing_pipeline
///    VK_PIPELINE_CREATE_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR = 0x00001000,
///  // Provided by VK_KHR_ray_tracing_pipeline
///    VK_PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR = 0x00002000,
///  // Provided by VK_KHR_ray_tracing_pipeline
///    VK_PIPELINE_CREATE_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR = 0x00080000,
///  // Provided by VK_NV_ray_tracing
///    VK_PIPELINE_CREATE_DEFER_COMPILE_BIT_NV = 0x00000020,
///  // Provided by VK_KHR_pipeline_executable_properties
///    VK_PIPELINE_CREATE_CAPTURE_STATISTICS_BIT_KHR = 0x00000040,
///  // Provided by VK_KHR_pipeline_executable_properties
///    VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR = 0x00000080,
///  // Provided by VK_NV_device_generated_commands
///    VK_PIPELINE_CREATE_INDIRECT_BINDABLE_BIT_NV = 0x00040000,
///  // Provided by VK_KHR_pipeline_library
///    VK_PIPELINE_CREATE_LIBRARY_BIT_KHR = 0x00000800,
///  // Provided by VK_NV_ray_tracing_motion_blur
///    VK_PIPELINE_CREATE_RAY_TRACING_ALLOW_MOTION_BIT_NV = 0x00100000,
///  // Provided by VK_VERSION_1_1
///    VK_PIPELINE_CREATE_DISPATCH_BASE = VK_PIPELINE_CREATE_DISPATCH_BASE_BIT,
///  // Provided by VK_KHR_dynamic_rendering with VK_KHR_fragment_shading_rate
///    VK_PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR =
/// VK_PIPELINE_CREATE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR,
///  // Provided by VK_KHR_dynamic_rendering with VK_EXT_fragment_density_map
///    VK_PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT =
/// VK_PIPELINE_CREATE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT,
///  // Provided by VK_KHR_device_group
///    VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR =
/// VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT,
///  // Provided by VK_KHR_device_group
///    VK_PIPELINE_CREATE_DISPATCH_BASE_KHR = VK_PIPELINE_CREATE_DISPATCH_BASE,
///  // Provided by VK_EXT_pipeline_creation_cache_control
///    VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT_EXT =
/// VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT,
///  // Provided by VK_EXT_pipeline_creation_cache_control
///    VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT_EXT =
/// VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT,
///} VkPipelineCreateFlagBits;
///```
///# Description
/// - [`PipelineCreateDisableOptimization`] specifies that the created pipeline will not be
///   optimized. Using this flag  **may**  reduce the time taken to create the pipeline.
/// - [`PipelineCreateAllowDerivatives`] specifies that the pipeline to be created is allowed to be
///   the parent of a pipeline that will be created in a subsequent pipeline creation call.
/// - [`PipelineCreateDerivative`] specifies that the pipeline to be created will be a child of a
///   previously created parent pipeline.
/// - [`ViewIndexFromDeviceIndex`] specifies that any shader input variables decorated as
///   `ViewIndex` will be assigned values as if they were decorated as `DeviceIndex`.
/// - [`DispatchBase`] specifies that a compute pipeline  **can**  be used with [`CmdDispatchBase`]
///   with a non-zero base workgroup.
/// - [`DeferCompileNv`] specifies that a pipeline is created with all shaders in the deferred
///   state. Before using the pipeline the application  **must**  call [`CompileDeferredNV`] exactly
///   once on each shader in the pipeline before using the pipeline.
/// - [`CaptureStatisticsKhr`] specifies that the shader compiler should capture statistics for the
///   pipeline executables produced by the compile process which  **can**  later be retrieved by
///   calling [`GetPipelineExecutableStatisticsKHR`]. Enabling this flag  **must**  not affect the
///   final compiled pipeline but  **may**  disable pipeline caching or otherwise affect pipeline
///   creation time.
/// - [`CaptureInternalRepresentationsKhr`] specifies that the shader compiler should capture the
///   internal representations of pipeline executables produced by the compile process which
///   **can**  later be retrieved by calling [`GetPipelineExecutableInternalRepresentationsKHR`].
///   Enabling this flag  **must**  not affect the final compiled pipeline but  **may**  disable
///   pipeline caching or otherwise affect pipeline creation time.
/// - [`LibraryKhr`] specifies that the pipeline  **cannot**  be used directly, and instead defines
///   a *pipeline library* that  **can**  be combined with other pipelines using the
///   [`PipelineLibraryCreateInfoKHR`] structure. This is available in ray tracing pipelines.
/// - [`RayTracingNoNullAnyHitShadersKhr`] specifies that an any-hit shader will always be present
///   when an any-hit shader would be executed. A NULL any-hit shader is an any-hit shader which is
///   effectively [`SHADER_UNUSED_KHR`], such as from a shader group consisting entirely of zeros.
/// - [`RayTracingNoNullClosestHitShadersKhr`] specifies that a closest hit shader will always be
///   present when a closest hit shader would be executed. A NULL closest hit shader is a closest
///   hit shader which is effectively [`SHADER_UNUSED_KHR`], such as from a shader group consisting
///   entirely of zeros.
/// - [`RayTracingNoNullMissShadersKhr`] specifies that a miss shader will always be present when a
///   miss shader would be executed. A NULL miss shader is a miss shader which is effectively
///   [`SHADER_UNUSED_KHR`], such as from a shader group consisting entirely of zeros.
/// - [`RayTracingNoNullIntersectionShadersKhr`] specifies that an intersection shader will always
///   be present when an intersection shader would be executed. A NULL intersection shader is an
///   intersection shader which is effectively [`SHADER_UNUSED_KHR`], such as from a shader group
///   consisting entirely of zeros.
/// - [`RayTracingSkipTrianglesKhr`] specifies that triangle primitives will be skipped during
///   traversal using `OpTraceRayKHR`.
/// - [`RayTracingSkipAabbsKhr`] specifies that AABB primitives will be skipped during traversal
///   using `OpTraceRayKHR`.
/// - [`RayTracingShaderGroupHandleCaptureReplayKhr`] specifies that the shader group handles
///   **can**  be saved and reused on a subsequent run (e.g. for trace capture and replay).
/// - [`IndirectBindableNv`] specifies that the pipeline can be used in combination with [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#device-generated-commands](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#device-generated-commands).
/// - [`FailOnPipelineCompileRequired`] specifies that pipeline creation will fail if a compile is
///   required for creation of a valid [`Pipeline`] object; `VK_PIPELINE_COMPILE_REQUIRED` will be
///   returned by pipeline creation, and the [`Pipeline`] will be set to
///   [`crate::utils::Handle::null`].
/// - When creating multiple pipelines, [`EarlyReturnOnFailure`] specifies that control will be
///   returned to the application on failure of the corresponding pipeline rather than continuing to
///   create additional pipelines.
/// - [`RayTracingAllowMotionNv`] specifies that the pipeline is allowed to use
///   `OpTraceRayMotionNV`.
/// - [`RenderingFragmentShadingRateAttachmentKhr`] specifies that the pipeline will be used with a
///   fragment shading rate attachment.
/// - [`RenderingFragmentDensityMapAttachmentExt`] specifies that the pipeline will be used with a
///   fragment density map attachment.
///It is valid to set both [`PipelineCreateAllowDerivatives`] and
///[`PipelineCreateDerivative`].
///This allows a pipeline to be both a parent and possibly a child in a
///pipeline hierarchy.
///See [Pipeline Derivatives](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipelines-pipeline-derivatives) for more
///information.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`PipelineCreateFlags`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkPipelineCreateFlagBits")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
#[repr(u32)]
pub enum PipelineCreateFlagBits {
    #[doc(hidden)]
    Empty = 0,
    ///[`PipelineCreateDisableOptimization`] specifies that the
    ///created pipeline will not be optimized.
    ///Using this flag  **may**  reduce the time taken to create the pipeline.
    PipelineCreateDisableOptimization = 1,
    ///[`PipelineCreateAllowDerivatives`] specifies that the
    ///pipeline to be created is allowed to be the parent of a pipeline that
    ///will be created in a subsequent pipeline creation call.
    PipelineCreateAllowDerivatives = 2,
    ///[`PipelineCreateDerivative`] specifies that the pipeline to
    ///be created will be a child of a previously created parent pipeline.
    PipelineCreateDerivative = 4,
    ///[`ViewIndexFromDeviceIndex`] specifies that
    ///any shader input variables decorated as `ViewIndex` will be assigned
    ///values as if they were decorated as `DeviceIndex`.
    ///
    ///Provided by [`crate::vulkan1_1`]
    ViewIndexFromDeviceIndex = 8,
    ///[`DispatchBase`] specifies that a compute pipeline
    /// **can**  be used with [`CmdDispatchBase`] with a non-zero base
    ///workgroup.
    ///
    ///Provided by [`crate::vulkan1_1`]
    DispatchBase = 16,
    ///[`FailOnPipelineCompileRequired`] specifies
    ///that pipeline creation will fail if a compile is required for creation
    ///of a valid [`Pipeline`] object; `VK_PIPELINE_COMPILE_REQUIRED`
    ///will be returned by pipeline creation, and the [`Pipeline`] will be
    ///set to [`crate::utils::Handle::null`].
    ///
    ///Provided by [`crate::vulkan1_3`]
    FailOnPipelineCompileRequired = 256,
    ///When creating multiple pipelines,
    ///[`EarlyReturnOnFailure`] specifies that
    ///control will be returned to the application on failure of the
    ///corresponding pipeline rather than continuing to create additional
    ///pipelines.
    ///
    ///Provided by [`crate::vulkan1_3`]
    EarlyReturnOnFailure = 512,
    ///[`RenderingFragmentShadingRateAttachmentKhr`]
    ///specifies that the pipeline will be used with a fragment shading rate
    ///attachment.
    ///
    ///Provided by [`crate::extensions::khr_dynamic_rendering`]
    RenderingFragmentShadingRateAttachmentKhr = 2097152,
    ///[`RenderingFragmentDensityMapAttachmentExt`]
    ///specifies that the pipeline will be used with a fragment density map
    ///attachment.
    ///
    ///Provided by [`crate::extensions::khr_dynamic_rendering`]
    RenderingFragmentDensityMapAttachmentExt = 4194304,
    ///[`RayTracingNoNullAnyHitShadersKhr`]
    ///specifies that an any-hit shader will always be present when an any-hit
    ///shader would be executed.
    ///A NULL any-hit shader is an any-hit shader which is effectively
    ///[`SHADER_UNUSED_KHR`], such as from a shader group consisting
    ///entirely of zeros.
    ///
    ///Provided by [`crate::extensions::khr_ray_tracing_pipeline`]
    RayTracingNoNullAnyHitShadersKhr = 16384,
    ///[`RayTracingNoNullClosestHitShadersKhr`]
    ///specifies that a closest hit shader will always be present when a
    ///closest hit shader would be executed.
    ///A NULL closest hit shader is a closest hit shader which is effectively
    ///[`SHADER_UNUSED_KHR`], such as from a shader group consisting
    ///entirely of zeros.
    ///
    ///Provided by [`crate::extensions::khr_ray_tracing_pipeline`]
    RayTracingNoNullClosestHitShadersKhr = 32768,
    ///[`RayTracingNoNullMissShadersKhr`]
    ///specifies that a miss shader will always be present when a miss shader
    ///would be executed.
    ///A NULL miss shader is a miss shader which is effectively
    ///[`SHADER_UNUSED_KHR`], such as from a shader group consisting
    ///entirely of zeros.
    ///
    ///Provided by [`crate::extensions::khr_ray_tracing_pipeline`]
    RayTracingNoNullMissShadersKhr = 65536,
    ///[`RayTracingNoNullIntersectionShadersKhr`]
    ///specifies that an intersection shader will always be present when an
    ///intersection shader would be executed.
    ///A NULL intersection shader is an intersection shader which is
    ///effectively [`SHADER_UNUSED_KHR`], such as from a shader group
    ///consisting entirely of zeros.
    ///
    ///Provided by [`crate::extensions::khr_ray_tracing_pipeline`]
    RayTracingNoNullIntersectionShadersKhr = 131072,
    ///[`RayTracingSkipTrianglesKhr`] specifies
    ///that triangle primitives will be skipped during traversal using
    ///`OpTraceRayKHR`.
    ///
    ///Provided by [`crate::extensions::khr_ray_tracing_pipeline`]
    RayTracingSkipTrianglesKhr = 4096,
    ///[`RayTracingSkipAabbsKhr`] specifies that
    ///AABB primitives will be skipped during traversal using
    ///`OpTraceRayKHR`.
    ///
    ///Provided by [`crate::extensions::khr_ray_tracing_pipeline`]
    RayTracingSkipAabbsKhr = 8192,
    ///[`RayTracingShaderGroupHandleCaptureReplayKhr`]
    ///specifies that the shader group handles  **can**  be saved and reused on a
    ///subsequent run (e.g. for trace capture and replay).
    ///
    ///Provided by [`crate::extensions::khr_ray_tracing_pipeline`]
    RayTracingShaderGroupHandleCaptureReplayKhr = 524288,
    ///[`DeferCompileNv`] specifies that a pipeline
    ///is created with all shaders in the deferred state.
    ///Before using the pipeline the application  **must**  call
    ///[`CompileDeferredNV`] exactly once on each shader in the pipeline
    ///before using the pipeline.
    ///
    ///Provided by [`crate::extensions::nv_ray_tracing`]
    DeferCompileNv = 32,
    ///[`CaptureStatisticsKhr`] specifies that the
    ///shader compiler should capture statistics for the pipeline executables
    ///produced by the compile process which  **can**  later be retrieved by calling
    ///[`GetPipelineExecutableStatisticsKHR`].
    ///Enabling this flag  **must**  not affect the final compiled pipeline but  **may**
    ///disable pipeline caching or otherwise affect pipeline creation time.
    ///
    ///Provided by [`crate::extensions::khr_pipeline_executable_properties`]
    CaptureStatisticsKhr = 64,
    ///[`CaptureInternalRepresentationsKhr`]
    ///specifies that the shader compiler should capture the internal
    ///representations of pipeline executables produced by the compile process
    ///which  **can**  later be retrieved by calling
    ///[`GetPipelineExecutableInternalRepresentationsKHR`].
    ///Enabling this flag  **must**  not affect the final compiled pipeline but  **may**
    ///disable pipeline caching or otherwise affect pipeline creation time.
    ///
    ///Provided by [`crate::extensions::khr_pipeline_executable_properties`]
    CaptureInternalRepresentationsKhr = 128,
    ///[`IndirectBindableNv`] specifies that the
    ///pipeline can be used in combination with [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#device-generated-commands](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#device-generated-commands).
    ///
    ///Provided by [`crate::extensions::nv_device_generated_commands`]
    IndirectBindableNv = 262144,
    ///[`LibraryKhr`] specifies that the pipeline
    /// **cannot**  be used directly, and instead defines a *pipeline library* that
    /// **can**  be combined with other pipelines using the
    ///[`PipelineLibraryCreateInfoKHR`] structure.
    ///This is available in ray tracing pipelines.
    ///
    ///Provided by [`crate::extensions::khr_pipeline_library`]
    LibraryKhr = 2048,
    ///[`RayTracingAllowMotionNv`] specifies that
    ///the pipeline is allowed to use `OpTraceRayMotionNV`.
    ///
    ///Provided by [`crate::extensions::nv_ray_tracing_motion_blur`]
    RayTracingAllowMotionNv = 1048576,
}
impl const Default for PipelineCreateFlagBits {
    fn default() -> Self {
        Self::Empty
    }
}
impl PipelineCreateFlagBits {
    ///Default empty value
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Gets the raw underlying value
    #[inline]
    pub const fn bits(&self) -> u32 {
        self as u32
    }
    ///Gets a value from a raw underlying value, unchecked and therefore unsafe
    #[inline]
    pub const unsafe fn from_bits(bits: u32) -> u32 {
        std::mem::transmute(bits)
    }
}
///[VkPipelineShaderStageCreateFlagBits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineShaderStageCreateFlagBits.html) - Bitmask controlling how a pipeline shader stage is created
///# C Specifications
///Possible values of the `flags` member of
///[`PipelineShaderStageCreateInfo`] specifying how a pipeline shader stage
///is created, are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkPipelineShaderStageCreateFlagBits {
///  // Provided by VK_VERSION_1_3
///    VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT = 0x00000001,
///  // Provided by VK_VERSION_1_3
///    VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT = 0x00000002,
///  // Provided by VK_EXT_subgroup_size_control
///    VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT =
/// VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT,
///  // Provided by VK_EXT_subgroup_size_control
///    VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT =
/// VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT,
///} VkPipelineShaderStageCreateFlagBits;
///```
///# Description
/// - [`AllowVaryingSubgroupSize`] specifies that the [`SubgroupSize`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#interfaces-builtin-variables-sgs)
///   **may**  vary in the shader stage.
/// - [`RequireFullSubgroups`] specifies that the subgroup sizes  **must**  be launched with all
///   invocations active in the compute stage.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`PipelineShaderStageCreateFlags`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkPipelineShaderStageCreateFlagBits")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
#[repr(u32)]
pub enum PipelineShaderStageCreateFlagBits {
    #[doc(hidden)]
    Empty = 0,
    ///[`AllowVaryingSubgroupSize`]
    ///specifies that the
    ///[`SubgroupSize`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#interfaces-builtin-variables-sgs) **may**  vary in the
    ///shader stage.
    ///
    ///Provided by [`crate::vulkan1_3`]
    AllowVaryingSubgroupSize = 1,
    ///[`RequireFullSubgroups`]
    ///specifies that the subgroup sizes  **must**  be launched with all invocations
    ///active in the compute stage.
    ///
    ///Provided by [`crate::vulkan1_3`]
    RequireFullSubgroups = 2,
}
impl const Default for PipelineShaderStageCreateFlagBits {
    fn default() -> Self {
        Self::Empty
    }
}
impl PipelineShaderStageCreateFlagBits {
    ///Default empty value
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Gets the raw underlying value
    #[inline]
    pub const fn bits(&self) -> u32 {
        self as u32
    }
    ///Gets a value from a raw underlying value, unchecked and therefore unsafe
    #[inline]
    pub const unsafe fn from_bits(bits: u32) -> u32 {
        std::mem::transmute(bits)
    }
}
///[VkColorComponentFlagBits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkColorComponentFlagBits.html) - Bitmask controlling which components are written to the framebuffer
///# C Specifications
///Bits which  **can**  be set in
///[`PipelineColorBlendAttachmentState::color_write_mask`], determining
///whether the final color values R, G, B and A are written to the
///framebuffer attachment, are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkColorComponentFlagBits {
///    VK_COLOR_COMPONENT_R_BIT = 0x00000001,
///    VK_COLOR_COMPONENT_G_BIT = 0x00000002,
///    VK_COLOR_COMPONENT_B_BIT = 0x00000004,
///    VK_COLOR_COMPONENT_A_BIT = 0x00000008,
///} VkColorComponentFlagBits;
///```
///# Description
/// - [`ColorComponentR`] specifies that the R value is written to the color attachment for the
///   appropriate sample. Otherwise, the value in memory is unmodified.
/// - [`ColorComponentG`] specifies that the G value is written to the color attachment for the
///   appropriate sample. Otherwise, the value in memory is unmodified.
/// - [`ColorComponentB`] specifies that the B value is written to the color attachment for the
///   appropriate sample. Otherwise, the value in memory is unmodified.
/// - [`ColorComponentA`] specifies that the A value is written to the color attachment for the
///   appropriate sample. Otherwise, the value in memory is unmodified.
///The color write mask operation is applied regardless of whether blending is
///enabled.The color write mask operation is applied only if
///[Color Write Enable](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#framebuffer-color-write-enable) is enabled for the
///respective attachment.
///Otherwise the color write mask is ignored and writes to all components of
///the attachment are disabled.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`ColorComponentFlags`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkColorComponentFlagBits")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
#[repr(u32)]
pub enum ColorComponentFlagBits {
    #[doc(hidden)]
    Empty = 0,
    ///[`ColorComponentR`] specifies that the R value is
    ///written to the color attachment for the appropriate sample.
    ///Otherwise, the value in memory is unmodified.
    ColorComponentR = 1,
    ///[`ColorComponentG`] specifies that the G value is
    ///written to the color attachment for the appropriate sample.
    ///Otherwise, the value in memory is unmodified.
    ColorComponentG = 2,
    ///[`ColorComponentB`] specifies that the B value is
    ///written to the color attachment for the appropriate sample.
    ///Otherwise, the value in memory is unmodified.
    ColorComponentB = 4,
    ///[`ColorComponentA`] specifies that the A value is
    ///written to the color attachment for the appropriate sample.
    ///Otherwise, the value in memory is unmodified.
    ColorComponentA = 8,
}
impl const Default for ColorComponentFlagBits {
    fn default() -> Self {
        Self::Empty
    }
}
impl ColorComponentFlagBits {
    ///Default empty value
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Gets the raw underlying value
    #[inline]
    pub const fn bits(&self) -> u32 {
        self as u32
    }
    ///Gets a value from a raw underlying value, unchecked and therefore unsafe
    #[inline]
    pub const unsafe fn from_bits(bits: u32) -> u32 {
        std::mem::transmute(bits)
    }
}
///[VkFenceCreateFlagBits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFenceCreateFlagBits.html) - Bitmask specifying initial state and behavior of a fence
///# C Specifications
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkFenceCreateFlagBits {
///    VK_FENCE_CREATE_SIGNALED_BIT = 0x00000001,
///} VkFenceCreateFlagBits;
///```
///# Description
/// - [`FenceCreateSignaled`] specifies that the fence object is created in the signaled state.
///   Otherwise, it is created in the unsignaled state.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`FenceCreateFlags`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkFenceCreateFlagBits")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
#[repr(u32)]
pub enum FenceCreateFlagBits {
    #[doc(hidden)]
    Empty = 0,
    ///[`FenceCreateSignaled`] specifies that the fence object is
    ///created in the signaled state.
    ///Otherwise, it is created in the unsignaled state.
    FenceCreateSignaled = 1,
}
impl const Default for FenceCreateFlagBits {
    fn default() -> Self {
        Self::Empty
    }
}
impl FenceCreateFlagBits {
    ///Default empty value
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Gets the raw underlying value
    #[inline]
    pub const fn bits(&self) -> u32 {
        self as u32
    }
    ///Gets a value from a raw underlying value, unchecked and therefore unsafe
    #[inline]
    pub const unsafe fn from_bits(bits: u32) -> u32 {
        std::mem::transmute(bits)
    }
}
///[VkFormatFeatureFlagBits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFormatFeatureFlagBits.html) - Bitmask specifying features supported by a buffer
///# C Specifications
///Bits which  **can**  be set in the [`FormatProperties`] features
///`linearTilingFeatures`, `optimalTilingFeatures`,
///[`DrmFormatModifierPropertiesEXT::drm_format_modifier_tiling_features`],
///and `bufferFeatures` are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkFormatFeatureFlagBits {
///    VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT = 0x00000001,
///    VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT = 0x00000002,
///    VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT = 0x00000004,
///    VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT = 0x00000008,
///    VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT = 0x00000010,
///    VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT = 0x00000020,
///    VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT = 0x00000040,
///    VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT = 0x00000080,
///    VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT = 0x00000100,
///    VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT = 0x00000200,
///    VK_FORMAT_FEATURE_BLIT_SRC_BIT = 0x00000400,
///    VK_FORMAT_FEATURE_BLIT_DST_BIT = 0x00000800,
///    VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT = 0x00001000,
///  // Provided by VK_VERSION_1_1
///    VK_FORMAT_FEATURE_TRANSFER_SRC_BIT = 0x00004000,
///  // Provided by VK_VERSION_1_1
///    VK_FORMAT_FEATURE_TRANSFER_DST_BIT = 0x00008000,
///  // Provided by VK_VERSION_1_1
///    VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT = 0x00020000,
///  // Provided by VK_VERSION_1_1
///    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT = 0x00040000,
///  // Provided by VK_VERSION_1_1
///    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT =
/// 0x00080000,
///  // Provided by VK_VERSION_1_1
///    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT =
/// 0x00100000,
///  // Provided by VK_VERSION_1_1
///    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT
/// = 0x00200000,
///  // Provided by VK_VERSION_1_1
///    VK_FORMAT_FEATURE_DISJOINT_BIT = 0x00400000,
///  // Provided by VK_VERSION_1_1
///    VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT = 0x00800000,
///  // Provided by VK_VERSION_1_2
///    VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT = 0x00010000,
///  // Provided by VK_IMG_filter_cubic
///    VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG = 0x00002000,
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_KHR_video_decode_queue
///    VK_FORMAT_FEATURE_VIDEO_DECODE_OUTPUT_BIT_KHR = 0x02000000,
///#endif
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_KHR_video_decode_queue
///    VK_FORMAT_FEATURE_VIDEO_DECODE_DPB_BIT_KHR = 0x04000000,
///#endif
///  // Provided by VK_KHR_acceleration_structure
///    VK_FORMAT_FEATURE_ACCELERATION_STRUCTURE_VERTEX_BUFFER_BIT_KHR = 0x20000000,
///  // Provided by VK_EXT_fragment_density_map
///    VK_FORMAT_FEATURE_FRAGMENT_DENSITY_MAP_BIT_EXT = 0x01000000,
///  // Provided by VK_KHR_fragment_shading_rate
///    VK_FORMAT_FEATURE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = 0x40000000,
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_KHR_video_encode_queue
///    VK_FORMAT_FEATURE_VIDEO_ENCODE_INPUT_BIT_KHR = 0x08000000,
///#endif
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_KHR_video_encode_queue
///    VK_FORMAT_FEATURE_VIDEO_ENCODE_DPB_BIT_KHR = 0x10000000,
///#endif
///  // Provided by VK_KHR_maintenance1
///    VK_FORMAT_FEATURE_TRANSFER_SRC_BIT_KHR = VK_FORMAT_FEATURE_TRANSFER_SRC_BIT,
///  // Provided by VK_KHR_maintenance1
///    VK_FORMAT_FEATURE_TRANSFER_DST_BIT_KHR = VK_FORMAT_FEATURE_TRANSFER_DST_BIT,
///  // Provided by VK_EXT_sampler_filter_minmax
///    VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT =
/// VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT,
///  // Provided by VK_KHR_sampler_ycbcr_conversion
///    VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT_KHR =
/// VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT,
///  // Provided by VK_KHR_sampler_ycbcr_conversion
///    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR =
/// VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT,
///  // Provided by VK_KHR_sampler_ycbcr_conversion
///    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR =
/// VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT,
///  // Provided by VK_KHR_sampler_ycbcr_conversion
///    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR =
/// VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT,
///  // Provided by VK_KHR_sampler_ycbcr_conversion
///    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR = VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT,
///  // Provided by VK_KHR_sampler_ycbcr_conversion
///    VK_FORMAT_FEATURE_DISJOINT_BIT_KHR = VK_FORMAT_FEATURE_DISJOINT_BIT,
///  // Provided by VK_KHR_sampler_ycbcr_conversion
///    VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT_KHR =
/// VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT,
///  // Provided by VK_EXT_filter_cubic
///    VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT =
/// VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG,
///} VkFormatFeatureFlagBits;
///```
///# Description
///These values
///all have the same meaning as the equivalently named values for
///[`FormatFeatureFlags2`] and
/// **may**  be set in
///`linearTilingFeatures`, `optimalTilingFeatures`, and
///[`DrmFormatModifierPropertiesEXT::drm_format_modifier_tiling_features`],
///specifying that the features are supported by [`Image`] or
///[`ImageView`]
///or [`SamplerYcbcrConversion`]
///created with the queried
///[`GetPhysicalDeviceFormatProperties`]`::format`:
/// - [`FormatFeatureSampledImage`] specifies that an image view  **can**  be [sampled from](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-sampledimage).
/// - [`FormatFeatureStorageImage`] specifies that an image view  **can**  be used as a [storage image](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storageimage).
/// - [`FormatFeatureStorageImageAtomic`] specifies that an image view  **can**  be used as storage
///   image that supports atomic operations.
/// - [`FormatFeatureColorAttachment`] specifies that an image view  **can**  be used as a
///   framebuffer color attachment and as an input attachment.
/// - [`FormatFeatureColorAttachmentBlend`] specifies that an image view  **can**  be used as a
///   framebuffer color attachment that supports blending and as an input attachment.
/// - [`FormatFeatureDepthStencilAttachment`] specifies that an image view  **can**  be used as a
///   framebuffer depth/stencil attachment and as an input attachment.
/// - [`FormatFeatureBlitSrc`] specifies that an image  **can**  be used as `srcImage` for the
///   [`CmdBlitImage2`] and [`CmdBlitImage`] commands.
/// - [`FormatFeatureBlitDst`] specifies that an image  **can**  be used as `dstImage` for the
///   [`CmdBlitImage2`] and [`CmdBlitImage`] commands.
/// - [`FormatFeatureSampledImageFilterLinear`] specifies that if [`FormatFeatureSampledImage`] is
///   also set, an image view  **can**  be used with a sampler that has either of `magFilter` or
///   `minFilter` set to `VK_FILTER_LINEAR`, or `mipmapMode` set to `VK_SAMPLER_MIPMAP_MODE_LINEAR`.
///   If [`FormatFeatureBlitSrc`] is also set, an image can be used as the `srcImage` to
///   [`CmdBlitImage2`] and [`CmdBlitImage`] with a `filter` of `VK_FILTER_LINEAR`. This bit
///   **must**  only be exposed for formats that also support the [`FormatFeatureSampledImage`] or
///   [`FormatFeatureBlitSrc`].If the format being queried is a depth/stencil format, this bit only
///   specifies that the depth aspect (not the stencil aspect) of an image of this format supports
///   linear filtering, and that linear filtering of the depth aspect is supported whether depth
///   compare is enabled in the sampler or not. Where depth comparison is supported it  **may**  be
///   linear filtered whether this bit is present or not, but where this bit is not present the
///   filtered value  **may**  be computed in an implementation-dependent manner which differs from
///   the normal rules of linear filtering. The resulting value  **must**  be in the range [0,1] and
///   **should**  be proportional to, or a weighted average of, the number of comparison passes or
///   failures.
/// - [`TransferSrc`] specifies that an image  **can**  be used as a source image for [copy commands](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#copies).
/// - [`TransferDst`] specifies that an image  **can**  be used as a destination image for [copy commands](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#copies)
///   and [clear commands](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#clears).
/// - [`SampledImageFilterMinmax`] specifies [`Image`] **can**  be used as a sampled image with a
///   min or max [`SamplerReductionMode`]. This bit  **must**  only be exposed for formats that also
///   support the [`FormatFeatureSampledImage`].
/// - [`SampledImageFilterCubicExt`] specifies that [`Image`] **can**  be used with a sampler that
///   has either of `magFilter` or `minFilter` set to `VK_FILTER_CUBIC_EXT`, or be the source image
///   for a blit with `filter` set to `VK_FILTER_CUBIC_EXT`. This bit  **must**  only be exposed for
///   formats that also support the [`FormatFeatureSampledImage`]. If the format being queried is a
///   depth/stencil format, this only specifies that the depth aspect is cubic filterable.
/// - [`MidpointChromaSamples`] specifies that an application  **can**  define a [sampler Y′C<sub>B</sub>C<sub>R</sub> conversion](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#samplers-YCbCr-conversion) using this format as a source, and that an image of this format  **can**  be used with a [`SamplerYcbcrConversionCreateInfo`]`xChromaOffset` and/or `yChromaOffset` of `VK_CHROMA_LOCATION_MIDPOINT`. Otherwise both `xChromaOffset` and `yChromaOffset` **must**  be `VK_CHROMA_LOCATION_COSITED_EVEN`. If a format does not incorporate chroma downsampling (it is not a “422” or “420” format) but the implementation supports sampler Y′C<sub>B</sub>C<sub>R</sub> conversion for this format, the implementation  **must**  set [`MidpointChromaSamples`].
/// - [`CositedChromaSamples`] specifies that an application  **can**  define a [sampler Y′C<sub>B</sub>C<sub>R</sub> conversion](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#samplers-YCbCr-conversion) using this format as a source, and that an image of this format  **can**  be used with a [`SamplerYcbcrConversionCreateInfo`]`xChromaOffset` and/or `yChromaOffset` of `VK_CHROMA_LOCATION_COSITED_EVEN`. Otherwise both `xChromaOffset` and `yChromaOffset` **must**  be `VK_CHROMA_LOCATION_MIDPOINT`. If neither [`CositedChromaSamples`] nor [`MidpointChromaSamples`] is set, the application  **must**  not define a [sampler Y′C<sub>B</sub>C<sub>R</sub> conversion](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#samplers-YCbCr-conversion) using this format as a source.
/// - [`SampledImageYcbcrConversionLinearFilter`] specifies that an application  **can**  define a [sampler Y′C<sub>B</sub>C<sub>R</sub> conversion](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#samplers-YCbCr-conversion) using this format as a source with `chromaFilter` set to `VK_FILTER_LINEAR`.
/// - [`SampledImageYcbcrConversionSeparateReconstructionFilter`] specifies that the format can have
///   different chroma, min, and mag filters.
/// - [`SampledImageYcbcrConversionChromaReconstructionExplicit`] specifies that reconstruction is explicit, as described in [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#textures-chroma-reconstruction](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#textures-chroma-reconstruction). If this bit is not present, reconstruction is implicit by default.
/// - [`SampledImageYcbcrConversionChromaReconstructionExplicitForceable`] specifies that
///   reconstruction  **can**  be forcibly made explicit by setting
///   [`SamplerYcbcrConversionCreateInfo::force_explicit_reconstruction`] to [`TRUE`]. If the format
///   being queried supports [`SampledImageYcbcrConversionChromaReconstructionExplicit`] it
///   **must**  also support [`SampledImageYcbcrConversionChromaReconstructionExplicitForceable`].
/// - [`Disjoint`] specifies that a multi-planar image  **can**  have the
///   `VK_IMAGE_CREATE_DISJOINT_BIT` set during image creation. An implementation  **must**  not set
///   [`Disjoint`] for *single-plane formats*.
/// - [`FragmentDensityMapExt`] specifies that an image view  **can**  be used as a [fragment density map attachment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-fragmentdensitymapattachment).
/// - [`FragmentShadingRateAttachmentKhr`] specifies that an image view  **can**  be used as a [fragment shading rate attachment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#primsrast-fragment-shading-rate-attachment). An implementation  **must**  not set this feature for formats with numeric type other than `*UINT`, or set it as a buffer feature.
/// - [`VideoDecodeOutputKhr`] specifies that an image view with this format  **can**  be used as an
///   output for [video decode operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-decode-operations)
/// - [`VideoDecodeDpbKhr`] specifies that an image view with this format  **can**  be used as a DPB
///   for [video decode operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-decode-operations)
/// - [`VideoEncodeInputKhr`] specifies that an image view with this format  **can**  be used as an input to [video encode operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-encode-operations)
/// - [`VideoEncodeDpbKhr`] specifies that an image view with this format  **can**  be used as a DPB
///   for [video encode operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-encode-operations)
///The following bits  **may**  be set in `bufferFeatures`, specifying that the
///features are supported by [`Buffer`] or [`BufferView`] created with the queried
///[`GetPhysicalDeviceFormatProperties`]`::format`:
/// - [`FormatFeatureUniformTexelBuffer`] specifies that the format  **can**  be used to create a
///   buffer view that  **can**  be bound to a `VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER` descriptor.
/// - [`FormatFeatureStorageTexelBuffer`] specifies that the format  **can**  be used to create a
///   buffer view that  **can**  be bound to a `VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER` descriptor.
/// - [`FormatFeatureStorageTexelBufferAtomic`] specifies that atomic operations are supported on
///   `VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER` with this format.
/// - [`FormatFeatureVertexBuffer`] specifies that the format  **can**  be used as a vertex
///   attribute format ([`VertexInputAttributeDescription::format`]).
/// - [`AccelerationStructureVertexBufferKhr`] specifies that the format  **can**  be used as the vertex format when creating an [acceleration structure](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#acceleration-structure) ([`AccelerationStructureGeometryTrianglesDataKHR::vertex_format`]). This format  **can**  also be used as the vertex format in host memory when doing [host acceleration structure](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#host-acceleration-structure) builds.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`FormatFeatureFlags`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkFormatFeatureFlagBits")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
#[repr(u32)]
pub enum FormatFeatureFlagBits {
    #[doc(hidden)]
    Empty = 0,
    ///[`FormatFeatureSampledImage`] specifies that an image view
    /// **can**  be [sampled from](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-sampledimage).
    FormatFeatureSampledImage = 1,
    ///[`FormatFeatureStorageImage`] specifies that an image view
    /// **can**  be used as a [storage image](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storageimage).
    FormatFeatureStorageImage = 2,
    ///[`FormatFeatureStorageImageAtomic`] specifies that an image
    ///view  **can**  be used as storage image that supports atomic operations.
    FormatFeatureStorageImageAtomic = 4,
    ///[`FormatFeatureUniformTexelBuffer`] specifies that the
    ///format  **can**  be used to create a buffer view that  **can**  be bound to a
    ///`VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER` descriptor.
    FormatFeatureUniformTexelBuffer = 8,
    ///[`FormatFeatureStorageTexelBuffer`] specifies that the
    ///format  **can**  be used to create a buffer view that  **can**  be bound to a
    ///`VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER` descriptor.
    FormatFeatureStorageTexelBuffer = 16,
    ///[`FormatFeatureStorageTexelBufferAtomic`] specifies that
    ///atomic operations are supported on
    ///`VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER` with this format.
    FormatFeatureStorageTexelBufferAtomic = 32,
    ///[`FormatFeatureVertexBuffer`] specifies that the format  **can**
    ///be used as a vertex attribute format
    ///([`VertexInputAttributeDescription`]::`format`).
    FormatFeatureVertexBuffer = 64,
    ///[`FormatFeatureColorAttachment`] specifies that an image
    ///view  **can**  be used as a framebuffer color attachment and as an input
    ///attachment.
    FormatFeatureColorAttachment = 128,
    ///[`FormatFeatureColorAttachmentBlend`] specifies that an
    ///image view  **can**  be used as a framebuffer color attachment that supports
    ///blending and as an input attachment.
    FormatFeatureColorAttachmentBlend = 256,
    ///[`FormatFeatureDepthStencilAttachment`] specifies that an
    ///image view  **can**  be used as a framebuffer depth/stencil attachment and as
    ///an input attachment.
    FormatFeatureDepthStencilAttachment = 512,
    ///[`FormatFeatureBlitSrc`] specifies that an image  **can**  be
    ///used as `srcImage` for the
    ///[`CmdBlitImage2`] and [`CmdBlitImage`] commands.
    FormatFeatureBlitSrc = 1024,
    ///[`FormatFeatureBlitDst`] specifies that an image  **can**  be
    ///used as `dstImage` for the
    ///[`CmdBlitImage2`] and [`CmdBlitImage`] commands.
    FormatFeatureBlitDst = 2048,
    ///[`FormatFeatureSampledImageFilterLinear`] specifies that
    ///if [`FormatFeatureSampledImage`] is also set, an image view
    /// **can**  be used with a sampler that has either of `magFilter` or
    ///`minFilter` set to `VK_FILTER_LINEAR`, or `mipmapMode` set
    ///to `VK_SAMPLER_MIPMAP_MODE_LINEAR`.
    ///If [`FormatFeatureBlitSrc`] is also set, an image can be
    ///used as the `srcImage` to
    ///[`CmdBlitImage2`] and [`CmdBlitImage`]
    ///with a `filter` of `VK_FILTER_LINEAR`.
    ///This bit  **must**  only be exposed for formats that also support the
    ///[`FormatFeatureSampledImage`] or
    ///[`FormatFeatureBlitSrc`].If the format being queried is a depth/stencil format, this bit
    /// only specifies that the depth aspect (not the stencil aspect) of an image of this
    ///format supports linear filtering, and that linear filtering of the depth
    ///aspect is supported whether depth compare is enabled in the sampler or not.
    ///Where depth comparison is supported it  **may**  be linear filtered whether this
    ///bit is present or not, but where this bit is not present the filtered value
    /// **may**  be computed in an implementation-dependent manner which differs from
    ///the normal rules of linear filtering.
    ///The resulting value  **must**  be in the range [0,1] and  **should**  be
    ///proportional to, or a weighted average of, the number of comparison passes
    ///or failures.
    FormatFeatureSampledImageFilterLinear = 4096,
    ///[`TransferSrc`] specifies that an image  **can**  be
    ///used as a source image for [copy commands](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#copies).
    ///
    ///Provided by [`crate::vulkan1_1`]
    TransferSrc = 16384,
    ///[`TransferDst`] specifies that an image  **can**  be
    ///used as a destination image for [copy commands](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#copies) and [clear commands](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#clears).
    ///
    ///Provided by [`crate::vulkan1_1`]
    TransferDst = 32768,
    ///[`MidpointChromaSamples`] specifies that an
    ///application  **can**  define a [sampler Y′C<sub>B</sub>C<sub>R</sub>
    ///conversion](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#samplers-YCbCr-conversion) using this format as a source, and that an image of this
    ///format  **can**  be used with a [`SamplerYcbcrConversionCreateInfo`]`xChromaOffset` and/or
    /// `yChromaOffset` of `VK_CHROMA_LOCATION_MIDPOINT`.
    ///Otherwise both `xChromaOffset` and `yChromaOffset` **must**  be
    ///`VK_CHROMA_LOCATION_COSITED_EVEN`.
    ///If a format does not incorporate chroma downsampling (it is not a
    ///“422” or “420” format) but the implementation supports sampler
    ///Y′C<sub>B</sub>C<sub>R</sub> conversion for this format, the implementation  **must**  set
    ///[`MidpointChromaSamples`].
    ///
    ///Provided by [`crate::vulkan1_1`]
    MidpointChromaSamples = 131072,
    ///[`SampledImageYcbcrConversionLinearFilter`]
    ///specifies that an application  **can**  define a
    ///[sampler Y′C<sub>B</sub>C<sub>R</sub> conversion](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#samplers-YCbCr-conversion) using this
    ///format as a source with `chromaFilter` set to
    ///`VK_FILTER_LINEAR`.
    ///
    ///Provided by [`crate::vulkan1_1`]
    SampledImageYcbcrConversionLinearFilter = 262144,
    ///[`SampledImageYcbcrConversionSeparateReconstructionFilter`]
    ///specifies that the format can have different chroma, min, and mag
    ///filters.
    ///
    ///Provided by [`crate::vulkan1_1`]
    SampledImageYcbcrConversionSeparateReconstructionFilter = 524288,
    ///[`SampledImageYcbcrConversionChromaReconstructionExplicit`]
    ///specifies that reconstruction is explicit, as described in
    ///[https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#textures-chroma-reconstruction](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#textures-chroma-reconstruction).
    ///If this bit is not present, reconstruction is implicit by default.
    ///
    ///Provided by [`crate::vulkan1_1`]
    SampledImageYcbcrConversionChromaReconstructionExplicit = 1048576,
    ///[`SampledImageYcbcrConversionChromaReconstructionExplicitForceable`]
    ///specifies that reconstruction  **can**  be forcibly made explicit by setting
    ///[`SamplerYcbcrConversionCreateInfo`]::`forceExplicitReconstruction`
    ///to [`TRUE`].
    ///If the format being queried supports
    ///[`SampledImageYcbcrConversionChromaReconstructionExplicit`]
    ///it  **must**  also support
    ///[`SampledImageYcbcrConversionChromaReconstructionExplicitForceable`].
    ///
    ///Provided by [`crate::vulkan1_1`]
    SampledImageYcbcrConversionChromaReconstructionExplicitForceable = 2097152,
    ///[`Disjoint`] specifies that a multi-planar image
    /// **can**  have the `VK_IMAGE_CREATE_DISJOINT_BIT` set during image
    ///creation.
    ///An implementation  **must**  not set [`Disjoint`] for
    ///*single-plane formats*.
    ///
    ///Provided by [`crate::vulkan1_1`]
    Disjoint = 4194304,
    ///[`CositedChromaSamples`] specifies that an
    ///application  **can**  define a [sampler Y′C<sub>B</sub>C<sub>R</sub>
    ///conversion](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#samplers-YCbCr-conversion) using this format as a source, and that an image of this
    ///format  **can**  be used with a [`SamplerYcbcrConversionCreateInfo`]`xChromaOffset` and/or
    /// `yChromaOffset` of `VK_CHROMA_LOCATION_COSITED_EVEN`.
    ///Otherwise both `xChromaOffset` and `yChromaOffset` **must**  be
    ///`VK_CHROMA_LOCATION_MIDPOINT`.
    ///If neither [`CositedChromaSamples`] nor
    ///[`MidpointChromaSamples`] is set, the
    ///application  **must**  not define a [sampler
    ///Y′C<sub>B</sub>C<sub>R</sub> conversion](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#samplers-YCbCr-conversion) using this format as a source.
    ///
    ///Provided by [`crate::vulkan1_1`]
    CositedChromaSamples = 8388608,
    ///[`SampledImageFilterMinmax`] specifies
    ///[`Image`] **can**  be used as a sampled image with a min or max
    ///[`SamplerReductionMode`].
    ///This bit  **must**  only be exposed for formats that also support the
    ///[`FormatFeatureSampledImage`].
    ///
    ///Provided by [`crate::vulkan1_2`]
    SampledImageFilterMinmax = 65536,
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::img_filter_cubic`]
    SampledImageFilterCubicImg = 8192,
    ///[`VideoDecodeOutputKhr`] specifies that an
    ///image view with this format  **can**  be used as an output for
    ///[video decode operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-decode-operations)
    ///
    ///Provided by [`crate::extensions::khr_video_decode_queue`]
    VideoDecodeOutputKhr = 33554432,
    ///[`VideoDecodeDpbKhr`] specifies that an image
    ///view with this format  **can**  be used as a DPB for
    ///[video decode operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-decode-operations)
    ///
    ///Provided by [`crate::extensions::khr_video_decode_queue`]
    VideoDecodeDpbKhr = 67108864,
    ///[`AccelerationStructureVertexBufferKhr`]
    ///specifies that the format  **can**  be used as the vertex format when
    ///creating an [acceleration structure](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#acceleration-structure)
    ///([`AccelerationStructureGeometryTrianglesDataKHR`]::`vertexFormat`).
    ///This format  **can**  also be used as the vertex format in host memory when
    ///doing [host acceleration structure](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#host-acceleration-structure)
    ///builds.
    ///
    ///Provided by [`crate::extensions::khr_acceleration_structure`]
    AccelerationStructureVertexBufferKhr = 536870912,
    ///[`FragmentDensityMapExt`] specifies that an
    ///image view  **can**  be used as a
    ///[fragment density map
    ///attachment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-fragmentdensitymapattachment).
    ///
    ///Provided by [`crate::extensions::ext_fragment_density_map`]
    FragmentDensityMapExt = 16777216,
    ///[`FragmentShadingRateAttachmentKhr`]
    ///specifies that an image view  **can**  be used as a
    ///[fragment shading rate
    ///attachment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#primsrast-fragment-shading-rate-attachment).
    ///An implementation  **must**  not set this feature for formats with numeric
    ///type other than `*UINT`, or set it as a buffer feature.
    ///
    ///Provided by [`crate::extensions::khr_fragment_shading_rate`]
    FragmentShadingRateAttachmentKhr = 1073741824,
    ///[`VideoEncodeInputKhr`] specifies that an
    ///image view with this format  **can**  be used as an input to
    ///[video encode operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-encode-operations)
    ///
    ///Provided by [`crate::extensions::khr_video_encode_queue`]
    VideoEncodeInputKhr = 134217728,
    ///[`VideoEncodeDpbKhr`] specifies that an image
    ///view with this format  **can**  be used as a DPB for
    ///[video encode operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-encode-operations)
    ///
    ///Provided by [`crate::extensions::khr_video_encode_queue`]
    VideoEncodeDpbKhr = 268435456,
}
impl const Default for FormatFeatureFlagBits {
    fn default() -> Self {
        Self::Empty
    }
}
impl FormatFeatureFlagBits {
    ///Default empty value
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Gets the raw underlying value
    #[inline]
    pub const fn bits(&self) -> u32 {
        self as u32
    }
    ///Gets a value from a raw underlying value, unchecked and therefore unsafe
    #[inline]
    pub const unsafe fn from_bits(bits: u32) -> u32 {
        std::mem::transmute(bits)
    }
}
///[VkQueryControlFlagBits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkQueryControlFlagBits.html) - Bitmask specifying constraints on a query
///# C Specifications
///Bits which  **can**  be set in [`CmdBeginQuery`]`::flags`, specifying
///constraints on the types of queries that  **can**  be performed, are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkQueryControlFlagBits {
///    VK_QUERY_CONTROL_PRECISE_BIT = 0x00000001,
///} VkQueryControlFlagBits;
///```
///# Description
/// - [`QueryControlPrecise`] specifies the precision of [occlusion queries](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#queries-occlusion).
///# Related
/// - [`crate::vulkan1_0`]
/// - [`QueryControlFlags`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkQueryControlFlagBits")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
#[repr(u32)]
pub enum QueryControlFlagBits {
    #[doc(hidden)]
    Empty = 0,
    ///[`QueryControlPrecise`] specifies the precision of
    ///[occlusion queries](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#queries-occlusion).
    QueryControlPrecise = 1,
}
impl const Default for QueryControlFlagBits {
    fn default() -> Self {
        Self::Empty
    }
}
impl QueryControlFlagBits {
    ///Default empty value
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Gets the raw underlying value
    #[inline]
    pub const fn bits(&self) -> u32 {
        self as u32
    }
    ///Gets a value from a raw underlying value, unchecked and therefore unsafe
    #[inline]
    pub const unsafe fn from_bits(bits: u32) -> u32 {
        std::mem::transmute(bits)
    }
}
///[VkQueryResultFlagBits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkQueryResultFlagBits.html) - Bitmask specifying how and when query results are returned
///# C Specifications
///Bits which  **can**  be set in [`GetQueryPoolResults`]`::flags` and
///[`CmdCopyQueryPoolResults`]`::flags`, specifying how and when
///results are returned, are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkQueryResultFlagBits {
///    VK_QUERY_RESULT_64_BIT = 0x00000001,
///    VK_QUERY_RESULT_WAIT_BIT = 0x00000002,
///    VK_QUERY_RESULT_WITH_AVAILABILITY_BIT = 0x00000004,
///    VK_QUERY_RESULT_PARTIAL_BIT = 0x00000008,
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_KHR_video_queue
///    VK_QUERY_RESULT_WITH_STATUS_BIT_KHR = 0x00000010,
///#endif
///} VkQueryResultFlagBits;
///```
///# Description
/// - [`QueryResult64`] specifies the results will be written as an array of 64-bit unsigned integer
///   values. If this bit is not set, the results will be written as an array of 32-bit unsigned
///   integer values.
/// - [`QueryResultWait`] specifies that Vulkan will wait for each query’s status to become
///   available before retrieving its results.
/// - [`QueryResultWithAvailability`] specifies that the availability status accompanies the
///   results.
/// - [`QueryResultPartial`] specifies that returning partial results is acceptable.
/// - [`WithStatusKhr`] specifies that the last value returned in the query is a [`QueryResultStatusKHR`] value. See [result status query](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#queries-result-status-only) for information on how an application can determine whether the use of this flag bit is supported.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`QueryResultFlags`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkQueryResultFlagBits")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
#[repr(u32)]
pub enum QueryResultFlagBits {
    #[doc(hidden)]
    Empty = 0,
    ///[`QueryResult64`] specifies the results will be written as an
    ///array of 64-bit unsigned integer values.
    ///If this bit is not set, the results will be written as an array of
    ///32-bit unsigned integer values.
    QueryResult64 = 1,
    ///[`QueryResultWait`] specifies that Vulkan will wait for each
    ///query’s status to become available before retrieving its results.
    QueryResultWait = 2,
    ///[`QueryResultWithAvailability`] specifies that the
    ///availability status accompanies the results.
    QueryResultWithAvailability = 4,
    ///[`QueryResultPartial`] specifies that returning partial
    ///results is acceptable.
    QueryResultPartial = 8,
    ///[`WithStatusKhr`] specifies that the last value
    ///returned in the query is a [`QueryResultStatusKHR`] value.
    ///See [result status query](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#queries-result-status-only) for information
    ///on how an application can determine whether the use of this flag bit is
    ///supported.
    ///
    ///Provided by [`crate::extensions::khr_video_queue`]
    WithStatusKhr = 16,
}
impl const Default for QueryResultFlagBits {
    fn default() -> Self {
        Self::Empty
    }
}
impl QueryResultFlagBits {
    ///Default empty value
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Gets the raw underlying value
    #[inline]
    pub const fn bits(&self) -> u32 {
        self as u32
    }
    ///Gets a value from a raw underlying value, unchecked and therefore unsafe
    #[inline]
    pub const unsafe fn from_bits(bits: u32) -> u32 {
        std::mem::transmute(bits)
    }
}
///[VkCommandBufferUsageFlagBits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandBufferUsageFlagBits.html) - Bitmask specifying usage behavior for command buffer
///# C Specifications
///Bits which  **can**  be set in [`CommandBufferBeginInfo::flags`],
///specifying usage behavior for a command buffer, are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkCommandBufferUsageFlagBits {
///    VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT = 0x00000001,
///    VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT = 0x00000002,
///    VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT = 0x00000004,
///} VkCommandBufferUsageFlagBits;
///```
///# Description
/// - [`CommandBufferUsageOneTimeSubmit`] specifies that each recording of the command buffer will
///   only be submitted once, and the command buffer will be reset and recorded again between each
///   submission.
/// - [`CommandBufferUsageRenderPassContinue`] specifies that a secondary command buffer is
///   considered to be entirely inside a render pass. If this is a primary command buffer, then this
///   bit is ignored.
/// - [`CommandBufferUsageSimultaneousUse`] specifies that a command buffer  **can**  be resubmitted
///   to a queue while it is in the *pending state*, and recorded into multiple primary command
///   buffers.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`CommandBufferUsageFlags`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkCommandBufferUsageFlagBits")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
#[repr(u32)]
pub enum CommandBufferUsageFlagBits {
    #[doc(hidden)]
    Empty = 0,
    ///[`CommandBufferUsageOneTimeSubmit`] specifies that each
    ///recording of the command buffer will only be submitted once, and the
    ///command buffer will be reset and recorded again between each submission.
    CommandBufferUsageOneTimeSubmit = 1,
    ///[`CommandBufferUsageRenderPassContinue`] specifies that a
    ///secondary command buffer is considered to be entirely inside a render
    ///pass.
    ///If this is a primary command buffer, then this bit is ignored.
    CommandBufferUsageRenderPassContinue = 2,
    ///[`CommandBufferUsageSimultaneousUse`] specifies that a
    ///command buffer  **can**  be resubmitted to a queue while it is in the
    ///*pending state*, and recorded into multiple primary command buffers.
    CommandBufferUsageSimultaneousUse = 4,
}
impl const Default for CommandBufferUsageFlagBits {
    fn default() -> Self {
        Self::Empty
    }
}
impl CommandBufferUsageFlagBits {
    ///Default empty value
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Gets the raw underlying value
    #[inline]
    pub const fn bits(&self) -> u32 {
        self as u32
    }
    ///Gets a value from a raw underlying value, unchecked and therefore unsafe
    #[inline]
    pub const unsafe fn from_bits(bits: u32) -> u32 {
        std::mem::transmute(bits)
    }
}
///[VkQueryPipelineStatisticFlagBits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkQueryPipelineStatisticFlagBits.html) - Bitmask specifying queried pipeline statistics
///# C Specifications
///Bits which  **can**  be set in
///[`QueryPoolCreateInfo::pipeline_statistics`] for query pools and in
///[`CommandBufferInheritanceInfo::pipeline_statistics`] for secondary
///command buffers, individually enabling pipeline statistics counters, are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkQueryPipelineStatisticFlagBits {
///    VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT = 0x00000001,
///    VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT = 0x00000002,
///    VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT = 0x00000004,
///    VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT = 0x00000008,
///    VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT = 0x00000010,
///    VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT = 0x00000020,
///    VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT = 0x00000040,
///    VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT = 0x00000080,
///    VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT = 0x00000100,
///    VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT = 0x00000200,
///    VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT = 0x00000400,
///} VkQueryPipelineStatisticFlagBits;
///```
///# Description
/// - [`QueryPipelineStatisticInputAssemblyVertices`] specifies that queries managed by the pool will count the number of vertices processed by the [input assembly](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#drawing) stage. Vertices corresponding to incomplete primitives  **may**  contribute to the count.
/// - [`QueryPipelineStatisticInputAssemblyPrimitives`] specifies that queries managed by the pool will count the number of primitives processed by the [input assembly](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#drawing) stage. If primitive restart is enabled, restarting the primitive topology has no effect on the count. Incomplete primitives  **may**  be counted.
/// - [`QueryPipelineStatisticVertexShaderInvocations`] specifies that queries managed by the pool will count the number of vertex shader invocations. This counter’s value is incremented each time a vertex shader is [invoked](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#shaders-vertex-execution).
/// - [`QueryPipelineStatisticGeometryShaderInvocations`] specifies that queries managed by the pool
///   will count the number of geometry shader invocations. This counter’s value is incremented each
///   time a geometry shader is [invoked](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#shaders-geometry-execution).
///   In the case of [instanced geometry shaders](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#geometry-invocations),
///   the geometry shader invocations count is incremented for each separate instanced invocation.
/// - [`QueryPipelineStatisticGeometryShaderPrimitives`] specifies that queries managed by the pool
///   will count the number of primitives generated by geometry shader invocations. The counter’s
///   value is incremented each time the geometry shader emits a primitive. Restarting primitive
///   topology using the SPIR-V instructions `OpEndPrimitive` or `OpEndStreamPrimitive` has no
///   effect on the geometry shader output primitives count.
/// - [`QueryPipelineStatisticClippingInvocations`] specifies that queries managed by the pool will count the number of primitives processed by the [Primitive Clipping](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#vertexpostproc-clipping) stage of the pipeline. The counter’s value is incremented each time a primitive reaches the primitive clipping stage.
/// - [`QueryPipelineStatisticClippingPrimitives`] specifies that queries managed by the pool will count the number of primitives output by the [Primitive Clipping](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#vertexpostproc-clipping) stage of the pipeline. The counter’s value is incremented each time a primitive passes the primitive clipping stage. The actual number of primitives output by the primitive clipping stage for a particular input primitive is implementation-dependent but  **must**  satisfy the following conditions:  - If at least one vertex of the input primitive lies inside the clipping volume, the counter is incremented by one or more.  - Otherwise, the counter is incremented by zero or more.
/// - [`QueryPipelineStatisticFragmentShaderInvocations`] specifies that queries managed by the pool
///   will count the number of fragment shader invocations. The counter’s value is incremented each time
///   the fragment shader is [invoked](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fragops-shader).
/// - [`QueryPipelineStatisticTessellationControlShaderPatches`] specifies that queries managed by the pool will count the number of patches processed by the tessellation control shader. The counter’s value is incremented once for each patch for which a tessellation control shader is [invoked](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#shaders-tessellation-control-execution).
/// - [`QueryPipelineStatisticTessellationEvaluationShaderInvocations`] specifies that queries managed by the pool will count the number of invocations of the tessellation evaluation shader. The counter’s value is incremented each time the tessellation evaluation shader is [invoked](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#shaders-tessellation-evaluation-execution).
/// - [`QueryPipelineStatisticComputeShaderInvocations`] specifies that queries managed by the pool
///   will count the number of compute shader invocations. The counter’s value is incremented every
///   time the compute shader is invoked. Implementations  **may**  skip the execution of certain
///   compute shader invocations or execute additional compute shader invocations for
///   implementation-dependent reasons as long as the results of rendering otherwise remain
///   unchanged.
///These values are intended to measure relative statistics on one
///implementation.
///Various device architectures will count these values differently.
///Any or all counters  **may**  be affected by the issues described in
///[Query Operation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#queries-operation-undefined).If a pipeline has `rasterizerDiscardEnable` enabled, implementations
/// **may**  discard primitives after the final
///[pre-rasterization shader
///stage](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-pre-rasterization).
///As a result, if `rasterizerDiscardEnable` is enabled, the clipping input
///and output primitives counters  **may**  not be incremented.When a pipeline statistics query
/// finishes, the result for that query is
///marked as available.
///The application  **can**  copy the result to a buffer (via
///[`CmdCopyQueryPoolResults`]), or request it be put into host memory (via
///[`GetQueryPoolResults`]).
///# Related
/// - [`crate::vulkan1_0`]
/// - [`QueryPipelineStatisticFlags`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkQueryPipelineStatisticFlagBits")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
#[repr(u32)]
pub enum QueryPipelineStatisticFlagBits {
    #[doc(hidden)]
    Empty = 0,
    ///[`QueryPipelineStatisticInputAssemblyVertices`] specifies
    ///that queries managed by the pool will count the number of vertices
    ///processed by the [input assembly](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#drawing) stage.
    ///Vertices corresponding to incomplete primitives  **may**  contribute to the
    ///count.
    QueryPipelineStatisticInputAssemblyVertices = 1,
    ///[`QueryPipelineStatisticInputAssemblyPrimitives`]
    ///specifies that queries managed by the pool will count the number of
    ///primitives processed by the [input assembly](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#drawing) stage.
    ///If primitive restart is enabled, restarting the primitive topology has
    ///no effect on the count.
    ///Incomplete primitives  **may**  be counted.
    QueryPipelineStatisticInputAssemblyPrimitives = 2,
    ///[`QueryPipelineStatisticVertexShaderInvocations`]
    ///specifies that queries managed by the pool will count the number of
    ///vertex shader invocations.
    ///This counter’s value is incremented each time a vertex shader is
    ///[invoked](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#shaders-vertex-execution).
    QueryPipelineStatisticVertexShaderInvocations = 4,
    ///[`QueryPipelineStatisticGeometryShaderInvocations`]
    ///specifies that queries managed by the pool will count the number of
    ///geometry shader invocations.
    ///This counter’s value is incremented each time a geometry shader is
    ///[invoked](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#shaders-geometry-execution).
    ///In the case of [instanced geometry shaders](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#geometry-invocations), the
    ///geometry shader invocations count is incremented for each separate
    ///instanced invocation.
    QueryPipelineStatisticGeometryShaderInvocations = 8,
    ///[`QueryPipelineStatisticGeometryShaderPrimitives`]
    ///specifies that queries managed by the pool will count the number of
    ///primitives generated by geometry shader invocations.
    ///The counter’s value is incremented each time the geometry shader emits a
    ///primitive.
    ///Restarting primitive topology using the SPIR-V instructions
    ///`OpEndPrimitive` or `OpEndStreamPrimitive` has no effect on the
    ///geometry shader output primitives count.
    QueryPipelineStatisticGeometryShaderPrimitives = 16,
    ///[`QueryPipelineStatisticClippingInvocations`] specifies
    ///that queries managed by the pool will count the number of primitives
    ///processed by the [Primitive Clipping](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#vertexpostproc-clipping) stage of
    ///the pipeline.
    ///The counter’s value is incremented each time a primitive reaches the
    ///primitive clipping stage.
    QueryPipelineStatisticClippingInvocations = 32,
    ///[`QueryPipelineStatisticClippingPrimitives`] specifies that
    ///queries managed by the pool will count the number of primitives output
    ///by the [Primitive Clipping](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#vertexpostproc-clipping) stage of the
    ///pipeline.
    ///The counter’s value is incremented each time a primitive passes the
    ///primitive clipping stage.
    ///The actual number of primitives output by the primitive clipping stage
    ///for a particular input primitive is implementation-dependent but  **must**
    ///satisfy the following conditions:
    /// - If at least one vertex of the input primitive lies inside the clipping volume, the counter
    ///   is incremented by one or more.
    /// - Otherwise, the counter is incremented by zero or more.
    QueryPipelineStatisticClippingPrimitives = 64,
    ///[`QueryPipelineStatisticFragmentShaderInvocations`]
    ///specifies that queries managed by the pool will count the number of
    ///fragment shader invocations.
    ///The counter’s value is incremented each time the fragment shader is
    ///[invoked](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fragops-shader).
    QueryPipelineStatisticFragmentShaderInvocations = 128,
    ///[`QueryPipelineStatisticTessellationControlShaderPatches`]
    ///specifies that queries managed by the pool will count the number of
    ///patches processed by the tessellation control shader.
    ///The counter’s value is incremented once for each patch for which a
    ///tessellation control shader is
    ///[invoked](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#shaders-tessellation-control-execution).
    QueryPipelineStatisticTessellationControlShaderPatches = 256,
    ///[`QueryPipelineStatisticTessellationEvaluationShaderInvocations`]
    ///specifies that queries managed by the pool will count the number of
    ///invocations of the tessellation evaluation shader.
    ///The counter’s value is incremented each time the tessellation evaluation
    ///shader is [invoked](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#shaders-tessellation-evaluation-execution).
    QueryPipelineStatisticTessellationEvaluationShaderInvocations = 512,
    ///[`QueryPipelineStatisticComputeShaderInvocations`]
    ///specifies that queries managed by the pool will count the number of
    ///compute shader invocations.
    ///The counter’s value is incremented every time the compute shader is
    ///invoked.
    ///Implementations  **may**  skip the execution of certain compute shader
    ///invocations or execute additional compute shader invocations for
    ///implementation-dependent reasons as long as the results of rendering
    ///otherwise remain unchanged.
    QueryPipelineStatisticComputeShaderInvocations = 1024,
}
impl const Default for QueryPipelineStatisticFlagBits {
    fn default() -> Self {
        Self::Empty
    }
}
impl QueryPipelineStatisticFlagBits {
    ///Default empty value
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Gets the raw underlying value
    #[inline]
    pub const fn bits(&self) -> u32 {
        self as u32
    }
    ///Gets a value from a raw underlying value, unchecked and therefore unsafe
    #[inline]
    pub const unsafe fn from_bits(bits: u32) -> u32 {
        std::mem::transmute(bits)
    }
}
///[VkImageAspectFlagBits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageAspectFlagBits.html) - Bitmask specifying which aspects of an image are included in a view
///# C Specifications
///Bits which  **can**  be set in an aspect mask to specify aspects of an image for
///purposes such as identifying a subresource, are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkImageAspectFlagBits {
///    VK_IMAGE_ASPECT_COLOR_BIT = 0x00000001,
///    VK_IMAGE_ASPECT_DEPTH_BIT = 0x00000002,
///    VK_IMAGE_ASPECT_STENCIL_BIT = 0x00000004,
///    VK_IMAGE_ASPECT_METADATA_BIT = 0x00000008,
///  // Provided by VK_VERSION_1_1
///    VK_IMAGE_ASPECT_PLANE_0_BIT = 0x00000010,
///  // Provided by VK_VERSION_1_1
///    VK_IMAGE_ASPECT_PLANE_1_BIT = 0x00000020,
///  // Provided by VK_VERSION_1_1
///    VK_IMAGE_ASPECT_PLANE_2_BIT = 0x00000040,
///  // Provided by VK_VERSION_1_3
///    VK_IMAGE_ASPECT_NONE = 0,
///  // Provided by VK_EXT_image_drm_format_modifier
///    VK_IMAGE_ASPECT_MEMORY_PLANE_0_BIT_EXT = 0x00000080,
///  // Provided by VK_EXT_image_drm_format_modifier
///    VK_IMAGE_ASPECT_MEMORY_PLANE_1_BIT_EXT = 0x00000100,
///  // Provided by VK_EXT_image_drm_format_modifier
///    VK_IMAGE_ASPECT_MEMORY_PLANE_2_BIT_EXT = 0x00000200,
///  // Provided by VK_EXT_image_drm_format_modifier
///    VK_IMAGE_ASPECT_MEMORY_PLANE_3_BIT_EXT = 0x00000400,
///  // Provided by VK_KHR_sampler_ycbcr_conversion
///    VK_IMAGE_ASPECT_PLANE_0_BIT_KHR = VK_IMAGE_ASPECT_PLANE_0_BIT,
///  // Provided by VK_KHR_sampler_ycbcr_conversion
///    VK_IMAGE_ASPECT_PLANE_1_BIT_KHR = VK_IMAGE_ASPECT_PLANE_1_BIT,
///  // Provided by VK_KHR_sampler_ycbcr_conversion
///    VK_IMAGE_ASPECT_PLANE_2_BIT_KHR = VK_IMAGE_ASPECT_PLANE_2_BIT,
///  // Provided by VK_KHR_maintenance4
///    VK_IMAGE_ASPECT_NONE_KHR = VK_IMAGE_ASPECT_NONE,
///} VkImageAspectFlagBits;
///```
///# Description
/// - [`None`] specifies no image aspect, or the image aspect is not applicable.
/// - [`ImageAspectColor`] specifies the color aspect.
/// - [`ImageAspectDepth`] specifies the depth aspect.
/// - [`ImageAspectStencil`] specifies the stencil aspect.
/// - [`ImageAspectMetadata`] specifies the metadata aspect, used for [sparse resource](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#sparsememory)
///   operations.
/// - [`Plane0`] specifies plane 0 of a *multi-planar* image format.
/// - [`Plane1`] specifies plane 1 of a *multi-planar* image format.
/// - [`Plane2`] specifies plane 2 of a *multi-planar* image format.
/// - [`MemoryPlane0Ext`] specifies *memory plane* 0.
/// - [`MemoryPlane1Ext`] specifies *memory plane* 1.
/// - [`MemoryPlane2Ext`] specifies *memory plane* 2.
/// - [`MemoryPlane3Ext`] specifies *memory plane* 3.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`BindImagePlaneMemoryInfo`]
/// - [`DeviceImageMemoryRequirements`]
/// - [`ImageAspectFlags`]
/// - [`ImagePlaneMemoryRequirementsInfo`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkImageAspectFlagBits")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
#[repr(u32)]
pub enum ImageAspectFlagBits {
    ///[`ImageAspectColor`] specifies the color aspect.
    ImageAspectColor = 1,
    ///[`ImageAspectDepth`] specifies the depth aspect.
    ImageAspectDepth = 2,
    ///[`ImageAspectStencil`] specifies the stencil aspect.
    ImageAspectStencil = 4,
    ///[`ImageAspectMetadata`] specifies the metadata aspect, used
    ///for [sparse resource](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#sparsememory) operations.
    ImageAspectMetadata = 8,
    ///[`Plane0`] specifies plane 0 of a *multi-planar*
    ///image format.
    ///
    ///Provided by [`crate::vulkan1_1`]
    Plane0 = 16,
    ///[`Plane1`] specifies plane 1 of a *multi-planar*
    ///image format.
    ///
    ///Provided by [`crate::vulkan1_1`]
    Plane1 = 32,
    ///[`Plane2`] specifies plane 2 of a *multi-planar*
    ///image format.
    ///
    ///Provided by [`crate::vulkan1_1`]
    Plane2 = 64,
    ///[`None`] specifies no image aspect, or the image
    ///aspect is not applicable.
    ///
    ///Provided by [`crate::vulkan1_3`]
    None = 0,
    ///[`MemoryPlane0Ext`] specifies *memory plane* 0.
    ///
    ///Provided by [`crate::extensions::ext_image_drm_format_modifier`]
    MemoryPlane0Ext = 128,
    ///[`MemoryPlane1Ext`] specifies *memory plane* 1.
    ///
    ///Provided by [`crate::extensions::ext_image_drm_format_modifier`]
    MemoryPlane1Ext = 256,
    ///[`MemoryPlane2Ext`] specifies *memory plane* 2.
    ///
    ///Provided by [`crate::extensions::ext_image_drm_format_modifier`]
    MemoryPlane2Ext = 512,
    ///[`MemoryPlane3Ext`] specifies *memory plane* 3.
    ///
    ///Provided by [`crate::extensions::ext_image_drm_format_modifier`]
    MemoryPlane3Ext = 1024,
}
impl const Default for ImageAspectFlagBits {
    fn default() -> Self {
        Self::None
    }
}
impl ImageAspectFlagBits {
    ///Default empty value
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Gets the raw underlying value
    #[inline]
    pub const fn bits(&self) -> u32 {
        self as u32
    }
    ///Gets a value from a raw underlying value, unchecked and therefore unsafe
    #[inline]
    pub const unsafe fn from_bits(bits: u32) -> u32 {
        std::mem::transmute(bits)
    }
}
///[VkSparseImageFormatFlagBits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSparseImageFormatFlagBits.html) - Bitmask specifying additional information about a sparse image resource
///# C Specifications
///Bits which  **may**  be set in [`SparseImageFormatProperties::flags`],
///specifying additional information about the sparse resource, are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkSparseImageFormatFlagBits {
///    VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT = 0x00000001,
///    VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT = 0x00000002,
///    VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT = 0x00000004,
///} VkSparseImageFormatFlagBits;
///```
///# Description
/// - [`SparseImageFormatSingleMiptail`] specifies that the image uses a single mip tail region for
///   all array layers.
/// - [`SparseImageFormatAlignedMipSize`] specifies that the first mip level whose dimensions are
///   not integer multiples of the corresponding dimensions of the sparse image block begins the mip
///   tail region.
/// - [`SparseImageFormatNonstandardBlockSize`] specifies that the image uses non-standard sparse
///   image block dimensions, and the `imageGranularity` values do not match the standard sparse
///   image block dimensions for the given format.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`SparseImageFormatFlags`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkSparseImageFormatFlagBits")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
#[repr(u32)]
pub enum SparseImageFormatFlagBits {
    #[doc(hidden)]
    Empty = 0,
    ///[`SparseImageFormatSingleMiptail`] specifies that the image
    ///uses a single mip tail region for all array layers.
    SparseImageFormatSingleMiptail = 1,
    ///[`SparseImageFormatAlignedMipSize`] specifies that the
    ///first mip level whose dimensions are not integer multiples of the
    ///corresponding dimensions of the sparse image block begins the mip tail
    ///region.
    SparseImageFormatAlignedMipSize = 2,
    ///[`SparseImageFormatNonstandardBlockSize`] specifies that
    ///the image uses non-standard sparse image block dimensions, and the
    ///`imageGranularity` values do not match the standard sparse image
    ///block dimensions for the given format.
    SparseImageFormatNonstandardBlockSize = 4,
}
impl const Default for SparseImageFormatFlagBits {
    fn default() -> Self {
        Self::Empty
    }
}
impl SparseImageFormatFlagBits {
    ///Default empty value
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Gets the raw underlying value
    #[inline]
    pub const fn bits(&self) -> u32 {
        self as u32
    }
    ///Gets a value from a raw underlying value, unchecked and therefore unsafe
    #[inline]
    pub const unsafe fn from_bits(bits: u32) -> u32 {
        std::mem::transmute(bits)
    }
}
///[VkSparseMemoryBindFlagBits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSparseMemoryBindFlagBits.html) - Bitmask specifying usage of a sparse memory binding operation
///# C Specifications
///Bits which  **can**  be set in [`SparseMemoryBind::flags`], specifying
///usage of a sparse memory binding operation, are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkSparseMemoryBindFlagBits {
///    VK_SPARSE_MEMORY_BIND_METADATA_BIT = 0x00000001,
///} VkSparseMemoryBindFlagBits;
///```
///# Description
/// - [`SparseMemoryBindMetadata`] specifies that the memory being bound is only for the metadata
///   aspect.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`SparseMemoryBindFlags`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkSparseMemoryBindFlagBits")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
#[repr(u32)]
pub enum SparseMemoryBindFlagBits {
    #[doc(hidden)]
    Empty = 0,
    ///[`SparseMemoryBindMetadata`] specifies that the memory being
    ///bound is only for the metadata aspect.
    SparseMemoryBindMetadata = 1,
}
impl const Default for SparseMemoryBindFlagBits {
    fn default() -> Self {
        Self::Empty
    }
}
impl SparseMemoryBindFlagBits {
    ///Default empty value
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Gets the raw underlying value
    #[inline]
    pub const fn bits(&self) -> u32 {
        self as u32
    }
    ///Gets a value from a raw underlying value, unchecked and therefore unsafe
    #[inline]
    pub const unsafe fn from_bits(bits: u32) -> u32 {
        std::mem::transmute(bits)
    }
}
///[VkPipelineStageFlagBits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineStageFlagBits.html) - Bitmask specifying pipeline stages
///# C Specifications
///Bits which  **can**  be set in a [`PipelineStageFlags`] mask, specifying
///stages of execution, are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkPipelineStageFlagBits {
///    VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT = 0x00000001,
///    VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT = 0x00000002,
///    VK_PIPELINE_STAGE_VERTEX_INPUT_BIT = 0x00000004,
///    VK_PIPELINE_STAGE_VERTEX_SHADER_BIT = 0x00000008,
///    VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT = 0x00000010,
///    VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT = 0x00000020,
///    VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT = 0x00000040,
///    VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT = 0x00000080,
///    VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT = 0x00000100,
///    VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT = 0x00000200,
///    VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT = 0x00000400,
///    VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT = 0x00000800,
///    VK_PIPELINE_STAGE_TRANSFER_BIT = 0x00001000,
///    VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT = 0x00002000,
///    VK_PIPELINE_STAGE_HOST_BIT = 0x00004000,
///    VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT = 0x00008000,
///    VK_PIPELINE_STAGE_ALL_COMMANDS_BIT = 0x00010000,
///  // Provided by VK_VERSION_1_3
///    VK_PIPELINE_STAGE_NONE = 0,
///  // Provided by VK_EXT_transform_feedback
///    VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT = 0x01000000,
///  // Provided by VK_EXT_conditional_rendering
///    VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT = 0x00040000,
///  // Provided by VK_KHR_acceleration_structure
///    VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR = 0x02000000,
///  // Provided by VK_KHR_ray_tracing_pipeline
///    VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_KHR = 0x00200000,
///  // Provided by VK_NV_mesh_shader
///    VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV = 0x00080000,
///  // Provided by VK_NV_mesh_shader
///    VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV = 0x00100000,
///  // Provided by VK_EXT_fragment_density_map
///    VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT = 0x00800000,
///  // Provided by VK_KHR_fragment_shading_rate
///    VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = 0x00400000,
///  // Provided by VK_NV_device_generated_commands
///    VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_NV = 0x00020000,
///  // Provided by VK_NV_shading_rate_image
///    VK_PIPELINE_STAGE_SHADING_RATE_IMAGE_BIT_NV =
/// VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR,
///  // Provided by VK_NV_ray_tracing
///    VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_NV = VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_KHR,
///  // Provided by VK_NV_ray_tracing
///    VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_NV =
/// VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR,
///  // Provided by VK_KHR_synchronization2
///    VK_PIPELINE_STAGE_NONE_KHR = VK_PIPELINE_STAGE_NONE,
///} VkPipelineStageFlagBits;
///```
///# Description
///These values all have the same meaning as the equivalently named values for
///[`PipelineStageFlags2`].
/// - [`None`] specifies no stages of execution.
/// - [`PipelineStageDrawIndirect`] specifies the stage of the pipeline where `VkDrawIndirect*` /
///   `VkDispatchIndirect*` / `VkTraceRaysIndirect*` data structures are consumed. This stage also
///   includes reading commands written by [`CmdExecuteGeneratedCommandsNV`].
/// - [`TaskShaderNv`] specifies the task shader stage.
/// - [`MeshShaderNv`] specifies the mesh shader stage.
/// - [`PipelineStageVertexInput`] specifies the stage of the pipeline where vertex and index
///   buffers are consumed.
/// - [`PipelineStageVertexShader`] specifies the vertex shader stage.
/// - [`PipelineStageTessellationControlShader`] specifies the tessellation control shader stage.
/// - [`PipelineStageTessellationEvaluationShader`] specifies the tessellation evaluation shader
///   stage.
/// - [`PipelineStageGeometryShader`] specifies the geometry shader stage.
/// - [`PipelineStageFragmentShader`] specifies the fragment shader stage.
/// - [`PipelineStageEarlyFragmentTests`] specifies the stage of the pipeline where early fragment tests (depth and stencil tests before fragment shading) are performed. This stage also includes [subpass load operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-load-store-ops) for framebuffer attachments with a depth/stencil format.
/// - [`PipelineStageLateFragmentTests`] specifies the stage of the pipeline where late fragment tests (depth and stencil tests after fragment shading) are performed. This stage also includes [subpass store operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-load-store-ops) for framebuffer attachments with a depth/stencil format.
/// - [`PipelineStageColorAttachmentOutput`] specifies the stage of the pipeline after blending where the final color values are output from the pipeline. This stage also includes [subpass load and store operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-load-store-ops) and multisample resolve operations for framebuffer attachments with a color or depth/stencil format.
/// - [`PipelineStageComputeShader`] specifies the execution of a compute shader.
/// - [`PipelineStageTransfer`] specifies the following commands:  - All [copy commands](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#copies), including [`CmdCopyQueryPoolResults`]  - [`CmdBlitImage2`] and [`CmdBlitImage`]  - [`CmdResolveImage2`] and [`CmdResolveImage`]  - All [clear commands](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#clears), with the exception of [`CmdClearAttachments`]
/// - [`PipelineStageHost`] specifies a pseudo-stage indicating execution on the host of
///   reads/writes of device memory. This stage is not invoked by any commands recorded in a command
///   buffer.
/// - [`AccelerationStructureBuildKhr`] specifies     the execution of
///   [`CmdBuildAccelerationStructureNV`],     [`CmdCopyAccelerationStructureNV`],
///   [`CmdWriteAccelerationStructuresPropertiesNV`] ,     [`CmdBuildAccelerationStructuresKHR`],
///   [`CmdBuildAccelerationStructuresIndirectKHR`],     [`CmdCopyAccelerationStructureKHR`],
///   [`CmdCopyAccelerationStructureToMemoryKHR`],     [`CmdCopyMemoryToAccelerationStructureKHR`],
///   and     [`CmdWriteAccelerationStructuresPropertiesKHR`].
/// - [`RayTracingShaderKhr`] specifies the     execution of the ray tracing shader stages, via
///   [`CmdTraceRaysNV`] , [`CmdTraceRaysKHR`], or [`CmdTraceRaysIndirectKHR`]
/// - [`PipelineStageAllGraphics`] specifies the execution of all graphics pipeline stages, and is
///   equivalent to the logical OR of:  - [`PipelineStageDrawIndirect`]  - [`TaskShaderNv`]  -
///   [`MeshShaderNv`]  - [`PipelineStageVertexInput`]  - [`PipelineStageVertexShader`]  -
///   [`PipelineStageTessellationControlShader`]  - [`PipelineStageTessellationEvaluationShader`]  -
///   [`PipelineStageGeometryShader`]  - [`PipelineStageFragmentShader`]  -
///   [`PipelineStageEarlyFragmentTests`]  - [`PipelineStageLateFragmentTests`]  -
///   [`PipelineStageColorAttachmentOutput`]  - [`ConditionalRenderingExt`]  -
///   [`TransformFeedbackExt`]  - [`FragmentShadingRateAttachmentKhr`]  -
///   [`FragmentDensityProcessExt`]
/// - [`PipelineStageAllCommands`] specifies all operations performed by all commands supported on
///   the queue it is used with.
/// - [`ConditionalRenderingExt`] specifies the stage of the pipeline where the predicate of
///   conditional rendering is consumed.
/// - [`TransformFeedbackExt`] specifies the stage of the pipeline where vertex attribute output
///   values are written to the transform feedback buffers.
/// - [`CommandPreprocessNv`] specifies the stage of the pipeline where device-side preprocessing
///   for generated commands via [`CmdPreprocessGeneratedCommandsNV`] is handled.
/// - [`FragmentShadingRateAttachmentKhr`]     specifies the stage of the pipeline where the     [fragment shading rate     attachment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#primsrast-fragment-shading-rate-attachment) or     [shading rate image](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#primsrast-shading-rate-image)     is read to determine the fragment shading rate for portions of a     rasterized primitive.
/// - [`FragmentDensityProcessExt`] specifies the stage of the pipeline where the fragment density map is read to [generate the fragment areas](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fragmentdensitymapops).
/// - [`PipelineStageTopOfPipe`] is equivalent to [`PipelineStageAllCommands`] with [`AccessFlags`]
///   set to `0` when specified in the second synchronization scope, but specifies no stage of
///   execution when specified in the first scope.
/// - [`PipelineStageBottomOfPipe`] is equivalent to [`PipelineStageAllCommands`] with
///   [`AccessFlags`] set to `0` when specified in the first synchronization scope, but specifies no
///   stage of execution when specified in the second scope.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`CheckpointDataNV`]
/// - [`PipelineStageFlags`]
/// - [`CmdWriteBufferMarkerAMD`]
/// - [`CmdWriteTimestamp`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkPipelineStageFlagBits")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
#[repr(u32)]
pub enum PipelineStageFlagBits {
    ///[`PipelineStageTopOfPipe`] is equivalent to
    ///[`PipelineStageAllCommands`] with [`AccessFlags`] set to
    ///`0` when specified in the second synchronization scope, but specifies no
    ///stage of execution when specified in the first scope.
    PipelineStageTopOfPipe = 1,
    ///[`PipelineStageDrawIndirect`] specifies the stage of the
    ///pipeline where `VkDrawIndirect*` / `VkDispatchIndirect*` /
    ///`VkTraceRaysIndirect*` data structures are consumed.
    ///This stage also includes reading commands written by
    ///[`CmdExecuteGeneratedCommandsNV`].
    PipelineStageDrawIndirect = 2,
    ///[`PipelineStageVertexInput`] specifies the stage of the
    ///pipeline where vertex and index buffers are consumed.
    PipelineStageVertexInput = 4,
    ///[`PipelineStageVertexShader`] specifies the vertex shader
    ///stage.
    PipelineStageVertexShader = 8,
    ///[`PipelineStageTessellationControlShader`] specifies the
    ///tessellation control shader stage.
    PipelineStageTessellationControlShader = 16,
    ///[`PipelineStageTessellationEvaluationShader`] specifies the
    ///tessellation evaluation shader stage.
    PipelineStageTessellationEvaluationShader = 32,
    ///[`PipelineStageGeometryShader`] specifies the geometry
    ///shader stage.
    PipelineStageGeometryShader = 64,
    ///[`PipelineStageFragmentShader`] specifies the fragment
    ///shader stage.
    PipelineStageFragmentShader = 128,
    ///[`PipelineStageEarlyFragmentTests`] specifies the stage of
    ///the pipeline where early fragment tests (depth and stencil tests before
    ///fragment shading) are performed.
    ///This stage also includes [subpass load
    ///operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-load-store-ops) for framebuffer attachments with a depth/stencil format.
    PipelineStageEarlyFragmentTests = 256,
    ///[`PipelineStageLateFragmentTests`] specifies the stage of
    ///the pipeline where late fragment tests (depth and stencil tests after
    ///fragment shading) are performed.
    ///This stage also includes [subpass store
    ///operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-load-store-ops) for framebuffer attachments with a depth/stencil format.
    PipelineStageLateFragmentTests = 512,
    ///[`PipelineStageColorAttachmentOutput`] specifies the stage
    ///of the pipeline after blending where the final color values are output
    ///from the pipeline.
    ///This stage also includes [subpass load and
    ///store operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-load-store-ops) and multisample resolve operations for framebuffer
    ///attachments with a color
    ///or depth/stencil
    ///format.
    PipelineStageColorAttachmentOutput = 1024,
    ///[`PipelineStageComputeShader`] specifies the execution of a
    ///compute shader.
    PipelineStageComputeShader = 2048,
    ///[`PipelineStageTransfer`] specifies the following commands:
    /// - All [copy commands](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#copies),
    ///   including [`CmdCopyQueryPoolResults`]
    /// - [`CmdBlitImage2`] and [`CmdBlitImage`]
    /// - [`CmdResolveImage2`] and [`CmdResolveImage`]
    /// - All [clear commands](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#clears),
    ///   with the exception of [`CmdClearAttachments`]
    PipelineStageTransfer = 4096,
    ///[`PipelineStageBottomOfPipe`] is equivalent to
    ///[`PipelineStageAllCommands`] with [`AccessFlags`] set to
    ///`0` when specified in the first synchronization scope, but specifies no
    ///stage of execution when specified in the second scope.
    PipelineStageBottomOfPipe = 8192,
    ///[`PipelineStageHost`] specifies a pseudo-stage indicating
    ///execution on the host of reads/writes of device memory.
    ///This stage is not invoked by any commands recorded in a command buffer.
    PipelineStageHost = 16384,
    ///[`PipelineStageAllGraphics`] specifies the execution of all
    ///graphics pipeline stages, and is equivalent to the logical OR of:
    /// - [`PipelineStageDrawIndirect`]
    /// - [`TaskShaderNv`]
    /// - [`MeshShaderNv`]
    /// - [`PipelineStageVertexInput`]
    /// - [`PipelineStageVertexShader`]
    /// - [`PipelineStageTessellationControlShader`]
    /// - [`PipelineStageTessellationEvaluationShader`]
    /// - [`PipelineStageGeometryShader`]
    /// - [`PipelineStageFragmentShader`]
    /// - [`PipelineStageEarlyFragmentTests`]
    /// - [`PipelineStageLateFragmentTests`]
    /// - [`PipelineStageColorAttachmentOutput`]
    /// - [`ConditionalRenderingExt`]
    /// - [`TransformFeedbackExt`]
    /// - [`FragmentShadingRateAttachmentKhr`]
    /// - [`FragmentDensityProcessExt`]
    PipelineStageAllGraphics = 32768,
    ///[`PipelineStageAllCommands`] specifies all operations
    ///performed by all commands supported on the queue it is used with.
    PipelineStageAllCommands = 65536,
    ///[`None`] specifies no stages of execution.
    ///
    ///Provided by [`crate::vulkan1_3`]
    None = 0,
    ///[`TransformFeedbackExt`]
    ///
    ///Provided by [`crate::extensions::ext_transform_feedback`]
    TransformFeedbackExt = 16777216,
    ///[`ConditionalRenderingExt`]
    ///
    ///Provided by [`crate::extensions::ext_conditional_rendering`]
    ConditionalRenderingExt = 262144,
    ///[`AccelerationStructureBuildKhr`] specifies
    ///    the execution of
    ///    [`CmdBuildAccelerationStructureNV`],
    ///    [`CmdCopyAccelerationStructureNV`],
    ///    [`CmdWriteAccelerationStructuresPropertiesNV`]
    ///,
    ///    [`CmdBuildAccelerationStructuresKHR`],
    ///    [`CmdBuildAccelerationStructuresIndirectKHR`],
    ///    [`CmdCopyAccelerationStructureKHR`],
    ///    [`CmdCopyAccelerationStructureToMemoryKHR`],
    ///    [`CmdCopyMemoryToAccelerationStructureKHR`], and
    ///    [`CmdWriteAccelerationStructuresPropertiesKHR`].
    ///
    ///Provided by [`crate::extensions::khr_acceleration_structure`]
    AccelerationStructureBuildKhr = 33554432,
    ///[`RayTracingShaderKhr`] specifies the
    ///    execution of the ray tracing shader stages, via
    ///[`CmdTraceRaysNV`]
    ///,
    ///[`CmdTraceRaysKHR`], or [`CmdTraceRaysIndirectKHR`]
    ///
    ///Provided by [`crate::extensions::khr_ray_tracing_pipeline`]
    RayTracingShaderKhr = 2097152,
    ///[`TaskShaderNv`] specifies the task shader
    ///stage.
    ///
    ///Provided by [`crate::extensions::nv_mesh_shader`]
    TaskShaderNv = 524288,
    ///[`MeshShaderNv`] specifies the mesh shader
    ///stage.
    ///
    ///Provided by [`crate::extensions::nv_mesh_shader`]
    MeshShaderNv = 1048576,
    ///[`FragmentDensityProcessExt`]
    ///
    ///Provided by [`crate::extensions::ext_fragment_density_map`]
    FragmentDensityProcessExt = 8388608,
    ///[`FragmentShadingRateAttachmentKhr`]
    ///
    ///Provided by [`crate::extensions::khr_fragment_shading_rate`]
    FragmentShadingRateAttachmentKhr = 4194304,
    ///[`CommandPreprocessNv`] specifies the stage of
    ///the pipeline where device-side preprocessing for generated commands via
    ///[`CmdPreprocessGeneratedCommandsNV`] is handled.
    ///
    ///Provided by [`crate::extensions::nv_device_generated_commands`]
    CommandPreprocessNv = 131072,
}
impl const Default for PipelineStageFlagBits {
    fn default() -> Self {
        Self::None
    }
}
impl PipelineStageFlagBits {
    ///Default empty value
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Gets the raw underlying value
    #[inline]
    pub const fn bits(&self) -> u32 {
        self as u32
    }
    ///Gets a value from a raw underlying value, unchecked and therefore unsafe
    #[inline]
    pub const unsafe fn from_bits(bits: u32) -> u32 {
        std::mem::transmute(bits)
    }
}
///[VkCommandPoolCreateFlagBits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandPoolCreateFlagBits.html) - Bitmask specifying usage behavior for a command pool
///# C Specifications
///Bits which  **can**  be set in [`CommandPoolCreateInfo::flags`],
///specifying usage behavior for a command pool, are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkCommandPoolCreateFlagBits {
///    VK_COMMAND_POOL_CREATE_TRANSIENT_BIT = 0x00000001,
///    VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT = 0x00000002,
///  // Provided by VK_VERSION_1_1
///    VK_COMMAND_POOL_CREATE_PROTECTED_BIT = 0x00000004,
///} VkCommandPoolCreateFlagBits;
///```
///# Description
/// - [`CommandPoolCreateTransient`] specifies that command buffers allocated from the pool will be
///   short-lived, meaning that they will be reset or freed in a relatively short timeframe. This
///   flag  **may**  be used by the implementation to control memory allocation behavior within the
///   pool.
/// - [`CommandPoolCreateResetCommandBuffer`] allows any command buffer allocated from a pool to be individually reset to the [initial state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#commandbuffers-lifecycle); either by calling [`ResetCommandBuffer`], or via the implicit reset when calling [`BeginCommandBuffer`]. If this flag is not set on a pool, then [`ResetCommandBuffer`] **must**  not be called for any command buffer allocated from that pool.
/// - [`Protected`] specifies that command buffers allocated from the pool are protected command
///   buffers.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`CommandPoolCreateFlags`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkCommandPoolCreateFlagBits")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
#[repr(u32)]
pub enum CommandPoolCreateFlagBits {
    #[doc(hidden)]
    Empty = 0,
    ///[`CommandPoolCreateTransient`] specifies that command
    ///buffers allocated from the pool will be short-lived, meaning that they
    ///will be reset or freed in a relatively short timeframe.
    ///This flag  **may**  be used by the implementation to control memory
    ///allocation behavior within the pool.
    CommandPoolCreateTransient = 1,
    ///[`CommandPoolCreateResetCommandBuffer`] allows any command
    ///buffer allocated from a pool to be individually reset to the
    ///[initial state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#commandbuffers-lifecycle); either by calling
    ///[`ResetCommandBuffer`], or via the implicit reset when calling
    ///[`BeginCommandBuffer`].
    ///If this flag is not set on a pool, then [`ResetCommandBuffer`] **must**
    ///not be called for any command buffer allocated from that pool.
    CommandPoolCreateResetCommandBuffer = 2,
    ///[`Protected`] specifies that command
    ///buffers allocated from the pool are protected command buffers.
    ///
    ///Provided by [`crate::vulkan1_1`]
    Protected = 4,
}
impl const Default for CommandPoolCreateFlagBits {
    fn default() -> Self {
        Self::Empty
    }
}
impl CommandPoolCreateFlagBits {
    ///Default empty value
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Gets the raw underlying value
    #[inline]
    pub const fn bits(&self) -> u32 {
        self as u32
    }
    ///Gets a value from a raw underlying value, unchecked and therefore unsafe
    #[inline]
    pub const unsafe fn from_bits(bits: u32) -> u32 {
        std::mem::transmute(bits)
    }
}
///[VkCommandPoolResetFlagBits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandPoolResetFlagBits.html) - Bitmask controlling behavior of a command pool reset
///# C Specifications
///Bits which  **can**  be set in [`ResetCommandPool`]`::flags`, controlling
///the reset operation, are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkCommandPoolResetFlagBits {
///    VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT = 0x00000001,
///} VkCommandPoolResetFlagBits;
///```
///# Description
/// - [`CommandPoolResetReleaseResources`] specifies that resetting a command pool recycles all of
///   the resources from the command pool back to the system.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`CommandPoolResetFlags`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkCommandPoolResetFlagBits")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
#[repr(u32)]
pub enum CommandPoolResetFlagBits {
    #[doc(hidden)]
    Empty = 0,
    ///[`CommandPoolResetReleaseResources`] specifies that
    ///resetting a command pool recycles all of the resources from the command
    ///pool back to the system.
    CommandPoolResetReleaseResources = 1,
}
impl const Default for CommandPoolResetFlagBits {
    fn default() -> Self {
        Self::Empty
    }
}
impl CommandPoolResetFlagBits {
    ///Default empty value
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Gets the raw underlying value
    #[inline]
    pub const fn bits(&self) -> u32 {
        self as u32
    }
    ///Gets a value from a raw underlying value, unchecked and therefore unsafe
    #[inline]
    pub const unsafe fn from_bits(bits: u32) -> u32 {
        std::mem::transmute(bits)
    }
}
///[VkCommandBufferResetFlagBits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandBufferResetFlagBits.html) - Bitmask controlling behavior of a command buffer reset
///# C Specifications
///Bits which  **can**  be set in [`ResetCommandBuffer`]`::flags`,
///controlling the reset operation, are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkCommandBufferResetFlagBits {
///    VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT = 0x00000001,
///} VkCommandBufferResetFlagBits;
///```
///# Description
/// - [`CommandBufferResetReleaseResources`] specifies that most or all memory resources currently owned by the command buffer  **should**  be returned to the parent command pool. If this flag is not set, then the command buffer  **may**  hold onto memory resources and reuse them when recording commands. `commandBuffer` is moved to the [initial state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#commandbuffers-lifecycle).
///# Related
/// - [`crate::vulkan1_0`]
/// - [`CommandBufferResetFlags`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkCommandBufferResetFlagBits")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
#[repr(u32)]
pub enum CommandBufferResetFlagBits {
    #[doc(hidden)]
    Empty = 0,
    ///[`CommandBufferResetReleaseResources`] specifies that most
    ///or all memory resources currently owned by the command buffer  **should**  be
    ///returned to the parent command pool.
    ///If this flag is not set, then the command buffer  **may**  hold onto memory
    ///resources and reuse them when recording commands.
    ///`commandBuffer` is moved to the [initial
    ///state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#commandbuffers-lifecycle).
    CommandBufferResetReleaseResources = 1,
}
impl const Default for CommandBufferResetFlagBits {
    fn default() -> Self {
        Self::Empty
    }
}
impl CommandBufferResetFlagBits {
    ///Default empty value
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Gets the raw underlying value
    #[inline]
    pub const fn bits(&self) -> u32 {
        self as u32
    }
    ///Gets a value from a raw underlying value, unchecked and therefore unsafe
    #[inline]
    pub const unsafe fn from_bits(bits: u32) -> u32 {
        std::mem::transmute(bits)
    }
}
///[VkSampleCountFlagBits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSampleCountFlagBits.html) - Bitmask specifying sample counts supported for an image used for storage operations
///# C Specifications
///Bits which  **may**  be set in the sample count limits returned by
///[`PhysicalDeviceLimits`], as well as in other queries and structures
///representing image sample counts, are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkSampleCountFlagBits {
///    VK_SAMPLE_COUNT_1_BIT = 0x00000001,
///    VK_SAMPLE_COUNT_2_BIT = 0x00000002,
///    VK_SAMPLE_COUNT_4_BIT = 0x00000004,
///    VK_SAMPLE_COUNT_8_BIT = 0x00000008,
///    VK_SAMPLE_COUNT_16_BIT = 0x00000010,
///    VK_SAMPLE_COUNT_32_BIT = 0x00000020,
///    VK_SAMPLE_COUNT_64_BIT = 0x00000040,
///} VkSampleCountFlagBits;
///```
///# Description
/// - [`SampleCount1`] specifies an image with one sample per pixel.
/// - [`SampleCount2`] specifies an image with 2 samples per pixel.
/// - [`SampleCount4`] specifies an image with 4 samples per pixel.
/// - [`SampleCount8`] specifies an image with 8 samples per pixel.
/// - [`SampleCount16`] specifies an image with 16 samples per pixel.
/// - [`SampleCount32`] specifies an image with 32 samples per pixel.
/// - [`SampleCount64`] specifies an image with 64 samples per pixel.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`AttachmentDescription`]
/// - [`AttachmentDescription2`]
/// - [`AttachmentSampleCountInfoAMD`]
/// - [`CommandBufferInheritanceRenderingInfo`]
/// - [`FramebufferMixedSamplesCombinationNV`]
/// - [`ImageCreateInfo`]
/// - [`PhysicalDeviceFragmentShadingRateEnumsPropertiesNV`]
/// - [`PhysicalDeviceFragmentShadingRatePropertiesKHR`]
/// - [`PhysicalDeviceSparseImageFormatInfo2`]
/// - [`PipelineMultisampleStateCreateInfo`]
/// - [`SampleCountFlags`]
/// - [`SampleLocationsInfoEXT`]
/// - [`GetPhysicalDeviceMultisamplePropertiesEXT`]
/// - [`GetPhysicalDeviceSparseImageFormatProperties`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkSampleCountFlagBits")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
#[repr(u32)]
pub enum SampleCountFlagBits {
    #[doc(hidden)]
    Empty = 0,
    ///[`SampleCount1`] specifies an image with one sample per
    ///pixel.
    SampleCount1 = 1,
    ///[`SampleCount2`] specifies an image with 2 samples per pixel.
    SampleCount2 = 2,
    ///[`SampleCount4`] specifies an image with 4 samples per pixel.
    SampleCount4 = 4,
    ///[`SampleCount8`] specifies an image with 8 samples per pixel.
    SampleCount8 = 8,
    ///[`SampleCount16`] specifies an image with 16 samples per
    ///pixel.
    SampleCount16 = 16,
    ///[`SampleCount32`] specifies an image with 32 samples per
    ///pixel.
    SampleCount32 = 32,
    ///[`SampleCount64`] specifies an image with 64 samples per
    ///pixel.
    SampleCount64 = 64,
}
impl const Default for SampleCountFlagBits {
    fn default() -> Self {
        Self::Empty
    }
}
impl SampleCountFlagBits {
    ///Default empty value
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Gets the raw underlying value
    #[inline]
    pub const fn bits(&self) -> u32 {
        self as u32
    }
    ///Gets a value from a raw underlying value, unchecked and therefore unsafe
    #[inline]
    pub const unsafe fn from_bits(bits: u32) -> u32 {
        std::mem::transmute(bits)
    }
}
///[VkAttachmentDescriptionFlagBits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAttachmentDescriptionFlagBits.html) - Bitmask specifying additional properties of an attachment
///# C Specifications
///Bits which  **can**  be set in [`AttachmentDescription::flags`],
///describing additional properties of the attachment, are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkAttachmentDescriptionFlagBits {
///    VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT = 0x00000001,
///} VkAttachmentDescriptionFlagBits;
///```
///# Description
/// - [`AttachmentDescriptionMayAlias`] specifies that the attachment aliases the same device memory
///   as other attachments.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`AttachmentDescriptionFlags`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkAttachmentDescriptionFlagBits")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
#[repr(u32)]
pub enum AttachmentDescriptionFlagBits {
    #[doc(hidden)]
    Empty = 0,
    ///[`AttachmentDescriptionMayAlias`] specifies that the
    ///attachment aliases the same device memory as other attachments.
    AttachmentDescriptionMayAlias = 1,
}
impl const Default for AttachmentDescriptionFlagBits {
    fn default() -> Self {
        Self::Empty
    }
}
impl AttachmentDescriptionFlagBits {
    ///Default empty value
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Gets the raw underlying value
    #[inline]
    pub const fn bits(&self) -> u32 {
        self as u32
    }
    ///Gets a value from a raw underlying value, unchecked and therefore unsafe
    #[inline]
    pub const unsafe fn from_bits(bits: u32) -> u32 {
        std::mem::transmute(bits)
    }
}
///[VkStencilFaceFlagBits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkStencilFaceFlagBits.html) - Bitmask specifying sets of stencil state for which to update the compare mask
///# C Specifications
///[`StencilFaceFlagBits`] values are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkStencilFaceFlagBits {
///    VK_STENCIL_FACE_FRONT_BIT = 0x00000001,
///    VK_STENCIL_FACE_BACK_BIT = 0x00000002,
///    VK_STENCIL_FACE_FRONT_AND_BACK = 0x00000003,
///    VK_STENCIL_FRONT_AND_BACK = VK_STENCIL_FACE_FRONT_AND_BACK,
///} VkStencilFaceFlagBits;
///```
///# Description
/// - [`StencilFaceFront`] specifies that only the front set of stencil state is updated.
/// - [`StencilFaceBack`] specifies that only the back set of stencil state is updated.
/// - [`StencilFaceFrontAndBack`] is the combination of [`StencilFaceFront`] and
///   [`StencilFaceBack`], and specifies that both sets of stencil state are updated.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`StencilFaceFlags`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkStencilFaceFlagBits")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
#[repr(u32)]
pub enum StencilFaceFlagBits {
    #[doc(hidden)]
    Empty = 0,
    ///[`StencilFaceFront`] specifies that only the front set of
    ///stencil state is updated.
    StencilFaceFront = 1,
    ///[`StencilFaceBack`] specifies that only the back set of
    ///stencil state is updated.
    StencilFaceBack = 2,
    ///[`StencilFaceFrontAndBack`] is the combination of
    ///[`StencilFaceFront`] and [`StencilFaceBack`], and
    ///specifies that both sets of stencil state are updated.
    StencilFaceFrontAndBack = 3,
}
impl const Default for StencilFaceFlagBits {
    fn default() -> Self {
        Self::Empty
    }
}
impl StencilFaceFlagBits {
    ///Default empty value
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Gets the raw underlying value
    #[inline]
    pub const fn bits(&self) -> u32 {
        self as u32
    }
    ///Gets a value from a raw underlying value, unchecked and therefore unsafe
    #[inline]
    pub const unsafe fn from_bits(bits: u32) -> u32 {
        std::mem::transmute(bits)
    }
}
///[VkDescriptorPoolCreateFlagBits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorPoolCreateFlagBits.html) - Bitmask specifying certain supported operations on a descriptor pool
///# C Specifications
///Bits which  **can**  be set in [`DescriptorPoolCreateInfo::flags`],
///enabling operations on a descriptor pool, are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkDescriptorPoolCreateFlagBits {
///    VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT = 0x00000001,
///  // Provided by VK_VERSION_1_2
///    VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT = 0x00000002,
///  // Provided by VK_VALVE_mutable_descriptor_type
///    VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_VALVE = 0x00000004,
///  // Provided by VK_EXT_descriptor_indexing
///    VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT =
/// VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT,
///} VkDescriptorPoolCreateFlagBits;
///```
///# Description
/// - [`DescriptorPoolCreateFreeDescriptorSet`] specifies that descriptor sets  **can**  return
///   their individual allocations to the pool, i.e. all of [`AllocateDescriptorSets`],
///   [`FreeDescriptorSets`], and [`ResetDescriptorPool`] are allowed. Otherwise, descriptor sets
///   allocated from the pool  **must**  not be individually freed back to the pool, i.e. only
///   [`AllocateDescriptorSets`] and [`ResetDescriptorPool`] are allowed.
/// - [`UpdateAfterBind`] specifies that descriptor sets allocated from this pool  **can**  include
///   bindings with the `VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT` bit set. It is valid to
///   allocate descriptor sets that have bindings that do not set the
///   `VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT` bit from a pool that has [`UpdateAfterBind`]
///   set.
/// - [`HostOnlyValve`] specifies that this descriptor pool and the descriptor sets allocated from
///   it reside entirely in host memory and cannot be bound. Descriptor sets allocated from this
///   pool are partially exempt from the external synchronization requirement in
///   [`UpdateDescriptorSetWithTemplateKHR`] and [`UpdateDescriptorSets`]. Descriptor sets and their
///   descriptors can be updated concurrently in different threads, though the same descriptor
///   **must**  not be updated concurrently by two threads.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`DescriptorPoolCreateFlags`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkDescriptorPoolCreateFlagBits")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
#[repr(u32)]
pub enum DescriptorPoolCreateFlagBits {
    #[doc(hidden)]
    Empty = 0,
    ///[`DescriptorPoolCreateFreeDescriptorSet`] specifies that
    ///descriptor sets  **can**  return their individual allocations to the pool,
    ///i.e. all of [`AllocateDescriptorSets`], [`FreeDescriptorSets`],
    ///and [`ResetDescriptorPool`] are allowed.
    ///Otherwise, descriptor sets allocated from the pool  **must**  not be
    ///individually freed back to the pool, i.e. only
    ///[`AllocateDescriptorSets`] and [`ResetDescriptorPool`] are
    ///allowed.
    DescriptorPoolCreateFreeDescriptorSet = 1,
    ///[`UpdateAfterBind`] specifies that
    ///descriptor sets allocated from this pool  **can**  include bindings with the
    ///`VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT` bit set.
    ///It is valid to allocate descriptor sets that have bindings that do not
    ///set the `VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT` bit from a
    ///pool that has [`UpdateAfterBind`] set.
    ///
    ///Provided by [`crate::vulkan1_2`]
    UpdateAfterBind = 2,
    ///[`HostOnlyValve`] specifies that this
    ///descriptor pool and the descriptor sets allocated from it reside
    ///entirely in host memory and cannot be bound.
    ///Descriptor sets allocated from this pool are partially exempt from the
    ///external synchronization requirement in
    ///[`UpdateDescriptorSetWithTemplateKHR`] and
    ///[`UpdateDescriptorSets`].
    ///Descriptor sets and their descriptors can be updated concurrently in
    ///different threads, though the same descriptor  **must**  not be updated
    ///concurrently by two threads.
    ///
    ///Provided by [`crate::extensions::valve_mutable_descriptor_type`]
    HostOnlyValve = 4,
}
impl const Default for DescriptorPoolCreateFlagBits {
    fn default() -> Self {
        Self::Empty
    }
}
impl DescriptorPoolCreateFlagBits {
    ///Default empty value
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Gets the raw underlying value
    #[inline]
    pub const fn bits(&self) -> u32 {
        self as u32
    }
    ///Gets a value from a raw underlying value, unchecked and therefore unsafe
    #[inline]
    pub const unsafe fn from_bits(bits: u32) -> u32 {
        std::mem::transmute(bits)
    }
}
///[VkDependencyFlagBits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDependencyFlagBits.html) - Bitmask specifying how execution and memory dependencies are formed
///# C Specifications
///Bits which  **can**  be set in [`CmdPipelineBarrier`]`::dependencyFlags`,
///specifying how execution and memory dependencies are formed, are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkDependencyFlagBits {
///    VK_DEPENDENCY_BY_REGION_BIT = 0x00000001,
///  // Provided by VK_VERSION_1_1
///    VK_DEPENDENCY_DEVICE_GROUP_BIT = 0x00000004,
///  // Provided by VK_VERSION_1_1
///    VK_DEPENDENCY_VIEW_LOCAL_BIT = 0x00000002,
///  // Provided by VK_KHR_multiview
///    VK_DEPENDENCY_VIEW_LOCAL_BIT_KHR = VK_DEPENDENCY_VIEW_LOCAL_BIT,
///  // Provided by VK_KHR_device_group
///    VK_DEPENDENCY_DEVICE_GROUP_BIT_KHR = VK_DEPENDENCY_DEVICE_GROUP_BIT,
///} VkDependencyFlagBits;
///```
///# Description
/// - [`DependencyByRegion`] specifies that dependencies will be [framebuffer-local](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-framebuffer-regions).
/// - [`ViewLocal`] specifies that a [subpass has more than one view](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-pipeline-barriers-subpass-self-dependencies).
/// - [`DeviceGroup`] specifies that dependencies are [non-device-local](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-device-local-dependencies).
///# Related
/// - [`crate::vulkan1_0`]
/// - [`DependencyFlags`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkDependencyFlagBits")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
#[repr(u32)]
pub enum DependencyFlagBits {
    #[doc(hidden)]
    Empty = 0,
    ///[`DependencyByRegion`] specifies that dependencies will be
    ///[framebuffer-local](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-framebuffer-regions).
    DependencyByRegion = 1,
    ///[`DeviceGroup`] specifies that dependencies are
    ///[non-device-local](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-device-local-dependencies).
    ///
    ///Provided by [`crate::vulkan1_1`]
    DeviceGroup = 4,
    ///[`ViewLocal`] specifies that a
    ///[subpass
    ///has more than one view](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-pipeline-barriers-subpass-self-dependencies).
    ///
    ///Provided by [`crate::vulkan1_1`]
    ViewLocal = 2,
}
impl const Default for DependencyFlagBits {
    fn default() -> Self {
        Self::Empty
    }
}
impl DependencyFlagBits {
    ///Default empty value
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Gets the raw underlying value
    #[inline]
    pub const fn bits(&self) -> u32 {
        self as u32
    }
    ///Gets a value from a raw underlying value, unchecked and therefore unsafe
    #[inline]
    pub const unsafe fn from_bits(bits: u32) -> u32 {
        std::mem::transmute(bits)
    }
}
///[VkDescriptorSetLayoutCreateFlagBits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorSetLayoutCreateFlagBits.html) - Bitmask specifying descriptor set layout properties
///# C Specifications
///Bits which  **can**  be set in
///[`DescriptorSetLayoutCreateInfo::flags`], specifying options for
///descriptor set layout, are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkDescriptorSetLayoutCreateFlagBits {
///  // Provided by VK_VERSION_1_2
///    VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT = 0x00000002,
///  // Provided by VK_KHR_push_descriptor
///    VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR = 0x00000001,
///  // Provided by VK_VALVE_mutable_descriptor_type
///    VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_VALVE = 0x00000004,
///  // Provided by VK_EXT_descriptor_indexing
///    VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT =
/// VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT,
///} VkDescriptorSetLayoutCreateFlagBits;
///```
///# Description
/// - [`PushDescriptorKhr`] specifies that descriptor sets  **must**  not be allocated using this
///   layout, and descriptors are instead pushed by [`CmdPushDescriptorSetKHR`].
/// - [`UpdateAfterBindPool`] specifies that descriptor sets using this layout  **must**  be
///   allocated from a descriptor pool created with the
///   `VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT` bit set. Descriptor set layouts created with
///   this bit set have alternate limits for the maximum number of descriptors per-stage and
///   per-pipeline layout. The non-UpdateAfterBind limits only count descriptors in sets created
///   without this flag. The UpdateAfterBind limits count all descriptors, but the limits  **may**
///   be higher than the non-UpdateAfterBind limits.
/// - [`HostOnlyPoolValve`] specifies that descriptor sets using this layout  **must**  be allocated
///   from a descriptor pool created with the `VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_VALVE` bit
///   set. Descriptor set layouts created with this bit have no expressable limit for maximum number
///   of descriptors per-stage. Host descriptor sets are limited only by available host memory, but
///   **may**  be limited for implementation specific reasons. Implementations  **may**  limit the
///   number of supported descriptors to UpdateAfterBind limits or non-UpdateAfterBind limits,
///   whichever is larger.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`DescriptorSetLayoutCreateFlags`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkDescriptorSetLayoutCreateFlagBits")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
#[repr(u32)]
pub enum DescriptorSetLayoutCreateFlagBits {
    #[doc(hidden)]
    Empty = 0,
    ///[`UpdateAfterBindPool`]
    ///specifies that descriptor sets using this layout  **must**  be allocated from
    ///a descriptor pool created with the
    ///`VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT` bit set.
    ///Descriptor set layouts created with this bit set have alternate limits
    ///for the maximum number of descriptors per-stage and per-pipeline layout.
    ///The non-UpdateAfterBind limits only count descriptors in sets created
    ///without this flag.
    ///The UpdateAfterBind limits count all descriptors, but the limits  **may**  be
    ///higher than the non-UpdateAfterBind limits.
    ///
    ///Provided by [`crate::vulkan1_2`]
    UpdateAfterBindPool = 2,
    ///[`PushDescriptorKhr`] specifies
    ///that descriptor sets  **must**  not be allocated using this layout, and
    ///descriptors are instead pushed by [`CmdPushDescriptorSetKHR`].
    ///
    ///Provided by [`crate::extensions::khr_push_descriptor`]
    PushDescriptorKhr = 1,
    ///[`HostOnlyPoolValve`] specifies
    ///that descriptor sets using this layout  **must**  be allocated from a
    ///descriptor pool created with the
    ///`VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_VALVE` bit set.
    ///Descriptor set layouts created with this bit have no expressable limit
    ///for maximum number of descriptors per-stage.
    ///Host descriptor sets are limited only by available host memory, but  **may**
    ///be limited for implementation specific reasons.
    ///Implementations  **may**  limit the number of supported descriptors to
    ///UpdateAfterBind limits or non-UpdateAfterBind limits, whichever is
    ///larger.
    ///
    ///Provided by [`crate::extensions::valve_mutable_descriptor_type`]
    HostOnlyPoolValve = 4,
}
impl const Default for DescriptorSetLayoutCreateFlagBits {
    fn default() -> Self {
        Self::Empty
    }
}
impl DescriptorSetLayoutCreateFlagBits {
    ///Default empty value
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Gets the raw underlying value
    #[inline]
    pub const fn bits(&self) -> u32 {
        self as u32
    }
    ///Gets a value from a raw underlying value, unchecked and therefore unsafe
    #[inline]
    pub const unsafe fn from_bits(bits: u32) -> u32 {
        std::mem::transmute(bits)
    }
}
///[VkSubpassDescriptionFlagBits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSubpassDescriptionFlagBits.html) - Bitmask specifying usage of a subpass
///# C Specifications
///Bits which  **can**  be set in [`SubpassDescription::flags`],
///specifying usage of the subpass, are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkSubpassDescriptionFlagBits {
///  // Provided by VK_NVX_multiview_per_view_attributes
///    VK_SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX = 0x00000001,
///  // Provided by VK_NVX_multiview_per_view_attributes
///    VK_SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX = 0x00000002,
///  // Provided by VK_QCOM_render_pass_shader_resolve
///    VK_SUBPASS_DESCRIPTION_FRAGMENT_REGION_BIT_QCOM = 0x00000004,
///  // Provided by VK_QCOM_render_pass_shader_resolve
///    VK_SUBPASS_DESCRIPTION_SHADER_RESOLVE_BIT_QCOM = 0x00000008,
///  // Provided by VK_ARM_rasterization_order_attachment_access
///    VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_COLOR_ACCESS_BIT_ARM = 0x00000010,
///  // Provided by VK_ARM_rasterization_order_attachment_access
///    VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_ARM = 0x00000020,
///  // Provided by VK_ARM_rasterization_order_attachment_access
///    VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_ARM = 0x00000040,
///} VkSubpassDescriptionFlagBits;
///```
///# Description
/// - [`PerViewAttributesNvx`] specifies that shaders compiled for this subpass write the attributes
///   for all views in a single invocation of each [pre-rasterization shader stage](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-pre-rasterization).
///   All pipelines compiled against a subpass that includes this bit  **must**  write per-view
///   attributes to the `*PerViewNV[]` shader outputs, in addition to the non-per-view (e.g.
///   `Position`) outputs.
/// - [`PerViewPositionXOnlyNvx`] specifies that shaders compiled for this subpass use per-view
///   positions which only differ in value in the x component. Per-view viewport mask  **can**  also
///   be used.
/// - [`FragmentRegionQcom`] specifies that the framebuffer region is the fragment region, that is,
///   the minimum region dependencies are by pixel rather than by sample, such that any fragment
///   shader invocation  **can**  access any sample associated with that fragment shader invocation.
/// - [`ShaderResolveQcom`] specifies that the subpass performs shader resolve operations.
/// - [`RasterizationOrderAttachmentColorAccessArm`] specifies that this subpass supports pipelines
///   created with
///   `VK_PIPELINE_COLOR_BLEND_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_ARM`.
/// - [`RasterizationOrderAttachmentDepthAccessArm`] specifies that this subpass supports pipelines
///   created with
///   `VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_ARM`.
/// - [`RasterizationOrderAttachmentStencilAccessArm`] specifies that this subpass supports
///   pipelines created with
///   `VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_ARM`.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`SubpassDescriptionFlags`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkSubpassDescriptionFlagBits")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
#[repr(u32)]
pub enum SubpassDescriptionFlagBits {
    #[doc(hidden)]
    Empty = 0,
    ///[`PerViewAttributesNvx`] specifies that
    ///shaders compiled for this subpass write the attributes for all views in
    ///a single invocation of each
    ///[pre-rasterization shader
    ///stage](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-pre-rasterization).
    ///All pipelines compiled against a subpass that includes this bit  **must**
    ///write per-view attributes to the `*PerViewNV[]` shader outputs, in
    ///addition to the non-per-view (e.g. `Position`) outputs.
    ///
    ///Provided by [`crate::extensions::nvx_multiview_per_view_attributes`]
    PerViewAttributesNvx = 1,
    ///[`PerViewPositionXOnlyNvx`] specifies
    ///that shaders compiled for this subpass use per-view positions which only
    ///differ in value in the x component.
    ///Per-view viewport mask  **can**  also be used.
    ///
    ///Provided by [`crate::extensions::nvx_multiview_per_view_attributes`]
    PerViewPositionXOnlyNvx = 2,
    ///[`FragmentRegionQcom`] specifies that the
    ///framebuffer region is the fragment region, that is, the minimum region
    ///dependencies are by pixel rather than by sample, such that any fragment
    ///shader invocation  **can**  access any sample associated with that fragment
    ///shader invocation.
    ///
    ///Provided by [`crate::extensions::qcom_render_pass_shader_resolve`]
    FragmentRegionQcom = 4,
    ///[`ShaderResolveQcom`] specifies that the
    ///subpass performs shader resolve operations.
    ///
    ///Provided by [`crate::extensions::qcom_render_pass_shader_resolve`]
    ShaderResolveQcom = 8,
    ///[`RasterizationOrderAttachmentColorAccessArm`]
    ///specifies that this subpass supports pipelines created with
    ///`VK_PIPELINE_COLOR_BLEND_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_ARM`.
    ///
    ///Provided by [`crate::extensions::arm_rasterization_order_attachment_access`]
    RasterizationOrderAttachmentColorAccessArm = 16,
    ///[`RasterizationOrderAttachmentDepthAccessArm`]
    ///specifies that this subpass supports pipelines created with
    ///`VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_ARM`.
    ///
    ///Provided by [`crate::extensions::arm_rasterization_order_attachment_access`]
    RasterizationOrderAttachmentDepthAccessArm = 32,
    ///[`RasterizationOrderAttachmentStencilAccessArm`]
    ///specifies that this subpass supports pipelines created with
    ///`VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_ARM`.
    ///
    ///Provided by [`crate::extensions::arm_rasterization_order_attachment_access`]
    RasterizationOrderAttachmentStencilAccessArm = 64,
}
impl const Default for SubpassDescriptionFlagBits {
    fn default() -> Self {
        Self::Empty
    }
}
impl SubpassDescriptionFlagBits {
    ///Default empty value
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Gets the raw underlying value
    #[inline]
    pub const fn bits(&self) -> u32 {
        self as u32
    }
    ///Gets a value from a raw underlying value, unchecked and therefore unsafe
    #[inline]
    pub const unsafe fn from_bits(bits: u32) -> u32 {
        std::mem::transmute(bits)
    }
}
///[VkFramebufferCreateFlagBits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFramebufferCreateFlagBits.html) - Bitmask specifying framebuffer properties
///# C Specifications
///Bits which  **can**  be set in [`FramebufferCreateInfo::flags`],
///specifying options for framebuffers, are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkFramebufferCreateFlagBits {
///  // Provided by VK_VERSION_1_2
///    VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT = 0x00000001,
///  // Provided by VK_KHR_imageless_framebuffer
///    VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT_KHR = VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT,
///} VkFramebufferCreateFlagBits;
///```
///# Description
/// - [`Imageless`] specifies that image views are not specified, and only attachment compatibility
///   information will be provided via a [`FramebufferAttachmentImageInfo`] structure.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`FramebufferCreateFlags`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkFramebufferCreateFlagBits")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
#[repr(u32)]
pub enum FramebufferCreateFlagBits {
    #[doc(hidden)]
    Empty = 0,
    ///[`Imageless`] specifies that image views are
    ///not specified, and only attachment compatibility information will be
    ///provided via a [`FramebufferAttachmentImageInfo`] structure.
    ///
    ///Provided by [`crate::vulkan1_2`]
    Imageless = 1,
}
impl const Default for FramebufferCreateFlagBits {
    fn default() -> Self {
        Self::Empty
    }
}
impl FramebufferCreateFlagBits {
    ///Default empty value
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Gets the raw underlying value
    #[inline]
    pub const fn bits(&self) -> u32 {
        self as u32
    }
    ///Gets a value from a raw underlying value, unchecked and therefore unsafe
    #[inline]
    pub const unsafe fn from_bits(bits: u32) -> u32 {
        std::mem::transmute(bits)
    }
}
///[VkEventCreateFlagBits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkEventCreateFlagBits.html) - Event creation flag bits
///# C Specifications
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkEventCreateFlagBits {
///  // Provided by VK_VERSION_1_3
///    VK_EVENT_CREATE_DEVICE_ONLY_BIT = 0x00000001,
///  // Provided by VK_KHR_synchronization2
///    VK_EVENT_CREATE_DEVICE_ONLY_BIT_KHR = VK_EVENT_CREATE_DEVICE_ONLY_BIT,
///} VkEventCreateFlagBits;
///```
///# Description
/// - [`DeviceOnly`] specifies that host event commands will not be used with this event.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`EventCreateFlags`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkEventCreateFlagBits")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
#[repr(u32)]
pub enum EventCreateFlagBits {
    #[doc(hidden)]
    Empty = 0,
    ///[`DeviceOnly`] specifies that host event commands
    ///will not be used with this event.
    ///
    ///Provided by [`crate::vulkan1_3`]
    DeviceOnly = 1,
}
impl const Default for EventCreateFlagBits {
    fn default() -> Self {
        Self::Empty
    }
}
impl EventCreateFlagBits {
    ///Default empty value
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Gets the raw underlying value
    #[inline]
    pub const fn bits(&self) -> u32 {
        self as u32
    }
    ///Gets a value from a raw underlying value, unchecked and therefore unsafe
    #[inline]
    pub const unsafe fn from_bits(bits: u32) -> u32 {
        std::mem::transmute(bits)
    }
}
///[VkFramebufferCreateFlagBits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFramebufferCreateFlagBits.html) - Bitmask specifying framebuffer properties
///# C Specifications
///Bits which  **can**  be set in [`FramebufferCreateInfo::flags`],
///specifying options for framebuffers, are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkFramebufferCreateFlagBits {
///  // Provided by VK_VERSION_1_2
///    VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT = 0x00000001,
///  // Provided by VK_KHR_imageless_framebuffer
///    VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT_KHR = VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT,
///} VkFramebufferCreateFlagBits;
///```
///# Description
/// - [`Imageless`] specifies that image views are not specified, and only attachment compatibility
///   information will be provided via a [`FramebufferAttachmentImageInfo`] structure.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`FramebufferCreateFlags`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(transparent)]
pub struct FramebufferCreateFlags(u32);
impl const Default for FramebufferCreateFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl From<FramebufferCreateFlagBits> for FramebufferCreateFlags {
    fn from(from: FramebufferCreateFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(from as u32) }
    }
}
impl FramebufferCreateFlags {
    ///[`Imageless`] specifies that image views are
    ///not specified, and only attachment compatibility information will be
    ///provided via a [`FramebufferAttachmentImageInfo`] structure.
    ///
    ///Provided by [`crate::vulkan1_2`]
    const Imageless: Self = Self(1);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    pub const fn all() -> Self {
        Self::empty() | Self::Imageless
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl const std::ops::BitOr for FramebufferCreateFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl std::ops::BitOrAssign for FramebufferCreateFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl const std::ops::BitXor for FramebufferCreateFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl std::ops::BitXorAssign for FramebufferCreateFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl const std::ops::BitAnd for FramebufferCreateFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl std::ops::BitAndAssign for FramebufferCreateFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl const std::ops::Sub for FramebufferCreateFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl std::ops::SubAssign for FramebufferCreateFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl const std::ops::Not for FramebufferCreateFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl std::iter::Extend<FramebufferCreateFlags> for FramebufferCreateFlags {
    fn extend<T: std::iter::IntoIterator<Item = FramebufferCreateFlags>>(&mut self, iterator: T) {
        for i in iterator {
            self.insert(i);
        }
    }
}
impl std::iter::Extend<FramebufferCreateFlagBits> for FramebufferCreateFlags {
    fn extend<T: std::iter::IntoIterator<Item = FramebufferCreateFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            self.insert(FramebufferCreateFlags::from(i));
        }
    }
}
impl std::iter::FromIterator<FramebufferCreateFlags> for FramebufferCreateFlags {
    fn from_iter<T: std::iter::IntoIterator<Item = FramebufferCreateFlags>>(iterator: T) -> FramebufferCreateFlags {
        let mut out = FramebufferCreateFlags::empty();
        out.extend(iterator);
        out
    }
}
impl std::iter::FromIterator<FramebufferCreateFlagBits> for FramebufferCreateFlags {
    fn from_iter<T: std::iter::IntoIterator<Item = FramebufferCreateFlagBits>>(iterator: T) -> FramebufferCreateFlags {
        let mut out = FramebufferCreateFlags::empty();
        out.extend(iterator);
        out
    }
}
impl std::fmt::Debug for FramebufferCreateFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(FramebufferCreateFlags);
        impl std::fmt::Debug for Flags {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == FramebufferCreateFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(FramebufferCreateFlags::Imageless) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(Imageless))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(FramebufferCreateFlags))
            .field(&Flags(*self))
            .finish()
    }
}
///[VkQueryPoolCreateFlags](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkQueryPoolCreateFlags.html) - Reserved for future use
///# C Specifications
///```c
///// Provided by VK_VERSION_1_0
///typedef VkFlags VkQueryPoolCreateFlags;
///```
///# Related
/// - [`crate::vulkan1_0`]
/// - [`QueryPoolCreateInfo`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(transparent)]
pub struct QueryPoolCreateFlags(u32);
impl const Default for QueryPoolCreateFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl std::fmt::Debug for QueryPoolCreateFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        f.debug_tuple(stringify!(QueryPoolCreateFlags)).field(&self.0).finish()
    }
}
///[VkRenderPassCreateFlagBits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderPassCreateFlagBits.html) - Bitmask specifying additional properties of a render pass
///# C Specifications
///Bits which  **can**  be set in [`RenderPassCreateInfo::flags`],
///describing additional properties of the render pass, are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkRenderPassCreateFlagBits {
///  // Provided by VK_QCOM_render_pass_transform
///    VK_RENDER_PASS_CREATE_TRANSFORM_BIT_QCOM = 0x00000002,
///} VkRenderPassCreateFlagBits;
///```
///# Description
/// - [`TransformQcom`] specifies that the created render pass is compatible with [render pass transform](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#vertexpostproc-renderpass-transform).
///# Related
/// - [`crate::vulkan1_0`]
/// - [`RenderPassCreateFlags`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(transparent)]
pub struct RenderPassCreateFlags(u32);
impl const Default for RenderPassCreateFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl From<RenderPassCreateFlagBits> for RenderPassCreateFlags {
    fn from(from: RenderPassCreateFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(from as u32) }
    }
}
impl RenderPassCreateFlags {
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_extension_221`]
    const Reserved0Khr: Self = Self(1);
    ///[`TransformQcom`] specifies that the
    ///created render pass is compatible with
    ///[render pass transform](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#vertexpostproc-renderpass-transform).
    ///
    ///Provided by [`crate::extensions::qcom_render_pass_transform`]
    const TransformQcom: Self = Self(2);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    pub const fn all() -> Self {
        Self::empty() | Self::Reserved0Khr | Self::TransformQcom
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl const std::ops::BitOr for RenderPassCreateFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl std::ops::BitOrAssign for RenderPassCreateFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl const std::ops::BitXor for RenderPassCreateFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl std::ops::BitXorAssign for RenderPassCreateFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl const std::ops::BitAnd for RenderPassCreateFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl std::ops::BitAndAssign for RenderPassCreateFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl const std::ops::Sub for RenderPassCreateFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl std::ops::SubAssign for RenderPassCreateFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl const std::ops::Not for RenderPassCreateFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl std::iter::Extend<RenderPassCreateFlags> for RenderPassCreateFlags {
    fn extend<T: std::iter::IntoIterator<Item = RenderPassCreateFlags>>(&mut self, iterator: T) {
        for i in iterator {
            self.insert(i);
        }
    }
}
impl std::iter::Extend<RenderPassCreateFlagBits> for RenderPassCreateFlags {
    fn extend<T: std::iter::IntoIterator<Item = RenderPassCreateFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            self.insert(RenderPassCreateFlags::from(i));
        }
    }
}
impl std::iter::FromIterator<RenderPassCreateFlags> for RenderPassCreateFlags {
    fn from_iter<T: std::iter::IntoIterator<Item = RenderPassCreateFlags>>(iterator: T) -> RenderPassCreateFlags {
        let mut out = RenderPassCreateFlags::empty();
        out.extend(iterator);
        out
    }
}
impl std::iter::FromIterator<RenderPassCreateFlagBits> for RenderPassCreateFlags {
    fn from_iter<T: std::iter::IntoIterator<Item = RenderPassCreateFlagBits>>(iterator: T) -> RenderPassCreateFlags {
        let mut out = RenderPassCreateFlags::empty();
        out.extend(iterator);
        out
    }
}
impl std::fmt::Debug for RenderPassCreateFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(RenderPassCreateFlags);
        impl std::fmt::Debug for Flags {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == RenderPassCreateFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(RenderPassCreateFlags::Reserved0Khr) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(Reserved0Khr))?;
                    }
                    if self.0.contains(RenderPassCreateFlags::TransformQcom) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(TransformQcom))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(RenderPassCreateFlags))
            .field(&Flags(*self))
            .finish()
    }
}
///[VkSamplerCreateFlagBits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSamplerCreateFlagBits.html) - Bitmask specifying additional parameters of sampler
///# C Specifications
///Bits which  **can**  be set in [`SamplerCreateInfo::flags`], specifying
///additional parameters of a sampler, are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkSamplerCreateFlagBits {
///  // Provided by VK_EXT_fragment_density_map
///    VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT = 0x00000001,
///  // Provided by VK_EXT_fragment_density_map
///    VK_SAMPLER_CREATE_SUBSAMPLED_COARSE_RECONSTRUCTION_BIT_EXT = 0x00000002,
///} VkSamplerCreateFlagBits;
///```
///# Description
/// - [`SubsampledExt`] specifies that the sampler will read from an image created with `flags`
///   containing `VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT`.
/// - [`SubsampledCoarseReconstructionExt`] specifies that the implementation  **may**  use
///   approximations when reconstructing a full color value for texture access from a subsampled
///   image.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`SamplerCreateFlags`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(transparent)]
pub struct SamplerCreateFlags(u32);
impl const Default for SamplerCreateFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl From<SamplerCreateFlagBits> for SamplerCreateFlags {
    fn from(from: SamplerCreateFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(from as u32) }
    }
}
impl SamplerCreateFlags {
    ///[`SubsampledExt`]
    ///specifies that the sampler will read from an image created with
    ///`flags` containing `VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT`.
    ///
    ///Provided by [`crate::extensions::ext_fragment_density_map`]
    const SubsampledExt: Self = Self(1);
    ///[`SubsampledCoarseReconstructionExt`]
    ///specifies that the implementation  **may**  use approximations when
    ///reconstructing a full color value for texture access from a subsampled
    ///image.
    ///
    ///Provided by [`crate::extensions::ext_fragment_density_map`]
    const SubsampledCoarseReconstructionExt: Self = Self(2);
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::amd_extension_317`]
    const Reserved3Amd: Self = Self(8);
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_disable_cube_map_wrap`]
    const Reserved2Ext: Self = Self(4);
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::qcom_extension_441`]
    const ImageProcessingQcom: Self = Self(16);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    pub const fn all() -> Self {
        Self::empty()
            | Self::SubsampledExt
            | Self::SubsampledCoarseReconstructionExt
            | Self::Reserved3Amd
            | Self::Reserved2Ext
            | Self::ImageProcessingQcom
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl const std::ops::BitOr for SamplerCreateFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl std::ops::BitOrAssign for SamplerCreateFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl const std::ops::BitXor for SamplerCreateFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl std::ops::BitXorAssign for SamplerCreateFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl const std::ops::BitAnd for SamplerCreateFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl std::ops::BitAndAssign for SamplerCreateFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl const std::ops::Sub for SamplerCreateFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl std::ops::SubAssign for SamplerCreateFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl const std::ops::Not for SamplerCreateFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl std::iter::Extend<SamplerCreateFlags> for SamplerCreateFlags {
    fn extend<T: std::iter::IntoIterator<Item = SamplerCreateFlags>>(&mut self, iterator: T) {
        for i in iterator {
            self.insert(i);
        }
    }
}
impl std::iter::Extend<SamplerCreateFlagBits> for SamplerCreateFlags {
    fn extend<T: std::iter::IntoIterator<Item = SamplerCreateFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            self.insert(SamplerCreateFlags::from(i));
        }
    }
}
impl std::iter::FromIterator<SamplerCreateFlags> for SamplerCreateFlags {
    fn from_iter<T: std::iter::IntoIterator<Item = SamplerCreateFlags>>(iterator: T) -> SamplerCreateFlags {
        let mut out = SamplerCreateFlags::empty();
        out.extend(iterator);
        out
    }
}
impl std::iter::FromIterator<SamplerCreateFlagBits> for SamplerCreateFlags {
    fn from_iter<T: std::iter::IntoIterator<Item = SamplerCreateFlagBits>>(iterator: T) -> SamplerCreateFlags {
        let mut out = SamplerCreateFlags::empty();
        out.extend(iterator);
        out
    }
}
impl std::fmt::Debug for SamplerCreateFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(SamplerCreateFlags);
        impl std::fmt::Debug for Flags {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == SamplerCreateFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(SamplerCreateFlags::SubsampledExt) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(SubsampledExt))?;
                    }
                    if self.0.contains(SamplerCreateFlags::SubsampledCoarseReconstructionExt) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(SubsampledCoarseReconstructionExt))?;
                    }
                    if self.0.contains(SamplerCreateFlags::Reserved3Amd) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(Reserved3Amd))?;
                    }
                    if self.0.contains(SamplerCreateFlags::Reserved2Ext) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(Reserved2Ext))?;
                    }
                    if self.0.contains(SamplerCreateFlags::ImageProcessingQcom) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(ImageProcessingQcom))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(SamplerCreateFlags))
            .field(&Flags(*self))
            .finish()
    }
}
///[VkPipelineLayoutCreateFlags](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineLayoutCreateFlags.html) - Reserved for future use
///# C Specifications
///```c
///// Provided by VK_VERSION_1_0
///typedef VkFlags VkPipelineLayoutCreateFlags;
///```
///# Related
/// - [`crate::vulkan1_0`]
/// - [`PipelineLayoutCreateInfo`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(transparent)]
pub struct PipelineLayoutCreateFlags(u32);
impl const Default for PipelineLayoutCreateFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl std::fmt::Debug for PipelineLayoutCreateFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        f.debug_tuple(stringify!(PipelineLayoutCreateFlags))
            .field(&self.0)
            .finish()
    }
}
///[VkPipelineCacheCreateFlagBits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineCacheCreateFlagBits.html) - Bitmask specifying the behavior of the pipeline cache
///# C Specifications
///Bits which  **can**  be set in [`PipelineCacheCreateInfo::flags`],
///specifying behavior of the pipeline cache, are:
///```c
///// Provided by VK_EXT_pipeline_creation_cache_control
///typedef enum VkPipelineCacheCreateFlagBits {
///  // Provided by VK_VERSION_1_3
///    VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT = 0x00000001,
///  // Provided by VK_EXT_pipeline_creation_cache_control
///    VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT_EXT =
/// VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT,
///} VkPipelineCacheCreateFlagBits;
///```
///# Description
/// - [`ExternallySynchronized`] specifies that all commands that modify the created [`PipelineCache`] will be [externally synchronized](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fundamentals-threadingbehavior). When set, the implementation  **may**  skip any unnecessary processing needed to support simultaneous modification from multiple threads where allowed.
///# Related
/// - [`VK_EXT_pipeline_creation_cache_control`]
/// - [`PipelineCacheCreateFlags`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(transparent)]
pub struct PipelineCacheCreateFlags(u32);
impl const Default for PipelineCacheCreateFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl From<PipelineCacheCreateFlagBits> for PipelineCacheCreateFlags {
    fn from(from: PipelineCacheCreateFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(from as u32) }
    }
}
impl PipelineCacheCreateFlags {
    ///[`ExternallySynchronized`] specifies
    ///that all commands that modify the created [`PipelineCache`] will be
    ///[externally synchronized](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fundamentals-threadingbehavior).
    ///When set, the implementation  **may**  skip any unnecessary processing needed
    ///to support simultaneous modification from multiple threads where
    ///allowed.
    ///
    ///Provided by [`crate::vulkan1_3`]
    const ExternallySynchronized: Self = Self(1);
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::google_extension_196`]
    const Reserved1Ext: Self = Self(2);
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_extension_299`]
    const Reserved2Khr: Self = Self(4);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    pub const fn all() -> Self {
        Self::empty() | Self::ExternallySynchronized | Self::Reserved1Ext | Self::Reserved2Khr
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl const std::ops::BitOr for PipelineCacheCreateFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl std::ops::BitOrAssign for PipelineCacheCreateFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl const std::ops::BitXor for PipelineCacheCreateFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl std::ops::BitXorAssign for PipelineCacheCreateFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl const std::ops::BitAnd for PipelineCacheCreateFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl std::ops::BitAndAssign for PipelineCacheCreateFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl const std::ops::Sub for PipelineCacheCreateFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl std::ops::SubAssign for PipelineCacheCreateFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl const std::ops::Not for PipelineCacheCreateFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl std::iter::Extend<PipelineCacheCreateFlags> for PipelineCacheCreateFlags {
    fn extend<T: std::iter::IntoIterator<Item = PipelineCacheCreateFlags>>(&mut self, iterator: T) {
        for i in iterator {
            self.insert(i);
        }
    }
}
impl std::iter::Extend<PipelineCacheCreateFlagBits> for PipelineCacheCreateFlags {
    fn extend<T: std::iter::IntoIterator<Item = PipelineCacheCreateFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            self.insert(PipelineCacheCreateFlags::from(i));
        }
    }
}
impl std::iter::FromIterator<PipelineCacheCreateFlags> for PipelineCacheCreateFlags {
    fn from_iter<T: std::iter::IntoIterator<Item = PipelineCacheCreateFlags>>(iterator: T) -> PipelineCacheCreateFlags {
        let mut out = PipelineCacheCreateFlags::empty();
        out.extend(iterator);
        out
    }
}
impl std::iter::FromIterator<PipelineCacheCreateFlagBits> for PipelineCacheCreateFlags {
    fn from_iter<T: std::iter::IntoIterator<Item = PipelineCacheCreateFlagBits>>(
        iterator: T,
    ) -> PipelineCacheCreateFlags {
        let mut out = PipelineCacheCreateFlags::empty();
        out.extend(iterator);
        out
    }
}
impl std::fmt::Debug for PipelineCacheCreateFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(PipelineCacheCreateFlags);
        impl std::fmt::Debug for Flags {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == PipelineCacheCreateFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(PipelineCacheCreateFlags::ExternallySynchronized) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(ExternallySynchronized))?;
                    }
                    if self.0.contains(PipelineCacheCreateFlags::Reserved1Ext) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(Reserved1Ext))?;
                    }
                    if self.0.contains(PipelineCacheCreateFlags::Reserved2Khr) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(Reserved2Khr))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(PipelineCacheCreateFlags))
            .field(&Flags(*self))
            .finish()
    }
}
///[VkPipelineDepthStencilStateCreateFlagBits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineDepthStencilStateCreateFlagBits.html) - Bitmask specifying additional depth/stencil state information.
///# C Specifications
///Bits which  **can**  be set in the
///[`PipelineDepthStencilStateCreateInfo::flags`] parameter are:
///```c
///// Provided by VK_ARM_rasterization_order_attachment_access
///typedef enum VkPipelineDepthStencilStateCreateFlagBits {
///  // Provided by VK_ARM_rasterization_order_attachment_access
///    VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_ARM =
/// 0x00000001,
///  // Provided by VK_ARM_rasterization_order_attachment_access
///    VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_ARM
/// = 0x00000002,
///} VkPipelineDepthStencilStateCreateFlagBits;
///```
///# Description
/// - [`RasterizationOrderAttachmentDepthAccessArm`] indicates that access to the depth aspects of depth/stencil and input attachments will have implicit framebuffer-local memory dependencies. See [renderpass feedback loops](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-feedbackloop) for more information.
/// - [`RasterizationOrderAttachmentStencilAccessArm`] indicates that access to the stencil aspects of depth/stencil and input attachments will have implicit framebuffer-local memory dependencies. See [renderpass feedback loops](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-feedbackloop) for more information.
///# Related
/// - [`VK_ARM_rasterization_order_attachment_access`]
/// - [`PipelineDepthStencilStateCreateFlags`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(transparent)]
pub struct PipelineDepthStencilStateCreateFlags(u32);
impl const Default for PipelineDepthStencilStateCreateFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl From<PipelineDepthStencilStateCreateFlagBits> for PipelineDepthStencilStateCreateFlags {
    fn from(from: PipelineDepthStencilStateCreateFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(from as u32) }
    }
}
impl PipelineDepthStencilStateCreateFlags {
    ///[`RasterizationOrderAttachmentDepthAccessArm`]
    ///indicates that access to the depth aspects of depth/stencil and input
    ///attachments will have implicit framebuffer-local memory dependencies.
    ///See [renderpass feedback loops](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-feedbackloop) for more
    ///information.
    ///
    ///Provided by [`crate::extensions::arm_rasterization_order_attachment_access`]
    const RasterizationOrderAttachmentDepthAccessArm: Self = Self(1);
    ///[`RasterizationOrderAttachmentStencilAccessArm`]
    ///indicates that access to the stencil aspects of depth/stencil and input
    ///attachments will have implicit framebuffer-local memory dependencies.
    ///See [renderpass feedback loops](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-feedbackloop) for more
    ///information.
    ///
    ///Provided by [`crate::extensions::arm_rasterization_order_attachment_access`]
    const RasterizationOrderAttachmentStencilAccessArm: Self = Self(2);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    pub const fn all() -> Self {
        Self::empty()
            | Self::RasterizationOrderAttachmentDepthAccessArm
            | Self::RasterizationOrderAttachmentStencilAccessArm
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl const std::ops::BitOr for PipelineDepthStencilStateCreateFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl std::ops::BitOrAssign for PipelineDepthStencilStateCreateFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl const std::ops::BitXor for PipelineDepthStencilStateCreateFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl std::ops::BitXorAssign for PipelineDepthStencilStateCreateFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl const std::ops::BitAnd for PipelineDepthStencilStateCreateFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl std::ops::BitAndAssign for PipelineDepthStencilStateCreateFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl const std::ops::Sub for PipelineDepthStencilStateCreateFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl std::ops::SubAssign for PipelineDepthStencilStateCreateFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl const std::ops::Not for PipelineDepthStencilStateCreateFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl std::iter::Extend<PipelineDepthStencilStateCreateFlags> for PipelineDepthStencilStateCreateFlags {
    fn extend<T: std::iter::IntoIterator<Item = PipelineDepthStencilStateCreateFlags>>(&mut self, iterator: T) {
        for i in iterator {
            self.insert(i);
        }
    }
}
impl std::iter::Extend<PipelineDepthStencilStateCreateFlagBits> for PipelineDepthStencilStateCreateFlags {
    fn extend<T: std::iter::IntoIterator<Item = PipelineDepthStencilStateCreateFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            self.insert(PipelineDepthStencilStateCreateFlags::from(i));
        }
    }
}
impl std::iter::FromIterator<PipelineDepthStencilStateCreateFlags> for PipelineDepthStencilStateCreateFlags {
    fn from_iter<T: std::iter::IntoIterator<Item = PipelineDepthStencilStateCreateFlags>>(
        iterator: T,
    ) -> PipelineDepthStencilStateCreateFlags {
        let mut out = PipelineDepthStencilStateCreateFlags::empty();
        out.extend(iterator);
        out
    }
}
impl std::iter::FromIterator<PipelineDepthStencilStateCreateFlagBits> for PipelineDepthStencilStateCreateFlags {
    fn from_iter<T: std::iter::IntoIterator<Item = PipelineDepthStencilStateCreateFlagBits>>(
        iterator: T,
    ) -> PipelineDepthStencilStateCreateFlags {
        let mut out = PipelineDepthStencilStateCreateFlags::empty();
        out.extend(iterator);
        out
    }
}
impl std::fmt::Debug for PipelineDepthStencilStateCreateFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(PipelineDepthStencilStateCreateFlags);
        impl std::fmt::Debug for Flags {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == PipelineDepthStencilStateCreateFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self
                        .0
                        .contains(PipelineDepthStencilStateCreateFlags::RasterizationOrderAttachmentDepthAccessArm)
                    {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(RasterizationOrderAttachmentDepthAccessArm))?;
                    }
                    if self
                        .0
                        .contains(PipelineDepthStencilStateCreateFlags::RasterizationOrderAttachmentStencilAccessArm)
                    {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(RasterizationOrderAttachmentStencilAccessArm))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(PipelineDepthStencilStateCreateFlags))
            .field(&Flags(*self))
            .finish()
    }
}
///[VkPipelineDynamicStateCreateFlags](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineDynamicStateCreateFlags.html) - Reserved for future use
///# C Specifications
///```c
///// Provided by VK_VERSION_1_0
///typedef VkFlags VkPipelineDynamicStateCreateFlags;
///```
///# Related
/// - [`crate::vulkan1_0`]
/// - [`PipelineDynamicStateCreateInfo`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(transparent)]
pub struct PipelineDynamicStateCreateFlags(u32);
impl const Default for PipelineDynamicStateCreateFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl std::fmt::Debug for PipelineDynamicStateCreateFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        f.debug_tuple(stringify!(PipelineDynamicStateCreateFlags))
            .field(&self.0)
            .finish()
    }
}
///[VkPipelineColorBlendStateCreateFlagBits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineColorBlendStateCreateFlagBits.html) - Bitmask specifying additional parameters of an image
///# C Specifications
///Bits which  **can**  be set in the
///[`PipelineColorBlendStateCreateInfo::flags`] parameter are:
///```c
///// Provided by VK_ARM_rasterization_order_attachment_access
///typedef enum VkPipelineColorBlendStateCreateFlagBits {
///  // Provided by VK_ARM_rasterization_order_attachment_access
///    VK_PIPELINE_COLOR_BLEND_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_ARM =
/// 0x00000001,
///} VkPipelineColorBlendStateCreateFlagBits;
///```
///# Description
/// - [`RasterizationOrderAttachmentAccessArm`] indicates that access to color and input attachments
///   will have implicit framebuffer-local memory dependencies, allowing applications to express custom
///   blending operations in a fragment shader. See [renderpass feedback loops](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-feedbackloop)
///   for more information.
///# Related
/// - [`VK_ARM_rasterization_order_attachment_access`]
/// - [`PipelineColorBlendStateCreateFlags`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(transparent)]
pub struct PipelineColorBlendStateCreateFlags(u32);
impl const Default for PipelineColorBlendStateCreateFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl From<PipelineColorBlendStateCreateFlagBits> for PipelineColorBlendStateCreateFlags {
    fn from(from: PipelineColorBlendStateCreateFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(from as u32) }
    }
}
impl PipelineColorBlendStateCreateFlags {
    ///[`RasterizationOrderAttachmentAccessArm`]
    ///indicates that access to color and input attachments will have implicit
    ///framebuffer-local memory dependencies, allowing applications to express
    ///custom blending operations in a fragment shader.
    ///See [renderpass feedback loops](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-feedbackloop) for more
    ///information.
    ///
    ///Provided by [`crate::extensions::arm_rasterization_order_attachment_access`]
    const RasterizationOrderAttachmentAccessArm: Self = Self(1);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    pub const fn all() -> Self {
        Self::empty() | Self::RasterizationOrderAttachmentAccessArm
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl const std::ops::BitOr for PipelineColorBlendStateCreateFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl std::ops::BitOrAssign for PipelineColorBlendStateCreateFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl const std::ops::BitXor for PipelineColorBlendStateCreateFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl std::ops::BitXorAssign for PipelineColorBlendStateCreateFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl const std::ops::BitAnd for PipelineColorBlendStateCreateFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl std::ops::BitAndAssign for PipelineColorBlendStateCreateFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl const std::ops::Sub for PipelineColorBlendStateCreateFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl std::ops::SubAssign for PipelineColorBlendStateCreateFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl const std::ops::Not for PipelineColorBlendStateCreateFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl std::iter::Extend<PipelineColorBlendStateCreateFlags> for PipelineColorBlendStateCreateFlags {
    fn extend<T: std::iter::IntoIterator<Item = PipelineColorBlendStateCreateFlags>>(&mut self, iterator: T) {
        for i in iterator {
            self.insert(i);
        }
    }
}
impl std::iter::Extend<PipelineColorBlendStateCreateFlagBits> for PipelineColorBlendStateCreateFlags {
    fn extend<T: std::iter::IntoIterator<Item = PipelineColorBlendStateCreateFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            self.insert(PipelineColorBlendStateCreateFlags::from(i));
        }
    }
}
impl std::iter::FromIterator<PipelineColorBlendStateCreateFlags> for PipelineColorBlendStateCreateFlags {
    fn from_iter<T: std::iter::IntoIterator<Item = PipelineColorBlendStateCreateFlags>>(
        iterator: T,
    ) -> PipelineColorBlendStateCreateFlags {
        let mut out = PipelineColorBlendStateCreateFlags::empty();
        out.extend(iterator);
        out
    }
}
impl std::iter::FromIterator<PipelineColorBlendStateCreateFlagBits> for PipelineColorBlendStateCreateFlags {
    fn from_iter<T: std::iter::IntoIterator<Item = PipelineColorBlendStateCreateFlagBits>>(
        iterator: T,
    ) -> PipelineColorBlendStateCreateFlags {
        let mut out = PipelineColorBlendStateCreateFlags::empty();
        out.extend(iterator);
        out
    }
}
impl std::fmt::Debug for PipelineColorBlendStateCreateFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(PipelineColorBlendStateCreateFlags);
        impl std::fmt::Debug for Flags {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == PipelineColorBlendStateCreateFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self
                        .0
                        .contains(PipelineColorBlendStateCreateFlags::RasterizationOrderAttachmentAccessArm)
                    {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(RasterizationOrderAttachmentAccessArm))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(PipelineColorBlendStateCreateFlags))
            .field(&Flags(*self))
            .finish()
    }
}
///[VkPipelineMultisampleStateCreateFlags](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineMultisampleStateCreateFlags.html) - Reserved for future use
///# C Specifications
///```c
///// Provided by VK_VERSION_1_0
///typedef VkFlags VkPipelineMultisampleStateCreateFlags;
///```
///# Related
/// - [`crate::vulkan1_0`]
/// - [`PipelineMultisampleStateCreateInfo`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(transparent)]
pub struct PipelineMultisampleStateCreateFlags(u32);
impl const Default for PipelineMultisampleStateCreateFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl std::fmt::Debug for PipelineMultisampleStateCreateFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        f.debug_tuple(stringify!(PipelineMultisampleStateCreateFlags))
            .field(&self.0)
            .finish()
    }
}
///[VkPipelineRasterizationStateCreateFlags](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineRasterizationStateCreateFlags.html) - Reserved for future use
///# C Specifications
///```c
///// Provided by VK_VERSION_1_0
///typedef VkFlags VkPipelineRasterizationStateCreateFlags;
///```
///# Related
/// - [`crate::vulkan1_0`]
/// - [`PipelineRasterizationStateCreateInfo`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(transparent)]
pub struct PipelineRasterizationStateCreateFlags(u32);
impl const Default for PipelineRasterizationStateCreateFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl std::fmt::Debug for PipelineRasterizationStateCreateFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        f.debug_tuple(stringify!(PipelineRasterizationStateCreateFlags))
            .field(&self.0)
            .finish()
    }
}
///[VkPipelineViewportStateCreateFlags](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineViewportStateCreateFlags.html) - Reserved for future use
///# C Specifications
///```c
///// Provided by VK_VERSION_1_0
///typedef VkFlags VkPipelineViewportStateCreateFlags;
///```
///# Related
/// - [`crate::vulkan1_0`]
/// - [`PipelineViewportStateCreateInfo`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(transparent)]
pub struct PipelineViewportStateCreateFlags(u32);
impl const Default for PipelineViewportStateCreateFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl std::fmt::Debug for PipelineViewportStateCreateFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        f.debug_tuple(stringify!(PipelineViewportStateCreateFlags))
            .field(&self.0)
            .finish()
    }
}
///[VkPipelineTessellationStateCreateFlags](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineTessellationStateCreateFlags.html) - Reserved for future use
///# C Specifications
///```c
///// Provided by VK_VERSION_1_0
///typedef VkFlags VkPipelineTessellationStateCreateFlags;
///```
///# Related
/// - [`crate::vulkan1_0`]
/// - [`PipelineTessellationStateCreateInfo`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(transparent)]
pub struct PipelineTessellationStateCreateFlags(u32);
impl const Default for PipelineTessellationStateCreateFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl std::fmt::Debug for PipelineTessellationStateCreateFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        f.debug_tuple(stringify!(PipelineTessellationStateCreateFlags))
            .field(&self.0)
            .finish()
    }
}
///[VkPipelineInputAssemblyStateCreateFlags](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineInputAssemblyStateCreateFlags.html) - Reserved for future use
///# C Specifications
///```c
///// Provided by VK_VERSION_1_0
///typedef VkFlags VkPipelineInputAssemblyStateCreateFlags;
///```
///# Related
/// - [`crate::vulkan1_0`]
/// - [`PipelineInputAssemblyStateCreateInfo`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(transparent)]
pub struct PipelineInputAssemblyStateCreateFlags(u32);
impl const Default for PipelineInputAssemblyStateCreateFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl std::fmt::Debug for PipelineInputAssemblyStateCreateFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        f.debug_tuple(stringify!(PipelineInputAssemblyStateCreateFlags))
            .field(&self.0)
            .finish()
    }
}
///[VkPipelineVertexInputStateCreateFlags](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineVertexInputStateCreateFlags.html) - Reserved for future use
///# C Specifications
///```c
///// Provided by VK_VERSION_1_0
///typedef VkFlags VkPipelineVertexInputStateCreateFlags;
///```
///# Related
/// - [`crate::vulkan1_0`]
/// - [`PipelineVertexInputStateCreateInfo`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(transparent)]
pub struct PipelineVertexInputStateCreateFlags(u32);
impl const Default for PipelineVertexInputStateCreateFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl std::fmt::Debug for PipelineVertexInputStateCreateFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        f.debug_tuple(stringify!(PipelineVertexInputStateCreateFlags))
            .field(&self.0)
            .finish()
    }
}
///[VkPipelineShaderStageCreateFlagBits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineShaderStageCreateFlagBits.html) - Bitmask controlling how a pipeline shader stage is created
///# C Specifications
///Possible values of the `flags` member of
///[`PipelineShaderStageCreateInfo`] specifying how a pipeline shader stage
///is created, are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkPipelineShaderStageCreateFlagBits {
///  // Provided by VK_VERSION_1_3
///    VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT = 0x00000001,
///  // Provided by VK_VERSION_1_3
///    VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT = 0x00000002,
///  // Provided by VK_EXT_subgroup_size_control
///    VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT =
/// VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT,
///  // Provided by VK_EXT_subgroup_size_control
///    VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT =
/// VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT,
///} VkPipelineShaderStageCreateFlagBits;
///```
///# Description
/// - [`AllowVaryingSubgroupSize`] specifies that the [`SubgroupSize`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#interfaces-builtin-variables-sgs)
///   **may**  vary in the shader stage.
/// - [`RequireFullSubgroups`] specifies that the subgroup sizes  **must**  be launched with all
///   invocations active in the compute stage.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`PipelineShaderStageCreateFlags`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(transparent)]
pub struct PipelineShaderStageCreateFlags(u32);
impl const Default for PipelineShaderStageCreateFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl From<PipelineShaderStageCreateFlagBits> for PipelineShaderStageCreateFlags {
    fn from(from: PipelineShaderStageCreateFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(from as u32) }
    }
}
impl PipelineShaderStageCreateFlags {
    ///[`AllowVaryingSubgroupSize`]
    ///specifies that the
    ///[`SubgroupSize`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#interfaces-builtin-variables-sgs) **may**  vary in the
    ///shader stage.
    ///
    ///Provided by [`crate::vulkan1_3`]
    const AllowVaryingSubgroupSize: Self = Self(1);
    ///[`RequireFullSubgroups`]
    ///specifies that the subgroup sizes  **must**  be launched with all invocations
    ///active in the compute stage.
    ///
    ///Provided by [`crate::vulkan1_3`]
    const RequireFullSubgroups: Self = Self(2);
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::nv_extension_52`]
    const Reserved2Nv: Self = Self(4);
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_extension_297`]
    const Reserved3Khr: Self = Self(8);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    pub const fn all() -> Self {
        Self::empty()
            | Self::AllowVaryingSubgroupSize
            | Self::RequireFullSubgroups
            | Self::Reserved2Nv
            | Self::Reserved3Khr
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl const std::ops::BitOr for PipelineShaderStageCreateFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl std::ops::BitOrAssign for PipelineShaderStageCreateFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl const std::ops::BitXor for PipelineShaderStageCreateFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl std::ops::BitXorAssign for PipelineShaderStageCreateFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl const std::ops::BitAnd for PipelineShaderStageCreateFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl std::ops::BitAndAssign for PipelineShaderStageCreateFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl const std::ops::Sub for PipelineShaderStageCreateFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl std::ops::SubAssign for PipelineShaderStageCreateFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl const std::ops::Not for PipelineShaderStageCreateFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl std::iter::Extend<PipelineShaderStageCreateFlags> for PipelineShaderStageCreateFlags {
    fn extend<T: std::iter::IntoIterator<Item = PipelineShaderStageCreateFlags>>(&mut self, iterator: T) {
        for i in iterator {
            self.insert(i);
        }
    }
}
impl std::iter::Extend<PipelineShaderStageCreateFlagBits> for PipelineShaderStageCreateFlags {
    fn extend<T: std::iter::IntoIterator<Item = PipelineShaderStageCreateFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            self.insert(PipelineShaderStageCreateFlags::from(i));
        }
    }
}
impl std::iter::FromIterator<PipelineShaderStageCreateFlags> for PipelineShaderStageCreateFlags {
    fn from_iter<T: std::iter::IntoIterator<Item = PipelineShaderStageCreateFlags>>(
        iterator: T,
    ) -> PipelineShaderStageCreateFlags {
        let mut out = PipelineShaderStageCreateFlags::empty();
        out.extend(iterator);
        out
    }
}
impl std::iter::FromIterator<PipelineShaderStageCreateFlagBits> for PipelineShaderStageCreateFlags {
    fn from_iter<T: std::iter::IntoIterator<Item = PipelineShaderStageCreateFlagBits>>(
        iterator: T,
    ) -> PipelineShaderStageCreateFlags {
        let mut out = PipelineShaderStageCreateFlags::empty();
        out.extend(iterator);
        out
    }
}
impl std::fmt::Debug for PipelineShaderStageCreateFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(PipelineShaderStageCreateFlags);
        impl std::fmt::Debug for Flags {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == PipelineShaderStageCreateFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self
                        .0
                        .contains(PipelineShaderStageCreateFlags::AllowVaryingSubgroupSize)
                    {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(AllowVaryingSubgroupSize))?;
                    }
                    if self.0.contains(PipelineShaderStageCreateFlags::RequireFullSubgroups) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(RequireFullSubgroups))?;
                    }
                    if self.0.contains(PipelineShaderStageCreateFlags::Reserved2Nv) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(Reserved2Nv))?;
                    }
                    if self.0.contains(PipelineShaderStageCreateFlags::Reserved3Khr) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(Reserved3Khr))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(PipelineShaderStageCreateFlags))
            .field(&Flags(*self))
            .finish()
    }
}
///[VkDescriptorSetLayoutCreateFlagBits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorSetLayoutCreateFlagBits.html) - Bitmask specifying descriptor set layout properties
///# C Specifications
///Bits which  **can**  be set in
///[`DescriptorSetLayoutCreateInfo::flags`], specifying options for
///descriptor set layout, are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkDescriptorSetLayoutCreateFlagBits {
///  // Provided by VK_VERSION_1_2
///    VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT = 0x00000002,
///  // Provided by VK_KHR_push_descriptor
///    VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR = 0x00000001,
///  // Provided by VK_VALVE_mutable_descriptor_type
///    VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_VALVE = 0x00000004,
///  // Provided by VK_EXT_descriptor_indexing
///    VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT =
/// VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT,
///} VkDescriptorSetLayoutCreateFlagBits;
///```
///# Description
/// - [`PushDescriptorKhr`] specifies that descriptor sets  **must**  not be allocated using this
///   layout, and descriptors are instead pushed by [`CmdPushDescriptorSetKHR`].
/// - [`UpdateAfterBindPool`] specifies that descriptor sets using this layout  **must**  be
///   allocated from a descriptor pool created with the
///   `VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT` bit set. Descriptor set layouts created with
///   this bit set have alternate limits for the maximum number of descriptors per-stage and
///   per-pipeline layout. The non-UpdateAfterBind limits only count descriptors in sets created
///   without this flag. The UpdateAfterBind limits count all descriptors, but the limits  **may**
///   be higher than the non-UpdateAfterBind limits.
/// - [`HostOnlyPoolValve`] specifies that descriptor sets using this layout  **must**  be allocated
///   from a descriptor pool created with the `VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_VALVE` bit
///   set. Descriptor set layouts created with this bit have no expressable limit for maximum number
///   of descriptors per-stage. Host descriptor sets are limited only by available host memory, but
///   **may**  be limited for implementation specific reasons. Implementations  **may**  limit the
///   number of supported descriptors to UpdateAfterBind limits or non-UpdateAfterBind limits,
///   whichever is larger.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`DescriptorSetLayoutCreateFlags`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(transparent)]
pub struct DescriptorSetLayoutCreateFlags(u32);
impl const Default for DescriptorSetLayoutCreateFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl From<DescriptorSetLayoutCreateFlagBits> for DescriptorSetLayoutCreateFlags {
    fn from(from: DescriptorSetLayoutCreateFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(from as u32) }
    }
}
impl DescriptorSetLayoutCreateFlags {
    ///[`UpdateAfterBindPool`]
    ///specifies that descriptor sets using this layout  **must**  be allocated from
    ///a descriptor pool created with the
    ///`VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT` bit set.
    ///Descriptor set layouts created with this bit set have alternate limits
    ///for the maximum number of descriptors per-stage and per-pipeline layout.
    ///The non-UpdateAfterBind limits only count descriptors in sets created
    ///without this flag.
    ///The UpdateAfterBind limits count all descriptors, but the limits  **may**  be
    ///higher than the non-UpdateAfterBind limits.
    ///
    ///Provided by [`crate::vulkan1_2`]
    const UpdateAfterBindPool: Self = Self(2);
    ///[`PushDescriptorKhr`] specifies
    ///that descriptor sets  **must**  not be allocated using this layout, and
    ///descriptors are instead pushed by [`CmdPushDescriptorSetKHR`].
    ///
    ///Provided by [`crate::extensions::khr_push_descriptor`]
    const PushDescriptorKhr: Self = Self(1);
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::amd_extension_317`]
    const Reserved4Amd: Self = Self(16);
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::amd_extension_319`]
    const Reserved3Amd: Self = Self(8);
    ///[`HostOnlyPoolValve`] specifies
    ///that descriptor sets using this layout  **must**  be allocated from a
    ///descriptor pool created with the
    ///`VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_VALVE` bit set.
    ///Descriptor set layouts created with this bit have no expressable limit
    ///for maximum number of descriptors per-stage.
    ///Host descriptor sets are limited only by available host memory, but  **may**
    ///be limited for implementation specific reasons.
    ///Implementations  **may**  limit the number of supported descriptors to
    ///UpdateAfterBind limits or non-UpdateAfterBind limits, whichever is
    ///larger.
    ///
    ///Provided by [`crate::extensions::valve_mutable_descriptor_type`]
    const HostOnlyPoolValve: Self = Self(4);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    pub const fn all() -> Self {
        Self::empty()
            | Self::UpdateAfterBindPool
            | Self::PushDescriptorKhr
            | Self::Reserved4Amd
            | Self::Reserved3Amd
            | Self::HostOnlyPoolValve
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl const std::ops::BitOr for DescriptorSetLayoutCreateFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl std::ops::BitOrAssign for DescriptorSetLayoutCreateFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl const std::ops::BitXor for DescriptorSetLayoutCreateFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl std::ops::BitXorAssign for DescriptorSetLayoutCreateFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl const std::ops::BitAnd for DescriptorSetLayoutCreateFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl std::ops::BitAndAssign for DescriptorSetLayoutCreateFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl const std::ops::Sub for DescriptorSetLayoutCreateFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl std::ops::SubAssign for DescriptorSetLayoutCreateFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl const std::ops::Not for DescriptorSetLayoutCreateFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl std::iter::Extend<DescriptorSetLayoutCreateFlags> for DescriptorSetLayoutCreateFlags {
    fn extend<T: std::iter::IntoIterator<Item = DescriptorSetLayoutCreateFlags>>(&mut self, iterator: T) {
        for i in iterator {
            self.insert(i);
        }
    }
}
impl std::iter::Extend<DescriptorSetLayoutCreateFlagBits> for DescriptorSetLayoutCreateFlags {
    fn extend<T: std::iter::IntoIterator<Item = DescriptorSetLayoutCreateFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            self.insert(DescriptorSetLayoutCreateFlags::from(i));
        }
    }
}
impl std::iter::FromIterator<DescriptorSetLayoutCreateFlags> for DescriptorSetLayoutCreateFlags {
    fn from_iter<T: std::iter::IntoIterator<Item = DescriptorSetLayoutCreateFlags>>(
        iterator: T,
    ) -> DescriptorSetLayoutCreateFlags {
        let mut out = DescriptorSetLayoutCreateFlags::empty();
        out.extend(iterator);
        out
    }
}
impl std::iter::FromIterator<DescriptorSetLayoutCreateFlagBits> for DescriptorSetLayoutCreateFlags {
    fn from_iter<T: std::iter::IntoIterator<Item = DescriptorSetLayoutCreateFlagBits>>(
        iterator: T,
    ) -> DescriptorSetLayoutCreateFlags {
        let mut out = DescriptorSetLayoutCreateFlags::empty();
        out.extend(iterator);
        out
    }
}
impl std::fmt::Debug for DescriptorSetLayoutCreateFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(DescriptorSetLayoutCreateFlags);
        impl std::fmt::Debug for Flags {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == DescriptorSetLayoutCreateFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(DescriptorSetLayoutCreateFlags::UpdateAfterBindPool) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(UpdateAfterBindPool))?;
                    }
                    if self.0.contains(DescriptorSetLayoutCreateFlags::PushDescriptorKhr) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(PushDescriptorKhr))?;
                    }
                    if self.0.contains(DescriptorSetLayoutCreateFlags::Reserved4Amd) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(Reserved4Amd))?;
                    }
                    if self.0.contains(DescriptorSetLayoutCreateFlags::Reserved3Amd) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(Reserved3Amd))?;
                    }
                    if self.0.contains(DescriptorSetLayoutCreateFlags::HostOnlyPoolValve) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(HostOnlyPoolValve))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(DescriptorSetLayoutCreateFlags))
            .field(&Flags(*self))
            .finish()
    }
}
///[VkBufferViewCreateFlags](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferViewCreateFlags.html) - Reserved for future use
///# C Specifications
///```c
///// Provided by VK_VERSION_1_0
///typedef VkFlags VkBufferViewCreateFlags;
///```
///# Related
/// - [`crate::vulkan1_0`]
/// - [`BufferViewCreateInfo`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(transparent)]
pub struct BufferViewCreateFlags(u32);
impl const Default for BufferViewCreateFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl std::fmt::Debug for BufferViewCreateFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        f.debug_tuple(stringify!(BufferViewCreateFlags)).field(&self.0).finish()
    }
}
///[VkInstanceCreateFlags](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkInstanceCreateFlags.html) - Reserved for future use
///# C Specifications
///```c
///// Provided by VK_VERSION_1_0
///typedef VkFlags VkInstanceCreateFlags;
///```
///# Related
/// - [`crate::vulkan1_0`]
/// - [`InstanceCreateInfo`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(transparent)]
pub struct InstanceCreateFlags(u32);
impl const Default for InstanceCreateFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl std::fmt::Debug for InstanceCreateFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        f.debug_tuple(stringify!(InstanceCreateFlags)).field(&self.0).finish()
    }
}
///[VkDeviceCreateFlags](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceCreateFlags.html) - Reserved for future use
///# C Specifications
///```c
///// Provided by VK_VERSION_1_0
///typedef VkFlags VkDeviceCreateFlags;
///```
///# Related
/// - [`crate::vulkan1_0`]
/// - [`DeviceCreateInfo`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(transparent)]
pub struct DeviceCreateFlags(u32);
impl const Default for DeviceCreateFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl std::fmt::Debug for DeviceCreateFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        f.debug_tuple(stringify!(DeviceCreateFlags)).field(&self.0).finish()
    }
}
///[VkDeviceQueueCreateFlagBits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceQueueCreateFlagBits.html) - Bitmask specifying behavior of the queue
///# C Specifications
///Bits which  **can**  be set in [`DeviceQueueCreateInfo::flags`],
///specifying usage behavior of a queue, are:
///```c
///// Provided by VK_VERSION_1_1
///typedef enum VkDeviceQueueCreateFlagBits {
///  // Provided by VK_VERSION_1_1
///    VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT = 0x00000001,
///} VkDeviceQueueCreateFlagBits;
///```
///# Description
/// - [`Protected`] specifies that the device queue is a protected-capable queue.
///# Related
/// - [`crate::vulkan1_1`]
/// - [`DeviceQueueCreateFlags`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(transparent)]
pub struct DeviceQueueCreateFlags(u32);
impl const Default for DeviceQueueCreateFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl From<DeviceQueueCreateFlagBits> for DeviceQueueCreateFlags {
    fn from(from: DeviceQueueCreateFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(from as u32) }
    }
}
impl DeviceQueueCreateFlags {
    ///[`Protected`] specifies that the device
    ///queue is a protected-capable queue.
    ///
    ///Provided by [`crate::vulkan1_1`]
    const Protected: Self = Self(1);
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::qcom_extension_440`]
    const Reserved1Qcom: Self = Self(2);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    pub const fn all() -> Self {
        Self::empty() | Self::Protected | Self::Reserved1Qcom
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl const std::ops::BitOr for DeviceQueueCreateFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl std::ops::BitOrAssign for DeviceQueueCreateFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl const std::ops::BitXor for DeviceQueueCreateFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl std::ops::BitXorAssign for DeviceQueueCreateFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl const std::ops::BitAnd for DeviceQueueCreateFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl std::ops::BitAndAssign for DeviceQueueCreateFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl const std::ops::Sub for DeviceQueueCreateFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl std::ops::SubAssign for DeviceQueueCreateFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl const std::ops::Not for DeviceQueueCreateFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl std::iter::Extend<DeviceQueueCreateFlags> for DeviceQueueCreateFlags {
    fn extend<T: std::iter::IntoIterator<Item = DeviceQueueCreateFlags>>(&mut self, iterator: T) {
        for i in iterator {
            self.insert(i);
        }
    }
}
impl std::iter::Extend<DeviceQueueCreateFlagBits> for DeviceQueueCreateFlags {
    fn extend<T: std::iter::IntoIterator<Item = DeviceQueueCreateFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            self.insert(DeviceQueueCreateFlags::from(i));
        }
    }
}
impl std::iter::FromIterator<DeviceQueueCreateFlags> for DeviceQueueCreateFlags {
    fn from_iter<T: std::iter::IntoIterator<Item = DeviceQueueCreateFlags>>(iterator: T) -> DeviceQueueCreateFlags {
        let mut out = DeviceQueueCreateFlags::empty();
        out.extend(iterator);
        out
    }
}
impl std::iter::FromIterator<DeviceQueueCreateFlagBits> for DeviceQueueCreateFlags {
    fn from_iter<T: std::iter::IntoIterator<Item = DeviceQueueCreateFlagBits>>(iterator: T) -> DeviceQueueCreateFlags {
        let mut out = DeviceQueueCreateFlags::empty();
        out.extend(iterator);
        out
    }
}
impl std::fmt::Debug for DeviceQueueCreateFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(DeviceQueueCreateFlags);
        impl std::fmt::Debug for Flags {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == DeviceQueueCreateFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(DeviceQueueCreateFlags::Protected) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(Protected))?;
                    }
                    if self.0.contains(DeviceQueueCreateFlags::Reserved1Qcom) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(Reserved1Qcom))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(DeviceQueueCreateFlags))
            .field(&Flags(*self))
            .finish()
    }
}
///[VkQueueFlagBits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkQueueFlagBits.html) - Bitmask specifying capabilities of queues in a queue family
///# C Specifications
///Bits which  **may**  be set in [`QueueFamilyProperties::queue_flags`],
///indicating capabilities of queues in a queue family are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkQueueFlagBits {
///    VK_QUEUE_GRAPHICS_BIT = 0x00000001,
///    VK_QUEUE_COMPUTE_BIT = 0x00000002,
///    VK_QUEUE_TRANSFER_BIT = 0x00000004,
///    VK_QUEUE_SPARSE_BINDING_BIT = 0x00000008,
///  // Provided by VK_VERSION_1_1
///    VK_QUEUE_PROTECTED_BIT = 0x00000010,
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_KHR_video_decode_queue
///    VK_QUEUE_VIDEO_DECODE_BIT_KHR = 0x00000020,
///#endif
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_KHR_video_encode_queue
///    VK_QUEUE_VIDEO_ENCODE_BIT_KHR = 0x00000040,
///#endif
///} VkQueueFlagBits;
///```
///# Description
/// - [`QueueGraphics`] specifies that queues in this queue family support graphics operations.
/// - [`QueueCompute`] specifies that queues in this queue family support compute operations.
/// - [`QueueTransfer`] specifies that queues in this queue family support transfer operations.
/// - [`QueueSparseBinding`] specifies that queues in this queue family support sparse memory management operations (see [Sparse Resources](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#sparsememory)). If any of the sparse resource features are enabled, then at least one queue family  **must**  support this bit.
/// - [`VideoDecodeKhr`] specifies that queues in this queue family support Video Decode operations.
/// - [`VideoEncodeKhr`] specifies that queues in this queue family support Video Encode operations.
/// - [`Protected`] specifies that queues in this queue family support the `VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT` bit. (see [Protected Memory](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#memory-protected-memory)). If the physical device supports the `protectedMemory` feature, at least one of its queue families  **must**  support this bit.
///If an implementation exposes any queue family that supports graphics
///operations, at least one queue family of at least one physical device
///exposed by the implementation  **must**  support both graphics and compute
///operations.Furthermore, if the protected memory physical device feature is supported,
///then at least one queue family of at least one physical device exposed by
///the implementation  **must**  support graphics operations, compute operations,
///and protected memory operations.For further details see [Queues](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#devsandqueues-queues).
///# Related
/// - [`crate::vulkan1_0`]
/// - [`QueueFlags`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(transparent)]
pub struct QueueFlags(u32);
impl const Default for QueueFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl From<QueueFlagBits> for QueueFlags {
    fn from(from: QueueFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(from as u32) }
    }
}
impl QueueFlags {
    ///[`QueueGraphics`] specifies that queues in this queue family
    ///support graphics operations.
    const QueueGraphics: Self = Self(1);
    ///[`QueueCompute`] specifies that queues in this queue family
    ///support compute operations.
    const QueueCompute: Self = Self(2);
    ///[`QueueTransfer`] specifies that queues in this queue family
    ///support transfer operations.
    const QueueTransfer: Self = Self(4);
    ///[`QueueSparseBinding`] specifies that queues in this queue
    ///family support sparse memory management operations (see
    ///[Sparse Resources](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#sparsememory)).
    ///If any of the sparse resource features are enabled, then at least one
    ///queue family  **must**  support this bit.
    const QueueSparseBinding: Self = Self(8);
    ///[`Protected`] specifies that queues in this queue family
    ///support the `VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT` bit.
    ///(see [Protected Memory](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#memory-protected-memory)).
    ///If the physical device supports the `protectedMemory` feature, at
    ///least one of its queue families  **must**  support this bit.
    ///
    ///Provided by [`crate::vulkan1_1`]
    const Protected: Self = Self(16);
    ///[`VideoDecodeKhr`] specifies that queues in this queue
    ///family support Video Decode operations.
    ///
    ///Provided by [`crate::extensions::khr_video_decode_queue`]
    const VideoDecodeKhr: Self = Self(32);
    ///[`VideoEncodeKhr`] specifies that queues in this queue
    ///family support Video Encode operations.
    ///
    ///Provided by [`crate::extensions::khr_video_encode_queue`]
    const VideoEncodeKhr: Self = Self(64);
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::qcom_extension_440`]
    const Reserved7Qcom: Self = Self(128);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    pub const fn all() -> Self {
        Self::empty()
            | Self::QueueGraphics
            | Self::QueueCompute
            | Self::QueueTransfer
            | Self::QueueSparseBinding
            | Self::Protected
            | Self::VideoDecodeKhr
            | Self::VideoEncodeKhr
            | Self::Reserved7Qcom
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl const std::ops::BitOr for QueueFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl std::ops::BitOrAssign for QueueFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl const std::ops::BitXor for QueueFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl std::ops::BitXorAssign for QueueFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl const std::ops::BitAnd for QueueFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl std::ops::BitAndAssign for QueueFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl const std::ops::Sub for QueueFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl std::ops::SubAssign for QueueFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl const std::ops::Not for QueueFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl std::iter::Extend<QueueFlags> for QueueFlags {
    fn extend<T: std::iter::IntoIterator<Item = QueueFlags>>(&mut self, iterator: T) {
        for i in iterator {
            self.insert(i);
        }
    }
}
impl std::iter::Extend<QueueFlagBits> for QueueFlags {
    fn extend<T: std::iter::IntoIterator<Item = QueueFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            self.insert(QueueFlags::from(i));
        }
    }
}
impl std::iter::FromIterator<QueueFlags> for QueueFlags {
    fn from_iter<T: std::iter::IntoIterator<Item = QueueFlags>>(iterator: T) -> QueueFlags {
        let mut out = QueueFlags::empty();
        out.extend(iterator);
        out
    }
}
impl std::iter::FromIterator<QueueFlagBits> for QueueFlags {
    fn from_iter<T: std::iter::IntoIterator<Item = QueueFlagBits>>(iterator: T) -> QueueFlags {
        let mut out = QueueFlags::empty();
        out.extend(iterator);
        out
    }
}
impl std::fmt::Debug for QueueFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(QueueFlags);
        impl std::fmt::Debug for Flags {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == QueueFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(QueueFlags::QueueGraphics) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(QueueGraphics))?;
                    }
                    if self.0.contains(QueueFlags::QueueCompute) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(QueueCompute))?;
                    }
                    if self.0.contains(QueueFlags::QueueTransfer) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(QueueTransfer))?;
                    }
                    if self.0.contains(QueueFlags::QueueSparseBinding) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(QueueSparseBinding))?;
                    }
                    if self.0.contains(QueueFlags::Protected) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(Protected))?;
                    }
                    if self.0.contains(QueueFlags::VideoDecodeKhr) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(VideoDecodeKhr))?;
                    }
                    if self.0.contains(QueueFlags::VideoEncodeKhr) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(VideoEncodeKhr))?;
                    }
                    if self.0.contains(QueueFlags::Reserved7Qcom) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(Reserved7Qcom))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(QueueFlags)).field(&Flags(*self)).finish()
    }
}
///[VkMemoryPropertyFlagBits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryPropertyFlagBits.html) - Bitmask specifying properties for a memory type
///# C Specifications
///Bits which  **may**  be set in [`MemoryType::property_flags`],
///indicating properties of a memory heap, are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkMemoryPropertyFlagBits {
///    VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT = 0x00000001,
///    VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT = 0x00000002,
///    VK_MEMORY_PROPERTY_HOST_COHERENT_BIT = 0x00000004,
///    VK_MEMORY_PROPERTY_HOST_CACHED_BIT = 0x00000008,
///    VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT = 0x00000010,
///  // Provided by VK_VERSION_1_1
///    VK_MEMORY_PROPERTY_PROTECTED_BIT = 0x00000020,
///  // Provided by VK_AMD_device_coherent_memory
///    VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD = 0x00000040,
///  // Provided by VK_AMD_device_coherent_memory
///    VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD = 0x00000080,
///  // Provided by VK_NV_external_memory_rdma
///    VK_MEMORY_PROPERTY_RDMA_CAPABLE_BIT_NV = 0x00000100,
///} VkMemoryPropertyFlagBits;
///```
///# Description
/// - [`MemoryPropertyDeviceLocal`] bit specifies that memory allocated with this type is the most
///   efficient for device access. This property will be set if and only if the memory type belongs
///   to a heap with the `VK_MEMORY_HEAP_DEVICE_LOCAL_BIT` set.
/// - [`MemoryPropertyHostVisible`] bit specifies that memory allocated with this type  **can**  be
///   mapped for host access using [`MapMemory`].
/// - [`MemoryPropertyHostCoherent`] bit specifies that the host cache management commands
///   [`FlushMappedMemoryRanges`] and [`InvalidateMappedMemoryRanges`] are not needed to flush host
///   writes to the device or make device writes visible to the host, respectively.
/// - [`MemoryPropertyHostCached`] bit specifies that memory allocated with this type is cached on
///   the host. Host memory accesses to uncached memory are slower than to cached memory, however
///   uncached memory is always host coherent.
/// - [`MemoryPropertyLazilyAllocated`] bit specifies that the memory type only allows device access
///   to the memory. Memory types  **must**  not have both [`MemoryPropertyLazilyAllocated`] and [`MemoryPropertyHostVisible`]
///   set. Additionally, the object’s backing memory  **may**  be provided by the implementation lazily
///   as specified in [Lazily Allocated Memory](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#memory-device-lazy_allocation).
/// - [`Protected`] bit specifies that the memory type only allows device access to the memory, and
///   allows protected queue operations to access the memory. Memory types  **must**  not have
///   [`Protected`] set and any of [`MemoryPropertyHostVisible`] set, or
///   [`MemoryPropertyHostCoherent`] set, or [`MemoryPropertyHostCached`] set.
/// - [`DeviceCoherentAmd`] bit specifies that device accesses to allocations of this memory type
///   are automatically made available and visible.
/// - [`DeviceUncachedAmd`] bit specifies that memory allocated with this type is not cached on the
///   device. Uncached device memory is always device coherent.
/// - [`RdmaCapableNv`] bit specifies that external devices can access this memory directly.
///For any memory allocated with both the
///[`MemoryPropertyHostCoherent`] and the
///[`DeviceCoherentAmd`], host or device accesses
///also perform automatic memory domain transfer operations, such that writes
///are always automatically available and visible to both host and device
///memory domains.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`MemoryPropertyFlags`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(transparent)]
pub struct MemoryPropertyFlags(u32);
impl const Default for MemoryPropertyFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl From<MemoryPropertyFlagBits> for MemoryPropertyFlags {
    fn from(from: MemoryPropertyFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(from as u32) }
    }
}
impl MemoryPropertyFlags {
    ///[`MemoryPropertyDeviceLocal`] bit specifies that memory
    ///allocated with this type is the most efficient for device access.
    ///This property will be set if and only if the memory type belongs to a
    ///heap with the `VK_MEMORY_HEAP_DEVICE_LOCAL_BIT` set.
    const MemoryPropertyDeviceLocal: Self = Self(1);
    ///[`MemoryPropertyHostVisible`] bit specifies that memory
    ///allocated with this type  **can**  be mapped for host access using
    ///[`MapMemory`].
    const MemoryPropertyHostVisible: Self = Self(2);
    ///[`MemoryPropertyHostCoherent`] bit specifies that the host
    ///cache management commands [`FlushMappedMemoryRanges`] and
    ///[`InvalidateMappedMemoryRanges`] are not needed to flush host writes
    ///to the device or make device writes visible to the host, respectively.
    const MemoryPropertyHostCoherent: Self = Self(4);
    ///[`MemoryPropertyHostCached`] bit specifies that memory
    ///allocated with this type is cached on the host.
    ///Host memory accesses to uncached memory are slower than to cached
    ///memory, however uncached memory is always host coherent.
    const MemoryPropertyHostCached: Self = Self(8);
    ///[`MemoryPropertyLazilyAllocated`] bit specifies that the
    ///memory type only allows device access to the memory.
    ///Memory types  **must**  not have both
    ///[`MemoryPropertyLazilyAllocated`] and
    ///[`MemoryPropertyHostVisible`] set.
    ///Additionally, the object’s backing memory  **may**  be provided by the
    ///implementation lazily as specified in [Lazily Allocated Memory](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#memory-device-lazy_allocation).
    const MemoryPropertyLazilyAllocated: Self = Self(16);
    ///[`Protected`] bit specifies that the memory
    ///type only allows device access to the memory, and allows protected queue
    ///operations to access the memory.
    ///Memory types  **must**  not have [`Protected`] set
    ///and any of [`MemoryPropertyHostVisible`] set, or
    ///[`MemoryPropertyHostCoherent`] set, or
    ///[`MemoryPropertyHostCached`] set.
    ///
    ///Provided by [`crate::vulkan1_1`]
    const Protected: Self = Self(32);
    ///[`DeviceCoherentAmd`] bit specifies that
    ///device accesses to allocations of this memory type are automatically
    ///made available and visible.
    ///
    ///Provided by [`crate::extensions::amd_device_coherent_memory`]
    const DeviceCoherentAmd: Self = Self(64);
    ///[`DeviceUncachedAmd`] bit specifies that
    ///memory allocated with this type is not cached on the device.
    ///Uncached device memory is always device coherent.
    ///
    ///Provided by [`crate::extensions::amd_device_coherent_memory`]
    const DeviceUncachedAmd: Self = Self(128);
    ///[`RdmaCapableNv`] bit specifies that external
    ///devices can access this memory directly.
    ///
    ///Provided by [`crate::extensions::nv_external_memory_rdma`]
    const RdmaCapableNv: Self = Self(256);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    pub const fn all() -> Self {
        Self::empty()
            | Self::MemoryPropertyDeviceLocal
            | Self::MemoryPropertyHostVisible
            | Self::MemoryPropertyHostCoherent
            | Self::MemoryPropertyHostCached
            | Self::MemoryPropertyLazilyAllocated
            | Self::Protected
            | Self::DeviceCoherentAmd
            | Self::DeviceUncachedAmd
            | Self::RdmaCapableNv
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl const std::ops::BitOr for MemoryPropertyFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl std::ops::BitOrAssign for MemoryPropertyFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl const std::ops::BitXor for MemoryPropertyFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl std::ops::BitXorAssign for MemoryPropertyFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl const std::ops::BitAnd for MemoryPropertyFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl std::ops::BitAndAssign for MemoryPropertyFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl const std::ops::Sub for MemoryPropertyFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl std::ops::SubAssign for MemoryPropertyFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl const std::ops::Not for MemoryPropertyFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl std::iter::Extend<MemoryPropertyFlags> for MemoryPropertyFlags {
    fn extend<T: std::iter::IntoIterator<Item = MemoryPropertyFlags>>(&mut self, iterator: T) {
        for i in iterator {
            self.insert(i);
        }
    }
}
impl std::iter::Extend<MemoryPropertyFlagBits> for MemoryPropertyFlags {
    fn extend<T: std::iter::IntoIterator<Item = MemoryPropertyFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            self.insert(MemoryPropertyFlags::from(i));
        }
    }
}
impl std::iter::FromIterator<MemoryPropertyFlags> for MemoryPropertyFlags {
    fn from_iter<T: std::iter::IntoIterator<Item = MemoryPropertyFlags>>(iterator: T) -> MemoryPropertyFlags {
        let mut out = MemoryPropertyFlags::empty();
        out.extend(iterator);
        out
    }
}
impl std::iter::FromIterator<MemoryPropertyFlagBits> for MemoryPropertyFlags {
    fn from_iter<T: std::iter::IntoIterator<Item = MemoryPropertyFlagBits>>(iterator: T) -> MemoryPropertyFlags {
        let mut out = MemoryPropertyFlags::empty();
        out.extend(iterator);
        out
    }
}
impl std::fmt::Debug for MemoryPropertyFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(MemoryPropertyFlags);
        impl std::fmt::Debug for Flags {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == MemoryPropertyFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(MemoryPropertyFlags::MemoryPropertyDeviceLocal) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(MemoryPropertyDeviceLocal))?;
                    }
                    if self.0.contains(MemoryPropertyFlags::MemoryPropertyHostVisible) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(MemoryPropertyHostVisible))?;
                    }
                    if self.0.contains(MemoryPropertyFlags::MemoryPropertyHostCoherent) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(MemoryPropertyHostCoherent))?;
                    }
                    if self.0.contains(MemoryPropertyFlags::MemoryPropertyHostCached) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(MemoryPropertyHostCached))?;
                    }
                    if self.0.contains(MemoryPropertyFlags::MemoryPropertyLazilyAllocated) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(MemoryPropertyLazilyAllocated))?;
                    }
                    if self.0.contains(MemoryPropertyFlags::Protected) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(Protected))?;
                    }
                    if self.0.contains(MemoryPropertyFlags::DeviceCoherentAmd) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(DeviceCoherentAmd))?;
                    }
                    if self.0.contains(MemoryPropertyFlags::DeviceUncachedAmd) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(DeviceUncachedAmd))?;
                    }
                    if self.0.contains(MemoryPropertyFlags::RdmaCapableNv) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(RdmaCapableNv))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(MemoryPropertyFlags))
            .field(&Flags(*self))
            .finish()
    }
}
///[VkMemoryHeapFlagBits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryHeapFlagBits.html) - Bitmask specifying attribute flags for a heap
///# C Specifications
///Bits which  **may**  be set in [`MemoryHeap::flags`], indicating
///attribute flags for the heap, are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkMemoryHeapFlagBits {
///    VK_MEMORY_HEAP_DEVICE_LOCAL_BIT = 0x00000001,
///  // Provided by VK_VERSION_1_1
///    VK_MEMORY_HEAP_MULTI_INSTANCE_BIT = 0x00000002,
///  // Provided by VK_KHR_device_group_creation
///    VK_MEMORY_HEAP_MULTI_INSTANCE_BIT_KHR = VK_MEMORY_HEAP_MULTI_INSTANCE_BIT,
///} VkMemoryHeapFlagBits;
///```
///# Description
/// - [`MemoryHeapDeviceLocal`] specifies that the heap corresponds to device-local memory.
///   Device-local memory  **may**  have different performance characteristics than host-local
///   memory, and  **may**  support different memory property flags.
/// - [`MultiInstance`] specifies that in a logical device representing more than one physical
///   device, there is a per-physical device instance of the heap memory. By default, an allocation
///   from such a heap will be replicated to each physical device’s instance of the heap.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`MemoryHeapFlags`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(transparent)]
pub struct MemoryHeapFlags(u32);
impl const Default for MemoryHeapFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl From<MemoryHeapFlagBits> for MemoryHeapFlags {
    fn from(from: MemoryHeapFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(from as u32) }
    }
}
impl MemoryHeapFlags {
    ///[`MemoryHeapDeviceLocal`] specifies that the heap
    ///corresponds to device-local memory.
    ///Device-local memory  **may**  have different performance characteristics than
    ///host-local memory, and  **may**  support different memory property flags.
    const MemoryHeapDeviceLocal: Self = Self(1);
    ///[`MultiInstance`] specifies that in a logical
    ///device representing more than one physical device, there is a
    ///per-physical device instance of the heap memory.
    ///By default, an allocation from such a heap will be replicated to each
    ///physical device’s instance of the heap.
    ///
    ///Provided by [`crate::vulkan1_1`]
    const MultiInstance: Self = Self(2);
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_extension_299`]
    const Reserved2Khr: Self = Self(4);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    pub const fn all() -> Self {
        Self::empty() | Self::MemoryHeapDeviceLocal | Self::MultiInstance | Self::Reserved2Khr
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl const std::ops::BitOr for MemoryHeapFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl std::ops::BitOrAssign for MemoryHeapFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl const std::ops::BitXor for MemoryHeapFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl std::ops::BitXorAssign for MemoryHeapFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl const std::ops::BitAnd for MemoryHeapFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl std::ops::BitAndAssign for MemoryHeapFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl const std::ops::Sub for MemoryHeapFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl std::ops::SubAssign for MemoryHeapFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl const std::ops::Not for MemoryHeapFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl std::iter::Extend<MemoryHeapFlags> for MemoryHeapFlags {
    fn extend<T: std::iter::IntoIterator<Item = MemoryHeapFlags>>(&mut self, iterator: T) {
        for i in iterator {
            self.insert(i);
        }
    }
}
impl std::iter::Extend<MemoryHeapFlagBits> for MemoryHeapFlags {
    fn extend<T: std::iter::IntoIterator<Item = MemoryHeapFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            self.insert(MemoryHeapFlags::from(i));
        }
    }
}
impl std::iter::FromIterator<MemoryHeapFlags> for MemoryHeapFlags {
    fn from_iter<T: std::iter::IntoIterator<Item = MemoryHeapFlags>>(iterator: T) -> MemoryHeapFlags {
        let mut out = MemoryHeapFlags::empty();
        out.extend(iterator);
        out
    }
}
impl std::iter::FromIterator<MemoryHeapFlagBits> for MemoryHeapFlags {
    fn from_iter<T: std::iter::IntoIterator<Item = MemoryHeapFlagBits>>(iterator: T) -> MemoryHeapFlags {
        let mut out = MemoryHeapFlags::empty();
        out.extend(iterator);
        out
    }
}
impl std::fmt::Debug for MemoryHeapFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(MemoryHeapFlags);
        impl std::fmt::Debug for Flags {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == MemoryHeapFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(MemoryHeapFlags::MemoryHeapDeviceLocal) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(MemoryHeapDeviceLocal))?;
                    }
                    if self.0.contains(MemoryHeapFlags::MultiInstance) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(MultiInstance))?;
                    }
                    if self.0.contains(MemoryHeapFlags::Reserved2Khr) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(Reserved2Khr))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(MemoryHeapFlags)).field(&Flags(*self)).finish()
    }
}
///[VkAccessFlagBits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAccessFlagBits.html) - Bitmask specifying memory access types that will participate in a memory dependency
///# C Specifications
///Bits which  **can**  be set in the `srcAccessMask` and `dstAccessMask`
///members of [`SubpassDependency`],
///[`SubpassDependency2`],
///[`MemoryBarrier`], [`BufferMemoryBarrier`], and
///[`ImageMemoryBarrier`], specifying access behavior, are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkAccessFlagBits {
///    VK_ACCESS_INDIRECT_COMMAND_READ_BIT = 0x00000001,
///    VK_ACCESS_INDEX_READ_BIT = 0x00000002,
///    VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT = 0x00000004,
///    VK_ACCESS_UNIFORM_READ_BIT = 0x00000008,
///    VK_ACCESS_INPUT_ATTACHMENT_READ_BIT = 0x00000010,
///    VK_ACCESS_SHADER_READ_BIT = 0x00000020,
///    VK_ACCESS_SHADER_WRITE_BIT = 0x00000040,
///    VK_ACCESS_COLOR_ATTACHMENT_READ_BIT = 0x00000080,
///    VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT = 0x00000100,
///    VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT = 0x00000200,
///    VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT = 0x00000400,
///    VK_ACCESS_TRANSFER_READ_BIT = 0x00000800,
///    VK_ACCESS_TRANSFER_WRITE_BIT = 0x00001000,
///    VK_ACCESS_HOST_READ_BIT = 0x00002000,
///    VK_ACCESS_HOST_WRITE_BIT = 0x00004000,
///    VK_ACCESS_MEMORY_READ_BIT = 0x00008000,
///    VK_ACCESS_MEMORY_WRITE_BIT = 0x00010000,
///  // Provided by VK_VERSION_1_3
///    VK_ACCESS_NONE = 0,
///  // Provided by VK_EXT_transform_feedback
///    VK_ACCESS_TRANSFORM_FEEDBACK_WRITE_BIT_EXT = 0x02000000,
///  // Provided by VK_EXT_transform_feedback
///    VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT = 0x04000000,
///  // Provided by VK_EXT_transform_feedback
///    VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT = 0x08000000,
///  // Provided by VK_EXT_conditional_rendering
///    VK_ACCESS_CONDITIONAL_RENDERING_READ_BIT_EXT = 0x00100000,
///  // Provided by VK_EXT_blend_operation_advanced
///    VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT = 0x00080000,
///  // Provided by VK_KHR_acceleration_structure
///    VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR = 0x00200000,
///  // Provided by VK_KHR_acceleration_structure
///    VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR = 0x00400000,
///  // Provided by VK_EXT_fragment_density_map
///    VK_ACCESS_FRAGMENT_DENSITY_MAP_READ_BIT_EXT = 0x01000000,
///  // Provided by VK_KHR_fragment_shading_rate
///    VK_ACCESS_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR = 0x00800000,
///  // Provided by VK_NV_device_generated_commands
///    VK_ACCESS_COMMAND_PREPROCESS_READ_BIT_NV = 0x00020000,
///  // Provided by VK_NV_device_generated_commands
///    VK_ACCESS_COMMAND_PREPROCESS_WRITE_BIT_NV = 0x00040000,
///  // Provided by VK_NV_shading_rate_image
///    VK_ACCESS_SHADING_RATE_IMAGE_READ_BIT_NV =
/// VK_ACCESS_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR,
///  // Provided by VK_NV_ray_tracing
///    VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_NV = VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR,
///  // Provided by VK_NV_ray_tracing
///    VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_NV =
/// VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR,
///  // Provided by VK_KHR_synchronization2
///    VK_ACCESS_NONE_KHR = VK_ACCESS_NONE,
///} VkAccessFlagBits;
///```
///# Description
///These values all have the same meaning as the equivalently named values for
///[`AccessFlags2`].
/// - [`None`] specifies no accesses.
/// - [`AccessMemoryRead`] specifies all read accesses. It is always valid in any access mask, and
///   is treated as equivalent to setting all `READ` access flags that are valid where it is used.
/// - [`AccessMemoryWrite`] specifies all write accesses. It is always valid in any access mask, and
///   is treated as equivalent to setting all `WRITE` access flags that are valid where it is used.
/// - [`AccessIndirectCommandRead`] specifies read access to     indirect command data read as part
///   of an indirect build, trace,     drawing or dispatching command.     Such access occurs in the
///   `VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT`     pipeline stage.
/// - [`AccessIndexRead`] specifies read access to an index buffer as part of an indexed drawing
///   command, bound by [`CmdBindIndexBuffer`]. Such access occurs in the
///   `VK_PIPELINE_STAGE_VERTEX_INPUT_BIT` pipeline stage.
/// - [`AccessVertexAttributeRead`] specifies read access to a vertex buffer as part of a drawing
///   command, bound by [`CmdBindVertexBuffers`]. Such access occurs in the
///   `VK_PIPELINE_STAGE_VERTEX_INPUT_BIT` pipeline stage.
/// - [`AccessUniformRead`] specifies read access to a [uniform buffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-uniformbuffer)
///   in any shader pipeline stage.
/// - [`AccessInputAttachmentRead`] specifies read access to an [input attachment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass)
///   within a render pass during subpass shading or fragment shading. Such access occurs in the
///   `VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI` or `VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT`
///   pipeline stage.
/// - [`AccessShaderRead`] specifies read access to a [uniform buffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-uniformbuffer),
///   [uniform texel buffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-uniformtexelbuffer),
///   [sampled image](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-sampledimage),
///   [storage buffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storagebuffer),
///   [physical storage buffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-physical-storage-buffer),
///   [shader binding table](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#shader-binding-table),
///   [storage texel buffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storagetexelbuffer),
///   or [storage image](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storageimage)
///   in any shader pipeline stage.
/// - [`AccessShaderWrite`] specifies write access to a [storage buffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storagebuffer),
///   [physical storage buffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-physical-storage-buffer),
///   [storage texel buffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storagetexelbuffer),
///   or [storage image](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storageimage)
///   in any shader pipeline stage.
/// - [`AccessColorAttachmentRead`] specifies read access to a [color attachment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass),
///   such as via [blending](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#framebuffer-blending),
///   [logic operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#framebuffer-logicop),
///   or via certain [subpass load operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-load-store-ops).
///   It does not include [advanced blend operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#framebuffer-blend-advanced).
///   Such access occurs in the `VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT` pipeline stage.
/// - [`AccessColorAttachmentWrite`] specifies write access to a [color, resolve, or depth/stencil resolve attachment](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#renderpass) during a [render pass](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass) or via certain [subpass load and store operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-load-store-ops). Such access occurs in the `VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT` pipeline stage.
/// - [`AccessDepthStencilAttachmentRead`] specifies read access to a [depth/stencil attachment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass),
///   via [depth or stencil operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fragops-ds-state)
///   or via certain [subpass load operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-load-store-ops).
///   Such access occurs in the `VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT` or
///   `VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT` pipeline stages.
/// - [`AccessDepthStencilAttachmentWrite`] specifies write access to a [depth/stencil attachment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass),
///   via [depth or stencil operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fragops-ds-state)
///   or via certain [subpass load and store operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-load-store-ops).
///   Such access occurs in the `VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT` or
///   `VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT` pipeline stages.
/// - [`AccessTransferRead`] specifies read access to an image or buffer in a [copy](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#copies)
///   operation. Such access occurs in the `VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT` pipeline stage.
/// - [`AccessTransferWrite`] specifies write access to an image or buffer in a [clear](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#clears)
///   or [copy](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#copies)
///   operation. Such access occurs in the `VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT` pipeline stage.
/// - [`AccessHostRead`] specifies read access by a host operation. Accesses of this type are not
///   performed through a resource, but directly on memory. Such access occurs in the
///   `VK_PIPELINE_STAGE_HOST_BIT` pipeline stage.
/// - [`AccessHostWrite`] specifies write access by a host operation. Accesses of this type are not
///   performed through a resource, but directly on memory. Such access occurs in the
///   `VK_PIPELINE_STAGE_HOST_BIT` pipeline stage.
/// - [`ConditionalRenderingReadExt`] specifies read access to a predicate as part of conditional
///   rendering. Such access occurs in the `VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT`
///   pipeline stage.
/// - [`TransformFeedbackWriteExt`] specifies write access to a transform feedback buffer made when
///   transform feedback is active. Such access occurs in the
///   `VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT` pipeline stage.
/// - [`TransformFeedbackCounterReadExt`] specifies read access to a transform feedback counter
///   buffer which is read when [`CmdBeginTransformFeedbackEXT`] executes. Such access occurs in the
///   `VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT` pipeline stage.
/// - [`TransformFeedbackCounterWriteExt`] specifies write access to a transform feedback counter
///   buffer which is written when [`CmdEndTransformFeedbackEXT`] executes. Such access occurs in
///   the `VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT` pipeline stage.
/// - [`CommandPreprocessReadNv`] specifies reads from buffer inputs to
///   [`CmdPreprocessGeneratedCommandsNV`]. Such access occurs in the
///   `VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_NV` pipeline stage.
/// - [`CommandPreprocessWriteNv`] specifies writes to the target command buffer:VkBuffer preprocess
///   outputs in [`CmdPreprocessGeneratedCommandsNV`]. Such access occurs in the
///   `VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_NV` pipeline stage.
/// - [`ColorAttachmentReadNoncoherentExt`] specifies read access to [color attachments](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass),
///   including [advanced blend operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#framebuffer-blend-advanced).
///   Such access occurs in the `VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT` pipeline stage.
/// - `VK_ACCESS_2_INVOCATION_MASK_READ_BIT_HUAWEI` specifies read access to a invocation mask image
///   in the `VK_PIPELINE_STAGE_2_INVOCATION_MASK_BIT_HUAWEI` pipeline stage.
/// - [`AccelerationStructureReadKhr`] specifies read access to an acceleration structure as part of
///   a trace, build, or copy command, or to an [acceleration structure scratch buffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#acceleration-structure-scratch)
///   as part of a build command. Such access occurs in the
///   `VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_KHR` pipeline stage or
///   `VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR` pipeline stage.
/// - [`AccelerationStructureWriteKhr`] specifies write access to an acceleration structure or [acceleration structure scratch buffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#acceleration-structure-scratch) as part of a build or copy command. Such access occurs in the `VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR` pipeline stage.
/// - [`FragmentDensityMapReadExt`] specifies read access to a [fragment density map attachment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-fragmentdensitymapattachment)
///   during dynamic [fragment density map operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fragmentdensitymapops)
///   Such access occurs in the `VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT` pipeline stage.
/// - [`FragmentShadingRateAttachmentReadKhr`] specifies read access to a fragment shading rate
///   attachment during rasterization. Such access occurs in the
///   `VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR` pipeline stage.
/// - [`ShadingRateImageReadNv`] specifies read access to a shading rate image during rasterization.
///   Such access occurs in the `VK_PIPELINE_STAGE_SHADING_RATE_IMAGE_BIT_NV` pipeline stage. It is
///   equivalent to `VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR`.
///Certain access types are only performed by a subset of pipeline stages.
///Any synchronization command that takes both stage masks and access masks
///uses both to define the [access
///scopes](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-dependencies-access-scopes) - only the specified access types performed by the specified stages
///are included in the access scope.
///An application  **must**  not specify an access flag in a synchronization command
///if it does not include a pipeline stage in the corresponding stage mask that
///is able to perform accesses of that type.
///The following table lists, for each access flag, which pipeline stages  **can**
///perform that type of access.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`AccessFlags`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(transparent)]
pub struct AccessFlags(u32);
impl const Default for AccessFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl From<AccessFlagBits> for AccessFlags {
    fn from(from: AccessFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(from as u32) }
    }
}
impl AccessFlags {
    ///[`AccessIndirectCommandRead`] specifies read access to
    ///    indirect command data read as part of an indirect
    ///build,
    ///trace,
    ///    drawing or dispatching command.
    ///    Such access occurs in the `VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT`
    ///    pipeline stage.
    const AccessIndirectCommandRead: Self = Self(1);
    ///[`AccessIndexRead`] specifies read access to an index buffer
    ///as part of an indexed drawing command, bound by
    ///[`CmdBindIndexBuffer`].
    ///Such access occurs in the `VK_PIPELINE_STAGE_VERTEX_INPUT_BIT`
    ///pipeline stage.
    const AccessIndexRead: Self = Self(2);
    ///[`AccessVertexAttributeRead`] specifies read access to a
    ///vertex buffer as part of a drawing command, bound by
    ///[`CmdBindVertexBuffers`].
    ///Such access occurs in the `VK_PIPELINE_STAGE_VERTEX_INPUT_BIT`
    ///pipeline stage.
    const AccessVertexAttributeRead: Self = Self(4);
    ///[`AccessUniformRead`] specifies read access to a
    ///[uniform buffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-uniformbuffer) in any shader pipeline
    ///stage.
    const AccessUniformRead: Self = Self(8);
    ///[`AccessInputAttachmentRead`] specifies read access to an
    ///[input attachment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass) within a render pass during
    ///subpass shading or
    ///fragment shading.
    ///Such access occurs in the
    ///`VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI` or
    ///`VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT` pipeline stage.
    const AccessInputAttachmentRead: Self = Self(16);
    ///[`AccessShaderRead`] specifies read access to a
    ///[uniform buffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-uniformbuffer),
    ///[uniform texel buffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-uniformtexelbuffer),
    ///[sampled image](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-sampledimage),
    ///[storage buffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storagebuffer),
    ///[physical storage buffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-physical-storage-buffer),
    ///[shader binding table](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#shader-binding-table),
    ///[storage texel buffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storagetexelbuffer), or
    ///[storage image](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storageimage) in any shader pipeline
    ///stage.
    const AccessShaderRead: Self = Self(32);
    ///[`AccessShaderWrite`] specifies write access to a
    ///[storage buffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storagebuffer),
    ///[physical storage buffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-physical-storage-buffer),
    ///[storage texel buffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storagetexelbuffer), or
    ///[storage image](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storageimage) in any shader pipeline
    ///stage.
    const AccessShaderWrite: Self = Self(64);
    ///[`AccessColorAttachmentRead`] specifies read access to a
    ///[color attachment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass), such as via [blending](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#framebuffer-blending), [logic operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#framebuffer-logicop), or via certain
    ///[subpass load operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-load-store-ops).
    ///It does not include [advanced blend
    ///operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#framebuffer-blend-advanced).
    ///Such access occurs in the
    ///`VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT` pipeline stage.
    const AccessColorAttachmentRead: Self = Self(128);
    ///[`AccessColorAttachmentWrite`] specifies write access to a
    ///[color, resolve, or depth/stencil resolve attachment](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#renderpass)
    ///during a [render pass](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass) or via certain
    ///[subpass load and store operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-load-store-ops).
    ///Such access occurs in the
    ///`VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT` pipeline stage.
    const AccessColorAttachmentWrite: Self = Self(256);
    ///[`AccessDepthStencilAttachmentRead`] specifies read access
    ///to a [depth/stencil attachment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass), via [depth or stencil operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fragops-ds-state) or via certain
    ///[subpass load operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-load-store-ops).
    ///Such access occurs in the
    ///`VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT` or
    ///`VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT` pipeline stages.
    const AccessDepthStencilAttachmentRead: Self = Self(512);
    ///[`AccessDepthStencilAttachmentWrite`] specifies write
    ///access to a [depth/stencil attachment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass), via
    ///[depth or stencil operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fragops-ds-state) or via certain
    ///[subpass load and store operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-load-store-ops).
    ///Such access occurs in the
    ///`VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT` or
    ///`VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT` pipeline stages.
    const AccessDepthStencilAttachmentWrite: Self = Self(1024);
    ///[`AccessTransferRead`] specifies read access to an image or
    ///buffer in a [copy](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#copies) operation.
    ///Such access occurs in the `VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT`
    ///pipeline stage.
    const AccessTransferRead: Self = Self(2048);
    ///[`AccessTransferWrite`] specifies write access to an image or
    ///buffer in a [clear](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#clears) or [copy](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#copies) operation.
    ///Such access occurs in the `VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT`
    ///pipeline stage.
    const AccessTransferWrite: Self = Self(4096);
    ///[`AccessHostRead`] specifies read access by a host operation.
    ///Accesses of this type are not performed through a resource, but directly
    ///on memory.
    ///Such access occurs in the `VK_PIPELINE_STAGE_HOST_BIT` pipeline
    ///stage.
    const AccessHostRead: Self = Self(8192);
    ///[`AccessHostWrite`] specifies write access by a host
    ///operation.
    ///Accesses of this type are not performed through a resource, but directly
    ///on memory.
    ///Such access occurs in the `VK_PIPELINE_STAGE_HOST_BIT` pipeline
    ///stage.
    const AccessHostWrite: Self = Self(16384);
    ///[`AccessMemoryRead`] specifies all read accesses.
    ///It is always valid in any access mask, and is treated as equivalent to
    ///setting all `READ` access flags that are valid where it is used.
    const AccessMemoryRead: Self = Self(32768);
    ///[`AccessMemoryWrite`] specifies all write accesses.
    ///It is always valid in any access mask, and is treated as equivalent to
    ///setting all `WRITE` access flags that are valid where it is used.
    const AccessMemoryWrite: Self = Self(65536);
    ///[`None`] specifies no accesses.
    ///
    ///Provided by [`crate::vulkan1_3`]
    const None: Self = Self(0);
    ///[`TransformFeedbackWriteExt`] specifies write access
    ///to a transform feedback buffer made when transform feedback is active.
    ///Such access occurs in the
    ///`VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT` pipeline stage.
    ///
    ///Provided by [`crate::extensions::ext_transform_feedback`]
    const TransformFeedbackWriteExt: Self = Self(33554432);
    ///[`TransformFeedbackCounterReadExt`] specifies read
    ///access to a transform feedback counter buffer which is read when
    ///[`CmdBeginTransformFeedbackEXT`] executes.
    ///Such access occurs in the
    ///`VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT` pipeline stage.
    ///
    ///Provided by [`crate::extensions::ext_transform_feedback`]
    const TransformFeedbackCounterReadExt: Self = Self(67108864);
    ///[`TransformFeedbackCounterWriteExt`] specifies write
    ///access to a transform feedback counter buffer which is written when
    ///[`CmdEndTransformFeedbackEXT`] executes.
    ///Such access occurs in the
    ///`VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT` pipeline stage.
    ///
    ///Provided by [`crate::extensions::ext_transform_feedback`]
    const TransformFeedbackCounterWriteExt: Self = Self(134217728);
    ///[`ConditionalRenderingReadExt`] specifies read access
    ///to a predicate as part of conditional rendering.
    ///Such access occurs in the
    ///`VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT` pipeline stage.
    ///
    ///Provided by [`crate::extensions::ext_conditional_rendering`]
    const ConditionalRenderingReadExt: Self = Self(1048576);
    ///[`ColorAttachmentReadNoncoherentExt`] specifies read
    ///access to [color attachments](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass), including
    ///[advanced blend operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#framebuffer-blend-advanced).
    ///Such access occurs in the
    ///`VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT` pipeline stage.
    ///
    ///Provided by [`crate::extensions::ext_blend_operation_advanced`]
    const ColorAttachmentReadNoncoherentExt: Self = Self(524288);
    ///[`AccelerationStructureReadKhr`] specifies read
    ///access to an acceleration structure as part of a trace, build, or copy
    ///command, or to an [acceleration
    ///structure scratch buffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#acceleration-structure-scratch) as part of a build command.
    ///Such access occurs in the
    ///`VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_KHR` pipeline stage or
    ///`VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR` pipeline
    ///stage.
    ///
    ///Provided by [`crate::extensions::khr_acceleration_structure`]
    const AccelerationStructureReadKhr: Self = Self(2097152);
    ///[`AccelerationStructureWriteKhr`] specifies write
    ///access to an acceleration structure or [acceleration structure scratch buffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#acceleration-structure-scratch) as part of a build or copy
    ///command.
    ///Such access occurs in the
    ///`VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR` pipeline
    ///stage.
    ///
    ///Provided by [`crate::extensions::khr_acceleration_structure`]
    const AccelerationStructureWriteKhr: Self = Self(4194304);
    ///[`FragmentDensityMapReadExt`] specifies read access
    ///to a [fragment density map
    ///attachment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-fragmentdensitymapattachment) during dynamic [fragment density
    ///map operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fragmentdensitymapops) Such access occurs in the
    ///`VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT` pipeline stage.
    ///
    ///Provided by [`crate::extensions::ext_fragment_density_map`]
    const FragmentDensityMapReadExt: Self = Self(16777216);
    ///[`FragmentShadingRateAttachmentReadKhr`] specifies
    ///read access to a fragment shading rate attachment during rasterization.
    ///Such access occurs in the
    ///`VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR`
    ///pipeline stage.
    ///
    ///Provided by [`crate::extensions::khr_fragment_shading_rate`]
    const FragmentShadingRateAttachmentReadKhr: Self = Self(8388608);
    ///[`CommandPreprocessReadNv`] specifies reads from
    ///buffer inputs to [`CmdPreprocessGeneratedCommandsNV`].
    ///Such access occurs in the
    ///`VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_NV` pipeline stage.
    ///
    ///Provided by [`crate::extensions::nv_device_generated_commands`]
    const CommandPreprocessReadNv: Self = Self(131072);
    ///[`CommandPreprocessWriteNv`] specifies writes to the
    ///target command buffer:VkBuffer preprocess outputs in
    ///[`CmdPreprocessGeneratedCommandsNV`].
    ///Such access occurs in the
    ///`VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_NV` pipeline stage.
    ///
    ///Provided by [`crate::extensions::nv_device_generated_commands`]
    const CommandPreprocessWriteNv: Self = Self(262144);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    pub const fn all() -> Self {
        Self::empty()
            | Self::AccessIndirectCommandRead
            | Self::AccessIndexRead
            | Self::AccessVertexAttributeRead
            | Self::AccessUniformRead
            | Self::AccessInputAttachmentRead
            | Self::AccessShaderRead
            | Self::AccessShaderWrite
            | Self::AccessColorAttachmentRead
            | Self::AccessColorAttachmentWrite
            | Self::AccessDepthStencilAttachmentRead
            | Self::AccessDepthStencilAttachmentWrite
            | Self::AccessTransferRead
            | Self::AccessTransferWrite
            | Self::AccessHostRead
            | Self::AccessHostWrite
            | Self::AccessMemoryRead
            | Self::AccessMemoryWrite
            | Self::None
            | Self::TransformFeedbackWriteExt
            | Self::TransformFeedbackCounterReadExt
            | Self::TransformFeedbackCounterWriteExt
            | Self::ConditionalRenderingReadExt
            | Self::ColorAttachmentReadNoncoherentExt
            | Self::AccelerationStructureReadKhr
            | Self::AccelerationStructureWriteKhr
            | Self::FragmentDensityMapReadExt
            | Self::FragmentShadingRateAttachmentReadKhr
            | Self::CommandPreprocessReadNv
            | Self::CommandPreprocessWriteNv
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl const std::ops::BitOr for AccessFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl std::ops::BitOrAssign for AccessFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl const std::ops::BitXor for AccessFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl std::ops::BitXorAssign for AccessFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl const std::ops::BitAnd for AccessFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl std::ops::BitAndAssign for AccessFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl const std::ops::Sub for AccessFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl std::ops::SubAssign for AccessFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl const std::ops::Not for AccessFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl std::iter::Extend<AccessFlags> for AccessFlags {
    fn extend<T: std::iter::IntoIterator<Item = AccessFlags>>(&mut self, iterator: T) {
        for i in iterator {
            self.insert(i);
        }
    }
}
impl std::iter::Extend<AccessFlagBits> for AccessFlags {
    fn extend<T: std::iter::IntoIterator<Item = AccessFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            self.insert(AccessFlags::from(i));
        }
    }
}
impl std::iter::FromIterator<AccessFlags> for AccessFlags {
    fn from_iter<T: std::iter::IntoIterator<Item = AccessFlags>>(iterator: T) -> AccessFlags {
        let mut out = AccessFlags::empty();
        out.extend(iterator);
        out
    }
}
impl std::iter::FromIterator<AccessFlagBits> for AccessFlags {
    fn from_iter<T: std::iter::IntoIterator<Item = AccessFlagBits>>(iterator: T) -> AccessFlags {
        let mut out = AccessFlags::empty();
        out.extend(iterator);
        out
    }
}
impl std::fmt::Debug for AccessFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(AccessFlags);
        impl std::fmt::Debug for Flags {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == AccessFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(AccessFlags::AccessIndirectCommandRead) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(AccessIndirectCommandRead))?;
                    }
                    if self.0.contains(AccessFlags::AccessIndexRead) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(AccessIndexRead))?;
                    }
                    if self.0.contains(AccessFlags::AccessVertexAttributeRead) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(AccessVertexAttributeRead))?;
                    }
                    if self.0.contains(AccessFlags::AccessUniformRead) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(AccessUniformRead))?;
                    }
                    if self.0.contains(AccessFlags::AccessInputAttachmentRead) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(AccessInputAttachmentRead))?;
                    }
                    if self.0.contains(AccessFlags::AccessShaderRead) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(AccessShaderRead))?;
                    }
                    if self.0.contains(AccessFlags::AccessShaderWrite) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(AccessShaderWrite))?;
                    }
                    if self.0.contains(AccessFlags::AccessColorAttachmentRead) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(AccessColorAttachmentRead))?;
                    }
                    if self.0.contains(AccessFlags::AccessColorAttachmentWrite) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(AccessColorAttachmentWrite))?;
                    }
                    if self.0.contains(AccessFlags::AccessDepthStencilAttachmentRead) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(AccessDepthStencilAttachmentRead))?;
                    }
                    if self.0.contains(AccessFlags::AccessDepthStencilAttachmentWrite) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(AccessDepthStencilAttachmentWrite))?;
                    }
                    if self.0.contains(AccessFlags::AccessTransferRead) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(AccessTransferRead))?;
                    }
                    if self.0.contains(AccessFlags::AccessTransferWrite) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(AccessTransferWrite))?;
                    }
                    if self.0.contains(AccessFlags::AccessHostRead) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(AccessHostRead))?;
                    }
                    if self.0.contains(AccessFlags::AccessHostWrite) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(AccessHostWrite))?;
                    }
                    if self.0.contains(AccessFlags::AccessMemoryRead) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(AccessMemoryRead))?;
                    }
                    if self.0.contains(AccessFlags::AccessMemoryWrite) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(AccessMemoryWrite))?;
                    }
                    if self.0.contains(AccessFlags::None) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(None))?;
                    }
                    if self.0.contains(AccessFlags::TransformFeedbackWriteExt) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(TransformFeedbackWriteExt))?;
                    }
                    if self.0.contains(AccessFlags::TransformFeedbackCounterReadExt) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(TransformFeedbackCounterReadExt))?;
                    }
                    if self.0.contains(AccessFlags::TransformFeedbackCounterWriteExt) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(TransformFeedbackCounterWriteExt))?;
                    }
                    if self.0.contains(AccessFlags::ConditionalRenderingReadExt) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(ConditionalRenderingReadExt))?;
                    }
                    if self.0.contains(AccessFlags::ColorAttachmentReadNoncoherentExt) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(ColorAttachmentReadNoncoherentExt))?;
                    }
                    if self.0.contains(AccessFlags::AccelerationStructureReadKhr) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(AccelerationStructureReadKhr))?;
                    }
                    if self.0.contains(AccessFlags::AccelerationStructureWriteKhr) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(AccelerationStructureWriteKhr))?;
                    }
                    if self.0.contains(AccessFlags::FragmentDensityMapReadExt) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(FragmentDensityMapReadExt))?;
                    }
                    if self.0.contains(AccessFlags::FragmentShadingRateAttachmentReadKhr) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(FragmentShadingRateAttachmentReadKhr))?;
                    }
                    if self.0.contains(AccessFlags::CommandPreprocessReadNv) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(CommandPreprocessReadNv))?;
                    }
                    if self.0.contains(AccessFlags::CommandPreprocessWriteNv) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(CommandPreprocessWriteNv))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(AccessFlags)).field(&Flags(*self)).finish()
    }
}
///[VkBufferUsageFlagBits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferUsageFlagBits.html) - Bitmask specifying allowed usage of a buffer
///# C Specifications
///Bits which  **can**  be set in [`BufferCreateInfo::usage`], specifying
///usage behavior of a buffer, are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkBufferUsageFlagBits {
///    VK_BUFFER_USAGE_TRANSFER_SRC_BIT = 0x00000001,
///    VK_BUFFER_USAGE_TRANSFER_DST_BIT = 0x00000002,
///    VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT = 0x00000004,
///    VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT = 0x00000008,
///    VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT = 0x00000010,
///    VK_BUFFER_USAGE_STORAGE_BUFFER_BIT = 0x00000020,
///    VK_BUFFER_USAGE_INDEX_BUFFER_BIT = 0x00000040,
///    VK_BUFFER_USAGE_VERTEX_BUFFER_BIT = 0x00000080,
///    VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT = 0x00000100,
///  // Provided by VK_VERSION_1_2
///    VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT = 0x00020000,
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_KHR_video_decode_queue
///    VK_BUFFER_USAGE_VIDEO_DECODE_SRC_BIT_KHR = 0x00002000,
///#endif
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_KHR_video_decode_queue
///    VK_BUFFER_USAGE_VIDEO_DECODE_DST_BIT_KHR = 0x00004000,
///#endif
///  // Provided by VK_EXT_transform_feedback
///    VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT = 0x00000800,
///  // Provided by VK_EXT_transform_feedback
///    VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT = 0x00001000,
///  // Provided by VK_EXT_conditional_rendering
///    VK_BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT = 0x00000200,
///  // Provided by VK_KHR_acceleration_structure
///    VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR = 0x00080000,
///  // Provided by VK_KHR_acceleration_structure
///    VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR = 0x00100000,
///  // Provided by VK_KHR_ray_tracing_pipeline
///    VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR = 0x00000400,
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_KHR_video_encode_queue
///    VK_BUFFER_USAGE_VIDEO_ENCODE_DST_BIT_KHR = 0x00008000,
///#endif
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_KHR_video_encode_queue
///    VK_BUFFER_USAGE_VIDEO_ENCODE_SRC_BIT_KHR = 0x00010000,
///#endif
///  // Provided by VK_NV_ray_tracing
///    VK_BUFFER_USAGE_RAY_TRACING_BIT_NV = VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR,
///  // Provided by VK_EXT_buffer_device_address
///    VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_EXT = VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT,
///  // Provided by VK_KHR_buffer_device_address
///    VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_KHR = VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT,
///} VkBufferUsageFlagBits;
///```
///# Description
/// - [`BufferUsageTransferSrc`] specifies that the buffer  **can**  be used as the source of a *transfer command* (see the definition of [`VK_PIPELINE_STAGE_TRANSFER_BIT`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-pipeline-stages-transfer)).
/// - [`BufferUsageTransferDst`] specifies that the buffer  **can**  be used as the destination of a
///   transfer command.
/// - [`BufferUsageUniformTexelBuffer`] specifies that the buffer  **can**  be used to create a
///   [`BufferView`] suitable for occupying a [`DescriptorSet`] slot of type
///   `VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER`.
/// - [`BufferUsageStorageTexelBuffer`] specifies that the buffer  **can**  be used to create a
///   [`BufferView`] suitable for occupying a [`DescriptorSet`] slot of type
///   `VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER`.
/// - [`BufferUsageUniformBuffer`] specifies that the buffer  **can**  be used in a
///   [`DescriptorBufferInfo`] suitable for occupying a [`DescriptorSet`] slot either of type
///   `VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER` or `VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC`.
/// - [`BufferUsageStorageBuffer`] specifies that the buffer  **can**  be used in a
///   [`DescriptorBufferInfo`] suitable for occupying a [`DescriptorSet`] slot either of type
///   `VK_DESCRIPTOR_TYPE_STORAGE_BUFFER` or `VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC`.
/// - [`BufferUsageIndexBuffer`] specifies that the buffer is suitable for passing as the `buffer`
///   parameter to [`CmdBindIndexBuffer`].
/// - [`BufferUsageVertexBuffer`] specifies that the buffer is suitable for passing as an element of
///   the `pBuffers` array to [`CmdBindVertexBuffers`].
/// - [`BufferUsageIndirectBuffer`] specifies that the buffer is suitable for passing as the
///   `buffer` parameter to [`CmdDrawIndirect`], [`CmdDrawIndexedIndirect`],
///   [`CmdDrawMeshTasksIndirectNV`], [`CmdDrawMeshTasksIndirectCountNV`], or
///   [`CmdDispatchIndirect`]. It is also suitable for passing as the `buffer` member of
///   [`IndirectCommandsStreamNV`], or `sequencesCountBuffer` or `sequencesIndexBuffer` or
///   `preprocessedBuffer` member of [`GeneratedCommandsInfoNV`]
/// - [`ConditionalRenderingExt`] specifies that the buffer is suitable for passing as the `buffer`
///   parameter to [`CmdBeginConditionalRenderingEXT`].
/// - [`TransformFeedbackBufferExt`] specifies that the buffer is suitable for using for binding as
///   a transform feedback buffer with [`CmdBindTransformFeedbackBuffersEXT`].
/// - [`TransformFeedbackCounterBufferExt`] specifies that the buffer is suitable for using as a
///   counter buffer with [`CmdBeginTransformFeedbackEXT`] and [`CmdEndTransformFeedbackEXT`].
/// - [`RayTracingNv`] specifies that the buffer is suitable for use in [`CmdTraceRaysNV`].
/// - [`ShaderBindingTableKhr`] specifies that the buffer is suitable for use as a [Shader Binding Table](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#shader-binding-table).
/// - [`AccelerationStructureBuildInputReadOnlyKhr`] specifies that the buffer is suitable for use as a read-only input to an [acceleration structure build](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#acceleration-structure-building).
/// - [`AccelerationStructureStorageKhr`] specifies that the buffer is suitable for storage space
///   for a [`AccelerationStructureKHR`].
/// - [`ShaderDeviceAddress`] specifies that the buffer  **can**  be used to retrieve a buffer
///   device address via [`GetBufferDeviceAddress`] and use that address to access the buffer’s
///   memory from a shader.
/// - [`VideoDecodeSrcKhr`] specifies that the buffer  **can**  be used as the source bitstream buffer in a [video decode operation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-decode-operations).
/// - [`VideoDecodeDstKhr`] specifies that the buffer  **can**  be used as the destination status buffer in a [video decode operation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-decode-operations).
/// - [`VideoEncodeDstKhr`] specifies that the buffer  **can**  be used as the destination bitstream
///   buffer in a [video encode operation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-encode-operations).
/// - [`VideoEncodeDstKhr`] specifies that the buffer  **can**  be used as the destination status buffer in a [video encode operation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-encode-operations).
///# Related
/// - [`crate::vulkan1_0`]
/// - [`BufferUsageFlags`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(transparent)]
pub struct BufferUsageFlags(u32);
impl const Default for BufferUsageFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl From<BufferUsageFlagBits> for BufferUsageFlags {
    fn from(from: BufferUsageFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(from as u32) }
    }
}
impl BufferUsageFlags {
    ///[`BufferUsageTransferSrc`] specifies that the buffer  **can**  be
    ///used as the source of a *transfer command* (see the definition of
    ///[`VK_PIPELINE_STAGE_TRANSFER_BIT`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-pipeline-stages-transfer)).
    const BufferUsageTransferSrc: Self = Self(1);
    ///[`BufferUsageTransferDst`] specifies that the buffer  **can**  be
    ///used as the destination of a transfer command.
    const BufferUsageTransferDst: Self = Self(2);
    ///[`BufferUsageUniformTexelBuffer`] specifies that the buffer
    /// **can**  be used to create a [`BufferView`] suitable for occupying a
    ///[`DescriptorSet`] slot of type
    ///`VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER`.
    const BufferUsageUniformTexelBuffer: Self = Self(4);
    ///[`BufferUsageStorageTexelBuffer`] specifies that the buffer
    /// **can**  be used to create a [`BufferView`] suitable for occupying a
    ///[`DescriptorSet`] slot of type
    ///`VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER`.
    const BufferUsageStorageTexelBuffer: Self = Self(8);
    ///[`BufferUsageUniformBuffer`] specifies that the buffer  **can**
    ///be used in a [`DescriptorBufferInfo`] suitable for occupying a
    ///[`DescriptorSet`] slot either of type
    ///`VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER` or
    ///`VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC`.
    const BufferUsageUniformBuffer: Self = Self(16);
    ///[`BufferUsageStorageBuffer`] specifies that the buffer  **can**
    ///be used in a [`DescriptorBufferInfo`] suitable for occupying a
    ///[`DescriptorSet`] slot either of type
    ///`VK_DESCRIPTOR_TYPE_STORAGE_BUFFER` or
    ///`VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC`.
    const BufferUsageStorageBuffer: Self = Self(32);
    ///[`BufferUsageIndexBuffer`] specifies that the buffer is
    ///suitable for passing as the `buffer` parameter to
    ///[`CmdBindIndexBuffer`].
    const BufferUsageIndexBuffer: Self = Self(64);
    ///[`BufferUsageVertexBuffer`] specifies that the buffer is
    ///suitable for passing as an element of the `pBuffers` array to
    ///[`CmdBindVertexBuffers`].
    const BufferUsageVertexBuffer: Self = Self(128);
    ///[`BufferUsageIndirectBuffer`] specifies that the buffer is
    ///suitable for passing as the `buffer` parameter to
    ///[`CmdDrawIndirect`], [`CmdDrawIndexedIndirect`],
    ///[`CmdDrawMeshTasksIndirectNV`],
    ///[`CmdDrawMeshTasksIndirectCountNV`],
    ///or [`CmdDispatchIndirect`].
    ///It is also suitable for passing as the `buffer` member of
    ///[`IndirectCommandsStreamNV`], or `sequencesCountBuffer` or
    ///`sequencesIndexBuffer` or `preprocessedBuffer` member of
    ///[`GeneratedCommandsInfoNV`]
    const BufferUsageIndirectBuffer: Self = Self(256);
    ///[`ShaderDeviceAddress`] specifies that the
    ///buffer  **can**  be used to retrieve a buffer device address via
    ///[`GetBufferDeviceAddress`] and use that address to access the
    ///buffer’s memory from a shader.
    ///
    ///Provided by [`crate::vulkan1_2`]
    const ShaderDeviceAddress: Self = Self(131072);
    ///[`VideoDecodeSrcKhr`] specifies that the buffer
    /// **can**  be used as the source bitstream buffer in a
    ///[video decode operation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-decode-operations).
    ///
    ///Provided by [`crate::extensions::khr_video_decode_queue`]
    const VideoDecodeSrcKhr: Self = Self(8192);
    ///[`VideoDecodeDstKhr`] specifies that the buffer
    /// **can**  be used as the destination status buffer in a
    ///[video decode operation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-decode-operations).
    ///
    ///Provided by [`crate::extensions::khr_video_decode_queue`]
    const VideoDecodeDstKhr: Self = Self(16384);
    ///[`TransformFeedbackBufferExt`] specifies that
    ///the buffer is suitable for using for binding as a transform feedback
    ///buffer with [`CmdBindTransformFeedbackBuffersEXT`].
    ///
    ///Provided by [`crate::extensions::ext_transform_feedback`]
    const TransformFeedbackBufferExt: Self = Self(2048);
    ///[`TransformFeedbackCounterBufferExt`]
    ///specifies that the buffer is suitable for using as a counter buffer with
    ///[`CmdBeginTransformFeedbackEXT`] and
    ///[`CmdEndTransformFeedbackEXT`].
    ///
    ///Provided by [`crate::extensions::ext_transform_feedback`]
    const TransformFeedbackCounterBufferExt: Self = Self(4096);
    ///[`ConditionalRenderingExt`] specifies that the
    ///buffer is suitable for passing as the `buffer` parameter to
    ///[`CmdBeginConditionalRenderingEXT`].
    ///
    ///Provided by [`crate::extensions::ext_conditional_rendering`]
    const ConditionalRenderingExt: Self = Self(512);
    ///[`AccelerationStructureBuildInputReadOnlyKhr`]
    ///specifies that the buffer is suitable for use as a read-only input to an
    ///[acceleration structure build](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#acceleration-structure-building).
    ///
    ///Provided by [`crate::extensions::khr_acceleration_structure`]
    const AccelerationStructureBuildInputReadOnlyKhr: Self = Self(524288);
    ///[`AccelerationStructureStorageKhr`] specifies
    ///that the buffer is suitable for storage space for a
    ///[`AccelerationStructureKHR`].
    ///
    ///Provided by [`crate::extensions::khr_acceleration_structure`]
    const AccelerationStructureStorageKhr: Self = Self(1048576);
    ///[`ShaderBindingTableKhr`] specifies that the
    ///buffer is suitable for use as a [Shader Binding
    ///Table](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#shader-binding-table).
    ///
    ///Provided by [`crate::extensions::khr_ray_tracing_pipeline`]
    const ShaderBindingTableKhr: Self = Self(1024);
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::qcom_extension_173`]
    const Reserved18Qcom: Self = Self(262144);
    ///[`VideoEncodeDstKhr`] specifies that the buffer
    /// **can**  be used as the destination bitstream buffer in a
    ///[video encode operation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-encode-operations).
    ///
    ///Provided by [`crate::extensions::khr_video_encode_queue`]
    const VideoEncodeDstKhr: Self = Self(32768);
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::khr_video_encode_queue`]
    const VideoEncodeSrcKhr: Self = Self(65536);
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::amd_extension_317`]
    const Reserved21Amd: Self = Self(2097152);
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::amd_extension_317`]
    const Reserved22Amd: Self = Self(4194304);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    pub const fn all() -> Self {
        Self::empty()
            | Self::BufferUsageTransferSrc
            | Self::BufferUsageTransferDst
            | Self::BufferUsageUniformTexelBuffer
            | Self::BufferUsageStorageTexelBuffer
            | Self::BufferUsageUniformBuffer
            | Self::BufferUsageStorageBuffer
            | Self::BufferUsageIndexBuffer
            | Self::BufferUsageVertexBuffer
            | Self::BufferUsageIndirectBuffer
            | Self::ShaderDeviceAddress
            | Self::VideoDecodeSrcKhr
            | Self::VideoDecodeDstKhr
            | Self::TransformFeedbackBufferExt
            | Self::TransformFeedbackCounterBufferExt
            | Self::ConditionalRenderingExt
            | Self::AccelerationStructureBuildInputReadOnlyKhr
            | Self::AccelerationStructureStorageKhr
            | Self::ShaderBindingTableKhr
            | Self::Reserved18Qcom
            | Self::VideoEncodeDstKhr
            | Self::VideoEncodeSrcKhr
            | Self::Reserved21Amd
            | Self::Reserved22Amd
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl const std::ops::BitOr for BufferUsageFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl std::ops::BitOrAssign for BufferUsageFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl const std::ops::BitXor for BufferUsageFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl std::ops::BitXorAssign for BufferUsageFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl const std::ops::BitAnd for BufferUsageFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl std::ops::BitAndAssign for BufferUsageFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl const std::ops::Sub for BufferUsageFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl std::ops::SubAssign for BufferUsageFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl const std::ops::Not for BufferUsageFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl std::iter::Extend<BufferUsageFlags> for BufferUsageFlags {
    fn extend<T: std::iter::IntoIterator<Item = BufferUsageFlags>>(&mut self, iterator: T) {
        for i in iterator {
            self.insert(i);
        }
    }
}
impl std::iter::Extend<BufferUsageFlagBits> for BufferUsageFlags {
    fn extend<T: std::iter::IntoIterator<Item = BufferUsageFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            self.insert(BufferUsageFlags::from(i));
        }
    }
}
impl std::iter::FromIterator<BufferUsageFlags> for BufferUsageFlags {
    fn from_iter<T: std::iter::IntoIterator<Item = BufferUsageFlags>>(iterator: T) -> BufferUsageFlags {
        let mut out = BufferUsageFlags::empty();
        out.extend(iterator);
        out
    }
}
impl std::iter::FromIterator<BufferUsageFlagBits> for BufferUsageFlags {
    fn from_iter<T: std::iter::IntoIterator<Item = BufferUsageFlagBits>>(iterator: T) -> BufferUsageFlags {
        let mut out = BufferUsageFlags::empty();
        out.extend(iterator);
        out
    }
}
impl std::fmt::Debug for BufferUsageFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(BufferUsageFlags);
        impl std::fmt::Debug for Flags {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == BufferUsageFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(BufferUsageFlags::BufferUsageTransferSrc) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(BufferUsageTransferSrc))?;
                    }
                    if self.0.contains(BufferUsageFlags::BufferUsageTransferDst) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(BufferUsageTransferDst))?;
                    }
                    if self.0.contains(BufferUsageFlags::BufferUsageUniformTexelBuffer) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(BufferUsageUniformTexelBuffer))?;
                    }
                    if self.0.contains(BufferUsageFlags::BufferUsageStorageTexelBuffer) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(BufferUsageStorageTexelBuffer))?;
                    }
                    if self.0.contains(BufferUsageFlags::BufferUsageUniformBuffer) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(BufferUsageUniformBuffer))?;
                    }
                    if self.0.contains(BufferUsageFlags::BufferUsageStorageBuffer) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(BufferUsageStorageBuffer))?;
                    }
                    if self.0.contains(BufferUsageFlags::BufferUsageIndexBuffer) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(BufferUsageIndexBuffer))?;
                    }
                    if self.0.contains(BufferUsageFlags::BufferUsageVertexBuffer) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(BufferUsageVertexBuffer))?;
                    }
                    if self.0.contains(BufferUsageFlags::BufferUsageIndirectBuffer) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(BufferUsageIndirectBuffer))?;
                    }
                    if self.0.contains(BufferUsageFlags::ShaderDeviceAddress) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(ShaderDeviceAddress))?;
                    }
                    if self.0.contains(BufferUsageFlags::VideoDecodeSrcKhr) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(VideoDecodeSrcKhr))?;
                    }
                    if self.0.contains(BufferUsageFlags::VideoDecodeDstKhr) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(VideoDecodeDstKhr))?;
                    }
                    if self.0.contains(BufferUsageFlags::TransformFeedbackBufferExt) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(TransformFeedbackBufferExt))?;
                    }
                    if self.0.contains(BufferUsageFlags::TransformFeedbackCounterBufferExt) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(TransformFeedbackCounterBufferExt))?;
                    }
                    if self.0.contains(BufferUsageFlags::ConditionalRenderingExt) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(ConditionalRenderingExt))?;
                    }
                    if self
                        .0
                        .contains(BufferUsageFlags::AccelerationStructureBuildInputReadOnlyKhr)
                    {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(AccelerationStructureBuildInputReadOnlyKhr))?;
                    }
                    if self.0.contains(BufferUsageFlags::AccelerationStructureStorageKhr) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(AccelerationStructureStorageKhr))?;
                    }
                    if self.0.contains(BufferUsageFlags::ShaderBindingTableKhr) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(ShaderBindingTableKhr))?;
                    }
                    if self.0.contains(BufferUsageFlags::Reserved18Qcom) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(Reserved18Qcom))?;
                    }
                    if self.0.contains(BufferUsageFlags::VideoEncodeDstKhr) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(VideoEncodeDstKhr))?;
                    }
                    if self.0.contains(BufferUsageFlags::VideoEncodeSrcKhr) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(VideoEncodeSrcKhr))?;
                    }
                    if self.0.contains(BufferUsageFlags::Reserved21Amd) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(Reserved21Amd))?;
                    }
                    if self.0.contains(BufferUsageFlags::Reserved22Amd) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(Reserved22Amd))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(BufferUsageFlags))
            .field(&Flags(*self))
            .finish()
    }
}
///[VkBufferCreateFlagBits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferCreateFlagBits.html) - Bitmask specifying additional parameters of a buffer
///# C Specifications
///Bits which  **can**  be set in [`BufferCreateInfo::flags`], specifying
///additional parameters of a buffer, are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkBufferCreateFlagBits {
///    VK_BUFFER_CREATE_SPARSE_BINDING_BIT = 0x00000001,
///    VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT = 0x00000002,
///    VK_BUFFER_CREATE_SPARSE_ALIASED_BIT = 0x00000004,
///  // Provided by VK_VERSION_1_1
///    VK_BUFFER_CREATE_PROTECTED_BIT = 0x00000008,
///  // Provided by VK_VERSION_1_2
///    VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT = 0x00000010,
///  // Provided by VK_EXT_buffer_device_address
///    VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT =
/// VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT,
///  // Provided by VK_KHR_buffer_device_address
///    VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR =
/// VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT,
///} VkBufferCreateFlagBits;
///```
///# Description
/// - [`BufferCreateSparseBinding`] specifies that the buffer will be backed using sparse memory
///   binding.
/// - [`BufferCreateSparseResidency`] specifies that the buffer  **can**  be partially backed using
///   sparse memory binding. Buffers created with this flag  **must**  also be created with the
///   [`BufferCreateSparseBinding`] flag.
/// - [`BufferCreateSparseAliased`] specifies that the buffer will be backed using sparse memory
///   binding with memory ranges that might also simultaneously be backing another buffer (or
///   another portion of the same buffer). Buffers created with this flag  **must**  also be created
///   with the [`BufferCreateSparseBinding`] flag.
/// - [`Protected`] specifies that the buffer is a protected buffer.
/// - [`DeviceAddressCaptureReplay`] specifies that the buffer’s address  **can**  be saved and
///   reused on a subsequent run (e.g. for trace capture and replay), see
///   [`BufferOpaqueCaptureAddressCreateInfo`] for more detail.
///See [Sparse Resource Features](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#sparsememory-sparseresourcefeatures) and
///[Physical Device Features](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features) for details of the sparse memory
///features supported on a device.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`BufferCreateFlags`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(transparent)]
pub struct BufferCreateFlags(u32);
impl const Default for BufferCreateFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl From<BufferCreateFlagBits> for BufferCreateFlags {
    fn from(from: BufferCreateFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(from as u32) }
    }
}
impl BufferCreateFlags {
    ///[`BufferCreateSparseBinding`] specifies that the buffer will
    ///be backed using sparse memory binding.
    const BufferCreateSparseBinding: Self = Self(1);
    ///[`BufferCreateSparseResidency`] specifies that the buffer
    /// **can**  be partially backed using sparse memory binding.
    ///Buffers created with this flag  **must**  also be created with the
    ///[`BufferCreateSparseBinding`] flag.
    const BufferCreateSparseResidency: Self = Self(2);
    ///[`BufferCreateSparseAliased`] specifies that the buffer will
    ///be backed using sparse memory binding with memory ranges that might also
    ///simultaneously be backing another buffer (or another portion of the same
    ///buffer).
    ///Buffers created with this flag  **must**  also be created with the
    ///[`BufferCreateSparseBinding`] flag.
    const BufferCreateSparseAliased: Self = Self(4);
    ///[`Protected`] specifies that the buffer is a
    ///protected buffer.
    ///
    ///Provided by [`crate::vulkan1_1`]
    const Protected: Self = Self(8);
    ///[`DeviceAddressCaptureReplay`] specifies that
    ///the buffer’s address  **can**  be saved and reused on a subsequent run (e.g.
    ///for trace capture and replay), see
    ///[`BufferOpaqueCaptureAddressCreateInfo`] for more detail.
    ///
    ///Provided by [`crate::vulkan1_2`]
    const DeviceAddressCaptureReplay: Self = Self(16);
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::amd_extension_317`]
    const Reserved5Amd: Self = Self(32);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    pub const fn all() -> Self {
        Self::empty()
            | Self::BufferCreateSparseBinding
            | Self::BufferCreateSparseResidency
            | Self::BufferCreateSparseAliased
            | Self::Protected
            | Self::DeviceAddressCaptureReplay
            | Self::Reserved5Amd
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl const std::ops::BitOr for BufferCreateFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl std::ops::BitOrAssign for BufferCreateFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl const std::ops::BitXor for BufferCreateFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl std::ops::BitXorAssign for BufferCreateFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl const std::ops::BitAnd for BufferCreateFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl std::ops::BitAndAssign for BufferCreateFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl const std::ops::Sub for BufferCreateFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl std::ops::SubAssign for BufferCreateFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl const std::ops::Not for BufferCreateFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl std::iter::Extend<BufferCreateFlags> for BufferCreateFlags {
    fn extend<T: std::iter::IntoIterator<Item = BufferCreateFlags>>(&mut self, iterator: T) {
        for i in iterator {
            self.insert(i);
        }
    }
}
impl std::iter::Extend<BufferCreateFlagBits> for BufferCreateFlags {
    fn extend<T: std::iter::IntoIterator<Item = BufferCreateFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            self.insert(BufferCreateFlags::from(i));
        }
    }
}
impl std::iter::FromIterator<BufferCreateFlags> for BufferCreateFlags {
    fn from_iter<T: std::iter::IntoIterator<Item = BufferCreateFlags>>(iterator: T) -> BufferCreateFlags {
        let mut out = BufferCreateFlags::empty();
        out.extend(iterator);
        out
    }
}
impl std::iter::FromIterator<BufferCreateFlagBits> for BufferCreateFlags {
    fn from_iter<T: std::iter::IntoIterator<Item = BufferCreateFlagBits>>(iterator: T) -> BufferCreateFlags {
        let mut out = BufferCreateFlags::empty();
        out.extend(iterator);
        out
    }
}
impl std::fmt::Debug for BufferCreateFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(BufferCreateFlags);
        impl std::fmt::Debug for Flags {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == BufferCreateFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(BufferCreateFlags::BufferCreateSparseBinding) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(BufferCreateSparseBinding))?;
                    }
                    if self.0.contains(BufferCreateFlags::BufferCreateSparseResidency) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(BufferCreateSparseResidency))?;
                    }
                    if self.0.contains(BufferCreateFlags::BufferCreateSparseAliased) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(BufferCreateSparseAliased))?;
                    }
                    if self.0.contains(BufferCreateFlags::Protected) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(Protected))?;
                    }
                    if self.0.contains(BufferCreateFlags::DeviceAddressCaptureReplay) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(DeviceAddressCaptureReplay))?;
                    }
                    if self.0.contains(BufferCreateFlags::Reserved5Amd) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(Reserved5Amd))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(BufferCreateFlags))
            .field(&Flags(*self))
            .finish()
    }
}
///[VkShaderStageFlagBits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkShaderStageFlagBits.html) - Bitmask specifying a pipeline stage
///# C Specifications
///Bits which  **can**  be set by commands and structures, specifying one or more
///shader stages, are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkShaderStageFlagBits {
///    VK_SHADER_STAGE_VERTEX_BIT = 0x00000001,
///    VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT = 0x00000002,
///    VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT = 0x00000004,
///    VK_SHADER_STAGE_GEOMETRY_BIT = 0x00000008,
///    VK_SHADER_STAGE_FRAGMENT_BIT = 0x00000010,
///    VK_SHADER_STAGE_COMPUTE_BIT = 0x00000020,
///    VK_SHADER_STAGE_ALL_GRAPHICS = 0x0000001F,
///    VK_SHADER_STAGE_ALL = 0x7FFFFFFF,
///  // Provided by VK_KHR_ray_tracing_pipeline
///    VK_SHADER_STAGE_RAYGEN_BIT_KHR = 0x00000100,
///  // Provided by VK_KHR_ray_tracing_pipeline
///    VK_SHADER_STAGE_ANY_HIT_BIT_KHR = 0x00000200,
///  // Provided by VK_KHR_ray_tracing_pipeline
///    VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR = 0x00000400,
///  // Provided by VK_KHR_ray_tracing_pipeline
///    VK_SHADER_STAGE_MISS_BIT_KHR = 0x00000800,
///  // Provided by VK_KHR_ray_tracing_pipeline
///    VK_SHADER_STAGE_INTERSECTION_BIT_KHR = 0x00001000,
///  // Provided by VK_KHR_ray_tracing_pipeline
///    VK_SHADER_STAGE_CALLABLE_BIT_KHR = 0x00002000,
///  // Provided by VK_NV_mesh_shader
///    VK_SHADER_STAGE_TASK_BIT_NV = 0x00000040,
///  // Provided by VK_NV_mesh_shader
///    VK_SHADER_STAGE_MESH_BIT_NV = 0x00000080,
///  // Provided by VK_HUAWEI_subpass_shading
///    VK_SHADER_STAGE_SUBPASS_SHADING_BIT_HUAWEI = 0x00004000,
///  // Provided by VK_NV_ray_tracing
///    VK_SHADER_STAGE_RAYGEN_BIT_NV = VK_SHADER_STAGE_RAYGEN_BIT_KHR,
///  // Provided by VK_NV_ray_tracing
///    VK_SHADER_STAGE_ANY_HIT_BIT_NV = VK_SHADER_STAGE_ANY_HIT_BIT_KHR,
///  // Provided by VK_NV_ray_tracing
///    VK_SHADER_STAGE_CLOSEST_HIT_BIT_NV = VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR,
///  // Provided by VK_NV_ray_tracing
///    VK_SHADER_STAGE_MISS_BIT_NV = VK_SHADER_STAGE_MISS_BIT_KHR,
///  // Provided by VK_NV_ray_tracing
///    VK_SHADER_STAGE_INTERSECTION_BIT_NV = VK_SHADER_STAGE_INTERSECTION_BIT_KHR,
///  // Provided by VK_NV_ray_tracing
///    VK_SHADER_STAGE_CALLABLE_BIT_NV = VK_SHADER_STAGE_CALLABLE_BIT_KHR,
///} VkShaderStageFlagBits;
///```
///# Description
/// - [`ShaderStageVertex`] specifies the vertex stage.
/// - [`ShaderStageTessellationControl`] specifies the tessellation control stage.
/// - [`ShaderStageTessellationEvaluation`] specifies the tessellation evaluation stage.
/// - [`ShaderStageGeometry`] specifies the geometry stage.
/// - [`ShaderStageFragment`] specifies the fragment stage.
/// - [`ShaderStageCompute`] specifies the compute stage.
/// - [`ShaderStageAllGraphics`] is a combination of bits used as shorthand to specify all graphics
///   stages defined above (excluding the compute stage).
/// - [`ShaderStageAll`] is a combination of bits used as shorthand to specify all shader stages
///   supported by the device, including all additional stages which are introduced by extensions.
/// - [`TaskNv`] specifies the task stage.
/// - [`MeshNv`] specifies the mesh stage.
/// - [`RaygenKhr`] specifies the ray generation stage.
/// - [`AnyHitKhr`] specifies the any-hit stage.
/// - [`ClosestHitKhr`] specifies the closest hit stage.
/// - [`MissKhr`] specifies the miss stage.
/// - [`IntersectionKhr`] specifies the intersection stage.
/// - [`CallableKhr`] specifies the callable stage.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`PipelineShaderStageCreateInfo`]
/// - [`ShaderStageFlags`]
/// - [`GetShaderInfoAMD`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(transparent)]
pub struct ShaderStageFlags(u32);
impl const Default for ShaderStageFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl From<ShaderStageFlagBits> for ShaderStageFlags {
    fn from(from: ShaderStageFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(from as u32) }
    }
}
impl ShaderStageFlags {
    ///[`ShaderStageVertex`] specifies the vertex stage.
    const ShaderStageVertex: Self = Self(1);
    ///[`ShaderStageTessellationControl`] specifies the
    ///tessellation control stage.
    const ShaderStageTessellationControl: Self = Self(2);
    ///[`ShaderStageTessellationEvaluation`] specifies the
    ///tessellation evaluation stage.
    const ShaderStageTessellationEvaluation: Self = Self(4);
    ///[`ShaderStageGeometry`] specifies the geometry stage.
    const ShaderStageGeometry: Self = Self(8);
    ///[`ShaderStageFragment`] specifies the fragment stage.
    const ShaderStageFragment: Self = Self(16);
    ///[`ShaderStageCompute`] specifies the compute stage.
    const ShaderStageCompute: Self = Self(32);
    ///[`ShaderStageAllGraphics`] is a combination of bits used as
    ///shorthand to specify all graphics stages defined above (excluding the
    ///compute stage).
    const ShaderStageAllGraphics: Self = Self(31);
    ///[`ShaderStageAll`] is a combination of bits used as shorthand to
    ///specify all shader stages supported by the device, including all
    ///additional stages which are introduced by extensions.
    const ShaderStageAll: Self = Self(2147483647);
    ///[`RaygenKhr`] specifies the ray generation stage.
    ///
    ///Provided by [`crate::extensions::khr_ray_tracing_pipeline`]
    const RaygenKhr: Self = Self(256);
    ///[`AnyHitKhr`] specifies the any-hit stage.
    ///
    ///Provided by [`crate::extensions::khr_ray_tracing_pipeline`]
    const AnyHitKhr: Self = Self(512);
    ///[`ClosestHitKhr`] specifies the closest hit
    ///stage.
    ///
    ///Provided by [`crate::extensions::khr_ray_tracing_pipeline`]
    const ClosestHitKhr: Self = Self(1024);
    ///[`MissKhr`] specifies the miss stage.
    ///
    ///Provided by [`crate::extensions::khr_ray_tracing_pipeline`]
    const MissKhr: Self = Self(2048);
    ///[`IntersectionKhr`] specifies the intersection
    ///stage.
    ///
    ///Provided by [`crate::extensions::khr_ray_tracing_pipeline`]
    const IntersectionKhr: Self = Self(4096);
    ///[`CallableKhr`] specifies the callable stage.
    ///
    ///Provided by [`crate::extensions::khr_ray_tracing_pipeline`]
    const CallableKhr: Self = Self(8192);
    ///[`TaskNv`] specifies the task stage.
    ///
    ///Provided by [`crate::extensions::nv_mesh_shader`]
    const TaskNv: Self = Self(64);
    ///[`MeshNv`] specifies the mesh stage.
    ///
    ///Provided by [`crate::extensions::nv_mesh_shader`]
    const MeshNv: Self = Self(128);
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::huawei_subpass_shading`]
    const SubpassShadingHuawei: Self = Self(16384);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    pub const fn all() -> Self {
        Self::empty()
            | Self::ShaderStageVertex
            | Self::ShaderStageTessellationControl
            | Self::ShaderStageTessellationEvaluation
            | Self::ShaderStageGeometry
            | Self::ShaderStageFragment
            | Self::ShaderStageCompute
            | Self::ShaderStageAllGraphics
            | Self::ShaderStageAll
            | Self::RaygenKhr
            | Self::AnyHitKhr
            | Self::ClosestHitKhr
            | Self::MissKhr
            | Self::IntersectionKhr
            | Self::CallableKhr
            | Self::TaskNv
            | Self::MeshNv
            | Self::SubpassShadingHuawei
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl const std::ops::BitOr for ShaderStageFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl std::ops::BitOrAssign for ShaderStageFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl const std::ops::BitXor for ShaderStageFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl std::ops::BitXorAssign for ShaderStageFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl const std::ops::BitAnd for ShaderStageFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl std::ops::BitAndAssign for ShaderStageFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl const std::ops::Sub for ShaderStageFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl std::ops::SubAssign for ShaderStageFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl const std::ops::Not for ShaderStageFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl std::iter::Extend<ShaderStageFlags> for ShaderStageFlags {
    fn extend<T: std::iter::IntoIterator<Item = ShaderStageFlags>>(&mut self, iterator: T) {
        for i in iterator {
            self.insert(i);
        }
    }
}
impl std::iter::Extend<ShaderStageFlagBits> for ShaderStageFlags {
    fn extend<T: std::iter::IntoIterator<Item = ShaderStageFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            self.insert(ShaderStageFlags::from(i));
        }
    }
}
impl std::iter::FromIterator<ShaderStageFlags> for ShaderStageFlags {
    fn from_iter<T: std::iter::IntoIterator<Item = ShaderStageFlags>>(iterator: T) -> ShaderStageFlags {
        let mut out = ShaderStageFlags::empty();
        out.extend(iterator);
        out
    }
}
impl std::iter::FromIterator<ShaderStageFlagBits> for ShaderStageFlags {
    fn from_iter<T: std::iter::IntoIterator<Item = ShaderStageFlagBits>>(iterator: T) -> ShaderStageFlags {
        let mut out = ShaderStageFlags::empty();
        out.extend(iterator);
        out
    }
}
impl std::fmt::Debug for ShaderStageFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(ShaderStageFlags);
        impl std::fmt::Debug for Flags {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == ShaderStageFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(ShaderStageFlags::ShaderStageVertex) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(ShaderStageVertex))?;
                    }
                    if self.0.contains(ShaderStageFlags::ShaderStageTessellationControl) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(ShaderStageTessellationControl))?;
                    }
                    if self.0.contains(ShaderStageFlags::ShaderStageTessellationEvaluation) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(ShaderStageTessellationEvaluation))?;
                    }
                    if self.0.contains(ShaderStageFlags::ShaderStageGeometry) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(ShaderStageGeometry))?;
                    }
                    if self.0.contains(ShaderStageFlags::ShaderStageFragment) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(ShaderStageFragment))?;
                    }
                    if self.0.contains(ShaderStageFlags::ShaderStageCompute) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(ShaderStageCompute))?;
                    }
                    if self.0.contains(ShaderStageFlags::ShaderStageAllGraphics) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(ShaderStageAllGraphics))?;
                    }
                    if self.0.contains(ShaderStageFlags::ShaderStageAll) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(ShaderStageAll))?;
                    }
                    if self.0.contains(ShaderStageFlags::RaygenKhr) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(RaygenKhr))?;
                    }
                    if self.0.contains(ShaderStageFlags::AnyHitKhr) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(AnyHitKhr))?;
                    }
                    if self.0.contains(ShaderStageFlags::ClosestHitKhr) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(ClosestHitKhr))?;
                    }
                    if self.0.contains(ShaderStageFlags::MissKhr) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(MissKhr))?;
                    }
                    if self.0.contains(ShaderStageFlags::IntersectionKhr) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(IntersectionKhr))?;
                    }
                    if self.0.contains(ShaderStageFlags::CallableKhr) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(CallableKhr))?;
                    }
                    if self.0.contains(ShaderStageFlags::TaskNv) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(TaskNv))?;
                    }
                    if self.0.contains(ShaderStageFlags::MeshNv) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(MeshNv))?;
                    }
                    if self.0.contains(ShaderStageFlags::SubpassShadingHuawei) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(SubpassShadingHuawei))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(ShaderStageFlags))
            .field(&Flags(*self))
            .finish()
    }
}
///[VkImageUsageFlagBits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageUsageFlagBits.html) - Bitmask specifying intended usage of an image
///# C Specifications
///Bits which  **can**  be set in
///  * [`ImageViewUsageCreateInfo::usage`]
///  * [`ImageStencilUsageCreateInfo::stencil_usage`]
///  * [`ImageCreateInfo::usage`]
///specify intended usage of an image, and are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkImageUsageFlagBits {
///    VK_IMAGE_USAGE_TRANSFER_SRC_BIT = 0x00000001,
///    VK_IMAGE_USAGE_TRANSFER_DST_BIT = 0x00000002,
///    VK_IMAGE_USAGE_SAMPLED_BIT = 0x00000004,
///    VK_IMAGE_USAGE_STORAGE_BIT = 0x00000008,
///    VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT = 0x00000010,
///    VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT = 0x00000020,
///    VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT = 0x00000040,
///    VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT = 0x00000080,
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_KHR_video_decode_queue
///    VK_IMAGE_USAGE_VIDEO_DECODE_DST_BIT_KHR = 0x00000400,
///#endif
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_KHR_video_decode_queue
///    VK_IMAGE_USAGE_VIDEO_DECODE_SRC_BIT_KHR = 0x00000800,
///#endif
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_KHR_video_decode_queue
///    VK_IMAGE_USAGE_VIDEO_DECODE_DPB_BIT_KHR = 0x00001000,
///#endif
///  // Provided by VK_EXT_fragment_density_map
///    VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT = 0x00000200,
///  // Provided by VK_KHR_fragment_shading_rate
///    VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = 0x00000100,
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_KHR_video_encode_queue
///    VK_IMAGE_USAGE_VIDEO_ENCODE_DST_BIT_KHR = 0x00002000,
///#endif
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_KHR_video_encode_queue
///    VK_IMAGE_USAGE_VIDEO_ENCODE_SRC_BIT_KHR = 0x00004000,
///#endif
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_KHR_video_encode_queue
///    VK_IMAGE_USAGE_VIDEO_ENCODE_DPB_BIT_KHR = 0x00008000,
///#endif
///  // Provided by VK_HUAWEI_invocation_mask
///    VK_IMAGE_USAGE_INVOCATION_MASK_BIT_HUAWEI = 0x00040000,
///  // Provided by VK_NV_shading_rate_image
///    VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV =
/// VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR,
///} VkImageUsageFlagBits;
///```
///# Description
/// - [`ImageUsageTransferSrc`] specifies that the image  **can**  be used as the source of a
///   transfer command.
/// - [`ImageUsageTransferDst`] specifies that the image  **can**  be used as the destination of a
///   transfer command.
/// - [`ImageUsageSampled`] specifies that the image  **can**  be used to create a [`ImageView`]
///   suitable for occupying a [`DescriptorSet`] slot either of type
///   `VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE` or `VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER`, and be
///   sampled by a shader.
/// - [`ImageUsageStorage`] specifies that the image  **can**  be used to create a [`ImageView`]
///   suitable for occupying a [`DescriptorSet`] slot of type `VK_DESCRIPTOR_TYPE_STORAGE_IMAGE`.
/// - [`ImageUsageColorAttachment`] specifies that the image  **can**  be used to create a
///   [`ImageView`] suitable for use as a color or resolve attachment in a [`Framebuffer`].
/// - [`ImageUsageDepthStencilAttachment`] specifies that the image  **can**  be used to create a
///   [`ImageView`] suitable for use as a depth/stencil or depth/stencil resolve attachment in a
///   [`Framebuffer`].
/// - [`ImageUsageTransientAttachment`] specifies that implementations  **may**  support using [memory allocations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#memory) with the `VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT` to back an image with this usage. This bit  **can**  be set for any image that  **can**  be used to create a [`ImageView`] suitable for use as a color, resolve, depth/stencil, or input attachment.
/// - [`ImageUsageInputAttachment`] specifies that the image  **can**  be used to create a
///   [`ImageView`] suitable for occupying [`DescriptorSet`] slot of type
///   `VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT`; be read from a shader as an input attachment; and be
///   used as an input attachment in a framebuffer.
/// - [`FragmentDensityMapExt`] specifies that the image  **can**  be used to create a [`ImageView`]
///   suitable for use as a [fragment density map image](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fragmentdensitymapops).
/// - [`FragmentShadingRateAttachmentKhr`] specifies     that the image  **can**  be used to create a [`ImageView`] suitable for     use as a     [fragment shading rate     attachment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#primsrast-fragment-shading-rate-attachment) or     [shading rate image](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#primsrast-shading-rate-image)
/// - [`VideoDecodeDstKhr`] specifies that [video decode operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-decode-operations)
///   **can**  use the image as an output picture for video decode operations.
/// - [`VideoDecodeSrcKhr`] is reserved for future use.
/// - [`VideoDecodeDpbKhr`] specifies that [video decode operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-decode-operations) **can**  use the image as a [DPB Video Picture Resource](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-picture-resources), representing a [reference picture](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#reference-picture). If an implementation requires separate allocations for DPB and decode output, indicating this by returning `VK_ERROR_FORMAT_NOT_SUPPORTED` to any [`GetPhysicalDeviceVideoFormatPropertiesKHR`] call with both [`VideoDecodeDpbKhr`] and [`VideoDecodeDstKhr`] usage bits, then [`VideoDecodeDpbKhr`] **must**  not be combined with any other VK_IMAGE_USAGE_* flags. Otherwise, [`VideoDecodeDpbKhr`] **must**  be combined with [`VideoDecodeDstKhr`], if the DPB image is required to coincide with the decoded output picture. In the case where DPB coincides with the decoded output picture, image resources  **can**  be used as [reference pictures](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#reference-picture) only after acting as targets for video decode operations, where its image view  **must**  be set to both [`VideoDecodeInfoKHR`]::`pSetupReferenceSlot->pPictureResource->imageViewBinding` and [`VideoDecodeInfoKHR`]::`dstPictureResource.imageViewBinding`.
/// - [`VideoEncodeSrcKhr`] specifies that the image  **can**  be used as an [input picture](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#input-encode-picture)
///   for [video encode operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-encode-operations).
/// - [`VideoEncodeDstKhr`] is reserved for future use.
/// - [`VideoEncodeDpbKhr`] specifies that [video encode operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-encode-operations)
///   **can**  use the image as an output to hold a [reconstructed picture](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-picture-resources)
///   that can subsequently act as an input [reference picture](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#reference-picture).
///# Related
/// - [`crate::vulkan1_0`]
/// - [`ImageUsageFlags`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(transparent)]
pub struct ImageUsageFlags(u32);
impl const Default for ImageUsageFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl From<ImageUsageFlagBits> for ImageUsageFlags {
    fn from(from: ImageUsageFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(from as u32) }
    }
}
impl ImageUsageFlags {
    ///[`ImageUsageTransferSrc`] specifies that the image  **can**  be
    ///used as the source of a transfer command.
    const ImageUsageTransferSrc: Self = Self(1);
    ///[`ImageUsageTransferDst`] specifies that the image  **can**  be
    ///used as the destination of a transfer command.
    const ImageUsageTransferDst: Self = Self(2);
    ///[`ImageUsageSampled`] specifies that the image  **can**  be used
    ///to create a [`ImageView`] suitable for occupying a
    ///[`DescriptorSet`] slot either of type
    ///`VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE` or
    ///`VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER`, and be sampled by a
    ///shader.
    const ImageUsageSampled: Self = Self(4);
    ///[`ImageUsageStorage`] specifies that the image  **can**  be used
    ///to create a [`ImageView`] suitable for occupying a
    ///[`DescriptorSet`] slot of type
    ///`VK_DESCRIPTOR_TYPE_STORAGE_IMAGE`.
    const ImageUsageStorage: Self = Self(8);
    ///[`ImageUsageColorAttachment`] specifies that the image  **can**
    ///be used to create a [`ImageView`] suitable for use as a color or
    ///resolve attachment in a [`Framebuffer`].
    const ImageUsageColorAttachment: Self = Self(16);
    ///[`ImageUsageDepthStencilAttachment`] specifies that the
    ///image  **can**  be used to create a [`ImageView`] suitable for use as a
    ///depth/stencil
    ///or depth/stencil resolve
    ///attachment in a [`Framebuffer`].
    const ImageUsageDepthStencilAttachment: Self = Self(32);
    ///[`ImageUsageTransientAttachment`] specifies that
    ///implementations  **may**  support using [memory allocations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#memory) with
    ///the `VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT` to back an image with
    ///this usage.
    ///This bit  **can**  be set for any image that  **can**  be used to create a
    ///[`ImageView`] suitable for use as a color, resolve, depth/stencil,
    ///or input attachment.
    const ImageUsageTransientAttachment: Self = Self(64);
    ///[`ImageUsageInputAttachment`] specifies that the image  **can**
    ///be used to create a [`ImageView`] suitable for occupying
    ///[`DescriptorSet`] slot of type
    ///`VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT`; be read from a shader as an
    ///input attachment; and be used as an input attachment in a framebuffer.
    const ImageUsageInputAttachment: Self = Self(128);
    ///[`VideoDecodeDstKhr`] specifies that
    ///[video decode operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-decode-operations) **can**  use the image
    ///as an output picture for video decode operations.
    ///
    ///Provided by [`crate::extensions::khr_video_decode_queue`]
    const VideoDecodeDstKhr: Self = Self(1024);
    ///[`VideoDecodeSrcKhr`] is reserved for future
    ///use.
    ///
    ///Provided by [`crate::extensions::khr_video_decode_queue`]
    const VideoDecodeSrcKhr: Self = Self(2048);
    ///[`VideoDecodeDpbKhr`] specifies that
    ///[video decode operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-decode-operations) **can**  use the image
    ///as a [DPB Video Picture Resource](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-picture-resources),
    ///representing a [reference picture](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#reference-picture).
    ///If an implementation requires separate allocations for DPB and decode
    ///output, indicating this by returning `VK_ERROR_FORMAT_NOT_SUPPORTED`
    ///to any [`GetPhysicalDeviceVideoFormatPropertiesKHR`] call with both
    ///[`VideoDecodeDpbKhr`] and
    ///[`VideoDecodeDstKhr`] usage bits, then
    ///[`VideoDecodeDpbKhr`] **must**  not be combined with
    ///any other VK_IMAGE_USAGE_* flags.
    ///Otherwise, [`VideoDecodeDpbKhr`] **must**  be
    ///combined with [`VideoDecodeDstKhr`], if the DPB
    ///image is required to coincide with the decoded output picture.
    ///In the case where DPB coincides with the decoded output picture, image
    ///resources  **can**  be used as [reference pictures](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#reference-picture) only
    ///after acting as targets for video decode operations, where its image
    ///view  **must**  be set to both
    ///[`VideoDecodeInfoKHR`]::`pSetupReferenceSlot->pPictureResource->imageViewBinding`
    ///and
    ///[`VideoDecodeInfoKHR`]::`dstPictureResource.imageViewBinding`.
    ///
    ///Provided by [`crate::extensions::khr_video_decode_queue`]
    const VideoDecodeDpbKhr: Self = Self(4096);
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::qcom_extension_173`]
    const Reserved16Qcom: Self = Self(65536);
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::qcom_extension_173`]
    const Reserved17Qcom: Self = Self(131072);
    ///[`FragmentDensityMapExt`] specifies that the
    ///image  **can**  be used to create a [`ImageView`] suitable for use as a
    ///[fragment density map image](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fragmentdensitymapops).
    ///
    ///Provided by [`crate::extensions::ext_fragment_density_map`]
    const FragmentDensityMapExt: Self = Self(512);
    ///[`FragmentShadingRateAttachmentKhr`] specifies
    ///    that the image  **can**  be used to create a [`ImageView`] suitable for
    ///    use as a
    ///    [fragment shading rate
    ///    attachment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#primsrast-fragment-shading-rate-attachment)
    ///or
    ///    [shading rate image](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#primsrast-shading-rate-image)
    ///
    ///Provided by [`crate::extensions::khr_fragment_shading_rate`]
    const FragmentShadingRateAttachmentKhr: Self = Self(256);
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::intel_extension_271`]
    const Reserved22Ext: Self = Self(4194304);
    ///[`VideoEncodeDstKhr`] is reserved for future
    ///use.
    ///
    ///Provided by [`crate::extensions::khr_video_encode_queue`]
    const VideoEncodeDstKhr: Self = Self(8192);
    ///[`VideoEncodeSrcKhr`] specifies that the image
    /// **can**  be used as an [input picture](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#input-encode-picture) for
    ///[video encode operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-encode-operations).
    ///
    ///Provided by [`crate::extensions::khr_video_encode_queue`]
    const VideoEncodeSrcKhr: Self = Self(16384);
    ///[`VideoEncodeDpbKhr`] specifies that
    ///[video encode operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-encode-operations) **can**  use the image
    ///as an output to hold a [reconstructed picture](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-picture-resources)
    ///that can subsequently act as an input [reference
    ///picture](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#reference-picture).
    ///
    ///Provided by [`crate::extensions::khr_video_encode_queue`]
    const VideoEncodeDpbKhr: Self = Self(32768);
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_extension_340`]
    const Reserved19Ext: Self = Self(524288);
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::huawei_invocation_mask`]
    const InvocationMaskHuawei: Self = Self(262144);
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::qcom_extension_441`]
    const Reserved20Qcom: Self = Self(1048576);
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::qcom_extension_441`]
    const Reserved21Qcom: Self = Self(2097152);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    pub const fn all() -> Self {
        Self::empty()
            | Self::ImageUsageTransferSrc
            | Self::ImageUsageTransferDst
            | Self::ImageUsageSampled
            | Self::ImageUsageStorage
            | Self::ImageUsageColorAttachment
            | Self::ImageUsageDepthStencilAttachment
            | Self::ImageUsageTransientAttachment
            | Self::ImageUsageInputAttachment
            | Self::VideoDecodeDstKhr
            | Self::VideoDecodeSrcKhr
            | Self::VideoDecodeDpbKhr
            | Self::Reserved16Qcom
            | Self::Reserved17Qcom
            | Self::FragmentDensityMapExt
            | Self::FragmentShadingRateAttachmentKhr
            | Self::Reserved22Ext
            | Self::VideoEncodeDstKhr
            | Self::VideoEncodeSrcKhr
            | Self::VideoEncodeDpbKhr
            | Self::Reserved19Ext
            | Self::InvocationMaskHuawei
            | Self::Reserved20Qcom
            | Self::Reserved21Qcom
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl const std::ops::BitOr for ImageUsageFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl std::ops::BitOrAssign for ImageUsageFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl const std::ops::BitXor for ImageUsageFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl std::ops::BitXorAssign for ImageUsageFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl const std::ops::BitAnd for ImageUsageFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl std::ops::BitAndAssign for ImageUsageFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl const std::ops::Sub for ImageUsageFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl std::ops::SubAssign for ImageUsageFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl const std::ops::Not for ImageUsageFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl std::iter::Extend<ImageUsageFlags> for ImageUsageFlags {
    fn extend<T: std::iter::IntoIterator<Item = ImageUsageFlags>>(&mut self, iterator: T) {
        for i in iterator {
            self.insert(i);
        }
    }
}
impl std::iter::Extend<ImageUsageFlagBits> for ImageUsageFlags {
    fn extend<T: std::iter::IntoIterator<Item = ImageUsageFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            self.insert(ImageUsageFlags::from(i));
        }
    }
}
impl std::iter::FromIterator<ImageUsageFlags> for ImageUsageFlags {
    fn from_iter<T: std::iter::IntoIterator<Item = ImageUsageFlags>>(iterator: T) -> ImageUsageFlags {
        let mut out = ImageUsageFlags::empty();
        out.extend(iterator);
        out
    }
}
impl std::iter::FromIterator<ImageUsageFlagBits> for ImageUsageFlags {
    fn from_iter<T: std::iter::IntoIterator<Item = ImageUsageFlagBits>>(iterator: T) -> ImageUsageFlags {
        let mut out = ImageUsageFlags::empty();
        out.extend(iterator);
        out
    }
}
impl std::fmt::Debug for ImageUsageFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(ImageUsageFlags);
        impl std::fmt::Debug for Flags {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == ImageUsageFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(ImageUsageFlags::ImageUsageTransferSrc) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(ImageUsageTransferSrc))?;
                    }
                    if self.0.contains(ImageUsageFlags::ImageUsageTransferDst) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(ImageUsageTransferDst))?;
                    }
                    if self.0.contains(ImageUsageFlags::ImageUsageSampled) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(ImageUsageSampled))?;
                    }
                    if self.0.contains(ImageUsageFlags::ImageUsageStorage) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(ImageUsageStorage))?;
                    }
                    if self.0.contains(ImageUsageFlags::ImageUsageColorAttachment) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(ImageUsageColorAttachment))?;
                    }
                    if self.0.contains(ImageUsageFlags::ImageUsageDepthStencilAttachment) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(ImageUsageDepthStencilAttachment))?;
                    }
                    if self.0.contains(ImageUsageFlags::ImageUsageTransientAttachment) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(ImageUsageTransientAttachment))?;
                    }
                    if self.0.contains(ImageUsageFlags::ImageUsageInputAttachment) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(ImageUsageInputAttachment))?;
                    }
                    if self.0.contains(ImageUsageFlags::VideoDecodeDstKhr) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(VideoDecodeDstKhr))?;
                    }
                    if self.0.contains(ImageUsageFlags::VideoDecodeSrcKhr) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(VideoDecodeSrcKhr))?;
                    }
                    if self.0.contains(ImageUsageFlags::VideoDecodeDpbKhr) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(VideoDecodeDpbKhr))?;
                    }
                    if self.0.contains(ImageUsageFlags::Reserved16Qcom) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(Reserved16Qcom))?;
                    }
                    if self.0.contains(ImageUsageFlags::Reserved17Qcom) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(Reserved17Qcom))?;
                    }
                    if self.0.contains(ImageUsageFlags::FragmentDensityMapExt) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(FragmentDensityMapExt))?;
                    }
                    if self.0.contains(ImageUsageFlags::FragmentShadingRateAttachmentKhr) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(FragmentShadingRateAttachmentKhr))?;
                    }
                    if self.0.contains(ImageUsageFlags::Reserved22Ext) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(Reserved22Ext))?;
                    }
                    if self.0.contains(ImageUsageFlags::VideoEncodeDstKhr) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(VideoEncodeDstKhr))?;
                    }
                    if self.0.contains(ImageUsageFlags::VideoEncodeSrcKhr) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(VideoEncodeSrcKhr))?;
                    }
                    if self.0.contains(ImageUsageFlags::VideoEncodeDpbKhr) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(VideoEncodeDpbKhr))?;
                    }
                    if self.0.contains(ImageUsageFlags::Reserved19Ext) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(Reserved19Ext))?;
                    }
                    if self.0.contains(ImageUsageFlags::InvocationMaskHuawei) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(InvocationMaskHuawei))?;
                    }
                    if self.0.contains(ImageUsageFlags::Reserved20Qcom) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(Reserved20Qcom))?;
                    }
                    if self.0.contains(ImageUsageFlags::Reserved21Qcom) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(Reserved21Qcom))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(ImageUsageFlags)).field(&Flags(*self)).finish()
    }
}
///[VkImageCreateFlagBits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageCreateFlagBits.html) - Bitmask specifying additional parameters of an image
///# C Specifications
///Bits which  **can**  be set in [`ImageCreateInfo::flags`], specifying
///additional parameters of an image, are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkImageCreateFlagBits {
///    VK_IMAGE_CREATE_SPARSE_BINDING_BIT = 0x00000001,
///    VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT = 0x00000002,
///    VK_IMAGE_CREATE_SPARSE_ALIASED_BIT = 0x00000004,
///    VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT = 0x00000008,
///    VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT = 0x00000010,
///  // Provided by VK_VERSION_1_1
///    VK_IMAGE_CREATE_ALIAS_BIT = 0x00000400,
///  // Provided by VK_VERSION_1_1
///    VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT = 0x00000040,
///  // Provided by VK_VERSION_1_1
///    VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT = 0x00000020,
///  // Provided by VK_VERSION_1_1
///    VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT = 0x00000080,
///  // Provided by VK_VERSION_1_1
///    VK_IMAGE_CREATE_EXTENDED_USAGE_BIT = 0x00000100,
///  // Provided by VK_VERSION_1_1
///    VK_IMAGE_CREATE_PROTECTED_BIT = 0x00000800,
///  // Provided by VK_VERSION_1_1
///    VK_IMAGE_CREATE_DISJOINT_BIT = 0x00000200,
///  // Provided by VK_NV_corner_sampled_image
///    VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV = 0x00002000,
///  // Provided by VK_EXT_sample_locations
///    VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT = 0x00001000,
///  // Provided by VK_EXT_fragment_density_map
///    VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT = 0x00004000,
///  // Provided by VK_QCOM_fragment_density_map_offset
///    VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_QCOM = 0x00008000,
///  // Provided by VK_KHR_bind_memory2 with VK_KHR_device_group
///    VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR =
/// VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT,
///  // Provided by VK_KHR_maintenance1
///    VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT_KHR = VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT,
///  // Provided by VK_KHR_maintenance2
///    VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT_KHR =
/// VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT,
///  // Provided by VK_KHR_maintenance2
///    VK_IMAGE_CREATE_EXTENDED_USAGE_BIT_KHR = VK_IMAGE_CREATE_EXTENDED_USAGE_BIT,
///  // Provided by VK_KHR_sampler_ycbcr_conversion
///    VK_IMAGE_CREATE_DISJOINT_BIT_KHR = VK_IMAGE_CREATE_DISJOINT_BIT,
///  // Provided by VK_KHR_bind_memory2
///    VK_IMAGE_CREATE_ALIAS_BIT_KHR = VK_IMAGE_CREATE_ALIAS_BIT,
///} VkImageCreateFlagBits;
///```
///# Description
/// - [`ImageCreateSparseBinding`] specifies that the image will be backed using sparse memory
///   binding.
/// - [`ImageCreateSparseResidency`] specifies that the image  **can**  be partially backed using
///   sparse memory binding. Images created with this flag  **must**  also be created with the
///   [`ImageCreateSparseBinding`] flag.
/// - [`ImageCreateSparseAliased`] specifies that the image will be backed using sparse memory
///   binding with memory ranges that might also simultaneously be backing another image (or another
///   portion of the same image). Images created with this flag  **must**  also be created with the
///   [`ImageCreateSparseBinding`] flag.
/// - [`ImageCreateMutableFormat`] specifies that the image  **can**  be used to create a [`ImageView`] with a different format from the image. For [multi-planar](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#formats-requiring-sampler-ycbcr-conversion) formats, [`ImageCreateMutableFormat`] specifies that a [`ImageView`] can be created of a *plane* of the image.
/// - [`ImageCreateCubeCompatible`] specifies that the image  **can**  be used to create a
///   [`ImageView`] of type `VK_IMAGE_VIEW_TYPE_CUBE` or `VK_IMAGE_VIEW_TYPE_CUBE_ARRAY`.
/// - [`2DArrayCompatible`] specifies that the image  **can**  be used to create a [`ImageView`] of
///   type `VK_IMAGE_VIEW_TYPE_2D` or `VK_IMAGE_VIEW_TYPE_2D_ARRAY`.
/// - [`Protected`] specifies that the image is a protected image.
/// - [`SplitInstanceBindRegions`] specifies that the image  **can**  be used with a non-zero value
///   of the `splitInstanceBindRegionCount` member of a [`BindImageMemoryDeviceGroupInfo`] structure
///   passed into [`BindImageMemory2`]. This flag also has the effect of making the image use the
///   standard sparse image block dimensions.
/// - [`BlockTexelViewCompatible`] specifies that the image having a compressed format  **can**  be
///   used to create a [`ImageView`] with an uncompressed format where each texel in the image view
///   corresponds to a compressed texel block of the image.
/// - [`ExtendedUsage`] specifies that the image  **can**  be created with usage flags that are not
///   supported for the format the image is created with but are supported for at least one format a
///   [`ImageView`] created from the image  **can**  have.
/// - [`Disjoint`] specifies that an image with a [multi-planar format](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#formats-requiring-sampler-ycbcr-conversion)
///   **must**  have each plane separately bound to memory, rather than having a single memory
///   binding for the whole image; the presence of this bit distinguishes a *disjoint image* from an
///   image without this bit set.
/// - [`Alias`] specifies that two images created with     the same creation parameters and aliased to the same memory  **can**      interpret the contents of the memory consistently with each other,     subject to the rules described in the [Memory     Aliasing](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#resources-memory-aliasing) section.     This flag further specifies that each plane of a *disjoint* image  **can**      share an in-memory non-linear representation with single-plane images,     and that a single-plane image  **can**  share an in-memory non-linear     representation with a plane of a multi-planar disjoint image, according     to the rules in [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#formats-compatible-planes](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#formats-compatible-planes).     If the `pNext` chain includes a [`ExternalMemoryImageCreateInfo`] or [`ExternalMemoryImageCreateInfoNV`]     structure whose `handleTypes` member is not `0`, it is as if     [`Alias`] is set.
/// - [`SampleLocationsCompatibleDepthExt`] specifies that an image with a depth or depth/stencil
///   format  **can**  be used with custom sample locations when used as a depth/stencil attachment.
/// - [`CornerSampledNv`] specifies that the image is a [corner-sampled image](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#resources-images-corner-sampled).
/// - [`SubsampledExt`] specifies that an image  **can**  be in a subsampled format which  **may**  be more optimal when written as an attachment by a render pass that has a fragment density map attachment. Accessing a subsampled image has additional considerations:  - Image data read as an image sampler will have undefined values if the sampler was not created with `flags` containing `VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT` or was not sampled through the use of a combined image sampler with an immutable sampler in [`DescriptorSetLayoutBinding`].  - Image data read with an input attachment will have undefined values if the contents were not written as an attachment in an earlier subpass of the same render pass.  - Image data read as an image sampler in the fragment shader will be additionally be read by the device during `VK_PIPELINE_STAGE_VERTEX_SHADER_BIT` if [[`PhysicalDeviceFragmentDensityMap2PropertiesEXT::subsampled_coarse_reconstruction_early_access`]](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#limits-subsampledCoarseReconstructionEarlyAccess) is [`TRUE`] and the sampler was created with `flags` containing `VK_SAMPLER_CREATE_SUBSAMPLED_COARSE_RECONSTRUCTION_BIT_EXT`.  - Image data read with load operations are resampled to the fragment density of the render pass if [[`PhysicalDeviceFragmentDensityMap2PropertiesEXT::subsampled_loads`]](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#limits-subsampledLoads) is [`TRUE`]. Otherwise, values of image data are undefined.  - Image contents outside of the render area take on undefined values if the image is stored as a render pass attachment.
/// - [`FragmentDensityMapOffsetQcom`] specifies that an image  **can**  be used in a render pass with non-zero [fragment density map offsets](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-fragmentdensitymapoffsets). In a renderpass with non-zero offsets, fragment density map attachments, input attachments, color attachments, depth/stencil attachment, resolve attachments, and preserve attachments  **must**  be created with VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_QCOM.
///See [Sparse Resource Features](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#sparsememory-sparseresourcefeatures) and
///[Sparse Physical Device Features](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#sparsememory-physicalfeatures) for more
///details.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`ImageCreateFlags`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(transparent)]
pub struct ImageCreateFlags(u32);
impl const Default for ImageCreateFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl From<ImageCreateFlagBits> for ImageCreateFlags {
    fn from(from: ImageCreateFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(from as u32) }
    }
}
impl ImageCreateFlags {
    ///[`ImageCreateSparseBinding`] specifies that the image will
    ///be backed using sparse memory binding.
    const ImageCreateSparseBinding: Self = Self(1);
    ///[`ImageCreateSparseResidency`] specifies that the image  **can**
    ///be partially backed using sparse memory binding.
    ///Images created with this flag  **must**  also be created with the
    ///[`ImageCreateSparseBinding`] flag.
    const ImageCreateSparseResidency: Self = Self(2);
    ///[`ImageCreateSparseAliased`] specifies that the image will
    ///be backed using sparse memory binding with memory ranges that might also
    ///simultaneously be backing another image (or another portion of the same
    ///image).
    ///Images created with this flag  **must**  also be created with the
    ///[`ImageCreateSparseBinding`] flag.
    const ImageCreateSparseAliased: Self = Self(4);
    ///[`ImageCreateMutableFormat`] specifies that the image  **can**
    ///be used to create a [`ImageView`] with a different format from the
    ///image.
    ///For [multi-planar](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#formats-requiring-sampler-ycbcr-conversion) formats,
    ///[`ImageCreateMutableFormat`] specifies that a
    ///[`ImageView`] can be created of a *plane* of the image.
    const ImageCreateMutableFormat: Self = Self(8);
    ///[`ImageCreateCubeCompatible`] specifies that the image  **can**
    ///be used to create a [`ImageView`] of type
    ///`VK_IMAGE_VIEW_TYPE_CUBE` or `VK_IMAGE_VIEW_TYPE_CUBE_ARRAY`.
    const ImageCreateCubeCompatible: Self = Self(16);
    ///[`Alias`] specifies that two images created with
    ///    the same creation parameters and aliased to the same memory  **can**
    ///    interpret the contents of the memory consistently with each other,
    ///    subject to the rules described in the [Memory
    ///    Aliasing](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#resources-memory-aliasing) section.
    ///    This flag further specifies that each plane of a *disjoint* image  **can**
    ///    share an in-memory non-linear representation with single-plane images,
    ///    and that a single-plane image  **can**  share an in-memory non-linear
    ///    representation with a plane of a multi-planar disjoint image, according
    ///    to the rules in [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#formats-compatible-planes](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#formats-compatible-planes).
    ///    If the `pNext` chain includes a
    ///[`ExternalMemoryImageCreateInfo`]
    ///or
    ///[`ExternalMemoryImageCreateInfoNV`]
    ///    structure whose `handleTypes` member is not `0`, it is as if
    ///    [`Alias`] is set.
    ///
    ///Provided by [`crate::vulkan1_1`]
    const Alias: Self = Self(1024);
    ///[`SplitInstanceBindRegions`] specifies that the
    ///image  **can**  be used with a non-zero value of the
    ///`splitInstanceBindRegionCount` member of a
    ///[`BindImageMemoryDeviceGroupInfo`] structure passed into
    ///[`BindImageMemory2`].
    ///This flag also has the effect of making the image use the standard
    ///sparse image block dimensions.
    ///
    ///Provided by [`crate::vulkan1_1`]
    const SplitInstanceBindRegions: Self = Self(64);
    ///[`2DArrayCompatible`] specifies that the image
    /// **can**  be used to create a [`ImageView`] of type
    ///`VK_IMAGE_VIEW_TYPE_2D` or `VK_IMAGE_VIEW_TYPE_2D_ARRAY`.
    ///
    ///Provided by [`crate::vulkan1_1`]
    const _2DArrayCompatible: Self = Self(32);
    ///[`BlockTexelViewCompatible`] specifies that the
    ///image having a compressed format  **can**  be used to create a
    ///[`ImageView`] with an uncompressed format where each texel in the
    ///image view corresponds to a compressed texel block of the image.
    ///
    ///Provided by [`crate::vulkan1_1`]
    const BlockTexelViewCompatible: Self = Self(128);
    ///[`ExtendedUsage`] specifies that the image  **can**
    ///be created with usage flags that are not supported for the format the
    ///image is created with but are supported for at least one format a
    ///[`ImageView`] created from the image  **can**  have.
    ///
    ///Provided by [`crate::vulkan1_1`]
    const ExtendedUsage: Self = Self(256);
    ///[`Protected`] specifies that the image is a
    ///protected image.
    ///
    ///Provided by [`crate::vulkan1_1`]
    const Protected: Self = Self(2048);
    ///[`Disjoint`] specifies that an image with a
    ///[multi-planar format](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#formats-requiring-sampler-ycbcr-conversion) **must**
    ///have each plane separately bound to memory, rather than having a single
    ///memory binding for the whole image; the presence of this bit
    ///distinguishes a *disjoint image* from an image without this bit set.
    ///
    ///Provided by [`crate::vulkan1_1`]
    const Disjoint: Self = Self(512);
    ///[`CornerSampledNv`] specifies that the image is
    ///a [corner-sampled image](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#resources-images-corner-sampled).
    ///
    ///Provided by [`crate::extensions::nv_corner_sampled_image`]
    const CornerSampledNv: Self = Self(8192);
    ///[`SampleLocationsCompatibleDepthExt`]
    ///specifies that an image with a depth or depth/stencil format  **can**  be
    ///used with custom sample locations when used as a depth/stencil
    ///attachment.
    ///
    ///Provided by [`crate::extensions::ext_sample_locations`]
    const SampleLocationsCompatibleDepthExt: Self = Self(4096);
    ///[`SubsampledExt`] specifies that an image  **can**  be
    ///in a subsampled format which  **may**  be more optimal when written as an
    ///attachment by a render pass that has a fragment density map attachment.
    ///Accessing a subsampled image has additional considerations:
    /// - Image data read as an image sampler will have undefined values if the sampler was not
    ///   created with `flags` containing `VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT` or was not sampled
    ///   through the use of a combined image sampler with an immutable sampler in
    ///   [`DescriptorSetLayoutBinding`].
    /// - Image data read with an input attachment will have undefined values if the contents were
    ///   not written as an attachment in an earlier subpass of the same render pass.
    /// - Image data read as an image sampler in the fragment shader will be additionally be read by
    ///   the device during `VK_PIPELINE_STAGE_VERTEX_SHADER_BIT` if [[`PhysicalDeviceFragmentDensityMap2PropertiesEXT`]::`subsampledCoarseReconstructionEarlyAccess`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#limits-subsampledCoarseReconstructionEarlyAccess)
    ///   is [`TRUE`] and the sampler was created with `flags` containing
    ///   `VK_SAMPLER_CREATE_SUBSAMPLED_COARSE_RECONSTRUCTION_BIT_EXT`.
    /// - Image data read with load operations are resampled to the fragment density of the render pass if [[`PhysicalDeviceFragmentDensityMap2PropertiesEXT`]::`subsampledLoads`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#limits-subsampledLoads) is [`TRUE`]. Otherwise, values of image data are undefined.
    /// - Image contents outside of the render area take on undefined values if the image is stored
    ///   as a render pass attachment.
    ///
    ///Provided by [`crate::extensions::ext_fragment_density_map`]
    const SubsampledExt: Self = Self(16384);
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::amd_extension_317`]
    const Reserved16Amd: Self = Self(65536);
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_extension_377`]
    const Reserved18Ext: Self = Self(262144);
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::ext_extension_394`]
    const Reserved394Ext: Self = Self(131072);
    ///[`FragmentDensityMapOffsetQcom`] specifies
    ///that an image  **can**  be used in a render pass with non-zero
    ///[fragment density map offsets](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-fragmentdensitymapoffsets).
    ///In a renderpass with non-zero offsets, fragment density map attachments,
    ///input attachments, color attachments, depth/stencil attachment, resolve
    ///attachments, and preserve attachments  **must**  be created with
    ///VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_QCOM.
    ///
    ///Provided by [`crate::extensions::qcom_fragment_density_map_offset`]
    const FragmentDensityMapOffsetQcom: Self = Self(32768);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    pub const fn all() -> Self {
        Self::empty()
            | Self::ImageCreateSparseBinding
            | Self::ImageCreateSparseResidency
            | Self::ImageCreateSparseAliased
            | Self::ImageCreateMutableFormat
            | Self::ImageCreateCubeCompatible
            | Self::Alias
            | Self::SplitInstanceBindRegions
            | Self::_2DArrayCompatible
            | Self::BlockTexelViewCompatible
            | Self::ExtendedUsage
            | Self::Protected
            | Self::Disjoint
            | Self::CornerSampledNv
            | Self::SampleLocationsCompatibleDepthExt
            | Self::SubsampledExt
            | Self::Reserved16Amd
            | Self::Reserved18Ext
            | Self::Reserved394Ext
            | Self::FragmentDensityMapOffsetQcom
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl const std::ops::BitOr for ImageCreateFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl std::ops::BitOrAssign for ImageCreateFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl const std::ops::BitXor for ImageCreateFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl std::ops::BitXorAssign for ImageCreateFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl const std::ops::BitAnd for ImageCreateFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl std::ops::BitAndAssign for ImageCreateFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl const std::ops::Sub for ImageCreateFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl std::ops::SubAssign for ImageCreateFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl const std::ops::Not for ImageCreateFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl std::iter::Extend<ImageCreateFlags> for ImageCreateFlags {
    fn extend<T: std::iter::IntoIterator<Item = ImageCreateFlags>>(&mut self, iterator: T) {
        for i in iterator {
            self.insert(i);
        }
    }
}
impl std::iter::Extend<ImageCreateFlagBits> for ImageCreateFlags {
    fn extend<T: std::iter::IntoIterator<Item = ImageCreateFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            self.insert(ImageCreateFlags::from(i));
        }
    }
}
impl std::iter::FromIterator<ImageCreateFlags> for ImageCreateFlags {
    fn from_iter<T: std::iter::IntoIterator<Item = ImageCreateFlags>>(iterator: T) -> ImageCreateFlags {
        let mut out = ImageCreateFlags::empty();
        out.extend(iterator);
        out
    }
}
impl std::iter::FromIterator<ImageCreateFlagBits> for ImageCreateFlags {
    fn from_iter<T: std::iter::IntoIterator<Item = ImageCreateFlagBits>>(iterator: T) -> ImageCreateFlags {
        let mut out = ImageCreateFlags::empty();
        out.extend(iterator);
        out
    }
}
impl std::fmt::Debug for ImageCreateFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(ImageCreateFlags);
        impl std::fmt::Debug for Flags {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == ImageCreateFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(ImageCreateFlags::ImageCreateSparseBinding) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(ImageCreateSparseBinding))?;
                    }
                    if self.0.contains(ImageCreateFlags::ImageCreateSparseResidency) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(ImageCreateSparseResidency))?;
                    }
                    if self.0.contains(ImageCreateFlags::ImageCreateSparseAliased) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(ImageCreateSparseAliased))?;
                    }
                    if self.0.contains(ImageCreateFlags::ImageCreateMutableFormat) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(ImageCreateMutableFormat))?;
                    }
                    if self.0.contains(ImageCreateFlags::ImageCreateCubeCompatible) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(ImageCreateCubeCompatible))?;
                    }
                    if self.0.contains(ImageCreateFlags::Alias) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(Alias))?;
                    }
                    if self.0.contains(ImageCreateFlags::SplitInstanceBindRegions) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(SplitInstanceBindRegions))?;
                    }
                    if self.0.contains(ImageCreateFlags::_2DArrayCompatible) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(_2DArrayCompatible))?;
                    }
                    if self.0.contains(ImageCreateFlags::BlockTexelViewCompatible) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(BlockTexelViewCompatible))?;
                    }
                    if self.0.contains(ImageCreateFlags::ExtendedUsage) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(ExtendedUsage))?;
                    }
                    if self.0.contains(ImageCreateFlags::Protected) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(Protected))?;
                    }
                    if self.0.contains(ImageCreateFlags::Disjoint) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(Disjoint))?;
                    }
                    if self.0.contains(ImageCreateFlags::CornerSampledNv) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(CornerSampledNv))?;
                    }
                    if self.0.contains(ImageCreateFlags::SampleLocationsCompatibleDepthExt) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(SampleLocationsCompatibleDepthExt))?;
                    }
                    if self.0.contains(ImageCreateFlags::SubsampledExt) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(SubsampledExt))?;
                    }
                    if self.0.contains(ImageCreateFlags::Reserved16Amd) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(Reserved16Amd))?;
                    }
                    if self.0.contains(ImageCreateFlags::Reserved18Ext) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(Reserved18Ext))?;
                    }
                    if self.0.contains(ImageCreateFlags::Reserved394Ext) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(Reserved394Ext))?;
                    }
                    if self.0.contains(ImageCreateFlags::FragmentDensityMapOffsetQcom) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(FragmentDensityMapOffsetQcom))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(ImageCreateFlags))
            .field(&Flags(*self))
            .finish()
    }
}
///[VkImageViewCreateFlagBits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageViewCreateFlagBits.html) - Bitmask specifying additional parameters of an image view
///# C Specifications
///Bits which  **can**  be set in [`ImageViewCreateInfo::flags`],
///specifying additional parameters of an image view, are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkImageViewCreateFlagBits {
///  // Provided by VK_EXT_fragment_density_map
///    VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT = 0x00000001,
///  // Provided by VK_EXT_fragment_density_map2
///    VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DEFERRED_BIT_EXT = 0x00000002,
///} VkImageViewCreateFlagBits;
///```
///# Description
/// - [`FragmentDensityMapDynamicExt`] specifies that the fragment density map will be read by
///   device during `VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT`
/// - [`FragmentDensityMapDeferredExt`] specifies that the fragment density map will be read by the
///   host during [`EndCommandBuffer`] for the primary command buffer that the render pass is
///   recorded into
///# Related
/// - [`crate::vulkan1_0`]
/// - [`ImageViewCreateFlags`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(transparent)]
pub struct ImageViewCreateFlags(u32);
impl const Default for ImageViewCreateFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl From<ImageViewCreateFlagBits> for ImageViewCreateFlags {
    fn from(from: ImageViewCreateFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(from as u32) }
    }
}
impl ImageViewCreateFlags {
    ///[`FragmentDensityMapDynamicExt`]
    ///specifies that the fragment density map will be read by device during
    ///`VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT`
    ///
    ///Provided by [`crate::extensions::ext_fragment_density_map`]
    const FragmentDensityMapDynamicExt: Self = Self(1);
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::amd_extension_317`]
    const Reserved2Amd: Self = Self(4);
    ///[`FragmentDensityMapDeferredExt`]
    ///specifies that the fragment density map will be read by the host during
    ///[`EndCommandBuffer`] for the primary command buffer that the render
    ///pass is recorded into
    ///
    ///Provided by [`crate::extensions::ext_fragment_density_map_2`]
    const FragmentDensityMapDeferredExt: Self = Self(2);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    pub const fn all() -> Self {
        Self::empty() | Self::FragmentDensityMapDynamicExt | Self::Reserved2Amd | Self::FragmentDensityMapDeferredExt
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl const std::ops::BitOr for ImageViewCreateFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl std::ops::BitOrAssign for ImageViewCreateFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl const std::ops::BitXor for ImageViewCreateFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl std::ops::BitXorAssign for ImageViewCreateFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl const std::ops::BitAnd for ImageViewCreateFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl std::ops::BitAndAssign for ImageViewCreateFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl const std::ops::Sub for ImageViewCreateFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl std::ops::SubAssign for ImageViewCreateFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl const std::ops::Not for ImageViewCreateFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl std::iter::Extend<ImageViewCreateFlags> for ImageViewCreateFlags {
    fn extend<T: std::iter::IntoIterator<Item = ImageViewCreateFlags>>(&mut self, iterator: T) {
        for i in iterator {
            self.insert(i);
        }
    }
}
impl std::iter::Extend<ImageViewCreateFlagBits> for ImageViewCreateFlags {
    fn extend<T: std::iter::IntoIterator<Item = ImageViewCreateFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            self.insert(ImageViewCreateFlags::from(i));
        }
    }
}
impl std::iter::FromIterator<ImageViewCreateFlags> for ImageViewCreateFlags {
    fn from_iter<T: std::iter::IntoIterator<Item = ImageViewCreateFlags>>(iterator: T) -> ImageViewCreateFlags {
        let mut out = ImageViewCreateFlags::empty();
        out.extend(iterator);
        out
    }
}
impl std::iter::FromIterator<ImageViewCreateFlagBits> for ImageViewCreateFlags {
    fn from_iter<T: std::iter::IntoIterator<Item = ImageViewCreateFlagBits>>(iterator: T) -> ImageViewCreateFlags {
        let mut out = ImageViewCreateFlags::empty();
        out.extend(iterator);
        out
    }
}
impl std::fmt::Debug for ImageViewCreateFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(ImageViewCreateFlags);
        impl std::fmt::Debug for Flags {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == ImageViewCreateFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(ImageViewCreateFlags::FragmentDensityMapDynamicExt) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(FragmentDensityMapDynamicExt))?;
                    }
                    if self.0.contains(ImageViewCreateFlags::Reserved2Amd) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(Reserved2Amd))?;
                    }
                    if self.0.contains(ImageViewCreateFlags::FragmentDensityMapDeferredExt) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(FragmentDensityMapDeferredExt))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(ImageViewCreateFlags))
            .field(&Flags(*self))
            .finish()
    }
}
///[VkPipelineCreateFlagBits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineCreateFlagBits.html) - Bitmask controlling how a pipeline is created
///# C Specifications
///Bits which  **can**  be set in
///  * [`GraphicsPipelineCreateInfo::flags`]
///  * [`ComputePipelineCreateInfo::flags`]
///  * [`RayTracingPipelineCreateInfoKHR::flags`]
///  * [`RayTracingPipelineCreateInfoNV::flags`]
///specify how a pipeline is created, and are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkPipelineCreateFlagBits {
///    VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT = 0x00000001,
///    VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT = 0x00000002,
///    VK_PIPELINE_CREATE_DERIVATIVE_BIT = 0x00000004,
///  // Provided by VK_VERSION_1_1
///    VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT = 0x00000008,
///  // Provided by VK_VERSION_1_1
///    VK_PIPELINE_CREATE_DISPATCH_BASE_BIT = 0x00000010,
///  // Provided by VK_VERSION_1_3
///    VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT = 0x00000100,
///  // Provided by VK_VERSION_1_3
///    VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT = 0x00000200,
///  // Provided by VK_KHR_dynamic_rendering with VK_KHR_fragment_shading_rate
///    VK_PIPELINE_CREATE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = 0x00200000,
///  // Provided by VK_KHR_dynamic_rendering with VK_EXT_fragment_density_map
///    VK_PIPELINE_CREATE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT = 0x00400000,
///  // Provided by VK_KHR_ray_tracing_pipeline
///    VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR = 0x00004000,
///  // Provided by VK_KHR_ray_tracing_pipeline
///    VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR = 0x00008000,
///  // Provided by VK_KHR_ray_tracing_pipeline
///    VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR = 0x00010000,
///  // Provided by VK_KHR_ray_tracing_pipeline
///    VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR = 0x00020000,
///  // Provided by VK_KHR_ray_tracing_pipeline
///    VK_PIPELINE_CREATE_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR = 0x00001000,
///  // Provided by VK_KHR_ray_tracing_pipeline
///    VK_PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR = 0x00002000,
///  // Provided by VK_KHR_ray_tracing_pipeline
///    VK_PIPELINE_CREATE_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR = 0x00080000,
///  // Provided by VK_NV_ray_tracing
///    VK_PIPELINE_CREATE_DEFER_COMPILE_BIT_NV = 0x00000020,
///  // Provided by VK_KHR_pipeline_executable_properties
///    VK_PIPELINE_CREATE_CAPTURE_STATISTICS_BIT_KHR = 0x00000040,
///  // Provided by VK_KHR_pipeline_executable_properties
///    VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR = 0x00000080,
///  // Provided by VK_NV_device_generated_commands
///    VK_PIPELINE_CREATE_INDIRECT_BINDABLE_BIT_NV = 0x00040000,
///  // Provided by VK_KHR_pipeline_library
///    VK_PIPELINE_CREATE_LIBRARY_BIT_KHR = 0x00000800,
///  // Provided by VK_NV_ray_tracing_motion_blur
///    VK_PIPELINE_CREATE_RAY_TRACING_ALLOW_MOTION_BIT_NV = 0x00100000,
///  // Provided by VK_VERSION_1_1
///    VK_PIPELINE_CREATE_DISPATCH_BASE = VK_PIPELINE_CREATE_DISPATCH_BASE_BIT,
///  // Provided by VK_KHR_dynamic_rendering with VK_KHR_fragment_shading_rate
///    VK_PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR =
/// VK_PIPELINE_CREATE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR,
///  // Provided by VK_KHR_dynamic_rendering with VK_EXT_fragment_density_map
///    VK_PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT =
/// VK_PIPELINE_CREATE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT,
///  // Provided by VK_KHR_device_group
///    VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR =
/// VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT,
///  // Provided by VK_KHR_device_group
///    VK_PIPELINE_CREATE_DISPATCH_BASE_KHR = VK_PIPELINE_CREATE_DISPATCH_BASE,
///  // Provided by VK_EXT_pipeline_creation_cache_control
///    VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT_EXT =
/// VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT,
///  // Provided by VK_EXT_pipeline_creation_cache_control
///    VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT_EXT =
/// VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT,
///} VkPipelineCreateFlagBits;
///```
///# Description
/// - [`PipelineCreateDisableOptimization`] specifies that the created pipeline will not be
///   optimized. Using this flag  **may**  reduce the time taken to create the pipeline.
/// - [`PipelineCreateAllowDerivatives`] specifies that the pipeline to be created is allowed to be
///   the parent of a pipeline that will be created in a subsequent pipeline creation call.
/// - [`PipelineCreateDerivative`] specifies that the pipeline to be created will be a child of a
///   previously created parent pipeline.
/// - [`ViewIndexFromDeviceIndex`] specifies that any shader input variables decorated as
///   `ViewIndex` will be assigned values as if they were decorated as `DeviceIndex`.
/// - [`DispatchBase`] specifies that a compute pipeline  **can**  be used with [`CmdDispatchBase`]
///   with a non-zero base workgroup.
/// - [`DeferCompileNv`] specifies that a pipeline is created with all shaders in the deferred
///   state. Before using the pipeline the application  **must**  call [`CompileDeferredNV`] exactly
///   once on each shader in the pipeline before using the pipeline.
/// - [`CaptureStatisticsKhr`] specifies that the shader compiler should capture statistics for the
///   pipeline executables produced by the compile process which  **can**  later be retrieved by
///   calling [`GetPipelineExecutableStatisticsKHR`]. Enabling this flag  **must**  not affect the
///   final compiled pipeline but  **may**  disable pipeline caching or otherwise affect pipeline
///   creation time.
/// - [`CaptureInternalRepresentationsKhr`] specifies that the shader compiler should capture the
///   internal representations of pipeline executables produced by the compile process which
///   **can**  later be retrieved by calling [`GetPipelineExecutableInternalRepresentationsKHR`].
///   Enabling this flag  **must**  not affect the final compiled pipeline but  **may**  disable
///   pipeline caching or otherwise affect pipeline creation time.
/// - [`LibraryKhr`] specifies that the pipeline  **cannot**  be used directly, and instead defines
///   a *pipeline library* that  **can**  be combined with other pipelines using the
///   [`PipelineLibraryCreateInfoKHR`] structure. This is available in ray tracing pipelines.
/// - [`RayTracingNoNullAnyHitShadersKhr`] specifies that an any-hit shader will always be present
///   when an any-hit shader would be executed. A NULL any-hit shader is an any-hit shader which is
///   effectively [`SHADER_UNUSED_KHR`], such as from a shader group consisting entirely of zeros.
/// - [`RayTracingNoNullClosestHitShadersKhr`] specifies that a closest hit shader will always be
///   present when a closest hit shader would be executed. A NULL closest hit shader is a closest
///   hit shader which is effectively [`SHADER_UNUSED_KHR`], such as from a shader group consisting
///   entirely of zeros.
/// - [`RayTracingNoNullMissShadersKhr`] specifies that a miss shader will always be present when a
///   miss shader would be executed. A NULL miss shader is a miss shader which is effectively
///   [`SHADER_UNUSED_KHR`], such as from a shader group consisting entirely of zeros.
/// - [`RayTracingNoNullIntersectionShadersKhr`] specifies that an intersection shader will always
///   be present when an intersection shader would be executed. A NULL intersection shader is an
///   intersection shader which is effectively [`SHADER_UNUSED_KHR`], such as from a shader group
///   consisting entirely of zeros.
/// - [`RayTracingSkipTrianglesKhr`] specifies that triangle primitives will be skipped during
///   traversal using `OpTraceRayKHR`.
/// - [`RayTracingSkipAabbsKhr`] specifies that AABB primitives will be skipped during traversal
///   using `OpTraceRayKHR`.
/// - [`RayTracingShaderGroupHandleCaptureReplayKhr`] specifies that the shader group handles
///   **can**  be saved and reused on a subsequent run (e.g. for trace capture and replay).
/// - [`IndirectBindableNv`] specifies that the pipeline can be used in combination with [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#device-generated-commands](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#device-generated-commands).
/// - [`FailOnPipelineCompileRequired`] specifies that pipeline creation will fail if a compile is
///   required for creation of a valid [`Pipeline`] object; `VK_PIPELINE_COMPILE_REQUIRED` will be
///   returned by pipeline creation, and the [`Pipeline`] will be set to
///   [`crate::utils::Handle::null`].
/// - When creating multiple pipelines, [`EarlyReturnOnFailure`] specifies that control will be
///   returned to the application on failure of the corresponding pipeline rather than continuing to
///   create additional pipelines.
/// - [`RayTracingAllowMotionNv`] specifies that the pipeline is allowed to use
///   `OpTraceRayMotionNV`.
/// - [`RenderingFragmentShadingRateAttachmentKhr`] specifies that the pipeline will be used with a
///   fragment shading rate attachment.
/// - [`RenderingFragmentDensityMapAttachmentExt`] specifies that the pipeline will be used with a
///   fragment density map attachment.
///It is valid to set both [`PipelineCreateAllowDerivatives`] and
///[`PipelineCreateDerivative`].
///This allows a pipeline to be both a parent and possibly a child in a
///pipeline hierarchy.
///See [Pipeline Derivatives](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipelines-pipeline-derivatives) for more
///information.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`PipelineCreateFlags`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(transparent)]
pub struct PipelineCreateFlags(u32);
impl const Default for PipelineCreateFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl From<PipelineCreateFlagBits> for PipelineCreateFlags {
    fn from(from: PipelineCreateFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(from as u32) }
    }
}
impl PipelineCreateFlags {
    ///[`PipelineCreateDisableOptimization`] specifies that the
    ///created pipeline will not be optimized.
    ///Using this flag  **may**  reduce the time taken to create the pipeline.
    const PipelineCreateDisableOptimization: Self = Self(1);
    ///[`PipelineCreateAllowDerivatives`] specifies that the
    ///pipeline to be created is allowed to be the parent of a pipeline that
    ///will be created in a subsequent pipeline creation call.
    const PipelineCreateAllowDerivatives: Self = Self(2);
    ///[`PipelineCreateDerivative`] specifies that the pipeline to
    ///be created will be a child of a previously created parent pipeline.
    const PipelineCreateDerivative: Self = Self(4);
    ///[`ViewIndexFromDeviceIndex`] specifies that
    ///any shader input variables decorated as `ViewIndex` will be assigned
    ///values as if they were decorated as `DeviceIndex`.
    ///
    ///Provided by [`crate::vulkan1_1`]
    const ViewIndexFromDeviceIndex: Self = Self(8);
    ///[`DispatchBase`] specifies that a compute pipeline
    /// **can**  be used with [`CmdDispatchBase`] with a non-zero base
    ///workgroup.
    ///
    ///Provided by [`crate::vulkan1_1`]
    const DispatchBase: Self = Self(16);
    ///[`FailOnPipelineCompileRequired`] specifies
    ///that pipeline creation will fail if a compile is required for creation
    ///of a valid [`Pipeline`] object; `VK_PIPELINE_COMPILE_REQUIRED`
    ///will be returned by pipeline creation, and the [`Pipeline`] will be
    ///set to [`crate::utils::Handle::null`].
    ///
    ///Provided by [`crate::vulkan1_3`]
    const FailOnPipelineCompileRequired: Self = Self(256);
    ///When creating multiple pipelines,
    ///[`EarlyReturnOnFailure`] specifies that
    ///control will be returned to the application on failure of the
    ///corresponding pipeline rather than continuing to create additional
    ///pipelines.
    ///
    ///Provided by [`crate::vulkan1_3`]
    const EarlyReturnOnFailure: Self = Self(512);
    ///[`RenderingFragmentShadingRateAttachmentKhr`]
    ///specifies that the pipeline will be used with a fragment shading rate
    ///attachment.
    ///
    ///Provided by [`crate::extensions::khr_dynamic_rendering`]
    const RenderingFragmentShadingRateAttachmentKhr: Self = Self(2097152);
    ///[`RenderingFragmentDensityMapAttachmentExt`]
    ///specifies that the pipeline will be used with a fragment density map
    ///attachment.
    ///
    ///Provided by [`crate::extensions::khr_dynamic_rendering`]
    const RenderingFragmentDensityMapAttachmentExt: Self = Self(4194304);
    ///[`RayTracingNoNullAnyHitShadersKhr`]
    ///specifies that an any-hit shader will always be present when an any-hit
    ///shader would be executed.
    ///A NULL any-hit shader is an any-hit shader which is effectively
    ///[`SHADER_UNUSED_KHR`], such as from a shader group consisting
    ///entirely of zeros.
    ///
    ///Provided by [`crate::extensions::khr_ray_tracing_pipeline`]
    const RayTracingNoNullAnyHitShadersKhr: Self = Self(16384);
    ///[`RayTracingNoNullClosestHitShadersKhr`]
    ///specifies that a closest hit shader will always be present when a
    ///closest hit shader would be executed.
    ///A NULL closest hit shader is a closest hit shader which is effectively
    ///[`SHADER_UNUSED_KHR`], such as from a shader group consisting
    ///entirely of zeros.
    ///
    ///Provided by [`crate::extensions::khr_ray_tracing_pipeline`]
    const RayTracingNoNullClosestHitShadersKhr: Self = Self(32768);
    ///[`RayTracingNoNullMissShadersKhr`]
    ///specifies that a miss shader will always be present when a miss shader
    ///would be executed.
    ///A NULL miss shader is a miss shader which is effectively
    ///[`SHADER_UNUSED_KHR`], such as from a shader group consisting
    ///entirely of zeros.
    ///
    ///Provided by [`crate::extensions::khr_ray_tracing_pipeline`]
    const RayTracingNoNullMissShadersKhr: Self = Self(65536);
    ///[`RayTracingNoNullIntersectionShadersKhr`]
    ///specifies that an intersection shader will always be present when an
    ///intersection shader would be executed.
    ///A NULL intersection shader is an intersection shader which is
    ///effectively [`SHADER_UNUSED_KHR`], such as from a shader group
    ///consisting entirely of zeros.
    ///
    ///Provided by [`crate::extensions::khr_ray_tracing_pipeline`]
    const RayTracingNoNullIntersectionShadersKhr: Self = Self(131072);
    ///[`RayTracingSkipTrianglesKhr`] specifies
    ///that triangle primitives will be skipped during traversal using
    ///`OpTraceRayKHR`.
    ///
    ///Provided by [`crate::extensions::khr_ray_tracing_pipeline`]
    const RayTracingSkipTrianglesKhr: Self = Self(4096);
    ///[`RayTracingSkipAabbsKhr`] specifies that
    ///AABB primitives will be skipped during traversal using
    ///`OpTraceRayKHR`.
    ///
    ///Provided by [`crate::extensions::khr_ray_tracing_pipeline`]
    const RayTracingSkipAabbsKhr: Self = Self(8192);
    ///[`RayTracingShaderGroupHandleCaptureReplayKhr`]
    ///specifies that the shader group handles  **can**  be saved and reused on a
    ///subsequent run (e.g. for trace capture and replay).
    ///
    ///Provided by [`crate::extensions::khr_ray_tracing_pipeline`]
    const RayTracingShaderGroupHandleCaptureReplayKhr: Self = Self(524288);
    ///[`DeferCompileNv`] specifies that a pipeline
    ///is created with all shaders in the deferred state.
    ///Before using the pipeline the application  **must**  call
    ///[`CompileDeferredNV`] exactly once on each shader in the pipeline
    ///before using the pipeline.
    ///
    ///Provided by [`crate::extensions::nv_ray_tracing`]
    const DeferCompileNv: Self = Self(32);
    ///[`CaptureStatisticsKhr`] specifies that the
    ///shader compiler should capture statistics for the pipeline executables
    ///produced by the compile process which  **can**  later be retrieved by calling
    ///[`GetPipelineExecutableStatisticsKHR`].
    ///Enabling this flag  **must**  not affect the final compiled pipeline but  **may**
    ///disable pipeline caching or otherwise affect pipeline creation time.
    ///
    ///Provided by [`crate::extensions::khr_pipeline_executable_properties`]
    const CaptureStatisticsKhr: Self = Self(64);
    ///[`CaptureInternalRepresentationsKhr`]
    ///specifies that the shader compiler should capture the internal
    ///representations of pipeline executables produced by the compile process
    ///which  **can**  later be retrieved by calling
    ///[`GetPipelineExecutableInternalRepresentationsKHR`].
    ///Enabling this flag  **must**  not affect the final compiled pipeline but  **may**
    ///disable pipeline caching or otherwise affect pipeline creation time.
    ///
    ///Provided by [`crate::extensions::khr_pipeline_executable_properties`]
    const CaptureInternalRepresentationsKhr: Self = Self(128);
    ///[`IndirectBindableNv`] specifies that the
    ///pipeline can be used in combination with [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#device-generated-commands](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#device-generated-commands).
    ///
    ///Provided by [`crate::extensions::nv_device_generated_commands`]
    const IndirectBindableNv: Self = Self(262144);
    ///[`LibraryKhr`] specifies that the pipeline
    /// **cannot**  be used directly, and instead defines a *pipeline library* that
    /// **can**  be combined with other pipelines using the
    ///[`PipelineLibraryCreateInfoKHR`] structure.
    ///This is available in ray tracing pipelines.
    ///
    ///Provided by [`crate::extensions::khr_pipeline_library`]
    const LibraryKhr: Self = Self(2048);
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::amd_extension_321`]
    const Reserved23Amd: Self = Self(8388608);
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::amd_extension_321`]
    const Reserved10Amd: Self = Self(1024);
    ///[`RayTracingAllowMotionNv`] specifies that
    ///the pipeline is allowed to use `OpTraceRayMotionNV`.
    ///
    ///Provided by [`crate::extensions::nv_ray_tracing_motion_blur`]
    const RayTracingAllowMotionNv: Self = Self(1048576);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    pub const fn all() -> Self {
        Self::empty()
            | Self::PipelineCreateDisableOptimization
            | Self::PipelineCreateAllowDerivatives
            | Self::PipelineCreateDerivative
            | Self::ViewIndexFromDeviceIndex
            | Self::DispatchBase
            | Self::FailOnPipelineCompileRequired
            | Self::EarlyReturnOnFailure
            | Self::RenderingFragmentShadingRateAttachmentKhr
            | Self::RenderingFragmentDensityMapAttachmentExt
            | Self::RayTracingNoNullAnyHitShadersKhr
            | Self::RayTracingNoNullClosestHitShadersKhr
            | Self::RayTracingNoNullMissShadersKhr
            | Self::RayTracingNoNullIntersectionShadersKhr
            | Self::RayTracingSkipTrianglesKhr
            | Self::RayTracingSkipAabbsKhr
            | Self::RayTracingShaderGroupHandleCaptureReplayKhr
            | Self::DeferCompileNv
            | Self::CaptureStatisticsKhr
            | Self::CaptureInternalRepresentationsKhr
            | Self::IndirectBindableNv
            | Self::LibraryKhr
            | Self::Reserved23Amd
            | Self::Reserved10Amd
            | Self::RayTracingAllowMotionNv
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl const std::ops::BitOr for PipelineCreateFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl std::ops::BitOrAssign for PipelineCreateFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl const std::ops::BitXor for PipelineCreateFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl std::ops::BitXorAssign for PipelineCreateFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl const std::ops::BitAnd for PipelineCreateFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl std::ops::BitAndAssign for PipelineCreateFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl const std::ops::Sub for PipelineCreateFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl std::ops::SubAssign for PipelineCreateFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl const std::ops::Not for PipelineCreateFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl std::iter::Extend<PipelineCreateFlags> for PipelineCreateFlags {
    fn extend<T: std::iter::IntoIterator<Item = PipelineCreateFlags>>(&mut self, iterator: T) {
        for i in iterator {
            self.insert(i);
        }
    }
}
impl std::iter::Extend<PipelineCreateFlagBits> for PipelineCreateFlags {
    fn extend<T: std::iter::IntoIterator<Item = PipelineCreateFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            self.insert(PipelineCreateFlags::from(i));
        }
    }
}
impl std::iter::FromIterator<PipelineCreateFlags> for PipelineCreateFlags {
    fn from_iter<T: std::iter::IntoIterator<Item = PipelineCreateFlags>>(iterator: T) -> PipelineCreateFlags {
        let mut out = PipelineCreateFlags::empty();
        out.extend(iterator);
        out
    }
}
impl std::iter::FromIterator<PipelineCreateFlagBits> for PipelineCreateFlags {
    fn from_iter<T: std::iter::IntoIterator<Item = PipelineCreateFlagBits>>(iterator: T) -> PipelineCreateFlags {
        let mut out = PipelineCreateFlags::empty();
        out.extend(iterator);
        out
    }
}
impl std::fmt::Debug for PipelineCreateFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(PipelineCreateFlags);
        impl std::fmt::Debug for Flags {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == PipelineCreateFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(PipelineCreateFlags::PipelineCreateDisableOptimization) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(PipelineCreateDisableOptimization))?;
                    }
                    if self.0.contains(PipelineCreateFlags::PipelineCreateAllowDerivatives) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(PipelineCreateAllowDerivatives))?;
                    }
                    if self.0.contains(PipelineCreateFlags::PipelineCreateDerivative) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(PipelineCreateDerivative))?;
                    }
                    if self.0.contains(PipelineCreateFlags::ViewIndexFromDeviceIndex) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(ViewIndexFromDeviceIndex))?;
                    }
                    if self.0.contains(PipelineCreateFlags::DispatchBase) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(DispatchBase))?;
                    }
                    if self.0.contains(PipelineCreateFlags::FailOnPipelineCompileRequired) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(FailOnPipelineCompileRequired))?;
                    }
                    if self.0.contains(PipelineCreateFlags::EarlyReturnOnFailure) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(EarlyReturnOnFailure))?;
                    }
                    if self
                        .0
                        .contains(PipelineCreateFlags::RenderingFragmentShadingRateAttachmentKhr)
                    {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(RenderingFragmentShadingRateAttachmentKhr))?;
                    }
                    if self
                        .0
                        .contains(PipelineCreateFlags::RenderingFragmentDensityMapAttachmentExt)
                    {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(RenderingFragmentDensityMapAttachmentExt))?;
                    }
                    if self.0.contains(PipelineCreateFlags::RayTracingNoNullAnyHitShadersKhr) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(RayTracingNoNullAnyHitShadersKhr))?;
                    }
                    if self
                        .0
                        .contains(PipelineCreateFlags::RayTracingNoNullClosestHitShadersKhr)
                    {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(RayTracingNoNullClosestHitShadersKhr))?;
                    }
                    if self.0.contains(PipelineCreateFlags::RayTracingNoNullMissShadersKhr) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(RayTracingNoNullMissShadersKhr))?;
                    }
                    if self
                        .0
                        .contains(PipelineCreateFlags::RayTracingNoNullIntersectionShadersKhr)
                    {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(RayTracingNoNullIntersectionShadersKhr))?;
                    }
                    if self.0.contains(PipelineCreateFlags::RayTracingSkipTrianglesKhr) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(RayTracingSkipTrianglesKhr))?;
                    }
                    if self.0.contains(PipelineCreateFlags::RayTracingSkipAabbsKhr) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(RayTracingSkipAabbsKhr))?;
                    }
                    if self
                        .0
                        .contains(PipelineCreateFlags::RayTracingShaderGroupHandleCaptureReplayKhr)
                    {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(RayTracingShaderGroupHandleCaptureReplayKhr))?;
                    }
                    if self.0.contains(PipelineCreateFlags::DeferCompileNv) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(DeferCompileNv))?;
                    }
                    if self.0.contains(PipelineCreateFlags::CaptureStatisticsKhr) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(CaptureStatisticsKhr))?;
                    }
                    if self.0.contains(PipelineCreateFlags::CaptureInternalRepresentationsKhr) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(CaptureInternalRepresentationsKhr))?;
                    }
                    if self.0.contains(PipelineCreateFlags::IndirectBindableNv) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(IndirectBindableNv))?;
                    }
                    if self.0.contains(PipelineCreateFlags::LibraryKhr) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(LibraryKhr))?;
                    }
                    if self.0.contains(PipelineCreateFlags::Reserved23Amd) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(Reserved23Amd))?;
                    }
                    if self.0.contains(PipelineCreateFlags::Reserved10Amd) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(Reserved10Amd))?;
                    }
                    if self.0.contains(PipelineCreateFlags::RayTracingAllowMotionNv) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(RayTracingAllowMotionNv))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(PipelineCreateFlags))
            .field(&Flags(*self))
            .finish()
    }
}
///[VkColorComponentFlagBits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkColorComponentFlagBits.html) - Bitmask controlling which components are written to the framebuffer
///# C Specifications
///Bits which  **can**  be set in
///[`PipelineColorBlendAttachmentState::color_write_mask`], determining
///whether the final color values R, G, B and A are written to the
///framebuffer attachment, are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkColorComponentFlagBits {
///    VK_COLOR_COMPONENT_R_BIT = 0x00000001,
///    VK_COLOR_COMPONENT_G_BIT = 0x00000002,
///    VK_COLOR_COMPONENT_B_BIT = 0x00000004,
///    VK_COLOR_COMPONENT_A_BIT = 0x00000008,
///} VkColorComponentFlagBits;
///```
///# Description
/// - [`ColorComponentR`] specifies that the R value is written to the color attachment for the
///   appropriate sample. Otherwise, the value in memory is unmodified.
/// - [`ColorComponentG`] specifies that the G value is written to the color attachment for the
///   appropriate sample. Otherwise, the value in memory is unmodified.
/// - [`ColorComponentB`] specifies that the B value is written to the color attachment for the
///   appropriate sample. Otherwise, the value in memory is unmodified.
/// - [`ColorComponentA`] specifies that the A value is written to the color attachment for the
///   appropriate sample. Otherwise, the value in memory is unmodified.
///The color write mask operation is applied regardless of whether blending is
///enabled.The color write mask operation is applied only if
///[Color Write Enable](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#framebuffer-color-write-enable) is enabled for the
///respective attachment.
///Otherwise the color write mask is ignored and writes to all components of
///the attachment are disabled.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`ColorComponentFlags`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(transparent)]
pub struct ColorComponentFlags(u32);
impl const Default for ColorComponentFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl From<ColorComponentFlagBits> for ColorComponentFlags {
    fn from(from: ColorComponentFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(from as u32) }
    }
}
impl ColorComponentFlags {
    ///[`ColorComponentR`] specifies that the R value is
    ///written to the color attachment for the appropriate sample.
    ///Otherwise, the value in memory is unmodified.
    const ColorComponentR: Self = Self(1);
    ///[`ColorComponentG`] specifies that the G value is
    ///written to the color attachment for the appropriate sample.
    ///Otherwise, the value in memory is unmodified.
    const ColorComponentG: Self = Self(2);
    ///[`ColorComponentB`] specifies that the B value is
    ///written to the color attachment for the appropriate sample.
    ///Otherwise, the value in memory is unmodified.
    const ColorComponentB: Self = Self(4);
    ///[`ColorComponentA`] specifies that the A value is
    ///written to the color attachment for the appropriate sample.
    ///Otherwise, the value in memory is unmodified.
    const ColorComponentA: Self = Self(8);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    pub const fn all() -> Self {
        Self::empty() | Self::ColorComponentR | Self::ColorComponentG | Self::ColorComponentB | Self::ColorComponentA
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl const std::ops::BitOr for ColorComponentFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl std::ops::BitOrAssign for ColorComponentFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl const std::ops::BitXor for ColorComponentFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl std::ops::BitXorAssign for ColorComponentFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl const std::ops::BitAnd for ColorComponentFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl std::ops::BitAndAssign for ColorComponentFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl const std::ops::Sub for ColorComponentFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl std::ops::SubAssign for ColorComponentFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl const std::ops::Not for ColorComponentFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl std::iter::Extend<ColorComponentFlags> for ColorComponentFlags {
    fn extend<T: std::iter::IntoIterator<Item = ColorComponentFlags>>(&mut self, iterator: T) {
        for i in iterator {
            self.insert(i);
        }
    }
}
impl std::iter::Extend<ColorComponentFlagBits> for ColorComponentFlags {
    fn extend<T: std::iter::IntoIterator<Item = ColorComponentFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            self.insert(ColorComponentFlags::from(i));
        }
    }
}
impl std::iter::FromIterator<ColorComponentFlags> for ColorComponentFlags {
    fn from_iter<T: std::iter::IntoIterator<Item = ColorComponentFlags>>(iterator: T) -> ColorComponentFlags {
        let mut out = ColorComponentFlags::empty();
        out.extend(iterator);
        out
    }
}
impl std::iter::FromIterator<ColorComponentFlagBits> for ColorComponentFlags {
    fn from_iter<T: std::iter::IntoIterator<Item = ColorComponentFlagBits>>(iterator: T) -> ColorComponentFlags {
        let mut out = ColorComponentFlags::empty();
        out.extend(iterator);
        out
    }
}
impl std::fmt::Debug for ColorComponentFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(ColorComponentFlags);
        impl std::fmt::Debug for Flags {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == ColorComponentFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(ColorComponentFlags::ColorComponentR) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(ColorComponentR))?;
                    }
                    if self.0.contains(ColorComponentFlags::ColorComponentG) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(ColorComponentG))?;
                    }
                    if self.0.contains(ColorComponentFlags::ColorComponentB) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(ColorComponentB))?;
                    }
                    if self.0.contains(ColorComponentFlags::ColorComponentA) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(ColorComponentA))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(ColorComponentFlags))
            .field(&Flags(*self))
            .finish()
    }
}
///[VkFenceCreateFlagBits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFenceCreateFlagBits.html) - Bitmask specifying initial state and behavior of a fence
///# C Specifications
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkFenceCreateFlagBits {
///    VK_FENCE_CREATE_SIGNALED_BIT = 0x00000001,
///} VkFenceCreateFlagBits;
///```
///# Description
/// - [`FenceCreateSignaled`] specifies that the fence object is created in the signaled state.
///   Otherwise, it is created in the unsignaled state.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`FenceCreateFlags`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(transparent)]
pub struct FenceCreateFlags(u32);
impl const Default for FenceCreateFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl From<FenceCreateFlagBits> for FenceCreateFlags {
    fn from(from: FenceCreateFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(from as u32) }
    }
}
impl FenceCreateFlags {
    ///[`FenceCreateSignaled`] specifies that the fence object is
    ///created in the signaled state.
    ///Otherwise, it is created in the unsignaled state.
    const FenceCreateSignaled: Self = Self(1);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    pub const fn all() -> Self {
        Self::empty() | Self::FenceCreateSignaled
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl const std::ops::BitOr for FenceCreateFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl std::ops::BitOrAssign for FenceCreateFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl const std::ops::BitXor for FenceCreateFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl std::ops::BitXorAssign for FenceCreateFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl const std::ops::BitAnd for FenceCreateFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl std::ops::BitAndAssign for FenceCreateFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl const std::ops::Sub for FenceCreateFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl std::ops::SubAssign for FenceCreateFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl const std::ops::Not for FenceCreateFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl std::iter::Extend<FenceCreateFlags> for FenceCreateFlags {
    fn extend<T: std::iter::IntoIterator<Item = FenceCreateFlags>>(&mut self, iterator: T) {
        for i in iterator {
            self.insert(i);
        }
    }
}
impl std::iter::Extend<FenceCreateFlagBits> for FenceCreateFlags {
    fn extend<T: std::iter::IntoIterator<Item = FenceCreateFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            self.insert(FenceCreateFlags::from(i));
        }
    }
}
impl std::iter::FromIterator<FenceCreateFlags> for FenceCreateFlags {
    fn from_iter<T: std::iter::IntoIterator<Item = FenceCreateFlags>>(iterator: T) -> FenceCreateFlags {
        let mut out = FenceCreateFlags::empty();
        out.extend(iterator);
        out
    }
}
impl std::iter::FromIterator<FenceCreateFlagBits> for FenceCreateFlags {
    fn from_iter<T: std::iter::IntoIterator<Item = FenceCreateFlagBits>>(iterator: T) -> FenceCreateFlags {
        let mut out = FenceCreateFlags::empty();
        out.extend(iterator);
        out
    }
}
impl std::fmt::Debug for FenceCreateFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(FenceCreateFlags);
        impl std::fmt::Debug for Flags {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == FenceCreateFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(FenceCreateFlags::FenceCreateSignaled) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(FenceCreateSignaled))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(FenceCreateFlags))
            .field(&Flags(*self))
            .finish()
    }
}
///[VkSemaphoreCreateFlags](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSemaphoreCreateFlags.html) - Reserved for future use
///# C Specifications
///```c
///// Provided by VK_VERSION_1_0
///typedef VkFlags VkSemaphoreCreateFlags;
///```
///# Related
/// - [`crate::vulkan1_0`]
/// - [`SemaphoreCreateInfo`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(transparent)]
pub struct SemaphoreCreateFlags(u32);
impl const Default for SemaphoreCreateFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl std::fmt::Debug for SemaphoreCreateFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        f.debug_tuple(stringify!(SemaphoreCreateFlags)).field(&self.0).finish()
    }
}
///[VkFormatFeatureFlagBits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFormatFeatureFlagBits.html) - Bitmask specifying features supported by a buffer
///# C Specifications
///Bits which  **can**  be set in the [`FormatProperties`] features
///`linearTilingFeatures`, `optimalTilingFeatures`,
///[`DrmFormatModifierPropertiesEXT::drm_format_modifier_tiling_features`],
///and `bufferFeatures` are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkFormatFeatureFlagBits {
///    VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT = 0x00000001,
///    VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT = 0x00000002,
///    VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT = 0x00000004,
///    VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT = 0x00000008,
///    VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT = 0x00000010,
///    VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT = 0x00000020,
///    VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT = 0x00000040,
///    VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT = 0x00000080,
///    VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT = 0x00000100,
///    VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT = 0x00000200,
///    VK_FORMAT_FEATURE_BLIT_SRC_BIT = 0x00000400,
///    VK_FORMAT_FEATURE_BLIT_DST_BIT = 0x00000800,
///    VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT = 0x00001000,
///  // Provided by VK_VERSION_1_1
///    VK_FORMAT_FEATURE_TRANSFER_SRC_BIT = 0x00004000,
///  // Provided by VK_VERSION_1_1
///    VK_FORMAT_FEATURE_TRANSFER_DST_BIT = 0x00008000,
///  // Provided by VK_VERSION_1_1
///    VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT = 0x00020000,
///  // Provided by VK_VERSION_1_1
///    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT = 0x00040000,
///  // Provided by VK_VERSION_1_1
///    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT =
/// 0x00080000,
///  // Provided by VK_VERSION_1_1
///    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT =
/// 0x00100000,
///  // Provided by VK_VERSION_1_1
///    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT
/// = 0x00200000,
///  // Provided by VK_VERSION_1_1
///    VK_FORMAT_FEATURE_DISJOINT_BIT = 0x00400000,
///  // Provided by VK_VERSION_1_1
///    VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT = 0x00800000,
///  // Provided by VK_VERSION_1_2
///    VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT = 0x00010000,
///  // Provided by VK_IMG_filter_cubic
///    VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG = 0x00002000,
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_KHR_video_decode_queue
///    VK_FORMAT_FEATURE_VIDEO_DECODE_OUTPUT_BIT_KHR = 0x02000000,
///#endif
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_KHR_video_decode_queue
///    VK_FORMAT_FEATURE_VIDEO_DECODE_DPB_BIT_KHR = 0x04000000,
///#endif
///  // Provided by VK_KHR_acceleration_structure
///    VK_FORMAT_FEATURE_ACCELERATION_STRUCTURE_VERTEX_BUFFER_BIT_KHR = 0x20000000,
///  // Provided by VK_EXT_fragment_density_map
///    VK_FORMAT_FEATURE_FRAGMENT_DENSITY_MAP_BIT_EXT = 0x01000000,
///  // Provided by VK_KHR_fragment_shading_rate
///    VK_FORMAT_FEATURE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = 0x40000000,
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_KHR_video_encode_queue
///    VK_FORMAT_FEATURE_VIDEO_ENCODE_INPUT_BIT_KHR = 0x08000000,
///#endif
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_KHR_video_encode_queue
///    VK_FORMAT_FEATURE_VIDEO_ENCODE_DPB_BIT_KHR = 0x10000000,
///#endif
///  // Provided by VK_KHR_maintenance1
///    VK_FORMAT_FEATURE_TRANSFER_SRC_BIT_KHR = VK_FORMAT_FEATURE_TRANSFER_SRC_BIT,
///  // Provided by VK_KHR_maintenance1
///    VK_FORMAT_FEATURE_TRANSFER_DST_BIT_KHR = VK_FORMAT_FEATURE_TRANSFER_DST_BIT,
///  // Provided by VK_EXT_sampler_filter_minmax
///    VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT =
/// VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT,
///  // Provided by VK_KHR_sampler_ycbcr_conversion
///    VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT_KHR =
/// VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT,
///  // Provided by VK_KHR_sampler_ycbcr_conversion
///    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR =
/// VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT,
///  // Provided by VK_KHR_sampler_ycbcr_conversion
///    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR =
/// VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT,
///  // Provided by VK_KHR_sampler_ycbcr_conversion
///    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR =
/// VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT,
///  // Provided by VK_KHR_sampler_ycbcr_conversion
///    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR = VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT,
///  // Provided by VK_KHR_sampler_ycbcr_conversion
///    VK_FORMAT_FEATURE_DISJOINT_BIT_KHR = VK_FORMAT_FEATURE_DISJOINT_BIT,
///  // Provided by VK_KHR_sampler_ycbcr_conversion
///    VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT_KHR =
/// VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT,
///  // Provided by VK_EXT_filter_cubic
///    VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT =
/// VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG,
///} VkFormatFeatureFlagBits;
///```
///# Description
///These values
///all have the same meaning as the equivalently named values for
///[`FormatFeatureFlags2`] and
/// **may**  be set in
///`linearTilingFeatures`, `optimalTilingFeatures`, and
///[`DrmFormatModifierPropertiesEXT::drm_format_modifier_tiling_features`],
///specifying that the features are supported by [`Image`] or
///[`ImageView`]
///or [`SamplerYcbcrConversion`]
///created with the queried
///[`GetPhysicalDeviceFormatProperties`]`::format`:
/// - [`FormatFeatureSampledImage`] specifies that an image view  **can**  be [sampled from](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-sampledimage).
/// - [`FormatFeatureStorageImage`] specifies that an image view  **can**  be used as a [storage image](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storageimage).
/// - [`FormatFeatureStorageImageAtomic`] specifies that an image view  **can**  be used as storage
///   image that supports atomic operations.
/// - [`FormatFeatureColorAttachment`] specifies that an image view  **can**  be used as a
///   framebuffer color attachment and as an input attachment.
/// - [`FormatFeatureColorAttachmentBlend`] specifies that an image view  **can**  be used as a
///   framebuffer color attachment that supports blending and as an input attachment.
/// - [`FormatFeatureDepthStencilAttachment`] specifies that an image view  **can**  be used as a
///   framebuffer depth/stencil attachment and as an input attachment.
/// - [`FormatFeatureBlitSrc`] specifies that an image  **can**  be used as `srcImage` for the
///   [`CmdBlitImage2`] and [`CmdBlitImage`] commands.
/// - [`FormatFeatureBlitDst`] specifies that an image  **can**  be used as `dstImage` for the
///   [`CmdBlitImage2`] and [`CmdBlitImage`] commands.
/// - [`FormatFeatureSampledImageFilterLinear`] specifies that if [`FormatFeatureSampledImage`] is
///   also set, an image view  **can**  be used with a sampler that has either of `magFilter` or
///   `minFilter` set to `VK_FILTER_LINEAR`, or `mipmapMode` set to `VK_SAMPLER_MIPMAP_MODE_LINEAR`.
///   If [`FormatFeatureBlitSrc`] is also set, an image can be used as the `srcImage` to
///   [`CmdBlitImage2`] and [`CmdBlitImage`] with a `filter` of `VK_FILTER_LINEAR`. This bit
///   **must**  only be exposed for formats that also support the [`FormatFeatureSampledImage`] or
///   [`FormatFeatureBlitSrc`].If the format being queried is a depth/stencil format, this bit only
///   specifies that the depth aspect (not the stencil aspect) of an image of this format supports
///   linear filtering, and that linear filtering of the depth aspect is supported whether depth
///   compare is enabled in the sampler or not. Where depth comparison is supported it  **may**  be
///   linear filtered whether this bit is present or not, but where this bit is not present the
///   filtered value  **may**  be computed in an implementation-dependent manner which differs from
///   the normal rules of linear filtering. The resulting value  **must**  be in the range [0,1] and
///   **should**  be proportional to, or a weighted average of, the number of comparison passes or
///   failures.
/// - [`TransferSrc`] specifies that an image  **can**  be used as a source image for [copy commands](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#copies).
/// - [`TransferDst`] specifies that an image  **can**  be used as a destination image for [copy commands](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#copies)
///   and [clear commands](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#clears).
/// - [`SampledImageFilterMinmax`] specifies [`Image`] **can**  be used as a sampled image with a
///   min or max [`SamplerReductionMode`]. This bit  **must**  only be exposed for formats that also
///   support the [`FormatFeatureSampledImage`].
/// - [`SampledImageFilterCubicExt`] specifies that [`Image`] **can**  be used with a sampler that
///   has either of `magFilter` or `minFilter` set to `VK_FILTER_CUBIC_EXT`, or be the source image
///   for a blit with `filter` set to `VK_FILTER_CUBIC_EXT`. This bit  **must**  only be exposed for
///   formats that also support the [`FormatFeatureSampledImage`]. If the format being queried is a
///   depth/stencil format, this only specifies that the depth aspect is cubic filterable.
/// - [`MidpointChromaSamples`] specifies that an application  **can**  define a [sampler Y′C<sub>B</sub>C<sub>R</sub> conversion](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#samplers-YCbCr-conversion) using this format as a source, and that an image of this format  **can**  be used with a [`SamplerYcbcrConversionCreateInfo`]`xChromaOffset` and/or `yChromaOffset` of `VK_CHROMA_LOCATION_MIDPOINT`. Otherwise both `xChromaOffset` and `yChromaOffset` **must**  be `VK_CHROMA_LOCATION_COSITED_EVEN`. If a format does not incorporate chroma downsampling (it is not a “422” or “420” format) but the implementation supports sampler Y′C<sub>B</sub>C<sub>R</sub> conversion for this format, the implementation  **must**  set [`MidpointChromaSamples`].
/// - [`CositedChromaSamples`] specifies that an application  **can**  define a [sampler Y′C<sub>B</sub>C<sub>R</sub> conversion](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#samplers-YCbCr-conversion) using this format as a source, and that an image of this format  **can**  be used with a [`SamplerYcbcrConversionCreateInfo`]`xChromaOffset` and/or `yChromaOffset` of `VK_CHROMA_LOCATION_COSITED_EVEN`. Otherwise both `xChromaOffset` and `yChromaOffset` **must**  be `VK_CHROMA_LOCATION_MIDPOINT`. If neither [`CositedChromaSamples`] nor [`MidpointChromaSamples`] is set, the application  **must**  not define a [sampler Y′C<sub>B</sub>C<sub>R</sub> conversion](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#samplers-YCbCr-conversion) using this format as a source.
/// - [`SampledImageYcbcrConversionLinearFilter`] specifies that an application  **can**  define a [sampler Y′C<sub>B</sub>C<sub>R</sub> conversion](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#samplers-YCbCr-conversion) using this format as a source with `chromaFilter` set to `VK_FILTER_LINEAR`.
/// - [`SampledImageYcbcrConversionSeparateReconstructionFilter`] specifies that the format can have
///   different chroma, min, and mag filters.
/// - [`SampledImageYcbcrConversionChromaReconstructionExplicit`] specifies that reconstruction is explicit, as described in [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#textures-chroma-reconstruction](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#textures-chroma-reconstruction). If this bit is not present, reconstruction is implicit by default.
/// - [`SampledImageYcbcrConversionChromaReconstructionExplicitForceable`] specifies that
///   reconstruction  **can**  be forcibly made explicit by setting
///   [`SamplerYcbcrConversionCreateInfo::force_explicit_reconstruction`] to [`TRUE`]. If the format
///   being queried supports [`SampledImageYcbcrConversionChromaReconstructionExplicit`] it
///   **must**  also support [`SampledImageYcbcrConversionChromaReconstructionExplicitForceable`].
/// - [`Disjoint`] specifies that a multi-planar image  **can**  have the
///   `VK_IMAGE_CREATE_DISJOINT_BIT` set during image creation. An implementation  **must**  not set
///   [`Disjoint`] for *single-plane formats*.
/// - [`FragmentDensityMapExt`] specifies that an image view  **can**  be used as a [fragment density map attachment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-fragmentdensitymapattachment).
/// - [`FragmentShadingRateAttachmentKhr`] specifies that an image view  **can**  be used as a [fragment shading rate attachment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#primsrast-fragment-shading-rate-attachment). An implementation  **must**  not set this feature for formats with numeric type other than `*UINT`, or set it as a buffer feature.
/// - [`VideoDecodeOutputKhr`] specifies that an image view with this format  **can**  be used as an
///   output for [video decode operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-decode-operations)
/// - [`VideoDecodeDpbKhr`] specifies that an image view with this format  **can**  be used as a DPB
///   for [video decode operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-decode-operations)
/// - [`VideoEncodeInputKhr`] specifies that an image view with this format  **can**  be used as an input to [video encode operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-encode-operations)
/// - [`VideoEncodeDpbKhr`] specifies that an image view with this format  **can**  be used as a DPB
///   for [video encode operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-encode-operations)
///The following bits  **may**  be set in `bufferFeatures`, specifying that the
///features are supported by [`Buffer`] or [`BufferView`] created with the queried
///[`GetPhysicalDeviceFormatProperties`]`::format`:
/// - [`FormatFeatureUniformTexelBuffer`] specifies that the format  **can**  be used to create a
///   buffer view that  **can**  be bound to a `VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER` descriptor.
/// - [`FormatFeatureStorageTexelBuffer`] specifies that the format  **can**  be used to create a
///   buffer view that  **can**  be bound to a `VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER` descriptor.
/// - [`FormatFeatureStorageTexelBufferAtomic`] specifies that atomic operations are supported on
///   `VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER` with this format.
/// - [`FormatFeatureVertexBuffer`] specifies that the format  **can**  be used as a vertex
///   attribute format ([`VertexInputAttributeDescription::format`]).
/// - [`AccelerationStructureVertexBufferKhr`] specifies that the format  **can**  be used as the vertex format when creating an [acceleration structure](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#acceleration-structure) ([`AccelerationStructureGeometryTrianglesDataKHR::vertex_format`]). This format  **can**  also be used as the vertex format in host memory when doing [host acceleration structure](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#host-acceleration-structure) builds.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`FormatFeatureFlags`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(transparent)]
pub struct FormatFeatureFlags(u32);
impl const Default for FormatFeatureFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl From<FormatFeatureFlagBits> for FormatFeatureFlags {
    fn from(from: FormatFeatureFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(from as u32) }
    }
}
impl FormatFeatureFlags {
    ///[`FormatFeatureSampledImage`] specifies that an image view
    /// **can**  be [sampled from](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-sampledimage).
    const FormatFeatureSampledImage: Self = Self(1);
    ///[`FormatFeatureStorageImage`] specifies that an image view
    /// **can**  be used as a [storage image](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storageimage).
    const FormatFeatureStorageImage: Self = Self(2);
    ///[`FormatFeatureStorageImageAtomic`] specifies that an image
    ///view  **can**  be used as storage image that supports atomic operations.
    const FormatFeatureStorageImageAtomic: Self = Self(4);
    ///[`FormatFeatureUniformTexelBuffer`] specifies that the
    ///format  **can**  be used to create a buffer view that  **can**  be bound to a
    ///`VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER` descriptor.
    const FormatFeatureUniformTexelBuffer: Self = Self(8);
    ///[`FormatFeatureStorageTexelBuffer`] specifies that the
    ///format  **can**  be used to create a buffer view that  **can**  be bound to a
    ///`VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER` descriptor.
    const FormatFeatureStorageTexelBuffer: Self = Self(16);
    ///[`FormatFeatureStorageTexelBufferAtomic`] specifies that
    ///atomic operations are supported on
    ///`VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER` with this format.
    const FormatFeatureStorageTexelBufferAtomic: Self = Self(32);
    ///[`FormatFeatureVertexBuffer`] specifies that the format  **can**
    ///be used as a vertex attribute format
    ///([`VertexInputAttributeDescription`]::`format`).
    const FormatFeatureVertexBuffer: Self = Self(64);
    ///[`FormatFeatureColorAttachment`] specifies that an image
    ///view  **can**  be used as a framebuffer color attachment and as an input
    ///attachment.
    const FormatFeatureColorAttachment: Self = Self(128);
    ///[`FormatFeatureColorAttachmentBlend`] specifies that an
    ///image view  **can**  be used as a framebuffer color attachment that supports
    ///blending and as an input attachment.
    const FormatFeatureColorAttachmentBlend: Self = Self(256);
    ///[`FormatFeatureDepthStencilAttachment`] specifies that an
    ///image view  **can**  be used as a framebuffer depth/stencil attachment and as
    ///an input attachment.
    const FormatFeatureDepthStencilAttachment: Self = Self(512);
    ///[`FormatFeatureBlitSrc`] specifies that an image  **can**  be
    ///used as `srcImage` for the
    ///[`CmdBlitImage2`] and [`CmdBlitImage`] commands.
    const FormatFeatureBlitSrc: Self = Self(1024);
    ///[`FormatFeatureBlitDst`] specifies that an image  **can**  be
    ///used as `dstImage` for the
    ///[`CmdBlitImage2`] and [`CmdBlitImage`] commands.
    const FormatFeatureBlitDst: Self = Self(2048);
    ///[`FormatFeatureSampledImageFilterLinear`] specifies that
    ///if [`FormatFeatureSampledImage`] is also set, an image view
    /// **can**  be used with a sampler that has either of `magFilter` or
    ///`minFilter` set to `VK_FILTER_LINEAR`, or `mipmapMode` set
    ///to `VK_SAMPLER_MIPMAP_MODE_LINEAR`.
    ///If [`FormatFeatureBlitSrc`] is also set, an image can be
    ///used as the `srcImage` to
    ///[`CmdBlitImage2`] and [`CmdBlitImage`]
    ///with a `filter` of `VK_FILTER_LINEAR`.
    ///This bit  **must**  only be exposed for formats that also support the
    ///[`FormatFeatureSampledImage`] or
    ///[`FormatFeatureBlitSrc`].If the format being queried is a depth/stencil format, this bit
    /// only specifies that the depth aspect (not the stencil aspect) of an image of this
    ///format supports linear filtering, and that linear filtering of the depth
    ///aspect is supported whether depth compare is enabled in the sampler or not.
    ///Where depth comparison is supported it  **may**  be linear filtered whether this
    ///bit is present or not, but where this bit is not present the filtered value
    /// **may**  be computed in an implementation-dependent manner which differs from
    ///the normal rules of linear filtering.
    ///The resulting value  **must**  be in the range [0,1] and  **should**  be
    ///proportional to, or a weighted average of, the number of comparison passes
    ///or failures.
    const FormatFeatureSampledImageFilterLinear: Self = Self(4096);
    ///[`TransferSrc`] specifies that an image  **can**  be
    ///used as a source image for [copy commands](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#copies).
    ///
    ///Provided by [`crate::vulkan1_1`]
    const TransferSrc: Self = Self(16384);
    ///[`TransferDst`] specifies that an image  **can**  be
    ///used as a destination image for [copy commands](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#copies) and [clear commands](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#clears).
    ///
    ///Provided by [`crate::vulkan1_1`]
    const TransferDst: Self = Self(32768);
    ///[`MidpointChromaSamples`] specifies that an
    ///application  **can**  define a [sampler Y′C<sub>B</sub>C<sub>R</sub>
    ///conversion](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#samplers-YCbCr-conversion) using this format as a source, and that an image of this
    ///format  **can**  be used with a [`SamplerYcbcrConversionCreateInfo`]`xChromaOffset` and/or
    /// `yChromaOffset` of `VK_CHROMA_LOCATION_MIDPOINT`.
    ///Otherwise both `xChromaOffset` and `yChromaOffset` **must**  be
    ///`VK_CHROMA_LOCATION_COSITED_EVEN`.
    ///If a format does not incorporate chroma downsampling (it is not a
    ///“422” or “420” format) but the implementation supports sampler
    ///Y′C<sub>B</sub>C<sub>R</sub> conversion for this format, the implementation  **must**  set
    ///[`MidpointChromaSamples`].
    ///
    ///Provided by [`crate::vulkan1_1`]
    const MidpointChromaSamples: Self = Self(131072);
    ///[`SampledImageYcbcrConversionLinearFilter`]
    ///specifies that an application  **can**  define a
    ///[sampler Y′C<sub>B</sub>C<sub>R</sub> conversion](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#samplers-YCbCr-conversion) using this
    ///format as a source with `chromaFilter` set to
    ///`VK_FILTER_LINEAR`.
    ///
    ///Provided by [`crate::vulkan1_1`]
    const SampledImageYcbcrConversionLinearFilter: Self = Self(262144);
    ///[`SampledImageYcbcrConversionSeparateReconstructionFilter`]
    ///specifies that the format can have different chroma, min, and mag
    ///filters.
    ///
    ///Provided by [`crate::vulkan1_1`]
    const SampledImageYcbcrConversionSeparateReconstructionFilter: Self = Self(524288);
    ///[`SampledImageYcbcrConversionChromaReconstructionExplicit`]
    ///specifies that reconstruction is explicit, as described in
    ///[https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#textures-chroma-reconstruction](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#textures-chroma-reconstruction).
    ///If this bit is not present, reconstruction is implicit by default.
    ///
    ///Provided by [`crate::vulkan1_1`]
    const SampledImageYcbcrConversionChromaReconstructionExplicit: Self = Self(1048576);
    ///[`SampledImageYcbcrConversionChromaReconstructionExplicitForceable`]
    ///specifies that reconstruction  **can**  be forcibly made explicit by setting
    ///[`SamplerYcbcrConversionCreateInfo`]::`forceExplicitReconstruction`
    ///to [`TRUE`].
    ///If the format being queried supports
    ///[`SampledImageYcbcrConversionChromaReconstructionExplicit`]
    ///it  **must**  also support
    ///[`SampledImageYcbcrConversionChromaReconstructionExplicitForceable`].
    ///
    ///Provided by [`crate::vulkan1_1`]
    const SampledImageYcbcrConversionChromaReconstructionExplicitForceable: Self = Self(2097152);
    ///[`Disjoint`] specifies that a multi-planar image
    /// **can**  have the `VK_IMAGE_CREATE_DISJOINT_BIT` set during image
    ///creation.
    ///An implementation  **must**  not set [`Disjoint`] for
    ///*single-plane formats*.
    ///
    ///Provided by [`crate::vulkan1_1`]
    const Disjoint: Self = Self(4194304);
    ///[`CositedChromaSamples`] specifies that an
    ///application  **can**  define a [sampler Y′C<sub>B</sub>C<sub>R</sub>
    ///conversion](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#samplers-YCbCr-conversion) using this format as a source, and that an image of this
    ///format  **can**  be used with a [`SamplerYcbcrConversionCreateInfo`]`xChromaOffset` and/or
    /// `yChromaOffset` of `VK_CHROMA_LOCATION_COSITED_EVEN`.
    ///Otherwise both `xChromaOffset` and `yChromaOffset` **must**  be
    ///`VK_CHROMA_LOCATION_MIDPOINT`.
    ///If neither [`CositedChromaSamples`] nor
    ///[`MidpointChromaSamples`] is set, the
    ///application  **must**  not define a [sampler
    ///Y′C<sub>B</sub>C<sub>R</sub> conversion](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#samplers-YCbCr-conversion) using this format as a source.
    ///
    ///Provided by [`crate::vulkan1_1`]
    const CositedChromaSamples: Self = Self(8388608);
    ///[`SampledImageFilterMinmax`] specifies
    ///[`Image`] **can**  be used as a sampled image with a min or max
    ///[`SamplerReductionMode`].
    ///This bit  **must**  only be exposed for formats that also support the
    ///[`FormatFeatureSampledImage`].
    ///
    ///Provided by [`crate::vulkan1_2`]
    const SampledImageFilterMinmax: Self = Self(65536);
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::img_filter_cubic`]
    const SampledImageFilterCubicImg: Self = Self(8192);
    ///[`VideoDecodeOutputKhr`] specifies that an
    ///image view with this format  **can**  be used as an output for
    ///[video decode operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-decode-operations)
    ///
    ///Provided by [`crate::extensions::khr_video_decode_queue`]
    const VideoDecodeOutputKhr: Self = Self(33554432);
    ///[`VideoDecodeDpbKhr`] specifies that an image
    ///view with this format  **can**  be used as a DPB for
    ///[video decode operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-decode-operations)
    ///
    ///Provided by [`crate::extensions::khr_video_decode_queue`]
    const VideoDecodeDpbKhr: Self = Self(67108864);
    ///[`AccelerationStructureVertexBufferKhr`]
    ///specifies that the format  **can**  be used as the vertex format when
    ///creating an [acceleration structure](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#acceleration-structure)
    ///([`AccelerationStructureGeometryTrianglesDataKHR`]::`vertexFormat`).
    ///This format  **can**  also be used as the vertex format in host memory when
    ///doing [host acceleration structure](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#host-acceleration-structure)
    ///builds.
    ///
    ///Provided by [`crate::extensions::khr_acceleration_structure`]
    const AccelerationStructureVertexBufferKhr: Self = Self(536870912);
    ///[`FragmentDensityMapExt`] specifies that an
    ///image view  **can**  be used as a
    ///[fragment density map
    ///attachment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-fragmentdensitymapattachment).
    ///
    ///Provided by [`crate::extensions::ext_fragment_density_map`]
    const FragmentDensityMapExt: Self = Self(16777216);
    ///[`FragmentShadingRateAttachmentKhr`]
    ///specifies that an image view  **can**  be used as a
    ///[fragment shading rate
    ///attachment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#primsrast-fragment-shading-rate-attachment).
    ///An implementation  **must**  not set this feature for formats with numeric
    ///type other than `*UINT`, or set it as a buffer feature.
    ///
    ///Provided by [`crate::extensions::khr_fragment_shading_rate`]
    const FragmentShadingRateAttachmentKhr: Self = Self(1073741824);
    ///[`VideoEncodeInputKhr`] specifies that an
    ///image view with this format  **can**  be used as an input to
    ///[video encode operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-encode-operations)
    ///
    ///Provided by [`crate::extensions::khr_video_encode_queue`]
    const VideoEncodeInputKhr: Self = Self(134217728);
    ///[`VideoEncodeDpbKhr`] specifies that an image
    ///view with this format  **can**  be used as a DPB for
    ///[video encode operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-encode-operations)
    ///
    ///Provided by [`crate::extensions::khr_video_encode_queue`]
    const VideoEncodeDpbKhr: Self = Self(268435456);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    pub const fn all() -> Self {
        Self::empty()
            | Self::FormatFeatureSampledImage
            | Self::FormatFeatureStorageImage
            | Self::FormatFeatureStorageImageAtomic
            | Self::FormatFeatureUniformTexelBuffer
            | Self::FormatFeatureStorageTexelBuffer
            | Self::FormatFeatureStorageTexelBufferAtomic
            | Self::FormatFeatureVertexBuffer
            | Self::FormatFeatureColorAttachment
            | Self::FormatFeatureColorAttachmentBlend
            | Self::FormatFeatureDepthStencilAttachment
            | Self::FormatFeatureBlitSrc
            | Self::FormatFeatureBlitDst
            | Self::FormatFeatureSampledImageFilterLinear
            | Self::TransferSrc
            | Self::TransferDst
            | Self::MidpointChromaSamples
            | Self::SampledImageYcbcrConversionLinearFilter
            | Self::SampledImageYcbcrConversionSeparateReconstructionFilter
            | Self::SampledImageYcbcrConversionChromaReconstructionExplicit
            | Self::SampledImageYcbcrConversionChromaReconstructionExplicitForceable
            | Self::Disjoint
            | Self::CositedChromaSamples
            | Self::SampledImageFilterMinmax
            | Self::SampledImageFilterCubicImg
            | Self::VideoDecodeOutputKhr
            | Self::VideoDecodeDpbKhr
            | Self::AccelerationStructureVertexBufferKhr
            | Self::FragmentDensityMapExt
            | Self::FragmentShadingRateAttachmentKhr
            | Self::VideoEncodeInputKhr
            | Self::VideoEncodeDpbKhr
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl const std::ops::BitOr for FormatFeatureFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl std::ops::BitOrAssign for FormatFeatureFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl const std::ops::BitXor for FormatFeatureFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl std::ops::BitXorAssign for FormatFeatureFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl const std::ops::BitAnd for FormatFeatureFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl std::ops::BitAndAssign for FormatFeatureFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl const std::ops::Sub for FormatFeatureFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl std::ops::SubAssign for FormatFeatureFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl const std::ops::Not for FormatFeatureFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl std::iter::Extend<FormatFeatureFlags> for FormatFeatureFlags {
    fn extend<T: std::iter::IntoIterator<Item = FormatFeatureFlags>>(&mut self, iterator: T) {
        for i in iterator {
            self.insert(i);
        }
    }
}
impl std::iter::Extend<FormatFeatureFlagBits> for FormatFeatureFlags {
    fn extend<T: std::iter::IntoIterator<Item = FormatFeatureFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            self.insert(FormatFeatureFlags::from(i));
        }
    }
}
impl std::iter::FromIterator<FormatFeatureFlags> for FormatFeatureFlags {
    fn from_iter<T: std::iter::IntoIterator<Item = FormatFeatureFlags>>(iterator: T) -> FormatFeatureFlags {
        let mut out = FormatFeatureFlags::empty();
        out.extend(iterator);
        out
    }
}
impl std::iter::FromIterator<FormatFeatureFlagBits> for FormatFeatureFlags {
    fn from_iter<T: std::iter::IntoIterator<Item = FormatFeatureFlagBits>>(iterator: T) -> FormatFeatureFlags {
        let mut out = FormatFeatureFlags::empty();
        out.extend(iterator);
        out
    }
}
impl std::fmt::Debug for FormatFeatureFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(FormatFeatureFlags);
        impl std::fmt::Debug for Flags {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == FormatFeatureFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(FormatFeatureFlags::FormatFeatureSampledImage) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(FormatFeatureSampledImage))?;
                    }
                    if self.0.contains(FormatFeatureFlags::FormatFeatureStorageImage) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(FormatFeatureStorageImage))?;
                    }
                    if self.0.contains(FormatFeatureFlags::FormatFeatureStorageImageAtomic) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(FormatFeatureStorageImageAtomic))?;
                    }
                    if self.0.contains(FormatFeatureFlags::FormatFeatureUniformTexelBuffer) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(FormatFeatureUniformTexelBuffer))?;
                    }
                    if self.0.contains(FormatFeatureFlags::FormatFeatureStorageTexelBuffer) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(FormatFeatureStorageTexelBuffer))?;
                    }
                    if self
                        .0
                        .contains(FormatFeatureFlags::FormatFeatureStorageTexelBufferAtomic)
                    {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(FormatFeatureStorageTexelBufferAtomic))?;
                    }
                    if self.0.contains(FormatFeatureFlags::FormatFeatureVertexBuffer) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(FormatFeatureVertexBuffer))?;
                    }
                    if self.0.contains(FormatFeatureFlags::FormatFeatureColorAttachment) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(FormatFeatureColorAttachment))?;
                    }
                    if self.0.contains(FormatFeatureFlags::FormatFeatureColorAttachmentBlend) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(FormatFeatureColorAttachmentBlend))?;
                    }
                    if self.0.contains(FormatFeatureFlags::FormatFeatureDepthStencilAttachment) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(FormatFeatureDepthStencilAttachment))?;
                    }
                    if self.0.contains(FormatFeatureFlags::FormatFeatureBlitSrc) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(FormatFeatureBlitSrc))?;
                    }
                    if self.0.contains(FormatFeatureFlags::FormatFeatureBlitDst) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(FormatFeatureBlitDst))?;
                    }
                    if self
                        .0
                        .contains(FormatFeatureFlags::FormatFeatureSampledImageFilterLinear)
                    {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(FormatFeatureSampledImageFilterLinear))?;
                    }
                    if self.0.contains(FormatFeatureFlags::TransferSrc) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(TransferSrc))?;
                    }
                    if self.0.contains(FormatFeatureFlags::TransferDst) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(TransferDst))?;
                    }
                    if self.0.contains(FormatFeatureFlags::MidpointChromaSamples) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(MidpointChromaSamples))?;
                    }
                    if self
                        .0
                        .contains(FormatFeatureFlags::SampledImageYcbcrConversionLinearFilter)
                    {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(SampledImageYcbcrConversionLinearFilter))?;
                    }
                    if self
                        .0
                        .contains(FormatFeatureFlags::SampledImageYcbcrConversionSeparateReconstructionFilter)
                    {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(SampledImageYcbcrConversionSeparateReconstructionFilter))?;
                    }
                    if self
                        .0
                        .contains(FormatFeatureFlags::SampledImageYcbcrConversionChromaReconstructionExplicit)
                    {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(SampledImageYcbcrConversionChromaReconstructionExplicit))?;
                    }
                    if self
                        .0
                        .contains(FormatFeatureFlags::SampledImageYcbcrConversionChromaReconstructionExplicitForceable)
                    {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(
                            SampledImageYcbcrConversionChromaReconstructionExplicitForceable
                        ))?;
                    }
                    if self.0.contains(FormatFeatureFlags::Disjoint) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(Disjoint))?;
                    }
                    if self.0.contains(FormatFeatureFlags::CositedChromaSamples) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(CositedChromaSamples))?;
                    }
                    if self.0.contains(FormatFeatureFlags::SampledImageFilterMinmax) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(SampledImageFilterMinmax))?;
                    }
                    if self.0.contains(FormatFeatureFlags::SampledImageFilterCubicImg) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(SampledImageFilterCubicImg))?;
                    }
                    if self.0.contains(FormatFeatureFlags::VideoDecodeOutputKhr) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(VideoDecodeOutputKhr))?;
                    }
                    if self.0.contains(FormatFeatureFlags::VideoDecodeDpbKhr) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(VideoDecodeDpbKhr))?;
                    }
                    if self
                        .0
                        .contains(FormatFeatureFlags::AccelerationStructureVertexBufferKhr)
                    {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(AccelerationStructureVertexBufferKhr))?;
                    }
                    if self.0.contains(FormatFeatureFlags::FragmentDensityMapExt) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(FragmentDensityMapExt))?;
                    }
                    if self.0.contains(FormatFeatureFlags::FragmentShadingRateAttachmentKhr) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(FragmentShadingRateAttachmentKhr))?;
                    }
                    if self.0.contains(FormatFeatureFlags::VideoEncodeInputKhr) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(VideoEncodeInputKhr))?;
                    }
                    if self.0.contains(FormatFeatureFlags::VideoEncodeDpbKhr) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(VideoEncodeDpbKhr))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(FormatFeatureFlags))
            .field(&Flags(*self))
            .finish()
    }
}
///[VkQueryControlFlagBits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkQueryControlFlagBits.html) - Bitmask specifying constraints on a query
///# C Specifications
///Bits which  **can**  be set in [`CmdBeginQuery`]`::flags`, specifying
///constraints on the types of queries that  **can**  be performed, are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkQueryControlFlagBits {
///    VK_QUERY_CONTROL_PRECISE_BIT = 0x00000001,
///} VkQueryControlFlagBits;
///```
///# Description
/// - [`QueryControlPrecise`] specifies the precision of [occlusion queries](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#queries-occlusion).
///# Related
/// - [`crate::vulkan1_0`]
/// - [`QueryControlFlags`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(transparent)]
pub struct QueryControlFlags(u32);
impl const Default for QueryControlFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl From<QueryControlFlagBits> for QueryControlFlags {
    fn from(from: QueryControlFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(from as u32) }
    }
}
impl QueryControlFlags {
    ///[`QueryControlPrecise`] specifies the precision of
    ///[occlusion queries](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#queries-occlusion).
    const QueryControlPrecise: Self = Self(1);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    pub const fn all() -> Self {
        Self::empty() | Self::QueryControlPrecise
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl const std::ops::BitOr for QueryControlFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl std::ops::BitOrAssign for QueryControlFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl const std::ops::BitXor for QueryControlFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl std::ops::BitXorAssign for QueryControlFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl const std::ops::BitAnd for QueryControlFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl std::ops::BitAndAssign for QueryControlFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl const std::ops::Sub for QueryControlFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl std::ops::SubAssign for QueryControlFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl const std::ops::Not for QueryControlFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl std::iter::Extend<QueryControlFlags> for QueryControlFlags {
    fn extend<T: std::iter::IntoIterator<Item = QueryControlFlags>>(&mut self, iterator: T) {
        for i in iterator {
            self.insert(i);
        }
    }
}
impl std::iter::Extend<QueryControlFlagBits> for QueryControlFlags {
    fn extend<T: std::iter::IntoIterator<Item = QueryControlFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            self.insert(QueryControlFlags::from(i));
        }
    }
}
impl std::iter::FromIterator<QueryControlFlags> for QueryControlFlags {
    fn from_iter<T: std::iter::IntoIterator<Item = QueryControlFlags>>(iterator: T) -> QueryControlFlags {
        let mut out = QueryControlFlags::empty();
        out.extend(iterator);
        out
    }
}
impl std::iter::FromIterator<QueryControlFlagBits> for QueryControlFlags {
    fn from_iter<T: std::iter::IntoIterator<Item = QueryControlFlagBits>>(iterator: T) -> QueryControlFlags {
        let mut out = QueryControlFlags::empty();
        out.extend(iterator);
        out
    }
}
impl std::fmt::Debug for QueryControlFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(QueryControlFlags);
        impl std::fmt::Debug for Flags {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == QueryControlFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(QueryControlFlags::QueryControlPrecise) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(QueryControlPrecise))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(QueryControlFlags))
            .field(&Flags(*self))
            .finish()
    }
}
///[VkQueryResultFlagBits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkQueryResultFlagBits.html) - Bitmask specifying how and when query results are returned
///# C Specifications
///Bits which  **can**  be set in [`GetQueryPoolResults`]`::flags` and
///[`CmdCopyQueryPoolResults`]`::flags`, specifying how and when
///results are returned, are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkQueryResultFlagBits {
///    VK_QUERY_RESULT_64_BIT = 0x00000001,
///    VK_QUERY_RESULT_WAIT_BIT = 0x00000002,
///    VK_QUERY_RESULT_WITH_AVAILABILITY_BIT = 0x00000004,
///    VK_QUERY_RESULT_PARTIAL_BIT = 0x00000008,
///#ifdef VK_ENABLE_BETA_EXTENSIONS
///  // Provided by VK_KHR_video_queue
///    VK_QUERY_RESULT_WITH_STATUS_BIT_KHR = 0x00000010,
///#endif
///} VkQueryResultFlagBits;
///```
///# Description
/// - [`QueryResult64`] specifies the results will be written as an array of 64-bit unsigned integer
///   values. If this bit is not set, the results will be written as an array of 32-bit unsigned
///   integer values.
/// - [`QueryResultWait`] specifies that Vulkan will wait for each query’s status to become
///   available before retrieving its results.
/// - [`QueryResultWithAvailability`] specifies that the availability status accompanies the
///   results.
/// - [`QueryResultPartial`] specifies that returning partial results is acceptable.
/// - [`WithStatusKhr`] specifies that the last value returned in the query is a [`QueryResultStatusKHR`] value. See [result status query](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#queries-result-status-only) for information on how an application can determine whether the use of this flag bit is supported.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`QueryResultFlags`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(transparent)]
pub struct QueryResultFlags(u32);
impl const Default for QueryResultFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl From<QueryResultFlagBits> for QueryResultFlags {
    fn from(from: QueryResultFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(from as u32) }
    }
}
impl QueryResultFlags {
    ///[`QueryResult64`] specifies the results will be written as an
    ///array of 64-bit unsigned integer values.
    ///If this bit is not set, the results will be written as an array of
    ///32-bit unsigned integer values.
    const QueryResult64: Self = Self(1);
    ///[`QueryResultWait`] specifies that Vulkan will wait for each
    ///query’s status to become available before retrieving its results.
    const QueryResultWait: Self = Self(2);
    ///[`QueryResultWithAvailability`] specifies that the
    ///availability status accompanies the results.
    const QueryResultWithAvailability: Self = Self(4);
    ///[`QueryResultPartial`] specifies that returning partial
    ///results is acceptable.
    const QueryResultPartial: Self = Self(8);
    ///[`WithStatusKhr`] specifies that the last value
    ///returned in the query is a [`QueryResultStatusKHR`] value.
    ///See [result status query](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#queries-result-status-only) for information
    ///on how an application can determine whether the use of this flag bit is
    ///supported.
    ///
    ///Provided by [`crate::extensions::khr_video_queue`]
    const WithStatusKhr: Self = Self(16);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    pub const fn all() -> Self {
        Self::empty()
            | Self::QueryResult64
            | Self::QueryResultWait
            | Self::QueryResultWithAvailability
            | Self::QueryResultPartial
            | Self::WithStatusKhr
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl const std::ops::BitOr for QueryResultFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl std::ops::BitOrAssign for QueryResultFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl const std::ops::BitXor for QueryResultFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl std::ops::BitXorAssign for QueryResultFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl const std::ops::BitAnd for QueryResultFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl std::ops::BitAndAssign for QueryResultFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl const std::ops::Sub for QueryResultFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl std::ops::SubAssign for QueryResultFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl const std::ops::Not for QueryResultFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl std::iter::Extend<QueryResultFlags> for QueryResultFlags {
    fn extend<T: std::iter::IntoIterator<Item = QueryResultFlags>>(&mut self, iterator: T) {
        for i in iterator {
            self.insert(i);
        }
    }
}
impl std::iter::Extend<QueryResultFlagBits> for QueryResultFlags {
    fn extend<T: std::iter::IntoIterator<Item = QueryResultFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            self.insert(QueryResultFlags::from(i));
        }
    }
}
impl std::iter::FromIterator<QueryResultFlags> for QueryResultFlags {
    fn from_iter<T: std::iter::IntoIterator<Item = QueryResultFlags>>(iterator: T) -> QueryResultFlags {
        let mut out = QueryResultFlags::empty();
        out.extend(iterator);
        out
    }
}
impl std::iter::FromIterator<QueryResultFlagBits> for QueryResultFlags {
    fn from_iter<T: std::iter::IntoIterator<Item = QueryResultFlagBits>>(iterator: T) -> QueryResultFlags {
        let mut out = QueryResultFlags::empty();
        out.extend(iterator);
        out
    }
}
impl std::fmt::Debug for QueryResultFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(QueryResultFlags);
        impl std::fmt::Debug for Flags {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == QueryResultFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(QueryResultFlags::QueryResult64) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(QueryResult64))?;
                    }
                    if self.0.contains(QueryResultFlags::QueryResultWait) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(QueryResultWait))?;
                    }
                    if self.0.contains(QueryResultFlags::QueryResultWithAvailability) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(QueryResultWithAvailability))?;
                    }
                    if self.0.contains(QueryResultFlags::QueryResultPartial) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(QueryResultPartial))?;
                    }
                    if self.0.contains(QueryResultFlags::WithStatusKhr) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(WithStatusKhr))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(QueryResultFlags))
            .field(&Flags(*self))
            .finish()
    }
}
///[VkShaderModuleCreateFlags](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkShaderModuleCreateFlags.html) - Reserved for future use
///# C Specifications
///```c
///// Provided by VK_VERSION_1_0
///typedef VkFlags VkShaderModuleCreateFlags;
///```
///# Related
/// - [`crate::vulkan1_0`]
/// - [`ShaderModuleCreateInfo`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(transparent)]
pub struct ShaderModuleCreateFlags(u32);
impl const Default for ShaderModuleCreateFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl std::fmt::Debug for ShaderModuleCreateFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        f.debug_tuple(stringify!(ShaderModuleCreateFlags))
            .field(&self.0)
            .finish()
    }
}
///[VkEventCreateFlagBits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkEventCreateFlagBits.html) - Event creation flag bits
///# C Specifications
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkEventCreateFlagBits {
///  // Provided by VK_VERSION_1_3
///    VK_EVENT_CREATE_DEVICE_ONLY_BIT = 0x00000001,
///  // Provided by VK_KHR_synchronization2
///    VK_EVENT_CREATE_DEVICE_ONLY_BIT_KHR = VK_EVENT_CREATE_DEVICE_ONLY_BIT,
///} VkEventCreateFlagBits;
///```
///# Description
/// - [`DeviceOnly`] specifies that host event commands will not be used with this event.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`EventCreateFlags`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(transparent)]
pub struct EventCreateFlags(u32);
impl const Default for EventCreateFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl From<EventCreateFlagBits> for EventCreateFlags {
    fn from(from: EventCreateFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(from as u32) }
    }
}
impl EventCreateFlags {
    ///[`DeviceOnly`] specifies that host event commands
    ///will not be used with this event.
    ///
    ///Provided by [`crate::vulkan1_3`]
    const DeviceOnly: Self = Self(1);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    pub const fn all() -> Self {
        Self::empty() | Self::DeviceOnly
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl const std::ops::BitOr for EventCreateFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl std::ops::BitOrAssign for EventCreateFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl const std::ops::BitXor for EventCreateFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl std::ops::BitXorAssign for EventCreateFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl const std::ops::BitAnd for EventCreateFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl std::ops::BitAndAssign for EventCreateFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl const std::ops::Sub for EventCreateFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl std::ops::SubAssign for EventCreateFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl const std::ops::Not for EventCreateFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl std::iter::Extend<EventCreateFlags> for EventCreateFlags {
    fn extend<T: std::iter::IntoIterator<Item = EventCreateFlags>>(&mut self, iterator: T) {
        for i in iterator {
            self.insert(i);
        }
    }
}
impl std::iter::Extend<EventCreateFlagBits> for EventCreateFlags {
    fn extend<T: std::iter::IntoIterator<Item = EventCreateFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            self.insert(EventCreateFlags::from(i));
        }
    }
}
impl std::iter::FromIterator<EventCreateFlags> for EventCreateFlags {
    fn from_iter<T: std::iter::IntoIterator<Item = EventCreateFlags>>(iterator: T) -> EventCreateFlags {
        let mut out = EventCreateFlags::empty();
        out.extend(iterator);
        out
    }
}
impl std::iter::FromIterator<EventCreateFlagBits> for EventCreateFlags {
    fn from_iter<T: std::iter::IntoIterator<Item = EventCreateFlagBits>>(iterator: T) -> EventCreateFlags {
        let mut out = EventCreateFlags::empty();
        out.extend(iterator);
        out
    }
}
impl std::fmt::Debug for EventCreateFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(EventCreateFlags);
        impl std::fmt::Debug for Flags {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == EventCreateFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(EventCreateFlags::DeviceOnly) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(DeviceOnly))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(EventCreateFlags))
            .field(&Flags(*self))
            .finish()
    }
}
///[VkCommandPoolCreateFlagBits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandPoolCreateFlagBits.html) - Bitmask specifying usage behavior for a command pool
///# C Specifications
///Bits which  **can**  be set in [`CommandPoolCreateInfo::flags`],
///specifying usage behavior for a command pool, are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkCommandPoolCreateFlagBits {
///    VK_COMMAND_POOL_CREATE_TRANSIENT_BIT = 0x00000001,
///    VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT = 0x00000002,
///  // Provided by VK_VERSION_1_1
///    VK_COMMAND_POOL_CREATE_PROTECTED_BIT = 0x00000004,
///} VkCommandPoolCreateFlagBits;
///```
///# Description
/// - [`CommandPoolCreateTransient`] specifies that command buffers allocated from the pool will be
///   short-lived, meaning that they will be reset or freed in a relatively short timeframe. This
///   flag  **may**  be used by the implementation to control memory allocation behavior within the
///   pool.
/// - [`CommandPoolCreateResetCommandBuffer`] allows any command buffer allocated from a pool to be individually reset to the [initial state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#commandbuffers-lifecycle); either by calling [`ResetCommandBuffer`], or via the implicit reset when calling [`BeginCommandBuffer`]. If this flag is not set on a pool, then [`ResetCommandBuffer`] **must**  not be called for any command buffer allocated from that pool.
/// - [`Protected`] specifies that command buffers allocated from the pool are protected command
///   buffers.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`CommandPoolCreateFlags`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(transparent)]
pub struct CommandPoolCreateFlags(u32);
impl const Default for CommandPoolCreateFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl From<CommandPoolCreateFlagBits> for CommandPoolCreateFlags {
    fn from(from: CommandPoolCreateFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(from as u32) }
    }
}
impl CommandPoolCreateFlags {
    ///[`CommandPoolCreateTransient`] specifies that command
    ///buffers allocated from the pool will be short-lived, meaning that they
    ///will be reset or freed in a relatively short timeframe.
    ///This flag  **may**  be used by the implementation to control memory
    ///allocation behavior within the pool.
    const CommandPoolCreateTransient: Self = Self(1);
    ///[`CommandPoolCreateResetCommandBuffer`] allows any command
    ///buffer allocated from a pool to be individually reset to the
    ///[initial state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#commandbuffers-lifecycle); either by calling
    ///[`ResetCommandBuffer`], or via the implicit reset when calling
    ///[`BeginCommandBuffer`].
    ///If this flag is not set on a pool, then [`ResetCommandBuffer`] **must**
    ///not be called for any command buffer allocated from that pool.
    const CommandPoolCreateResetCommandBuffer: Self = Self(2);
    ///[`Protected`] specifies that command
    ///buffers allocated from the pool are protected command buffers.
    ///
    ///Provided by [`crate::vulkan1_1`]
    const Protected: Self = Self(4);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    pub const fn all() -> Self {
        Self::empty() | Self::CommandPoolCreateTransient | Self::CommandPoolCreateResetCommandBuffer | Self::Protected
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl const std::ops::BitOr for CommandPoolCreateFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl std::ops::BitOrAssign for CommandPoolCreateFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl const std::ops::BitXor for CommandPoolCreateFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl std::ops::BitXorAssign for CommandPoolCreateFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl const std::ops::BitAnd for CommandPoolCreateFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl std::ops::BitAndAssign for CommandPoolCreateFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl const std::ops::Sub for CommandPoolCreateFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl std::ops::SubAssign for CommandPoolCreateFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl const std::ops::Not for CommandPoolCreateFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl std::iter::Extend<CommandPoolCreateFlags> for CommandPoolCreateFlags {
    fn extend<T: std::iter::IntoIterator<Item = CommandPoolCreateFlags>>(&mut self, iterator: T) {
        for i in iterator {
            self.insert(i);
        }
    }
}
impl std::iter::Extend<CommandPoolCreateFlagBits> for CommandPoolCreateFlags {
    fn extend<T: std::iter::IntoIterator<Item = CommandPoolCreateFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            self.insert(CommandPoolCreateFlags::from(i));
        }
    }
}
impl std::iter::FromIterator<CommandPoolCreateFlags> for CommandPoolCreateFlags {
    fn from_iter<T: std::iter::IntoIterator<Item = CommandPoolCreateFlags>>(iterator: T) -> CommandPoolCreateFlags {
        let mut out = CommandPoolCreateFlags::empty();
        out.extend(iterator);
        out
    }
}
impl std::iter::FromIterator<CommandPoolCreateFlagBits> for CommandPoolCreateFlags {
    fn from_iter<T: std::iter::IntoIterator<Item = CommandPoolCreateFlagBits>>(iterator: T) -> CommandPoolCreateFlags {
        let mut out = CommandPoolCreateFlags::empty();
        out.extend(iterator);
        out
    }
}
impl std::fmt::Debug for CommandPoolCreateFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(CommandPoolCreateFlags);
        impl std::fmt::Debug for Flags {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == CommandPoolCreateFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(CommandPoolCreateFlags::CommandPoolCreateTransient) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(CommandPoolCreateTransient))?;
                    }
                    if self
                        .0
                        .contains(CommandPoolCreateFlags::CommandPoolCreateResetCommandBuffer)
                    {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(CommandPoolCreateResetCommandBuffer))?;
                    }
                    if self.0.contains(CommandPoolCreateFlags::Protected) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(Protected))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(CommandPoolCreateFlags))
            .field(&Flags(*self))
            .finish()
    }
}
///[VkCommandPoolResetFlagBits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandPoolResetFlagBits.html) - Bitmask controlling behavior of a command pool reset
///# C Specifications
///Bits which  **can**  be set in [`ResetCommandPool`]`::flags`, controlling
///the reset operation, are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkCommandPoolResetFlagBits {
///    VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT = 0x00000001,
///} VkCommandPoolResetFlagBits;
///```
///# Description
/// - [`CommandPoolResetReleaseResources`] specifies that resetting a command pool recycles all of
///   the resources from the command pool back to the system.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`CommandPoolResetFlags`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(transparent)]
pub struct CommandPoolResetFlags(u32);
impl const Default for CommandPoolResetFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl From<CommandPoolResetFlagBits> for CommandPoolResetFlags {
    fn from(from: CommandPoolResetFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(from as u32) }
    }
}
impl CommandPoolResetFlags {
    ///[`CommandPoolResetReleaseResources`] specifies that
    ///resetting a command pool recycles all of the resources from the command
    ///pool back to the system.
    const CommandPoolResetReleaseResources: Self = Self(1);
    ///No documentation found
    ///
    ///Provided by [`crate::extensions::coreavi_extension_444`]
    const Reserved1Coreavi: Self = Self(2);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    pub const fn all() -> Self {
        Self::empty() | Self::CommandPoolResetReleaseResources | Self::Reserved1Coreavi
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl const std::ops::BitOr for CommandPoolResetFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl std::ops::BitOrAssign for CommandPoolResetFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl const std::ops::BitXor for CommandPoolResetFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl std::ops::BitXorAssign for CommandPoolResetFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl const std::ops::BitAnd for CommandPoolResetFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl std::ops::BitAndAssign for CommandPoolResetFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl const std::ops::Sub for CommandPoolResetFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl std::ops::SubAssign for CommandPoolResetFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl const std::ops::Not for CommandPoolResetFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl std::iter::Extend<CommandPoolResetFlags> for CommandPoolResetFlags {
    fn extend<T: std::iter::IntoIterator<Item = CommandPoolResetFlags>>(&mut self, iterator: T) {
        for i in iterator {
            self.insert(i);
        }
    }
}
impl std::iter::Extend<CommandPoolResetFlagBits> for CommandPoolResetFlags {
    fn extend<T: std::iter::IntoIterator<Item = CommandPoolResetFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            self.insert(CommandPoolResetFlags::from(i));
        }
    }
}
impl std::iter::FromIterator<CommandPoolResetFlags> for CommandPoolResetFlags {
    fn from_iter<T: std::iter::IntoIterator<Item = CommandPoolResetFlags>>(iterator: T) -> CommandPoolResetFlags {
        let mut out = CommandPoolResetFlags::empty();
        out.extend(iterator);
        out
    }
}
impl std::iter::FromIterator<CommandPoolResetFlagBits> for CommandPoolResetFlags {
    fn from_iter<T: std::iter::IntoIterator<Item = CommandPoolResetFlagBits>>(iterator: T) -> CommandPoolResetFlags {
        let mut out = CommandPoolResetFlags::empty();
        out.extend(iterator);
        out
    }
}
impl std::fmt::Debug for CommandPoolResetFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(CommandPoolResetFlags);
        impl std::fmt::Debug for Flags {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == CommandPoolResetFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(CommandPoolResetFlags::CommandPoolResetReleaseResources) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(CommandPoolResetReleaseResources))?;
                    }
                    if self.0.contains(CommandPoolResetFlags::Reserved1Coreavi) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(Reserved1Coreavi))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(CommandPoolResetFlags))
            .field(&Flags(*self))
            .finish()
    }
}
///[VkCommandBufferResetFlagBits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandBufferResetFlagBits.html) - Bitmask controlling behavior of a command buffer reset
///# C Specifications
///Bits which  **can**  be set in [`ResetCommandBuffer`]`::flags`,
///controlling the reset operation, are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkCommandBufferResetFlagBits {
///    VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT = 0x00000001,
///} VkCommandBufferResetFlagBits;
///```
///# Description
/// - [`CommandBufferResetReleaseResources`] specifies that most or all memory resources currently owned by the command buffer  **should**  be returned to the parent command pool. If this flag is not set, then the command buffer  **may**  hold onto memory resources and reuse them when recording commands. `commandBuffer` is moved to the [initial state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#commandbuffers-lifecycle).
///# Related
/// - [`crate::vulkan1_0`]
/// - [`CommandBufferResetFlags`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(transparent)]
pub struct CommandBufferResetFlags(u32);
impl const Default for CommandBufferResetFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl From<CommandBufferResetFlagBits> for CommandBufferResetFlags {
    fn from(from: CommandBufferResetFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(from as u32) }
    }
}
impl CommandBufferResetFlags {
    ///[`CommandBufferResetReleaseResources`] specifies that most
    ///or all memory resources currently owned by the command buffer  **should**  be
    ///returned to the parent command pool.
    ///If this flag is not set, then the command buffer  **may**  hold onto memory
    ///resources and reuse them when recording commands.
    ///`commandBuffer` is moved to the [initial
    ///state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#commandbuffers-lifecycle).
    const CommandBufferResetReleaseResources: Self = Self(1);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    pub const fn all() -> Self {
        Self::empty() | Self::CommandBufferResetReleaseResources
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl const std::ops::BitOr for CommandBufferResetFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl std::ops::BitOrAssign for CommandBufferResetFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl const std::ops::BitXor for CommandBufferResetFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl std::ops::BitXorAssign for CommandBufferResetFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl const std::ops::BitAnd for CommandBufferResetFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl std::ops::BitAndAssign for CommandBufferResetFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl const std::ops::Sub for CommandBufferResetFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl std::ops::SubAssign for CommandBufferResetFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl const std::ops::Not for CommandBufferResetFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl std::iter::Extend<CommandBufferResetFlags> for CommandBufferResetFlags {
    fn extend<T: std::iter::IntoIterator<Item = CommandBufferResetFlags>>(&mut self, iterator: T) {
        for i in iterator {
            self.insert(i);
        }
    }
}
impl std::iter::Extend<CommandBufferResetFlagBits> for CommandBufferResetFlags {
    fn extend<T: std::iter::IntoIterator<Item = CommandBufferResetFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            self.insert(CommandBufferResetFlags::from(i));
        }
    }
}
impl std::iter::FromIterator<CommandBufferResetFlags> for CommandBufferResetFlags {
    fn from_iter<T: std::iter::IntoIterator<Item = CommandBufferResetFlags>>(iterator: T) -> CommandBufferResetFlags {
        let mut out = CommandBufferResetFlags::empty();
        out.extend(iterator);
        out
    }
}
impl std::iter::FromIterator<CommandBufferResetFlagBits> for CommandBufferResetFlags {
    fn from_iter<T: std::iter::IntoIterator<Item = CommandBufferResetFlagBits>>(
        iterator: T,
    ) -> CommandBufferResetFlags {
        let mut out = CommandBufferResetFlags::empty();
        out.extend(iterator);
        out
    }
}
impl std::fmt::Debug for CommandBufferResetFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(CommandBufferResetFlags);
        impl std::fmt::Debug for Flags {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == CommandBufferResetFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self
                        .0
                        .contains(CommandBufferResetFlags::CommandBufferResetReleaseResources)
                    {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(CommandBufferResetReleaseResources))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(CommandBufferResetFlags))
            .field(&Flags(*self))
            .finish()
    }
}
///[VkCommandBufferUsageFlagBits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandBufferUsageFlagBits.html) - Bitmask specifying usage behavior for command buffer
///# C Specifications
///Bits which  **can**  be set in [`CommandBufferBeginInfo::flags`],
///specifying usage behavior for a command buffer, are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkCommandBufferUsageFlagBits {
///    VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT = 0x00000001,
///    VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT = 0x00000002,
///    VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT = 0x00000004,
///} VkCommandBufferUsageFlagBits;
///```
///# Description
/// - [`CommandBufferUsageOneTimeSubmit`] specifies that each recording of the command buffer will
///   only be submitted once, and the command buffer will be reset and recorded again between each
///   submission.
/// - [`CommandBufferUsageRenderPassContinue`] specifies that a secondary command buffer is
///   considered to be entirely inside a render pass. If this is a primary command buffer, then this
///   bit is ignored.
/// - [`CommandBufferUsageSimultaneousUse`] specifies that a command buffer  **can**  be resubmitted
///   to a queue while it is in the *pending state*, and recorded into multiple primary command
///   buffers.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`CommandBufferUsageFlags`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(transparent)]
pub struct CommandBufferUsageFlags(u32);
impl const Default for CommandBufferUsageFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl From<CommandBufferUsageFlagBits> for CommandBufferUsageFlags {
    fn from(from: CommandBufferUsageFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(from as u32) }
    }
}
impl CommandBufferUsageFlags {
    ///[`CommandBufferUsageOneTimeSubmit`] specifies that each
    ///recording of the command buffer will only be submitted once, and the
    ///command buffer will be reset and recorded again between each submission.
    const CommandBufferUsageOneTimeSubmit: Self = Self(1);
    ///[`CommandBufferUsageRenderPassContinue`] specifies that a
    ///secondary command buffer is considered to be entirely inside a render
    ///pass.
    ///If this is a primary command buffer, then this bit is ignored.
    const CommandBufferUsageRenderPassContinue: Self = Self(2);
    ///[`CommandBufferUsageSimultaneousUse`] specifies that a
    ///command buffer  **can**  be resubmitted to a queue while it is in the
    ///*pending state*, and recorded into multiple primary command buffers.
    const CommandBufferUsageSimultaneousUse: Self = Self(4);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    pub const fn all() -> Self {
        Self::empty()
            | Self::CommandBufferUsageOneTimeSubmit
            | Self::CommandBufferUsageRenderPassContinue
            | Self::CommandBufferUsageSimultaneousUse
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl const std::ops::BitOr for CommandBufferUsageFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl std::ops::BitOrAssign for CommandBufferUsageFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl const std::ops::BitXor for CommandBufferUsageFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl std::ops::BitXorAssign for CommandBufferUsageFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl const std::ops::BitAnd for CommandBufferUsageFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl std::ops::BitAndAssign for CommandBufferUsageFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl const std::ops::Sub for CommandBufferUsageFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl std::ops::SubAssign for CommandBufferUsageFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl const std::ops::Not for CommandBufferUsageFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl std::iter::Extend<CommandBufferUsageFlags> for CommandBufferUsageFlags {
    fn extend<T: std::iter::IntoIterator<Item = CommandBufferUsageFlags>>(&mut self, iterator: T) {
        for i in iterator {
            self.insert(i);
        }
    }
}
impl std::iter::Extend<CommandBufferUsageFlagBits> for CommandBufferUsageFlags {
    fn extend<T: std::iter::IntoIterator<Item = CommandBufferUsageFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            self.insert(CommandBufferUsageFlags::from(i));
        }
    }
}
impl std::iter::FromIterator<CommandBufferUsageFlags> for CommandBufferUsageFlags {
    fn from_iter<T: std::iter::IntoIterator<Item = CommandBufferUsageFlags>>(iterator: T) -> CommandBufferUsageFlags {
        let mut out = CommandBufferUsageFlags::empty();
        out.extend(iterator);
        out
    }
}
impl std::iter::FromIterator<CommandBufferUsageFlagBits> for CommandBufferUsageFlags {
    fn from_iter<T: std::iter::IntoIterator<Item = CommandBufferUsageFlagBits>>(
        iterator: T,
    ) -> CommandBufferUsageFlags {
        let mut out = CommandBufferUsageFlags::empty();
        out.extend(iterator);
        out
    }
}
impl std::fmt::Debug for CommandBufferUsageFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(CommandBufferUsageFlags);
        impl std::fmt::Debug for Flags {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == CommandBufferUsageFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self
                        .0
                        .contains(CommandBufferUsageFlags::CommandBufferUsageOneTimeSubmit)
                    {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(CommandBufferUsageOneTimeSubmit))?;
                    }
                    if self
                        .0
                        .contains(CommandBufferUsageFlags::CommandBufferUsageRenderPassContinue)
                    {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(CommandBufferUsageRenderPassContinue))?;
                    }
                    if self
                        .0
                        .contains(CommandBufferUsageFlags::CommandBufferUsageSimultaneousUse)
                    {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(CommandBufferUsageSimultaneousUse))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(CommandBufferUsageFlags))
            .field(&Flags(*self))
            .finish()
    }
}
///[VkQueryPipelineStatisticFlagBits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkQueryPipelineStatisticFlagBits.html) - Bitmask specifying queried pipeline statistics
///# C Specifications
///Bits which  **can**  be set in
///[`QueryPoolCreateInfo::pipeline_statistics`] for query pools and in
///[`CommandBufferInheritanceInfo::pipeline_statistics`] for secondary
///command buffers, individually enabling pipeline statistics counters, are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkQueryPipelineStatisticFlagBits {
///    VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT = 0x00000001,
///    VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT = 0x00000002,
///    VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT = 0x00000004,
///    VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT = 0x00000008,
///    VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT = 0x00000010,
///    VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT = 0x00000020,
///    VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT = 0x00000040,
///    VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT = 0x00000080,
///    VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT = 0x00000100,
///    VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT = 0x00000200,
///    VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT = 0x00000400,
///} VkQueryPipelineStatisticFlagBits;
///```
///# Description
/// - [`QueryPipelineStatisticInputAssemblyVertices`] specifies that queries managed by the pool will count the number of vertices processed by the [input assembly](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#drawing) stage. Vertices corresponding to incomplete primitives  **may**  contribute to the count.
/// - [`QueryPipelineStatisticInputAssemblyPrimitives`] specifies that queries managed by the pool will count the number of primitives processed by the [input assembly](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#drawing) stage. If primitive restart is enabled, restarting the primitive topology has no effect on the count. Incomplete primitives  **may**  be counted.
/// - [`QueryPipelineStatisticVertexShaderInvocations`] specifies that queries managed by the pool will count the number of vertex shader invocations. This counter’s value is incremented each time a vertex shader is [invoked](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#shaders-vertex-execution).
/// - [`QueryPipelineStatisticGeometryShaderInvocations`] specifies that queries managed by the pool
///   will count the number of geometry shader invocations. This counter’s value is incremented each
///   time a geometry shader is [invoked](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#shaders-geometry-execution).
///   In the case of [instanced geometry shaders](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#geometry-invocations),
///   the geometry shader invocations count is incremented for each separate instanced invocation.
/// - [`QueryPipelineStatisticGeometryShaderPrimitives`] specifies that queries managed by the pool
///   will count the number of primitives generated by geometry shader invocations. The counter’s
///   value is incremented each time the geometry shader emits a primitive. Restarting primitive
///   topology using the SPIR-V instructions `OpEndPrimitive` or `OpEndStreamPrimitive` has no
///   effect on the geometry shader output primitives count.
/// - [`QueryPipelineStatisticClippingInvocations`] specifies that queries managed by the pool will count the number of primitives processed by the [Primitive Clipping](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#vertexpostproc-clipping) stage of the pipeline. The counter’s value is incremented each time a primitive reaches the primitive clipping stage.
/// - [`QueryPipelineStatisticClippingPrimitives`] specifies that queries managed by the pool will count the number of primitives output by the [Primitive Clipping](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#vertexpostproc-clipping) stage of the pipeline. The counter’s value is incremented each time a primitive passes the primitive clipping stage. The actual number of primitives output by the primitive clipping stage for a particular input primitive is implementation-dependent but  **must**  satisfy the following conditions:  - If at least one vertex of the input primitive lies inside the clipping volume, the counter is incremented by one or more.  - Otherwise, the counter is incremented by zero or more.
/// - [`QueryPipelineStatisticFragmentShaderInvocations`] specifies that queries managed by the pool
///   will count the number of fragment shader invocations. The counter’s value is incremented each time
///   the fragment shader is [invoked](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fragops-shader).
/// - [`QueryPipelineStatisticTessellationControlShaderPatches`] specifies that queries managed by the pool will count the number of patches processed by the tessellation control shader. The counter’s value is incremented once for each patch for which a tessellation control shader is [invoked](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#shaders-tessellation-control-execution).
/// - [`QueryPipelineStatisticTessellationEvaluationShaderInvocations`] specifies that queries managed by the pool will count the number of invocations of the tessellation evaluation shader. The counter’s value is incremented each time the tessellation evaluation shader is [invoked](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#shaders-tessellation-evaluation-execution).
/// - [`QueryPipelineStatisticComputeShaderInvocations`] specifies that queries managed by the pool
///   will count the number of compute shader invocations. The counter’s value is incremented every
///   time the compute shader is invoked. Implementations  **may**  skip the execution of certain
///   compute shader invocations or execute additional compute shader invocations for
///   implementation-dependent reasons as long as the results of rendering otherwise remain
///   unchanged.
///These values are intended to measure relative statistics on one
///implementation.
///Various device architectures will count these values differently.
///Any or all counters  **may**  be affected by the issues described in
///[Query Operation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#queries-operation-undefined).If a pipeline has `rasterizerDiscardEnable` enabled, implementations
/// **may**  discard primitives after the final
///[pre-rasterization shader
///stage](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-pre-rasterization).
///As a result, if `rasterizerDiscardEnable` is enabled, the clipping input
///and output primitives counters  **may**  not be incremented.When a pipeline statistics query
/// finishes, the result for that query is
///marked as available.
///The application  **can**  copy the result to a buffer (via
///[`CmdCopyQueryPoolResults`]), or request it be put into host memory (via
///[`GetQueryPoolResults`]).
///# Related
/// - [`crate::vulkan1_0`]
/// - [`QueryPipelineStatisticFlags`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(transparent)]
pub struct QueryPipelineStatisticFlags(u32);
impl const Default for QueryPipelineStatisticFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl From<QueryPipelineStatisticFlagBits> for QueryPipelineStatisticFlags {
    fn from(from: QueryPipelineStatisticFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(from as u32) }
    }
}
impl QueryPipelineStatisticFlags {
    ///[`QueryPipelineStatisticInputAssemblyVertices`] specifies
    ///that queries managed by the pool will count the number of vertices
    ///processed by the [input assembly](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#drawing) stage.
    ///Vertices corresponding to incomplete primitives  **may**  contribute to the
    ///count.
    const QueryPipelineStatisticInputAssemblyVertices: Self = Self(1);
    ///[`QueryPipelineStatisticInputAssemblyPrimitives`]
    ///specifies that queries managed by the pool will count the number of
    ///primitives processed by the [input assembly](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#drawing) stage.
    ///If primitive restart is enabled, restarting the primitive topology has
    ///no effect on the count.
    ///Incomplete primitives  **may**  be counted.
    const QueryPipelineStatisticInputAssemblyPrimitives: Self = Self(2);
    ///[`QueryPipelineStatisticVertexShaderInvocations`]
    ///specifies that queries managed by the pool will count the number of
    ///vertex shader invocations.
    ///This counter’s value is incremented each time a vertex shader is
    ///[invoked](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#shaders-vertex-execution).
    const QueryPipelineStatisticVertexShaderInvocations: Self = Self(4);
    ///[`QueryPipelineStatisticGeometryShaderInvocations`]
    ///specifies that queries managed by the pool will count the number of
    ///geometry shader invocations.
    ///This counter’s value is incremented each time a geometry shader is
    ///[invoked](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#shaders-geometry-execution).
    ///In the case of [instanced geometry shaders](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#geometry-invocations), the
    ///geometry shader invocations count is incremented for each separate
    ///instanced invocation.
    const QueryPipelineStatisticGeometryShaderInvocations: Self = Self(8);
    ///[`QueryPipelineStatisticGeometryShaderPrimitives`]
    ///specifies that queries managed by the pool will count the number of
    ///primitives generated by geometry shader invocations.
    ///The counter’s value is incremented each time the geometry shader emits a
    ///primitive.
    ///Restarting primitive topology using the SPIR-V instructions
    ///`OpEndPrimitive` or `OpEndStreamPrimitive` has no effect on the
    ///geometry shader output primitives count.
    const QueryPipelineStatisticGeometryShaderPrimitives: Self = Self(16);
    ///[`QueryPipelineStatisticClippingInvocations`] specifies
    ///that queries managed by the pool will count the number of primitives
    ///processed by the [Primitive Clipping](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#vertexpostproc-clipping) stage of
    ///the pipeline.
    ///The counter’s value is incremented each time a primitive reaches the
    ///primitive clipping stage.
    const QueryPipelineStatisticClippingInvocations: Self = Self(32);
    ///[`QueryPipelineStatisticClippingPrimitives`] specifies that
    ///queries managed by the pool will count the number of primitives output
    ///by the [Primitive Clipping](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#vertexpostproc-clipping) stage of the
    ///pipeline.
    ///The counter’s value is incremented each time a primitive passes the
    ///primitive clipping stage.
    ///The actual number of primitives output by the primitive clipping stage
    ///for a particular input primitive is implementation-dependent but  **must**
    ///satisfy the following conditions:
    /// - If at least one vertex of the input primitive lies inside the clipping volume, the counter
    ///   is incremented by one or more.
    /// - Otherwise, the counter is incremented by zero or more.
    const QueryPipelineStatisticClippingPrimitives: Self = Self(64);
    ///[`QueryPipelineStatisticFragmentShaderInvocations`]
    ///specifies that queries managed by the pool will count the number of
    ///fragment shader invocations.
    ///The counter’s value is incremented each time the fragment shader is
    ///[invoked](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fragops-shader).
    const QueryPipelineStatisticFragmentShaderInvocations: Self = Self(128);
    ///[`QueryPipelineStatisticTessellationControlShaderPatches`]
    ///specifies that queries managed by the pool will count the number of
    ///patches processed by the tessellation control shader.
    ///The counter’s value is incremented once for each patch for which a
    ///tessellation control shader is
    ///[invoked](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#shaders-tessellation-control-execution).
    const QueryPipelineStatisticTessellationControlShaderPatches: Self = Self(256);
    ///[`QueryPipelineStatisticTessellationEvaluationShaderInvocations`]
    ///specifies that queries managed by the pool will count the number of
    ///invocations of the tessellation evaluation shader.
    ///The counter’s value is incremented each time the tessellation evaluation
    ///shader is [invoked](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#shaders-tessellation-evaluation-execution).
    const QueryPipelineStatisticTessellationEvaluationShaderInvocations: Self = Self(512);
    ///[`QueryPipelineStatisticComputeShaderInvocations`]
    ///specifies that queries managed by the pool will count the number of
    ///compute shader invocations.
    ///The counter’s value is incremented every time the compute shader is
    ///invoked.
    ///Implementations  **may**  skip the execution of certain compute shader
    ///invocations or execute additional compute shader invocations for
    ///implementation-dependent reasons as long as the results of rendering
    ///otherwise remain unchanged.
    const QueryPipelineStatisticComputeShaderInvocations: Self = Self(1024);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    pub const fn all() -> Self {
        Self::empty()
            | Self::QueryPipelineStatisticInputAssemblyVertices
            | Self::QueryPipelineStatisticInputAssemblyPrimitives
            | Self::QueryPipelineStatisticVertexShaderInvocations
            | Self::QueryPipelineStatisticGeometryShaderInvocations
            | Self::QueryPipelineStatisticGeometryShaderPrimitives
            | Self::QueryPipelineStatisticClippingInvocations
            | Self::QueryPipelineStatisticClippingPrimitives
            | Self::QueryPipelineStatisticFragmentShaderInvocations
            | Self::QueryPipelineStatisticTessellationControlShaderPatches
            | Self::QueryPipelineStatisticTessellationEvaluationShaderInvocations
            | Self::QueryPipelineStatisticComputeShaderInvocations
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl const std::ops::BitOr for QueryPipelineStatisticFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl std::ops::BitOrAssign for QueryPipelineStatisticFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl const std::ops::BitXor for QueryPipelineStatisticFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl std::ops::BitXorAssign for QueryPipelineStatisticFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl const std::ops::BitAnd for QueryPipelineStatisticFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl std::ops::BitAndAssign for QueryPipelineStatisticFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl const std::ops::Sub for QueryPipelineStatisticFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl std::ops::SubAssign for QueryPipelineStatisticFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl const std::ops::Not for QueryPipelineStatisticFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl std::iter::Extend<QueryPipelineStatisticFlags> for QueryPipelineStatisticFlags {
    fn extend<T: std::iter::IntoIterator<Item = QueryPipelineStatisticFlags>>(&mut self, iterator: T) {
        for i in iterator {
            self.insert(i);
        }
    }
}
impl std::iter::Extend<QueryPipelineStatisticFlagBits> for QueryPipelineStatisticFlags {
    fn extend<T: std::iter::IntoIterator<Item = QueryPipelineStatisticFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            self.insert(QueryPipelineStatisticFlags::from(i));
        }
    }
}
impl std::iter::FromIterator<QueryPipelineStatisticFlags> for QueryPipelineStatisticFlags {
    fn from_iter<T: std::iter::IntoIterator<Item = QueryPipelineStatisticFlags>>(
        iterator: T,
    ) -> QueryPipelineStatisticFlags {
        let mut out = QueryPipelineStatisticFlags::empty();
        out.extend(iterator);
        out
    }
}
impl std::iter::FromIterator<QueryPipelineStatisticFlagBits> for QueryPipelineStatisticFlags {
    fn from_iter<T: std::iter::IntoIterator<Item = QueryPipelineStatisticFlagBits>>(
        iterator: T,
    ) -> QueryPipelineStatisticFlags {
        let mut out = QueryPipelineStatisticFlags::empty();
        out.extend(iterator);
        out
    }
}
impl std::fmt::Debug for QueryPipelineStatisticFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(QueryPipelineStatisticFlags);
        impl std::fmt::Debug for Flags {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == QueryPipelineStatisticFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self
                        .0
                        .contains(QueryPipelineStatisticFlags::QueryPipelineStatisticInputAssemblyVertices)
                    {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(QueryPipelineStatisticInputAssemblyVertices))?;
                    }
                    if self
                        .0
                        .contains(QueryPipelineStatisticFlags::QueryPipelineStatisticInputAssemblyPrimitives)
                    {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(QueryPipelineStatisticInputAssemblyPrimitives))?;
                    }
                    if self
                        .0
                        .contains(QueryPipelineStatisticFlags::QueryPipelineStatisticVertexShaderInvocations)
                    {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(QueryPipelineStatisticVertexShaderInvocations))?;
                    }
                    if self
                        .0
                        .contains(QueryPipelineStatisticFlags::QueryPipelineStatisticGeometryShaderInvocations)
                    {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(QueryPipelineStatisticGeometryShaderInvocations))?;
                    }
                    if self
                        .0
                        .contains(QueryPipelineStatisticFlags::QueryPipelineStatisticGeometryShaderPrimitives)
                    {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(QueryPipelineStatisticGeometryShaderPrimitives))?;
                    }
                    if self
                        .0
                        .contains(QueryPipelineStatisticFlags::QueryPipelineStatisticClippingInvocations)
                    {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(QueryPipelineStatisticClippingInvocations))?;
                    }
                    if self
                        .0
                        .contains(QueryPipelineStatisticFlags::QueryPipelineStatisticClippingPrimitives)
                    {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(QueryPipelineStatisticClippingPrimitives))?;
                    }
                    if self
                        .0
                        .contains(QueryPipelineStatisticFlags::QueryPipelineStatisticFragmentShaderInvocations)
                    {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(QueryPipelineStatisticFragmentShaderInvocations))?;
                    }
                    if self
                        .0
                        .contains(QueryPipelineStatisticFlags::QueryPipelineStatisticTessellationControlShaderPatches)
                    {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(QueryPipelineStatisticTessellationControlShaderPatches))?;
                    }
                    if self.0.contains(
                        QueryPipelineStatisticFlags::QueryPipelineStatisticTessellationEvaluationShaderInvocations,
                    ) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(
                            QueryPipelineStatisticTessellationEvaluationShaderInvocations
                        ))?;
                    }
                    if self
                        .0
                        .contains(QueryPipelineStatisticFlags::QueryPipelineStatisticComputeShaderInvocations)
                    {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(QueryPipelineStatisticComputeShaderInvocations))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(QueryPipelineStatisticFlags))
            .field(&Flags(*self))
            .finish()
    }
}
///[VkMemoryMapFlags](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryMapFlags.html) - Reserved for future use
///# C Specifications
///```c
///// Provided by VK_VERSION_1_0
///typedef VkFlags VkMemoryMapFlags;
///```
///# Related
/// - [`crate::vulkan1_0`]
/// - [`MapMemory`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(transparent)]
pub struct MemoryMapFlags(u32);
impl const Default for MemoryMapFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl std::fmt::Debug for MemoryMapFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        f.debug_tuple(stringify!(MemoryMapFlags)).field(&self.0).finish()
    }
}
///[VkImageAspectFlagBits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageAspectFlagBits.html) - Bitmask specifying which aspects of an image are included in a view
///# C Specifications
///Bits which  **can**  be set in an aspect mask to specify aspects of an image for
///purposes such as identifying a subresource, are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkImageAspectFlagBits {
///    VK_IMAGE_ASPECT_COLOR_BIT = 0x00000001,
///    VK_IMAGE_ASPECT_DEPTH_BIT = 0x00000002,
///    VK_IMAGE_ASPECT_STENCIL_BIT = 0x00000004,
///    VK_IMAGE_ASPECT_METADATA_BIT = 0x00000008,
///  // Provided by VK_VERSION_1_1
///    VK_IMAGE_ASPECT_PLANE_0_BIT = 0x00000010,
///  // Provided by VK_VERSION_1_1
///    VK_IMAGE_ASPECT_PLANE_1_BIT = 0x00000020,
///  // Provided by VK_VERSION_1_1
///    VK_IMAGE_ASPECT_PLANE_2_BIT = 0x00000040,
///  // Provided by VK_VERSION_1_3
///    VK_IMAGE_ASPECT_NONE = 0,
///  // Provided by VK_EXT_image_drm_format_modifier
///    VK_IMAGE_ASPECT_MEMORY_PLANE_0_BIT_EXT = 0x00000080,
///  // Provided by VK_EXT_image_drm_format_modifier
///    VK_IMAGE_ASPECT_MEMORY_PLANE_1_BIT_EXT = 0x00000100,
///  // Provided by VK_EXT_image_drm_format_modifier
///    VK_IMAGE_ASPECT_MEMORY_PLANE_2_BIT_EXT = 0x00000200,
///  // Provided by VK_EXT_image_drm_format_modifier
///    VK_IMAGE_ASPECT_MEMORY_PLANE_3_BIT_EXT = 0x00000400,
///  // Provided by VK_KHR_sampler_ycbcr_conversion
///    VK_IMAGE_ASPECT_PLANE_0_BIT_KHR = VK_IMAGE_ASPECT_PLANE_0_BIT,
///  // Provided by VK_KHR_sampler_ycbcr_conversion
///    VK_IMAGE_ASPECT_PLANE_1_BIT_KHR = VK_IMAGE_ASPECT_PLANE_1_BIT,
///  // Provided by VK_KHR_sampler_ycbcr_conversion
///    VK_IMAGE_ASPECT_PLANE_2_BIT_KHR = VK_IMAGE_ASPECT_PLANE_2_BIT,
///  // Provided by VK_KHR_maintenance4
///    VK_IMAGE_ASPECT_NONE_KHR = VK_IMAGE_ASPECT_NONE,
///} VkImageAspectFlagBits;
///```
///# Description
/// - [`None`] specifies no image aspect, or the image aspect is not applicable.
/// - [`ImageAspectColor`] specifies the color aspect.
/// - [`ImageAspectDepth`] specifies the depth aspect.
/// - [`ImageAspectStencil`] specifies the stencil aspect.
/// - [`ImageAspectMetadata`] specifies the metadata aspect, used for [sparse resource](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#sparsememory)
///   operations.
/// - [`Plane0`] specifies plane 0 of a *multi-planar* image format.
/// - [`Plane1`] specifies plane 1 of a *multi-planar* image format.
/// - [`Plane2`] specifies plane 2 of a *multi-planar* image format.
/// - [`MemoryPlane0Ext`] specifies *memory plane* 0.
/// - [`MemoryPlane1Ext`] specifies *memory plane* 1.
/// - [`MemoryPlane2Ext`] specifies *memory plane* 2.
/// - [`MemoryPlane3Ext`] specifies *memory plane* 3.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`BindImagePlaneMemoryInfo`]
/// - [`DeviceImageMemoryRequirements`]
/// - [`ImageAspectFlags`]
/// - [`ImagePlaneMemoryRequirementsInfo`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(transparent)]
pub struct ImageAspectFlags(u32);
impl const Default for ImageAspectFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl From<ImageAspectFlagBits> for ImageAspectFlags {
    fn from(from: ImageAspectFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(from as u32) }
    }
}
impl ImageAspectFlags {
    ///[`ImageAspectColor`] specifies the color aspect.
    const ImageAspectColor: Self = Self(1);
    ///[`ImageAspectDepth`] specifies the depth aspect.
    const ImageAspectDepth: Self = Self(2);
    ///[`ImageAspectStencil`] specifies the stencil aspect.
    const ImageAspectStencil: Self = Self(4);
    ///[`ImageAspectMetadata`] specifies the metadata aspect, used
    ///for [sparse resource](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#sparsememory) operations.
    const ImageAspectMetadata: Self = Self(8);
    ///[`Plane0`] specifies plane 0 of a *multi-planar*
    ///image format.
    ///
    ///Provided by [`crate::vulkan1_1`]
    const Plane0: Self = Self(16);
    ///[`Plane1`] specifies plane 1 of a *multi-planar*
    ///image format.
    ///
    ///Provided by [`crate::vulkan1_1`]
    const Plane1: Self = Self(32);
    ///[`Plane2`] specifies plane 2 of a *multi-planar*
    ///image format.
    ///
    ///Provided by [`crate::vulkan1_1`]
    const Plane2: Self = Self(64);
    ///[`None`] specifies no image aspect, or the image
    ///aspect is not applicable.
    ///
    ///Provided by [`crate::vulkan1_3`]
    const None: Self = Self(0);
    ///[`MemoryPlane0Ext`] specifies *memory plane* 0.
    ///
    ///Provided by [`crate::extensions::ext_image_drm_format_modifier`]
    const MemoryPlane0Ext: Self = Self(128);
    ///[`MemoryPlane1Ext`] specifies *memory plane* 1.
    ///
    ///Provided by [`crate::extensions::ext_image_drm_format_modifier`]
    const MemoryPlane1Ext: Self = Self(256);
    ///[`MemoryPlane2Ext`] specifies *memory plane* 2.
    ///
    ///Provided by [`crate::extensions::ext_image_drm_format_modifier`]
    const MemoryPlane2Ext: Self = Self(512);
    ///[`MemoryPlane3Ext`] specifies *memory plane* 3.
    ///
    ///Provided by [`crate::extensions::ext_image_drm_format_modifier`]
    const MemoryPlane3Ext: Self = Self(1024);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    pub const fn all() -> Self {
        Self::empty()
            | Self::ImageAspectColor
            | Self::ImageAspectDepth
            | Self::ImageAspectStencil
            | Self::ImageAspectMetadata
            | Self::Plane0
            | Self::Plane1
            | Self::Plane2
            | Self::None
            | Self::MemoryPlane0Ext
            | Self::MemoryPlane1Ext
            | Self::MemoryPlane2Ext
            | Self::MemoryPlane3Ext
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl const std::ops::BitOr for ImageAspectFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl std::ops::BitOrAssign for ImageAspectFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl const std::ops::BitXor for ImageAspectFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl std::ops::BitXorAssign for ImageAspectFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl const std::ops::BitAnd for ImageAspectFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl std::ops::BitAndAssign for ImageAspectFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl const std::ops::Sub for ImageAspectFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl std::ops::SubAssign for ImageAspectFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl const std::ops::Not for ImageAspectFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl std::iter::Extend<ImageAspectFlags> for ImageAspectFlags {
    fn extend<T: std::iter::IntoIterator<Item = ImageAspectFlags>>(&mut self, iterator: T) {
        for i in iterator {
            self.insert(i);
        }
    }
}
impl std::iter::Extend<ImageAspectFlagBits> for ImageAspectFlags {
    fn extend<T: std::iter::IntoIterator<Item = ImageAspectFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            self.insert(ImageAspectFlags::from(i));
        }
    }
}
impl std::iter::FromIterator<ImageAspectFlags> for ImageAspectFlags {
    fn from_iter<T: std::iter::IntoIterator<Item = ImageAspectFlags>>(iterator: T) -> ImageAspectFlags {
        let mut out = ImageAspectFlags::empty();
        out.extend(iterator);
        out
    }
}
impl std::iter::FromIterator<ImageAspectFlagBits> for ImageAspectFlags {
    fn from_iter<T: std::iter::IntoIterator<Item = ImageAspectFlagBits>>(iterator: T) -> ImageAspectFlags {
        let mut out = ImageAspectFlags::empty();
        out.extend(iterator);
        out
    }
}
impl std::fmt::Debug for ImageAspectFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(ImageAspectFlags);
        impl std::fmt::Debug for Flags {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == ImageAspectFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(ImageAspectFlags::ImageAspectColor) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(ImageAspectColor))?;
                    }
                    if self.0.contains(ImageAspectFlags::ImageAspectDepth) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(ImageAspectDepth))?;
                    }
                    if self.0.contains(ImageAspectFlags::ImageAspectStencil) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(ImageAspectStencil))?;
                    }
                    if self.0.contains(ImageAspectFlags::ImageAspectMetadata) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(ImageAspectMetadata))?;
                    }
                    if self.0.contains(ImageAspectFlags::Plane0) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(Plane0))?;
                    }
                    if self.0.contains(ImageAspectFlags::Plane1) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(Plane1))?;
                    }
                    if self.0.contains(ImageAspectFlags::Plane2) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(Plane2))?;
                    }
                    if self.0.contains(ImageAspectFlags::None) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(None))?;
                    }
                    if self.0.contains(ImageAspectFlags::MemoryPlane0Ext) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(MemoryPlane0Ext))?;
                    }
                    if self.0.contains(ImageAspectFlags::MemoryPlane1Ext) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(MemoryPlane1Ext))?;
                    }
                    if self.0.contains(ImageAspectFlags::MemoryPlane2Ext) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(MemoryPlane2Ext))?;
                    }
                    if self.0.contains(ImageAspectFlags::MemoryPlane3Ext) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(MemoryPlane3Ext))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(ImageAspectFlags))
            .field(&Flags(*self))
            .finish()
    }
}
///[VkSparseMemoryBindFlagBits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSparseMemoryBindFlagBits.html) - Bitmask specifying usage of a sparse memory binding operation
///# C Specifications
///Bits which  **can**  be set in [`SparseMemoryBind::flags`], specifying
///usage of a sparse memory binding operation, are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkSparseMemoryBindFlagBits {
///    VK_SPARSE_MEMORY_BIND_METADATA_BIT = 0x00000001,
///} VkSparseMemoryBindFlagBits;
///```
///# Description
/// - [`SparseMemoryBindMetadata`] specifies that the memory being bound is only for the metadata
///   aspect.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`SparseMemoryBindFlags`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(transparent)]
pub struct SparseMemoryBindFlags(u32);
impl const Default for SparseMemoryBindFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl From<SparseMemoryBindFlagBits> for SparseMemoryBindFlags {
    fn from(from: SparseMemoryBindFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(from as u32) }
    }
}
impl SparseMemoryBindFlags {
    ///[`SparseMemoryBindMetadata`] specifies that the memory being
    ///bound is only for the metadata aspect.
    const SparseMemoryBindMetadata: Self = Self(1);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    pub const fn all() -> Self {
        Self::empty() | Self::SparseMemoryBindMetadata
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl const std::ops::BitOr for SparseMemoryBindFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl std::ops::BitOrAssign for SparseMemoryBindFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl const std::ops::BitXor for SparseMemoryBindFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl std::ops::BitXorAssign for SparseMemoryBindFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl const std::ops::BitAnd for SparseMemoryBindFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl std::ops::BitAndAssign for SparseMemoryBindFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl const std::ops::Sub for SparseMemoryBindFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl std::ops::SubAssign for SparseMemoryBindFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl const std::ops::Not for SparseMemoryBindFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl std::iter::Extend<SparseMemoryBindFlags> for SparseMemoryBindFlags {
    fn extend<T: std::iter::IntoIterator<Item = SparseMemoryBindFlags>>(&mut self, iterator: T) {
        for i in iterator {
            self.insert(i);
        }
    }
}
impl std::iter::Extend<SparseMemoryBindFlagBits> for SparseMemoryBindFlags {
    fn extend<T: std::iter::IntoIterator<Item = SparseMemoryBindFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            self.insert(SparseMemoryBindFlags::from(i));
        }
    }
}
impl std::iter::FromIterator<SparseMemoryBindFlags> for SparseMemoryBindFlags {
    fn from_iter<T: std::iter::IntoIterator<Item = SparseMemoryBindFlags>>(iterator: T) -> SparseMemoryBindFlags {
        let mut out = SparseMemoryBindFlags::empty();
        out.extend(iterator);
        out
    }
}
impl std::iter::FromIterator<SparseMemoryBindFlagBits> for SparseMemoryBindFlags {
    fn from_iter<T: std::iter::IntoIterator<Item = SparseMemoryBindFlagBits>>(iterator: T) -> SparseMemoryBindFlags {
        let mut out = SparseMemoryBindFlags::empty();
        out.extend(iterator);
        out
    }
}
impl std::fmt::Debug for SparseMemoryBindFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(SparseMemoryBindFlags);
        impl std::fmt::Debug for Flags {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == SparseMemoryBindFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(SparseMemoryBindFlags::SparseMemoryBindMetadata) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(SparseMemoryBindMetadata))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(SparseMemoryBindFlags))
            .field(&Flags(*self))
            .finish()
    }
}
///[VkSparseImageFormatFlagBits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSparseImageFormatFlagBits.html) - Bitmask specifying additional information about a sparse image resource
///# C Specifications
///Bits which  **may**  be set in [`SparseImageFormatProperties::flags`],
///specifying additional information about the sparse resource, are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkSparseImageFormatFlagBits {
///    VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT = 0x00000001,
///    VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT = 0x00000002,
///    VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT = 0x00000004,
///} VkSparseImageFormatFlagBits;
///```
///# Description
/// - [`SparseImageFormatSingleMiptail`] specifies that the image uses a single mip tail region for
///   all array layers.
/// - [`SparseImageFormatAlignedMipSize`] specifies that the first mip level whose dimensions are
///   not integer multiples of the corresponding dimensions of the sparse image block begins the mip
///   tail region.
/// - [`SparseImageFormatNonstandardBlockSize`] specifies that the image uses non-standard sparse
///   image block dimensions, and the `imageGranularity` values do not match the standard sparse
///   image block dimensions for the given format.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`SparseImageFormatFlags`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(transparent)]
pub struct SparseImageFormatFlags(u32);
impl const Default for SparseImageFormatFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl From<SparseImageFormatFlagBits> for SparseImageFormatFlags {
    fn from(from: SparseImageFormatFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(from as u32) }
    }
}
impl SparseImageFormatFlags {
    ///[`SparseImageFormatSingleMiptail`] specifies that the image
    ///uses a single mip tail region for all array layers.
    const SparseImageFormatSingleMiptail: Self = Self(1);
    ///[`SparseImageFormatAlignedMipSize`] specifies that the
    ///first mip level whose dimensions are not integer multiples of the
    ///corresponding dimensions of the sparse image block begins the mip tail
    ///region.
    const SparseImageFormatAlignedMipSize: Self = Self(2);
    ///[`SparseImageFormatNonstandardBlockSize`] specifies that
    ///the image uses non-standard sparse image block dimensions, and the
    ///`imageGranularity` values do not match the standard sparse image
    ///block dimensions for the given format.
    const SparseImageFormatNonstandardBlockSize: Self = Self(4);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    pub const fn all() -> Self {
        Self::empty()
            | Self::SparseImageFormatSingleMiptail
            | Self::SparseImageFormatAlignedMipSize
            | Self::SparseImageFormatNonstandardBlockSize
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl const std::ops::BitOr for SparseImageFormatFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl std::ops::BitOrAssign for SparseImageFormatFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl const std::ops::BitXor for SparseImageFormatFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl std::ops::BitXorAssign for SparseImageFormatFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl const std::ops::BitAnd for SparseImageFormatFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl std::ops::BitAndAssign for SparseImageFormatFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl const std::ops::Sub for SparseImageFormatFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl std::ops::SubAssign for SparseImageFormatFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl const std::ops::Not for SparseImageFormatFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl std::iter::Extend<SparseImageFormatFlags> for SparseImageFormatFlags {
    fn extend<T: std::iter::IntoIterator<Item = SparseImageFormatFlags>>(&mut self, iterator: T) {
        for i in iterator {
            self.insert(i);
        }
    }
}
impl std::iter::Extend<SparseImageFormatFlagBits> for SparseImageFormatFlags {
    fn extend<T: std::iter::IntoIterator<Item = SparseImageFormatFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            self.insert(SparseImageFormatFlags::from(i));
        }
    }
}
impl std::iter::FromIterator<SparseImageFormatFlags> for SparseImageFormatFlags {
    fn from_iter<T: std::iter::IntoIterator<Item = SparseImageFormatFlags>>(iterator: T) -> SparseImageFormatFlags {
        let mut out = SparseImageFormatFlags::empty();
        out.extend(iterator);
        out
    }
}
impl std::iter::FromIterator<SparseImageFormatFlagBits> for SparseImageFormatFlags {
    fn from_iter<T: std::iter::IntoIterator<Item = SparseImageFormatFlagBits>>(iterator: T) -> SparseImageFormatFlags {
        let mut out = SparseImageFormatFlags::empty();
        out.extend(iterator);
        out
    }
}
impl std::fmt::Debug for SparseImageFormatFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(SparseImageFormatFlags);
        impl std::fmt::Debug for Flags {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == SparseImageFormatFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(SparseImageFormatFlags::SparseImageFormatSingleMiptail) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(SparseImageFormatSingleMiptail))?;
                    }
                    if self.0.contains(SparseImageFormatFlags::SparseImageFormatAlignedMipSize) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(SparseImageFormatAlignedMipSize))?;
                    }
                    if self
                        .0
                        .contains(SparseImageFormatFlags::SparseImageFormatNonstandardBlockSize)
                    {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(SparseImageFormatNonstandardBlockSize))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(SparseImageFormatFlags))
            .field(&Flags(*self))
            .finish()
    }
}
///[VkSubpassDescriptionFlagBits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSubpassDescriptionFlagBits.html) - Bitmask specifying usage of a subpass
///# C Specifications
///Bits which  **can**  be set in [`SubpassDescription::flags`],
///specifying usage of the subpass, are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkSubpassDescriptionFlagBits {
///  // Provided by VK_NVX_multiview_per_view_attributes
///    VK_SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX = 0x00000001,
///  // Provided by VK_NVX_multiview_per_view_attributes
///    VK_SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX = 0x00000002,
///  // Provided by VK_QCOM_render_pass_shader_resolve
///    VK_SUBPASS_DESCRIPTION_FRAGMENT_REGION_BIT_QCOM = 0x00000004,
///  // Provided by VK_QCOM_render_pass_shader_resolve
///    VK_SUBPASS_DESCRIPTION_SHADER_RESOLVE_BIT_QCOM = 0x00000008,
///  // Provided by VK_ARM_rasterization_order_attachment_access
///    VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_COLOR_ACCESS_BIT_ARM = 0x00000010,
///  // Provided by VK_ARM_rasterization_order_attachment_access
///    VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_ARM = 0x00000020,
///  // Provided by VK_ARM_rasterization_order_attachment_access
///    VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_ARM = 0x00000040,
///} VkSubpassDescriptionFlagBits;
///```
///# Description
/// - [`PerViewAttributesNvx`] specifies that shaders compiled for this subpass write the attributes
///   for all views in a single invocation of each [pre-rasterization shader stage](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-pre-rasterization).
///   All pipelines compiled against a subpass that includes this bit  **must**  write per-view
///   attributes to the `*PerViewNV[]` shader outputs, in addition to the non-per-view (e.g.
///   `Position`) outputs.
/// - [`PerViewPositionXOnlyNvx`] specifies that shaders compiled for this subpass use per-view
///   positions which only differ in value in the x component. Per-view viewport mask  **can**  also
///   be used.
/// - [`FragmentRegionQcom`] specifies that the framebuffer region is the fragment region, that is,
///   the minimum region dependencies are by pixel rather than by sample, such that any fragment
///   shader invocation  **can**  access any sample associated with that fragment shader invocation.
/// - [`ShaderResolveQcom`] specifies that the subpass performs shader resolve operations.
/// - [`RasterizationOrderAttachmentColorAccessArm`] specifies that this subpass supports pipelines
///   created with
///   `VK_PIPELINE_COLOR_BLEND_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_ARM`.
/// - [`RasterizationOrderAttachmentDepthAccessArm`] specifies that this subpass supports pipelines
///   created with
///   `VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_ARM`.
/// - [`RasterizationOrderAttachmentStencilAccessArm`] specifies that this subpass supports
///   pipelines created with
///   `VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_ARM`.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`SubpassDescriptionFlags`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(transparent)]
pub struct SubpassDescriptionFlags(u32);
impl const Default for SubpassDescriptionFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl From<SubpassDescriptionFlagBits> for SubpassDescriptionFlags {
    fn from(from: SubpassDescriptionFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(from as u32) }
    }
}
impl SubpassDescriptionFlags {
    ///[`PerViewAttributesNvx`] specifies that
    ///shaders compiled for this subpass write the attributes for all views in
    ///a single invocation of each
    ///[pre-rasterization shader
    ///stage](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-pre-rasterization).
    ///All pipelines compiled against a subpass that includes this bit  **must**
    ///write per-view attributes to the `*PerViewNV[]` shader outputs, in
    ///addition to the non-per-view (e.g. `Position`) outputs.
    ///
    ///Provided by [`crate::extensions::nvx_multiview_per_view_attributes`]
    const PerViewAttributesNvx: Self = Self(1);
    ///[`PerViewPositionXOnlyNvx`] specifies
    ///that shaders compiled for this subpass use per-view positions which only
    ///differ in value in the x component.
    ///Per-view viewport mask  **can**  also be used.
    ///
    ///Provided by [`crate::extensions::nvx_multiview_per_view_attributes`]
    const PerViewPositionXOnlyNvx: Self = Self(2);
    ///[`FragmentRegionQcom`] specifies that the
    ///framebuffer region is the fragment region, that is, the minimum region
    ///dependencies are by pixel rather than by sample, such that any fragment
    ///shader invocation  **can**  access any sample associated with that fragment
    ///shader invocation.
    ///
    ///Provided by [`crate::extensions::qcom_render_pass_shader_resolve`]
    const FragmentRegionQcom: Self = Self(4);
    ///[`ShaderResolveQcom`] specifies that the
    ///subpass performs shader resolve operations.
    ///
    ///Provided by [`crate::extensions::qcom_render_pass_shader_resolve`]
    const ShaderResolveQcom: Self = Self(8);
    ///[`RasterizationOrderAttachmentColorAccessArm`]
    ///specifies that this subpass supports pipelines created with
    ///`VK_PIPELINE_COLOR_BLEND_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_ARM`.
    ///
    ///Provided by [`crate::extensions::arm_rasterization_order_attachment_access`]
    const RasterizationOrderAttachmentColorAccessArm: Self = Self(16);
    ///[`RasterizationOrderAttachmentDepthAccessArm`]
    ///specifies that this subpass supports pipelines created with
    ///`VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_ARM`.
    ///
    ///Provided by [`crate::extensions::arm_rasterization_order_attachment_access`]
    const RasterizationOrderAttachmentDepthAccessArm: Self = Self(32);
    ///[`RasterizationOrderAttachmentStencilAccessArm`]
    ///specifies that this subpass supports pipelines created with
    ///`VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_ARM`.
    ///
    ///Provided by [`crate::extensions::arm_rasterization_order_attachment_access`]
    const RasterizationOrderAttachmentStencilAccessArm: Self = Self(64);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    pub const fn all() -> Self {
        Self::empty()
            | Self::PerViewAttributesNvx
            | Self::PerViewPositionXOnlyNvx
            | Self::FragmentRegionQcom
            | Self::ShaderResolveQcom
            | Self::RasterizationOrderAttachmentColorAccessArm
            | Self::RasterizationOrderAttachmentDepthAccessArm
            | Self::RasterizationOrderAttachmentStencilAccessArm
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl const std::ops::BitOr for SubpassDescriptionFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl std::ops::BitOrAssign for SubpassDescriptionFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl const std::ops::BitXor for SubpassDescriptionFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl std::ops::BitXorAssign for SubpassDescriptionFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl const std::ops::BitAnd for SubpassDescriptionFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl std::ops::BitAndAssign for SubpassDescriptionFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl const std::ops::Sub for SubpassDescriptionFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl std::ops::SubAssign for SubpassDescriptionFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl const std::ops::Not for SubpassDescriptionFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl std::iter::Extend<SubpassDescriptionFlags> for SubpassDescriptionFlags {
    fn extend<T: std::iter::IntoIterator<Item = SubpassDescriptionFlags>>(&mut self, iterator: T) {
        for i in iterator {
            self.insert(i);
        }
    }
}
impl std::iter::Extend<SubpassDescriptionFlagBits> for SubpassDescriptionFlags {
    fn extend<T: std::iter::IntoIterator<Item = SubpassDescriptionFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            self.insert(SubpassDescriptionFlags::from(i));
        }
    }
}
impl std::iter::FromIterator<SubpassDescriptionFlags> for SubpassDescriptionFlags {
    fn from_iter<T: std::iter::IntoIterator<Item = SubpassDescriptionFlags>>(iterator: T) -> SubpassDescriptionFlags {
        let mut out = SubpassDescriptionFlags::empty();
        out.extend(iterator);
        out
    }
}
impl std::iter::FromIterator<SubpassDescriptionFlagBits> for SubpassDescriptionFlags {
    fn from_iter<T: std::iter::IntoIterator<Item = SubpassDescriptionFlagBits>>(
        iterator: T,
    ) -> SubpassDescriptionFlags {
        let mut out = SubpassDescriptionFlags::empty();
        out.extend(iterator);
        out
    }
}
impl std::fmt::Debug for SubpassDescriptionFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(SubpassDescriptionFlags);
        impl std::fmt::Debug for Flags {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == SubpassDescriptionFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(SubpassDescriptionFlags::PerViewAttributesNvx) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(PerViewAttributesNvx))?;
                    }
                    if self.0.contains(SubpassDescriptionFlags::PerViewPositionXOnlyNvx) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(PerViewPositionXOnlyNvx))?;
                    }
                    if self.0.contains(SubpassDescriptionFlags::FragmentRegionQcom) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(FragmentRegionQcom))?;
                    }
                    if self.0.contains(SubpassDescriptionFlags::ShaderResolveQcom) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(ShaderResolveQcom))?;
                    }
                    if self
                        .0
                        .contains(SubpassDescriptionFlags::RasterizationOrderAttachmentColorAccessArm)
                    {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(RasterizationOrderAttachmentColorAccessArm))?;
                    }
                    if self
                        .0
                        .contains(SubpassDescriptionFlags::RasterizationOrderAttachmentDepthAccessArm)
                    {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(RasterizationOrderAttachmentDepthAccessArm))?;
                    }
                    if self
                        .0
                        .contains(SubpassDescriptionFlags::RasterizationOrderAttachmentStencilAccessArm)
                    {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(RasterizationOrderAttachmentStencilAccessArm))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(SubpassDescriptionFlags))
            .field(&Flags(*self))
            .finish()
    }
}
///[VkPipelineStageFlagBits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineStageFlagBits.html) - Bitmask specifying pipeline stages
///# C Specifications
///Bits which  **can**  be set in a [`PipelineStageFlags`] mask, specifying
///stages of execution, are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkPipelineStageFlagBits {
///    VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT = 0x00000001,
///    VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT = 0x00000002,
///    VK_PIPELINE_STAGE_VERTEX_INPUT_BIT = 0x00000004,
///    VK_PIPELINE_STAGE_VERTEX_SHADER_BIT = 0x00000008,
///    VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT = 0x00000010,
///    VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT = 0x00000020,
///    VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT = 0x00000040,
///    VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT = 0x00000080,
///    VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT = 0x00000100,
///    VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT = 0x00000200,
///    VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT = 0x00000400,
///    VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT = 0x00000800,
///    VK_PIPELINE_STAGE_TRANSFER_BIT = 0x00001000,
///    VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT = 0x00002000,
///    VK_PIPELINE_STAGE_HOST_BIT = 0x00004000,
///    VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT = 0x00008000,
///    VK_PIPELINE_STAGE_ALL_COMMANDS_BIT = 0x00010000,
///  // Provided by VK_VERSION_1_3
///    VK_PIPELINE_STAGE_NONE = 0,
///  // Provided by VK_EXT_transform_feedback
///    VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT = 0x01000000,
///  // Provided by VK_EXT_conditional_rendering
///    VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT = 0x00040000,
///  // Provided by VK_KHR_acceleration_structure
///    VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR = 0x02000000,
///  // Provided by VK_KHR_ray_tracing_pipeline
///    VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_KHR = 0x00200000,
///  // Provided by VK_NV_mesh_shader
///    VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV = 0x00080000,
///  // Provided by VK_NV_mesh_shader
///    VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV = 0x00100000,
///  // Provided by VK_EXT_fragment_density_map
///    VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT = 0x00800000,
///  // Provided by VK_KHR_fragment_shading_rate
///    VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = 0x00400000,
///  // Provided by VK_NV_device_generated_commands
///    VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_NV = 0x00020000,
///  // Provided by VK_NV_shading_rate_image
///    VK_PIPELINE_STAGE_SHADING_RATE_IMAGE_BIT_NV =
/// VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR,
///  // Provided by VK_NV_ray_tracing
///    VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_NV = VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_KHR,
///  // Provided by VK_NV_ray_tracing
///    VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_NV =
/// VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR,
///  // Provided by VK_KHR_synchronization2
///    VK_PIPELINE_STAGE_NONE_KHR = VK_PIPELINE_STAGE_NONE,
///} VkPipelineStageFlagBits;
///```
///# Description
///These values all have the same meaning as the equivalently named values for
///[`PipelineStageFlags2`].
/// - [`None`] specifies no stages of execution.
/// - [`PipelineStageDrawIndirect`] specifies the stage of the pipeline where `VkDrawIndirect*` /
///   `VkDispatchIndirect*` / `VkTraceRaysIndirect*` data structures are consumed. This stage also
///   includes reading commands written by [`CmdExecuteGeneratedCommandsNV`].
/// - [`TaskShaderNv`] specifies the task shader stage.
/// - [`MeshShaderNv`] specifies the mesh shader stage.
/// - [`PipelineStageVertexInput`] specifies the stage of the pipeline where vertex and index
///   buffers are consumed.
/// - [`PipelineStageVertexShader`] specifies the vertex shader stage.
/// - [`PipelineStageTessellationControlShader`] specifies the tessellation control shader stage.
/// - [`PipelineStageTessellationEvaluationShader`] specifies the tessellation evaluation shader
///   stage.
/// - [`PipelineStageGeometryShader`] specifies the geometry shader stage.
/// - [`PipelineStageFragmentShader`] specifies the fragment shader stage.
/// - [`PipelineStageEarlyFragmentTests`] specifies the stage of the pipeline where early fragment tests (depth and stencil tests before fragment shading) are performed. This stage also includes [subpass load operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-load-store-ops) for framebuffer attachments with a depth/stencil format.
/// - [`PipelineStageLateFragmentTests`] specifies the stage of the pipeline where late fragment tests (depth and stencil tests after fragment shading) are performed. This stage also includes [subpass store operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-load-store-ops) for framebuffer attachments with a depth/stencil format.
/// - [`PipelineStageColorAttachmentOutput`] specifies the stage of the pipeline after blending where the final color values are output from the pipeline. This stage also includes [subpass load and store operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-load-store-ops) and multisample resolve operations for framebuffer attachments with a color or depth/stencil format.
/// - [`PipelineStageComputeShader`] specifies the execution of a compute shader.
/// - [`PipelineStageTransfer`] specifies the following commands:  - All [copy commands](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#copies), including [`CmdCopyQueryPoolResults`]  - [`CmdBlitImage2`] and [`CmdBlitImage`]  - [`CmdResolveImage2`] and [`CmdResolveImage`]  - All [clear commands](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#clears), with the exception of [`CmdClearAttachments`]
/// - [`PipelineStageHost`] specifies a pseudo-stage indicating execution on the host of
///   reads/writes of device memory. This stage is not invoked by any commands recorded in a command
///   buffer.
/// - [`AccelerationStructureBuildKhr`] specifies     the execution of
///   [`CmdBuildAccelerationStructureNV`],     [`CmdCopyAccelerationStructureNV`],
///   [`CmdWriteAccelerationStructuresPropertiesNV`] ,     [`CmdBuildAccelerationStructuresKHR`],
///   [`CmdBuildAccelerationStructuresIndirectKHR`],     [`CmdCopyAccelerationStructureKHR`],
///   [`CmdCopyAccelerationStructureToMemoryKHR`],     [`CmdCopyMemoryToAccelerationStructureKHR`],
///   and     [`CmdWriteAccelerationStructuresPropertiesKHR`].
/// - [`RayTracingShaderKhr`] specifies the     execution of the ray tracing shader stages, via
///   [`CmdTraceRaysNV`] , [`CmdTraceRaysKHR`], or [`CmdTraceRaysIndirectKHR`]
/// - [`PipelineStageAllGraphics`] specifies the execution of all graphics pipeline stages, and is
///   equivalent to the logical OR of:  - [`PipelineStageDrawIndirect`]  - [`TaskShaderNv`]  -
///   [`MeshShaderNv`]  - [`PipelineStageVertexInput`]  - [`PipelineStageVertexShader`]  -
///   [`PipelineStageTessellationControlShader`]  - [`PipelineStageTessellationEvaluationShader`]  -
///   [`PipelineStageGeometryShader`]  - [`PipelineStageFragmentShader`]  -
///   [`PipelineStageEarlyFragmentTests`]  - [`PipelineStageLateFragmentTests`]  -
///   [`PipelineStageColorAttachmentOutput`]  - [`ConditionalRenderingExt`]  -
///   [`TransformFeedbackExt`]  - [`FragmentShadingRateAttachmentKhr`]  -
///   [`FragmentDensityProcessExt`]
/// - [`PipelineStageAllCommands`] specifies all operations performed by all commands supported on
///   the queue it is used with.
/// - [`ConditionalRenderingExt`] specifies the stage of the pipeline where the predicate of
///   conditional rendering is consumed.
/// - [`TransformFeedbackExt`] specifies the stage of the pipeline where vertex attribute output
///   values are written to the transform feedback buffers.
/// - [`CommandPreprocessNv`] specifies the stage of the pipeline where device-side preprocessing
///   for generated commands via [`CmdPreprocessGeneratedCommandsNV`] is handled.
/// - [`FragmentShadingRateAttachmentKhr`]     specifies the stage of the pipeline where the     [fragment shading rate     attachment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#primsrast-fragment-shading-rate-attachment) or     [shading rate image](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#primsrast-shading-rate-image)     is read to determine the fragment shading rate for portions of a     rasterized primitive.
/// - [`FragmentDensityProcessExt`] specifies the stage of the pipeline where the fragment density map is read to [generate the fragment areas](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fragmentdensitymapops).
/// - [`PipelineStageTopOfPipe`] is equivalent to [`PipelineStageAllCommands`] with [`AccessFlags`]
///   set to `0` when specified in the second synchronization scope, but specifies no stage of
///   execution when specified in the first scope.
/// - [`PipelineStageBottomOfPipe`] is equivalent to [`PipelineStageAllCommands`] with
///   [`AccessFlags`] set to `0` when specified in the first synchronization scope, but specifies no
///   stage of execution when specified in the second scope.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`CheckpointDataNV`]
/// - [`PipelineStageFlags`]
/// - [`CmdWriteBufferMarkerAMD`]
/// - [`CmdWriteTimestamp`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(transparent)]
pub struct PipelineStageFlags(u32);
impl const Default for PipelineStageFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl From<PipelineStageFlagBits> for PipelineStageFlags {
    fn from(from: PipelineStageFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(from as u32) }
    }
}
impl PipelineStageFlags {
    ///[`PipelineStageTopOfPipe`] is equivalent to
    ///[`PipelineStageAllCommands`] with [`AccessFlags`] set to
    ///`0` when specified in the second synchronization scope, but specifies no
    ///stage of execution when specified in the first scope.
    const PipelineStageTopOfPipe: Self = Self(1);
    ///[`PipelineStageDrawIndirect`] specifies the stage of the
    ///pipeline where `VkDrawIndirect*` / `VkDispatchIndirect*` /
    ///`VkTraceRaysIndirect*` data structures are consumed.
    ///This stage also includes reading commands written by
    ///[`CmdExecuteGeneratedCommandsNV`].
    const PipelineStageDrawIndirect: Self = Self(2);
    ///[`PipelineStageVertexInput`] specifies the stage of the
    ///pipeline where vertex and index buffers are consumed.
    const PipelineStageVertexInput: Self = Self(4);
    ///[`PipelineStageVertexShader`] specifies the vertex shader
    ///stage.
    const PipelineStageVertexShader: Self = Self(8);
    ///[`PipelineStageTessellationControlShader`] specifies the
    ///tessellation control shader stage.
    const PipelineStageTessellationControlShader: Self = Self(16);
    ///[`PipelineStageTessellationEvaluationShader`] specifies the
    ///tessellation evaluation shader stage.
    const PipelineStageTessellationEvaluationShader: Self = Self(32);
    ///[`PipelineStageGeometryShader`] specifies the geometry
    ///shader stage.
    const PipelineStageGeometryShader: Self = Self(64);
    ///[`PipelineStageFragmentShader`] specifies the fragment
    ///shader stage.
    const PipelineStageFragmentShader: Self = Self(128);
    ///[`PipelineStageEarlyFragmentTests`] specifies the stage of
    ///the pipeline where early fragment tests (depth and stencil tests before
    ///fragment shading) are performed.
    ///This stage also includes [subpass load
    ///operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-load-store-ops) for framebuffer attachments with a depth/stencil format.
    const PipelineStageEarlyFragmentTests: Self = Self(256);
    ///[`PipelineStageLateFragmentTests`] specifies the stage of
    ///the pipeline where late fragment tests (depth and stencil tests after
    ///fragment shading) are performed.
    ///This stage also includes [subpass store
    ///operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-load-store-ops) for framebuffer attachments with a depth/stencil format.
    const PipelineStageLateFragmentTests: Self = Self(512);
    ///[`PipelineStageColorAttachmentOutput`] specifies the stage
    ///of the pipeline after blending where the final color values are output
    ///from the pipeline.
    ///This stage also includes [subpass load and
    ///store operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-load-store-ops) and multisample resolve operations for framebuffer
    ///attachments with a color
    ///or depth/stencil
    ///format.
    const PipelineStageColorAttachmentOutput: Self = Self(1024);
    ///[`PipelineStageComputeShader`] specifies the execution of a
    ///compute shader.
    const PipelineStageComputeShader: Self = Self(2048);
    ///[`PipelineStageTransfer`] specifies the following commands:
    /// - All [copy commands](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#copies),
    ///   including [`CmdCopyQueryPoolResults`]
    /// - [`CmdBlitImage2`] and [`CmdBlitImage`]
    /// - [`CmdResolveImage2`] and [`CmdResolveImage`]
    /// - All [clear commands](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#clears),
    ///   with the exception of [`CmdClearAttachments`]
    const PipelineStageTransfer: Self = Self(4096);
    ///[`PipelineStageBottomOfPipe`] is equivalent to
    ///[`PipelineStageAllCommands`] with [`AccessFlags`] set to
    ///`0` when specified in the first synchronization scope, but specifies no
    ///stage of execution when specified in the second scope.
    const PipelineStageBottomOfPipe: Self = Self(8192);
    ///[`PipelineStageHost`] specifies a pseudo-stage indicating
    ///execution on the host of reads/writes of device memory.
    ///This stage is not invoked by any commands recorded in a command buffer.
    const PipelineStageHost: Self = Self(16384);
    ///[`PipelineStageAllGraphics`] specifies the execution of all
    ///graphics pipeline stages, and is equivalent to the logical OR of:
    /// - [`PipelineStageDrawIndirect`]
    /// - [`TaskShaderNv`]
    /// - [`MeshShaderNv`]
    /// - [`PipelineStageVertexInput`]
    /// - [`PipelineStageVertexShader`]
    /// - [`PipelineStageTessellationControlShader`]
    /// - [`PipelineStageTessellationEvaluationShader`]
    /// - [`PipelineStageGeometryShader`]
    /// - [`PipelineStageFragmentShader`]
    /// - [`PipelineStageEarlyFragmentTests`]
    /// - [`PipelineStageLateFragmentTests`]
    /// - [`PipelineStageColorAttachmentOutput`]
    /// - [`ConditionalRenderingExt`]
    /// - [`TransformFeedbackExt`]
    /// - [`FragmentShadingRateAttachmentKhr`]
    /// - [`FragmentDensityProcessExt`]
    const PipelineStageAllGraphics: Self = Self(32768);
    ///[`PipelineStageAllCommands`] specifies all operations
    ///performed by all commands supported on the queue it is used with.
    const PipelineStageAllCommands: Self = Self(65536);
    ///[`None`] specifies no stages of execution.
    ///
    ///Provided by [`crate::vulkan1_3`]
    const None: Self = Self(0);
    ///[`TransformFeedbackExt`]
    ///
    ///Provided by [`crate::extensions::ext_transform_feedback`]
    const TransformFeedbackExt: Self = Self(16777216);
    ///[`ConditionalRenderingExt`]
    ///
    ///Provided by [`crate::extensions::ext_conditional_rendering`]
    const ConditionalRenderingExt: Self = Self(262144);
    ///[`AccelerationStructureBuildKhr`] specifies
    ///    the execution of
    ///    [`CmdBuildAccelerationStructureNV`],
    ///    [`CmdCopyAccelerationStructureNV`],
    ///    [`CmdWriteAccelerationStructuresPropertiesNV`]
    ///,
    ///    [`CmdBuildAccelerationStructuresKHR`],
    ///    [`CmdBuildAccelerationStructuresIndirectKHR`],
    ///    [`CmdCopyAccelerationStructureKHR`],
    ///    [`CmdCopyAccelerationStructureToMemoryKHR`],
    ///    [`CmdCopyMemoryToAccelerationStructureKHR`], and
    ///    [`CmdWriteAccelerationStructuresPropertiesKHR`].
    ///
    ///Provided by [`crate::extensions::khr_acceleration_structure`]
    const AccelerationStructureBuildKhr: Self = Self(33554432);
    ///[`RayTracingShaderKhr`] specifies the
    ///    execution of the ray tracing shader stages, via
    ///[`CmdTraceRaysNV`]
    ///,
    ///[`CmdTraceRaysKHR`], or [`CmdTraceRaysIndirectKHR`]
    ///
    ///Provided by [`crate::extensions::khr_ray_tracing_pipeline`]
    const RayTracingShaderKhr: Self = Self(2097152);
    ///[`TaskShaderNv`] specifies the task shader
    ///stage.
    ///
    ///Provided by [`crate::extensions::nv_mesh_shader`]
    const TaskShaderNv: Self = Self(524288);
    ///[`MeshShaderNv`] specifies the mesh shader
    ///stage.
    ///
    ///Provided by [`crate::extensions::nv_mesh_shader`]
    const MeshShaderNv: Self = Self(1048576);
    ///[`FragmentDensityProcessExt`]
    ///
    ///Provided by [`crate::extensions::ext_fragment_density_map`]
    const FragmentDensityProcessExt: Self = Self(8388608);
    ///[`FragmentShadingRateAttachmentKhr`]
    ///
    ///Provided by [`crate::extensions::khr_fragment_shading_rate`]
    const FragmentShadingRateAttachmentKhr: Self = Self(4194304);
    ///[`CommandPreprocessNv`] specifies the stage of
    ///the pipeline where device-side preprocessing for generated commands via
    ///[`CmdPreprocessGeneratedCommandsNV`] is handled.
    ///
    ///Provided by [`crate::extensions::nv_device_generated_commands`]
    const CommandPreprocessNv: Self = Self(131072);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    pub const fn all() -> Self {
        Self::empty()
            | Self::PipelineStageTopOfPipe
            | Self::PipelineStageDrawIndirect
            | Self::PipelineStageVertexInput
            | Self::PipelineStageVertexShader
            | Self::PipelineStageTessellationControlShader
            | Self::PipelineStageTessellationEvaluationShader
            | Self::PipelineStageGeometryShader
            | Self::PipelineStageFragmentShader
            | Self::PipelineStageEarlyFragmentTests
            | Self::PipelineStageLateFragmentTests
            | Self::PipelineStageColorAttachmentOutput
            | Self::PipelineStageComputeShader
            | Self::PipelineStageTransfer
            | Self::PipelineStageBottomOfPipe
            | Self::PipelineStageHost
            | Self::PipelineStageAllGraphics
            | Self::PipelineStageAllCommands
            | Self::None
            | Self::TransformFeedbackExt
            | Self::ConditionalRenderingExt
            | Self::AccelerationStructureBuildKhr
            | Self::RayTracingShaderKhr
            | Self::TaskShaderNv
            | Self::MeshShaderNv
            | Self::FragmentDensityProcessExt
            | Self::FragmentShadingRateAttachmentKhr
            | Self::CommandPreprocessNv
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl const std::ops::BitOr for PipelineStageFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl std::ops::BitOrAssign for PipelineStageFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl const std::ops::BitXor for PipelineStageFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl std::ops::BitXorAssign for PipelineStageFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl const std::ops::BitAnd for PipelineStageFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl std::ops::BitAndAssign for PipelineStageFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl const std::ops::Sub for PipelineStageFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl std::ops::SubAssign for PipelineStageFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl const std::ops::Not for PipelineStageFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl std::iter::Extend<PipelineStageFlags> for PipelineStageFlags {
    fn extend<T: std::iter::IntoIterator<Item = PipelineStageFlags>>(&mut self, iterator: T) {
        for i in iterator {
            self.insert(i);
        }
    }
}
impl std::iter::Extend<PipelineStageFlagBits> for PipelineStageFlags {
    fn extend<T: std::iter::IntoIterator<Item = PipelineStageFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            self.insert(PipelineStageFlags::from(i));
        }
    }
}
impl std::iter::FromIterator<PipelineStageFlags> for PipelineStageFlags {
    fn from_iter<T: std::iter::IntoIterator<Item = PipelineStageFlags>>(iterator: T) -> PipelineStageFlags {
        let mut out = PipelineStageFlags::empty();
        out.extend(iterator);
        out
    }
}
impl std::iter::FromIterator<PipelineStageFlagBits> for PipelineStageFlags {
    fn from_iter<T: std::iter::IntoIterator<Item = PipelineStageFlagBits>>(iterator: T) -> PipelineStageFlags {
        let mut out = PipelineStageFlags::empty();
        out.extend(iterator);
        out
    }
}
impl std::fmt::Debug for PipelineStageFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(PipelineStageFlags);
        impl std::fmt::Debug for Flags {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == PipelineStageFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(PipelineStageFlags::PipelineStageTopOfPipe) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(PipelineStageTopOfPipe))?;
                    }
                    if self.0.contains(PipelineStageFlags::PipelineStageDrawIndirect) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(PipelineStageDrawIndirect))?;
                    }
                    if self.0.contains(PipelineStageFlags::PipelineStageVertexInput) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(PipelineStageVertexInput))?;
                    }
                    if self.0.contains(PipelineStageFlags::PipelineStageVertexShader) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(PipelineStageVertexShader))?;
                    }
                    if self
                        .0
                        .contains(PipelineStageFlags::PipelineStageTessellationControlShader)
                    {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(PipelineStageTessellationControlShader))?;
                    }
                    if self
                        .0
                        .contains(PipelineStageFlags::PipelineStageTessellationEvaluationShader)
                    {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(PipelineStageTessellationEvaluationShader))?;
                    }
                    if self.0.contains(PipelineStageFlags::PipelineStageGeometryShader) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(PipelineStageGeometryShader))?;
                    }
                    if self.0.contains(PipelineStageFlags::PipelineStageFragmentShader) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(PipelineStageFragmentShader))?;
                    }
                    if self.0.contains(PipelineStageFlags::PipelineStageEarlyFragmentTests) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(PipelineStageEarlyFragmentTests))?;
                    }
                    if self.0.contains(PipelineStageFlags::PipelineStageLateFragmentTests) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(PipelineStageLateFragmentTests))?;
                    }
                    if self.0.contains(PipelineStageFlags::PipelineStageColorAttachmentOutput) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(PipelineStageColorAttachmentOutput))?;
                    }
                    if self.0.contains(PipelineStageFlags::PipelineStageComputeShader) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(PipelineStageComputeShader))?;
                    }
                    if self.0.contains(PipelineStageFlags::PipelineStageTransfer) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(PipelineStageTransfer))?;
                    }
                    if self.0.contains(PipelineStageFlags::PipelineStageBottomOfPipe) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(PipelineStageBottomOfPipe))?;
                    }
                    if self.0.contains(PipelineStageFlags::PipelineStageHost) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(PipelineStageHost))?;
                    }
                    if self.0.contains(PipelineStageFlags::PipelineStageAllGraphics) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(PipelineStageAllGraphics))?;
                    }
                    if self.0.contains(PipelineStageFlags::PipelineStageAllCommands) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(PipelineStageAllCommands))?;
                    }
                    if self.0.contains(PipelineStageFlags::None) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(None))?;
                    }
                    if self.0.contains(PipelineStageFlags::TransformFeedbackExt) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(TransformFeedbackExt))?;
                    }
                    if self.0.contains(PipelineStageFlags::ConditionalRenderingExt) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(ConditionalRenderingExt))?;
                    }
                    if self.0.contains(PipelineStageFlags::AccelerationStructureBuildKhr) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(AccelerationStructureBuildKhr))?;
                    }
                    if self.0.contains(PipelineStageFlags::RayTracingShaderKhr) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(RayTracingShaderKhr))?;
                    }
                    if self.0.contains(PipelineStageFlags::TaskShaderNv) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(TaskShaderNv))?;
                    }
                    if self.0.contains(PipelineStageFlags::MeshShaderNv) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(MeshShaderNv))?;
                    }
                    if self.0.contains(PipelineStageFlags::FragmentDensityProcessExt) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(FragmentDensityProcessExt))?;
                    }
                    if self.0.contains(PipelineStageFlags::FragmentShadingRateAttachmentKhr) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(FragmentShadingRateAttachmentKhr))?;
                    }
                    if self.0.contains(PipelineStageFlags::CommandPreprocessNv) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(CommandPreprocessNv))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(PipelineStageFlags))
            .field(&Flags(*self))
            .finish()
    }
}
///[VkSampleCountFlagBits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSampleCountFlagBits.html) - Bitmask specifying sample counts supported for an image used for storage operations
///# C Specifications
///Bits which  **may**  be set in the sample count limits returned by
///[`PhysicalDeviceLimits`], as well as in other queries and structures
///representing image sample counts, are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkSampleCountFlagBits {
///    VK_SAMPLE_COUNT_1_BIT = 0x00000001,
///    VK_SAMPLE_COUNT_2_BIT = 0x00000002,
///    VK_SAMPLE_COUNT_4_BIT = 0x00000004,
///    VK_SAMPLE_COUNT_8_BIT = 0x00000008,
///    VK_SAMPLE_COUNT_16_BIT = 0x00000010,
///    VK_SAMPLE_COUNT_32_BIT = 0x00000020,
///    VK_SAMPLE_COUNT_64_BIT = 0x00000040,
///} VkSampleCountFlagBits;
///```
///# Description
/// - [`SampleCount1`] specifies an image with one sample per pixel.
/// - [`SampleCount2`] specifies an image with 2 samples per pixel.
/// - [`SampleCount4`] specifies an image with 4 samples per pixel.
/// - [`SampleCount8`] specifies an image with 8 samples per pixel.
/// - [`SampleCount16`] specifies an image with 16 samples per pixel.
/// - [`SampleCount32`] specifies an image with 32 samples per pixel.
/// - [`SampleCount64`] specifies an image with 64 samples per pixel.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`AttachmentDescription`]
/// - [`AttachmentDescription2`]
/// - [`AttachmentSampleCountInfoAMD`]
/// - [`CommandBufferInheritanceRenderingInfo`]
/// - [`FramebufferMixedSamplesCombinationNV`]
/// - [`ImageCreateInfo`]
/// - [`PhysicalDeviceFragmentShadingRateEnumsPropertiesNV`]
/// - [`PhysicalDeviceFragmentShadingRatePropertiesKHR`]
/// - [`PhysicalDeviceSparseImageFormatInfo2`]
/// - [`PipelineMultisampleStateCreateInfo`]
/// - [`SampleCountFlags`]
/// - [`SampleLocationsInfoEXT`]
/// - [`GetPhysicalDeviceMultisamplePropertiesEXT`]
/// - [`GetPhysicalDeviceSparseImageFormatProperties`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(transparent)]
pub struct SampleCountFlags(u32);
impl const Default for SampleCountFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl From<SampleCountFlagBits> for SampleCountFlags {
    fn from(from: SampleCountFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(from as u32) }
    }
}
impl SampleCountFlags {
    ///[`SampleCount1`] specifies an image with one sample per
    ///pixel.
    const SampleCount1: Self = Self(1);
    ///[`SampleCount2`] specifies an image with 2 samples per pixel.
    const SampleCount2: Self = Self(2);
    ///[`SampleCount4`] specifies an image with 4 samples per pixel.
    const SampleCount4: Self = Self(4);
    ///[`SampleCount8`] specifies an image with 8 samples per pixel.
    const SampleCount8: Self = Self(8);
    ///[`SampleCount16`] specifies an image with 16 samples per
    ///pixel.
    const SampleCount16: Self = Self(16);
    ///[`SampleCount32`] specifies an image with 32 samples per
    ///pixel.
    const SampleCount32: Self = Self(32);
    ///[`SampleCount64`] specifies an image with 64 samples per
    ///pixel.
    const SampleCount64: Self = Self(64);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    pub const fn all() -> Self {
        Self::empty()
            | Self::SampleCount1
            | Self::SampleCount2
            | Self::SampleCount4
            | Self::SampleCount8
            | Self::SampleCount16
            | Self::SampleCount32
            | Self::SampleCount64
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl const std::ops::BitOr for SampleCountFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl std::ops::BitOrAssign for SampleCountFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl const std::ops::BitXor for SampleCountFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl std::ops::BitXorAssign for SampleCountFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl const std::ops::BitAnd for SampleCountFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl std::ops::BitAndAssign for SampleCountFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl const std::ops::Sub for SampleCountFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl std::ops::SubAssign for SampleCountFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl const std::ops::Not for SampleCountFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl std::iter::Extend<SampleCountFlags> for SampleCountFlags {
    fn extend<T: std::iter::IntoIterator<Item = SampleCountFlags>>(&mut self, iterator: T) {
        for i in iterator {
            self.insert(i);
        }
    }
}
impl std::iter::Extend<SampleCountFlagBits> for SampleCountFlags {
    fn extend<T: std::iter::IntoIterator<Item = SampleCountFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            self.insert(SampleCountFlags::from(i));
        }
    }
}
impl std::iter::FromIterator<SampleCountFlags> for SampleCountFlags {
    fn from_iter<T: std::iter::IntoIterator<Item = SampleCountFlags>>(iterator: T) -> SampleCountFlags {
        let mut out = SampleCountFlags::empty();
        out.extend(iterator);
        out
    }
}
impl std::iter::FromIterator<SampleCountFlagBits> for SampleCountFlags {
    fn from_iter<T: std::iter::IntoIterator<Item = SampleCountFlagBits>>(iterator: T) -> SampleCountFlags {
        let mut out = SampleCountFlags::empty();
        out.extend(iterator);
        out
    }
}
impl std::fmt::Debug for SampleCountFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(SampleCountFlags);
        impl std::fmt::Debug for Flags {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == SampleCountFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(SampleCountFlags::SampleCount1) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(SampleCount1))?;
                    }
                    if self.0.contains(SampleCountFlags::SampleCount2) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(SampleCount2))?;
                    }
                    if self.0.contains(SampleCountFlags::SampleCount4) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(SampleCount4))?;
                    }
                    if self.0.contains(SampleCountFlags::SampleCount8) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(SampleCount8))?;
                    }
                    if self.0.contains(SampleCountFlags::SampleCount16) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(SampleCount16))?;
                    }
                    if self.0.contains(SampleCountFlags::SampleCount32) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(SampleCount32))?;
                    }
                    if self.0.contains(SampleCountFlags::SampleCount64) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(SampleCount64))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(SampleCountFlags))
            .field(&Flags(*self))
            .finish()
    }
}
///[VkAttachmentDescriptionFlagBits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAttachmentDescriptionFlagBits.html) - Bitmask specifying additional properties of an attachment
///# C Specifications
///Bits which  **can**  be set in [`AttachmentDescription::flags`],
///describing additional properties of the attachment, are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkAttachmentDescriptionFlagBits {
///    VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT = 0x00000001,
///} VkAttachmentDescriptionFlagBits;
///```
///# Description
/// - [`AttachmentDescriptionMayAlias`] specifies that the attachment aliases the same device memory
///   as other attachments.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`AttachmentDescriptionFlags`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(transparent)]
pub struct AttachmentDescriptionFlags(u32);
impl const Default for AttachmentDescriptionFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl From<AttachmentDescriptionFlagBits> for AttachmentDescriptionFlags {
    fn from(from: AttachmentDescriptionFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(from as u32) }
    }
}
impl AttachmentDescriptionFlags {
    ///[`AttachmentDescriptionMayAlias`] specifies that the
    ///attachment aliases the same device memory as other attachments.
    const AttachmentDescriptionMayAlias: Self = Self(1);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    pub const fn all() -> Self {
        Self::empty() | Self::AttachmentDescriptionMayAlias
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl const std::ops::BitOr for AttachmentDescriptionFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl std::ops::BitOrAssign for AttachmentDescriptionFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl const std::ops::BitXor for AttachmentDescriptionFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl std::ops::BitXorAssign for AttachmentDescriptionFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl const std::ops::BitAnd for AttachmentDescriptionFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl std::ops::BitAndAssign for AttachmentDescriptionFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl const std::ops::Sub for AttachmentDescriptionFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl std::ops::SubAssign for AttachmentDescriptionFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl const std::ops::Not for AttachmentDescriptionFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl std::iter::Extend<AttachmentDescriptionFlags> for AttachmentDescriptionFlags {
    fn extend<T: std::iter::IntoIterator<Item = AttachmentDescriptionFlags>>(&mut self, iterator: T) {
        for i in iterator {
            self.insert(i);
        }
    }
}
impl std::iter::Extend<AttachmentDescriptionFlagBits> for AttachmentDescriptionFlags {
    fn extend<T: std::iter::IntoIterator<Item = AttachmentDescriptionFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            self.insert(AttachmentDescriptionFlags::from(i));
        }
    }
}
impl std::iter::FromIterator<AttachmentDescriptionFlags> for AttachmentDescriptionFlags {
    fn from_iter<T: std::iter::IntoIterator<Item = AttachmentDescriptionFlags>>(
        iterator: T,
    ) -> AttachmentDescriptionFlags {
        let mut out = AttachmentDescriptionFlags::empty();
        out.extend(iterator);
        out
    }
}
impl std::iter::FromIterator<AttachmentDescriptionFlagBits> for AttachmentDescriptionFlags {
    fn from_iter<T: std::iter::IntoIterator<Item = AttachmentDescriptionFlagBits>>(
        iterator: T,
    ) -> AttachmentDescriptionFlags {
        let mut out = AttachmentDescriptionFlags::empty();
        out.extend(iterator);
        out
    }
}
impl std::fmt::Debug for AttachmentDescriptionFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(AttachmentDescriptionFlags);
        impl std::fmt::Debug for Flags {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == AttachmentDescriptionFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self
                        .0
                        .contains(AttachmentDescriptionFlags::AttachmentDescriptionMayAlias)
                    {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(AttachmentDescriptionMayAlias))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(AttachmentDescriptionFlags))
            .field(&Flags(*self))
            .finish()
    }
}
///[VkStencilFaceFlagBits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkStencilFaceFlagBits.html) - Bitmask specifying sets of stencil state for which to update the compare mask
///# C Specifications
///[`StencilFaceFlagBits`] values are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkStencilFaceFlagBits {
///    VK_STENCIL_FACE_FRONT_BIT = 0x00000001,
///    VK_STENCIL_FACE_BACK_BIT = 0x00000002,
///    VK_STENCIL_FACE_FRONT_AND_BACK = 0x00000003,
///    VK_STENCIL_FRONT_AND_BACK = VK_STENCIL_FACE_FRONT_AND_BACK,
///} VkStencilFaceFlagBits;
///```
///# Description
/// - [`StencilFaceFront`] specifies that only the front set of stencil state is updated.
/// - [`StencilFaceBack`] specifies that only the back set of stencil state is updated.
/// - [`StencilFaceFrontAndBack`] is the combination of [`StencilFaceFront`] and
///   [`StencilFaceBack`], and specifies that both sets of stencil state are updated.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`StencilFaceFlags`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(transparent)]
pub struct StencilFaceFlags(u32);
impl const Default for StencilFaceFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl From<StencilFaceFlagBits> for StencilFaceFlags {
    fn from(from: StencilFaceFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(from as u32) }
    }
}
impl StencilFaceFlags {
    ///[`StencilFaceFront`] specifies that only the front set of
    ///stencil state is updated.
    const StencilFaceFront: Self = Self(1);
    ///[`StencilFaceBack`] specifies that only the back set of
    ///stencil state is updated.
    const StencilFaceBack: Self = Self(2);
    ///[`StencilFaceFrontAndBack`] is the combination of
    ///[`StencilFaceFront`] and [`StencilFaceBack`], and
    ///specifies that both sets of stencil state are updated.
    const StencilFaceFrontAndBack: Self = Self(3);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    pub const fn all() -> Self {
        Self::empty() | Self::StencilFaceFront | Self::StencilFaceBack | Self::StencilFaceFrontAndBack
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl const std::ops::BitOr for StencilFaceFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl std::ops::BitOrAssign for StencilFaceFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl const std::ops::BitXor for StencilFaceFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl std::ops::BitXorAssign for StencilFaceFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl const std::ops::BitAnd for StencilFaceFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl std::ops::BitAndAssign for StencilFaceFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl const std::ops::Sub for StencilFaceFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl std::ops::SubAssign for StencilFaceFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl const std::ops::Not for StencilFaceFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl std::iter::Extend<StencilFaceFlags> for StencilFaceFlags {
    fn extend<T: std::iter::IntoIterator<Item = StencilFaceFlags>>(&mut self, iterator: T) {
        for i in iterator {
            self.insert(i);
        }
    }
}
impl std::iter::Extend<StencilFaceFlagBits> for StencilFaceFlags {
    fn extend<T: std::iter::IntoIterator<Item = StencilFaceFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            self.insert(StencilFaceFlags::from(i));
        }
    }
}
impl std::iter::FromIterator<StencilFaceFlags> for StencilFaceFlags {
    fn from_iter<T: std::iter::IntoIterator<Item = StencilFaceFlags>>(iterator: T) -> StencilFaceFlags {
        let mut out = StencilFaceFlags::empty();
        out.extend(iterator);
        out
    }
}
impl std::iter::FromIterator<StencilFaceFlagBits> for StencilFaceFlags {
    fn from_iter<T: std::iter::IntoIterator<Item = StencilFaceFlagBits>>(iterator: T) -> StencilFaceFlags {
        let mut out = StencilFaceFlags::empty();
        out.extend(iterator);
        out
    }
}
impl std::fmt::Debug for StencilFaceFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(StencilFaceFlags);
        impl std::fmt::Debug for Flags {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == StencilFaceFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(StencilFaceFlags::StencilFaceFront) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(StencilFaceFront))?;
                    }
                    if self.0.contains(StencilFaceFlags::StencilFaceBack) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(StencilFaceBack))?;
                    }
                    if self.0.contains(StencilFaceFlags::StencilFaceFrontAndBack) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(StencilFaceFrontAndBack))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(StencilFaceFlags))
            .field(&Flags(*self))
            .finish()
    }
}
///[VkCullModeFlagBits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCullModeFlagBits.html) - Bitmask controlling triangle culling
///# C Specifications
///Once the orientation of triangles is determined, they are culled according
///to the [`PipelineRasterizationStateCreateInfo::cull_mode`] property
///of the currently active pipeline.
///Possible values are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkCullModeFlagBits {
///    VK_CULL_MODE_NONE = 0,
///    VK_CULL_MODE_FRONT_BIT = 0x00000001,
///    VK_CULL_MODE_BACK_BIT = 0x00000002,
///    VK_CULL_MODE_FRONT_AND_BACK = 0x00000003,
///} VkCullModeFlagBits;
///```
///# Description
/// - [`CullModeNone`] specifies that no triangles are discarded
/// - [`CullModeFront`] specifies that front-facing triangles are discarded
/// - [`CullModeBack`] specifies that back-facing triangles are discarded
/// - [`CullModeFrontAndBack`] specifies that all triangles are discarded.
///Following culling, fragments are produced for any triangles which have not
///been discarded.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`CullModeFlags`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(transparent)]
pub struct CullModeFlags(u32);
impl const Default for CullModeFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl From<CullModeFlagBits> for CullModeFlags {
    fn from(from: CullModeFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(from as u32) }
    }
}
impl CullModeFlags {
    ///[`CullModeNone`] specifies that no triangles are discarded
    const CullModeNone: Self = Self(0);
    ///[`CullModeFront`] specifies that front-facing triangles are
    ///discarded
    const CullModeFront: Self = Self(1);
    ///[`CullModeBack`] specifies that back-facing triangles are
    ///discarded
    const CullModeBack: Self = Self(2);
    ///[`CullModeFrontAndBack`] specifies that all triangles are
    ///discarded.
    const CullModeFrontAndBack: Self = Self(3);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    pub const fn all() -> Self {
        Self::empty() | Self::CullModeNone | Self::CullModeFront | Self::CullModeBack | Self::CullModeFrontAndBack
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl const std::ops::BitOr for CullModeFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl std::ops::BitOrAssign for CullModeFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl const std::ops::BitXor for CullModeFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl std::ops::BitXorAssign for CullModeFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl const std::ops::BitAnd for CullModeFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl std::ops::BitAndAssign for CullModeFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl const std::ops::Sub for CullModeFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl std::ops::SubAssign for CullModeFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl const std::ops::Not for CullModeFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl std::iter::Extend<CullModeFlags> for CullModeFlags {
    fn extend<T: std::iter::IntoIterator<Item = CullModeFlags>>(&mut self, iterator: T) {
        for i in iterator {
            self.insert(i);
        }
    }
}
impl std::iter::Extend<CullModeFlagBits> for CullModeFlags {
    fn extend<T: std::iter::IntoIterator<Item = CullModeFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            self.insert(CullModeFlags::from(i));
        }
    }
}
impl std::iter::FromIterator<CullModeFlags> for CullModeFlags {
    fn from_iter<T: std::iter::IntoIterator<Item = CullModeFlags>>(iterator: T) -> CullModeFlags {
        let mut out = CullModeFlags::empty();
        out.extend(iterator);
        out
    }
}
impl std::iter::FromIterator<CullModeFlagBits> for CullModeFlags {
    fn from_iter<T: std::iter::IntoIterator<Item = CullModeFlagBits>>(iterator: T) -> CullModeFlags {
        let mut out = CullModeFlags::empty();
        out.extend(iterator);
        out
    }
}
impl std::fmt::Debug for CullModeFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(CullModeFlags);
        impl std::fmt::Debug for Flags {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == CullModeFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(CullModeFlags::CullModeNone) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(CullModeNone))?;
                    }
                    if self.0.contains(CullModeFlags::CullModeFront) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(CullModeFront))?;
                    }
                    if self.0.contains(CullModeFlags::CullModeBack) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(CullModeBack))?;
                    }
                    if self.0.contains(CullModeFlags::CullModeFrontAndBack) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(CullModeFrontAndBack))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(CullModeFlags)).field(&Flags(*self)).finish()
    }
}
///[VkDescriptorPoolCreateFlagBits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorPoolCreateFlagBits.html) - Bitmask specifying certain supported operations on a descriptor pool
///# C Specifications
///Bits which  **can**  be set in [`DescriptorPoolCreateInfo::flags`],
///enabling operations on a descriptor pool, are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkDescriptorPoolCreateFlagBits {
///    VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT = 0x00000001,
///  // Provided by VK_VERSION_1_2
///    VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT = 0x00000002,
///  // Provided by VK_VALVE_mutable_descriptor_type
///    VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_VALVE = 0x00000004,
///  // Provided by VK_EXT_descriptor_indexing
///    VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT =
/// VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT,
///} VkDescriptorPoolCreateFlagBits;
///```
///# Description
/// - [`DescriptorPoolCreateFreeDescriptorSet`] specifies that descriptor sets  **can**  return
///   their individual allocations to the pool, i.e. all of [`AllocateDescriptorSets`],
///   [`FreeDescriptorSets`], and [`ResetDescriptorPool`] are allowed. Otherwise, descriptor sets
///   allocated from the pool  **must**  not be individually freed back to the pool, i.e. only
///   [`AllocateDescriptorSets`] and [`ResetDescriptorPool`] are allowed.
/// - [`UpdateAfterBind`] specifies that descriptor sets allocated from this pool  **can**  include
///   bindings with the `VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT` bit set. It is valid to
///   allocate descriptor sets that have bindings that do not set the
///   `VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT` bit from a pool that has [`UpdateAfterBind`]
///   set.
/// - [`HostOnlyValve`] specifies that this descriptor pool and the descriptor sets allocated from
///   it reside entirely in host memory and cannot be bound. Descriptor sets allocated from this
///   pool are partially exempt from the external synchronization requirement in
///   [`UpdateDescriptorSetWithTemplateKHR`] and [`UpdateDescriptorSets`]. Descriptor sets and their
///   descriptors can be updated concurrently in different threads, though the same descriptor
///   **must**  not be updated concurrently by two threads.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`DescriptorPoolCreateFlags`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(transparent)]
pub struct DescriptorPoolCreateFlags(u32);
impl const Default for DescriptorPoolCreateFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl From<DescriptorPoolCreateFlagBits> for DescriptorPoolCreateFlags {
    fn from(from: DescriptorPoolCreateFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(from as u32) }
    }
}
impl DescriptorPoolCreateFlags {
    ///[`DescriptorPoolCreateFreeDescriptorSet`] specifies that
    ///descriptor sets  **can**  return their individual allocations to the pool,
    ///i.e. all of [`AllocateDescriptorSets`], [`FreeDescriptorSets`],
    ///and [`ResetDescriptorPool`] are allowed.
    ///Otherwise, descriptor sets allocated from the pool  **must**  not be
    ///individually freed back to the pool, i.e. only
    ///[`AllocateDescriptorSets`] and [`ResetDescriptorPool`] are
    ///allowed.
    const DescriptorPoolCreateFreeDescriptorSet: Self = Self(1);
    ///[`UpdateAfterBind`] specifies that
    ///descriptor sets allocated from this pool  **can**  include bindings with the
    ///`VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT` bit set.
    ///It is valid to allocate descriptor sets that have bindings that do not
    ///set the `VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT` bit from a
    ///pool that has [`UpdateAfterBind`] set.
    ///
    ///Provided by [`crate::vulkan1_2`]
    const UpdateAfterBind: Self = Self(2);
    ///[`HostOnlyValve`] specifies that this
    ///descriptor pool and the descriptor sets allocated from it reside
    ///entirely in host memory and cannot be bound.
    ///Descriptor sets allocated from this pool are partially exempt from the
    ///external synchronization requirement in
    ///[`UpdateDescriptorSetWithTemplateKHR`] and
    ///[`UpdateDescriptorSets`].
    ///Descriptor sets and their descriptors can be updated concurrently in
    ///different threads, though the same descriptor  **must**  not be updated
    ///concurrently by two threads.
    ///
    ///Provided by [`crate::extensions::valve_mutable_descriptor_type`]
    const HostOnlyValve: Self = Self(4);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    pub const fn all() -> Self {
        Self::empty() | Self::DescriptorPoolCreateFreeDescriptorSet | Self::UpdateAfterBind | Self::HostOnlyValve
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl const std::ops::BitOr for DescriptorPoolCreateFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl std::ops::BitOrAssign for DescriptorPoolCreateFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl const std::ops::BitXor for DescriptorPoolCreateFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl std::ops::BitXorAssign for DescriptorPoolCreateFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl const std::ops::BitAnd for DescriptorPoolCreateFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl std::ops::BitAndAssign for DescriptorPoolCreateFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl const std::ops::Sub for DescriptorPoolCreateFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl std::ops::SubAssign for DescriptorPoolCreateFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl const std::ops::Not for DescriptorPoolCreateFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl std::iter::Extend<DescriptorPoolCreateFlags> for DescriptorPoolCreateFlags {
    fn extend<T: std::iter::IntoIterator<Item = DescriptorPoolCreateFlags>>(&mut self, iterator: T) {
        for i in iterator {
            self.insert(i);
        }
    }
}
impl std::iter::Extend<DescriptorPoolCreateFlagBits> for DescriptorPoolCreateFlags {
    fn extend<T: std::iter::IntoIterator<Item = DescriptorPoolCreateFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            self.insert(DescriptorPoolCreateFlags::from(i));
        }
    }
}
impl std::iter::FromIterator<DescriptorPoolCreateFlags> for DescriptorPoolCreateFlags {
    fn from_iter<T: std::iter::IntoIterator<Item = DescriptorPoolCreateFlags>>(
        iterator: T,
    ) -> DescriptorPoolCreateFlags {
        let mut out = DescriptorPoolCreateFlags::empty();
        out.extend(iterator);
        out
    }
}
impl std::iter::FromIterator<DescriptorPoolCreateFlagBits> for DescriptorPoolCreateFlags {
    fn from_iter<T: std::iter::IntoIterator<Item = DescriptorPoolCreateFlagBits>>(
        iterator: T,
    ) -> DescriptorPoolCreateFlags {
        let mut out = DescriptorPoolCreateFlags::empty();
        out.extend(iterator);
        out
    }
}
impl std::fmt::Debug for DescriptorPoolCreateFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(DescriptorPoolCreateFlags);
        impl std::fmt::Debug for Flags {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == DescriptorPoolCreateFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self
                        .0
                        .contains(DescriptorPoolCreateFlags::DescriptorPoolCreateFreeDescriptorSet)
                    {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(DescriptorPoolCreateFreeDescriptorSet))?;
                    }
                    if self.0.contains(DescriptorPoolCreateFlags::UpdateAfterBind) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(UpdateAfterBind))?;
                    }
                    if self.0.contains(DescriptorPoolCreateFlags::HostOnlyValve) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(HostOnlyValve))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(DescriptorPoolCreateFlags))
            .field(&Flags(*self))
            .finish()
    }
}
///[VkDescriptorPoolResetFlags](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorPoolResetFlags.html) - Reserved for future use
///# C Specifications
///```c
///// Provided by VK_VERSION_1_0
///typedef VkFlags VkDescriptorPoolResetFlags;
///```
///# Related
/// - [`crate::vulkan1_0`]
/// - [`ResetDescriptorPool`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(transparent)]
pub struct DescriptorPoolResetFlags(u32);
impl const Default for DescriptorPoolResetFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl std::fmt::Debug for DescriptorPoolResetFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        f.debug_tuple(stringify!(DescriptorPoolResetFlags))
            .field(&self.0)
            .finish()
    }
}
///[VkDependencyFlagBits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDependencyFlagBits.html) - Bitmask specifying how execution and memory dependencies are formed
///# C Specifications
///Bits which  **can**  be set in [`CmdPipelineBarrier`]`::dependencyFlags`,
///specifying how execution and memory dependencies are formed, are:
///```c
///// Provided by VK_VERSION_1_0
///typedef enum VkDependencyFlagBits {
///    VK_DEPENDENCY_BY_REGION_BIT = 0x00000001,
///  // Provided by VK_VERSION_1_1
///    VK_DEPENDENCY_DEVICE_GROUP_BIT = 0x00000004,
///  // Provided by VK_VERSION_1_1
///    VK_DEPENDENCY_VIEW_LOCAL_BIT = 0x00000002,
///  // Provided by VK_KHR_multiview
///    VK_DEPENDENCY_VIEW_LOCAL_BIT_KHR = VK_DEPENDENCY_VIEW_LOCAL_BIT,
///  // Provided by VK_KHR_device_group
///    VK_DEPENDENCY_DEVICE_GROUP_BIT_KHR = VK_DEPENDENCY_DEVICE_GROUP_BIT,
///} VkDependencyFlagBits;
///```
///# Description
/// - [`DependencyByRegion`] specifies that dependencies will be [framebuffer-local](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-framebuffer-regions).
/// - [`ViewLocal`] specifies that a [subpass has more than one view](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-pipeline-barriers-subpass-self-dependencies).
/// - [`DeviceGroup`] specifies that dependencies are [non-device-local](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-device-local-dependencies).
///# Related
/// - [`crate::vulkan1_0`]
/// - [`DependencyFlags`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(transparent)]
pub struct DependencyFlags(u32);
impl const Default for DependencyFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl From<DependencyFlagBits> for DependencyFlags {
    fn from(from: DependencyFlagBits) -> Self {
        unsafe { Self::from_bits_unchecked(from as u32) }
    }
}
impl DependencyFlags {
    ///[`DependencyByRegion`] specifies that dependencies will be
    ///[framebuffer-local](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-framebuffer-regions).
    const DependencyByRegion: Self = Self(1);
    ///[`DeviceGroup`] specifies that dependencies are
    ///[non-device-local](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-device-local-dependencies).
    ///
    ///Provided by [`crate::vulkan1_1`]
    const DeviceGroup: Self = Self(4);
    ///[`ViewLocal`] specifies that a
    ///[subpass
    ///has more than one view](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-pipeline-barriers-subpass-self-dependencies).
    ///
    ///Provided by [`crate::vulkan1_1`]
    const ViewLocal: Self = Self(2);
    ///Default empty flags
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Returns a value with all of the flags enabled
    #[inline]
    pub const fn all() -> Self {
        Self::empty() | Self::DependencyByRegion | Self::DeviceGroup | Self::ViewLocal
    }
    ///Returns the raw bits
    #[inline]
    pub const fn bits(&self) -> u32 {
        self.0
    }
    ///Convert raw bits into a bit flags checking that only valid
    ///bits are contained.
    #[inline]
    pub const fn from_bits(bits: u32) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self(bits))
        } else {
            None
        }
    }
    ///Convert raw bits into a bit flags truncating all invalid
    ///bits that may be contained.
    #[inline]
    pub const fn from_bits_truncate(bits: u32) -> Self {
        Self(Self::all().0 & bits)
    }
    ///Convert raw bits into a bit preserving all bits
    ///
    ///# Safety
    ///The caller of this function must ensure that all of the bits are valid.
    #[inline]
    pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
        Self(bits)
    }
    ///Returns `true` if no flags are currently set
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }
    ///Returns `true` if all flags are currently set
    #[inline]
    pub const fn is_all(&self) -> bool {
        self.bits() == Self::all().bits()
    }
    ///Returns `true` if there are flags in common to `self` and `other`
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !Self(self.bits() & other.bits()).is_empty()
    }
    ///Returns `true` if all of the flags in `other` are contained `self`
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits() & other.bits()) == other.bits()
    }
    ///Inserts a set of flags in place
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.0 |= other.bits()
    }
    ///Removes a set of flags in place
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.0 &= !other.bits();
    }
    ///Toggles a set of flags in place
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.0 ^= other.bits();
    }
    ///Inserts or removes the specified flags depending on the value of `is_insert`
    #[inline]
    pub fn set(&mut self, other: Self, is_insert: bool) {
        if is_insert {
            self.insert(other);
        } else {
            self.remove(other);
        }
    }
    ///Returns the intersection between `self` and `other`
    #[inline]
    pub const fn intersection(self, other: Self) -> Self {
        Self(self.bits() & other.bits())
    }
    ///Returns the union between `self` and `other`
    #[inline]
    pub const fn union(self, other: Self) -> Self {
        Self(self.bits() | other.bits())
    }
    ///Returns the difference between `self` and `other`
    #[inline]
    pub const fn difference(self, other: Self) -> Self {
        Self(self.bits() & !other.bits())
    }
    ///Returns the [symmetric difference][sym-diff] between `self` and `other`
    ///
    ///[sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
    #[inline]
    pub const fn symmetric_difference(self, other: Self) -> Self {
        Self(self.bits() ^ other.bits())
    }
    ///Returns the complement of `self`.
    #[inline]
    pub const fn complement(self) -> Self {
        Self::from_bits_truncate(!self.bits())
    }
}
impl const std::ops::BitOr for DependencyFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        self.union(other)
    }
}
impl std::ops::BitOrAssign for DependencyFlags {
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        *self = *self | other;
    }
}
impl const std::ops::BitXor for DependencyFlags {
    type Output = Self;
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        self.symmetric_difference(other)
    }
}
impl std::ops::BitXorAssign for DependencyFlags {
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        *self = *self ^ other;
    }
}
impl const std::ops::BitAnd for DependencyFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        self.intersection(other)
    }
}
impl std::ops::BitAndAssign for DependencyFlags {
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        *self = *self & other;
    }
}
impl const std::ops::Sub for DependencyFlags {
    type Output = Self;
    #[inline]
    fn sub(self, other: Self) -> Self {
        self.difference(other)
    }
}
impl std::ops::SubAssign for DependencyFlags {
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}
impl const std::ops::Not for DependencyFlags {
    type Output = Self;
    #[inline]
    fn not(self) -> Self {
        self.complement()
    }
}
impl std::iter::Extend<DependencyFlags> for DependencyFlags {
    fn extend<T: std::iter::IntoIterator<Item = DependencyFlags>>(&mut self, iterator: T) {
        for i in iterator {
            self.insert(i);
        }
    }
}
impl std::iter::Extend<DependencyFlagBits> for DependencyFlags {
    fn extend<T: std::iter::IntoIterator<Item = DependencyFlagBits>>(&mut self, iterator: T) {
        for i in iterator {
            self.insert(DependencyFlags::from(i));
        }
    }
}
impl std::iter::FromIterator<DependencyFlags> for DependencyFlags {
    fn from_iter<T: std::iter::IntoIterator<Item = DependencyFlags>>(iterator: T) -> DependencyFlags {
        let mut out = DependencyFlags::empty();
        out.extend(iterator);
        out
    }
}
impl std::iter::FromIterator<DependencyFlagBits> for DependencyFlags {
    fn from_iter<T: std::iter::IntoIterator<Item = DependencyFlagBits>>(iterator: T) -> DependencyFlags {
        let mut out = DependencyFlags::empty();
        out.extend(iterator);
        out
    }
}
impl std::fmt::Debug for DependencyFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        struct Flags(DependencyFlags);
        impl std::fmt::Debug for Flags {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                if self.0 == DependencyFlags::empty() {
                    f.write_str("empty")?;
                } else {
                    let mut first = true;
                    if self.0.contains(DependencyFlags::DependencyByRegion) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(DependencyByRegion))?;
                    }
                    if self.0.contains(DependencyFlags::DeviceGroup) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(DeviceGroup))?;
                    }
                    if self.0.contains(DependencyFlags::ViewLocal) {
                        if !first {
                            first = false;
                            f.write_str(" | ")?;
                        }
                        f.write_str(stringify!(ViewLocal))?;
                    }
                }
                Ok(())
            }
        }
        f.debug_tuple(stringify!(DependencyFlags)).field(&Flags(*self)).finish()
    }
}
///[VkBaseOutStructure](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBaseOutStructure.html) - Base structure for a read-only pointer chain
///# C Specifications
///The [`BaseOutStructure`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkBaseOutStructure {
///    VkStructureType               sType;
///    struct VkBaseOutStructure*    pNext;
///} VkBaseOutStructure;
///```
///# Members
/// - [`s_type`] is the structure type of the structure being iterated through.
/// - [`next`] is `NULL` or a pointer to the next structure in a structure chain.
///# Description
///[`BaseOutStructure`] can be used to facilitate iterating through a
///structure pointer chain that returns data back to the application.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`BaseOutStructure`]
/// - [`StructureType`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Eq, Ord, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[repr(C)]
pub struct BaseOutStructure<'lt> {
    _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] is the structure type of the structure being iterated
    ///through.
    s_type: StructureType,
    ///[`next`] is `NULL` or a pointer to the next structure in a structure
    ///chain.
    next: *mut BaseOutStructure<'lt>,
}
impl<'lt> Default for BaseOutStructure<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: Default::default(),
            next: std::ptr::null_mut(),
        }
    }
}
impl<'lt> BaseOutStructure<'lt> {
    ///Gets the raw value of [`Self::next`]
    pub fn next_raw(&self) -> &*mut BaseOutStructure<'lt> {
        &self.next
    }
    ///Sets the raw value of [`Self::next`]
    pub fn set_next_raw(&mut self, value: *mut BaseOutStructure<'lt>) -> &mut Self {
        self.next = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn next(&self) -> &BaseOutStructure<'lt> {
        &*self.next
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn next_mut(&mut self) -> &mut BaseOutStructure<'lt> {
        &mut *self.next
    }
    ///Sets the raw value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the raw value of [`Self::next`]
    pub fn set_next(&mut self, value: &'lt mut crate::vulkan1_0::BaseOutStructure<'lt>) -> &mut Self {
        self.next = value as *mut _;
        self
    }
}
///[VkBaseInStructure](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBaseInStructure.html) - Base structure for a read-only pointer chain
///# C Specifications
///The [`BaseInStructure`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkBaseInStructure {
///    VkStructureType                    sType;
///    const struct VkBaseInStructure*    pNext;
///} VkBaseInStructure;
///```
///# Members
/// - [`s_type`] is the structure type of the structure being iterated through.
/// - [`next`] is `NULL` or a pointer to the next structure in a structure chain.
///# Description
///[`BaseInStructure`] can be used to facilitate iterating through a
///read-only structure pointer chain.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`BaseInStructure`]
/// - [`StructureType`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[repr(C)]
pub struct BaseInStructure<'lt> {
    _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] is the structure type of the structure being iterated
    ///through.
    s_type: StructureType,
    ///[`next`] is `NULL` or a pointer to the next structure in a structure
    ///chain.
    next: *const BaseInStructure<'lt>,
}
impl<'lt> Default for BaseInStructure<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: Default::default(),
            next: std::ptr::null(),
        }
    }
}
impl<'lt> BaseInStructure<'lt> {
    ///Gets the raw value of [`Self::next`]
    pub fn next_raw(&self) -> *const BaseInStructure<'lt> {
        self.next
    }
    ///Sets the raw value of [`Self::next`]
    pub fn set_next_raw(&mut self, value: *const BaseInStructure<'lt>) -> &mut Self {
        self.next = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn next(&self) -> &BaseInStructure<'lt> {
        &*self.next
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Sets the raw value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the raw value of [`Self::next`]
    pub fn set_next(&mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> &mut Self {
        self.next = value as *const _;
        self
    }
}
///[VkOffset2D](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkOffset2D.html) - Structure specifying a two-dimensional offset
///# C Specifications
///A two-dimensional offset is defined by the structure:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkOffset2D {
///    int32_t    x;
///    int32_t    y;
///} VkOffset2D;
///```
///# Members
/// - [`x`] is the x offset.
/// - [`y`] is the y offset.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`DisplayPlaneCapabilitiesKHR`]
/// - [`Rect2D`]
/// - [`RectLayerKHR`]
/// - [`SubpassFragmentDensityMapOffsetEndInfoQCOM`]
/// - [`VideoDecodeH264CapabilitiesEXT`]
/// - [`VideoDecodeInfoKHR`]
/// - [`VideoPictureResourceKHR`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct Offset2D {
    ///[`x`] is the x offset.
    x: i32,
    ///[`y`] is the y offset.
    y: i32,
}
impl Default for Offset2D {
    fn default() -> Self {
        Self { x: 0, y: 0 }
    }
}
impl Offset2D {
    ///Gets the value of [`Self::x`]
    pub fn x(&self) -> i32 {
        self.x
    }
    ///Gets the value of [`Self::y`]
    pub fn y(&self) -> i32 {
        self.y
    }
    ///Gets a mutable reference to the value of [`Self::x`]
    pub fn x_mut(&mut self) -> &mut i32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::y`]
    pub fn y_mut(&mut self) -> &mut i32 {
        &mut getter
    }
    ///Sets the raw value of [`Self::x`]
    pub fn set_x(&mut self, value: i32) -> &mut Self {
        self.x = value;
        self
    }
    ///Sets the raw value of [`Self::y`]
    pub fn set_y(&mut self, value: i32) -> &mut Self {
        self.y = value;
        self
    }
}
///[VkOffset3D](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkOffset3D.html) - Structure specifying a three-dimensional offset
///# C Specifications
///A three-dimensional offset is defined by the structure:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkOffset3D {
///    int32_t    x;
///    int32_t    y;
///    int32_t    z;
///} VkOffset3D;
///```
///# Members
/// - [`x`] is the x offset.
/// - [`y`] is the y offset.
/// - [`z`] is the z offset.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`BufferImageCopy`]
/// - [`BufferImageCopy2`]
/// - [`ImageBlit`]
/// - [`ImageBlit2`]
/// - [`ImageCopy`]
/// - [`ImageCopy2`]
/// - [`ImageResolve`]
/// - [`ImageResolve2`]
/// - [`SparseImageMemoryBind`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct Offset3D {
    ///[`x`] is the x offset.
    x: i32,
    ///[`y`] is the y offset.
    y: i32,
    ///[`z`] is the z offset.
    z: i32,
}
impl Default for Offset3D {
    fn default() -> Self {
        Self { x: 0, y: 0, z: 0 }
    }
}
impl Offset3D {
    ///Gets the value of [`Self::x`]
    pub fn x(&self) -> i32 {
        self.x
    }
    ///Gets the value of [`Self::y`]
    pub fn y(&self) -> i32 {
        self.y
    }
    ///Gets the value of [`Self::z`]
    pub fn z(&self) -> i32 {
        self.z
    }
    ///Gets a mutable reference to the value of [`Self::x`]
    pub fn x_mut(&mut self) -> &mut i32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::y`]
    pub fn y_mut(&mut self) -> &mut i32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::z`]
    pub fn z_mut(&mut self) -> &mut i32 {
        &mut getter
    }
    ///Sets the raw value of [`Self::x`]
    pub fn set_x(&mut self, value: i32) -> &mut Self {
        self.x = value;
        self
    }
    ///Sets the raw value of [`Self::y`]
    pub fn set_y(&mut self, value: i32) -> &mut Self {
        self.y = value;
        self
    }
    ///Sets the raw value of [`Self::z`]
    pub fn set_z(&mut self, value: i32) -> &mut Self {
        self.z = value;
        self
    }
}
///[VkExtent2D](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExtent2D.html) - Structure specifying a two-dimensional extent
///# C Specifications
///A two-dimensional extent is defined by the structure:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkExtent2D {
///    uint32_t    width;
///    uint32_t    height;
///} VkExtent2D;
///```
///# Members
/// - [`width`] is the width of the extent.
/// - [`height`] is the height of the extent.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`DisplayModeParametersKHR`]
/// - [`DisplayPlaneCapabilitiesKHR`]
/// - [`DisplayPropertiesKHR`]
/// - [`DisplaySurfaceCreateInfoKHR`]
/// - [`FragmentShadingRateAttachmentInfoKHR`]
/// - [`MultisamplePropertiesEXT`]
/// - [`PhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM`]
/// - [`PhysicalDeviceFragmentDensityMapPropertiesEXT`]
/// - [`PhysicalDeviceFragmentShadingRateKHR`]
/// - [`PhysicalDeviceFragmentShadingRatePropertiesKHR`]
/// - [`PhysicalDeviceSampleLocationsPropertiesEXT`]
/// - [`PhysicalDeviceShadingRateImagePropertiesNV`]
/// - [`PipelineFragmentShadingRateStateCreateInfoKHR`]
/// - [`Rect2D`]
/// - [`RectLayerKHR`]
/// - [`RenderingFragmentShadingRateAttachmentInfoKHR`]
/// - [`SampleLocationsInfoEXT`]
/// - [`SurfaceCapabilities2EXT`]
/// - [`SurfaceCapabilitiesKHR`]
/// - [`SwapchainCreateInfoKHR`]
/// - [`VideoCapabilitiesKHR`]
/// - [`VideoDecodeInfoKHR`]
/// - [`VideoEncodeCapabilitiesKHR`]
/// - [`VideoEncodeH264SessionCreateInfoEXT`]
/// - [`VideoEncodeInfoKHR`]
/// - [`VideoPictureResourceKHR`]
/// - [`VideoSessionCreateInfoKHR`]
/// - [`CmdSetFragmentShadingRateKHR`]
/// - [`GetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI`]
/// - [`GetRenderAreaGranularity`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct Extent2D {
    ///[`width`] is the width of the extent.
    width: u32,
    ///[`height`] is the height of the extent.
    height: u32,
}
impl Default for Extent2D {
    fn default() -> Self {
        Self { width: 0, height: 0 }
    }
}
impl Extent2D {
    ///Gets the value of [`Self::width`]
    pub fn width(&self) -> u32 {
        self.width
    }
    ///Gets the value of [`Self::height`]
    pub fn height(&self) -> u32 {
        self.height
    }
    ///Gets a mutable reference to the value of [`Self::width`]
    pub fn width_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::height`]
    pub fn height_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Sets the raw value of [`Self::width`]
    pub fn set_width(&mut self, value: u32) -> &mut Self {
        self.width = value;
        self
    }
    ///Sets the raw value of [`Self::height`]
    pub fn set_height(&mut self, value: u32) -> &mut Self {
        self.height = value;
        self
    }
}
///[VkExtent3D](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExtent3D.html) - Structure specifying a three-dimensional extent
///# C Specifications
///A three-dimensional extent is defined by the structure:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkExtent3D {
///    uint32_t    width;
///    uint32_t    height;
///    uint32_t    depth;
///} VkExtent3D;
///```
///# Members
/// - [`width`] is the width of the extent.
/// - [`height`] is the height of the extent.
/// - [`depth`] is the depth of the extent.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`BufferImageCopy`]
/// - [`BufferImageCopy2`]
/// - [`ImageCopy`]
/// - [`ImageCopy2`]
/// - [`ImageCreateInfo`]
/// - [`ImageFormatProperties`]
/// - [`ImageResolve`]
/// - [`ImageResolve2`]
/// - [`QueueFamilyProperties`]
/// - [`SparseImageFormatProperties`]
/// - [`SparseImageMemoryBind`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct Extent3D {
    ///[`width`] is the width of the extent.
    width: u32,
    ///[`height`] is the height of the extent.
    height: u32,
    ///[`depth`] is the depth of the extent.
    depth: u32,
}
impl Default for Extent3D {
    fn default() -> Self {
        Self {
            width: 0,
            height: 0,
            depth: 0,
        }
    }
}
impl Extent3D {
    ///Gets the value of [`Self::width`]
    pub fn width(&self) -> u32 {
        self.width
    }
    ///Gets the value of [`Self::height`]
    pub fn height(&self) -> u32 {
        self.height
    }
    ///Gets the value of [`Self::depth`]
    pub fn depth(&self) -> u32 {
        self.depth
    }
    ///Gets a mutable reference to the value of [`Self::width`]
    pub fn width_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::height`]
    pub fn height_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::depth`]
    pub fn depth_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Sets the raw value of [`Self::width`]
    pub fn set_width(&mut self, value: u32) -> &mut Self {
        self.width = value;
        self
    }
    ///Sets the raw value of [`Self::height`]
    pub fn set_height(&mut self, value: u32) -> &mut Self {
        self.height = value;
        self
    }
    ///Sets the raw value of [`Self::depth`]
    pub fn set_depth(&mut self, value: u32) -> &mut Self {
        self.depth = value;
        self
    }
}
///[VkViewport](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkViewport.html) - Structure specifying a viewport
///# C Specifications
///The [`Viewport`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkViewport {
///    float    x;
///    float    y;
///    float    width;
///    float    height;
///    float    minDepth;
///    float    maxDepth;
///} VkViewport;
///```
///# Members
/// - [`x`] and [`y`] are the viewport’s upper left corner (x,y).
/// - [`width`] and [`height`] are the viewport’s width and height, respectively.
/// - [`min_depth`] and [`max_depth`] are the depth range for the viewport.
///# Description
///The framebuffer depth coordinate `z`<sub>f</sub> **may**  be represented using
///either a fixed-point or floating-point representation.
///However, a floating-point representation  **must**  be used if the depth/stencil
///attachment has a floating-point depth component.
///If an m-bit fixed-point representation is used, we assume that it
///represents each value <span class="katex"><span class="katex-html" aria-hidden="true"><span
/// class="base"><span class="strut"
/// style="height:1.283439em;vertical-align:-0.403331em;"></span><span class="mord"><span
/// class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span
/// class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span
/// style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing
/// reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord
/// mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span
/// style="height:0.5935428571428571em;" class="vlist"><span
/// style="top:-2.786em;margin-right:0.07142857142857144em;"><span style="height:2.5em;"
/// class="pstrut"></span><span class="sizing reset-size3 size1 mtight"><span class="mord
/// mathdefault mtight">m</span></span></span></span></span></span></span></span><span class="mbin
/// mtight">−</span><span class="mord mtight">1</span></span></span></span><span
/// style="top:-3.23em;"><span style="height:3em;" class="pstrut"></span><span
/// style="border-bottom-width:0.04em;" class="frac-line"></span></span><span
/// style="top:-3.394em;"><span style="height:3em;" class="pstrut"></span><span class="sizing
/// reset-size6 size3 mtight"><span class="mord mtight"><span style="margin-right:0.03148em;"
/// class="mord mathdefault mtight">k</span></span></span></span></span><span
/// class="vlist-s">​</span></span><span class="vlist-r"><span style="height:0.403331em;"
/// class="vlist"><span></span></span></span></span></span><span class="mclose
/// nulldelimiter"></span></span></span></span></span>, where k ∈ {
///0, 1, …​, 2<sup>m</sup>-1 }, as k (e.g. 1.0 is represented in binary as a
///string of all ones).The viewport parameters shown in the above equations are found from these
///values as
/// * o<sub>x</sub> = [`x`] +  [`width`] / 2
/// * o<sub>y</sub> = [`y`] +  [`height`] / 2
/// * o<sub>z</sub> = [`min_depth`]
/// * p<sub>x</sub> = [`width`]
/// * p<sub>y</sub> = [`height`]
/// * p<sub>z</sub> = [`max_depth`] - [`min_depth`].
///If a render pass transform is enabled, the values (p<sub>x</sub>,p<sub>y</sub>) and
///(o<sub>x</sub>, o<sub>y</sub>) defining the viewport are transformed as described in
///[render pass transform](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#vertexpostproc-renderpass-transform) before
///participating in the viewport transform.The application  **can**  specify a negative term for
/// [`height`], which has the
///effect of negating the y coordinate in clip space before performing the
///transform.
///When using a negative [`height`], the application  **should**  also adjust the
///[`y`] value to point to the lower left corner of the viewport instead of
///the upper left corner.
///Using the negative [`height`] allows the application to avoid having to
///negate the y component of the `Position` output from the last
///[pre-rasterization shader
///stage](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-pre-rasterization).The width and height of the [implementation-dependent maximum viewport dimensions](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#limits-maxViewportDimensions) **must**  be greater than
///or equal to the width and height of the largest image which  **can**  be created
///and attached to a framebuffer.The floating-point viewport bounds are represented with an
///[implementation-dependent precision](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#limits-viewportSubPixelBits).
///## Valid Usage
/// - [`width`] **must**  be greater than `0.0`
/// - [`width`] **must**  be less than or equal to
///   [`PhysicalDeviceLimits::max_viewport_dimensions`][0]
/// - The absolute value of [`height`] **must**  be less than or equal to
///   [`PhysicalDeviceLimits::max_viewport_dimensions`][1]
/// - [`x`] **must**  be greater than or equal to `viewportBoundsRange`[0]
/// - ([`x`] +  [`width`]) **must**  be less than or equal to `viewportBoundsRange`[1]
/// - [`y`] **must**  be greater than or equal to `viewportBoundsRange`[0]
/// - [`y`] **must**  be less than or equal to `viewportBoundsRange`[1]
/// - ([`y`] +  [`height`]) **must**  be greater than or equal to `viewportBoundsRange`[0]
/// - ([`y`] +  [`height`]) **must**  be less than or equal to `viewportBoundsRange`[1]
/// - Unless `[`VK_EXT_depth_range_unrestricted`]` extension is enabled [`min_depth`] **must**  be
///   between `0.0` and `1.0`, inclusive
/// - Unless `[`VK_EXT_depth_range_unrestricted`]` extension is enabled [`max_depth`] **must**  be
///   between `0.0` and `1.0`, inclusive
///# Related
/// - [`crate::vulkan1_0`]
/// - [`CommandBufferInheritanceViewportScissorInfoNV`]
/// - [`PipelineViewportStateCreateInfo`]
/// - [`CmdSetViewport`]
/// - [`CmdSetViewportWithCount`]
/// - [`CmdSetViewportWithCountEXT`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, PartialEq, PartialOrd)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct Viewport {
    ///[`x`] and [`y`] are the viewport’s upper left corner (x,y).
    x: f32,
    ///No documentation found
    y: f32,
    ///[`width`] and [`height`] are the viewport’s width and height,
    ///respectively.
    width: f32,
    ///No documentation found
    height: f32,
    ///[`min_depth`] and [`max_depth`] are the depth range for the viewport.
    min_depth: f32,
    ///No documentation found
    max_depth: f32,
}
impl Default for Viewport {
    fn default() -> Self {
        Self {
            x: 0.0,
            y: 0.0,
            width: 0.0,
            height: 0.0,
            min_depth: 0.0,
            max_depth: 0.0,
        }
    }
}
impl Viewport {
    ///Gets the value of [`Self::x`]
    pub fn x(&self) -> f32 {
        self.x
    }
    ///Gets the value of [`Self::y`]
    pub fn y(&self) -> f32 {
        self.y
    }
    ///Gets the value of [`Self::width`]
    pub fn width(&self) -> f32 {
        self.width
    }
    ///Gets the value of [`Self::height`]
    pub fn height(&self) -> f32 {
        self.height
    }
    ///Gets the value of [`Self::min_depth`]
    pub fn min_depth(&self) -> f32 {
        self.min_depth
    }
    ///Gets the value of [`Self::max_depth`]
    pub fn max_depth(&self) -> f32 {
        self.max_depth
    }
    ///Gets a mutable reference to the value of [`Self::x`]
    pub fn x_mut(&mut self) -> &mut f32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::y`]
    pub fn y_mut(&mut self) -> &mut f32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::width`]
    pub fn width_mut(&mut self) -> &mut f32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::height`]
    pub fn height_mut(&mut self) -> &mut f32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::min_depth`]
    pub fn min_depth_mut(&mut self) -> &mut f32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::max_depth`]
    pub fn max_depth_mut(&mut self) -> &mut f32 {
        &mut getter
    }
    ///Sets the raw value of [`Self::x`]
    pub fn set_x(&mut self, value: f32) -> &mut Self {
        self.x = value;
        self
    }
    ///Sets the raw value of [`Self::y`]
    pub fn set_y(&mut self, value: f32) -> &mut Self {
        self.y = value;
        self
    }
    ///Sets the raw value of [`Self::width`]
    pub fn set_width(&mut self, value: f32) -> &mut Self {
        self.width = value;
        self
    }
    ///Sets the raw value of [`Self::height`]
    pub fn set_height(&mut self, value: f32) -> &mut Self {
        self.height = value;
        self
    }
    ///Sets the raw value of [`Self::min_depth`]
    pub fn set_min_depth(&mut self, value: f32) -> &mut Self {
        self.min_depth = value;
        self
    }
    ///Sets the raw value of [`Self::max_depth`]
    pub fn set_max_depth(&mut self, value: f32) -> &mut Self {
        self.max_depth = value;
        self
    }
}
///[VkRect2D](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRect2D.html) - Structure specifying a two-dimensional subregion
///# C Specifications
///Rectangles are used to describe a specified rectangular region of pixels
///within an image or framebuffer.
///Rectangles include both an offset and an extent of the same dimensionality,
///as described above.
///Two-dimensional rectangles are defined by the structure
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkRect2D {
///    VkOffset2D    offset;
///    VkExtent2D    extent;
///} VkRect2D;
///```
///# Members
/// - [`offset`] is a [`Offset2D`] specifying the rectangle offset.
/// - [`extent`] is a [`Extent2D`] specifying the rectangle extent.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`BindImageMemoryDeviceGroupInfo`]
/// - [`ClearRect`]
/// - [`CommandBufferInheritanceRenderPassTransformInfoQCOM`]
/// - [`DeviceGroupRenderPassBeginInfo`]
/// - [`DisplayPresentInfoKHR`]
/// - [`Extent2D`]
/// - [`Offset2D`]
/// - [`PipelineDiscardRectangleStateCreateInfoEXT`]
/// - [`PipelineViewportExclusiveScissorStateCreateInfoNV`]
/// - [`PipelineViewportStateCreateInfo`]
/// - [`RenderPassBeginInfo`]
/// - [`RenderingInfo`]
/// - [`CmdSetDiscardRectangleEXT`]
/// - [`CmdSetExclusiveScissorNV`]
/// - [`CmdSetScissor`]
/// - [`CmdSetScissorWithCount`]
/// - [`CmdSetScissorWithCountEXT`]
/// - [`GetPhysicalDevicePresentRectanglesKHR`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct Rect2D {
    ///[`offset`] is a [`Offset2D`] specifying the rectangle offset.
    offset: Offset2D,
    ///[`extent`] is a [`Extent2D`] specifying the rectangle extent.
    extent: Extent2D,
}
impl Default for Rect2D {
    fn default() -> Self {
        Self {
            offset: Default::default(),
            extent: Default::default(),
        }
    }
}
impl Rect2D {
    ///Gets the value of [`Self::offset`]
    pub fn offset(&self) -> Offset2D {
        self.offset
    }
    ///Gets the value of [`Self::extent`]
    pub fn extent(&self) -> Extent2D {
        self.extent
    }
    ///Gets a mutable reference to the value of [`Self::offset`]
    pub fn offset_mut(&mut self) -> &mut Offset2D {
        &mut self.offset
    }
    ///Gets a mutable reference to the value of [`Self::extent`]
    pub fn extent_mut(&mut self) -> &mut Extent2D {
        &mut self.extent
    }
    ///Sets the raw value of [`Self::offset`]
    pub fn set_offset(&mut self, value: crate::vulkan1_0::Offset2D) -> &mut Self {
        self.offset = value;
        self
    }
    ///Sets the raw value of [`Self::extent`]
    pub fn set_extent(&mut self, value: crate::vulkan1_0::Extent2D) -> &mut Self {
        self.extent = value;
        self
    }
}
///[VkClearRect](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkClearRect.html) - Structure specifying a clear rectangle
///# C Specifications
///The [`ClearRect`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkClearRect {
///    VkRect2D    rect;
///    uint32_t    baseArrayLayer;
///    uint32_t    layerCount;
///} VkClearRect;
///```
///# Members
/// - [`rect`] is the two-dimensional region to be cleared.
/// - [`base_array_layer`] is the first layer to be cleared.
/// - [`layer_count`] is the number of layers to clear.
///# Description
///The layers [[`base_array_layer`], [`base_array_layer`] +
///[`layer_count`]) counting from the base layer of the attachment image view
///are cleared.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`Rect2D`]
/// - [`CmdClearAttachments`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct ClearRect {
    ///[`rect`] is the two-dimensional region to be cleared.
    rect: Rect2D,
    ///[`base_array_layer`] is the first layer to be cleared.
    base_array_layer: u32,
    ///[`layer_count`] is the number of layers to clear.
    layer_count: u32,
}
impl Default for ClearRect {
    fn default() -> Self {
        Self {
            rect: Default::default(),
            base_array_layer: 0,
            layer_count: 0,
        }
    }
}
impl ClearRect {
    ///Gets the value of [`Self::rect`]
    pub fn rect(&self) -> Rect2D {
        self.rect
    }
    ///Gets the value of [`Self::base_array_layer`]
    pub fn base_array_layer(&self) -> u32 {
        self.base_array_layer
    }
    ///Gets the value of [`Self::layer_count`]
    pub fn layer_count(&self) -> u32 {
        self.layer_count
    }
    ///Gets a mutable reference to the value of [`Self::rect`]
    pub fn rect_mut(&mut self) -> &mut Rect2D {
        &mut self.rect
    }
    ///Gets a mutable reference to the value of [`Self::base_array_layer`]
    pub fn base_array_layer_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::layer_count`]
    pub fn layer_count_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Sets the raw value of [`Self::rect`]
    pub fn set_rect(&mut self, value: crate::vulkan1_0::Rect2D) -> &mut Self {
        self.rect = value;
        self
    }
    ///Sets the raw value of [`Self::base_array_layer`]
    pub fn set_base_array_layer(&mut self, value: u32) -> &mut Self {
        self.base_array_layer = value;
        self
    }
    ///Sets the raw value of [`Self::layer_count`]
    pub fn set_layer_count(&mut self, value: u32) -> &mut Self {
        self.layer_count = value;
        self
    }
}
///[VkComponentMapping](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkComponentMapping.html) - Structure specifying a color component mapping
///# C Specifications
///The [`ComponentMapping`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkComponentMapping {
///    VkComponentSwizzle    r;
///    VkComponentSwizzle    g;
///    VkComponentSwizzle    b;
///    VkComponentSwizzle    a;
///} VkComponentMapping;
///```
///# Members
/// - [`r`] is a [`ComponentSwizzle`] specifying the component value placed in the R component of
///   the output vector.
/// - [`g`] is a [`ComponentSwizzle`] specifying the component value placed in the G component of
///   the output vector.
/// - [`b`] is a [`ComponentSwizzle`] specifying the component value placed in the B component of
///   the output vector.
/// - [`a`] is a [`ComponentSwizzle`] specifying the component value placed in the A component of
///   the output vector.
///# Description
///## Valid Usage (Implicit)
/// - [`r`] **must**  be a valid [`ComponentSwizzle`] value
/// - [`g`] **must**  be a valid [`ComponentSwizzle`] value
/// - [`b`] **must**  be a valid [`ComponentSwizzle`] value
/// - [`a`] **must**  be a valid [`ComponentSwizzle`] value
///# Related
/// - [`crate::vulkan1_0`]
/// - [`AndroidHardwareBufferFormatProperties2ANDROID`]
/// - [`AndroidHardwareBufferFormatPropertiesANDROID`]
/// - [`BufferCollectionPropertiesFUCHSIA`]
/// - [`ComponentSwizzle`]
/// - [`ImageViewCreateInfo`]
/// - [`SamplerBorderColorComponentMappingCreateInfoEXT`]
/// - [`SamplerYcbcrConversionCreateInfo`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct ComponentMapping {
    ///[`r`] is a [`ComponentSwizzle`] specifying the component value
    ///placed in the R component of the output vector.
    r: ComponentSwizzle,
    ///[`g`] is a [`ComponentSwizzle`] specifying the component value
    ///placed in the G component of the output vector.
    g: ComponentSwizzle,
    ///[`b`] is a [`ComponentSwizzle`] specifying the component value
    ///placed in the B component of the output vector.
    b: ComponentSwizzle,
    ///[`a`] is a [`ComponentSwizzle`] specifying the component value
    ///placed in the A component of the output vector.
    a: ComponentSwizzle,
}
impl Default for ComponentMapping {
    fn default() -> Self {
        Self {
            r: Default::default(),
            g: Default::default(),
            b: Default::default(),
            a: Default::default(),
        }
    }
}
impl ComponentMapping {
    ///Gets the value of [`Self::r`]
    pub fn r(&self) -> ComponentSwizzle {
        self.r
    }
    ///Gets the value of [`Self::g`]
    pub fn g(&self) -> ComponentSwizzle {
        self.g
    }
    ///Gets the value of [`Self::b`]
    pub fn b(&self) -> ComponentSwizzle {
        self.b
    }
    ///Gets the value of [`Self::a`]
    pub fn a(&self) -> ComponentSwizzle {
        self.a
    }
    ///Gets a mutable reference to the value of [`Self::r`]
    pub fn r_mut(&mut self) -> &mut ComponentSwizzle {
        &mut self.r
    }
    ///Gets a mutable reference to the value of [`Self::g`]
    pub fn g_mut(&mut self) -> &mut ComponentSwizzle {
        &mut self.g
    }
    ///Gets a mutable reference to the value of [`Self::b`]
    pub fn b_mut(&mut self) -> &mut ComponentSwizzle {
        &mut self.b
    }
    ///Gets a mutable reference to the value of [`Self::a`]
    pub fn a_mut(&mut self) -> &mut ComponentSwizzle {
        &mut self.a
    }
    ///Sets the raw value of [`Self::r`]
    pub fn set_r(&mut self, value: crate::vulkan1_0::ComponentSwizzle) -> &mut Self {
        self.r = value;
        self
    }
    ///Sets the raw value of [`Self::g`]
    pub fn set_g(&mut self, value: crate::vulkan1_0::ComponentSwizzle) -> &mut Self {
        self.g = value;
        self
    }
    ///Sets the raw value of [`Self::b`]
    pub fn set_b(&mut self, value: crate::vulkan1_0::ComponentSwizzle) -> &mut Self {
        self.b = value;
        self
    }
    ///Sets the raw value of [`Self::a`]
    pub fn set_a(&mut self, value: crate::vulkan1_0::ComponentSwizzle) -> &mut Self {
        self.a = value;
        self
    }
}
///[VkPhysicalDeviceProperties](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceProperties.html) - Structure specifying physical device properties
///# C Specifications
///The [`PhysicalDeviceProperties`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkPhysicalDeviceProperties {
///    uint32_t                            apiVersion;
///    uint32_t                            driverVersion;
///    uint32_t                            vendorID;
///    uint32_t                            deviceID;
///    VkPhysicalDeviceType                deviceType;
///    char                                deviceName[VK_MAX_PHYSICAL_DEVICE_NAME_SIZE];
///    uint8_t                             pipelineCacheUUID[VK_UUID_SIZE];
///    VkPhysicalDeviceLimits              limits;
///    VkPhysicalDeviceSparseProperties    sparseProperties;
///} VkPhysicalDeviceProperties;
///```
///# Members
/// - [`api_version`] is the version of Vulkan supported by the device, encoded as described in [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#extendingvulkan-coreversions-versionnumbers](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#extendingvulkan-coreversions-versionnumbers).
/// - [`driver_version`] is the vendor-specified version of the driver.
/// - [`vendor_id`] is a unique identifier for the *vendor* (see below) of the physical device.
/// - [`device_id`] is a unique identifier for the physical device among devices available from the
///   vendor.
/// - [`device_type`] is a [`PhysicalDeviceType`] specifying the type of device.
/// - [`device_name`] is an array of [`MAX_PHYSICAL_DEVICE_NAME_SIZE`]`char` containing a
///   null-terminated UTF-8 string which is the name of the device.
/// - [`pipeline_cache_uuid`] is an array of [`UUID_SIZE`]`uint8_t` values representing a
///   universally unique identifier for the device.
/// - [`limits`] is the [`PhysicalDeviceLimits`] structure specifying device-specific limits of the physical device. See [Limits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#limits) for details.
/// - [`sparse_properties`] is the [`PhysicalDeviceSparseProperties`] structure specifying various sparse related properties of the physical device. See [Sparse Properties](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#sparsememory-physicalprops) for details.
///# Description
///On implementations that claim support for the [Roadmap 2022](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#roadmap-2022)
///profile, the major and minor version expressed by [`api_version`] **must**  be
///at least Vulkan 1.3.The [`vendor_id`] and [`device_id`] fields are provided to allow
///applications to adapt to device characteristics that are not adequately
///exposed by other Vulkan queries.The *vendor* identified by [`vendor_id`] is the entity
/// responsible for the
///most salient characteristics of the underlying implementation of the
///[`PhysicalDevice`] being queried.If the vendor has a [PCI
///vendor ID](https://pcisig.com/membership/member-companies), the low 16 bits of [`vendor_id`] **must**  contain that PCI vendor
///ID, and the remaining bits  **must**  be set to zero.
///Otherwise, the value returned  **must**  be a valid Khronos vendor ID, obtained
///as described in the [Vulkan Documentation and Extensions:
///Procedures and Conventions](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#vulkan-styleguide) document in the section “Registering a Vendor
///ID with Khronos”.
///Khronos vendor IDs are allocated starting at 0x10000, to distinguish them
///from the PCI vendor ID namespace.
///Khronos vendor IDs are symbolically defined in the [`VendorId`] type.The vendor is also
/// responsible for the value returned in [`device_id`].
///If the implementation is driven primarily by a [PCI
///device](https://pcisig.com/) with a [PCI device ID](https://pcisig.com/), the low 16 bits of
///[`device_id`] **must**  contain that PCI device ID, and the remaining bits
/// **must**  be set to zero.
///Otherwise, the choice of what values to return  **may**  be dictated by operating
///system or platform policies - but  **should**  uniquely identify both the device
///version and any major configuration options (for example, core count in the
///case of multicore devices).
///# Related
/// - [`crate::vulkan1_0`]
/// - [`PhysicalDeviceLimits`]
/// - [`PhysicalDeviceProperties2`]
/// - [`PhysicalDeviceSparseProperties`]
/// - [`PhysicalDeviceType`]
/// - [`GetPhysicalDeviceProperties`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, PartialEq, PartialOrd)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct PhysicalDeviceProperties {
    ///[`api_version`] is the version of Vulkan supported by the device,
    ///encoded as described in [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#extendingvulkan-coreversions-versionnumbers](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#extendingvulkan-coreversions-versionnumbers).
    api_version: u32,
    ///[`driver_version`] is the vendor-specified version of the driver.
    driver_version: u32,
    ///[`vendor_id`] is a unique identifier for the *vendor* (see below) of
    ///the physical device.
    vendor_id: u32,
    ///[`device_id`] is a unique identifier for the physical device among
    ///devices available from the vendor.
    device_id: u32,
    ///[`device_type`] is a [`PhysicalDeviceType`] specifying the type of
    ///device.
    device_type: PhysicalDeviceType,
    ///[`device_name`] is an array of [`MAX_PHYSICAL_DEVICE_NAME_SIZE`]`char` containing a
    /// null-terminated UTF-8 string which is the name of the device.
    device_name: [c_schar; MAX_PHYSICAL_DEVICE_NAME_SIZE],
    ///[`pipeline_cache_uuid`] is an array of [`UUID_SIZE`]`uint8_t`
    ///values representing a universally unique identifier for the device.
    pipeline_cache_uuid: [u8; UUID_SIZE],
    ///[`limits`] is the [`PhysicalDeviceLimits`] structure specifying
    ///device-specific limits of the physical device.
    ///See [Limits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#limits) for details.
    limits: PhysicalDeviceLimits,
    ///[`sparse_properties`] is the [`PhysicalDeviceSparseProperties`]
    ///structure specifying various sparse related properties of the physical
    ///device.
    ///See [Sparse Properties](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#sparsememory-physicalprops) for details.
    sparse_properties: PhysicalDeviceSparseProperties,
}
impl Default for PhysicalDeviceProperties {
    fn default() -> Self {
        Self {
            api_version: 0,
            driver_version: 0,
            vendor_id: 0,
            device_id: 0,
            device_type: Default::default(),
            device_name: [b'\0' as i8; MAX_PHYSICAL_DEVICE_NAME_SIZE],
            pipeline_cache_uuid: [0; UUID_SIZE],
            limits: Default::default(),
            sparse_properties: Default::default(),
        }
    }
}
impl PhysicalDeviceProperties {
    ///Gets the value of [`Self::api_version`]
    pub fn api_version(&self) -> u32 {
        self.api_version
    }
    ///Gets the value of [`Self::driver_version`]
    pub fn driver_version(&self) -> u32 {
        self.driver_version
    }
    ///Gets the value of [`Self::vendor_id`]
    pub fn vendor_id(&self) -> u32 {
        self.vendor_id
    }
    ///Gets the value of [`Self::device_id`]
    pub fn device_id(&self) -> u32 {
        self.device_id
    }
    ///Gets the value of [`Self::device_type`]
    pub fn device_type(&self) -> PhysicalDeviceType {
        self.device_type
    }
    ///Gets the value of [`Self::device_name`]
    pub fn device_name(&self) -> &[c_schar; MAX_PHYSICAL_DEVICE_NAME_SIZE] {
        &getter
    }
    ///Gets the value of [`Self::pipeline_cache_uuid`]
    pub fn pipeline_cache_uuid(&self) -> &[u8; UUID_SIZE] {
        &getter
    }
    ///Gets the value of [`Self::limits`]
    pub fn limits(&self) -> PhysicalDeviceLimits {
        self.limits
    }
    ///Gets the value of [`Self::sparse_properties`]
    pub fn sparse_properties(&self) -> PhysicalDeviceSparseProperties {
        self.sparse_properties
    }
    ///Gets a mutable reference to the value of [`Self::api_version`]
    pub fn api_version_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::driver_version`]
    pub fn driver_version_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::vendor_id`]
    pub fn vendor_id_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::device_id`]
    pub fn device_id_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::device_type`]
    pub fn device_type_mut(&mut self) -> &mut PhysicalDeviceType {
        &mut self.device_type
    }
    ///Gets a mutable reference to the value of [`Self::device_name`]
    pub fn device_name_mut(&mut self) -> &mut [c_schar; MAX_PHYSICAL_DEVICE_NAME_SIZE] {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::pipeline_cache_uuid`]
    pub fn pipeline_cache_uuid_mut(&mut self) -> &mut [u8; UUID_SIZE] {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::limits`]
    pub fn limits_mut(&mut self) -> &mut PhysicalDeviceLimits {
        &mut self.limits
    }
    ///Gets a mutable reference to the value of [`Self::sparse_properties`]
    pub fn sparse_properties_mut(&mut self) -> &mut PhysicalDeviceSparseProperties {
        &mut self.sparse_properties
    }
    ///Sets the raw value of [`Self::api_version`]
    pub fn set_api_version(&mut self, value: u32) -> &mut Self {
        self.api_version = value;
        self
    }
    ///Sets the raw value of [`Self::driver_version`]
    pub fn set_driver_version(&mut self, value: u32) -> &mut Self {
        self.driver_version = value;
        self
    }
    ///Sets the raw value of [`Self::vendor_id`]
    pub fn set_vendor_id(&mut self, value: u32) -> &mut Self {
        self.vendor_id = value;
        self
    }
    ///Sets the raw value of [`Self::device_id`]
    pub fn set_device_id(&mut self, value: u32) -> &mut Self {
        self.device_id = value;
        self
    }
    ///Sets the raw value of [`Self::device_type`]
    pub fn set_device_type(&mut self, value: crate::vulkan1_0::PhysicalDeviceType) -> &mut Self {
        self.device_type = value;
        self
    }
    ///Sets the raw value of [`Self::device_name`]
    pub fn set_device_name(
        &mut self,
        value: [std::os::raw::c_char; crate::core::MAX_PHYSICAL_DEVICE_NAME_SIZE],
    ) -> &mut Self {
        self.device_name = value;
        self
    }
    ///Sets the raw value of [`Self::pipeline_cache_uuid`]
    pub fn set_pipeline_cache_uuid(&mut self, value: [u8; crate::core::UUID_SIZE]) -> &mut Self {
        self.pipeline_cache_uuid = value;
        self
    }
    ///Sets the raw value of [`Self::limits`]
    pub fn set_limits(&mut self, value: crate::vulkan1_0::PhysicalDeviceLimits) -> &mut Self {
        self.limits = value;
        self
    }
    ///Sets the raw value of [`Self::sparse_properties`]
    pub fn set_sparse_properties(&mut self, value: crate::vulkan1_0::PhysicalDeviceSparseProperties) -> &mut Self {
        self.sparse_properties = value;
        self
    }
}
///[VkExtensionProperties](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExtensionProperties.html) - Structure specifying an extension properties
///# C Specifications
///The [`ExtensionProperties`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkExtensionProperties {
///    char        extensionName[VK_MAX_EXTENSION_NAME_SIZE];
///    uint32_t    specVersion;
///} VkExtensionProperties;
///```
///# Members
/// - [`extension_name`] is an array of [`MAX_EXTENSION_NAME_SIZE`]`char` containing a
///   null-terminated UTF-8 string which is the name of the extension.
/// - [`spec_version`] is the version of this extension. It is an integer, incremented with backward
///   compatible changes.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`VideoDecodeH264CapabilitiesEXT`]
/// - [`VideoDecodeH264SessionCreateInfoEXT`]
/// - [`VideoDecodeH265CapabilitiesEXT`]
/// - [`VideoDecodeH265SessionCreateInfoEXT`]
/// - [`VideoEncodeH264CapabilitiesEXT`]
/// - [`VideoEncodeH264SessionCreateInfoEXT`]
/// - [`VideoEncodeH265CapabilitiesEXT`]
/// - [`VideoEncodeH265SessionCreateInfoEXT`]
/// - [`EnumerateDeviceExtensionProperties`]
/// - [`EnumerateInstanceExtensionProperties`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct ExtensionProperties {
    ///[`extension_name`] is an array of [`MAX_EXTENSION_NAME_SIZE`]`char` containing a
    /// null-terminated UTF-8 string which is the name of the extension.
    extension_name: [c_schar; MAX_EXTENSION_NAME_SIZE],
    ///[`spec_version`] is the version of this extension.
    ///It is an integer, incremented with backward compatible changes.
    spec_version: u32,
}
impl Default for ExtensionProperties {
    fn default() -> Self {
        Self {
            extension_name: [b'\0' as i8; MAX_EXTENSION_NAME_SIZE],
            spec_version: 0,
        }
    }
}
impl ExtensionProperties {
    ///Gets the value of [`Self::extension_name`]
    pub fn extension_name(&self) -> &[c_schar; MAX_EXTENSION_NAME_SIZE] {
        &getter
    }
    ///Gets the value of [`Self::spec_version`]
    pub fn spec_version(&self) -> u32 {
        self.spec_version
    }
    ///Gets a mutable reference to the value of [`Self::extension_name`]
    pub fn extension_name_mut(&mut self) -> &mut [c_schar; MAX_EXTENSION_NAME_SIZE] {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::spec_version`]
    pub fn spec_version_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Sets the raw value of [`Self::extension_name`]
    pub fn set_extension_name(
        &mut self,
        value: [std::os::raw::c_char; crate::core::MAX_EXTENSION_NAME_SIZE],
    ) -> &mut Self {
        self.extension_name = value;
        self
    }
    ///Sets the raw value of [`Self::spec_version`]
    pub fn set_spec_version(&mut self, value: u32) -> &mut Self {
        self.spec_version = value;
        self
    }
}
///[VkLayerProperties](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkLayerProperties.html) - Structure specifying layer properties
///# C Specifications
///The [`LayerProperties`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkLayerProperties {
///    char        layerName[VK_MAX_EXTENSION_NAME_SIZE];
///    uint32_t    specVersion;
///    uint32_t    implementationVersion;
///    char        description[VK_MAX_DESCRIPTION_SIZE];
///} VkLayerProperties;
///```
///# Members
/// - [`layer_name`] is an array of [`MAX_EXTENSION_NAME_SIZE`]`char` containing a null-terminated
///   UTF-8 string which is the name of the layer. Use this name in the `ppEnabledLayerNames` array
///   passed in the [`InstanceCreateInfo`] structure to enable this layer for an instance.
/// - [`spec_version`] is the Vulkan version the layer was written to, encoded as described in [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#extendingvulkan-coreversions-versionnumbers](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#extendingvulkan-coreversions-versionnumbers).
/// - [`implementation_version`] is the version of this layer. It is an integer, increasing with
///   backward compatible changes.
/// - [`description`] is an array of [`MAX_DESCRIPTION_SIZE`]`char` containing a null-terminated
///   UTF-8 string which provides additional details that  **can**  be used by the application to
///   identify the layer.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`EnumerateDeviceLayerProperties`]
/// - [`EnumerateInstanceLayerProperties`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct LayerProperties {
    ///[`layer_name`] is an array of [`MAX_EXTENSION_NAME_SIZE`]`char` containing a null-terminated
    /// UTF-8 string which is the name of the layer.
    ///Use this name in the `ppEnabledLayerNames` array passed in the
    ///[`InstanceCreateInfo`] structure to enable this layer for an
    ///instance.
    layer_name: [c_schar; MAX_EXTENSION_NAME_SIZE],
    ///[`spec_version`] is the Vulkan version the layer was written to,
    ///encoded as described in [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#extendingvulkan-coreversions-versionnumbers](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#extendingvulkan-coreversions-versionnumbers).
    spec_version: u32,
    ///[`implementation_version`] is the version of this layer.
    ///It is an integer, increasing with backward compatible changes.
    implementation_version: u32,
    ///[`description`] is an array of [`MAX_DESCRIPTION_SIZE`]`char`
    ///containing a null-terminated UTF-8 string which provides additional
    ///details that  **can**  be used by the application to identify the layer.
    description: [c_schar; MAX_DESCRIPTION_SIZE],
}
impl Default for LayerProperties {
    fn default() -> Self {
        Self {
            layer_name: [b'\0' as i8; MAX_EXTENSION_NAME_SIZE],
            spec_version: 0,
            implementation_version: 0,
            description: [b'\0' as i8; MAX_DESCRIPTION_SIZE],
        }
    }
}
impl LayerProperties {
    ///Gets the value of [`Self::layer_name`]
    pub fn layer_name(&self) -> &[c_schar; MAX_EXTENSION_NAME_SIZE] {
        &getter
    }
    ///Gets the value of [`Self::spec_version`]
    pub fn spec_version(&self) -> u32 {
        self.spec_version
    }
    ///Gets the value of [`Self::implementation_version`]
    pub fn implementation_version(&self) -> u32 {
        self.implementation_version
    }
    ///Gets the value of [`Self::description`]
    pub fn description(&self) -> &[c_schar; MAX_DESCRIPTION_SIZE] {
        &getter
    }
    ///Gets a mutable reference to the value of [`Self::layer_name`]
    pub fn layer_name_mut(&mut self) -> &mut [c_schar; MAX_EXTENSION_NAME_SIZE] {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::spec_version`]
    pub fn spec_version_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::implementation_version`]
    pub fn implementation_version_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::description`]
    pub fn description_mut(&mut self) -> &mut [c_schar; MAX_DESCRIPTION_SIZE] {
        &mut getter
    }
    ///Sets the raw value of [`Self::layer_name`]
    pub fn set_layer_name(&mut self, value: [std::os::raw::c_char; crate::core::MAX_EXTENSION_NAME_SIZE]) -> &mut Self {
        self.layer_name = value;
        self
    }
    ///Sets the raw value of [`Self::spec_version`]
    pub fn set_spec_version(&mut self, value: u32) -> &mut Self {
        self.spec_version = value;
        self
    }
    ///Sets the raw value of [`Self::implementation_version`]
    pub fn set_implementation_version(&mut self, value: u32) -> &mut Self {
        self.implementation_version = value;
        self
    }
    ///Sets the raw value of [`Self::description`]
    pub fn set_description(&mut self, value: [std::os::raw::c_char; crate::core::MAX_DESCRIPTION_SIZE]) -> &mut Self {
        self.description = value;
        self
    }
}
///[VkApplicationInfo](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkApplicationInfo.html) - Structure specifying application information
///# C Specifications
///The [`ApplicationInfo`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkApplicationInfo {
///    VkStructureType    sType;
///    const void*        pNext;
///    const char*        pApplicationName;
///    uint32_t           applicationVersion;
///    const char*        pEngineName;
///    uint32_t           engineVersion;
///    uint32_t           apiVersion;
///} VkApplicationInfo;
///```
///# Members
/// - [`s_type`] is the type of this structure.
/// - [`p_next`] is `NULL` or a pointer to a structure extending this structure.
/// - [`application_name`] is `NULL` or is a pointer to a null-terminated UTF-8 string containing
///   the name of the application.
/// - [`application_version`] is an unsigned integer variable containing the developer-supplied
///   version number of the application.
/// - [`engine_name`] is `NULL` or is a pointer to a null-terminated UTF-8 string containing the
///   name of the engine (if any) used to create the application.
/// - [`engine_version`] is an unsigned integer variable containing the developer-supplied version
///   number of the engine used to create the application.
/// - [`api_version`] **must**  be the highest version of Vulkan that the application is designed to
///   use, encoded as described in [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#extendingvulkan-coreversions-versionnumbers](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#extendingvulkan-coreversions-versionnumbers).
///   The patch version number specified in [`api_version`] is ignored when creating an instance
///   object. Only the major and minor versions of the instance  **must**  match those requested in
///   [`api_version`].
///# Description
///Vulkan 1.0 implementations were required to return
///`VK_ERROR_INCOMPATIBLE_DRIVER` if [`api_version`] was larger than 1.0.
///Implementations that support Vulkan 1.1 or later  **must**  not return
///`VK_ERROR_INCOMPATIBLE_DRIVER` for any value of [`api_version`].As long as the instance supports
/// at least Vulkan 1.1, an application  **can**
///use different versions of Vulkan with an instance than it does with a device
///or physical device.Implicit layers  **must**  be disabled if they do not support a version at
/// least
///as high as [`api_version`].
///See the [“Architecture of the Vulkan Loader
///Interfaces”](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#LoaderInterfaceArchitecture) document for additional information.
///## Valid Usage
/// - If [`api_version`] is not `0`, then it  **must**  be greater than or equal to
///   [`crate::utils::Version::VULKAN1_0`]
///
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be `VK_STRUCTURE_TYPE_APPLICATION_INFO`
/// - [`p_next`] **must**  be `NULL`
/// - If [`application_name`] is not `NULL`, [`application_name`] **must**  be a null-terminated
///   UTF-8 string
/// - If [`engine_name`] is not `NULL`, [`engine_name`] **must**  be a null-terminated UTF-8 string
///# Related
/// - [`crate::vulkan1_0`]
/// - [`InstanceCreateInfo`]
/// - [`StructureType`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[repr(C)]
pub struct ApplicationInfo<'lt> {
    _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] is the type of this structure.
    s_type: StructureType,
    ///[`p_next`] is `NULL` or a pointer to a structure extending this
    ///structure.
    p_next: *const BaseInStructure<'lt>,
    ///[`application_name`] is `NULL` or is a pointer to a null-terminated
    ///UTF-8 string containing the name of the application.
    application_name: &'lt CStr,
    ///[`application_version`] is an unsigned integer variable containing the
    ///developer-supplied version number of the application.
    application_version: u32,
    ///[`engine_name`] is `NULL` or is a pointer to a null-terminated UTF-8
    ///string containing the name of the engine (if any) used to create the
    ///application.
    engine_name: &'lt CStr,
    ///[`engine_version`] is an unsigned integer variable containing the
    ///developer-supplied version number of the engine used to create the
    ///application.
    engine_version: u32,
    ///[`api_version`] **must**  be the highest version of Vulkan that the
    ///application is designed to use, encoded as described in
    ///[https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#extendingvulkan-coreversions-versionnumbers](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#extendingvulkan-coreversions-versionnumbers).
    ///The patch version number specified in [`api_version`] is ignored when
    ///creating an instance object.
    ///Only the major and minor versions of the instance  **must**  match those
    ///requested in [`api_version`].
    api_version: u32,
}
impl<'lt> Default for ApplicationInfo<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: Default::default(),
            p_next: std::ptr::null(),
            application_name: std::ptr::null(),
            application_version: 0,
            engine_name: std::ptr::null(),
            engine_version: 0,
            api_version: 0,
        }
    }
}
impl<'lt> ApplicationInfo<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *const BaseInStructure<'lt> {
        self.p_next
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *const BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseInStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::application_name`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn application_name(&self) -> &'lt CStr {
        self.application_name
    }
    ///Gets the value of [`Self::application_version`]
    pub fn application_version(&self) -> u32 {
        self.application_version
    }
    ///Gets the value of [`Self::engine_name`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn engine_name(&self) -> &'lt CStr {
        self.engine_name
    }
    ///Gets the value of [`Self::engine_version`]
    pub fn engine_version(&self) -> u32 {
        self.engine_version
    }
    ///Gets the value of [`Self::api_version`]
    pub fn api_version(&self) -> u32 {
        self.api_version
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::application_version`]
    pub fn application_version_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::engine_version`]
    pub fn engine_version_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::api_version`]
    pub fn api_version_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Sets the raw value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the raw value of [`Self::application_name`]
    pub fn set_application_name(&mut self, value: &'lt std::ffi::CStr) -> &mut Self {
        self.application_name = value;
        self
    }
    ///Sets the raw value of [`Self::application_version`]
    pub fn set_application_version(&mut self, value: u32) -> &mut Self {
        self.application_version = value;
        self
    }
    ///Sets the raw value of [`Self::engine_name`]
    pub fn set_engine_name(&mut self, value: &'lt std::ffi::CStr) -> &mut Self {
        self.engine_name = value;
        self
    }
    ///Sets the raw value of [`Self::engine_version`]
    pub fn set_engine_version(&mut self, value: u32) -> &mut Self {
        self.engine_version = value;
        self
    }
    ///Sets the raw value of [`Self::api_version`]
    pub fn set_api_version(&mut self, value: u32) -> &mut Self {
        self.api_version = value;
        self
    }
}
///[VkAllocationCallbacks](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAllocationCallbacks.html) - Structure containing callback function pointers for memory allocation
///# C Specifications
///Allocators are provided by the application as a pointer to a
///[`AllocationCallbacks`] structure:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkAllocationCallbacks {
///    void*                                   pUserData;
///    PFN_vkAllocationFunction                pfnAllocation;
///    PFN_vkReallocationFunction              pfnReallocation;
///    PFN_vkFreeFunction                      pfnFree;
///    PFN_vkInternalAllocationNotification    pfnInternalAllocation;
///    PFN_vkInternalFreeNotification          pfnInternalFree;
///} VkAllocationCallbacks;
///```
///# Members
/// - [`user_data`] is a value to be interpreted by the implementation of the callbacks. When any of
///   the callbacks in [`AllocationCallbacks`] are called, the Vulkan implementation will pass this
///   value as the first parameter to the callback. This value  **can**  vary each time an allocator
///   is passed into a command, even when the same object takes an allocator in multiple commands.
/// - [`pfn_allocation`] is a [`PFNAllocationFunction`] pointer to an application-defined memory
///   allocation function.
/// - [`pfn_reallocation`] is a [`PFNReallocationFunction`] pointer to an application-defined memory
///   reallocation function.
/// - [`pfn_free`] is a [`PFNFreeFunction`] pointer to an application-defined memory free function.
/// - [`pfn_internal_allocation`] is a [`PFNInternalAllocationNotification`] pointer to an
///   application-defined function that is called by the implementation when the implementation
///   makes internal allocations.
/// - [`pfn_internal_free`] is a [`PFNInternalFreeNotification`] pointer to an application-defined
///   function that is called by the implementation when the implementation frees internal
///   allocations.
///# Description
///## Valid Usage
/// - [`pfn_allocation`] **must**  be a valid pointer to a valid user-defined
///   [`PFNAllocationFunction`]
/// - [`pfn_reallocation`] **must**  be a valid pointer to a valid user-defined
///   [`PFNReallocationFunction`]
/// - [`pfn_free`] **must**  be a valid pointer to a valid user-defined [`PFNFreeFunction`]
/// - If either of [`pfn_internal_allocation`] or [`pfn_internal_free`] is not `NULL`, both
///   **must**  be valid callbacks
///# Related
/// - [`PFNAllocationFunction`]
/// - [`PFNFreeFunction`]
/// - [`PFNInternalAllocationNotification`]
/// - [`PFNInternalFreeNotification`]
/// - [`PFNReallocationFunction`]
/// - [`crate::vulkan1_0`]
/// - [`AllocateMemory`]
/// - [`CreateAccelerationStructureKHR`]
/// - [`CreateAccelerationStructureNV`]
/// - [`CreateAndroidSurfaceKHR`]
/// - [`CreateBuffer`]
/// - [`CreateBufferCollectionFUCHSIA`]
/// - [`CreateBufferView`]
/// - [`CreateCommandPool`]
/// - [`CreateComputePipelines`]
/// - [`CreateCuFunctionNVX`]
/// - [`CreateCuModuleNVX`]
/// - [`CreateDebugReportCallbackEXT`]
/// - [`CreateDebugUtilsMessengerEXT`]
/// - [`CreateDeferredOperationKHR`]
/// - [`CreateDescriptorPool`]
/// - [`CreateDescriptorSetLayout`]
/// - [`CreateDescriptorUpdateTemplate`]
/// - [`CreateDescriptorUpdateTemplateKHR`]
/// - [`CreateDevice`]
/// - [`CreateDirectFBSurfaceEXT`]
/// - [`CreateDisplayModeKHR`]
/// - [`CreateDisplayPlaneSurfaceKHR`]
/// - [`CreateEvent`]
/// - [`CreateFence`]
/// - [`CreateFramebuffer`]
/// - [`CreateGraphicsPipelines`]
/// - [`CreateHeadlessSurfaceEXT`]
/// - [`CreateIosSurfaceMVK`]
/// - [`CreateImage`]
/// - [`CreateImagePipeSurfaceFUCHSIA`]
/// - [`CreateImageView`]
/// - [`CreateIndirectCommandsLayoutNV`]
/// - [`CreateInstance`]
/// - [`CreateMacOsSurfaceMVK`]
/// - [`CreateMetalSurfaceEXT`]
/// - [`CreatePipelineCache`]
/// - [`CreatePipelineLayout`]
/// - [`CreatePrivateDataSlot`]
/// - [`CreatePrivateDataSlotEXT`]
/// - [`CreateQueryPool`]
/// - [`CreateRayTracingPipelinesKHR`]
/// - [`CreateRayTracingPipelinesNV`]
/// - [`CreateRenderPass`]
/// - [`CreateRenderPass2`]
/// - [`CreateRenderPass2KHR`]
/// - [`CreateSampler`]
/// - [`CreateSamplerYcbcrConversion`]
/// - [`CreateSamplerYcbcrConversionKHR`]
/// - [`CreateScreenSurfaceQNX`]
/// - [`CreateSemaphore`]
/// - [`CreateShaderModule`]
/// - [`CreateSharedSwapchainsKHR`]
/// - [`CreateStreamDescriptorSurfaceGGP`]
/// - [`CreateSwapchainKHR`]
/// - [`CreateValidationCacheEXT`]
/// - [`CreateViSurfaceNN`]
/// - [`CreateVideoSessionKHR`]
/// - [`CreateVideoSessionParametersKHR`]
/// - [`CreateWaylandSurfaceKHR`]
/// - [`CreateWin32SurfaceKHR`]
/// - [`CreateXcbSurfaceKHR`]
/// - [`CreateXlibSurfaceKHR`]
/// - [`DestroyAccelerationStructureKHR`]
/// - [`DestroyAccelerationStructureNV`]
/// - [`DestroyBuffer`]
/// - [`DestroyBufferCollectionFUCHSIA`]
/// - [`DestroyBufferView`]
/// - [`DestroyCommandPool`]
/// - [`DestroyCuFunctionNVX`]
/// - [`DestroyCuModuleNVX`]
/// - [`DestroyDebugReportCallbackEXT`]
/// - [`DestroyDebugUtilsMessengerEXT`]
/// - [`DestroyDeferredOperationKHR`]
/// - [`DestroyDescriptorPool`]
/// - [`DestroyDescriptorSetLayout`]
/// - [`DestroyDescriptorUpdateTemplate`]
/// - [`DestroyDescriptorUpdateTemplateKHR`]
/// - [`DestroyDevice`]
/// - [`DestroyEvent`]
/// - [`DestroyFence`]
/// - [`DestroyFramebuffer`]
/// - [`DestroyImage`]
/// - [`DestroyImageView`]
/// - [`DestroyIndirectCommandsLayoutNV`]
/// - [`DestroyInstance`]
/// - [`DestroyPipeline`]
/// - [`DestroyPipelineCache`]
/// - [`DestroyPipelineLayout`]
/// - [`DestroyPrivateDataSlot`]
/// - [`DestroyPrivateDataSlotEXT`]
/// - [`DestroyQueryPool`]
/// - [`DestroyRenderPass`]
/// - [`DestroySampler`]
/// - [`DestroySamplerYcbcrConversion`]
/// - [`DestroySamplerYcbcrConversionKHR`]
/// - [`DestroySemaphore`]
/// - [`DestroyShaderModule`]
/// - [`DestroySurfaceKHR`]
/// - [`DestroySwapchainKHR`]
/// - [`DestroyValidationCacheEXT`]
/// - [`DestroyVideoSessionKHR`]
/// - [`DestroyVideoSessionParametersKHR`]
/// - [`FreeMemory`]
/// - [`RegisterDeviceEventEXT`]
/// - [`RegisterDisplayEventEXT`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Eq, Ord, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[repr(C)]
pub struct AllocationCallbacks<'lt> {
    _lifetime: PhantomData<&'lt ()>,
    ///[`user_data`] is a value to be interpreted by the implementation of
    ///the callbacks.
    ///When any of the callbacks in [`AllocationCallbacks`] are called, the
    ///Vulkan implementation will pass this value as the first parameter to the
    ///callback.
    ///This value  **can**  vary each time an allocator is passed into a command,
    ///even when the same object takes an allocator in multiple commands.
    user_data: *mut c_void,
    ///[`pfn_allocation`] is a [`PFNAllocationFunction`] pointer to an
    ///application-defined memory allocation function.
    pfn_allocation: PFNAllocationFunction<'lt>,
    ///[`pfn_reallocation`] is a [`PFNReallocationFunction`] pointer to
    ///an application-defined memory reallocation function.
    pfn_reallocation: PFNReallocationFunction<'lt>,
    ///[`pfn_free`] is a [`PFNFreeFunction`] pointer to an
    ///application-defined memory free function.
    pfn_free: PFNFreeFunction<'lt>,
    ///[`pfn_internal_allocation`] is a
    ///[`PFNInternalAllocationNotification`] pointer to an
    ///application-defined function that is called by the implementation when
    ///the implementation makes internal allocations.
    pfn_internal_allocation: PFNInternalAllocationNotification<'lt>,
    ///[`pfn_internal_free`] is a [`PFNInternalFreeNotification`] pointer
    ///to an application-defined function that is called by the implementation
    ///when the implementation frees internal allocations.
    pfn_internal_free: PFNInternalFreeNotification<'lt>,
}
impl<'lt> Default for AllocationCallbacks<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            user_data: std::ptr::null_mut(),
            pfn_allocation: Default::default(),
            pfn_reallocation: Default::default(),
            pfn_free: Default::default(),
            pfn_internal_allocation: Default::default(),
            pfn_internal_free: Default::default(),
        }
    }
}
impl<'lt> AllocationCallbacks<'lt> {
    ///Gets the raw value of [`Self::user_data`]
    pub fn user_data_raw(&self) -> &*mut c_void {
        &self.user_data
    }
    ///Sets the raw value of [`Self::user_data`]
    pub fn set_user_data_raw(&mut self, value: *mut c_void) -> &mut Self {
        self.user_data = value;
        self
    }
    ///Gets the value of [`Self::user_data`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn user_data(&self) -> &c_void {
        &*self.user_data
    }
    ///Gets the value of [`Self::pfn_allocation`]
    pub fn pfn_allocation(&self) -> &PFNAllocationFunction<'lt> {
        &self.pfn_allocation
    }
    ///Gets the value of [`Self::pfn_reallocation`]
    pub fn pfn_reallocation(&self) -> &PFNReallocationFunction<'lt> {
        &self.pfn_reallocation
    }
    ///Gets the value of [`Self::pfn_free`]
    pub fn pfn_free(&self) -> &PFNFreeFunction<'lt> {
        &self.pfn_free
    }
    ///Gets the value of [`Self::pfn_internal_allocation`]
    pub fn pfn_internal_allocation(&self) -> &PFNInternalAllocationNotification<'lt> {
        &self.pfn_internal_allocation
    }
    ///Gets the value of [`Self::pfn_internal_free`]
    pub fn pfn_internal_free(&self) -> &PFNInternalFreeNotification<'lt> {
        &self.pfn_internal_free
    }
    ///Gets a mutable reference to the value of [`Self::user_data`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn user_data_mut(&mut self) -> &mut c_void {
        &mut *self.user_data
    }
    ///Gets a mutable reference to the value of [`Self::pfn_allocation`]
    pub fn pfn_allocation_mut(&mut self) -> &mut PFNAllocationFunction<'lt> {
        &mut self.pfn_allocation
    }
    ///Gets a mutable reference to the value of [`Self::pfn_reallocation`]
    pub fn pfn_reallocation_mut(&mut self) -> &mut PFNReallocationFunction<'lt> {
        &mut self.pfn_reallocation
    }
    ///Gets a mutable reference to the value of [`Self::pfn_free`]
    pub fn pfn_free_mut(&mut self) -> &mut PFNFreeFunction<'lt> {
        &mut self.pfn_free
    }
    ///Gets a mutable reference to the value of [`Self::pfn_internal_allocation`]
    pub fn pfn_internal_allocation_mut(&mut self) -> &mut PFNInternalAllocationNotification<'lt> {
        &mut self.pfn_internal_allocation
    }
    ///Gets a mutable reference to the value of [`Self::pfn_internal_free`]
    pub fn pfn_internal_free_mut(&mut self) -> &mut PFNInternalFreeNotification<'lt> {
        &mut self.pfn_internal_free
    }
    ///Sets the raw value of [`Self::user_data`]
    pub fn set_user_data(&mut self, value: &'lt mut std::ffi::c_void) -> &mut Self {
        self.user_data = value as *mut _;
        self
    }
    ///Sets the raw value of [`Self::pfn_allocation`]
    pub fn set_pfn_allocation(&mut self, value: crate::vulkan1_0::PFNAllocationFunction<'lt>) -> &mut Self {
        self.pfn_allocation = value;
        self
    }
    ///Sets the raw value of [`Self::pfn_reallocation`]
    pub fn set_pfn_reallocation(&mut self, value: crate::vulkan1_0::PFNReallocationFunction<'lt>) -> &mut Self {
        self.pfn_reallocation = value;
        self
    }
    ///Sets the raw value of [`Self::pfn_free`]
    pub fn set_pfn_free(&mut self, value: crate::vulkan1_0::PFNFreeFunction<'lt>) -> &mut Self {
        self.pfn_free = value;
        self
    }
    ///Sets the raw value of [`Self::pfn_internal_allocation`]
    pub fn set_pfn_internal_allocation(
        &mut self,
        value: crate::vulkan1_0::PFNInternalAllocationNotification<'lt>,
    ) -> &mut Self {
        self.pfn_internal_allocation = value;
        self
    }
    ///Sets the raw value of [`Self::pfn_internal_free`]
    pub fn set_pfn_internal_free(&mut self, value: crate::vulkan1_0::PFNInternalFreeNotification<'lt>) -> &mut Self {
        self.pfn_internal_free = value;
        self
    }
}
///[VkDeviceQueueCreateInfo](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceQueueCreateInfo.html) - Structure specifying parameters of a newly created device queue
///# C Specifications
///The [`DeviceQueueCreateInfo`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkDeviceQueueCreateInfo {
///    VkStructureType             sType;
///    const void*                 pNext;
///    VkDeviceQueueCreateFlags    flags;
///    uint32_t                    queueFamilyIndex;
///    uint32_t                    queueCount;
///    const float*                pQueuePriorities;
///} VkDeviceQueueCreateInfo;
///```
///# Members
/// - [`s_type`] is the type of this structure.
/// - [`p_next`] is `NULL` or a pointer to a structure extending this structure.
/// - [`flags`] is a bitmask indicating behavior of the queue.
/// - [`queue_family_index`] is an unsigned integer indicating the index of the queue family in
///   which to create the queue on this device. This index corresponds to the index of an element of
///   the `pQueueFamilyProperties` array that was returned by
///   [`GetPhysicalDeviceQueueFamilyProperties`].
/// - [`queue_count`] is an unsigned integer specifying the number of queues to create in the queue
///   family indicated by [`queue_family_index`].
/// - [`queue_priorities`] is a pointer to an array of [`queue_count`] normalized floating point values, specifying priorities of work that will be submitted to each created queue. See [Queue Priority](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#devsandqueues-priority) for more information.
///# Description
///## Valid Usage
/// - [`queue_family_index`] **must**  be less than `pQueueFamilyPropertyCount` returned by
///   [`GetPhysicalDeviceQueueFamilyProperties`]
/// - [`queue_count`] **must**  be less than or equal to the [`queue_count`] member of the
///   [`QueueFamilyProperties`] structure, as returned by [`GetPhysicalDeviceQueueFamilyProperties`]
///   in the `pQueueFamilyProperties`[queueFamilyIndex]
/// - Each element of [`queue_priorities`] **must**  be between `0.0` and `1.0` inclusive
/// - If the [protected memory](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-protectedMemory)
///   feature is not enabled, the `VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT` bit of [`flags`] **must**
///   not be set
/// - If [`flags`] includes `VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT`, [`queue_family_index`] **must**
///   be the index of a queue family that includes the `VK_QUEUE_PROTECTED_BIT` capability
///
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be `VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO`
/// - [`p_next`] **must**  be `NULL` or a pointer to a valid instance of
///   [`DeviceQueueGlobalPriorityCreateInfoKHR`]
/// - The [`s_type`] value of each struct in the [`p_next`] chain  **must**  be unique
/// - [`flags`] **must**  be a valid combination of [`DeviceQueueCreateFlagBits`] values
/// - [`queue_priorities`] **must**  be a valid pointer to an array of [`queue_count`]`float` values
/// - [`queue_count`] **must**  be greater than `0`
///# Related
/// - [`crate::vulkan1_0`]
/// - [`DeviceCreateInfo`]
/// - [`DeviceQueueCreateFlags`]
/// - [`StructureType`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[repr(C)]
pub struct DeviceQueueCreateInfo<'lt> {
    _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] is the type of this structure.
    s_type: StructureType,
    ///[`p_next`] is `NULL` or a pointer to a structure extending this
    ///structure.
    p_next: *const BaseInStructure<'lt>,
    ///[`flags`] is a bitmask indicating behavior of the queue.
    flags: DeviceQueueCreateFlags,
    ///[`queue_family_index`] is an unsigned integer indicating the index of
    ///the queue family in which to create the queue on this device.
    ///This index corresponds to the index of an element of the
    ///`pQueueFamilyProperties` array that was returned by
    ///[`GetPhysicalDeviceQueueFamilyProperties`].
    queue_family_index: u32,
    ///[`queue_count`] is an unsigned integer specifying the number of queues
    ///to create in the queue family indicated by [`queue_family_index`].
    queue_count: u32,
    ///[`queue_priorities`] is a pointer to an array of [`queue_count`]
    ///normalized floating point values, specifying priorities of work that
    ///will be submitted to each created queue.
    ///See [Queue Priority](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#devsandqueues-priority) for more information.
    queue_priorities: *const f32,
}
impl<'lt> Default for DeviceQueueCreateInfo<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: Default::default(),
            p_next: std::ptr::null(),
            flags: Default::default(),
            queue_family_index: 0,
            queue_count: 0,
            queue_priorities: std::ptr::null(),
        }
    }
}
impl<'lt> DeviceQueueCreateInfo<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *const BaseInStructure<'lt> {
        self.p_next
    }
    ///Gets the raw value of [`Self::queue_priorities`]
    pub fn queue_priorities_raw(&self) -> *const f32 {
        self.queue_priorities
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *const BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::queue_priorities`]
    pub fn set_queue_priorities_raw(&mut self, value: *const f32) -> &mut Self {
        self.queue_priorities = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseInStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::flags`]
    pub fn flags(&self) -> DeviceQueueCreateFlags {
        self.flags
    }
    ///Gets the value of [`Self::queue_family_index`]
    pub fn queue_family_index(&self) -> u32 {
        self.queue_family_index
    }
    ///Gets the value of [`Self::queue_count`]
    pub fn queue_count(&self) -> u32 {
        self.queue_count
    }
    ///Gets the value of [`Self::queue_priorities`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn queue_priorities(&self) -> &[f32] {
        std::slice::from_raw_parts(self.queue_priorities, self.queue_count as usize)
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::flags`]
    pub fn flags_mut(&mut self) -> &mut DeviceQueueCreateFlags {
        &mut self.flags
    }
    ///Gets a mutable reference to the value of [`Self::queue_family_index`]
    pub fn queue_family_index_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::queue_count`]
    pub fn queue_count_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Sets the raw value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the raw value of [`Self::flags`]
    pub fn set_flags(&mut self, value: crate::vulkan1_0::DeviceQueueCreateFlags) -> &mut Self {
        self.flags = value;
        self
    }
    ///Sets the raw value of [`Self::queue_family_index`]
    pub fn set_queue_family_index(&mut self, value: u32) -> &mut Self {
        self.queue_family_index = value;
        self
    }
    ///Sets the raw value of [`Self::queue_count`]
    pub fn set_queue_count(&mut self, value: u32) -> &mut Self {
        self.queue_count = value;
        self
    }
    ///Sets the raw value of [`Self::queue_priorities`]
    pub fn set_queue_priorities(&mut self, value: &'lt [f32]) -> &mut Self {
        let len_ = value.len() as u32;
        let len_ = len_;
        self.queue_priorities = value.as_ptr();
        self.queue_count = len_;
        self
    }
}
///[VkDeviceCreateInfo](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceCreateInfo.html) - Structure specifying parameters of a newly created device
///# C Specifications
///The [`DeviceCreateInfo`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkDeviceCreateInfo {
///    VkStructureType                    sType;
///    const void*                        pNext;
///    VkDeviceCreateFlags                flags;
///    uint32_t                           queueCreateInfoCount;
///    const VkDeviceQueueCreateInfo*     pQueueCreateInfos;
///    uint32_t                           enabledLayerCount;
///    const char* const*                 ppEnabledLayerNames;
///    uint32_t                           enabledExtensionCount;
///    const char* const*                 ppEnabledExtensionNames;
///    const VkPhysicalDeviceFeatures*    pEnabledFeatures;
///} VkDeviceCreateInfo;
///```
///# Members
/// - [`s_type`] is the type of this structure.
/// - [`p_next`] is `NULL` or a pointer to a structure extending this structure.
/// - [`flags`] is reserved for future use.
/// - [`queue_create_info_count`] is the unsigned integer size of the [`queue_create_infos`] array. Refer to the [Queue Creation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#devsandqueues-queue-creation) section below for further details.
/// - [`queue_create_infos`] is a pointer to an array of [`DeviceQueueCreateInfo`] structures describing the queues that are requested to be created along with the logical device. Refer to the [Queue Creation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#devsandqueues-queue-creation) section below for further details.
/// - [`enabled_layer_count`] is deprecated and ignored.
/// - [`pp_enabled_layer_names`] is deprecated and ignored. See [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#extendingvulkan-layers-devicelayerdeprecation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#extendingvulkan-layers-devicelayerdeprecation).
/// - [`enabled_extension_count`] is the number of device extensions to enable.
/// - [`pp_enabled_extension_names`] is a pointer to an array of [`enabled_extension_count`] null-terminated UTF-8 strings containing the names of extensions to enable for the created device. See the [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#extendingvulkan-extensions](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#extendingvulkan-extensions) section for further details.
/// - [`enabled_features`] is `NULL` or a pointer to a [`PhysicalDeviceFeatures`] structure containing boolean indicators of all the features to be enabled. Refer to the [Features](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features) section for further details.
///# Description
///## Valid Usage
/// - The `queueFamilyIndex` member of each element of [`queue_create_infos`] **must**  be unique
///   within [`queue_create_infos`], except that two members can share the same `queueFamilyIndex`
///   if one is a protected-capable queue and one is not a protected-capable queue
/// - If the [`p_next`] chain includes a [`PhysicalDeviceFeatures2`] structure, then
///   [`enabled_features`] **must**  be `NULL`
/// - [`pp_enabled_extension_names`] **must**  not contain `[`VK_AMD_negative_viewport_height`]`
/// - [`pp_enabled_extension_names`] **must**  not contain both `[`VK_KHR_buffer_device_address`]`
///   and `[`VK_EXT_buffer_device_address`]`
/// - if the [`p_next`] chain includes a [`PhysicalDeviceVulkan12Features`] structure and
///   [`PhysicalDeviceVulkan12Features::buffer_device_address`] is [`TRUE`],
///   [`pp_enabled_extension_names`] **must**  not contain `[`VK_EXT_buffer_device_address`]`
/// - If the [`p_next`] chain includes a [`PhysicalDeviceVulkan11Features`] structure, then it
///   **must**  not include a [`PhysicalDevice16BitStorageFeatures`],
///   [`PhysicalDeviceMultiviewFeatures`], [`PhysicalDeviceVariablePointersFeatures`],
///   [`PhysicalDeviceProtectedMemoryFeatures`], [`PhysicalDeviceSamplerYcbcrConversionFeatures`],
///   or [`PhysicalDeviceShaderDrawParametersFeatures`] structure
/// - If the [`p_next`] chain includes a [`PhysicalDeviceVulkan12Features`] structure, then it
///   **must**  not include a [`PhysicalDevice8BitStorageFeatures`],
///   [`PhysicalDeviceShaderAtomicInt64Features`], [`PhysicalDeviceShaderFloat16Int8Features`],
///   [`PhysicalDeviceDescriptorIndexingFeatures`], [`PhysicalDeviceScalarBlockLayoutFeatures`],
///   [`PhysicalDeviceImagelessFramebufferFeatures`],
///   [`PhysicalDeviceUniformBufferStandardLayoutFeatures`],
///   [`PhysicalDeviceShaderSubgroupExtendedTypesFeatures`],
///   [`PhysicalDeviceSeparateDepthStencilLayoutsFeatures`],
///   [`PhysicalDeviceHostQueryResetFeatures`], [`PhysicalDeviceTimelineSemaphoreFeatures`],
///   [`PhysicalDeviceBufferDeviceAddressFeatures`], or [`PhysicalDeviceVulkanMemoryModelFeatures`]
///   structure
/// - If [`pp_enabled_extension_names`] contains `"VK_KHR_shader_draw_parameters"` and the
///   [`p_next`] chain includes a [`PhysicalDeviceVulkan11Features`] structure, then
///   [`PhysicalDeviceVulkan11Features::shader_draw_parameters`] **must**  be [`TRUE`]
/// - If [`pp_enabled_extension_names`] contains `"VK_KHR_draw_indirect_count"` and the [`p_next`]
///   chain includes a [`PhysicalDeviceVulkan12Features`] structure, then
///   [`PhysicalDeviceVulkan12Features::draw_indirect_count`] **must**  be [`TRUE`]
/// - If [`pp_enabled_extension_names`] contains `"VK_KHR_sampler_mirror_clamp_to_edge"` and the
///   [`p_next`] chain includes a [`PhysicalDeviceVulkan12Features`] structure, then
///   [`PhysicalDeviceVulkan12Features::sampler_mirror_clamp_to_edge`] **must**  be [`TRUE`]
/// - If [`pp_enabled_extension_names`] contains `"VK_EXT_descriptor_indexing"` and the [`p_next`]
///   chain includes a [`PhysicalDeviceVulkan12Features`] structure, then
///   [`PhysicalDeviceVulkan12Features::descriptor_indexing`] **must**  be [`TRUE`]
/// - If [`pp_enabled_extension_names`] contains `"VK_EXT_sampler_filter_minmax"` and the [`p_next`]
///   chain includes a [`PhysicalDeviceVulkan12Features`] structure, then
///   [`PhysicalDeviceVulkan12Features::sampler_filter_minmax`] **must**  be [`TRUE`]
/// - If [`pp_enabled_extension_names`] contains `"VK_EXT_shader_viewport_index_layer"` and the
///   [`p_next`] chain includes a [`PhysicalDeviceVulkan12Features`] structure, then
///   [`PhysicalDeviceVulkan12Features::shader_output_viewport_index`] and
///   [`PhysicalDeviceVulkan12Features::shader_output_layer`] **must**  both be [`TRUE`]
/// - If the [`p_next`] chain includes a [`PhysicalDeviceVulkan13Features`] structure, then it
///   **must**  not include a [`PhysicalDeviceDynamicRenderingFeatures`],
///   [`PhysicalDeviceImageRobustnessFeatures`], [`PhysicalDeviceInlineUniformBlockFeatures`],
///   [`PhysicalDeviceMaintenance4Features`],
///   [`PhysicalDevicePipelineCreationCacheControlFeatures`], [`PhysicalDevicePrivateDataFeatures`],
///   [`PhysicalDeviceShaderDemoteToHelperInvocationFeatures`],
///   [`PhysicalDeviceShaderIntegerDotProductFeatures`],
///   [`PhysicalDeviceShaderTerminateInvocationFeatures`],
///   [`PhysicalDeviceSubgroupSizeControlFeatures`], [`PhysicalDeviceSynchronization2Features`],
///   [`PhysicalDeviceTextureCompressionAstchdrFeatures`], or
///   [`PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures`] structure
/// - If the `[`VK_KHR_portability_subset`]` extension is included in `pProperties` of
///   [`EnumerateDeviceExtensionProperties`], [`pp_enabled_extension_names`] **must**  include
///   `"VK_KHR_portability_subset"`
/// - If [`shadingRateImage`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-shadingRateImage)
///   is enabled, [`pipelineFragmentShadingRate`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-pipelineFragmentShadingRate)
///   **must**  not be enabled
/// - If [`shadingRateImage`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-shadingRateImage)
///   is enabled, [`primitiveFragmentShadingRate`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-primitiveFragmentShadingRate)
///   **must**  not be enabled
/// - If [`shadingRateImage`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-shadingRateImage)
///   is enabled, [`attachmentFragmentShadingRate`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-attachmentFragmentShadingRate)
///   **must**  not be enabled
/// - If [`fragmentDensityMap`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-fragmentDensityMap)
///   is enabled, [`pipelineFragmentShadingRate`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-pipelineFragmentShadingRate)
///   **must**  not be enabled
/// - If [`fragmentDensityMap`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-fragmentDensityMap)
///   is enabled, [`primitiveFragmentShadingRate`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-primitiveFragmentShadingRate)
///   **must**  not be enabled
/// - If [`fragmentDensityMap`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-fragmentDensityMap)
///   is enabled, [`attachmentFragmentShadingRate`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-attachmentFragmentShadingRate)
///   **must**  not be enabled
/// - If [`sparseImageInt64Atomics`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-sparseImageInt64Atomics)
///   is enabled, [`shaderImageInt64Atomics`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-shaderImageInt64Atomics)
///   **must**  be enabled
/// - If [`sparseImageFloat32Atomics`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-sparseImageFloat32Atomics)
///   is enabled, [`shaderImageFloat32Atomics`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-shaderImageFloat32Atomics)
///   **must**  be enabled
/// - If [`sparseImageFloat32AtomicAdd`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-sparseImageFloat32AtomicAdd)
///   is enabled, [`shaderImageFloat32AtomicAdd`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-shaderImageFloat32AtomicAdd)
///   **must**  be enabled
/// - If [`sparseImageFloat32AtomicMinMax`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-sparseImageFloat32AtomicMinMax)
///   is enabled, [`shaderImageFloat32AtomicMinMax`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-shaderImageFloat32AtomicMinMax)
///   **must**  be enabled
///
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be `VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO`
/// - Each [`p_next`] member of any structure (including this one) in the [`p_next`] chain  **must**
///   be either `NULL` or a pointer to a valid instance of
///   [`DeviceDeviceMemoryReportCreateInfoEXT`], [`DeviceDiagnosticsConfigCreateInfoNV`],
///   [`DeviceGroupDeviceCreateInfo`], [`DeviceMemoryOverallocationCreateInfoAMD`],
///   [`DevicePrivateDataCreateInfo`], [`PhysicalDevice16BitStorageFeatures`],
///   [`PhysicalDevice4444FormatsFeaturesEXT`], [`PhysicalDevice8BitStorageFeatures`],
///   [`PhysicalDeviceAstcDecodeFeaturesEXT`], [`PhysicalDeviceAccelerationStructureFeaturesKHR`],
///   [`PhysicalDeviceBlendOperationAdvancedFeaturesEXT`],
///   [`PhysicalDeviceBorderColorSwizzleFeaturesEXT`],
///   [`PhysicalDeviceBufferDeviceAddressFeatures`],
///   [`PhysicalDeviceBufferDeviceAddressFeaturesEXT`], [`PhysicalDeviceCoherentMemoryFeaturesAMD`],
///   [`PhysicalDeviceColorWriteEnableFeaturesEXT`],
///   [`PhysicalDeviceComputeShaderDerivativesFeaturesNV`],
///   [`PhysicalDeviceConditionalRenderingFeaturesEXT`],
///   [`PhysicalDeviceCooperativeMatrixFeaturesNV`], [`PhysicalDeviceCornerSampledImageFeaturesNV`],
///   [`PhysicalDeviceCoverageReductionModeFeaturesNV`],
///   [`PhysicalDeviceCustomBorderColorFeaturesEXT`],
///   [`PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV`],
///   [`PhysicalDeviceDepthClipControlFeaturesEXT`], [`PhysicalDeviceDepthClipEnableFeaturesEXT`],
///   [`PhysicalDeviceDescriptorIndexingFeatures`],
///   [`PhysicalDeviceDescriptorSetHostMappingFeaturesVALVE`],
///   [`PhysicalDeviceDeviceGeneratedCommandsFeaturesNV`],
///   [`PhysicalDeviceDeviceMemoryReportFeaturesEXT`],
///   [`PhysicalDeviceDiagnosticsConfigFeaturesNV`], [`PhysicalDeviceDynamicRenderingFeatures`],
///   [`PhysicalDeviceExclusiveScissorFeaturesNV`],
///   [`PhysicalDeviceExtendedDynamicState2FeaturesEXT`],
///   [`PhysicalDeviceExtendedDynamicStateFeaturesEXT`],
///   [`PhysicalDeviceExternalMemoryRdmaFeaturesNV`], [`PhysicalDeviceFeatures2`],
///   [`PhysicalDeviceFragmentDensityMap2FeaturesEXT`],
///   [`PhysicalDeviceFragmentDensityMapFeaturesEXT`],
///   [`PhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM`],
///   [`PhysicalDeviceFragmentShaderBarycentricFeaturesNV`],
///   [`PhysicalDeviceFragmentShaderInterlockFeaturesEXT`],
///   [`PhysicalDeviceFragmentShadingRateEnumsFeaturesNV`],
///   [`PhysicalDeviceFragmentShadingRateFeaturesKHR`],
///   [`PhysicalDeviceGlobalPriorityQueryFeaturesKHR`], [`PhysicalDeviceHostQueryResetFeatures`],
///   [`PhysicalDeviceImageRobustnessFeatures`], [`PhysicalDeviceImageViewMinLodFeaturesEXT`],
///   [`PhysicalDeviceImagelessFramebufferFeatures`], [`PhysicalDeviceIndexTypeUint8FeaturesEXT`],
///   [`PhysicalDeviceInheritedViewportScissorFeaturesNV`],
///   [`PhysicalDeviceInlineUniformBlockFeatures`], [`PhysicalDeviceInvocationMaskFeaturesHUAWEI`],
///   [`PhysicalDeviceLineRasterizationFeaturesEXT`],
///   [`PhysicalDeviceLinearColorAttachmentFeaturesNV`], [`PhysicalDeviceMaintenance4Features`],
///   [`PhysicalDeviceMemoryPriorityFeaturesEXT`], [`PhysicalDeviceMeshShaderFeaturesNV`],
///   [`PhysicalDeviceMultiDrawFeaturesEXT`], [`PhysicalDeviceMultiviewFeatures`],
///   [`PhysicalDeviceMutableDescriptorTypeFeaturesVALVE`],
///   [`PhysicalDevicePageableDeviceLocalMemoryFeaturesEXT`],
///   [`PhysicalDevicePerformanceQueryFeaturesKHR`],
///   [`PhysicalDevicePipelineCreationCacheControlFeatures`],
///   [`PhysicalDevicePipelineExecutablePropertiesFeaturesKHR`],
///   [`PhysicalDevicePortabilitySubsetFeaturesKHR`], [`PhysicalDevicePresentIdFeaturesKHR`],
///   [`PhysicalDevicePresentWaitFeaturesKHR`],
///   [`PhysicalDevicePrimitiveTopologyListRestartFeaturesEXT`],
///   [`PhysicalDevicePrivateDataFeatures`], [`PhysicalDeviceProtectedMemoryFeatures`],
///   [`PhysicalDeviceProvokingVertexFeaturesEXT`], [`PhysicalDeviceRgba10X6FormatsFeaturesEXT`],
///   [`PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesARM`],
///   [`PhysicalDeviceRayQueryFeaturesKHR`], [`PhysicalDeviceRayTracingMotionBlurFeaturesNV`],
///   [`PhysicalDeviceRayTracingPipelineFeaturesKHR`],
///   [`PhysicalDeviceRepresentativeFragmentTestFeaturesNV`],
///   [`PhysicalDeviceRobustness2FeaturesEXT`], [`PhysicalDeviceSamplerYcbcrConversionFeatures`],
///   [`PhysicalDeviceScalarBlockLayoutFeatures`],
///   [`PhysicalDeviceSeparateDepthStencilLayoutsFeatures`],
///   [`PhysicalDeviceShaderAtomicFloat2FeaturesEXT`],
///   [`PhysicalDeviceShaderAtomicFloatFeaturesEXT`], [`PhysicalDeviceShaderAtomicInt64Features`],
///   [`PhysicalDeviceShaderClockFeaturesKHR`],
///   [`PhysicalDeviceShaderDemoteToHelperInvocationFeatures`],
///   [`PhysicalDeviceShaderDrawParametersFeatures`], [`PhysicalDeviceShaderFloat16Int8Features`],
///   [`PhysicalDeviceShaderImageAtomicInt64FeaturesEXT`],
///   [`PhysicalDeviceShaderImageFootprintFeaturesNV`],
///   [`PhysicalDeviceShaderIntegerDotProductFeatures`],
///   [`PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL`],
///   [`PhysicalDeviceShaderSmBuiltinsFeaturesNV`],
///   [`PhysicalDeviceShaderSubgroupExtendedTypesFeatures`],
///   [`PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR`],
///   [`PhysicalDeviceShaderTerminateInvocationFeatures`],
///   [`PhysicalDeviceShadingRateImageFeaturesNV`], [`PhysicalDeviceSubgroupSizeControlFeatures`],
///   [`PhysicalDeviceSubpassShadingFeaturesHUAWEI`], [`PhysicalDeviceSynchronization2Features`],
///   [`PhysicalDeviceTexelBufferAlignmentFeaturesEXT`],
///   [`PhysicalDeviceTextureCompressionAstchdrFeatures`],
///   [`PhysicalDeviceTimelineSemaphoreFeatures`], [`PhysicalDeviceTransformFeedbackFeaturesEXT`],
///   [`PhysicalDeviceUniformBufferStandardLayoutFeatures`],
///   [`PhysicalDeviceVariablePointersFeatures`],
///   [`PhysicalDeviceVertexAttributeDivisorFeaturesEXT`],
///   [`PhysicalDeviceVertexInputDynamicStateFeaturesEXT`], [`PhysicalDeviceVulkan11Features`],
///   [`PhysicalDeviceVulkan12Features`], [`PhysicalDeviceVulkan13Features`],
///   [`PhysicalDeviceVulkanMemoryModelFeatures`],
///   [`PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR`],
///   [`PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT`],
///   [`PhysicalDeviceYcbcrImageArraysFeaturesEXT`], or
///   [`PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures`]
/// - The [`s_type`] value of each struct in the [`p_next`] chain  **must**  be unique, with the
///   exception of structures of type [`DeviceDeviceMemoryReportCreateInfoEXT`] or
///   [`DevicePrivateDataCreateInfo`]
/// - [`flags`] **must**  be `0`
/// - [`queue_create_infos`] **must**  be a valid pointer to an array of [`queue_create_info_count`]
///   valid [`DeviceQueueCreateInfo`] structures
/// - If [`enabled_layer_count`] is not `0`, [`pp_enabled_layer_names`] **must**  be a valid pointer
///   to an array of [`enabled_layer_count`] null-terminated UTF-8 strings
/// - If [`enabled_extension_count`] is not `0`, [`pp_enabled_extension_names`] **must**  be a valid
///   pointer to an array of [`enabled_extension_count`] null-terminated UTF-8 strings
/// - If [`enabled_features`] is not `NULL`, [`enabled_features`] **must**  be a valid pointer to a
///   valid [`PhysicalDeviceFeatures`] structure
/// - [`queue_create_info_count`] **must**  be greater than `0`
///# Related
/// - [`crate::vulkan1_0`]
/// - [`DeviceCreateFlags`]
/// - [`DeviceQueueCreateInfo`]
/// - [`PhysicalDeviceFeatures`]
/// - [`StructureType`]
/// - [`CreateDevice`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[repr(C)]
pub struct DeviceCreateInfo<'lt> {
    _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] is the type of this structure.
    s_type: StructureType,
    ///[`p_next`] is `NULL` or a pointer to a structure extending this
    ///structure.
    p_next: *const BaseInStructure<'lt>,
    ///[`flags`] is reserved for future use.
    flags: DeviceCreateFlags,
    ///[`queue_create_info_count`] is the unsigned integer size of the
    ///[`queue_create_infos`] array.
    ///Refer to the [Queue Creation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#devsandqueues-queue-creation) section
    ///below for further details.
    queue_create_info_count: u32,
    ///[`queue_create_infos`] is a pointer to an array of
    ///[`DeviceQueueCreateInfo`] structures describing the queues that are
    ///requested to be created along with the logical device.
    ///Refer to the [Queue Creation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#devsandqueues-queue-creation) section
    ///below for further details.
    queue_create_infos: *const DeviceQueueCreateInfo<'lt>,
    ///[`enabled_layer_count`] is deprecated and ignored.
    enabled_layer_count: u32,
    ///[`pp_enabled_layer_names`] is deprecated and ignored.
    ///See [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#extendingvulkan-layers-devicelayerdeprecation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#extendingvulkan-layers-devicelayerdeprecation).
    pp_enabled_layer_names: *const &'lt CStr,
    ///[`enabled_extension_count`] is the number of device extensions to
    ///enable.
    enabled_extension_count: u32,
    ///[`pp_enabled_extension_names`] is a pointer to an array of
    ///[`enabled_extension_count`] null-terminated UTF-8 strings containing the
    ///names of extensions to enable for the created device.
    ///See the [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#extendingvulkan-extensions](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#extendingvulkan-extensions) section for further details.
    pp_enabled_extension_names: *const &'lt CStr,
    ///[`enabled_features`] is `NULL` or a pointer to a
    ///[`PhysicalDeviceFeatures`] structure containing boolean indicators
    ///of all the features to be enabled.
    ///Refer to the [Features](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features) section for further details.
    enabled_features: *const PhysicalDeviceFeatures,
}
impl<'lt> Default for DeviceCreateInfo<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: Default::default(),
            p_next: std::ptr::null(),
            flags: Default::default(),
            queue_create_info_count: 0,
            queue_create_infos: std::ptr::null(),
            enabled_layer_count: 0,
            pp_enabled_layer_names: std::ptr::null(),
            enabled_extension_count: 0,
            pp_enabled_extension_names: std::ptr::null(),
            enabled_features: std::ptr::null(),
        }
    }
}
impl<'lt> DeviceCreateInfo<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *const BaseInStructure<'lt> {
        self.p_next
    }
    ///Gets the raw value of [`Self::queue_create_infos`]
    pub fn queue_create_infos_raw(&self) -> *const DeviceQueueCreateInfo<'lt> {
        self.queue_create_infos
    }
    ///Gets the raw value of [`Self::pp_enabled_layer_names`]
    pub fn pp_enabled_layer_names_raw(&self) -> *const &'lt CStr {
        self.pp_enabled_layer_names
    }
    ///Gets the raw value of [`Self::pp_enabled_extension_names`]
    pub fn pp_enabled_extension_names_raw(&self) -> *const &'lt CStr {
        self.pp_enabled_extension_names
    }
    ///Gets the raw value of [`Self::enabled_features`]
    pub fn enabled_features_raw(&self) -> *const PhysicalDeviceFeatures {
        self.enabled_features
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *const BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::queue_create_infos`]
    pub fn set_queue_create_infos_raw(&mut self, value: *const DeviceQueueCreateInfo<'lt>) -> &mut Self {
        self.queue_create_infos = value;
        self
    }
    ///Sets the raw value of [`Self::pp_enabled_layer_names`]
    pub fn set_pp_enabled_layer_names_raw(&mut self, value: *const &'lt CStr) -> &mut Self {
        self.pp_enabled_layer_names = value;
        self
    }
    ///Sets the raw value of [`Self::pp_enabled_extension_names`]
    pub fn set_pp_enabled_extension_names_raw(&mut self, value: *const &'lt CStr) -> &mut Self {
        self.pp_enabled_extension_names = value;
        self
    }
    ///Sets the raw value of [`Self::enabled_features`]
    pub fn set_enabled_features_raw(&mut self, value: *const PhysicalDeviceFeatures) -> &mut Self {
        self.enabled_features = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseInStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::flags`]
    pub fn flags(&self) -> DeviceCreateFlags {
        self.flags
    }
    ///Gets the value of [`Self::queue_create_info_count`]
    pub fn queue_create_info_count(&self) -> u32 {
        self.queue_create_info_count
    }
    ///Gets the value of [`Self::queue_create_infos`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn queue_create_infos(&self) -> &[DeviceQueueCreateInfo<'lt>] {
        std::slice::from_raw_parts(self.queue_create_infos, self.queue_create_info_count as usize)
    }
    ///Gets the value of [`Self::enabled_layer_count`]
    pub fn enabled_layer_count(&self) -> u32 {
        self.enabled_layer_count
    }
    ///Gets the value of [`Self::pp_enabled_layer_names`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn pp_enabled_layer_names(&self) -> &[&'lt CStr] {
        std::slice::from_raw_parts(self.pp_enabled_layer_names, self.enabled_layer_count as usize)
    }
    ///Gets the value of [`Self::enabled_extension_count`]
    pub fn enabled_extension_count(&self) -> u32 {
        self.enabled_extension_count
    }
    ///Gets the value of [`Self::pp_enabled_extension_names`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn pp_enabled_extension_names(&self) -> &[&'lt CStr] {
        std::slice::from_raw_parts(self.pp_enabled_extension_names, self.enabled_extension_count as usize)
    }
    ///Gets the value of [`Self::enabled_features`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn enabled_features(&self) -> &PhysicalDeviceFeatures {
        &*self.enabled_features
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::flags`]
    pub fn flags_mut(&mut self) -> &mut DeviceCreateFlags {
        &mut self.flags
    }
    ///Gets a mutable reference to the value of [`Self::queue_create_info_count`]
    pub fn queue_create_info_count_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::enabled_layer_count`]
    pub fn enabled_layer_count_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::enabled_extension_count`]
    pub fn enabled_extension_count_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Sets the raw value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the raw value of [`Self::flags`]
    pub fn set_flags(&mut self, value: crate::vulkan1_0::DeviceCreateFlags) -> &mut Self {
        self.flags = value;
        self
    }
    ///Sets the raw value of [`Self::queue_create_info_count`]
    pub fn set_queue_create_info_count(&mut self, value: u32) -> &mut Self {
        self.queue_create_info_count = value;
        self
    }
    ///Sets the raw value of [`Self::queue_create_infos`]
    pub fn set_queue_create_infos(&mut self, value: &'lt [crate::vulkan1_0::DeviceQueueCreateInfo<'lt>]) -> &mut Self {
        let len_ = value.len() as u32;
        let len_ = len_;
        self.queue_create_infos = value.as_ptr();
        self.queue_create_info_count = len_;
        self
    }
    ///Sets the raw value of [`Self::enabled_layer_count`]
    pub fn set_enabled_layer_count(&mut self, value: u32) -> &mut Self {
        self.enabled_layer_count = value;
        self
    }
    ///Sets the raw value of [`Self::pp_enabled_layer_names`]
    pub fn set_pp_enabled_layer_names(&mut self, value: &'lt [&'lt std::ffi::CStr]) -> &mut Self {
        let len_ = value.len() as u32;
        let len_ = len_;
        self.pp_enabled_layer_names = value.as_ptr();
        self.enabled_layer_count = len_;
        self
    }
    ///Sets the raw value of [`Self::enabled_extension_count`]
    pub fn set_enabled_extension_count(&mut self, value: u32) -> &mut Self {
        self.enabled_extension_count = value;
        self
    }
    ///Sets the raw value of [`Self::pp_enabled_extension_names`]
    pub fn set_pp_enabled_extension_names(&mut self, value: &'lt [&'lt std::ffi::CStr]) -> &mut Self {
        let len_ = value.len() as u32;
        let len_ = len_;
        self.pp_enabled_extension_names = value.as_ptr();
        self.enabled_extension_count = len_;
        self
    }
    ///Sets the raw value of [`Self::enabled_features`]
    pub fn set_enabled_features(&mut self, value: &'lt crate::vulkan1_0::PhysicalDeviceFeatures) -> &mut Self {
        self.enabled_features = value as *const _;
        self
    }
}
///[VkInstanceCreateInfo](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkInstanceCreateInfo.html) - Structure specifying parameters of a newly created instance
///# C Specifications
///The [`InstanceCreateInfo`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkInstanceCreateInfo {
///    VkStructureType             sType;
///    const void*                 pNext;
///    VkInstanceCreateFlags       flags;
///    const VkApplicationInfo*    pApplicationInfo;
///    uint32_t                    enabledLayerCount;
///    const char* const*          ppEnabledLayerNames;
///    uint32_t                    enabledExtensionCount;
///    const char* const*          ppEnabledExtensionNames;
///} VkInstanceCreateInfo;
///```
///# Members
/// - [`s_type`] is the type of this structure.
/// - [`p_next`] is `NULL` or a pointer to a structure extending this structure.
/// - [`flags`] is reserved for future use.
/// - [`application_info`] is `NULL` or a pointer to a [`ApplicationInfo`] structure. If not `NULL`,
///   this information helps implementations recognize behavior inherent to classes of applications.
///   [`ApplicationInfo`] is defined in detail below.
/// - [`enabled_layer_count`] is the number of global layers to enable.
/// - [`pp_enabled_layer_names`] is a pointer to an array of [`enabled_layer_count`] null-terminated
///   UTF-8 strings containing the names of layers to enable for the created instance. The layers are
///   loaded in the order they are listed in this array, with the first array element being the closest
///   to the application, and the last array element being the closest to the driver. See the [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#extendingvulkan-layers](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#extendingvulkan-layers)
///   section for further details.
/// - [`enabled_extension_count`] is the number of global extensions to enable.
/// - [`pp_enabled_extension_names`] is a pointer to an array of [`enabled_extension_count`]
///   null-terminated UTF-8 strings containing the names of extensions to enable.
///# Description
///To capture events that occur while creating or destroying an instance, an
///application can link a
///[`DebugReportCallbackCreateInfoEXT`] structure
///or a
///[`DebugUtilsMessengerCreateInfoEXT`] structure
///to the [`p_next`] element of the [`InstanceCreateInfo`] structure given
///to [`CreateInstance`].
///This callback is only valid for the duration of the [`CreateInstance`]
///and the [`DestroyInstance`] call.
///Use
///[`CreateDebugReportCallbackEXT`]
///or
///[`CreateDebugUtilsMessengerEXT`]
///to create persistent callback objects.
///## Valid Usage
/// - If the [`p_next`] chain of [`InstanceCreateInfo`] includes a
///   [`DebugReportCallbackCreateInfoEXT`] structure, the list of enabled extensions in
///   [`pp_enabled_extension_names`] **must**  contain [`VK_EXT_debug_report`]
/// - If the [`p_next`] chain of [`InstanceCreateInfo`] includes a
///   [`DebugUtilsMessengerCreateInfoEXT`] structure, the list of enabled extensions in
///   [`pp_enabled_extension_names`] **must**  contain [`VK_EXT_debug_utils`]
///
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be `VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO`
/// - Each [`p_next`] member of any structure (including this one) in the [`p_next`] chain  **must**
///   be either `NULL` or a pointer to a valid instance of [`DebugReportCallbackCreateInfoEXT`],
///   [`DebugUtilsMessengerCreateInfoEXT`], [`ValidationFeaturesEXT`], or [`ValidationFlagsEXT`]
/// - The [`s_type`] value of each struct in the [`p_next`] chain  **must**  be unique, with the
///   exception of structures of type [`DebugUtilsMessengerCreateInfoEXT`]
/// - [`flags`] **must**  be `0`
/// - If [`application_info`] is not `NULL`, [`application_info`] **must**  be a valid pointer to a
///   valid [`ApplicationInfo`] structure
/// - If [`enabled_layer_count`] is not `0`, [`pp_enabled_layer_names`] **must**  be a valid pointer
///   to an array of [`enabled_layer_count`] null-terminated UTF-8 strings
/// - If [`enabled_extension_count`] is not `0`, [`pp_enabled_extension_names`] **must**  be a valid
///   pointer to an array of [`enabled_extension_count`] null-terminated UTF-8 strings
///# Related
/// - [`crate::vulkan1_0`]
/// - [`ApplicationInfo`]
/// - [`InstanceCreateFlags`]
/// - [`StructureType`]
/// - [`CreateInstance`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[repr(C)]
pub struct InstanceCreateInfo<'lt> {
    _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] is the type of this structure.
    s_type: StructureType,
    ///[`p_next`] is `NULL` or a pointer to a structure extending this
    ///structure.
    p_next: *const BaseInStructure<'lt>,
    ///[`flags`] is reserved for future use.
    flags: InstanceCreateFlags,
    ///[`application_info`] is `NULL` or a pointer to a
    ///[`ApplicationInfo`] structure.
    ///If not `NULL`, this information helps implementations recognize behavior
    ///inherent to classes of applications.
    ///[`ApplicationInfo`] is defined in detail below.
    application_info: *const ApplicationInfo<'lt>,
    ///[`enabled_layer_count`] is the number of global layers to enable.
    enabled_layer_count: u32,
    ///[`pp_enabled_layer_names`] is a pointer to an array of
    ///[`enabled_layer_count`] null-terminated UTF-8 strings containing the
    ///names of layers to enable for the created instance.
    ///The layers are loaded in the order they are listed in this array, with
    ///the first array element being the closest to the application, and the
    ///last array element being the closest to the driver.
    ///See the [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#extendingvulkan-layers](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#extendingvulkan-layers) section for further details.
    pp_enabled_layer_names: *const &'lt CStr,
    ///[`enabled_extension_count`] is the number of global extensions to
    ///enable.
    enabled_extension_count: u32,
    ///[`pp_enabled_extension_names`] is a pointer to an array of
    ///[`enabled_extension_count`] null-terminated UTF-8 strings containing the
    ///names of extensions to enable.
    pp_enabled_extension_names: *const &'lt CStr,
}
impl<'lt> Default for InstanceCreateInfo<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: Default::default(),
            p_next: std::ptr::null(),
            flags: Default::default(),
            application_info: std::ptr::null(),
            enabled_layer_count: 0,
            pp_enabled_layer_names: std::ptr::null(),
            enabled_extension_count: 0,
            pp_enabled_extension_names: std::ptr::null(),
        }
    }
}
impl<'lt> InstanceCreateInfo<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *const BaseInStructure<'lt> {
        self.p_next
    }
    ///Gets the raw value of [`Self::application_info`]
    pub fn application_info_raw(&self) -> *const ApplicationInfo<'lt> {
        self.application_info
    }
    ///Gets the raw value of [`Self::pp_enabled_layer_names`]
    pub fn pp_enabled_layer_names_raw(&self) -> *const &'lt CStr {
        self.pp_enabled_layer_names
    }
    ///Gets the raw value of [`Self::pp_enabled_extension_names`]
    pub fn pp_enabled_extension_names_raw(&self) -> *const &'lt CStr {
        self.pp_enabled_extension_names
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *const BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::application_info`]
    pub fn set_application_info_raw(&mut self, value: *const ApplicationInfo<'lt>) -> &mut Self {
        self.application_info = value;
        self
    }
    ///Sets the raw value of [`Self::pp_enabled_layer_names`]
    pub fn set_pp_enabled_layer_names_raw(&mut self, value: *const &'lt CStr) -> &mut Self {
        self.pp_enabled_layer_names = value;
        self
    }
    ///Sets the raw value of [`Self::pp_enabled_extension_names`]
    pub fn set_pp_enabled_extension_names_raw(&mut self, value: *const &'lt CStr) -> &mut Self {
        self.pp_enabled_extension_names = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseInStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::flags`]
    pub fn flags(&self) -> InstanceCreateFlags {
        self.flags
    }
    ///Gets the value of [`Self::application_info`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn application_info(&self) -> &ApplicationInfo<'lt> {
        &*self.application_info
    }
    ///Gets the value of [`Self::enabled_layer_count`]
    pub fn enabled_layer_count(&self) -> u32 {
        self.enabled_layer_count
    }
    ///Gets the value of [`Self::pp_enabled_layer_names`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn pp_enabled_layer_names(&self) -> &[&'lt CStr] {
        std::slice::from_raw_parts(self.pp_enabled_layer_names, self.enabled_layer_count as usize)
    }
    ///Gets the value of [`Self::enabled_extension_count`]
    pub fn enabled_extension_count(&self) -> u32 {
        self.enabled_extension_count
    }
    ///Gets the value of [`Self::pp_enabled_extension_names`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn pp_enabled_extension_names(&self) -> &[&'lt CStr] {
        std::slice::from_raw_parts(self.pp_enabled_extension_names, self.enabled_extension_count as usize)
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::flags`]
    pub fn flags_mut(&mut self) -> &mut InstanceCreateFlags {
        &mut self.flags
    }
    ///Gets a mutable reference to the value of [`Self::enabled_layer_count`]
    pub fn enabled_layer_count_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::enabled_extension_count`]
    pub fn enabled_extension_count_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Sets the raw value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the raw value of [`Self::flags`]
    pub fn set_flags(&mut self, value: crate::vulkan1_0::InstanceCreateFlags) -> &mut Self {
        self.flags = value;
        self
    }
    ///Sets the raw value of [`Self::application_info`]
    pub fn set_application_info(&mut self, value: &'lt crate::vulkan1_0::ApplicationInfo<'lt>) -> &mut Self {
        self.application_info = value as *const _;
        self
    }
    ///Sets the raw value of [`Self::enabled_layer_count`]
    pub fn set_enabled_layer_count(&mut self, value: u32) -> &mut Self {
        self.enabled_layer_count = value;
        self
    }
    ///Sets the raw value of [`Self::pp_enabled_layer_names`]
    pub fn set_pp_enabled_layer_names(&mut self, value: &'lt [&'lt std::ffi::CStr]) -> &mut Self {
        let len_ = value.len() as u32;
        let len_ = len_;
        self.pp_enabled_layer_names = value.as_ptr();
        self.enabled_layer_count = len_;
        self
    }
    ///Sets the raw value of [`Self::enabled_extension_count`]
    pub fn set_enabled_extension_count(&mut self, value: u32) -> &mut Self {
        self.enabled_extension_count = value;
        self
    }
    ///Sets the raw value of [`Self::pp_enabled_extension_names`]
    pub fn set_pp_enabled_extension_names(&mut self, value: &'lt [&'lt std::ffi::CStr]) -> &mut Self {
        let len_ = value.len() as u32;
        let len_ = len_;
        self.pp_enabled_extension_names = value.as_ptr();
        self.enabled_extension_count = len_;
        self
    }
}
///[VkQueueFamilyProperties](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkQueueFamilyProperties.html) - Structure providing information about a queue family
///# C Specifications
///The [`QueueFamilyProperties`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkQueueFamilyProperties {
///    VkQueueFlags    queueFlags;
///    uint32_t        queueCount;
///    uint32_t        timestampValidBits;
///    VkExtent3D      minImageTransferGranularity;
///} VkQueueFamilyProperties;
///```
///# Members
/// - [`queue_flags`] is a bitmask of [`QueueFlagBits`] indicating capabilities of the queues in
///   this queue family.
/// - [`queue_count`] is the unsigned integer count of queues in this queue family. Each queue
///   family  **must**  support at least one queue.
/// - [`timestamp_valid_bits`] is the unsigned integer count of meaningful bits in the timestamps
///   written via [`CmdWriteTimestamp2`] or [`CmdWriteTimestamp`]. The valid range for the count is
///   36..64 bits, or a value of 0, indicating no support for timestamps. Bits outside the valid
///   range are guaranteed to be zeros.
/// - [`min_image_transfer_granularity`] is the minimum granularity supported for image transfer
///   operations on the queues in this queue family.
///# Description
///The value returned in [`min_image_transfer_granularity`] has a unit of
///compressed texel blocks for images having a block-compressed format, and a
///unit of texels otherwise.Possible values of [`min_image_transfer_granularity`] are:
/// - (0,0,0) specifies that only whole mip levels  **must**  be transferred using the image
///   transfer operations on the corresponding queues. In this case, the following restrictions
///   apply to all offset and extent parameters of image transfer operations:  - The `x`, `y`, and
///   `z` members of a [`Offset3D`] parameter  **must**  always be zero.  - The `width`, `height`,
///   and `depth` members of a [`Extent3D`] parameter  **must**  always match the width, height, and
///   depth of the image subresource corresponding to the parameter, respectively.
/// - (A<sub>x</sub>, A<sub>y</sub>, A<sub>z</sub>) where A<sub>x</sub>, A<sub>y</sub>, and
///   A<sub>z</sub> are all integer powers of two. In this case the following restrictions apply to
///   all image transfer operations:  - `x`, `y`, and `z` of a [`Offset3D`] parameter  **must**  be
///   integer multiples of A<sub>x</sub>, A<sub>y</sub>, and A<sub>z</sub>, respectively.  - `width`
///   of a [`Extent3D`] parameter  **must**  be an integer multiple of A<sub>x</sub>, or else `x` +
///   `width` **must**  equal the width of the image subresource corresponding to the parameter.  -
///   `height` of a [`Extent3D`] parameter  **must**  be an integer multiple of A<sub>y</sub>, or
///   else `y` +  `height` **must**  equal the height of the image subresource corresponding to the
///   parameter.  - `depth` of a [`Extent3D`] parameter  **must**  be an integer multiple of
///   A<sub>z</sub>, or else `z` +  `depth` **must**  equal the depth of the image subresource
///   corresponding to the parameter.  - If the format of the image corresponding to the parameters
///   is one of the block-compressed formats then for the purposes of the above calculations the
///   granularity  **must**  be scaled up by the compressed texel block dimensions.
///Queues supporting graphics and/or compute operations  **must**  report
///(1,1,1) in [`min_image_transfer_granularity`], meaning that there are
///no additional restrictions on the granularity of image transfer operations
///for these queues.
///Other queues supporting image transfer operations are only  **required**  to
///support whole mip level transfers, thus [`min_image_transfer_granularity`]
///for queues belonging to such queue families  **may**  be (0,0,0).The [Device Memory](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#memory-device) section describes memory properties
///queried from the physical device.For physical device feature queries see the [Features](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features) chapter.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`Extent3D`]
/// - [`QueueFamilyProperties2`]
/// - [`QueueFlags`]
/// - [`GetPhysicalDeviceQueueFamilyProperties`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct QueueFamilyProperties {
    ///[`queue_flags`] is a bitmask of [`QueueFlagBits`] indicating
    ///capabilities of the queues in this queue family.
    queue_flags: QueueFlags,
    ///[`queue_count`] is the unsigned integer count of queues in this queue
    ///family.
    ///Each queue family  **must**  support at least one queue.
    queue_count: u32,
    ///[`timestamp_valid_bits`] is the unsigned integer count of meaningful
    ///bits in the timestamps written via
    ///[`CmdWriteTimestamp2`] or
    ///[`CmdWriteTimestamp`].
    ///The valid range for the count is 36..64 bits, or a value of 0,
    ///indicating no support for timestamps.
    ///Bits outside the valid range are guaranteed to be zeros.
    timestamp_valid_bits: u32,
    ///[`min_image_transfer_granularity`] is the minimum granularity supported
    ///for image transfer operations on the queues in this queue family.
    min_image_transfer_granularity: Extent3D,
}
impl Default for QueueFamilyProperties {
    fn default() -> Self {
        Self {
            queue_flags: Default::default(),
            queue_count: 0,
            timestamp_valid_bits: 0,
            min_image_transfer_granularity: Default::default(),
        }
    }
}
impl QueueFamilyProperties {
    ///Gets the value of [`Self::queue_flags`]
    pub fn queue_flags(&self) -> QueueFlags {
        self.queue_flags
    }
    ///Gets the value of [`Self::queue_count`]
    pub fn queue_count(&self) -> u32 {
        self.queue_count
    }
    ///Gets the value of [`Self::timestamp_valid_bits`]
    pub fn timestamp_valid_bits(&self) -> u32 {
        self.timestamp_valid_bits
    }
    ///Gets the value of [`Self::min_image_transfer_granularity`]
    pub fn min_image_transfer_granularity(&self) -> Extent3D {
        self.min_image_transfer_granularity
    }
    ///Gets a mutable reference to the value of [`Self::queue_flags`]
    pub fn queue_flags_mut(&mut self) -> &mut QueueFlags {
        &mut self.queue_flags
    }
    ///Gets a mutable reference to the value of [`Self::queue_count`]
    pub fn queue_count_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::timestamp_valid_bits`]
    pub fn timestamp_valid_bits_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::min_image_transfer_granularity`]
    pub fn min_image_transfer_granularity_mut(&mut self) -> &mut Extent3D {
        &mut self.min_image_transfer_granularity
    }
    ///Sets the raw value of [`Self::queue_flags`]
    pub fn set_queue_flags(&mut self, value: crate::vulkan1_0::QueueFlags) -> &mut Self {
        self.queue_flags = value;
        self
    }
    ///Sets the raw value of [`Self::queue_count`]
    pub fn set_queue_count(&mut self, value: u32) -> &mut Self {
        self.queue_count = value;
        self
    }
    ///Sets the raw value of [`Self::timestamp_valid_bits`]
    pub fn set_timestamp_valid_bits(&mut self, value: u32) -> &mut Self {
        self.timestamp_valid_bits = value;
        self
    }
    ///Sets the raw value of [`Self::min_image_transfer_granularity`]
    pub fn set_min_image_transfer_granularity(&mut self, value: crate::vulkan1_0::Extent3D) -> &mut Self {
        self.min_image_transfer_granularity = value;
        self
    }
}
///[VkPhysicalDeviceMemoryProperties](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMemoryProperties.html) - Structure specifying physical device memory properties
///# C Specifications
///The [`PhysicalDeviceMemoryProperties`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkPhysicalDeviceMemoryProperties {
///    uint32_t        memoryTypeCount;
///    VkMemoryType    memoryTypes[VK_MAX_MEMORY_TYPES];
///    uint32_t        memoryHeapCount;
///    VkMemoryHeap    memoryHeaps[VK_MAX_MEMORY_HEAPS];
///} VkPhysicalDeviceMemoryProperties;
///```
///# Members
/// - [`memory_type_count`] is the number of valid elements in the [`memory_types`] array.
/// - [`memory_types`] is an array of [`MAX_MEMORY_TYPES`][`MemoryType`] structures describing the
///   *memory types* that  **can**  be used to access memory allocated from the heaps specified by
///   [`memory_heaps`].
/// - [`memory_heap_count`] is the number of valid elements in the [`memory_heaps`] array.
/// - [`memory_heaps`] is an array of [`MAX_MEMORY_HEAPS`][`MemoryHeap`] structures describing the
///   *memory heaps* from which memory  **can**  be allocated.
///# Description
///The [`PhysicalDeviceMemoryProperties`] structure describes a number of
///*memory heaps* as well as a number of *memory types* that  **can**  be used to
///access memory allocated in those heaps.
///Each heap describes a memory resource of a particular size, and each memory
///type describes a set of memory properties (e.g. host cached vs uncached)
///that  **can**  be used with a given memory heap.
///Allocations using a particular memory type will consume resources from the
///heap indicated by that memory type’s heap index.
///More than one memory type  **may**  share each heap, and the heaps and memory
///types provide a mechanism to advertise an accurate size of the physical
///memory resources while allowing the memory to be used with a variety of
///different properties.The number of memory heaps is given by [`memory_heap_count`] and is less
///than or equal to [`MAX_MEMORY_HEAPS`].
///Each heap is described by an element of the [`memory_heaps`] array as a
///[`MemoryHeap`] structure.
///The number of memory types available across all memory heaps is given by
///[`memory_type_count`] and is less than or equal to
///[`MAX_MEMORY_TYPES`].
///Each memory type is described by an element of the [`memory_types`] array
///as a [`MemoryType`] structure.At least one heap  **must**  include
/// `VK_MEMORY_HEAP_DEVICE_LOCAL_BIT` in
///[`MemoryHeap::flags`].
///If there are multiple heaps that all have similar performance
///characteristics, they  **may**  all include
///`VK_MEMORY_HEAP_DEVICE_LOCAL_BIT`.
///In a unified memory architecture (UMA) system there is often only a single
///memory heap which is considered to be equally “local” to the host and to
///the device, and such an implementation  **must**  advertise the heap as
///device-local.Each memory type returned by [`GetPhysicalDeviceMemoryProperties`] **must**
///have its `propertyFlags` set to one of the following values:
/// - 0
/// - `VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT` | `VK_MEMORY_PROPERTY_HOST_COHERENT_BIT`
/// - `VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT` | `VK_MEMORY_PROPERTY_HOST_CACHED_BIT`
/// - `VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT` | `VK_MEMORY_PROPERTY_HOST_CACHED_BIT` |
///   `VK_MEMORY_PROPERTY_HOST_COHERENT_BIT`
/// - `VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT`
/// - `VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT` | `VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT` |
///   `VK_MEMORY_PROPERTY_HOST_COHERENT_BIT`
/// - `VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT` | `VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT` |
///   `VK_MEMORY_PROPERTY_HOST_CACHED_BIT`
/// - `VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT` | `VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT` |
///   `VK_MEMORY_PROPERTY_HOST_CACHED_BIT` | `VK_MEMORY_PROPERTY_HOST_COHERENT_BIT`
/// - `VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT` | `VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT`
/// - `VK_MEMORY_PROPERTY_PROTECTED_BIT`
/// - `VK_MEMORY_PROPERTY_PROTECTED_BIT` | `VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT`
/// - `VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT` | `VK_MEMORY_PROPERTY_HOST_COHERENT_BIT` |
///   `VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD`
/// - `VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT` | `VK_MEMORY_PROPERTY_HOST_CACHED_BIT` |
///   `VK_MEMORY_PROPERTY_HOST_COHERENT_BIT` | `VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD`
/// - `VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT` | `VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD`
/// - `VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT` | `VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT` |
///   `VK_MEMORY_PROPERTY_HOST_COHERENT_BIT` | `VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD`
/// - `VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT` | `VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT` |
///   `VK_MEMORY_PROPERTY_HOST_CACHED_BIT` | `VK_MEMORY_PROPERTY_HOST_COHERENT_BIT` |
///   `VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD`
/// - `VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT` | `VK_MEMORY_PROPERTY_HOST_COHERENT_BIT` |
///   `VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD` | `VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD`
/// - `VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT` | `VK_MEMORY_PROPERTY_HOST_CACHED_BIT` |
///   `VK_MEMORY_PROPERTY_HOST_COHERENT_BIT` | `VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD` |
///   `VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD`
/// - `VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT` | `VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD` |
///   `VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD`
/// - `VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT` | `VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT` |
///   `VK_MEMORY_PROPERTY_HOST_COHERENT_BIT` | `VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD` |
///   `VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD`
/// - `VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT` | `VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT` |
///   `VK_MEMORY_PROPERTY_HOST_CACHED_BIT` | `VK_MEMORY_PROPERTY_HOST_COHERENT_BIT` |
///   `VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD` | `VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD`
/// - `VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT` | `VK_MEMORY_PROPERTY_RDMA_CAPABLE_BIT_NV`
///There  **must**  be at least one memory type with both the
///`VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT` and
///`VK_MEMORY_PROPERTY_HOST_COHERENT_BIT` bits set in its
///`propertyFlags`.
///There  **must**  be at least one memory type with the
///`VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT` bit set in its
///`propertyFlags`.
///If the [`deviceCoherentMemory`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-deviceCoherentMemory) feature
///is enabled, there  **must**  be at least one memory type with the
///`VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD` bit set in its
///`propertyFlags`.For each pair of elements  **X**  and  **Y**  returned in [`memory_types`],
/// **X**  **must**  be placed at a lower index position than  **Y**  if:
/// - the set of bit flags returned in the `propertyFlags` member of  **X**  is a strict subset of
///   the set of bit flags returned in the `propertyFlags` member of  **Y** ; or
/// - the `propertyFlags` members of  **X**  and  **Y**  are equal, and  **X**  belongs to a memory
///   heap with greater performance (as determined in an implementation-specific manner) ; or
/// - the `propertyFlags` members of  **Y**  includes `VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD`
///   or `VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD` and  **X**  does not
///This ordering requirement enables applications to use a simple search loop
///to select the desired memory type along the lines of:
///```c
///// Find a memory in `memoryTypeBitsRequirement` that includes all of `requiredProperties`
///int32_t findProperties(const VkPhysicalDeviceMemoryProperties* pMemoryProperties,
///                       uint32_t memoryTypeBitsRequirement,
///                       VkMemoryPropertyFlags requiredProperties) {
///    const uint32_t memoryCount = pMemoryProperties->memoryTypeCount;
///    for (uint32_t memoryIndex = 0; memoryIndex < memoryCount; ++memoryIndex) {
///        const uint32_t memoryTypeBits = (1 << memoryIndex);
///        const bool isRequiredMemoryType = memoryTypeBitsRequirement & memoryTypeBits;
///
///        const VkMemoryPropertyFlags properties =
///            pMemoryProperties->memoryTypes[memoryIndex].propertyFlags;
///        const bool hasRequiredProperties =
///            (properties & requiredProperties) == requiredProperties;
///
///        if (isRequiredMemoryType && hasRequiredProperties)
///            return static_cast<int32_t>(memoryIndex);
///    }
///
///    // failed to find memory type
///    return -1;
///}
///
///// Try to find an optimal memory type, or if it does not exist try fallback memory type
///// `device` is the VkDevice
///// `image` is the VkImage that requires memory to be bound
///// `memoryProperties` properties as returned by vkGetPhysicalDeviceMemoryProperties
///// `requiredProperties` are the property flags that must be present
///// `optimalProperties` are the property flags that are preferred by the application
///VkMemoryRequirements memoryRequirements;
///vkGetImageMemoryRequirements(device, image, &memoryRequirements);
///int32_t memoryType =
///    findProperties(&memoryProperties, memoryRequirements.memoryTypeBits, optimalProperties);
///if (memoryType == -1) // not found; try fallback properties
///    memoryType =
///        findProperties(&memoryProperties, memoryRequirements.memoryTypeBits, requiredProperties);
///```
///# Related
/// - [`crate::vulkan1_0`]
/// - [`MemoryHeap`]
/// - [`MemoryType`]
/// - [`PhysicalDeviceMemoryProperties2`]
/// - [`GetPhysicalDeviceMemoryProperties`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct PhysicalDeviceMemoryProperties {
    ///[`memory_type_count`] is the number of valid elements in the
    ///[`memory_types`] array.
    memory_type_count: u32,
    ///[`memory_types`] is an array of [`MAX_MEMORY_TYPES`][`MemoryType`] structures describing the
    /// *memory types* that  **can**  be used to access memory allocated from the heaps
    /// specified by [`memory_heaps`].
    memory_types: [MemoryType; MAX_MEMORY_TYPES],
    ///[`memory_heap_count`] is the number of valid elements in the
    ///[`memory_heaps`] array.
    memory_heap_count: u32,
    ///[`memory_heaps`] is an array of [`MAX_MEMORY_HEAPS`][`MemoryHeap`] structures describing the
    /// *memory heaps* from which memory  **can**  be allocated.
    memory_heaps: [MemoryHeap; MAX_MEMORY_HEAPS],
}
impl Default for PhysicalDeviceMemoryProperties {
    fn default() -> Self {
        Self {
            memory_type_count: 0,
            memory_types: [Default::default(); MAX_MEMORY_TYPES],
            memory_heap_count: 0,
            memory_heaps: [Default::default(); MAX_MEMORY_HEAPS],
        }
    }
}
impl PhysicalDeviceMemoryProperties {
    ///Gets the value of [`Self::memory_type_count`]
    pub fn memory_type_count(&self) -> u32 {
        self.memory_type_count
    }
    ///Gets the value of [`Self::memory_types`]
    pub fn memory_types(&self) -> &[MemoryType; MAX_MEMORY_TYPES] {
        &getter
    }
    ///Gets the value of [`Self::memory_heap_count`]
    pub fn memory_heap_count(&self) -> u32 {
        self.memory_heap_count
    }
    ///Gets the value of [`Self::memory_heaps`]
    pub fn memory_heaps(&self) -> &[MemoryHeap; MAX_MEMORY_HEAPS] {
        &getter
    }
    ///Gets a mutable reference to the value of [`Self::memory_type_count`]
    pub fn memory_type_count_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::memory_types`]
    pub fn memory_types_mut(&mut self) -> &mut [MemoryType; MAX_MEMORY_TYPES] {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::memory_heap_count`]
    pub fn memory_heap_count_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::memory_heaps`]
    pub fn memory_heaps_mut(&mut self) -> &mut [MemoryHeap; MAX_MEMORY_HEAPS] {
        &mut getter
    }
    ///Sets the raw value of [`Self::memory_type_count`]
    pub fn set_memory_type_count(&mut self, value: u32) -> &mut Self {
        self.memory_type_count = value;
        self
    }
    ///Sets the raw value of [`Self::memory_types`]
    pub fn set_memory_types(
        &mut self,
        value: [crate::vulkan1_0::MemoryType; crate::core::MAX_MEMORY_TYPES],
    ) -> &mut Self {
        self.memory_types = value;
        self
    }
    ///Sets the raw value of [`Self::memory_heap_count`]
    pub fn set_memory_heap_count(&mut self, value: u32) -> &mut Self {
        self.memory_heap_count = value;
        self
    }
    ///Sets the raw value of [`Self::memory_heaps`]
    pub fn set_memory_heaps(
        &mut self,
        value: [crate::vulkan1_0::MemoryHeap; crate::core::MAX_MEMORY_HEAPS],
    ) -> &mut Self {
        self.memory_heaps = value;
        self
    }
}
///[VkMemoryAllocateInfo](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryAllocateInfo.html) - Structure containing parameters of a memory allocation
///# C Specifications
///The [`MemoryAllocateInfo`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkMemoryAllocateInfo {
///    VkStructureType    sType;
///    const void*        pNext;
///    VkDeviceSize       allocationSize;
///    uint32_t           memoryTypeIndex;
///} VkMemoryAllocateInfo;
///```
///# Members
/// - [`s_type`] is the type of this structure.
/// - [`p_next`] is `NULL` or a pointer to a structure extending this structure.
/// - [`allocation_size`] is the size of the allocation in bytes.
/// - [`memory_type_index`] is an index identifying a memory type from the `memoryTypes` array of
///   the [`PhysicalDeviceMemoryProperties`] structure.
///# Description
///The internal data of an allocated device memory object  **must**  include a
///reference to implementation-specific resources, referred to as the memory
///object’s *payload*.
///Applications  **can**  also import and export that internal data to and from
///device memory objects to share data between Vulkan instances and other
///compatible APIs.
///A [`MemoryAllocateInfo`] structure defines a memory import operation if
///its [`p_next`] chain includes one of the following structures:
/// - [`ImportMemoryWin32HandleInfoKHR`] with a non-zero `handleType` value
/// - [`ImportMemoryFdInfoKHR`] with a non-zero `handleType` value
/// - [`ImportMemoryHostPointerInfoEXT`] with a non-zero `handleType` value
/// - [`ImportAndroidHardwareBufferInfoANDROID`] with a non-`NULL``buffer` value
/// - [`ImportMemoryZirconHandleInfoFUCHSIA`] with a non-zero `handleType` value
/// - [`ImportMemoryBufferCollectionFUCHSIA`]
///If the parameters define an import operation and the external handle type is
///`VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT`,
///`VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT`, or
///`VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT`,
///[`allocation_size`] is ignored.
///The implementation  **must**  query the size of these allocations from the OS.Whether device
/// memory objects constructed via a memory import operation hold
///a reference to their payload depends on the properties of the handle type
///used to perform the import, as defined below for each valid handle type.
///Importing memory  **must**  not modify the content of the memory.
///Implementations  **must**  ensure that importing memory does not enable the
///importing Vulkan instance to access any memory or resources in other Vulkan
///instances other than that corresponding to the memory object imported.
///Implementations  **must**  also ensure accessing imported memory which has not
///been initialized does not allow the importing Vulkan instance to obtain data
///from the exporting Vulkan instance or vice-versa.Importing memory  **must**  not increase
/// overall heap usage within a system.
///However, it  **must**  affect the following per-process values:
/// - [`PhysicalDeviceMaintenance3Properties`]`::maxMemoryAllocationCount`
/// - [`PhysicalDeviceMemoryBudgetPropertiesEXT::heap_usage`]
///When performing a memory import operation, it is the responsibility of the
///application to ensure the external handles and their associated payloads
///meet all valid usage requirements.
///However, implementations  **must**  perform sufficient validation of external
///handles and payloads to ensure that the operation results in a valid memory
///object which will not cause program termination, device loss, queue stalls,
///or corruption of other resources when used as allowed according to its
///allocation parameters.
///If the external handle provided does not meet these requirements, the
///implementation  **must**  fail the memory import operation with the error code
///`VK_ERROR_INVALID_EXTERNAL_HANDLE`.
///## Valid Usage
/// - If the parameters define an import operation from an [`BufferCollectionFUCHSIA`], and
///   [`MemoryDedicatedAllocateInfo::buffer`] is present and non-NULL,
///   [`ImportMemoryBufferCollectionFUCHSIA::collection`] and
///   [`ImportMemoryBufferCollectionFUCHSIA::index`] must match
///   [`BufferCollectionBufferCreateInfoFUCHSIA::collection`] and
///   [`BufferCollectionBufferCreateInfoFUCHSIA::index`], respectively, of the
///   [`BufferCollectionBufferCreateInfoFUCHSIA`] structure used to create the
///   [`MemoryDedicatedAllocateInfo::buffer`]
/// - If the parameters define an import operation from an [`BufferCollectionFUCHSIA`], and
///   [`MemoryDedicatedAllocateInfo::image`] is present and non-NULL,
///   [`ImportMemoryBufferCollectionFUCHSIA::collection`] and
///   [`ImportMemoryBufferCollectionFUCHSIA::index`] must match
///   [`BufferCollectionImageCreateInfoFUCHSIA::collection`] and
///   [`BufferCollectionImageCreateInfoFUCHSIA::index`], respectively, of the
///   [`BufferCollectionImageCreateInfoFUCHSIA`] structure used to create the
///   [`MemoryDedicatedAllocateInfo::image`]
/// - If the parameters define an import operation from an [`BufferCollectionFUCHSIA`],
///   [`allocation_size`] **must**  match [`MemoryRequirements::size`] value retrieved by
///   [`GetImageMemoryRequirements`] or [`GetBufferMemoryRequirements`] for image-based or
///   buffer-based collections respectively
/// - If the parameters define an import operation from an [`BufferCollectionFUCHSIA`], the
///   [`p_next`] chain  **must**  include a [`MemoryDedicatedAllocateInfo`] structure with either
///   its `image` or `buffer` field set to a value other than [`crate::utils::Handle::null`].
/// - If the parameters define an import operation from an [`BufferCollectionFUCHSIA`] and
///   [`MemoryDedicatedAllocateInfo::image`] is not [`crate::utils::Handle::null`], the `image`
///   **must**  be created with a [`BufferCollectionImageCreateInfoFUCHSIA`] structure chained to
///   its [`ImageCreateInfo`]::[`p_next`] pointer
/// - If the parameters define an import operation from an [`BufferCollectionFUCHSIA`] and
///   [`MemoryDedicatedAllocateInfo::buffer`] is not [`crate::utils::Handle::null`], the `buffer`
///   **must**  be created with a [`BufferCollectionBufferCreateInfoFUCHSIA`] structure chained to
///   its [`BufferCreateInfo`]::[`p_next`] pointer
/// - If the parameters define an import operation from an [`BufferCollectionFUCHSIA`],
///   [`memory_type_index`] **must**  be from [`BufferCollectionPropertiesFUCHSIA`] as retrieved by
///   [`GetBufferCollectionPropertiesFUCHSIA`].
/// - If the [`p_next`] chain includes a [`ExportMemoryAllocateInfo`] structure, and any of the
///   handle types specified in [`ExportMemoryAllocateInfo::handle_types`] require a dedicated
///   allocation, as reported by [`GetPhysicalDeviceImageFormatProperties2`] in
///   [`ExternalImageFormatProperties`]::`externalMemoryProperties.externalMemoryFeatures` or
///   [`ExternalBufferProperties`]::`externalMemoryProperties.externalMemoryFeatures`, the
///   [`p_next`] chain  **must**  include a [`MemoryDedicatedAllocateInfo`] or
///   [`DedicatedAllocationMemoryAllocateInfoNV`] structure with either its `image` or `buffer`
///   member set to a value other than [`crate::utils::Handle::null`]
/// - If the [`p_next`] chain includes a [`ExportMemoryAllocateInfo`] structure, it  **must**  not
///   include a [`ExportMemoryAllocateInfoNV`] or [`ExportMemoryWin32HandleInfoNV`] structure
/// - If the [`p_next`] chain includes a [`ImportMemoryWin32HandleInfoKHR`] structure, it  **must**
///   not include a [`ImportMemoryWin32HandleInfoNV`] structure
/// - If the parameters define an import operation, the external handle specified was created by the
///   Vulkan API, and the external handle type is `VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT`,
///   then the values of [`allocation_size`] and [`memory_type_index`] **must**  match those
///   specified when the payload being imported was created
/// - If the parameters define an import operation and the external handle specified was created by
///   the Vulkan API, the device mask specified by [`MemoryAllocateFlagsInfo`] **must**  match the
///   mask specified when the payload being imported was allocated
/// - If the parameters define an import operation and the external handle specified was created by
///   the Vulkan API, the list of physical devices that comprise the logical device passed to
///   [`AllocateMemory`] **must**  match the list of physical devices that comprise the logical
///   device on which the payload was originally allocated
/// - If the parameters define an import operation and the external handle is an NT handle or a
///   global share handle created outside of the Vulkan API, the value of [`memory_type_index`]
///   **must**  be one of those returned by [`GetMemoryWin32HandlePropertiesKHR`]
/// - If the parameters define an import operation, the external handle was created by the Vulkan
///   API, and the external handle type is `VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT` or
///   `VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT`, then the values of [`allocation_size`]
///   and [`memory_type_index`] **must**  match those specified when the payload being imported was
///   created
/// - If the parameters define an import operation and the external handle type is
///   `VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT`, [`allocation_size`] **must**  match the size
///   specified when creating the Direct3D 12 heap from which the payload was extracted
/// - If the parameters define an import operation and the external handle is a POSIX file
///   descriptor created outside of the Vulkan API, the value of [`memory_type_index`] **must**  be
///   one of those returned by [`GetMemoryFdPropertiesKHR`]
/// - If the protected memory feature is not enabled, the
///   [`MemoryAllocateInfo`]::[`memory_type_index`] **must**  not indicate a memory type that
///   reports `VK_MEMORY_PROPERTY_PROTECTED_BIT`
/// - If the parameters define an import operation and the external handle is a host pointer, the
///   value of [`memory_type_index`] **must**  be one of those returned by
///   [`GetMemoryHostPointerPropertiesEXT`]
/// - If the parameters define an import operation and the external handle is a host pointer,
///   [`allocation_size`] **must**  be an integer multiple of
///   [`PhysicalDeviceExternalMemoryHostPropertiesEXT::min_imported_host_pointer_alignment`]
/// - If the parameters define an import operation and the external handle is a host pointer, the
///   [`p_next`] chain  **must**  not include a [`DedicatedAllocationMemoryAllocateInfoNV`]
///   structure with either its `image` or `buffer` field set to a value other than
///   [`crate::utils::Handle::null`]
/// - If the parameters define an import operation and the external handle is a host pointer, the
///   [`p_next`] chain  **must**  not include a [`MemoryDedicatedAllocateInfo`] structure with
///   either its `image` or `buffer` field set to a value other than [`crate::utils::Handle::null`]
/// - If the parameters define an import operation and the external handle type is
///   `VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID`, [`allocation_size`]
///   **must**  be the size returned by [`GetAndroidHardwareBufferPropertiesANDROID`] for the
///   Android hardware buffer
/// - If the parameters define an import operation and the external handle type is
///   `VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID`, and the [`p_next`] chain
///   does not include a [`MemoryDedicatedAllocateInfo`] structure or
///   [`MemoryDedicatedAllocateInfo::image`] is [`crate::utils::Handle::null`], the Android hardware
///   buffer  **must**  have a `AHardwareBuffer_Desc`::`format` of `AHARDWAREBUFFER_FORMAT_BLOB` and
///   a `AHardwareBuffer_Desc`::`usage` that includes `AHARDWAREBUFFER_USAGE_GPU_DATA_BUFFER`
/// - If the parameters define an import operation and the external handle type is
///   `VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID`, [`memory_type_index`]
///   **must**  be one of those returned by [`GetAndroidHardwareBufferPropertiesANDROID`] for the
///   Android hardware buffer
/// - If the parameters do not define an import operation, and the [`p_next`] chain includes a
///   [`ExportMemoryAllocateInfo`] structure with
///   `VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID` included in its
///   `handleTypes` member, and the [`p_next`] chain includes a [`MemoryDedicatedAllocateInfo`]
///   structure with `image` not equal to [`crate::utils::Handle::null`], then [`allocation_size`]
///   **must**  be `0`, otherwise [`allocation_size`] **must**  be greater than `0`
/// - If the parameters define an import operation, the external handle is an Android hardware
///   buffer, and the [`p_next`] chain includes a [`MemoryDedicatedAllocateInfo`] with `image` that
///   is not [`crate::utils::Handle::null`], the Android hardware buffer’s
///   [`AHardwareBuffer`]`::usage` **must**  include at least one of
///   `AHARDWAREBUFFER_USAGE_GPU_FRAMEBUFFER` or `AHARDWAREBUFFER_USAGE_GPU_SAMPLED_IMAGE`
/// - If the parameters define an import operation, the external handle is an Android hardware
///   buffer, and the [`p_next`] chain includes a [`MemoryDedicatedAllocateInfo`] with `image` that
///   is not [`crate::utils::Handle::null`], the format of `image` **must**  be
///   `VK_FORMAT_UNDEFINED` or the format returned by [`GetAndroidHardwareBufferPropertiesANDROID`]
///   in [`AndroidHardwareBufferFormatPropertiesANDROID::format`] for the Android hardware buffer
/// - If the parameters define an import operation, the external handle is an Android hardware
///   buffer, and the [`p_next`] chain includes a [`MemoryDedicatedAllocateInfo`] structure with
///   `image` that is not [`crate::utils::Handle::null`], the width, height, and array layer
///   dimensions of `image` and the Android hardware buffer’s `AHardwareBuffer_Desc` **must**  be
///   identical
/// - If the parameters define an import operation, the external handle is an Android hardware
///   buffer, and the [`p_next`] chain includes a [`MemoryDedicatedAllocateInfo`] structure with
///   `image` that is not [`crate::utils::Handle::null`], and the Android hardware buffer’s
///   [`AHardwareBuffer`]`::usage` includes `AHARDWAREBUFFER_USAGE_GPU_MIPMAP_COMPLETE`, the `image`
///   **must**  have a complete mipmap chain
/// - If the parameters define an import operation, the external handle is an Android hardware
///   buffer, and the [`p_next`] chain includes a [`MemoryDedicatedAllocateInfo`] structure with
///   `image` that is not [`crate::utils::Handle::null`], and the Android hardware buffer’s
///   [`AHardwareBuffer`]`::usage` does not include `AHARDWAREBUFFER_USAGE_GPU_MIPMAP_COMPLETE`, the
///   `image` **must**  have exactly one mipmap level
/// -    If the parameters define an import operation, the external handle is an Android hardware buffer, and the [`p_next`] chain includes a [`MemoryDedicatedAllocateInfo`] structure with `image` that is not [`crate::utils::Handle::null`], each bit set in the usage of `image` **must**  be listed in [AHardwareBuffer Usage Equivalence](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#memory-external-android-hardware-buffer-usage), and if there is a corresponding `AHARDWAREBUFFER_USAGE` bit listed that bit  **must**  be included in the Android hardware buffer’s `AHardwareBuffer_Desc`::`usage`
/// - If [`MemoryOpaqueCaptureAddressAllocateInfo::opaque_capture_address`] is not zero,
///   [`MemoryAllocateFlagsInfo::flags`] **must**  include
///   `VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT`
/// -    If [`MemoryAllocateFlagsInfo::flags`] includes `VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT`, the [bufferDeviceAddressCaptureReplay](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-bufferDeviceAddressCaptureReplay) feature  **must**  be enabled
/// - If [`MemoryAllocateFlagsInfo::flags`] includes `VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT`, the [bufferDeviceAddress](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-bufferDeviceAddress)
///   feature  **must**  be enabled
/// - If the [`p_next`] chain includes a [`ImportMemoryHostPointerInfoEXT`] structure,
///   [`MemoryOpaqueCaptureAddressAllocateInfo::opaque_capture_address`] **must**  be zero
/// - If the parameters define an import operation,
///   [`MemoryOpaqueCaptureAddressAllocateInfo::opaque_capture_address`] **must**  be zero
/// - If the parameters define an import operation and the external handle type is
///   `VK_EXTERNAL_MEMORY_HANDLE_TYPE_ZIRCON_VMO_BIT_FUCHSIA`, the value of [`memory_type_index`]
///   **must**  be an index identifying a memory type from the `memoryTypeBits` field of the
///   [`MemoryZirconHandlePropertiesFUCHSIA`] structure populated by a call to
///   [`GetMemoryZirconHandlePropertiesFUCHSIA`]
/// - If the parameters define an import operation and the external handle type is
///   `VK_EXTERNAL_MEMORY_HANDLE_TYPE_ZIRCON_VMO_BIT_FUCHSIA`, the value of [`allocation_size`]
///   **must**  be greater than `0` and  **must**  be less than or equal to the size of the VMO as
///   determined by `zx_vmo_get_size`(`handle`) where `handle` is the VMO handle to the imported
///   external memory
///
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be `VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO`
/// - Each [`p_next`] member of any structure (including this one) in the [`p_next`] chain  **must**
///   be either `NULL` or a pointer to a valid instance of
///   [`DedicatedAllocationMemoryAllocateInfoNV`], [`ExportMemoryAllocateInfo`],
///   [`ExportMemoryAllocateInfoNV`], [`ExportMemoryWin32HandleInfoKHR`],
///   [`ExportMemoryWin32HandleInfoNV`], [`ImportAndroidHardwareBufferInfoANDROID`],
///   [`ImportMemoryBufferCollectionFUCHSIA`], [`ImportMemoryFdInfoKHR`],
///   [`ImportMemoryHostPointerInfoEXT`], [`ImportMemoryWin32HandleInfoKHR`],
///   [`ImportMemoryWin32HandleInfoNV`], [`ImportMemoryZirconHandleInfoFUCHSIA`],
///   [`MemoryAllocateFlagsInfo`], [`MemoryDedicatedAllocateInfo`],
///   [`MemoryOpaqueCaptureAddressAllocateInfo`], or [`MemoryPriorityAllocateInfoEXT`]
/// - The [`s_type`] value of each struct in the [`p_next`] chain  **must**  be unique
///# Related
/// - [`crate::vulkan1_0`]
/// - [`DeviceSize`]
/// - [`StructureType`]
/// - [`AllocateMemory`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[repr(C)]
pub struct MemoryAllocateInfo<'lt> {
    _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] is the type of this structure.
    s_type: StructureType,
    ///[`p_next`] is `NULL` or a pointer to a structure extending this
    ///structure.
    p_next: *const BaseInStructure<'lt>,
    ///[`allocation_size`] is the size of the allocation in bytes.
    allocation_size: DeviceSize,
    ///[`memory_type_index`] is an index identifying a memory type from the
    ///`memoryTypes` array of the [`PhysicalDeviceMemoryProperties`]
    ///structure.
    memory_type_index: u32,
}
impl<'lt> Default for MemoryAllocateInfo<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: Default::default(),
            p_next: std::ptr::null(),
            allocation_size: Default::default(),
            memory_type_index: 0,
        }
    }
}
impl<'lt> MemoryAllocateInfo<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *const BaseInStructure<'lt> {
        self.p_next
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *const BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseInStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::allocation_size`]
    pub fn allocation_size(&self) -> DeviceSize {
        self.allocation_size
    }
    ///Gets the value of [`Self::memory_type_index`]
    pub fn memory_type_index(&self) -> u32 {
        self.memory_type_index
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::allocation_size`]
    pub fn allocation_size_mut(&mut self) -> &mut DeviceSize {
        &mut self.allocation_size
    }
    ///Gets a mutable reference to the value of [`Self::memory_type_index`]
    pub fn memory_type_index_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Sets the raw value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the raw value of [`Self::allocation_size`]
    pub fn set_allocation_size(&mut self, value: crate::vulkan1_0::DeviceSize) -> &mut Self {
        self.allocation_size = value;
        self
    }
    ///Sets the raw value of [`Self::memory_type_index`]
    pub fn set_memory_type_index(&mut self, value: u32) -> &mut Self {
        self.memory_type_index = value;
        self
    }
}
///[VkMemoryRequirements](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryRequirements.html) - Structure specifying memory requirements
///# C Specifications
///The [`MemoryRequirements`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkMemoryRequirements {
///    VkDeviceSize    size;
///    VkDeviceSize    alignment;
///    uint32_t        memoryTypeBits;
///} VkMemoryRequirements;
///```
///# Members
/// - [`size`] is the size, in bytes, of the memory allocation  **required**  for the resource.
/// - [`alignment`] is the alignment, in bytes, of the offset within the allocation  **required**
///   for the resource.
/// - [`memory_type_bits`] is a bitmask and contains one bit set for every supported memory type for
///   the resource. Bit `i` is set if and only if the memory type `i` in the
///   [`PhysicalDeviceMemoryProperties`] structure for the physical device is supported for the
///   resource.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`DeviceSize`]
/// - [`MemoryRequirements2`]
/// - [`GetBufferMemoryRequirements`]
/// - [`GetImageMemoryRequirements`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct MemoryRequirements {
    ///[`size`] is the size, in bytes, of the memory allocation  **required**  for
    ///the resource.
    size: DeviceSize,
    ///[`alignment`] is the alignment, in bytes, of the offset within the
    ///allocation  **required**  for the resource.
    alignment: DeviceSize,
    ///[`memory_type_bits`] is a bitmask and contains one bit set for every
    ///supported memory type for the resource.
    ///Bit `i` is set if and only if the memory type `i` in the
    ///[`PhysicalDeviceMemoryProperties`] structure for the physical device
    ///is supported for the resource.
    memory_type_bits: u32,
}
impl Default for MemoryRequirements {
    fn default() -> Self {
        Self {
            size: Default::default(),
            alignment: Default::default(),
            memory_type_bits: 0,
        }
    }
}
impl MemoryRequirements {
    ///Gets the value of [`Self::size`]
    pub fn size(&self) -> DeviceSize {
        self.size
    }
    ///Gets the value of [`Self::alignment`]
    pub fn alignment(&self) -> DeviceSize {
        self.alignment
    }
    ///Gets the value of [`Self::memory_type_bits`]
    pub fn memory_type_bits(&self) -> u32 {
        self.memory_type_bits
    }
    ///Gets a mutable reference to the value of [`Self::size`]
    pub fn size_mut(&mut self) -> &mut DeviceSize {
        &mut self.size
    }
    ///Gets a mutable reference to the value of [`Self::alignment`]
    pub fn alignment_mut(&mut self) -> &mut DeviceSize {
        &mut self.alignment
    }
    ///Gets a mutable reference to the value of [`Self::memory_type_bits`]
    pub fn memory_type_bits_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Sets the raw value of [`Self::size`]
    pub fn set_size(&mut self, value: crate::vulkan1_0::DeviceSize) -> &mut Self {
        self.size = value;
        self
    }
    ///Sets the raw value of [`Self::alignment`]
    pub fn set_alignment(&mut self, value: crate::vulkan1_0::DeviceSize) -> &mut Self {
        self.alignment = value;
        self
    }
    ///Sets the raw value of [`Self::memory_type_bits`]
    pub fn set_memory_type_bits(&mut self, value: u32) -> &mut Self {
        self.memory_type_bits = value;
        self
    }
}
///[VkSparseImageFormatProperties](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSparseImageFormatProperties.html) - Structure specifying sparse image format properties
///# C Specifications
///The [`SparseImageFormatProperties`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkSparseImageFormatProperties {
///    VkImageAspectFlags          aspectMask;
///    VkExtent3D                  imageGranularity;
///    VkSparseImageFormatFlags    flags;
///} VkSparseImageFormatProperties;
///```
///# Members
/// - [`aspect_mask`] is a bitmask [`ImageAspectFlagBits`] specifying which aspects of the image the
///   properties apply to.
/// - [`image_granularity`] is the width, height, and depth of the sparse image block in texels or
///   compressed texel blocks.
/// - [`flags`] is a bitmask of [`SparseImageFormatFlagBits`] specifying additional information
///   about the sparse resource.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`Extent3D`]
/// - [`ImageAspectFlags`]
/// - [`SparseImageFormatFlags`]
/// - [`SparseImageFormatProperties2`]
/// - [`SparseImageMemoryRequirements`]
/// - [`GetPhysicalDeviceSparseImageFormatProperties`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct SparseImageFormatProperties {
    ///[`aspect_mask`] is a bitmask [`ImageAspectFlagBits`] specifying
    ///which aspects of the image the properties apply to.
    aspect_mask: ImageAspectFlags,
    ///[`image_granularity`] is the width, height, and depth of the sparse
    ///image block in texels or compressed texel blocks.
    image_granularity: Extent3D,
    ///[`flags`] is a bitmask of [`SparseImageFormatFlagBits`] specifying
    ///additional information about the sparse resource.
    flags: SparseImageFormatFlags,
}
impl Default for SparseImageFormatProperties {
    fn default() -> Self {
        Self {
            aspect_mask: Default::default(),
            image_granularity: Default::default(),
            flags: Default::default(),
        }
    }
}
impl SparseImageFormatProperties {
    ///Gets the value of [`Self::aspect_mask`]
    pub fn aspect_mask(&self) -> ImageAspectFlags {
        self.aspect_mask
    }
    ///Gets the value of [`Self::image_granularity`]
    pub fn image_granularity(&self) -> Extent3D {
        self.image_granularity
    }
    ///Gets the value of [`Self::flags`]
    pub fn flags(&self) -> SparseImageFormatFlags {
        self.flags
    }
    ///Gets a mutable reference to the value of [`Self::aspect_mask`]
    pub fn aspect_mask_mut(&mut self) -> &mut ImageAspectFlags {
        &mut self.aspect_mask
    }
    ///Gets a mutable reference to the value of [`Self::image_granularity`]
    pub fn image_granularity_mut(&mut self) -> &mut Extent3D {
        &mut self.image_granularity
    }
    ///Gets a mutable reference to the value of [`Self::flags`]
    pub fn flags_mut(&mut self) -> &mut SparseImageFormatFlags {
        &mut self.flags
    }
    ///Sets the raw value of [`Self::aspect_mask`]
    pub fn set_aspect_mask(&mut self, value: crate::vulkan1_0::ImageAspectFlags) -> &mut Self {
        self.aspect_mask = value;
        self
    }
    ///Sets the raw value of [`Self::image_granularity`]
    pub fn set_image_granularity(&mut self, value: crate::vulkan1_0::Extent3D) -> &mut Self {
        self.image_granularity = value;
        self
    }
    ///Sets the raw value of [`Self::flags`]
    pub fn set_flags(&mut self, value: crate::vulkan1_0::SparseImageFormatFlags) -> &mut Self {
        self.flags = value;
        self
    }
}
///[VkSparseImageMemoryRequirements](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSparseImageMemoryRequirements.html) - Structure specifying sparse image memory requirements
///# C Specifications
///The [`SparseImageMemoryRequirements`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkSparseImageMemoryRequirements {
///    VkSparseImageFormatProperties    formatProperties;
///    uint32_t                         imageMipTailFirstLod;
///    VkDeviceSize                     imageMipTailSize;
///    VkDeviceSize                     imageMipTailOffset;
///    VkDeviceSize                     imageMipTailStride;
///} VkSparseImageMemoryRequirements;
///```
///# Members
/// - [`format_properties`] is a [`SparseImageFormatProperties`] structure specifying properties of
///   the image format.
/// - [`image_mip_tail_first_lod`] is the first mip level at which image subresources are included
///   in the mip tail region.
/// - [`image_mip_tail_size`] is the memory size (in bytes) of the mip tail region. If
///   `formatProperties.flags` contains `VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT`, this is the
///   size of the whole mip tail, otherwise this is the size of the mip tail of a single array
///   layer. This value is guaranteed to be a multiple of the sparse block size in bytes.
/// - [`image_mip_tail_offset`] is the opaque memory offset used with
///   [`SparseImageOpaqueMemoryBindInfo`] to bind the mip tail region(s).
/// - [`image_mip_tail_stride`] is the offset stride between each array-layer’s mip tail, if
///   `formatProperties.flags` does not contain `VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT`
///   (otherwise the value is undefined).
///# Related
/// - [`crate::vulkan1_0`]
/// - [`DeviceSize`]
/// - [`SparseImageFormatProperties`]
/// - [`SparseImageMemoryRequirements2`]
/// - [`GetImageSparseMemoryRequirements`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct SparseImageMemoryRequirements {
    ///[`format_properties`] is a [`SparseImageFormatProperties`]
    ///structure specifying properties of the image format.
    format_properties: SparseImageFormatProperties,
    ///[`image_mip_tail_first_lod`] is the first mip level at which image
    ///subresources are included in the mip tail region.
    image_mip_tail_first_lod: u32,
    ///[`image_mip_tail_size`] is the memory size (in bytes) of the mip tail
    ///region.
    ///If `formatProperties.flags` contains
    ///`VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT`, this is the size of the
    ///whole mip tail, otherwise this is the size of the mip tail of a single
    ///array layer.
    ///This value is guaranteed to be a multiple of the sparse block size in
    ///bytes.
    image_mip_tail_size: DeviceSize,
    ///[`image_mip_tail_offset`] is the opaque memory offset used with
    ///[`SparseImageOpaqueMemoryBindInfo`] to bind the mip tail region(s).
    image_mip_tail_offset: DeviceSize,
    ///[`image_mip_tail_stride`] is the offset stride between each array-layer’s
    ///mip tail, if `formatProperties.flags` does not contain
    ///`VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT` (otherwise the value is
    ///undefined).
    image_mip_tail_stride: DeviceSize,
}
impl Default for SparseImageMemoryRequirements {
    fn default() -> Self {
        Self {
            format_properties: Default::default(),
            image_mip_tail_first_lod: 0,
            image_mip_tail_size: Default::default(),
            image_mip_tail_offset: Default::default(),
            image_mip_tail_stride: Default::default(),
        }
    }
}
impl SparseImageMemoryRequirements {
    ///Gets the value of [`Self::format_properties`]
    pub fn format_properties(&self) -> SparseImageFormatProperties {
        self.format_properties
    }
    ///Gets the value of [`Self::image_mip_tail_first_lod`]
    pub fn image_mip_tail_first_lod(&self) -> u32 {
        self.image_mip_tail_first_lod
    }
    ///Gets the value of [`Self::image_mip_tail_size`]
    pub fn image_mip_tail_size(&self) -> DeviceSize {
        self.image_mip_tail_size
    }
    ///Gets the value of [`Self::image_mip_tail_offset`]
    pub fn image_mip_tail_offset(&self) -> DeviceSize {
        self.image_mip_tail_offset
    }
    ///Gets the value of [`Self::image_mip_tail_stride`]
    pub fn image_mip_tail_stride(&self) -> DeviceSize {
        self.image_mip_tail_stride
    }
    ///Gets a mutable reference to the value of [`Self::format_properties`]
    pub fn format_properties_mut(&mut self) -> &mut SparseImageFormatProperties {
        &mut self.format_properties
    }
    ///Gets a mutable reference to the value of [`Self::image_mip_tail_first_lod`]
    pub fn image_mip_tail_first_lod_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::image_mip_tail_size`]
    pub fn image_mip_tail_size_mut(&mut self) -> &mut DeviceSize {
        &mut self.image_mip_tail_size
    }
    ///Gets a mutable reference to the value of [`Self::image_mip_tail_offset`]
    pub fn image_mip_tail_offset_mut(&mut self) -> &mut DeviceSize {
        &mut self.image_mip_tail_offset
    }
    ///Gets a mutable reference to the value of [`Self::image_mip_tail_stride`]
    pub fn image_mip_tail_stride_mut(&mut self) -> &mut DeviceSize {
        &mut self.image_mip_tail_stride
    }
    ///Sets the raw value of [`Self::format_properties`]
    pub fn set_format_properties(&mut self, value: crate::vulkan1_0::SparseImageFormatProperties) -> &mut Self {
        self.format_properties = value;
        self
    }
    ///Sets the raw value of [`Self::image_mip_tail_first_lod`]
    pub fn set_image_mip_tail_first_lod(&mut self, value: u32) -> &mut Self {
        self.image_mip_tail_first_lod = value;
        self
    }
    ///Sets the raw value of [`Self::image_mip_tail_size`]
    pub fn set_image_mip_tail_size(&mut self, value: crate::vulkan1_0::DeviceSize) -> &mut Self {
        self.image_mip_tail_size = value;
        self
    }
    ///Sets the raw value of [`Self::image_mip_tail_offset`]
    pub fn set_image_mip_tail_offset(&mut self, value: crate::vulkan1_0::DeviceSize) -> &mut Self {
        self.image_mip_tail_offset = value;
        self
    }
    ///Sets the raw value of [`Self::image_mip_tail_stride`]
    pub fn set_image_mip_tail_stride(&mut self, value: crate::vulkan1_0::DeviceSize) -> &mut Self {
        self.image_mip_tail_stride = value;
        self
    }
}
///[VkMemoryType](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryType.html) - Structure specifying memory type
///# C Specifications
///The [`MemoryType`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkMemoryType {
///    VkMemoryPropertyFlags    propertyFlags;
///    uint32_t                 heapIndex;
///} VkMemoryType;
///```
///# Members
/// - [`heap_index`] describes which memory heap this memory type corresponds to, and  **must**  be
///   less than `memoryHeapCount` from the [`PhysicalDeviceMemoryProperties`] structure.
/// - [`property_flags`] is a bitmask of [`MemoryPropertyFlagBits`] of properties for this memory
///   type.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`MemoryPropertyFlags`]
/// - [`PhysicalDeviceMemoryProperties`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct MemoryType {
    ///[`property_flags`] is a bitmask of [`MemoryPropertyFlagBits`] of
    ///properties for this memory type.
    property_flags: MemoryPropertyFlags,
    ///[`heap_index`] describes which memory heap this memory type corresponds
    ///to, and  **must**  be less than `memoryHeapCount` from the
    ///[`PhysicalDeviceMemoryProperties`] structure.
    heap_index: u32,
}
impl Default for MemoryType {
    fn default() -> Self {
        Self {
            property_flags: Default::default(),
            heap_index: 0,
        }
    }
}
impl MemoryType {
    ///Gets the value of [`Self::property_flags`]
    pub fn property_flags(&self) -> MemoryPropertyFlags {
        self.property_flags
    }
    ///Gets the value of [`Self::heap_index`]
    pub fn heap_index(&self) -> u32 {
        self.heap_index
    }
    ///Gets a mutable reference to the value of [`Self::property_flags`]
    pub fn property_flags_mut(&mut self) -> &mut MemoryPropertyFlags {
        &mut self.property_flags
    }
    ///Gets a mutable reference to the value of [`Self::heap_index`]
    pub fn heap_index_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Sets the raw value of [`Self::property_flags`]
    pub fn set_property_flags(&mut self, value: crate::vulkan1_0::MemoryPropertyFlags) -> &mut Self {
        self.property_flags = value;
        self
    }
    ///Sets the raw value of [`Self::heap_index`]
    pub fn set_heap_index(&mut self, value: u32) -> &mut Self {
        self.heap_index = value;
        self
    }
}
///[VkMemoryHeap](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryHeap.html) - Structure specifying a memory heap
///# C Specifications
///The [`MemoryHeap`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkMemoryHeap {
///    VkDeviceSize         size;
///    VkMemoryHeapFlags    flags;
///} VkMemoryHeap;
///```
///# Members
/// - [`size`] is the total memory size in bytes in the heap.
/// - [`flags`] is a bitmask of [`MemoryHeapFlagBits`] specifying attribute flags for the heap.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`DeviceSize`]
/// - [`MemoryHeapFlags`]
/// - [`PhysicalDeviceMemoryProperties`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct MemoryHeap {
    ///[`size`] is the total memory size in bytes in the heap.
    size: DeviceSize,
    ///[`flags`] is a bitmask of [`MemoryHeapFlagBits`] specifying
    ///attribute flags for the heap.
    flags: MemoryHeapFlags,
}
impl Default for MemoryHeap {
    fn default() -> Self {
        Self {
            size: Default::default(),
            flags: Default::default(),
        }
    }
}
impl MemoryHeap {
    ///Gets the value of [`Self::size`]
    pub fn size(&self) -> DeviceSize {
        self.size
    }
    ///Gets the value of [`Self::flags`]
    pub fn flags(&self) -> MemoryHeapFlags {
        self.flags
    }
    ///Gets a mutable reference to the value of [`Self::size`]
    pub fn size_mut(&mut self) -> &mut DeviceSize {
        &mut self.size
    }
    ///Gets a mutable reference to the value of [`Self::flags`]
    pub fn flags_mut(&mut self) -> &mut MemoryHeapFlags {
        &mut self.flags
    }
    ///Sets the raw value of [`Self::size`]
    pub fn set_size(&mut self, value: crate::vulkan1_0::DeviceSize) -> &mut Self {
        self.size = value;
        self
    }
    ///Sets the raw value of [`Self::flags`]
    pub fn set_flags(&mut self, value: crate::vulkan1_0::MemoryHeapFlags) -> &mut Self {
        self.flags = value;
        self
    }
}
///[VkMappedMemoryRange](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMappedMemoryRange.html) - Structure specifying a mapped memory range
///# C Specifications
///The [`MappedMemoryRange`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkMappedMemoryRange {
///    VkStructureType    sType;
///    const void*        pNext;
///    VkDeviceMemory     memory;
///    VkDeviceSize       offset;
///    VkDeviceSize       size;
///} VkMappedMemoryRange;
///```
///# Members
/// - [`s_type`] is the type of this structure.
/// - [`p_next`] is `NULL` or a pointer to a structure extending this structure.
/// - [`memory`] is the memory object to which this range belongs.
/// - [`offset`] is the zero-based byte offset from the beginning of the memory object.
/// - [`size`] is either the size of range, or [`WHOLE_SIZE`] to affect the range from [`offset`] to
///   the end of the current mapping of the allocation.
///# Description
///## Valid Usage
/// - [`memory`] **must**  be currently host mapped
/// - If [`size`] is not equal to [`WHOLE_SIZE`], [`offset`] and [`size`] **must**  specify a range
///   contained within the currently mapped range of [`memory`]
/// - If [`size`] is equal to [`WHOLE_SIZE`], [`offset`] **must**  be within the currently mapped
///   range of [`memory`]
/// - [`offset`] **must**  be a multiple of [`PhysicalDeviceLimits::non_coherent_atom_size`]
/// - If [`size`] is equal to [`WHOLE_SIZE`], the end of the current mapping of [`memory`] **must**
///   either be a multiple of [`PhysicalDeviceLimits::non_coherent_atom_size`] bytes from the
///   beginning of the memory object, or be equal to the end of the memory object
/// - If [`size`] is not equal to [`WHOLE_SIZE`], [`size`] **must**  either be a multiple of
///   [`PhysicalDeviceLimits::non_coherent_atom_size`], or [`offset`] plus [`size`] **must**  equal
///   the size of [`memory`]
///
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be `VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE`
/// - [`p_next`] **must**  be `NULL`
/// - [`memory`] **must**  be a valid [`DeviceMemory`] handle
///# Related
/// - [`crate::vulkan1_0`]
/// - [`DeviceMemory`]
/// - [`DeviceSize`]
/// - [`StructureType`]
/// - [`FlushMappedMemoryRanges`]
/// - [`InvalidateMappedMemoryRanges`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[repr(C)]
pub struct MappedMemoryRange<'lt> {
    _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] is the type of this structure.
    s_type: StructureType,
    ///[`p_next`] is `NULL` or a pointer to a structure extending this
    ///structure.
    p_next: *const BaseInStructure<'lt>,
    ///[`memory`] is the memory object to which this range belongs.
    memory: DeviceMemory,
    ///[`offset`] is the zero-based byte offset from the beginning of the
    ///memory object.
    offset: DeviceSize,
    ///[`size`] is either the size of range, or [`WHOLE_SIZE`] to affect
    ///the range from [`offset`] to the end of the current mapping of the
    ///allocation.
    size: DeviceSize,
}
impl<'lt> Default for MappedMemoryRange<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: Default::default(),
            p_next: std::ptr::null(),
            memory: Default::default(),
            offset: Default::default(),
            size: Default::default(),
        }
    }
}
impl<'lt> MappedMemoryRange<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *const BaseInStructure<'lt> {
        self.p_next
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *const BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseInStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::memory`]
    pub fn memory(&self) -> DeviceMemory {
        self.memory
    }
    ///Gets the value of [`Self::offset`]
    pub fn offset(&self) -> DeviceSize {
        self.offset
    }
    ///Gets the value of [`Self::size`]
    pub fn size(&self) -> DeviceSize {
        self.size
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::memory`]
    pub fn memory_mut(&mut self) -> &mut DeviceMemory {
        &mut self.memory
    }
    ///Gets a mutable reference to the value of [`Self::offset`]
    pub fn offset_mut(&mut self) -> &mut DeviceSize {
        &mut self.offset
    }
    ///Gets a mutable reference to the value of [`Self::size`]
    pub fn size_mut(&mut self) -> &mut DeviceSize {
        &mut self.size
    }
    ///Sets the raw value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the raw value of [`Self::memory`]
    pub fn set_memory(&mut self, value: crate::vulkan1_0::DeviceMemory) -> &mut Self {
        self.memory = value;
        self
    }
    ///Sets the raw value of [`Self::offset`]
    pub fn set_offset(&mut self, value: crate::vulkan1_0::DeviceSize) -> &mut Self {
        self.offset = value;
        self
    }
    ///Sets the raw value of [`Self::size`]
    pub fn set_size(&mut self, value: crate::vulkan1_0::DeviceSize) -> &mut Self {
        self.size = value;
        self
    }
}
///[VkFormatProperties](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFormatProperties.html) - Structure specifying image format properties
///# C Specifications
///The [`FormatProperties`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkFormatProperties {
///    VkFormatFeatureFlags    linearTilingFeatures;
///    VkFormatFeatureFlags    optimalTilingFeatures;
///    VkFormatFeatureFlags    bufferFeatures;
///} VkFormatProperties;
///```
///# Members
/// - [`linear_tiling_features`] is a bitmask of [`FormatFeatureFlagBits`] specifying features
///   supported by images created with a `tiling` parameter of `VK_IMAGE_TILING_LINEAR`.
/// - [`optimal_tiling_features`] is a bitmask of [`FormatFeatureFlagBits`] specifying features
///   supported by images created with a `tiling` parameter of `VK_IMAGE_TILING_OPTIMAL`.
/// - [`buffer_features`] is a bitmask of [`FormatFeatureFlagBits`] specifying features supported by
///   buffers.
///# Description
///If `format` is a block-compressed format, then [`buffer_features`] **must**  not support any
/// features for the format.If `format` is not a multi-plane format then [`linear_tiling_features`]
///and [`optimal_tiling_features`] **must**  not contain
///`VK_FORMAT_FEATURE_DISJOINT_BIT`.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`FormatFeatureFlags`]
/// - [`FormatProperties2`]
/// - [`GetPhysicalDeviceFormatProperties`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct FormatProperties {
    ///[`linear_tiling_features`] is a bitmask of [`FormatFeatureFlagBits`]
    ///specifying features supported by images created with a `tiling`
    ///parameter of `VK_IMAGE_TILING_LINEAR`.
    linear_tiling_features: FormatFeatureFlags,
    ///[`optimal_tiling_features`] is a bitmask of
    ///[`FormatFeatureFlagBits`] specifying features supported by images
    ///created with a `tiling` parameter of `VK_IMAGE_TILING_OPTIMAL`.
    optimal_tiling_features: FormatFeatureFlags,
    ///[`buffer_features`] is a bitmask of [`FormatFeatureFlagBits`]
    ///specifying features supported by buffers.
    buffer_features: FormatFeatureFlags,
}
impl Default for FormatProperties {
    fn default() -> Self {
        Self {
            linear_tiling_features: Default::default(),
            optimal_tiling_features: Default::default(),
            buffer_features: Default::default(),
        }
    }
}
impl FormatProperties {
    ///Gets the value of [`Self::linear_tiling_features`]
    pub fn linear_tiling_features(&self) -> FormatFeatureFlags {
        self.linear_tiling_features
    }
    ///Gets the value of [`Self::optimal_tiling_features`]
    pub fn optimal_tiling_features(&self) -> FormatFeatureFlags {
        self.optimal_tiling_features
    }
    ///Gets the value of [`Self::buffer_features`]
    pub fn buffer_features(&self) -> FormatFeatureFlags {
        self.buffer_features
    }
    ///Gets a mutable reference to the value of [`Self::linear_tiling_features`]
    pub fn linear_tiling_features_mut(&mut self) -> &mut FormatFeatureFlags {
        &mut self.linear_tiling_features
    }
    ///Gets a mutable reference to the value of [`Self::optimal_tiling_features`]
    pub fn optimal_tiling_features_mut(&mut self) -> &mut FormatFeatureFlags {
        &mut self.optimal_tiling_features
    }
    ///Gets a mutable reference to the value of [`Self::buffer_features`]
    pub fn buffer_features_mut(&mut self) -> &mut FormatFeatureFlags {
        &mut self.buffer_features
    }
    ///Sets the raw value of [`Self::linear_tiling_features`]
    pub fn set_linear_tiling_features(&mut self, value: crate::vulkan1_0::FormatFeatureFlags) -> &mut Self {
        self.linear_tiling_features = value;
        self
    }
    ///Sets the raw value of [`Self::optimal_tiling_features`]
    pub fn set_optimal_tiling_features(&mut self, value: crate::vulkan1_0::FormatFeatureFlags) -> &mut Self {
        self.optimal_tiling_features = value;
        self
    }
    ///Sets the raw value of [`Self::buffer_features`]
    pub fn set_buffer_features(&mut self, value: crate::vulkan1_0::FormatFeatureFlags) -> &mut Self {
        self.buffer_features = value;
        self
    }
}
///[VkImageFormatProperties](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageFormatProperties.html) - Structure specifying an image format properties
///# C Specifications
///The [`ImageFormatProperties`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkImageFormatProperties {
///    VkExtent3D            maxExtent;
///    uint32_t              maxMipLevels;
///    uint32_t              maxArrayLayers;
///    VkSampleCountFlags    sampleCounts;
///    VkDeviceSize          maxResourceSize;
///} VkImageFormatProperties;
///```
///# Members
/// - [`max_extent`] are the maximum image dimensions. See the [Allowed Extent Values](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-extentperimagetype)
///   section below for how these values are constrained by `type`.
/// - [`max_mip_levels`] is the maximum number of mipmap levels. [`max_mip_levels`] **must**  be equal to the number of levels in the complete mipmap chain based on the `maxExtent.width`, `maxExtent.height`, and `maxExtent.depth`, except when one of the following conditions is true, in which case it  **may**  instead be `1`:  - [`GetPhysicalDeviceImageFormatProperties`]`::tiling` was `VK_IMAGE_TILING_LINEAR`  - [`PhysicalDeviceImageFormatInfo2::tiling`] was `VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT`  - the [`PhysicalDeviceImageFormatInfo2::p_next`] chain included a [`PhysicalDeviceExternalImageFormatInfo`] structure with a handle type included in the `handleTypes` member for which mipmap image support is not required  - image `format` is one of the [formats that require a sampler Y′C<sub>B</sub>C<sub>R</sub> conversion](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#formats-requiring-sampler-ycbcr-conversion)  - `flags` contains `VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT`
/// - [`max_array_layers`] is the maximum number of array layers. [`max_array_layers`] **must**  be no less than [`PhysicalDeviceLimits::max_image_array_layers`], except when one of the following conditions is true, in which case it  **may**  instead be `1`:  - `tiling` is `VK_IMAGE_TILING_LINEAR`  - `tiling` is `VK_IMAGE_TILING_OPTIMAL` and `type` is `VK_IMAGE_TYPE_3D`  - `format` is one of the [formats that require a sampler Y′C<sub>B</sub>C<sub>R</sub> conversion](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#formats-requiring-sampler-ycbcr-conversion)
/// - If `tiling` is `VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT`, then [`max_array_layers`] **must**
///   not be 0.
/// - [`sample_counts`] is a bitmask of [`SampleCountFlagBits`] specifying all the supported sample counts for this image as described [below](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-supported-sample-counts).
/// - [`max_resource_size`] is an upper bound on the total image size in bytes, inclusive of all
///   image subresources. Implementations  **may**  have an address space limit on total size of a
///   resource, which is advertised by this property. [`max_resource_size`] **must**  be at least
///   2<sup>31</sup>.
///# Description
///If the combination of parameters to
///[`GetPhysicalDeviceImageFormatProperties`] is not supported by the
///implementation for use in [`CreateImage`], then all members of
///[`ImageFormatProperties`] will be filled with zero.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`DeviceSize`]
/// - [`Extent3D`]
/// - [`ExternalImageFormatPropertiesNV`]
/// - [`ImageFormatProperties2`]
/// - [`SampleCountFlags`]
/// - [`GetPhysicalDeviceImageFormatProperties`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct ImageFormatProperties {
    ///[`max_extent`] are the maximum image dimensions.
    ///See the [Allowed Extent Values](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-extentperimagetype) section
    ///below for how these values are constrained by `type`.
    max_extent: Extent3D,
    ///[`max_mip_levels`] is the maximum number of mipmap levels.
    ///[`max_mip_levels`] **must**  be equal to the number of levels in the
    ///complete mipmap chain based on the `maxExtent.width`,
    ///`maxExtent.height`, and `maxExtent.depth`, except
    ///when one of the following conditions is true, in which case it  **may**
    ///instead be `1`:
    /// - [`GetPhysicalDeviceImageFormatProperties`]::`tiling` was `VK_IMAGE_TILING_LINEAR`
    /// - [`PhysicalDeviceImageFormatInfo2`]::`tiling` was `VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT`
    /// - the [`PhysicalDeviceImageFormatInfo2`]::`pNext` chain included a
    ///   [`PhysicalDeviceExternalImageFormatInfo`] structure with a handle type included in the
    ///   `handleTypes` member for which mipmap image support is not required
    /// - image `format` is one of the [formats that require a sampler Y′C<sub>B</sub>C<sub>R</sub> conversion](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#formats-requiring-sampler-ycbcr-conversion)
    /// - `flags` contains `VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT`
    max_mip_levels: u32,
    ///[`max_array_layers`] is the maximum number of array layers.
    ///[`max_array_layers`] **must**  be no less than
    ///[`PhysicalDeviceLimits`]::`maxImageArrayLayers`, except when one
    ///of the following conditions is true, in which case it  **may**  instead be
    ///`1`:
    /// - `tiling` is `VK_IMAGE_TILING_LINEAR`
    /// - `tiling` is `VK_IMAGE_TILING_OPTIMAL` and `type` is `VK_IMAGE_TYPE_3D`
    /// - `format` is one of the [formats that require a sampler Y′C<sub>B</sub>C<sub>R</sub> conversion](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#formats-requiring-sampler-ycbcr-conversion)
    max_array_layers: u32,
    ///[`sample_counts`] is a bitmask of [`SampleCountFlagBits`]
    ///specifying all the supported sample counts for this image as described
    ///[below](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-supported-sample-counts).
    sample_counts: SampleCountFlags,
    ///[`max_resource_size`] is an upper bound on the total image size in
    ///bytes, inclusive of all image subresources.
    ///Implementations  **may**  have an address space limit on total size of a
    ///resource, which is advertised by this property.
    ///[`max_resource_size`] **must**  be at least 2<sup>31</sup>.
    max_resource_size: DeviceSize,
}
impl Default for ImageFormatProperties {
    fn default() -> Self {
        Self {
            max_extent: Default::default(),
            max_mip_levels: 0,
            max_array_layers: 0,
            sample_counts: Default::default(),
            max_resource_size: Default::default(),
        }
    }
}
impl ImageFormatProperties {
    ///Gets the value of [`Self::max_extent`]
    pub fn max_extent(&self) -> Extent3D {
        self.max_extent
    }
    ///Gets the value of [`Self::max_mip_levels`]
    pub fn max_mip_levels(&self) -> u32 {
        self.max_mip_levels
    }
    ///Gets the value of [`Self::max_array_layers`]
    pub fn max_array_layers(&self) -> u32 {
        self.max_array_layers
    }
    ///Gets the value of [`Self::sample_counts`]
    pub fn sample_counts(&self) -> SampleCountFlags {
        self.sample_counts
    }
    ///Gets the value of [`Self::max_resource_size`]
    pub fn max_resource_size(&self) -> DeviceSize {
        self.max_resource_size
    }
    ///Gets a mutable reference to the value of [`Self::max_extent`]
    pub fn max_extent_mut(&mut self) -> &mut Extent3D {
        &mut self.max_extent
    }
    ///Gets a mutable reference to the value of [`Self::max_mip_levels`]
    pub fn max_mip_levels_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::max_array_layers`]
    pub fn max_array_layers_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::sample_counts`]
    pub fn sample_counts_mut(&mut self) -> &mut SampleCountFlags {
        &mut self.sample_counts
    }
    ///Gets a mutable reference to the value of [`Self::max_resource_size`]
    pub fn max_resource_size_mut(&mut self) -> &mut DeviceSize {
        &mut self.max_resource_size
    }
    ///Sets the raw value of [`Self::max_extent`]
    pub fn set_max_extent(&mut self, value: crate::vulkan1_0::Extent3D) -> &mut Self {
        self.max_extent = value;
        self
    }
    ///Sets the raw value of [`Self::max_mip_levels`]
    pub fn set_max_mip_levels(&mut self, value: u32) -> &mut Self {
        self.max_mip_levels = value;
        self
    }
    ///Sets the raw value of [`Self::max_array_layers`]
    pub fn set_max_array_layers(&mut self, value: u32) -> &mut Self {
        self.max_array_layers = value;
        self
    }
    ///Sets the raw value of [`Self::sample_counts`]
    pub fn set_sample_counts(&mut self, value: crate::vulkan1_0::SampleCountFlags) -> &mut Self {
        self.sample_counts = value;
        self
    }
    ///Sets the raw value of [`Self::max_resource_size`]
    pub fn set_max_resource_size(&mut self, value: crate::vulkan1_0::DeviceSize) -> &mut Self {
        self.max_resource_size = value;
        self
    }
}
///[VkDescriptorBufferInfo](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorBufferInfo.html) - Structure specifying descriptor buffer information
///# C Specifications
///The [`DescriptorBufferInfo`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkDescriptorBufferInfo {
///    VkBuffer        buffer;
///    VkDeviceSize    offset;
///    VkDeviceSize    range;
///} VkDescriptorBufferInfo;
///```
///# Members
/// - [`buffer`] is [`crate::utils::Handle::null`] or the buffer resource.
/// - [`offset`] is the offset in bytes from the start of [`buffer`]. Access to buffer memory via
///   this descriptor uses addressing that is relative to this starting offset.
/// - [`range`] is the size in bytes that is used for this descriptor update, or [`WHOLE_SIZE`] to
///   use the range from [`offset`] to the end of the buffer.
///# Description
///For `VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC` and
///`VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC` descriptor types,
///[`offset`] is the base offset from which the dynamic offset is applied and
///[`range`] is the static size used for all dynamic offsets.
///## Valid Usage
/// - [`offset`] **must**  be less than the size of [`buffer`]
/// - If [`range`] is not equal to [`WHOLE_SIZE`], [`range`] **must**  be greater than `0`
/// - If [`range`] is not equal to [`WHOLE_SIZE`], [`range`] **must**  be less than or equal to the
///   size of [`buffer`] minus [`offset`]
/// - If the [nullDescriptor](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-nullDescriptor)
///   feature is not enabled, [`buffer`] **must**  not be [`crate::utils::Handle::null`]
/// - If [`buffer`] is [`crate::utils::Handle::null`], [`offset`] **must**  be zero and [`range`]
///   **must**  be [`WHOLE_SIZE`]
///
///## Valid Usage (Implicit)
/// - If [`buffer`] is not [`crate::utils::Handle::null`], [`buffer`] **must**  be a valid
///   [`Buffer`] handle
///# Related
/// - [`crate::vulkan1_0`]
/// - [`Buffer`]
/// - [`DeviceSize`]
/// - [`WriteDescriptorSet`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[repr(C)]
pub struct DescriptorBufferInfo {
    ///[`buffer`] is
    ///[`crate::utils::Handle::null`] or
    ///the buffer resource.
    buffer: Buffer,
    ///[`offset`] is the offset in bytes from the start of [`buffer`].
    ///Access to buffer memory via this descriptor uses addressing that is
    ///relative to this starting offset.
    offset: DeviceSize,
    ///[`range`] is the size in bytes that is used for this descriptor
    ///update, or [`WHOLE_SIZE`] to use the range from [`offset`] to the
    ///end of the buffer.
    range: DeviceSize,
}
impl Default for DescriptorBufferInfo {
    fn default() -> Self {
        Self {
            buffer: Default::default(),
            offset: Default::default(),
            range: Default::default(),
        }
    }
}
impl DescriptorBufferInfo {
    ///Gets the value of [`Self::buffer`]
    pub fn buffer(&self) -> Buffer {
        self.buffer
    }
    ///Gets the value of [`Self::offset`]
    pub fn offset(&self) -> DeviceSize {
        self.offset
    }
    ///Gets the value of [`Self::range`]
    pub fn range(&self) -> DeviceSize {
        self.range
    }
    ///Gets a mutable reference to the value of [`Self::buffer`]
    pub fn buffer_mut(&mut self) -> &mut Buffer {
        &mut self.buffer
    }
    ///Gets a mutable reference to the value of [`Self::offset`]
    pub fn offset_mut(&mut self) -> &mut DeviceSize {
        &mut self.offset
    }
    ///Gets a mutable reference to the value of [`Self::range`]
    pub fn range_mut(&mut self) -> &mut DeviceSize {
        &mut self.range
    }
    ///Sets the raw value of [`Self::buffer`]
    pub fn set_buffer(&mut self, value: crate::vulkan1_0::Buffer) -> &mut Self {
        self.buffer = value;
        self
    }
    ///Sets the raw value of [`Self::offset`]
    pub fn set_offset(&mut self, value: crate::vulkan1_0::DeviceSize) -> &mut Self {
        self.offset = value;
        self
    }
    ///Sets the raw value of [`Self::range`]
    pub fn set_range(&mut self, value: crate::vulkan1_0::DeviceSize) -> &mut Self {
        self.range = value;
        self
    }
}
///[VkDescriptorImageInfo](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorImageInfo.html) - Structure specifying descriptor image information
///# C Specifications
///The [`DescriptorImageInfo`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkDescriptorImageInfo {
///    VkSampler        sampler;
///    VkImageView      imageView;
///    VkImageLayout    imageLayout;
///} VkDescriptorImageInfo;
///```
///# Members
/// - [`sampler`] is a sampler handle, and is used in descriptor updates for types
///   `VK_DESCRIPTOR_TYPE_SAMPLER` and `VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER` if the binding
///   being updated does not use immutable samplers.
/// - [`image_view`] is [`crate::utils::Handle::null`] or an image view handle, and is used in
///   descriptor updates for types `VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE`,
///   `VK_DESCRIPTOR_TYPE_STORAGE_IMAGE`, `VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER`, and
///   `VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT`.
/// - [`image_layout`] is the layout that the image subresources accessible from [`image_view`] will
///   be in at the time this descriptor is accessed. [`image_layout`] is used in descriptor updates
///   for types `VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE`, `VK_DESCRIPTOR_TYPE_STORAGE_IMAGE`,
///   `VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER`, and `VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT`.
///# Description
///Members of [`DescriptorImageInfo`] that are not used in an update (as
///described above) are ignored.
///## Valid Usage
/// - [`image_view`] **must**  not be 2D or 2D array image view created from a 3D image
/// - If [`image_view`] is created from a depth/stencil image, the `aspectMask` used to create the
///   [`image_view`] **must**  include either `VK_IMAGE_ASPECT_DEPTH_BIT` or
///   `VK_IMAGE_ASPECT_STENCIL_BIT` but not both
/// -  [`image_layout`] **must**  match the actual [`ImageLayout`] of each subresource accessible from [`image_view`] at the time this descriptor is accessed as defined by the [image layout matching rules](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#resources-image-layouts-matching-rule)
/// - If [`sampler`] is used and the [`Format`] of the image is a [multi-planar format](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#formats-requiring-sampler-ycbcr-conversion),
///   the image  **must**  have been created with `VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT`, and the
///   `aspectMask` of the [`image_view`] **must**  be `VK_IMAGE_ASPECT_PLANE_0_BIT`,
///   `VK_IMAGE_ASPECT_PLANE_1_BIT` or (for three-plane formats only) `VK_IMAGE_ASPECT_PLANE_2_BIT`
/// - If the `[`VK_KHR_portability_subset`]` extension is enabled, and
///   [`PhysicalDevicePortabilitySubsetFeaturesKHR::mutable_comparison_samplers`] is [`FALSE`], then
///   [`sampler`] **must**  have been created with [`SamplerCreateInfo::compare_enable`] set to
///   [`FALSE`]
///
///## Valid Usage (Implicit)
/// - Both of [`image_view`], and [`sampler`] that are valid handles of non-ignored parameters
///   **must**  have been created, allocated, or retrieved from the same [`Device`]
///# Related
/// - [`crate::vulkan1_0`]
/// - [`ImageLayout`]
/// - [`ImageView`]
/// - [`Sampler`]
/// - [`WriteDescriptorSet`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[repr(C)]
pub struct DescriptorImageInfo {
    ///[`sampler`] is a sampler handle, and is used in descriptor updates for
    ///types `VK_DESCRIPTOR_TYPE_SAMPLER` and
    ///`VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER` if the binding being
    ///updated does not use immutable samplers.
    sampler: Sampler,
    ///[`image_view`] is
    ///[`crate::utils::Handle::null`] or
    ///an image view handle, and is used in descriptor updates for types
    ///`VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE`,
    ///`VK_DESCRIPTOR_TYPE_STORAGE_IMAGE`,
    ///`VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER`, and
    ///`VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT`.
    image_view: ImageView,
    ///[`image_layout`] is the layout that the image subresources accessible
    ///from [`image_view`] will be in at the time this descriptor is accessed.
    ///[`image_layout`] is used in descriptor updates for types
    ///`VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE`,
    ///`VK_DESCRIPTOR_TYPE_STORAGE_IMAGE`,
    ///`VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER`, and
    ///`VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT`.
    image_layout: ImageLayout,
}
impl Default for DescriptorImageInfo {
    fn default() -> Self {
        Self {
            sampler: Default::default(),
            image_view: Default::default(),
            image_layout: Default::default(),
        }
    }
}
impl DescriptorImageInfo {
    ///Gets the value of [`Self::sampler`]
    pub fn sampler(&self) -> Sampler {
        self.sampler
    }
    ///Gets the value of [`Self::image_view`]
    pub fn image_view(&self) -> ImageView {
        self.image_view
    }
    ///Gets the value of [`Self::image_layout`]
    pub fn image_layout(&self) -> ImageLayout {
        self.image_layout
    }
    ///Gets a mutable reference to the value of [`Self::sampler`]
    pub fn sampler_mut(&mut self) -> &mut Sampler {
        &mut self.sampler
    }
    ///Gets a mutable reference to the value of [`Self::image_view`]
    pub fn image_view_mut(&mut self) -> &mut ImageView {
        &mut self.image_view
    }
    ///Gets a mutable reference to the value of [`Self::image_layout`]
    pub fn image_layout_mut(&mut self) -> &mut ImageLayout {
        &mut self.image_layout
    }
    ///Sets the raw value of [`Self::sampler`]
    pub fn set_sampler(&mut self, value: crate::vulkan1_0::Sampler) -> &mut Self {
        self.sampler = value;
        self
    }
    ///Sets the raw value of [`Self::image_view`]
    pub fn set_image_view(&mut self, value: crate::vulkan1_0::ImageView) -> &mut Self {
        self.image_view = value;
        self
    }
    ///Sets the raw value of [`Self::image_layout`]
    pub fn set_image_layout(&mut self, value: crate::vulkan1_0::ImageLayout) -> &mut Self {
        self.image_layout = value;
        self
    }
}
///[VkWriteDescriptorSet](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkWriteDescriptorSet.html) - Structure specifying the parameters of a descriptor set write operation
///# C Specifications
///The [`WriteDescriptorSet`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkWriteDescriptorSet {
///    VkStructureType                  sType;
///    const void*                      pNext;
///    VkDescriptorSet                  dstSet;
///    uint32_t                         dstBinding;
///    uint32_t                         dstArrayElement;
///    uint32_t                         descriptorCount;
///    VkDescriptorType                 descriptorType;
///    const VkDescriptorImageInfo*     pImageInfo;
///    const VkDescriptorBufferInfo*    pBufferInfo;
///    const VkBufferView*              pTexelBufferView;
///} VkWriteDescriptorSet;
///```
///# Members
/// - [`s_type`] is the type of this structure.
/// - [`p_next`] is `NULL` or a pointer to a structure extending this structure.
/// - [`dst_set`] is the destination descriptor set to update.
/// - [`dst_binding`] is the descriptor binding within that set.
/// - [`dst_array_element`] is the starting element in that array. If the descriptor binding
///   identified by [`dst_set`] and [`dst_binding`] has a descriptor type of
///   `VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK` then [`dst_array_element`] specifies the starting
///   byte offset within the binding.
/// - [`descriptor_count`] is the number of descriptors to update. If the descriptor binding
///   identified by [`dst_set`] and [`dst_binding`] has a descriptor type of
///   `VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK`, then [`descriptor_count`] specifies the number of
///   bytes to update. Otherwise, [`descriptor_count`] is one of  - the number of elements in
///   [`image_info`]  - the number of elements in [`buffer_info`]  - the number of elements in
///   [`texel_buffer_view`]  - a value matching the `dataSize` member of a
///   [`WriteDescriptorSetInlineUniformBlock`] structure in the [`p_next`] chain  - a value matching
///   the `accelerationStructureCount` of a [`WriteDescriptorSetAccelerationStructureKHR`] structure
///   in the [`p_next`] chain
/// - [`descriptor_type`] is a [`DescriptorType`] specifying the type of each descriptor in
///   [`image_info`], [`buffer_info`], or [`texel_buffer_view`], as described below. If
///   [`DescriptorSetLayoutBinding`] for [`dst_set`] at [`dst_binding`] is not equal to
///   `VK_DESCRIPTOR_TYPE_MUTABLE_VALVE`, [`descriptor_type`] **must**  be the same type as the
///   [`descriptor_type`] specified in [`DescriptorSetLayoutBinding`] for [`dst_set`] at
///   [`dst_binding`]. The type of the descriptor also controls which array the descriptors are
///   taken from.
/// - [`image_info`] is a pointer to an array of [`DescriptorImageInfo`] structures or is ignored,
///   as described below.
/// - [`buffer_info`] is a pointer to an array of [`DescriptorBufferInfo`] structures or is ignored,
///   as described below.
/// - [`texel_buffer_view`] is a pointer to an array of [`BufferView`] handles as described in the [Buffer Views](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#resources-buffer-views) section or is ignored, as described below.
///# Description
///Only one of [`image_info`], [`buffer_info`], or [`texel_buffer_view`]
///members is used according to the descriptor type specified in the
///[`descriptor_type`] member of the containing [`WriteDescriptorSet`]
///structure,
///or none of them in case [`descriptor_type`] is
///`VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK`, in which case the source data
///for the descriptor writes is taken from the
///[`WriteDescriptorSetInlineUniformBlock`] structure included in the
///[`p_next`] chain of [`WriteDescriptorSet`],
///or if [`descriptor_type`] is
///`VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR`, in which case the
///source data for the descriptor writes is taken from the
///[`WriteDescriptorSetAccelerationStructureKHR`] structure in the
///[`p_next`] chain of [`WriteDescriptorSet`],
///or if [`descriptor_type`] is
///`VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV`, in which case the source
///data for the descriptor writes is taken from the
///[`WriteDescriptorSetAccelerationStructureNV`] structure in the
///[`p_next`] chain of [`WriteDescriptorSet`],
///as specified below.If the [nullDescriptor](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-nullDescriptor) feature is enabled, the
///buffer,
///acceleration structure,
///imageView, or bufferView  **can**  be [`crate::utils::Handle::null`].
///Loads from a null descriptor return zero values and stores and atomics to a
///null descriptor are discarded.
///A null acceleration structure descriptor results in the miss shader being
///invoked.If the destination descriptor is a mutable descriptor, the active descriptor
///type for the destination descriptor becomes [`descriptor_type`].If the [`dst_binding`] has fewer
/// than [`descriptor_count`] array elements
///remaining starting from [`dst_array_element`], then the remainder will be
///used to update the subsequent binding - [`dst_binding`]+1 starting at
///array element zero.
///If a binding has a [`descriptor_count`] of zero, it is skipped.
///This behavior applies recursively, with the update affecting consecutive
///bindings as needed to update all [`descriptor_count`] descriptors.
///Consecutive bindings  **must**  have identical [`DescriptorType`],
///[`ShaderStageFlags`],
///[`DescriptorBindingFlagBits`],
///and immutable samplers references.
///## Valid Usage
/// - [`dst_binding`] **must**  be less than or equal to the maximum value of `binding` of all
///   [`DescriptorSetLayoutBinding`] structures specified when [`dst_set`]’s descriptor set layout
///   was created
/// - [`dst_binding`] **must**  be a binding with a non-zero [`descriptor_count`]
/// - All consecutive bindings updated via a single [`WriteDescriptorSet`] structure, except those
///   with a [`descriptor_count`] of zero,  **must**  have identical [`descriptor_type`] and
///   `stageFlags`
/// - All consecutive bindings updated via a single [`WriteDescriptorSet`] structure, except those
///   with a [`descriptor_count`] of zero,  **must**  all either use immutable samplers or  **must**
///   all not use immutable samplers
/// - [`descriptor_type`] **must**  match the type of [`dst_binding`] within [`dst_set`]
/// - [`dst_set`] **must**  be a valid [`DescriptorSet`] handle
/// -    The sum of [`dst_array_element`] and [`descriptor_count`] **must**  be less than or equal to the number of array elements in the descriptor set binding specified by [`dst_binding`], and all applicable consecutive bindings, as described by [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-updates-consecutive](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-updates-consecutive)
/// - If [`descriptor_type`] is `VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK`, [`dst_array_element`]
///   **must**  be an integer multiple of `4`
/// - If [`descriptor_type`] is `VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK`, [`descriptor_count`]
///   **must**  be an integer multiple of `4`
/// - If [`descriptor_type`] is `VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER` or
///   `VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER`, each element of [`texel_buffer_view`] **must**  be
///   either a valid [`BufferView`] handle or [`crate::utils::Handle::null`]
/// -    If [`descriptor_type`] is `VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER` or `VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER` and the [nullDescriptor](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-nullDescriptor) feature is not enabled, each element of [`texel_buffer_view`] **must**  not be [`crate::utils::Handle::null`]
/// - If [`descriptor_type`] is `VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER`,
///   `VK_DESCRIPTOR_TYPE_STORAGE_BUFFER`, `VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC`, or
///   `VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC`, [`buffer_info`] **must**  be a valid pointer to
///   an array of [`descriptor_count`] valid [`DescriptorBufferInfo`] structures
/// - If [`descriptor_type`] is `VK_DESCRIPTOR_TYPE_SAMPLER` or
///   `VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER`, and [`dst_set`] was not allocated with a layout
///   that included immutable samplers for [`dst_binding`] with [`descriptor_type`], the `sampler`
///   member of each element of [`image_info`] **must**  be a valid [`Sampler`] object
/// - If [`descriptor_type`] is `VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER`,
///   `VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE`, `VK_DESCRIPTOR_TYPE_STORAGE_IMAGE`, or
///   `VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT`, the `imageView` member of each element of
///   [`image_info`] **must**  be either a valid [`ImageView`] handle or
///   [`crate::utils::Handle::null`]
/// -    If [`descriptor_type`] is `VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER`, `VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE`, `VK_DESCRIPTOR_TYPE_STORAGE_IMAGE`, or `VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT` and the [nullDescriptor](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-nullDescriptor) feature is not enabled, the `imageView` member of each element of [`image_info`] **must**  not be [`crate::utils::Handle::null`]
/// - If [`descriptor_type`] is `VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK`, the [`p_next`] chain
///   **must**  include a [`WriteDescriptorSetInlineUniformBlock`] structure whose `dataSize` member
///   equals [`descriptor_count`]
/// - If [`descriptor_type`] is `VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR`, the [`p_next`]
///   chain  **must**  include a [`WriteDescriptorSetAccelerationStructureKHR`] structure whose
///   `accelerationStructureCount` member equals [`descriptor_count`]
/// - If [`descriptor_type`] is `VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV`, the [`p_next`] chain
///   **must**  include a [`WriteDescriptorSetAccelerationStructureNV`] structure whose
///   `accelerationStructureCount` member equals [`descriptor_count`]
/// - If [`descriptor_type`] is `VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE`, then the `imageView` member of
///   each [`image_info`] element  **must**  have been created without a
///   [`SamplerYcbcrConversionInfo`] structure in its [`p_next`] chain
/// - If [`descriptor_type`] is `VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER`, and if any element of
///   [`image_info`] has a `imageView` member that was created with a [`SamplerYcbcrConversionInfo`]
///   structure in its [`p_next`] chain, then [`dst_set`] **must**  have been allocated with a
///   layout that included immutable samplers for [`dst_binding`], and the corresponding immutable
///   sampler  **must**  have been created with an *identically
///   defined*[`SamplerYcbcrConversionInfo`] object
/// -    If [`descriptor_type`] is `VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER`, and [`dst_set`] was allocated with a layout that included immutable samplers for [`dst_binding`], then the `imageView` member of each element of [`image_info`] which corresponds to an immutable sampler that enables [sampler Y′C<sub>B</sub>C<sub>R</sub> conversion](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#samplers-YCbCr-conversion) **must**  have been created with a [`SamplerYcbcrConversionInfo`] structure in its [`p_next`] chain with an *identically defined*[`SamplerYcbcrConversionInfo`] to the corresponding immutable sampler
/// - If [`descriptor_type`] is `VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER` or
///   `VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC`, the `offset` member of each element of
///   [`buffer_info`] **must**  be a multiple of
///   [`PhysicalDeviceLimits::min_uniform_buffer_offset_alignment`]
/// - If [`descriptor_type`] is `VK_DESCRIPTOR_TYPE_STORAGE_BUFFER` or
///   `VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC`, the `offset` member of each element of
///   [`buffer_info`] **must**  be a multiple of
///   [`PhysicalDeviceLimits::min_storage_buffer_offset_alignment`]
/// - If [`descriptor_type`] is `VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER`,
///   `VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC`, `VK_DESCRIPTOR_TYPE_STORAGE_BUFFER`, or
///   `VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC`, and the `buffer` member of any element of
///   [`buffer_info`] is the handle of a non-sparse buffer, then that buffer  **must**  be bound
///   completely and contiguously to a single [`DeviceMemory`] object
/// - If [`descriptor_type`] is `VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER` or
///   `VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC`, the `buffer` member of each element of
///   [`buffer_info`] **must**  have been created with `VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT` set
/// - If [`descriptor_type`] is `VK_DESCRIPTOR_TYPE_STORAGE_BUFFER` or
///   `VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC`, the `buffer` member of each element of
///   [`buffer_info`] **must**  have been created with `VK_BUFFER_USAGE_STORAGE_BUFFER_BIT` set
/// - If [`descriptor_type`] is `VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER` or
///   `VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC`, the `range` member of each element of
///   [`buffer_info`], or the effective range if `range` is [`WHOLE_SIZE`],  **must**  be less than
///   or equal to [`PhysicalDeviceLimits::max_uniform_buffer_range`]
/// - If [`descriptor_type`] is `VK_DESCRIPTOR_TYPE_STORAGE_BUFFER` or
///   `VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC`, the `range` member of each element of
///   [`buffer_info`], or the effective range if `range` is [`WHOLE_SIZE`],  **must**  be less than
///   or equal to [`PhysicalDeviceLimits::max_storage_buffer_range`]
/// - If [`descriptor_type`] is `VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER`, the [`Buffer`] that each
///   element of [`texel_buffer_view`] was created from  **must**  have been created with
///   `VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT` set
/// - If [`descriptor_type`] is `VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER`, the [`Buffer`] that each
///   element of [`texel_buffer_view`] was created from  **must**  have been created with
///   `VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT` set
/// - If [`descriptor_type`] is `VK_DESCRIPTOR_TYPE_STORAGE_IMAGE` or
///   `VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT`, the `imageView` member of each element of
///   [`image_info`] **must**  have been created with the identity swizzle
/// - If [`descriptor_type`] is `VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE` or
///   `VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER`, the `imageView` member of each element of
///   [`image_info`] **must**  have been created with `VK_IMAGE_USAGE_SAMPLED_BIT` set
/// -    If [`descriptor_type`] is `VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE` the `imageLayout` member of each element of [`image_info`] **must**  be a member of the list given in [Sampled Image](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-sampledimage)
/// - If [`descriptor_type`] is `VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER` the `imageLayout` member
///   of each element of [`image_info`] **must**  be a member of the list given in [Combined Image Sampler](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-combinedimagesampler)
/// -    If [`descriptor_type`] is `VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT` the `imageLayout` member of each element of [`image_info`] **must**  be a member of the list given in [Input Attachment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-inputattachment)
/// -    If [`descriptor_type`] is `VK_DESCRIPTOR_TYPE_STORAGE_IMAGE` the `imageLayout` member of each element of [`image_info`] **must**  be a member of the list given in [Storage Image](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storageimage)
/// - If [`descriptor_type`] is `VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT`, the `imageView` member of
///   each element of [`image_info`] **must**  have been created with
///   `VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT` set
/// - If [`descriptor_type`] is `VK_DESCRIPTOR_TYPE_STORAGE_IMAGE`, the `imageView` member of each
///   element of [`image_info`] **must**  have been created with `VK_IMAGE_USAGE_STORAGE_BIT` set
/// - If [`descriptor_type`] is `VK_DESCRIPTOR_TYPE_SAMPLER`, then [`dst_set`] **must**  not have
///   been allocated with a layout that included immutable samplers for [`dst_binding`]
/// - If the [`DescriptorSetLayoutBinding`] for [`dst_set`] at [`dst_binding`] is
///   `VK_DESCRIPTOR_TYPE_MUTABLE_VALVE`, the new active descriptor type [`descriptor_type`]
///   **must**  exist in the corresponding `pMutableDescriptorTypeLists` list for [`dst_binding`]
/// - If [`descriptor_type`] is `VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT`, the `imageView` member of
///   each element of [`image_info`] **must**  have either been created without a
///   [`ImageViewMinLodCreateInfoEXT`] present in the [`p_next`] chain or with a
///   [`ImageViewMinLodCreateInfoEXT::min_lod`] of `0.0`
///
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be `VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET`
/// - Each [`p_next`] member of any structure (including this one) in the [`p_next`] chain  **must**
///   be either `NULL` or a pointer to a valid instance of
///   [`WriteDescriptorSetAccelerationStructureKHR`], [`WriteDescriptorSetAccelerationStructureNV`],
///   or [`WriteDescriptorSetInlineUniformBlock`]
/// - The [`s_type`] value of each struct in the [`p_next`] chain  **must**  be unique
/// - [`descriptor_type`] **must**  be a valid [`DescriptorType`] value
/// - [`descriptor_count`] **must**  be greater than `0`
/// - Both of [`dst_set`], and the elements of [`texel_buffer_view`] that are valid handles of
///   non-ignored parameters  **must**  have been created, allocated, or retrieved from the same
///   [`Device`]
///# Related
/// - [`crate::vulkan1_0`]
/// - [`BufferView`]
/// - [`DescriptorBufferInfo`]
/// - [`DescriptorImageInfo`]
/// - [`DescriptorSet`]
/// - [`DescriptorType`]
/// - [`StructureType`]
/// - [`CmdPushDescriptorSetKHR`]
/// - [`UpdateDescriptorSets`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[repr(C)]
pub struct WriteDescriptorSet<'lt> {
    _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] is the type of this structure.
    s_type: StructureType,
    ///[`p_next`] is `NULL` or a pointer to a structure extending this
    ///structure.
    p_next: *const BaseInStructure<'lt>,
    ///[`dst_set`] is the destination descriptor set to update.
    dst_set: DescriptorSet,
    ///[`dst_binding`] is the descriptor binding within that set.
    dst_binding: u32,
    ///[`dst_array_element`] is the starting element in that array.
    ///If the descriptor binding identified by [`dst_set`] and
    ///[`dst_binding`] has a descriptor type of
    ///`VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK` then [`dst_array_element`]
    ///specifies the starting byte offset within the binding.
    dst_array_element: u32,
    ///[`descriptor_count`] is the number of descriptors to update.
    ///If the descriptor binding identified by [`dst_set`] and
    ///[`dst_binding`] has a descriptor type of
    ///`VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK`, then
    ///[`descriptor_count`] specifies the number of bytes to update.
    ///Otherwise,
    ///[`descriptor_count`] is one of
    /// - the number of elements in [`image_info`]
    /// - the number of elements in [`buffer_info`]
    /// - the number of elements in [`texel_buffer_view`]
    /// - a value matching the `dataSize` member of a [`WriteDescriptorSetInlineUniformBlock`]
    ///   structure in the [`p_next`] chain
    /// - a value matching the `accelerationStructureCount` of a
    ///   [`WriteDescriptorSetAccelerationStructureKHR`] structure in the [`p_next`] chain
    descriptor_count: u32,
    ///[`descriptor_type`] is a [`DescriptorType`] specifying the type of
    ///each descriptor in [`image_info`], [`buffer_info`], or
    ///[`texel_buffer_view`], as described below.
    ///If [`DescriptorSetLayoutBinding`] for [`dst_set`] at
    ///[`dst_binding`] is not equal to `VK_DESCRIPTOR_TYPE_MUTABLE_VALVE`,
    ///[`descriptor_type`] **must**
    ///be the same type as the [`descriptor_type`] specified in
    ///[`DescriptorSetLayoutBinding`] for [`dst_set`] at [`dst_binding`].
    ///The type of the descriptor also controls which array the descriptors are
    ///taken from.
    descriptor_type: DescriptorType,
    ///the number of elements in [`image_info`]
    image_info: *const DescriptorImageInfo,
    ///the number of elements in [`buffer_info`]
    buffer_info: *const DescriptorBufferInfo,
    ///the number of elements in [`texel_buffer_view`]
    texel_buffer_view: *const BufferView,
}
impl<'lt> Default for WriteDescriptorSet<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: Default::default(),
            p_next: std::ptr::null(),
            dst_set: Default::default(),
            dst_binding: 0,
            dst_array_element: 0,
            descriptor_count: 0,
            descriptor_type: Default::default(),
            image_info: std::ptr::null(),
            buffer_info: std::ptr::null(),
            texel_buffer_view: std::ptr::null(),
        }
    }
}
impl<'lt> WriteDescriptorSet<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *const BaseInStructure<'lt> {
        self.p_next
    }
    ///Gets the raw value of [`Self::image_info`]
    pub fn image_info_raw(&self) -> *const DescriptorImageInfo {
        self.image_info
    }
    ///Gets the raw value of [`Self::buffer_info`]
    pub fn buffer_info_raw(&self) -> *const DescriptorBufferInfo {
        self.buffer_info
    }
    ///Gets the raw value of [`Self::texel_buffer_view`]
    pub fn texel_buffer_view_raw(&self) -> *const BufferView {
        self.texel_buffer_view
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *const BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::image_info`]
    pub fn set_image_info_raw(&mut self, value: *const DescriptorImageInfo) -> &mut Self {
        self.image_info = value;
        self
    }
    ///Sets the raw value of [`Self::buffer_info`]
    pub fn set_buffer_info_raw(&mut self, value: *const DescriptorBufferInfo) -> &mut Self {
        self.buffer_info = value;
        self
    }
    ///Sets the raw value of [`Self::texel_buffer_view`]
    pub fn set_texel_buffer_view_raw(&mut self, value: *const BufferView) -> &mut Self {
        self.texel_buffer_view = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseInStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::dst_set`]
    pub fn dst_set(&self) -> DescriptorSet {
        self.dst_set
    }
    ///Gets the value of [`Self::dst_binding`]
    pub fn dst_binding(&self) -> u32 {
        self.dst_binding
    }
    ///Gets the value of [`Self::dst_array_element`]
    pub fn dst_array_element(&self) -> u32 {
        self.dst_array_element
    }
    ///Gets the value of [`Self::descriptor_count`]
    pub fn descriptor_count(&self) -> u32 {
        self.descriptor_count
    }
    ///Gets the value of [`Self::descriptor_type`]
    pub fn descriptor_type(&self) -> DescriptorType {
        self.descriptor_type
    }
    ///Gets the value of [`Self::image_info`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn image_info(&self) -> &[DescriptorImageInfo] {
        std::slice::from_raw_parts(self.image_info, self.descriptor_count as usize)
    }
    ///Gets the value of [`Self::buffer_info`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn buffer_info(&self) -> &[DescriptorBufferInfo] {
        std::slice::from_raw_parts(self.buffer_info, self.descriptor_count as usize)
    }
    ///Gets the value of [`Self::texel_buffer_view`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn texel_buffer_view(&self) -> &[BufferView] {
        std::slice::from_raw_parts(self.texel_buffer_view, self.descriptor_count as usize)
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::dst_set`]
    pub fn dst_set_mut(&mut self) -> &mut DescriptorSet {
        &mut self.dst_set
    }
    ///Gets a mutable reference to the value of [`Self::dst_binding`]
    pub fn dst_binding_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::dst_array_element`]
    pub fn dst_array_element_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::descriptor_count`]
    pub fn descriptor_count_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::descriptor_type`]
    pub fn descriptor_type_mut(&mut self) -> &mut DescriptorType {
        &mut self.descriptor_type
    }
    ///Sets the raw value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the raw value of [`Self::dst_set`]
    pub fn set_dst_set(&mut self, value: crate::vulkan1_0::DescriptorSet) -> &mut Self {
        self.dst_set = value;
        self
    }
    ///Sets the raw value of [`Self::dst_binding`]
    pub fn set_dst_binding(&mut self, value: u32) -> &mut Self {
        self.dst_binding = value;
        self
    }
    ///Sets the raw value of [`Self::dst_array_element`]
    pub fn set_dst_array_element(&mut self, value: u32) -> &mut Self {
        self.dst_array_element = value;
        self
    }
    ///Sets the raw value of [`Self::descriptor_count`]
    pub fn set_descriptor_count(&mut self, value: u32) -> &mut Self {
        self.descriptor_count = value;
        self
    }
    ///Sets the raw value of [`Self::descriptor_type`]
    pub fn set_descriptor_type(&mut self, value: crate::vulkan1_0::DescriptorType) -> &mut Self {
        self.descriptor_type = value;
        self
    }
    ///Sets the raw value of [`Self::image_info`]
    pub fn set_image_info(&mut self, value: &'lt [crate::vulkan1_0::DescriptorImageInfo]) -> &mut Self {
        let len_ = value.len() as u32;
        let len_ = len_;
        self.image_info = value.as_ptr();
        self.descriptor_count = len_;
        self
    }
    ///Sets the raw value of [`Self::buffer_info`]
    pub fn set_buffer_info(&mut self, value: &'lt [crate::vulkan1_0::DescriptorBufferInfo]) -> &mut Self {
        let len_ = value.len() as u32;
        let len_ = len_;
        self.buffer_info = value.as_ptr();
        self.descriptor_count = len_;
        self
    }
    ///Sets the raw value of [`Self::texel_buffer_view`]
    pub fn set_texel_buffer_view(&mut self, value: &'lt [crate::vulkan1_0::BufferView]) -> &mut Self {
        let len_ = value.len() as u32;
        let len_ = len_;
        self.texel_buffer_view = value.as_ptr();
        self.descriptor_count = len_;
        self
    }
}
///[VkCopyDescriptorSet](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCopyDescriptorSet.html) - Structure specifying a copy descriptor set operation
///# C Specifications
///The [`CopyDescriptorSet`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkCopyDescriptorSet {
///    VkStructureType    sType;
///    const void*        pNext;
///    VkDescriptorSet    srcSet;
///    uint32_t           srcBinding;
///    uint32_t           srcArrayElement;
///    VkDescriptorSet    dstSet;
///    uint32_t           dstBinding;
///    uint32_t           dstArrayElement;
///    uint32_t           descriptorCount;
///} VkCopyDescriptorSet;
///```
///# Members
/// - [`s_type`] is the type of this structure.
/// - [`p_next`] is `NULL` or a pointer to a structure extending this structure.
/// - [`src_set`], [`src_binding`], and [`src_array_element`] are the source set, binding, and array
///   element, respectively. If the descriptor binding identified by [`src_set`] and [`src_binding`]
///   has a descriptor type of `VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK` then [`src_array_element`]
///   specifies the starting byte offset within the binding to copy from.
/// - [`dst_set`], [`dst_binding`], and [`dst_array_element`] are the destination set, binding, and
///   array element, respectively. If the descriptor binding identified by [`dst_set`] and
///   [`dst_binding`] has a descriptor type of `VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK` then
///   [`dst_array_element`] specifies the starting byte offset within the binding to copy to.
/// - [`descriptor_count`] is the number of descriptors to copy from the source to destination. If
///   [`descriptor_count`] is greater than the number of remaining array elements in the source or
///   destination binding, those affect consecutive bindings in a manner similar to
///   [`WriteDescriptorSet`] above. If the descriptor binding identified by [`src_set`] and
///   [`src_binding`] has a descriptor type of `VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK` then
///   [`descriptor_count`] specifies the number of bytes to copy and the remaining array elements in
///   the source or destination binding refer to the remaining number of bytes in those.
///# Description
///If the [`DescriptorSetLayoutBinding`] for [`dst_binding`] is
///`VK_DESCRIPTOR_TYPE_MUTABLE_VALVE` and [`src_binding`] is not
///`VK_DESCRIPTOR_TYPE_MUTABLE_VALVE`, the new active descriptor type
///becomes the descriptor type of [`src_binding`].
///If both [`DescriptorSetLayoutBinding`] for [`src_binding`] and
///[`dst_binding`] are `VK_DESCRIPTOR_TYPE_MUTABLE_VALVE`, the active
///descriptor type in each source descriptor is copied into the corresponding
///destination descriptor.
///The active descriptor type  **can**  be different for each source descriptor.
///## Valid Usage
/// - [`src_binding`] **must**  be a valid binding within [`src_set`]
/// -    The sum of [`src_array_element`] and [`descriptor_count`] **must**  be less than or equal to the number of array elements in the descriptor set binding specified by [`src_binding`], and all applicable consecutive bindings, as described by [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-updates-consecutive](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-updates-consecutive)
/// - [`dst_binding`] **must**  be a valid binding within [`dst_set`]
/// -    The sum of [`dst_array_element`] and [`descriptor_count`] **must**  be less than or equal to the number of array elements in the descriptor set binding specified by [`dst_binding`], and all applicable consecutive bindings, as described by [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-updates-consecutive](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-updates-consecutive)
/// - The type of [`dst_binding`] within [`dst_set`] **must**  be equal to the type of
///   [`src_binding`] within [`src_set`]
/// - If [`src_set`] is equal to [`dst_set`], then the source and destination ranges of descriptors 
///   **must**  not overlap, where the ranges  **may**  include array elements from consecutive bindings
///   as described by [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-updates-consecutive](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-updates-consecutive)
/// - If the descriptor type of the descriptor set binding specified by [`src_binding`] is
///   `VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK`, [`src_array_element`] **must**  be an integer
///   multiple of `4`
/// - If the descriptor type of the descriptor set binding specified by [`dst_binding`] is
///   `VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK`, [`dst_array_element`] **must**  be an integer
///   multiple of `4`
/// - If the descriptor type of the descriptor set binding specified by either [`src_binding`] or
///   [`dst_binding`] is `VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK`, [`descriptor_count`] **must**
///   be an integer multiple of `4`
/// - If [`src_set`]’s layout was created with the
///   `VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT` flag set, then [`dst_set`]’s
///   layout  **must**  also have been created with the
///   `VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT` flag set
/// - If [`src_set`]’s layout was created with neither
///   `VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT` nor
///   `VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_VALVE` flags set, then [`dst_set`]’s
///   layout  **must**  have been created without the
///   `VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT` flag set
/// - If the descriptor pool from which [`src_set`] was allocated was created with the
///   `VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT` flag set, then the descriptor pool from
///   which [`dst_set`] was allocated  **must**  also have been created with the
///   `VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT` flag set
/// - If the descriptor pool from which [`src_set`] was allocated was created with neither
///   `VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT` nor
///   `VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_VALVE` flags set, then the descriptor pool from which
///   [`dst_set`] was allocated  **must**  have been created without the
///   `VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT` flag set
/// - If the descriptor type of the descriptor set binding specified by [`dst_binding`] is
///   `VK_DESCRIPTOR_TYPE_SAMPLER`, then [`dst_set`] **must**  not have been allocated with a layout
///   that included immutable samplers for [`dst_binding`]
/// - If [`DescriptorSetLayoutBinding`] for [`dst_set`] at [`dst_binding`] is
///   `VK_DESCRIPTOR_TYPE_MUTABLE_VALVE`, the new active descriptor type  **must**  exist in the
///   corresponding `pMutableDescriptorTypeLists` list for [`dst_binding`] if the new active
///   descriptor type is not `VK_DESCRIPTOR_TYPE_MUTABLE_VALVE`
/// - If [`DescriptorSetLayoutBinding`] for [`src_set`] at [`src_binding`] is
///   `VK_DESCRIPTOR_TYPE_MUTABLE_VALVE` and the [`DescriptorSetLayoutBinding`] for [`dst_set`] at
///   [`dst_binding`] is not `VK_DESCRIPTOR_TYPE_MUTABLE_VALVE`, the active descriptor type for the
///   source descriptor  **must**  match the descriptor type of [`dst_binding`]
/// - If [`DescriptorSetLayoutBinding`] for [`dst_set`] at [`dst_binding`] is
///   `VK_DESCRIPTOR_TYPE_MUTABLE_VALVE`, and the new active descriptor type is
///   `VK_DESCRIPTOR_TYPE_MUTABLE_VALVE`, the `pMutableDescriptorTypeLists` for [`src_binding`] and
///   [`dst_binding`] **must**  match exactly
///
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be `VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET`
/// - [`p_next`] **must**  be `NULL`
/// - [`src_set`] **must**  be a valid [`DescriptorSet`] handle
/// - [`dst_set`] **must**  be a valid [`DescriptorSet`] handle
/// - Both of [`dst_set`], and [`src_set`] **must**  have been created, allocated, or retrieved from
///   the same [`Device`]
///# Related
/// - [`crate::vulkan1_0`]
/// - [`DescriptorSet`]
/// - [`StructureType`]
/// - [`UpdateDescriptorSets`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[repr(C)]
pub struct CopyDescriptorSet<'lt> {
    _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] is the type of this structure.
    s_type: StructureType,
    ///[`p_next`] is `NULL` or a pointer to a structure extending this
    ///structure.
    p_next: *const BaseInStructure<'lt>,
    ///[`src_set`], [`src_binding`], and [`src_array_element`] are the source
    ///set, binding, and array element, respectively.
    ///If the descriptor binding identified by [`src_set`] and
    ///[`src_binding`] has a descriptor type of
    ///`VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK` then [`src_array_element`]
    ///specifies the starting byte offset within the binding to copy from.
    src_set: DescriptorSet,
    ///No documentation found
    src_binding: u32,
    ///No documentation found
    src_array_element: u32,
    ///[`dst_set`], [`dst_binding`], and [`dst_array_element`] are the
    ///destination set, binding, and array element, respectively.
    ///If the descriptor binding identified by [`dst_set`] and
    ///[`dst_binding`] has a descriptor type of
    ///`VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK` then [`dst_array_element`]
    ///specifies the starting byte offset within the binding to copy to.
    dst_set: DescriptorSet,
    ///No documentation found
    dst_binding: u32,
    ///No documentation found
    dst_array_element: u32,
    ///[`descriptor_count`] is the number of descriptors to copy from the
    ///source to destination.
    ///If [`descriptor_count`] is greater than the number of remaining array
    ///elements in the source or destination binding, those affect consecutive
    ///bindings in a manner similar to [`WriteDescriptorSet`] above.
    ///If the descriptor binding identified by [`src_set`] and
    ///[`src_binding`] has a descriptor type of
    ///`VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK` then [`descriptor_count`]
    ///specifies the number of bytes to copy and the remaining array elements
    ///in the source or destination binding refer to the remaining number of
    ///bytes in those.
    descriptor_count: u32,
}
impl<'lt> Default for CopyDescriptorSet<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: Default::default(),
            p_next: std::ptr::null(),
            src_set: Default::default(),
            src_binding: 0,
            src_array_element: 0,
            dst_set: Default::default(),
            dst_binding: 0,
            dst_array_element: 0,
            descriptor_count: 0,
        }
    }
}
impl<'lt> CopyDescriptorSet<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *const BaseInStructure<'lt> {
        self.p_next
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *const BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseInStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::src_set`]
    pub fn src_set(&self) -> DescriptorSet {
        self.src_set
    }
    ///Gets the value of [`Self::src_binding`]
    pub fn src_binding(&self) -> u32 {
        self.src_binding
    }
    ///Gets the value of [`Self::src_array_element`]
    pub fn src_array_element(&self) -> u32 {
        self.src_array_element
    }
    ///Gets the value of [`Self::dst_set`]
    pub fn dst_set(&self) -> DescriptorSet {
        self.dst_set
    }
    ///Gets the value of [`Self::dst_binding`]
    pub fn dst_binding(&self) -> u32 {
        self.dst_binding
    }
    ///Gets the value of [`Self::dst_array_element`]
    pub fn dst_array_element(&self) -> u32 {
        self.dst_array_element
    }
    ///Gets the value of [`Self::descriptor_count`]
    pub fn descriptor_count(&self) -> u32 {
        self.descriptor_count
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::src_set`]
    pub fn src_set_mut(&mut self) -> &mut DescriptorSet {
        &mut self.src_set
    }
    ///Gets a mutable reference to the value of [`Self::src_binding`]
    pub fn src_binding_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::src_array_element`]
    pub fn src_array_element_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::dst_set`]
    pub fn dst_set_mut(&mut self) -> &mut DescriptorSet {
        &mut self.dst_set
    }
    ///Gets a mutable reference to the value of [`Self::dst_binding`]
    pub fn dst_binding_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::dst_array_element`]
    pub fn dst_array_element_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::descriptor_count`]
    pub fn descriptor_count_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Sets the raw value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the raw value of [`Self::src_set`]
    pub fn set_src_set(&mut self, value: crate::vulkan1_0::DescriptorSet) -> &mut Self {
        self.src_set = value;
        self
    }
    ///Sets the raw value of [`Self::src_binding`]
    pub fn set_src_binding(&mut self, value: u32) -> &mut Self {
        self.src_binding = value;
        self
    }
    ///Sets the raw value of [`Self::src_array_element`]
    pub fn set_src_array_element(&mut self, value: u32) -> &mut Self {
        self.src_array_element = value;
        self
    }
    ///Sets the raw value of [`Self::dst_set`]
    pub fn set_dst_set(&mut self, value: crate::vulkan1_0::DescriptorSet) -> &mut Self {
        self.dst_set = value;
        self
    }
    ///Sets the raw value of [`Self::dst_binding`]
    pub fn set_dst_binding(&mut self, value: u32) -> &mut Self {
        self.dst_binding = value;
        self
    }
    ///Sets the raw value of [`Self::dst_array_element`]
    pub fn set_dst_array_element(&mut self, value: u32) -> &mut Self {
        self.dst_array_element = value;
        self
    }
    ///Sets the raw value of [`Self::descriptor_count`]
    pub fn set_descriptor_count(&mut self, value: u32) -> &mut Self {
        self.descriptor_count = value;
        self
    }
}
///[VkBufferCreateInfo](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferCreateInfo.html) - Structure specifying the parameters of a newly created buffer object
///# C Specifications
///The [`BufferCreateInfo`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkBufferCreateInfo {
///    VkStructureType        sType;
///    const void*            pNext;
///    VkBufferCreateFlags    flags;
///    VkDeviceSize           size;
///    VkBufferUsageFlags     usage;
///    VkSharingMode          sharingMode;
///    uint32_t               queueFamilyIndexCount;
///    const uint32_t*        pQueueFamilyIndices;
///} VkBufferCreateInfo;
///```
///# Members
/// - [`s_type`] is the type of this structure.
/// - [`p_next`] is `NULL` or a pointer to a structure extending this structure.
/// - [`flags`] is a bitmask of [`BufferCreateFlagBits`] specifying additional parameters of the
///   buffer.
/// - [`size`] is the size in bytes of the buffer to be created.
/// - [`usage`] is a bitmask of [`BufferUsageFlagBits`] specifying allowed usages of the buffer.
/// - [`sharing_mode`] is a [`SharingMode`] value specifying the sharing mode of the buffer when it
///   will be accessed by multiple queue families.
/// - [`queue_family_index_count`] is the number of entries in the [`queue_family_indices`] array.
/// - [`queue_family_indices`] is a pointer to an array of queue families that will access this
///   buffer. It is ignored if [`sharing_mode`] is not `VK_SHARING_MODE_CONCURRENT`.
///# Description
///## Valid Usage
/// - [`size`] **must**  be greater than `0`
/// - If [`sharing_mode`] is `VK_SHARING_MODE_CONCURRENT`, [`queue_family_indices`] **must**  be a
///   valid pointer to an array of [`queue_family_index_count`]`uint32_t` values
/// - If [`sharing_mode`] is `VK_SHARING_MODE_CONCURRENT`, [`queue_family_index_count`] **must**  be
///   greater than `1`
/// - If [`sharing_mode`] is `VK_SHARING_MODE_CONCURRENT`, each element of [`queue_family_indices`]
///   **must**  be unique and  **must**  be less than `pQueueFamilyPropertyCount` returned by either
///   [`GetPhysicalDeviceQueueFamilyProperties`] or [`GetPhysicalDeviceQueueFamilyProperties2`] for
///   the `physicalDevice` that was used to create `device`
/// - If the [sparse bindings](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-sparseBinding)
///   feature is not enabled, [`flags`] **must**  not contain `VK_BUFFER_CREATE_SPARSE_BINDING_BIT`
/// - If the [sparse buffer residency](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-sparseResidencyBuffer)
///   feature is not enabled, [`flags`] **must**  not contain
///   `VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT`
/// - If the [sparse aliased residency](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-sparseResidencyAliased)
///   feature is not enabled, [`flags`] **must**  not contain `VK_BUFFER_CREATE_SPARSE_ALIASED_BIT`
/// - If [`flags`] contains `VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT` or
///   `VK_BUFFER_CREATE_SPARSE_ALIASED_BIT`, it  **must**  also contain
///   `VK_BUFFER_CREATE_SPARSE_BINDING_BIT`
/// - If the [`p_next`] chain includes a [`ExternalMemoryBufferCreateInfo`] structure, its
///   `handleTypes` member  **must**  only contain bits that are also in
///   [`ExternalBufferProperties`]::`externalMemoryProperties.compatibleHandleTypes`, as returned by
///   [`GetPhysicalDeviceExternalBufferProperties`] with `pExternalBufferInfo->handleType` equal to
///   any one of the handle types specified in [`ExternalMemoryBufferCreateInfo::handle_types`]
/// - If the protected memory feature is not enabled, [`flags`] **must**  not contain
///   `VK_BUFFER_CREATE_PROTECTED_BIT`
/// - If any of the bits `VK_BUFFER_CREATE_SPARSE_BINDING_BIT`,
///   `VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT`, or `VK_BUFFER_CREATE_SPARSE_ALIASED_BIT` are set,
///   `VK_BUFFER_CREATE_PROTECTED_BIT` **must**  not also be set
/// - If the [`p_next`] chain includes a [`DedicatedAllocationBufferCreateInfoNV`] structure, and
///   the `dedicatedAllocation` member of the chained structure is [`TRUE`], then [`flags`] **must**
///   not include `VK_BUFFER_CREATE_SPARSE_BINDING_BIT`, `VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT`, or
///   `VK_BUFFER_CREATE_SPARSE_ALIASED_BIT`
/// - If [`BufferDeviceAddressCreateInfoEXT::device_address`] is not zero, [`flags`] **must**
///   include `VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT`
/// - If [`BufferOpaqueCaptureAddressCreateInfo::opaque_capture_address`] is not zero, [`flags`]
///   **must**  include `VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT`
/// - If [`flags`] includes `VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT`, the [bufferDeviceAddressCaptureReplay](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-bufferDeviceAddressCaptureReplay)
///   or [[`PhysicalDeviceBufferDeviceAddressFeaturesEXT::buffer_device_address_capture_replay`]](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-bufferDeviceAddressCaptureReplayEXT)
///   feature  **must**  be enabled
/// - If [`usage`] includes `VK_BUFFER_USAGE_VIDEO_DECODE_SRC_BIT_KHR`,
///   `VK_BUFFER_USAGE_VIDEO_DECODE_DST_BIT_KHR`, then the [`p_next`] chain  **must**  include a
///   valid [`VideoProfilesKHR`] structure which includes at least one [`VideoProfileKHR`] with a
///   decode codec-operation
/// - If [`usage`] includes `VK_BUFFER_USAGE_VIDEO_ENCODE_SRC_BIT_KHR`,
///   `VK_BUFFER_USAGE_VIDEO_ENCODE_DST_BIT_KHR`, then the [`p_next`] chain  **must**  include a
///   valid [`VideoProfilesKHR`] structure which includes at least one [`VideoProfileKHR`] with a
///   encode codec-operation
/// - [`size`] **must**  be less than or equal to
///   [`PhysicalDeviceMaintenance4Properties::max_buffer_size`]
///
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be `VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO`
/// - Each [`p_next`] member of any structure (including this one) in the [`p_next`] chain  **must**
///   be either `NULL` or a pointer to a valid instance of
///   [`BufferCollectionBufferCreateInfoFUCHSIA`], [`BufferDeviceAddressCreateInfoEXT`],
///   [`BufferOpaqueCaptureAddressCreateInfo`], [`DedicatedAllocationBufferCreateInfoNV`],
///   [`ExternalMemoryBufferCreateInfo`], [`VideoDecodeH264ProfileEXT`],
///   [`VideoDecodeH265ProfileEXT`], [`VideoEncodeH264ProfileEXT`], [`VideoEncodeH265ProfileEXT`],
///   [`VideoProfileKHR`], or [`VideoProfilesKHR`]
/// - The [`s_type`] value of each struct in the [`p_next`] chain  **must**  be unique
/// - [`flags`] **must**  be a valid combination of [`BufferCreateFlagBits`] values
/// - [`usage`] **must**  be a valid combination of [`BufferUsageFlagBits`] values
/// - [`usage`] **must**  not be `0`
/// - [`sharing_mode`] **must**  be a valid [`SharingMode`] value
///# Related
/// - [`crate::vulkan1_0`]
/// - [`BufferConstraintsInfoFUCHSIA`]
/// - [`BufferCreateFlags`]
/// - [`BufferUsageFlags`]
/// - [`DeviceBufferMemoryRequirements`]
/// - [`DeviceSize`]
/// - [`SharingMode`]
/// - [`StructureType`]
/// - [`CreateBuffer`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[repr(C)]
pub struct BufferCreateInfo<'lt> {
    _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] is the type of this structure.
    s_type: StructureType,
    ///[`p_next`] is `NULL` or a pointer to a structure extending this
    ///structure.
    p_next: *const BaseInStructure<'lt>,
    ///[`flags`] is a bitmask of [`BufferCreateFlagBits`] specifying
    ///additional parameters of the buffer.
    flags: BufferCreateFlags,
    ///[`size`] is the size in bytes of the buffer to be created.
    size: DeviceSize,
    ///[`usage`] is a bitmask of [`BufferUsageFlagBits`] specifying
    ///allowed usages of the buffer.
    usage: BufferUsageFlags,
    ///[`sharing_mode`] is a [`SharingMode`] value specifying the sharing
    ///mode of the buffer when it will be accessed by multiple queue families.
    sharing_mode: SharingMode,
    ///[`queue_family_index_count`] is the number of entries in the
    ///[`queue_family_indices`] array.
    queue_family_index_count: u32,
    ///[`queue_family_indices`] is a pointer to an array of queue families
    ///that will access this buffer.
    ///It is ignored if [`sharing_mode`] is not
    ///`VK_SHARING_MODE_CONCURRENT`.
    queue_family_indices: *const u32,
}
impl<'lt> Default for BufferCreateInfo<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: Default::default(),
            p_next: std::ptr::null(),
            flags: Default::default(),
            size: Default::default(),
            usage: Default::default(),
            sharing_mode: Default::default(),
            queue_family_index_count: 0,
            queue_family_indices: std::ptr::null(),
        }
    }
}
impl<'lt> BufferCreateInfo<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *const BaseInStructure<'lt> {
        self.p_next
    }
    ///Gets the raw value of [`Self::queue_family_indices`]
    pub fn queue_family_indices_raw(&self) -> *const u32 {
        self.queue_family_indices
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *const BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::queue_family_indices`]
    pub fn set_queue_family_indices_raw(&mut self, value: *const u32) -> &mut Self {
        self.queue_family_indices = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseInStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::flags`]
    pub fn flags(&self) -> BufferCreateFlags {
        self.flags
    }
    ///Gets the value of [`Self::size`]
    pub fn size(&self) -> DeviceSize {
        self.size
    }
    ///Gets the value of [`Self::usage`]
    pub fn usage(&self) -> BufferUsageFlags {
        self.usage
    }
    ///Gets the value of [`Self::sharing_mode`]
    pub fn sharing_mode(&self) -> SharingMode {
        self.sharing_mode
    }
    ///Gets the value of [`Self::queue_family_index_count`]
    pub fn queue_family_index_count(&self) -> u32 {
        self.queue_family_index_count
    }
    ///Gets the value of [`Self::queue_family_indices`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn queue_family_indices(&self) -> &[u32] {
        std::slice::from_raw_parts(self.queue_family_indices, self.queue_family_index_count as usize)
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::flags`]
    pub fn flags_mut(&mut self) -> &mut BufferCreateFlags {
        &mut self.flags
    }
    ///Gets a mutable reference to the value of [`Self::size`]
    pub fn size_mut(&mut self) -> &mut DeviceSize {
        &mut self.size
    }
    ///Gets a mutable reference to the value of [`Self::usage`]
    pub fn usage_mut(&mut self) -> &mut BufferUsageFlags {
        &mut self.usage
    }
    ///Gets a mutable reference to the value of [`Self::sharing_mode`]
    pub fn sharing_mode_mut(&mut self) -> &mut SharingMode {
        &mut self.sharing_mode
    }
    ///Gets a mutable reference to the value of [`Self::queue_family_index_count`]
    pub fn queue_family_index_count_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Sets the raw value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the raw value of [`Self::flags`]
    pub fn set_flags(&mut self, value: crate::vulkan1_0::BufferCreateFlags) -> &mut Self {
        self.flags = value;
        self
    }
    ///Sets the raw value of [`Self::size`]
    pub fn set_size(&mut self, value: crate::vulkan1_0::DeviceSize) -> &mut Self {
        self.size = value;
        self
    }
    ///Sets the raw value of [`Self::usage`]
    pub fn set_usage(&mut self, value: crate::vulkan1_0::BufferUsageFlags) -> &mut Self {
        self.usage = value;
        self
    }
    ///Sets the raw value of [`Self::sharing_mode`]
    pub fn set_sharing_mode(&mut self, value: crate::vulkan1_0::SharingMode) -> &mut Self {
        self.sharing_mode = value;
        self
    }
    ///Sets the raw value of [`Self::queue_family_index_count`]
    pub fn set_queue_family_index_count(&mut self, value: u32) -> &mut Self {
        self.queue_family_index_count = value;
        self
    }
    ///Sets the raw value of [`Self::queue_family_indices`]
    pub fn set_queue_family_indices(&mut self, value: &'lt [u32]) -> &mut Self {
        let len_ = value.len() as u32;
        let len_ = len_;
        self.queue_family_indices = value.as_ptr();
        self.queue_family_index_count = len_;
        self
    }
}
///[VkBufferViewCreateInfo](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferViewCreateInfo.html) - Structure specifying parameters of a newly created buffer view
///# C Specifications
///The [`BufferViewCreateInfo`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkBufferViewCreateInfo {
///    VkStructureType            sType;
///    const void*                pNext;
///    VkBufferViewCreateFlags    flags;
///    VkBuffer                   buffer;
///    VkFormat                   format;
///    VkDeviceSize               offset;
///    VkDeviceSize               range;
///} VkBufferViewCreateInfo;
///```
///# Members
/// - [`s_type`] is the type of this structure.
/// - [`p_next`] is `NULL` or a pointer to a structure extending this structure.
/// - [`flags`] is reserved for future use.
/// - [`buffer`] is a [`Buffer`] on which the view will be created.
/// - [`format`] is a [`Format`] describing the format of the data elements in the buffer.
/// - [`offset`] is an offset in bytes from the base address of the buffer. Accesses to the buffer
///   view from shaders use addressing that is relative to this starting offset.
/// - [`range`] is a size in bytes of the buffer view. If [`range`] is equal to [`WHOLE_SIZE`], the range from [`offset`] to the end of the buffer is used. If [`WHOLE_SIZE`] is used and the remaining size of the buffer is not a multiple of the [texel block size](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#texel-block-size) of [`format`], the nearest smaller multiple is used.
///# Description
///## Valid Usage
/// - [`offset`] **must**  be less than the size of [`buffer`]
/// - If [`range`] is not equal to [`WHOLE_SIZE`], [`range`] **must**  be greater than `0`
/// - If [`range`] is not equal to [`WHOLE_SIZE`], [`range`] **must**  be an integer multiple of the
///   texel block size of [`format`]
/// -    If [`range`] is not equal to [`WHOLE_SIZE`], the number of texel buffer elements given by (⌊[`range`] / (texel block size)⌋ × (texels per block)) where texel block size and texels per block are as defined in the [Compatible Formats](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#formats-compatibility) table for [`format`],  **must**  be less than or equal to [`PhysicalDeviceLimits::max_texel_buffer_elements`]
/// - If [`range`] is not equal to [`WHOLE_SIZE`], the sum of [`offset`] and [`range`] **must**  be
///   less than or equal to the size of [`buffer`]
/// -    If [`range`] is equal to [`WHOLE_SIZE`], the number of texel buffer elements given by (⌊(size - [`offset`]) / (texel block size)⌋ × (texels per block)) where size is the size of [`buffer`], and texel block size and texels per block are as defined in the [Compatible Formats](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#formats-compatibility) table for [`format`],  **must**  be less than or equal to [`PhysicalDeviceLimits::max_texel_buffer_elements`]
/// - [`buffer`] **must**  have been created with a `usage` value containing at least one of
///   `VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT` or `VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT`
/// - If [`buffer`] was created with `usage` containing `VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT`,
///   [`format`] **must**  be supported for uniform texel buffers, as specified by the
///   `VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT` flag in [`FormatProperties::buffer_features`]
///   returned by [`GetPhysicalDeviceFormatProperties`]
/// - If [`buffer`] was created with `usage` containing `VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT`,
///   [`format`] **must**  be supported for storage texel buffers, as specified by the
///   `VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT` flag in [`FormatProperties::buffer_features`]
///   returned by [`GetPhysicalDeviceFormatProperties`]
/// - If [`buffer`] is non-sparse then it  **must**  be bound completely and contiguously to a
///   single [`DeviceMemory`] object
/// - If the [texelBufferAlignment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-texelBufferAlignment)
///   feature is not enabled, [`offset`] **must**  be a multiple of
///   [`PhysicalDeviceLimits::min_texel_buffer_offset_alignment`]
/// - If the [texelBufferAlignment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-texelBufferAlignment)
///   feature is enabled and if [`buffer`] was created with `usage` containing
///   `VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT`, [`offset`] **must**  be a multiple of the lesser
///   of [`PhysicalDeviceTexelBufferAlignmentProperties::
///   storage_texel_buffer_offset_alignment_bytes`] or, if
///   [`PhysicalDeviceTexelBufferAlignmentProperties::
///   storage_texel_buffer_offset_single_texel_alignment`] is [`TRUE`], the size of a texel of the
///   requested [`format`]. If the size of a texel is a multiple of three bytes, then the size of a
///   single component of [`format`] is used instead
/// - If the [texelBufferAlignment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-texelBufferAlignment)
///   feature is enabled and if [`buffer`] was created with `usage` containing
///   `VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT`, [`offset`] **must**  be a multiple of the lesser
///   of [`PhysicalDeviceTexelBufferAlignmentProperties::
///   uniform_texel_buffer_offset_alignment_bytes`] or, if
///   [`PhysicalDeviceTexelBufferAlignmentProperties::
///   uniform_texel_buffer_offset_single_texel_alignment`] is [`TRUE`], the size of a texel of the
///   requested [`format`]. If the size of a texel is a multiple of three bytes, then the size of a
///   single component of [`format`] is used instead
///
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be `VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO`
/// - [`p_next`] **must**  be `NULL`
/// - [`flags`] **must**  be `0`
/// - [`buffer`] **must**  be a valid [`Buffer`] handle
/// - [`format`] **must**  be a valid [`Format`] value
///# Related
/// - [`crate::vulkan1_0`]
/// - [`Buffer`]
/// - [`BufferViewCreateFlags`]
/// - [`DeviceSize`]
/// - [`Format`]
/// - [`StructureType`]
/// - [`CreateBufferView`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[repr(C)]
pub struct BufferViewCreateInfo<'lt> {
    _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] is the type of this structure.
    s_type: StructureType,
    ///[`p_next`] is `NULL` or a pointer to a structure extending this
    ///structure.
    p_next: *const BaseInStructure<'lt>,
    ///[`flags`] is reserved for future use.
    flags: BufferViewCreateFlags,
    ///[`buffer`] is a [`Buffer`] on which the view will be created.
    buffer: Buffer,
    ///[`format`] is a [`Format`] describing the format of the data
    ///elements in the buffer.
    format: Format,
    ///[`offset`] is an offset in bytes from the base address of the buffer.
    ///Accesses to the buffer view from shaders use addressing that is relative
    ///to this starting offset.
    offset: DeviceSize,
    ///[`range`] is a size in bytes of the buffer view.
    ///If [`range`] is equal to [`WHOLE_SIZE`], the range from
    ///[`offset`] to the end of the buffer is used.
    ///If [`WHOLE_SIZE`] is used and the remaining size of the buffer is
    ///not a multiple of the [texel block size](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#texel-block-size) of
    ///[`format`], the nearest smaller multiple is used.
    range: DeviceSize,
}
impl<'lt> Default for BufferViewCreateInfo<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: Default::default(),
            p_next: std::ptr::null(),
            flags: Default::default(),
            buffer: Default::default(),
            format: Default::default(),
            offset: Default::default(),
            range: Default::default(),
        }
    }
}
impl<'lt> BufferViewCreateInfo<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *const BaseInStructure<'lt> {
        self.p_next
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *const BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseInStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::flags`]
    pub fn flags(&self) -> BufferViewCreateFlags {
        self.flags
    }
    ///Gets the value of [`Self::buffer`]
    pub fn buffer(&self) -> Buffer {
        self.buffer
    }
    ///Gets the value of [`Self::format`]
    pub fn format(&self) -> Format {
        self.format
    }
    ///Gets the value of [`Self::offset`]
    pub fn offset(&self) -> DeviceSize {
        self.offset
    }
    ///Gets the value of [`Self::range`]
    pub fn range(&self) -> DeviceSize {
        self.range
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::flags`]
    pub fn flags_mut(&mut self) -> &mut BufferViewCreateFlags {
        &mut self.flags
    }
    ///Gets a mutable reference to the value of [`Self::buffer`]
    pub fn buffer_mut(&mut self) -> &mut Buffer {
        &mut self.buffer
    }
    ///Gets a mutable reference to the value of [`Self::format`]
    pub fn format_mut(&mut self) -> &mut Format {
        &mut self.format
    }
    ///Gets a mutable reference to the value of [`Self::offset`]
    pub fn offset_mut(&mut self) -> &mut DeviceSize {
        &mut self.offset
    }
    ///Gets a mutable reference to the value of [`Self::range`]
    pub fn range_mut(&mut self) -> &mut DeviceSize {
        &mut self.range
    }
    ///Sets the raw value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the raw value of [`Self::flags`]
    pub fn set_flags(&mut self, value: crate::vulkan1_0::BufferViewCreateFlags) -> &mut Self {
        self.flags = value;
        self
    }
    ///Sets the raw value of [`Self::buffer`]
    pub fn set_buffer(&mut self, value: crate::vulkan1_0::Buffer) -> &mut Self {
        self.buffer = value;
        self
    }
    ///Sets the raw value of [`Self::format`]
    pub fn set_format(&mut self, value: crate::vulkan1_0::Format) -> &mut Self {
        self.format = value;
        self
    }
    ///Sets the raw value of [`Self::offset`]
    pub fn set_offset(&mut self, value: crate::vulkan1_0::DeviceSize) -> &mut Self {
        self.offset = value;
        self
    }
    ///Sets the raw value of [`Self::range`]
    pub fn set_range(&mut self, value: crate::vulkan1_0::DeviceSize) -> &mut Self {
        self.range = value;
        self
    }
}
///[VkImageSubresource](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageSubresource.html) - Structure specifying an image subresource
///# C Specifications
///The [`ImageSubresource`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkImageSubresource {
///    VkImageAspectFlags    aspectMask;
///    uint32_t              mipLevel;
///    uint32_t              arrayLayer;
///} VkImageSubresource;
///```
///# Members
/// - [`aspect_mask`] is a [`ImageAspectFlags`] value selecting the image *aspect*.
/// - [`mip_level`] selects the mipmap level.
/// - [`array_layer`] selects the array layer.
///# Description
///## Valid Usage (Implicit)
/// - [`aspect_mask`] **must**  be a valid combination of [`ImageAspectFlagBits`] values
/// - [`aspect_mask`] **must**  not be `0`
///# Related
/// - [`crate::vulkan1_0`]
/// - [`ImageAspectFlags`]
/// - [`SparseImageMemoryBind`]
/// - [`GetImageSubresourceLayout`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct ImageSubresource {
    ///[`aspect_mask`] is a [`ImageAspectFlags`] value selecting the image
    ///*aspect*.
    aspect_mask: ImageAspectFlags,
    ///[`mip_level`] selects the mipmap level.
    mip_level: u32,
    ///[`array_layer`] selects the array layer.
    array_layer: u32,
}
impl Default for ImageSubresource {
    fn default() -> Self {
        Self {
            aspect_mask: Default::default(),
            mip_level: 0,
            array_layer: 0,
        }
    }
}
impl ImageSubresource {
    ///Gets the value of [`Self::aspect_mask`]
    pub fn aspect_mask(&self) -> ImageAspectFlags {
        self.aspect_mask
    }
    ///Gets the value of [`Self::mip_level`]
    pub fn mip_level(&self) -> u32 {
        self.mip_level
    }
    ///Gets the value of [`Self::array_layer`]
    pub fn array_layer(&self) -> u32 {
        self.array_layer
    }
    ///Gets a mutable reference to the value of [`Self::aspect_mask`]
    pub fn aspect_mask_mut(&mut self) -> &mut ImageAspectFlags {
        &mut self.aspect_mask
    }
    ///Gets a mutable reference to the value of [`Self::mip_level`]
    pub fn mip_level_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::array_layer`]
    pub fn array_layer_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Sets the raw value of [`Self::aspect_mask`]
    pub fn set_aspect_mask(&mut self, value: crate::vulkan1_0::ImageAspectFlags) -> &mut Self {
        self.aspect_mask = value;
        self
    }
    ///Sets the raw value of [`Self::mip_level`]
    pub fn set_mip_level(&mut self, value: u32) -> &mut Self {
        self.mip_level = value;
        self
    }
    ///Sets the raw value of [`Self::array_layer`]
    pub fn set_array_layer(&mut self, value: u32) -> &mut Self {
        self.array_layer = value;
        self
    }
}
///[VkImageSubresourceLayers](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageSubresourceLayers.html) - Structure specifying an image subresource layers
///# C Specifications
///The [`ImageSubresourceLayers`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkImageSubresourceLayers {
///    VkImageAspectFlags    aspectMask;
///    uint32_t              mipLevel;
///    uint32_t              baseArrayLayer;
///    uint32_t              layerCount;
///} VkImageSubresourceLayers;
///```
///# Members
/// - [`aspect_mask`] is a combination of [`ImageAspectFlagBits`], selecting the color, depth and/or
///   stencil aspects to be copied.
/// - [`mip_level`] is the mipmap level to copy
/// - [`base_array_layer`] and [`layer_count`] are the starting layer and number of layers to copy.
///# Description
///## Valid Usage
/// - If [`aspect_mask`] contains `VK_IMAGE_ASPECT_COLOR_BIT`, it  **must**  not contain either of
///   `VK_IMAGE_ASPECT_DEPTH_BIT` or `VK_IMAGE_ASPECT_STENCIL_BIT`
/// - [`aspect_mask`] **must**  not contain `VK_IMAGE_ASPECT_METADATA_BIT`
/// - [`aspect_mask`] **must**  not include `VK_IMAGE_ASPECT_MEMORY_PLANE*_i_*BIT_EXT` for any index
///   *i*
/// - [`layer_count`] **must**  be greater than 0
///
///## Valid Usage (Implicit)
/// - [`aspect_mask`] **must**  be a valid combination of [`ImageAspectFlagBits`] values
/// - [`aspect_mask`] **must**  not be `0`
///# Related
/// - [`crate::vulkan1_0`]
/// - [`BufferImageCopy`]
/// - [`BufferImageCopy2`]
/// - [`ImageAspectFlags`]
/// - [`ImageBlit`]
/// - [`ImageBlit2`]
/// - [`ImageCopy`]
/// - [`ImageCopy2`]
/// - [`ImageResolve`]
/// - [`ImageResolve2`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct ImageSubresourceLayers {
    ///[`aspect_mask`] is a combination of [`ImageAspectFlagBits`],
    ///selecting the color, depth and/or stencil aspects to be copied.
    aspect_mask: ImageAspectFlags,
    ///[`mip_level`] is the mipmap level to copy
    mip_level: u32,
    ///[`base_array_layer`] and [`layer_count`] are the starting layer and
    ///number of layers to copy.
    base_array_layer: u32,
    ///No documentation found
    layer_count: u32,
}
impl Default for ImageSubresourceLayers {
    fn default() -> Self {
        Self {
            aspect_mask: Default::default(),
            mip_level: 0,
            base_array_layer: 0,
            layer_count: 0,
        }
    }
}
impl ImageSubresourceLayers {
    ///Gets the value of [`Self::aspect_mask`]
    pub fn aspect_mask(&self) -> ImageAspectFlags {
        self.aspect_mask
    }
    ///Gets the value of [`Self::mip_level`]
    pub fn mip_level(&self) -> u32 {
        self.mip_level
    }
    ///Gets the value of [`Self::base_array_layer`]
    pub fn base_array_layer(&self) -> u32 {
        self.base_array_layer
    }
    ///Gets the value of [`Self::layer_count`]
    pub fn layer_count(&self) -> u32 {
        self.layer_count
    }
    ///Gets a mutable reference to the value of [`Self::aspect_mask`]
    pub fn aspect_mask_mut(&mut self) -> &mut ImageAspectFlags {
        &mut self.aspect_mask
    }
    ///Gets a mutable reference to the value of [`Self::mip_level`]
    pub fn mip_level_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::base_array_layer`]
    pub fn base_array_layer_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::layer_count`]
    pub fn layer_count_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Sets the raw value of [`Self::aspect_mask`]
    pub fn set_aspect_mask(&mut self, value: crate::vulkan1_0::ImageAspectFlags) -> &mut Self {
        self.aspect_mask = value;
        self
    }
    ///Sets the raw value of [`Self::mip_level`]
    pub fn set_mip_level(&mut self, value: u32) -> &mut Self {
        self.mip_level = value;
        self
    }
    ///Sets the raw value of [`Self::base_array_layer`]
    pub fn set_base_array_layer(&mut self, value: u32) -> &mut Self {
        self.base_array_layer = value;
        self
    }
    ///Sets the raw value of [`Self::layer_count`]
    pub fn set_layer_count(&mut self, value: u32) -> &mut Self {
        self.layer_count = value;
        self
    }
}
///[VkImageSubresourceRange](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageSubresourceRange.html) - Structure specifying an image subresource range
///# C Specifications
///The [`ImageSubresourceRange`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkImageSubresourceRange {
///    VkImageAspectFlags    aspectMask;
///    uint32_t              baseMipLevel;
///    uint32_t              levelCount;
///    uint32_t              baseArrayLayer;
///    uint32_t              layerCount;
///} VkImageSubresourceRange;
///```
///# Members
/// - [`aspect_mask`] is a bitmask of [`ImageAspectFlagBits`] specifying which aspect(s) of the
///   image are included in the view.
/// - [`base_mip_level`] is the first mipmap level accessible to the view.
/// - [`level_count`] is the number of mipmap levels (starting from [`base_mip_level`]) accessible
///   to the view.
/// - [`base_array_layer`] is the first array layer accessible to the view.
/// - [`layer_count`] is the number of array layers (starting from [`base_array_layer`]) accessible
///   to the view.
///# Description
///The number of mipmap levels and array layers  **must**  be a subset of the image
///subresources in the image.
///If an application wants to use all mip levels or layers in an image after
///the [`base_mip_level`] or [`base_array_layer`], it  **can**  set [`level_count`]
///and [`layer_count`] to the special values [`REMAINING_MIP_LEVELS`] and
///[`REMAINING_ARRAY_LAYERS`] without knowing the exact number of mip
///levels or layers.For cube and cube array image views, the layers of the image view starting
///at [`base_array_layer`] correspond to faces in the order +X, -X, +Y, -Y, +Z,
///-Z.
///For cube arrays, each set of six sequential layers is a single cube, so the
///number of cube maps in a cube map array view is *[`layer_count`] / 6*, and
///image array layer ([`base_array_layer`] +  i) is face index
///(i mod 6) of cube *i / 6*.
///If the number of layers in the view, whether set explicitly in
///[`layer_count`] or implied by [`REMAINING_ARRAY_LAYERS`], is not a
///multiple of 6, the last cube map in the array  **must**  not be accessed.[`aspect_mask`]
/// **must**  be only `VK_IMAGE_ASPECT_COLOR_BIT`,
///`VK_IMAGE_ASPECT_DEPTH_BIT` or `VK_IMAGE_ASPECT_STENCIL_BIT` if
///`format` is a color, depth-only or stencil-only format,
///respectively, except if `format` is a
///[multi-planar format](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#formats-requiring-sampler-ycbcr-conversion).
///If using a depth/stencil format with both depth and stencil components,
///[`aspect_mask`] **must**  include at least one of
///`VK_IMAGE_ASPECT_DEPTH_BIT` and `VK_IMAGE_ASPECT_STENCIL_BIT`, and
/// **can**  include both.When the [`ImageSubresourceRange`] structure is used to select a subset
///of the slices of a 3D image’s mip level in order to create a 2D or 2D array
///image view of a 3D image created with
///`VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT`, [`base_array_layer`] and
///[`layer_count`] specify the first slice index and the number of slices to
///include in the created image view.
///Such an image view  **can**  be used as a framebuffer attachment that refers only
///to the specified range of slices of the selected mip level.
///However, any layout transitions performed on such an attachment view during
///a render pass instance still apply to the entire subresource referenced
///which includes all the slices of the selected mip level.When using an image view of a
/// depth/stencil image to populate a descriptor
///set (e.g. for sampling in the shader, or for use as an input attachment),
///the [`aspect_mask`] **must**  only include one bit, which selects whether the
///image view is used for depth reads (i.e. using a floating-point sampler or
///input attachment in the shader) or stencil reads (i.e. using an unsigned
///integer sampler or input attachment in the shader).
///When an image view of a depth/stencil image is used as a depth/stencil
///framebuffer attachment, the [`aspect_mask`] is ignored and both depth and
///stencil image subresources are used.When creating a [`ImageView`], if [sampler
///Y′C<sub>B</sub>C<sub>R</sub> conversion](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#samplers-YCbCr-conversion) is enabled in the sampler, the [`aspect_mask`] of a
///`subresourceRange` used by the [`ImageView`] **must**  be
///`VK_IMAGE_ASPECT_COLOR_BIT`.When creating a [`ImageView`], if sampler
/// Y′C<sub>B</sub>C<sub>R</sub> conversion is not
///enabled in the sampler and the image `format` is
///[multi-planar](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#formats-requiring-sampler-ycbcr-conversion), the image  **must**
///have been created with `VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT`, and the
///[`aspect_mask`] of the [`ImageView`]’s `subresourceRange` **must**  be
///`VK_IMAGE_ASPECT_PLANE_0_BIT`, `VK_IMAGE_ASPECT_PLANE_1_BIT` or
///`VK_IMAGE_ASPECT_PLANE_2_BIT`.
///## Valid Usage
/// - If [`level_count`] is not [`REMAINING_MIP_LEVELS`], it  **must**  be greater than `0`
/// - If [`layer_count`] is not [`REMAINING_ARRAY_LAYERS`], it  **must**  be greater than `0`
/// - If [`aspect_mask`] includes `VK_IMAGE_ASPECT_COLOR_BIT`, then it  **must**  not include any of
///   `VK_IMAGE_ASPECT_PLANE_0_BIT`, `VK_IMAGE_ASPECT_PLANE_1_BIT`, or `VK_IMAGE_ASPECT_PLANE_2_BIT`
/// - [`aspect_mask`] **must**  not include `VK_IMAGE_ASPECT_MEMORY_PLANE*_i_*BIT_EXT` for any index
///   *i*
///
///## Valid Usage (Implicit)
/// - [`aspect_mask`] **must**  be a valid combination of [`ImageAspectFlagBits`] values
/// - [`aspect_mask`] **must**  not be `0`
///# Related
/// - [`crate::vulkan1_0`]
/// - [`ImageAspectFlags`]
/// - [`ImageMemoryBarrier`]
/// - [`ImageMemoryBarrier2`]
/// - [`ImageViewCreateInfo`]
/// - [`CmdClearColorImage`]
/// - [`CmdClearDepthStencilImage`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct ImageSubresourceRange {
    ///[`aspect_mask`] is a bitmask of [`ImageAspectFlagBits`] specifying
    ///which aspect(s) of the image are included in the view.
    aspect_mask: ImageAspectFlags,
    ///[`base_mip_level`] is the first mipmap level accessible to the view.
    base_mip_level: u32,
    ///[`level_count`] is the number of mipmap levels (starting from
    ///[`base_mip_level`]) accessible to the view.
    level_count: u32,
    ///[`base_array_layer`] is the first array layer accessible to the view.
    base_array_layer: u32,
    ///[`layer_count`] is the number of array layers (starting from
    ///[`base_array_layer`]) accessible to the view.
    layer_count: u32,
}
impl Default for ImageSubresourceRange {
    fn default() -> Self {
        Self {
            aspect_mask: Default::default(),
            base_mip_level: 0,
            level_count: 0,
            base_array_layer: 0,
            layer_count: 0,
        }
    }
}
impl ImageSubresourceRange {
    ///Gets the value of [`Self::aspect_mask`]
    pub fn aspect_mask(&self) -> ImageAspectFlags {
        self.aspect_mask
    }
    ///Gets the value of [`Self::base_mip_level`]
    pub fn base_mip_level(&self) -> u32 {
        self.base_mip_level
    }
    ///Gets the value of [`Self::level_count`]
    pub fn level_count(&self) -> u32 {
        self.level_count
    }
    ///Gets the value of [`Self::base_array_layer`]
    pub fn base_array_layer(&self) -> u32 {
        self.base_array_layer
    }
    ///Gets the value of [`Self::layer_count`]
    pub fn layer_count(&self) -> u32 {
        self.layer_count
    }
    ///Gets a mutable reference to the value of [`Self::aspect_mask`]
    pub fn aspect_mask_mut(&mut self) -> &mut ImageAspectFlags {
        &mut self.aspect_mask
    }
    ///Gets a mutable reference to the value of [`Self::base_mip_level`]
    pub fn base_mip_level_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::level_count`]
    pub fn level_count_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::base_array_layer`]
    pub fn base_array_layer_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::layer_count`]
    pub fn layer_count_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Sets the raw value of [`Self::aspect_mask`]
    pub fn set_aspect_mask(&mut self, value: crate::vulkan1_0::ImageAspectFlags) -> &mut Self {
        self.aspect_mask = value;
        self
    }
    ///Sets the raw value of [`Self::base_mip_level`]
    pub fn set_base_mip_level(&mut self, value: u32) -> &mut Self {
        self.base_mip_level = value;
        self
    }
    ///Sets the raw value of [`Self::level_count`]
    pub fn set_level_count(&mut self, value: u32) -> &mut Self {
        self.level_count = value;
        self
    }
    ///Sets the raw value of [`Self::base_array_layer`]
    pub fn set_base_array_layer(&mut self, value: u32) -> &mut Self {
        self.base_array_layer = value;
        self
    }
    ///Sets the raw value of [`Self::layer_count`]
    pub fn set_layer_count(&mut self, value: u32) -> &mut Self {
        self.layer_count = value;
        self
    }
}
///[VkMemoryBarrier](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryBarrier.html) - Structure specifying a global memory barrier
///# C Specifications
///The [`MemoryBarrier`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkMemoryBarrier {
///    VkStructureType    sType;
///    const void*        pNext;
///    VkAccessFlags      srcAccessMask;
///    VkAccessFlags      dstAccessMask;
///} VkMemoryBarrier;
///```
///# Members
/// - [`s_type`] is the type of this structure.
/// - [`p_next`] is `NULL` or a pointer to a structure extending this structure.
/// - [`src_access_mask`] is a bitmask of [`AccessFlagBits`] specifying a [source access mask](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-access-masks).
/// - [`dst_access_mask`] is a bitmask of [`AccessFlagBits`] specifying a [destination access mask](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-access-masks).
///# Description
///The first [access scope](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-dependencies-access-scopes) is
///limited to access types in the [source access
///mask](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-access-masks) specified by [`src_access_mask`].The second [access scope](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-dependencies-access-scopes) is
///limited to access types in the [destination
///access mask](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-access-masks) specified by [`dst_access_mask`].
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be `VK_STRUCTURE_TYPE_MEMORY_BARRIER`
/// - [`p_next`] **must**  be `NULL`
/// - [`src_access_mask`] **must**  be a valid combination of [`AccessFlagBits`] values
/// - [`dst_access_mask`] **must**  be a valid combination of [`AccessFlagBits`] values
///# Related
/// - [`crate::vulkan1_0`]
/// - [`AccessFlags`]
/// - [`StructureType`]
/// - [`CmdPipelineBarrier`]
/// - [`CmdWaitEvents`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[repr(C)]
pub struct MemoryBarrier<'lt> {
    _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] is the type of this structure.
    s_type: StructureType,
    ///[`p_next`] is `NULL` or a pointer to a structure extending this
    ///structure.
    p_next: *const BaseInStructure<'lt>,
    ///[`src_access_mask`] is a bitmask of [`AccessFlagBits`] specifying a
    ///[source access mask](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-access-masks).
    src_access_mask: AccessFlags,
    ///[`dst_access_mask`] is a bitmask of [`AccessFlagBits`] specifying a
    ///[destination access mask](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-access-masks).
    dst_access_mask: AccessFlags,
}
impl<'lt> Default for MemoryBarrier<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: Default::default(),
            p_next: std::ptr::null(),
            src_access_mask: Default::default(),
            dst_access_mask: Default::default(),
        }
    }
}
impl<'lt> MemoryBarrier<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *const BaseInStructure<'lt> {
        self.p_next
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *const BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseInStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::src_access_mask`]
    pub fn src_access_mask(&self) -> AccessFlags {
        self.src_access_mask
    }
    ///Gets the value of [`Self::dst_access_mask`]
    pub fn dst_access_mask(&self) -> AccessFlags {
        self.dst_access_mask
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::src_access_mask`]
    pub fn src_access_mask_mut(&mut self) -> &mut AccessFlags {
        &mut self.src_access_mask
    }
    ///Gets a mutable reference to the value of [`Self::dst_access_mask`]
    pub fn dst_access_mask_mut(&mut self) -> &mut AccessFlags {
        &mut self.dst_access_mask
    }
    ///Sets the raw value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the raw value of [`Self::src_access_mask`]
    pub fn set_src_access_mask(&mut self, value: crate::vulkan1_0::AccessFlags) -> &mut Self {
        self.src_access_mask = value;
        self
    }
    ///Sets the raw value of [`Self::dst_access_mask`]
    pub fn set_dst_access_mask(&mut self, value: crate::vulkan1_0::AccessFlags) -> &mut Self {
        self.dst_access_mask = value;
        self
    }
}
///[VkBufferMemoryBarrier](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferMemoryBarrier.html) - Structure specifying a buffer memory barrier
///# C Specifications
///The [`BufferMemoryBarrier`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkBufferMemoryBarrier {
///    VkStructureType    sType;
///    const void*        pNext;
///    VkAccessFlags      srcAccessMask;
///    VkAccessFlags      dstAccessMask;
///    uint32_t           srcQueueFamilyIndex;
///    uint32_t           dstQueueFamilyIndex;
///    VkBuffer           buffer;
///    VkDeviceSize       offset;
///    VkDeviceSize       size;
///} VkBufferMemoryBarrier;
///```
///# Members
/// - [`s_type`] is the type of this structure.
/// - [`p_next`] is `NULL` or a pointer to a structure extending this structure.
/// - [`src_access_mask`] is a bitmask of [`AccessFlagBits`] specifying a [source access mask](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-access-masks).
/// - [`dst_access_mask`] is a bitmask of [`AccessFlagBits`] specifying a [destination access mask](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-access-masks).
/// - [`src_queue_family_index`] is the source queue family for a [queue family ownership transfer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-queue-transfers).
/// - [`dst_queue_family_index`] is the destination queue family for a [queue family ownership transfer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-queue-transfers).
/// - [`buffer`] is a handle to the buffer whose backing memory is affected by the barrier.
/// - [`offset`] is an offset in bytes into the backing memory for [`buffer`]; this is relative to
///   the base offset as bound to the buffer (see [`BindBufferMemory`]).
/// - [`size`] is a size in bytes of the affected area of backing memory for [`buffer`], or
///   [`WHOLE_SIZE`] to use the range from [`offset`] to the end of the buffer.
///# Description
///The first [access scope](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-dependencies-access-scopes) is
///limited to access to memory through the specified buffer range, via access
///types in the [source access mask](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-access-masks) specified
///by [`src_access_mask`].
///If [`src_access_mask`] includes `VK_ACCESS_HOST_WRITE_BIT`, memory
///writes performed by that access type are also made visible, as that access
///type is not performed through a resource.The second [access scope](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-dependencies-access-scopes) is
///limited to access to memory through the specified buffer range, via access
///types in the [destination access mask](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-access-masks)
///specified by [`dst_access_mask`].
///If [`dst_access_mask`] includes `VK_ACCESS_HOST_WRITE_BIT` or
///`VK_ACCESS_HOST_READ_BIT`, available memory writes are also made visible
///to accesses of those types, as those access types are not performed through
///a resource.If [`src_queue_family_index`] is not equal to [`dst_queue_family_index`], and
///[`src_queue_family_index`] is equal to the current queue family, then the
///memory barrier defines a [queue
///family release operation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-queue-transfers-release) for the specified buffer range, and the second
///access scope includes no access, as if [`dst_access_mask`] was `0`.If [`dst_queue_family_index`]
/// is not equal to [`src_queue_family_index`], and
///[`dst_queue_family_index`] is equal to the current queue family, then the
///memory barrier defines a [queue
///family acquire operation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-queue-transfers-acquire) for the specified buffer range, and the first
///access scope includes no access, as if [`src_access_mask`] was `0`.
///## Valid Usage
/// - [`offset`] **must**  be less than the size of [`buffer`]
/// - If [`size`] is not equal to [`WHOLE_SIZE`], [`size`] **must**  be greater than `0`
/// - If [`size`] is not equal to [`WHOLE_SIZE`], [`size`] **must**  be less than or equal to than
///   the size of [`buffer`] minus [`offset`]
/// - If [`buffer`] is non-sparse then it  **must**  be bound completely and contiguously to a
///   single [`DeviceMemory`] object
/// -    If [`src_queue_family_index`] is not equal to [`dst_queue_family_index`], at least one  **must**  not be a special queue family reserved for external memory ownership transfers, as described in [[synchronization-queue-transfers]](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#synchronization-queue-transfers)
/// - If [`buffer`] was created with a sharing mode of `VK_SHARING_MODE_CONCURRENT`,
///   [`src_queue_family_index`] and [`dst_queue_family_index`] are not equal, and one of
///   [`src_queue_family_index`] and [`dst_queue_family_index`] is one of the special queue family
///   values reserved for external memory transfers, the other  **must**  be
///   [`QUEUE_FAMILY_IGNORED`]
/// -    If [`buffer`] was created with a sharing mode of `VK_SHARING_MODE_EXCLUSIVE`, and [`src_queue_family_index`] and [`dst_queue_family_index`] are not equal, [`src_queue_family_index`] and [`dst_queue_family_index`] **must**  both be valid queue families, or one of the special queue family values reserved for external memory transfers, as described in [[synchronization-queue-transfers]](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#synchronization-queue-transfers)
/// - If the [`synchronization2` feature](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-synchronization2)
///   is not enabled, and [`buffer`] was created with a sharing mode of
///   `VK_SHARING_MODE_CONCURRENT`, at least one of [`src_queue_family_index`] and
///   [`dst_queue_family_index`] **must**  be [`QUEUE_FAMILY_IGNORED`]
///
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be `VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER`
/// - [`p_next`] **must**  be `NULL`
/// - [`buffer`] **must**  be a valid [`Buffer`] handle
///# Related
/// - [`crate::vulkan1_0`]
/// - [`AccessFlags`]
/// - [`Buffer`]
/// - [`DeviceSize`]
/// - [`StructureType`]
/// - [`CmdPipelineBarrier`]
/// - [`CmdWaitEvents`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[repr(C)]
pub struct BufferMemoryBarrier<'lt> {
    _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] is the type of this structure.
    s_type: StructureType,
    ///[`p_next`] is `NULL` or a pointer to a structure extending this
    ///structure.
    p_next: *const BaseInStructure<'lt>,
    ///[`src_access_mask`] is a bitmask of [`AccessFlagBits`] specifying a
    ///[source access mask](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-access-masks).
    src_access_mask: AccessFlags,
    ///[`dst_access_mask`] is a bitmask of [`AccessFlagBits`] specifying a
    ///[destination access mask](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-access-masks).
    dst_access_mask: AccessFlags,
    ///[`src_queue_family_index`] is the source queue family for a
    ///[queue family ownership transfer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-queue-transfers).
    src_queue_family_index: u32,
    ///[`dst_queue_family_index`] is the destination queue family for a
    ///[queue family ownership transfer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-queue-transfers).
    dst_queue_family_index: u32,
    ///[`buffer`] is a handle to the buffer whose backing memory is affected
    ///by the barrier.
    buffer: Buffer,
    ///[`offset`] is an offset in bytes into the backing memory for
    ///[`buffer`]; this is relative to the base offset as bound to the buffer
    ///(see [`BindBufferMemory`]).
    offset: DeviceSize,
    ///[`size`] is a size in bytes of the affected area of backing memory for
    ///[`buffer`], or [`WHOLE_SIZE`] to use the range from [`offset`]
    ///to the end of the buffer.
    size: DeviceSize,
}
impl<'lt> Default for BufferMemoryBarrier<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: Default::default(),
            p_next: std::ptr::null(),
            src_access_mask: Default::default(),
            dst_access_mask: Default::default(),
            src_queue_family_index: 0,
            dst_queue_family_index: 0,
            buffer: Default::default(),
            offset: Default::default(),
            size: Default::default(),
        }
    }
}
impl<'lt> BufferMemoryBarrier<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *const BaseInStructure<'lt> {
        self.p_next
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *const BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseInStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::src_access_mask`]
    pub fn src_access_mask(&self) -> AccessFlags {
        self.src_access_mask
    }
    ///Gets the value of [`Self::dst_access_mask`]
    pub fn dst_access_mask(&self) -> AccessFlags {
        self.dst_access_mask
    }
    ///Gets the value of [`Self::src_queue_family_index`]
    pub fn src_queue_family_index(&self) -> u32 {
        self.src_queue_family_index
    }
    ///Gets the value of [`Self::dst_queue_family_index`]
    pub fn dst_queue_family_index(&self) -> u32 {
        self.dst_queue_family_index
    }
    ///Gets the value of [`Self::buffer`]
    pub fn buffer(&self) -> Buffer {
        self.buffer
    }
    ///Gets the value of [`Self::offset`]
    pub fn offset(&self) -> DeviceSize {
        self.offset
    }
    ///Gets the value of [`Self::size`]
    pub fn size(&self) -> DeviceSize {
        self.size
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::src_access_mask`]
    pub fn src_access_mask_mut(&mut self) -> &mut AccessFlags {
        &mut self.src_access_mask
    }
    ///Gets a mutable reference to the value of [`Self::dst_access_mask`]
    pub fn dst_access_mask_mut(&mut self) -> &mut AccessFlags {
        &mut self.dst_access_mask
    }
    ///Gets a mutable reference to the value of [`Self::src_queue_family_index`]
    pub fn src_queue_family_index_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::dst_queue_family_index`]
    pub fn dst_queue_family_index_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::buffer`]
    pub fn buffer_mut(&mut self) -> &mut Buffer {
        &mut self.buffer
    }
    ///Gets a mutable reference to the value of [`Self::offset`]
    pub fn offset_mut(&mut self) -> &mut DeviceSize {
        &mut self.offset
    }
    ///Gets a mutable reference to the value of [`Self::size`]
    pub fn size_mut(&mut self) -> &mut DeviceSize {
        &mut self.size
    }
    ///Sets the raw value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the raw value of [`Self::src_access_mask`]
    pub fn set_src_access_mask(&mut self, value: crate::vulkan1_0::AccessFlags) -> &mut Self {
        self.src_access_mask = value;
        self
    }
    ///Sets the raw value of [`Self::dst_access_mask`]
    pub fn set_dst_access_mask(&mut self, value: crate::vulkan1_0::AccessFlags) -> &mut Self {
        self.dst_access_mask = value;
        self
    }
    ///Sets the raw value of [`Self::src_queue_family_index`]
    pub fn set_src_queue_family_index(&mut self, value: u32) -> &mut Self {
        self.src_queue_family_index = value;
        self
    }
    ///Sets the raw value of [`Self::dst_queue_family_index`]
    pub fn set_dst_queue_family_index(&mut self, value: u32) -> &mut Self {
        self.dst_queue_family_index = value;
        self
    }
    ///Sets the raw value of [`Self::buffer`]
    pub fn set_buffer(&mut self, value: crate::vulkan1_0::Buffer) -> &mut Self {
        self.buffer = value;
        self
    }
    ///Sets the raw value of [`Self::offset`]
    pub fn set_offset(&mut self, value: crate::vulkan1_0::DeviceSize) -> &mut Self {
        self.offset = value;
        self
    }
    ///Sets the raw value of [`Self::size`]
    pub fn set_size(&mut self, value: crate::vulkan1_0::DeviceSize) -> &mut Self {
        self.size = value;
        self
    }
}
///[VkImageMemoryBarrier](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageMemoryBarrier.html) - Structure specifying the parameters of an image memory barrier
///# C Specifications
///The [`ImageMemoryBarrier`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkImageMemoryBarrier {
///    VkStructureType            sType;
///    const void*                pNext;
///    VkAccessFlags              srcAccessMask;
///    VkAccessFlags              dstAccessMask;
///    VkImageLayout              oldLayout;
///    VkImageLayout              newLayout;
///    uint32_t                   srcQueueFamilyIndex;
///    uint32_t                   dstQueueFamilyIndex;
///    VkImage                    image;
///    VkImageSubresourceRange    subresourceRange;
///} VkImageMemoryBarrier;
///```
///# Members
/// - [`s_type`] is the type of this structure.
/// - [`p_next`] is `NULL` or a pointer to a structure extending this structure.
/// - [`src_access_mask`] is a bitmask of [`AccessFlagBits`] specifying a [source access mask](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-access-masks).
/// - [`dst_access_mask`] is a bitmask of [`AccessFlagBits`] specifying a [destination access mask](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-access-masks).
/// - [`old_layout`] is the old layout in an [image layout transition](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-image-layout-transitions).
/// - [`new_layout`] is the new layout in an [image layout transition](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-image-layout-transitions).
/// - [`src_queue_family_index`] is the source queue family for a [queue family ownership transfer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-queue-transfers).
/// - [`dst_queue_family_index`] is the destination queue family for a [queue family ownership transfer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-queue-transfers).
/// - [`image`] is a handle to the image affected by this barrier.
/// - [`subresource_range`] describes the [image subresource range](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#resources-image-views)
///   within [`image`] that is affected by this barrier.
///# Description
///The first [access scope](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-dependencies-access-scopes) is
///limited to access to memory through the specified image subresource range,
///via access types in the [source access mask](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-access-masks)
///specified by [`src_access_mask`].
///If [`src_access_mask`] includes `VK_ACCESS_HOST_WRITE_BIT`, memory
///writes performed by that access type are also made visible, as that access
///type is not performed through a resource.The second [access scope](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-dependencies-access-scopes) is
///limited to access to memory through the specified image subresource range,
///via access types in the [destination access
///mask](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-access-masks) specified by [`dst_access_mask`].
///If [`dst_access_mask`] includes `VK_ACCESS_HOST_WRITE_BIT` or
///`VK_ACCESS_HOST_READ_BIT`, available memory writes are also made visible
///to accesses of those types, as those access types are not performed through
///a resource.If [`src_queue_family_index`] is not equal to [`dst_queue_family_index`], and
///[`src_queue_family_index`] is equal to the current queue family, then the
///memory barrier defines a [queue
///family release operation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-queue-transfers-release) for the specified image subresource range, and
///the second access scope includes no access, as if [`dst_access_mask`] was
///`0`.If [`dst_queue_family_index`] is not equal to [`src_queue_family_index`], and
///[`dst_queue_family_index`] is equal to the current queue family, then the
///memory barrier defines a [queue
///family acquire operation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-queue-transfers-acquire) for the specified image subresource range, and
///the first access scope includes no access, as if [`src_access_mask`] was
///`0`.If the [`synchronization2` feature](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-synchronization2) is not
///enabled or [`old_layout`] is not equal to [`new_layout`],
///[`old_layout`] and [`new_layout`] define an
///[image layout transition](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-image-layout-transitions) for
///the specified image subresource range.If [`image`] has a multi-planar format and the image is
/// *disjoint*, then
///including `VK_IMAGE_ASPECT_COLOR_BIT` in the `aspectMask` member of
///[`subresource_range`] is equivalent to including
///`VK_IMAGE_ASPECT_PLANE_0_BIT`, `VK_IMAGE_ASPECT_PLANE_1_BIT`, and
///(for three-plane formats only) `VK_IMAGE_ASPECT_PLANE_2_BIT`.
///## Valid Usage
/// - `subresourceRange.baseMipLevel` **must**  be less than the `mipLevels` specified in
///   [`ImageCreateInfo`] when [`image`] was created
/// - If `subresourceRange.levelCount` is not [`REMAINING_MIP_LEVELS`],
///   `subresourceRange.baseMipLevel` +  `subresourceRange.levelCount` **must**  be less than or
///   equal to the `mipLevels` specified in [`ImageCreateInfo`] when [`image`] was created
/// - `subresourceRange.baseArrayLayer` **must**  be less than the `arrayLayers` specified in
///   [`ImageCreateInfo`] when [`image`] was created
/// - If `subresourceRange.layerCount` is not [`REMAINING_ARRAY_LAYERS`],
///   `subresourceRange.baseArrayLayer` +  `subresourceRange.layerCount` **must**  be less than or
///   equal to the `arrayLayers` specified in [`ImageCreateInfo`] when [`image`] was created
/// - If [`image`] is non-sparse then it  **must**  be bound completely and contiguously to a single
///   [`DeviceMemory`] object
/// - If [`src_queue_family_index`] and [`dst_queue_family_index`] define a [queue family ownership transfer](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#synchronization-queue-transfers)
///   or [`old_layout`] and [`new_layout`] define an [image layout transition](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#synchronization-image-layout-transitions),
///   and [`old_layout`] or [`new_layout`] is `VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL` then
///   [`image`] **must**  have been created with `VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT`
/// - If [`src_queue_family_index`] and [`dst_queue_family_index`] define a [queue family ownership transfer](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#synchronization-queue-transfers)
///   or [`old_layout`] and [`new_layout`] define an [image layout transition](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#synchronization-image-layout-transitions),
///   and [`old_layout`] or [`new_layout`] is `VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL`
///   then [`image`] **must**  have been created with `VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT`
/// - If [`src_queue_family_index`] and [`dst_queue_family_index`] define a [queue family ownership transfer](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#synchronization-queue-transfers)
///   or [`old_layout`] and [`new_layout`] define an [image layout transition](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#synchronization-image-layout-transitions),
///   and [`old_layout`] or [`new_layout`] is `VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL` then
///   [`image`] **must**  have been created with `VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT`
/// - If [`src_queue_family_index`] and [`dst_queue_family_index`] define a [queue family ownership transfer](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#synchronization-queue-transfers)
///   or [`old_layout`] and [`new_layout`] define an [image layout transition](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#synchronization-image-layout-transitions),
///   and [`old_layout`] or [`new_layout`] is `VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL` then
///   [`image`] **must**  have been created with `VK_IMAGE_USAGE_SAMPLED_BIT` or
///   `VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT`
/// - If [`src_queue_family_index`] and [`dst_queue_family_index`] define a [queue family ownership transfer](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#synchronization-queue-transfers)
///   or [`old_layout`] and [`new_layout`] define an [image layout transition](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#synchronization-image-layout-transitions),
///   and [`old_layout`] or [`new_layout`] is `VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL` then [`image`]
///   **must**  have been created with `VK_IMAGE_USAGE_TRANSFER_SRC_BIT`
/// - If [`src_queue_family_index`] and [`dst_queue_family_index`] define a [queue family ownership transfer](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#synchronization-queue-transfers)
///   or [`old_layout`] and [`new_layout`] define an [image layout transition](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#synchronization-image-layout-transitions),
///   and [`old_layout`] or [`new_layout`] is `VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL` then [`image`]
///   **must**  have been created with `VK_IMAGE_USAGE_TRANSFER_DST_BIT`
/// - If [`src_queue_family_index`] and [`dst_queue_family_index`] define a [queue family ownership transfer](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#synchronization-queue-transfers)
///   or [`old_layout`] and [`new_layout`] define an [image layout transition](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#synchronization-image-layout-transitions),
///   [`old_layout`] **must**  be `VK_IMAGE_LAYOUT_UNDEFINED` or the current layout of the image
///   subresources affected by the barrier
/// - If [`src_queue_family_index`] and [`dst_queue_family_index`] define a [queue family ownership transfer](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#synchronization-queue-transfers)
///   or [`old_layout`] and [`new_layout`] define an [image layout transition](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#synchronization-image-layout-transitions),
///   [`new_layout`] **must**  not be `VK_IMAGE_LAYOUT_UNDEFINED` or
///   `VK_IMAGE_LAYOUT_PREINITIALIZED`
/// - If [`src_queue_family_index`] and [`dst_queue_family_index`] define a [queue family ownership transfer](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#synchronization-queue-transfers)
///   or [`old_layout`] and [`new_layout`] define an [image layout transition](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#synchronization-image-layout-transitions),
///   and [`old_layout`] or [`new_layout`] is
///   `VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL` then [`image`] **must**  have
///   been created with `VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT`
/// - If [`src_queue_family_index`] and [`dst_queue_family_index`] define a [queue family ownership transfer](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#synchronization-queue-transfers)
///   or [`old_layout`] and [`new_layout`] define an [image layout transition](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#synchronization-image-layout-transitions),
///   and [`old_layout`] or [`new_layout`] is
///   `VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL` then [`image`] **must**  have
///   been created with `VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT`
/// - If [`src_queue_family_index`] and [`dst_queue_family_index`] define a [queue family ownership transfer](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#synchronization-queue-transfers)
///   or [`old_layout`] and [`new_layout`] define an [image layout transition](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#synchronization-image-layout-transitions),
///   and [`old_layout`] or [`new_layout`] is `VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL` then
///   [`image`] **must**  have been created with at least one of
///   `VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT`, `VK_IMAGE_USAGE_SAMPLED_BIT`, or
///   `VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT`
/// - If [`src_queue_family_index`] and [`dst_queue_family_index`] define a [queue family ownership transfer](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#synchronization-queue-transfers)
///   or [`old_layout`] and [`new_layout`] define an [image layout transition](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#synchronization-image-layout-transitions),
///   and [`old_layout`] or [`new_layout`] is `VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL` then
///   [`image`] **must**  have been created with `VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT` set
/// - If [`src_queue_family_index`] and [`dst_queue_family_index`] define a [queue family ownership transfer](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#synchronization-queue-transfers)
///   or [`old_layout`] and [`new_layout`] define an [image layout transition](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#synchronization-image-layout-transitions),
///   and [`old_layout`] or [`new_layout`] is `VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL` then
///   [`image`] **must**  have been created with at least one of
///   `VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT`, `VK_IMAGE_USAGE_SAMPLED_BIT`, or
///   `VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT`
/// - If [`src_queue_family_index`] and [`dst_queue_family_index`] define a [queue family ownership transfer](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#synchronization-queue-transfers)
///   or [`old_layout`] and [`new_layout`] define an [image layout transition](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#synchronization-image-layout-transitions),
///   and [`old_layout`] or [`new_layout`] is `VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL` then
///   [`image`] **must**  have been created with `VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT` set
/// - If [`src_queue_family_index`] and [`dst_queue_family_index`] define a [queue family ownership transfer](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#synchronization-queue-transfers)
///   or [`old_layout`] and [`new_layout`] define an [image layout transition](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#synchronization-image-layout-transitions),
///   and [`old_layout`] or [`new_layout`] is `VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL`, [`image`]
///   **must**  have been created with `VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT` or
///   `VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT`
/// - If [`src_queue_family_index`] and [`dst_queue_family_index`] define a [queue family ownership transfer](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#synchronization-queue-transfers)
///   or [`old_layout`] and [`new_layout`] define an [image layout transition](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#synchronization-image-layout-transitions),
///   and [`old_layout`] or [`new_layout`] is `VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL`, [`image`]
///   **must**  have been created with at least one of
///   `VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT`, `VK_IMAGE_USAGE_SAMPLED_BIT`, or
///   `VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT`
/// - If [`src_queue_family_index`] and [`dst_queue_family_index`] define a [queue family ownership transfer](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#synchronization-queue-transfers)
///   or [`old_layout`] and [`new_layout`] define an [image layout transition](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#synchronization-image-layout-transitions),
///   and [`old_layout`] or [`new_layout`] is
///   `VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR` then [`image`] **must**  have
///   been created with `VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR` set
/// - If [`image`] has a single-plane color format or is not *disjoint*, then the `aspectMask`
///   member of [`subresource_range`] **must**  be `VK_IMAGE_ASPECT_COLOR_BIT`
/// - If [`image`] has a multi-planar format and the image is *disjoint*, then the `aspectMask`
///   member of [`subresource_range`] **must**  include either at least one of
///   `VK_IMAGE_ASPECT_PLANE_0_BIT`, `VK_IMAGE_ASPECT_PLANE_1_BIT`, and
///   `VK_IMAGE_ASPECT_PLANE_2_BIT`; or  **must**  include `VK_IMAGE_ASPECT_COLOR_BIT`
/// - If [`image`] has a multi-planar format with only two planes, then the `aspectMask` member of
///   [`subresource_range`] **must**  not include `VK_IMAGE_ASPECT_PLANE_2_BIT`
/// - If [`image`] has a depth/stencil format with both depth and stencil and the [separateDepthStencilLayouts](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-separateDepthStencilLayouts)
///   feature is enabled, then the `aspectMask` member of [`subresource_range`] **must**  include
///   either or both `VK_IMAGE_ASPECT_DEPTH_BIT` and `VK_IMAGE_ASPECT_STENCIL_BIT`
/// - If [`image`] has a depth/stencil format with both depth and stencil and the [separateDepthStencilLayouts](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-separateDepthStencilLayouts)
///   feature is not enabled, then the `aspectMask` member of [`subresource_range`] **must**
///   include both `VK_IMAGE_ASPECT_DEPTH_BIT` and `VK_IMAGE_ASPECT_STENCIL_BIT`
/// -    If [`src_queue_family_index`] is not equal to [`dst_queue_family_index`], at least one  **must**  not be a special queue family reserved for external memory ownership transfers, as described in [[synchronization-queue-transfers]](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#synchronization-queue-transfers)
/// - If [`image`] was created with a sharing mode of `VK_SHARING_MODE_CONCURRENT`,
///   [`src_queue_family_index`] and [`dst_queue_family_index`] are not equal, and one of
///   [`src_queue_family_index`] and [`dst_queue_family_index`] is one of the special queue family
///   values reserved for external memory transfers, the other  **must**  be
///   [`QUEUE_FAMILY_IGNORED`]
/// -    If [`image`] was created with a sharing mode of `VK_SHARING_MODE_EXCLUSIVE`, and [`src_queue_family_index`] and [`dst_queue_family_index`] are not equal, [`src_queue_family_index`] and [`dst_queue_family_index`] **must**  both be valid queue families, or one of the special queue family values reserved for external memory transfers, as described in [[synchronization-queue-transfers]](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#synchronization-queue-transfers)
/// - If the [`synchronization2` feature](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-synchronization2)
///   is not enabled, and [`image`] was created with a sharing mode of `VK_SHARING_MODE_CONCURRENT`,
///   at least one of [`src_queue_family_index`] and [`dst_queue_family_index`] **must**  be
///   [`QUEUE_FAMILY_IGNORED`]
///
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be `VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER`
/// - [`p_next`] **must**  be `NULL` or a pointer to a valid instance of [`SampleLocationsInfoEXT`]
/// - The [`s_type`] value of each struct in the [`p_next`] chain  **must**  be unique
/// - [`old_layout`] **must**  be a valid [`ImageLayout`] value
/// - [`new_layout`] **must**  be a valid [`ImageLayout`] value
/// - [`image`] **must**  be a valid [`Image`] handle
/// - [`subresource_range`] **must**  be a valid [`ImageSubresourceRange`] structure
///# Related
/// - [`crate::vulkan1_0`]
/// - [`AccessFlags`]
/// - [`Image`]
/// - [`ImageLayout`]
/// - [`ImageSubresourceRange`]
/// - [`StructureType`]
/// - [`CmdPipelineBarrier`]
/// - [`CmdWaitEvents`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[repr(C)]
pub struct ImageMemoryBarrier<'lt> {
    _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] is the type of this structure.
    s_type: StructureType,
    ///[`p_next`] is `NULL` or a pointer to a structure extending this
    ///structure.
    p_next: *const BaseInStructure<'lt>,
    ///[`src_access_mask`] is a bitmask of [`AccessFlagBits`] specifying a
    ///[source access mask](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-access-masks).
    src_access_mask: AccessFlags,
    ///[`dst_access_mask`] is a bitmask of [`AccessFlagBits`] specifying a
    ///[destination access mask](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-access-masks).
    dst_access_mask: AccessFlags,
    ///[`old_layout`] is the old layout in an
    ///[image layout transition](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-image-layout-transitions).
    old_layout: ImageLayout,
    ///[`new_layout`] is the new layout in an
    ///[image layout transition](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-image-layout-transitions).
    new_layout: ImageLayout,
    ///[`src_queue_family_index`] is the source queue family for a
    ///[queue family ownership transfer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-queue-transfers).
    src_queue_family_index: u32,
    ///[`dst_queue_family_index`] is the destination queue family for a
    ///[queue family ownership transfer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-queue-transfers).
    dst_queue_family_index: u32,
    ///[`image`] is a handle to the image affected by this barrier.
    image: Image,
    ///[`subresource_range`] describes the [image
    ///subresource range](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#resources-image-views) within [`image`] that is affected by this barrier.
    subresource_range: ImageSubresourceRange,
}
impl<'lt> Default for ImageMemoryBarrier<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: Default::default(),
            p_next: std::ptr::null(),
            src_access_mask: Default::default(),
            dst_access_mask: Default::default(),
            old_layout: Default::default(),
            new_layout: Default::default(),
            src_queue_family_index: 0,
            dst_queue_family_index: 0,
            image: Default::default(),
            subresource_range: Default::default(),
        }
    }
}
impl<'lt> ImageMemoryBarrier<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *const BaseInStructure<'lt> {
        self.p_next
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *const BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseInStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::src_access_mask`]
    pub fn src_access_mask(&self) -> AccessFlags {
        self.src_access_mask
    }
    ///Gets the value of [`Self::dst_access_mask`]
    pub fn dst_access_mask(&self) -> AccessFlags {
        self.dst_access_mask
    }
    ///Gets the value of [`Self::old_layout`]
    pub fn old_layout(&self) -> ImageLayout {
        self.old_layout
    }
    ///Gets the value of [`Self::new_layout`]
    pub fn new_layout(&self) -> ImageLayout {
        self.new_layout
    }
    ///Gets the value of [`Self::src_queue_family_index`]
    pub fn src_queue_family_index(&self) -> u32 {
        self.src_queue_family_index
    }
    ///Gets the value of [`Self::dst_queue_family_index`]
    pub fn dst_queue_family_index(&self) -> u32 {
        self.dst_queue_family_index
    }
    ///Gets the value of [`Self::image`]
    pub fn image(&self) -> Image {
        self.image
    }
    ///Gets the value of [`Self::subresource_range`]
    pub fn subresource_range(&self) -> ImageSubresourceRange {
        self.subresource_range
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::src_access_mask`]
    pub fn src_access_mask_mut(&mut self) -> &mut AccessFlags {
        &mut self.src_access_mask
    }
    ///Gets a mutable reference to the value of [`Self::dst_access_mask`]
    pub fn dst_access_mask_mut(&mut self) -> &mut AccessFlags {
        &mut self.dst_access_mask
    }
    ///Gets a mutable reference to the value of [`Self::old_layout`]
    pub fn old_layout_mut(&mut self) -> &mut ImageLayout {
        &mut self.old_layout
    }
    ///Gets a mutable reference to the value of [`Self::new_layout`]
    pub fn new_layout_mut(&mut self) -> &mut ImageLayout {
        &mut self.new_layout
    }
    ///Gets a mutable reference to the value of [`Self::src_queue_family_index`]
    pub fn src_queue_family_index_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::dst_queue_family_index`]
    pub fn dst_queue_family_index_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::image`]
    pub fn image_mut(&mut self) -> &mut Image {
        &mut self.image
    }
    ///Gets a mutable reference to the value of [`Self::subresource_range`]
    pub fn subresource_range_mut(&mut self) -> &mut ImageSubresourceRange {
        &mut self.subresource_range
    }
    ///Sets the raw value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the raw value of [`Self::src_access_mask`]
    pub fn set_src_access_mask(&mut self, value: crate::vulkan1_0::AccessFlags) -> &mut Self {
        self.src_access_mask = value;
        self
    }
    ///Sets the raw value of [`Self::dst_access_mask`]
    pub fn set_dst_access_mask(&mut self, value: crate::vulkan1_0::AccessFlags) -> &mut Self {
        self.dst_access_mask = value;
        self
    }
    ///Sets the raw value of [`Self::old_layout`]
    pub fn set_old_layout(&mut self, value: crate::vulkan1_0::ImageLayout) -> &mut Self {
        self.old_layout = value;
        self
    }
    ///Sets the raw value of [`Self::new_layout`]
    pub fn set_new_layout(&mut self, value: crate::vulkan1_0::ImageLayout) -> &mut Self {
        self.new_layout = value;
        self
    }
    ///Sets the raw value of [`Self::src_queue_family_index`]
    pub fn set_src_queue_family_index(&mut self, value: u32) -> &mut Self {
        self.src_queue_family_index = value;
        self
    }
    ///Sets the raw value of [`Self::dst_queue_family_index`]
    pub fn set_dst_queue_family_index(&mut self, value: u32) -> &mut Self {
        self.dst_queue_family_index = value;
        self
    }
    ///Sets the raw value of [`Self::image`]
    pub fn set_image(&mut self, value: crate::vulkan1_0::Image) -> &mut Self {
        self.image = value;
        self
    }
    ///Sets the raw value of [`Self::subresource_range`]
    pub fn set_subresource_range(&mut self, value: crate::vulkan1_0::ImageSubresourceRange) -> &mut Self {
        self.subresource_range = value;
        self
    }
}
///[VkImageCreateInfo](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageCreateInfo.html) - Structure specifying the parameters of a newly created image object
///# C Specifications
///The [`ImageCreateInfo`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkImageCreateInfo {
///    VkStructureType          sType;
///    const void*              pNext;
///    VkImageCreateFlags       flags;
///    VkImageType              imageType;
///    VkFormat                 format;
///    VkExtent3D               extent;
///    uint32_t                 mipLevels;
///    uint32_t                 arrayLayers;
///    VkSampleCountFlagBits    samples;
///    VkImageTiling            tiling;
///    VkImageUsageFlags        usage;
///    VkSharingMode            sharingMode;
///    uint32_t                 queueFamilyIndexCount;
///    const uint32_t*          pQueueFamilyIndices;
///    VkImageLayout            initialLayout;
///} VkImageCreateInfo;
///```
///# Members
/// - [`s_type`] is the type of this structure.
/// - [`p_next`] is `NULL` or a pointer to a structure extending this structure.
/// - [`flags`] is a bitmask of [`ImageCreateFlagBits`] describing additional parameters of the
///   image.
/// - [`image_type`] is a [`ImageType`] value specifying the basic dimensionality of the image.
///   Layers in array textures do not count as a dimension for the purposes of the image type.
/// - [`format`] is a [`Format`] describing the format and type of the texel blocks that will be
///   contained in the image.
/// - [`extent`] is a [`Extent3D`] describing the number of data elements in each dimension of the
///   base level.
/// - [`mip_levels`] describes the number of levels of detail available for minified sampling of the
///   image.
/// - [`array_layers`] is the number of layers in the image.
/// - [`samples`] is a [`SampleCountFlagBits`] value specifying the number of [samples per texel](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#primsrast-multisampling).
/// - [`tiling`] is a [`ImageTiling`] value specifying the tiling arrangement of the texel blocks in
///   memory.
/// - [`usage`] is a bitmask of [`ImageUsageFlagBits`] describing the intended usage of the image.
/// - [`sharing_mode`] is a [`SharingMode`] value specifying the sharing mode of the image when it
///   will be accessed by multiple queue families.
/// - [`queue_family_index_count`] is the number of entries in the [`queue_family_indices`] array.
/// - [`queue_family_indices`] is a pointer to an array of queue families that will access this
///   image. It is ignored if [`sharing_mode`] is not `VK_SHARING_MODE_CONCURRENT`.
/// - [`initial_layout`] is a [`ImageLayout`] value specifying the initial [`ImageLayout`] of all image subresources of the image. See [Image Layouts](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#resources-image-layouts).
///# Description
///Images created with [`tiling`] equal to `VK_IMAGE_TILING_LINEAR` have
///further restrictions on their limits and capabilities compared to images
///created with [`tiling`] equal to `VK_IMAGE_TILING_OPTIMAL`.
///Creation of images with tiling `VK_IMAGE_TILING_LINEAR` **may**  not be
///supported unless other parameters meet all of the constraints:
/// - [`image_type`] is `VK_IMAGE_TYPE_2D`
/// - [`format`] is not a depth/stencil format
/// - [`mip_levels`] is 1
/// - [`array_layers`] is 1
/// - [`samples`] is `VK_SAMPLE_COUNT_1_BIT`
/// - [`usage`] only includes `VK_IMAGE_USAGE_TRANSFER_SRC_BIT` and/or
///   `VK_IMAGE_USAGE_TRANSFER_DST_BIT`
///Images created with one of the [formats that require a sampler Y′C<sub>B</sub>C<sub>R</sub> conversion](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#formats-requiring-sampler-ycbcr-conversion), have further
///restrictions on their limits and capabilities compared to images created
///with other formats.
///Creation of images with a format requiring
///[Y′C<sub>B</sub>C<sub>R</sub> conversion](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#formats-requiring-sampler-ycbcr-conversion) **may**  not
///be supported unless other parameters meet all of the constraints:
/// - [`image_type`] is `VK_IMAGE_TYPE_2D`
/// - [`mip_levels`] is 1
/// - [`array_layers`] is 1
/// - [`samples`] is `VK_SAMPLE_COUNT_1_BIT`
///Implementations  **may**  support additional limits and capabilities beyond those
///listed above.To determine the set of valid [`usage`] bits for a given format, call
///[`GetPhysicalDeviceFormatProperties`].If the size of the resultant image would exceed
/// `maxResourceSize`, then
///[`CreateImage`] **must**  fail and return
///`VK_ERROR_OUT_OF_DEVICE_MEMORY`.
///This failure  **may**  occur even when all image creation parameters satisfy
///their valid usage requirements.
///## Image Creation LimitsValid values for some image creation parameters are limited by a
/// numerical
///upper bound or by inclusion in a bitset.
///For example, [`ImageCreateInfo`]::[`array_layers`] is limited by
///`imageCreateMaxArrayLayers`, defined below; and
///[`ImageCreateInfo`]::[`samples`] is limited by
///`imageCreateSampleCounts`, also defined below.Several limiting values are defined below, as well
/// as assisting values from
///which the limiting values are derived.
///The limiting values are referenced by the relevant valid usage statements of
///[`ImageCreateInfo`].
/// - Let `uint64_t imageCreateDrmFormatModifiers[]` be the set of [Linux DRM format modifiers](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#glossary-drm-format-modifier)
///   that the resultant image  **may**  have.  - If [`tiling`] is not
///   `VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT`, then `imageCreateDrmFormatModifiers` is empty.  -
///   If [`ImageCreateInfo`]::[`p_next`] contains [`ImageDrmFormatModifierExplicitCreateInfoEXT`],
///   then `imageCreateDrmFormatModifiers` contains exactly one modifier,
///   [`ImageDrmFormatModifierExplicitCreateInfoEXT::drm_format_modifier`].  - If
///   [`ImageCreateInfo`]::[`p_next`] contains [`ImageDrmFormatModifierListCreateInfoEXT`], then
///   `imageCreateDrmFormatModifiers` contains the entire array
///   [`ImageDrmFormatModifierListCreateInfoEXT::drm_format_modifiers`].
/// - Let `VkBool32 imageCreateMaybeLinear` indicate if the resultant image may be [linear](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#glossary-linear-resource).
///   - If [`tiling`] is `VK_IMAGE_TILING_LINEAR`, then `imageCreateMaybeLinear` is [`TRUE`].  - If
///   [`tiling`] is `VK_IMAGE_TILING_OPTIMAL`, then `imageCreateMaybeLinear` is [`FALSE`].  - If
///   [`tiling`] is `VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT`, then `imageCreateMaybeLinear` is
///   [`TRUE`] if and only if `imageCreateDrmFormatModifiers` contains `DRM_FORMAT_MOD_LINEAR`.
/// - Let `VkFormatFeatureFlags imageCreateFormatFeatures` be the set of valid *format features*
///   available during image creation.  - If [`tiling`] is `VK_IMAGE_TILING_LINEAR`, then
///   `imageCreateFormatFeatures` is the value of [`FormatProperties::linear_tiling_features`] found
///   by calling [`GetPhysicalDeviceFormatProperties`] with parameter [`format`] equal to
///   [`ImageCreateInfo`]::[`format`].  - If [`tiling`] is `VK_IMAGE_TILING_OPTIMAL`, and if the
///   [`p_next`] chain includes no [`ExternalFormatANDROID`] structure with non-zero
///   `externalFormat`, then `imageCreateFormatFeatures` is the value of
///   [`FormatProperties::optimal_tiling_features`] found by calling
///   [`GetPhysicalDeviceFormatProperties`] with parameter [`format`] equal to
///   [`ImageCreateInfo`]::[`format`].  - If [`tiling`] is `VK_IMAGE_TILING_OPTIMAL`, and if the
///   [`p_next`] chain includes a [`ExternalFormatANDROID`] structure with non-zero
///   `externalFormat`, then `imageCreateFormatFeatures` is the value of
///   [`AndroidHardwareBufferFormatPropertiesANDROID::format_features`] obtained by
///   [`GetAndroidHardwareBufferPropertiesANDROID`] with a matching `externalFormat` value.  - If
///   the [`p_next`] chain includes a [`BufferCollectionImageCreateInfoFUCHSIA`] structure, then
///   `imageCreateFormatFeatures` is the value of
///   [`BufferCollectionPropertiesFUCHSIA::format_features`] found by calling
///   [`GetBufferCollectionPropertiesFUCHSIA`] with a parameter `collection` equal to
///   [`BufferCollectionImageCreateInfoFUCHSIA::collection`]  - If [`tiling`] is
///   `VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT`, then the value of `imageCreateFormatFeatures` is
///   found by calling [`GetPhysicalDeviceFormatProperties2`] with
///   [`ImageFormatProperties`]::[`format`] equal to [`ImageCreateInfo`]::[`format`] and with
///   [`DrmFormatModifierPropertiesListEXT`] chained into [`FormatProperties2`]; by collecting all
///   members of the returned array
///   [`DrmFormatModifierPropertiesListEXT::drm_format_modifier_properties`] whose
///   `drmFormatModifier` belongs to `imageCreateDrmFormatModifiers`; and by taking the bitwise
///   intersection, over the collected array members, of `drmFormatModifierTilingFeatures`. (The
///   resultant `imageCreateFormatFeatures` **may**  be empty).
/// - Let `VkImageFormatProperties2 imageCreateImageFormatPropertiesList[]` be defined as follows.
///   - If [`ImageCreateInfo`]::[`p_next`] contains no [`ExternalFormatANDROID`] structure with
///   non-zero `externalFormat`, then `imageCreateImageFormatPropertiesList` is the list of
///   structures obtained by calling [`GetPhysicalDeviceImageFormatProperties2`], possibly multiple
///   times, as follows:   - The parameters [`PhysicalDeviceImageFormatInfo2`]::[`format`],
///   [`image_type`], [`tiling`], [`usage`], and [`flags`] **must**  be equal to those in
///   [`ImageCreateInfo`].   - If [`ImageCreateInfo`]::[`p_next`] contains a
///   [`ExternalMemoryImageCreateInfo`] structure whose `handleTypes` is not `0`, then
///   [`PhysicalDeviceImageFormatInfo2`]::[`p_next`] **must**  contain a
///   [`PhysicalDeviceExternalImageFormatInfo`] structure whose `handleType` is not `0`; and
///   [`GetPhysicalDeviceImageFormatProperties2`] **must**  be called for each handle type in
///   [`ExternalMemoryImageCreateInfo::handle_types`], successively setting
///   [`PhysicalDeviceExternalImageFormatInfo::handle_type`] on each call.   - If
///   [`ImageCreateInfo`]::[`p_next`] contains no [`ExternalMemoryImageCreateInfo`] structure, or
///   contains a structure whose `handleTypes` is `0`, then
///   [`PhysicalDeviceImageFormatInfo2`]::[`p_next`] **must**  either contain no
///   [`PhysicalDeviceExternalImageFormatInfo`] structure, or contain a structure whose `handleType`
///   is `0`.   - If [`tiling`] is `VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT`, then
///   [`PhysicalDeviceImageFormatInfo2`]::[`p_next`] **must**  contain a
///   [`PhysicalDeviceImageDrmFormatModifierInfoEXT`] structure where [`sharing_mode`] is equal to
///   [`ImageCreateInfo`]::[`sharing_mode`]; and, if [`sharing_mode`] is
///   `VK_SHARING_MODE_CONCURRENT`, then [`queue_family_index_count`] and [`queue_family_indices`]
///   **must**  be equal to those in [`ImageCreateInfo`]; and, if [`flags`] contains
///   `VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT`, then the [`ImageFormatListCreateInfo`] structure
///   included in the [`p_next`] chain of [`PhysicalDeviceImageFormatInfo2`] **must**  be equivalent
///   to the one included in the [`p_next`] chain of [`ImageCreateInfo`]; and
///   [`GetPhysicalDeviceImageFormatProperties2`] **must**  be called for each modifier in
///   `imageCreateDrmFormatModifiers`, successively setting
///   [`PhysicalDeviceImageDrmFormatModifierInfoEXT::drm_format_modifier`] on each call.   - If
///   [`tiling`] is not `VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT`, then
///   [`PhysicalDeviceImageFormatInfo2`]::[`p_next`] **must**  contain no
///   [`PhysicalDeviceImageDrmFormatModifierInfoEXT`] structure.   - If any call to
///   [`GetPhysicalDeviceImageFormatProperties2`] returns an error, then
///   `imageCreateImageFormatPropertiesList` is defined to be the empty list.   - If
///   [`ImageCreateInfo`]::[`p_next`] contains a [`ExternalFormatANDROID`] structure with non-zero
///   `externalFormat`, then `imageCreateImageFormatPropertiesList` contains a single element where:
///   - [`ImageFormatProperties::max_mip_levels`] is ⌊log<sub>2</sub>(max(`extent.width`,
///   `extent.height`, `extent.depth`))⌋ +  1.   - [`ImageFormatProperties::max_array_layers`] is
///   [`PhysicalDeviceLimits::max_image_array_layers`].   - Each component of
///   [`ImageFormatProperties::max_extent`] is [`PhysicalDeviceLimits::max_image_dimension_2_d`].
///   - [`ImageFormatProperties::sample_counts`] contains exactly `VK_SAMPLE_COUNT_1_BIT`.
/// - Let `uint32_t imageCreateMaxMipLevels` be the minimum value of
///   [`ImageFormatProperties::max_mip_levels`] in `imageCreateImageFormatPropertiesList`. The value
///   is undefined if `imageCreateImageFormatPropertiesList` is empty.
/// - Let `uint32_t imageCreateMaxArrayLayers` be the minimum value of
///   [`ImageFormatProperties::max_array_layers`] in `imageCreateImageFormatPropertiesList`. The
///   value is undefined if `imageCreateImageFormatPropertiesList` is empty.
/// - Let `VkExtent3D imageCreateMaxExtent` be the component-wise minimum over all
///   [`ImageFormatProperties::max_extent`] values in `imageCreateImageFormatPropertiesList`. The
///   value is undefined if `imageCreateImageFormatPropertiesList` is empty.
/// - Let `VkSampleCountFlags imageCreateSampleCounts` be the intersection of each
///   [`ImageFormatProperties::sample_counts`] in `imageCreateImageFormatPropertiesList`. The value
///   is undefined if `imageCreateImageFormatPropertiesList` is empty.
///
///## Valid Usage
/// - Each of the following values (as described in [Image Creation Limits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#resources-image-creation-limits))
///   **must**  not be undefined : `imageCreateMaxMipLevels`, `imageCreateMaxArrayLayers`,
///   `imageCreateMaxExtent`, and `imageCreateSampleCounts`
/// - If [`sharing_mode`] is `VK_SHARING_MODE_CONCURRENT`, [`queue_family_indices`] **must**  be a
///   valid pointer to an array of [`queue_family_index_count`]`uint32_t` values
/// - If [`sharing_mode`] is `VK_SHARING_MODE_CONCURRENT`, [`queue_family_index_count`] **must**  be
///   greater than `1`
/// - If [`sharing_mode`] is `VK_SHARING_MODE_CONCURRENT`, each element of [`queue_family_indices`]
///   **must**  be unique and  **must**  be less than `pQueueFamilyPropertyCount` returned by either
///   [`GetPhysicalDeviceQueueFamilyProperties`] or [`GetPhysicalDeviceQueueFamilyProperties2`] for
///   the `physicalDevice` that was used to create `device`
/// - If the [`p_next`] chain includes a [`ExternalFormatANDROID`] structure, and its
///   `externalFormat` member is non-zero the [`format`] **must**  be `VK_FORMAT_UNDEFINED`
/// - If the [`p_next`] chain does not include a [`ExternalFormatANDROID`] structure, or does and
///   its `externalFormat` member is `0`, the [`format`] **must**  not be `VK_FORMAT_UNDEFINED`
/// - `extent.width` **must**  be greater than `0`
/// - `extent.height` **must**  be greater than `0`
/// - `extent.depth` **must**  be greater than `0`
/// - [`mip_levels`] **must**  be greater than `0`
/// - [`array_layers`] **must**  be greater than `0`
/// - If [`flags`] contains `VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT`, [`image_type`] **must**  be
///   `VK_IMAGE_TYPE_2D`
/// - If [`flags`] contains `VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT`, [`image_type`] **must**
///   be `VK_IMAGE_TYPE_2D`
/// - If [`flags`] contains `VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT`, [`image_type`] **must**  be
///   `VK_IMAGE_TYPE_3D`
/// -  `extent.width` **must**  be less than or equal to `imageCreateMaxExtent.width` (as defined in [Image Creation Limits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#resources-image-creation-limits))
/// -  `extent.height` **must**  be less than or equal to `imageCreateMaxExtent.height` (as defined in [Image Creation Limits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#resources-image-creation-limits))
/// -  `extent.depth` **must**  be less than or equal to `imageCreateMaxExtent.depth` (as defined in [Image Creation Limits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#resources-image-creation-limits))
/// - If [`image_type`] is `VK_IMAGE_TYPE_2D` and [`flags`] contains
///   `VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT`, `extent.width` and `extent.height` **must**  be equal
///   and [`array_layers`] **must**  be greater than or equal to 6
/// - If [`image_type`] is `VK_IMAGE_TYPE_1D`, both `extent.height` and `extent.depth` **must**  be
///   `1`
/// - If [`image_type`] is `VK_IMAGE_TYPE_2D`, `extent.depth` **must**  be `1`
/// - [`mip_levels`] **must**  be less than or equal to the number of levels in the complete mipmap
///   chain based on `extent.width`, `extent.height`, and `extent.depth`
/// -  [`mip_levels`] **must**  be less than or equal to `imageCreateMaxMipLevels` (as defined in [Image Creation Limits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#resources-image-creation-limits))
/// - [`array_layers`] **must**  be less than or equal to `imageCreateMaxArrayLayers` (as defined in
///   [Image Creation Limits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#resources-image-creation-limits))
/// - If [`image_type`] is `VK_IMAGE_TYPE_3D`, [`array_layers`] **must**  be `1`
/// -    If [`samples`] is not `VK_SAMPLE_COUNT_1_BIT`, then [`image_type`] **must**  be `VK_IMAGE_TYPE_2D`, [`flags`] **must**  not contain `VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT`, [`mip_levels`] **must**  be equal to `1`, and `imageCreateMaybeLinear` (as defined in [Image Creation Limits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#resources-image-creation-limits))  **must**  be [`FALSE`],
/// - If [`samples`] is not `VK_SAMPLE_COUNT_1_BIT`, [`usage`] **must**  not contain
///   `VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT`
/// - If [`usage`] includes `VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT`, then bits other than
///   `VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT`, `VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT`, and
///   `VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT` **must**  not be set
/// - If [`usage`] includes `VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT`,
///   `VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT`, `VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT`, or
///   `VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT`, `extent.width` **must**  be less than or equal to
///   [`PhysicalDeviceLimits::max_framebuffer_width`]
/// - If [`usage`] includes `VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT`,
///   `VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT`, `VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT`, or
///   `VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT`, `extent.height` **must**  be less than or equal to
///   [`PhysicalDeviceLimits::max_framebuffer_height`]
/// - If [`fragmentDensityMapOffset`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-fragmentDensityMapOffset)
///   is not enabled and [`usage`] includes `VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT`,
///   `extent.width` **must**  be less than or equal to <span class="katex"><span class="katex-html"
///   aria-hidden="true"><span class="base"><span class="strut"
///   style="height:1.80002em;vertical-align:-0.65002em;"></span><span class="minner"><span
///   class="mopen delimcenter" style="top:0em;"><span class="delimsizing
///   size2">⌈</span></span><span class="mord"><span class="mord"><span class="mopen
///   nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span
///   class="vlist-r"><span class="vlist" style="height:0.9322159999999999em;"><span
///   style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span
///   class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord
///   mathdefault mtight">m</span><span class="mord mathdefault mtight">i</span><span class="mord
///   mathdefault mtight">n</span><span style="margin-right:0.13889em;" class="mord mathdefault
///   mtight">F</span><span class="mord mathdefault mtight"
///   style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">a</span><span
///   class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mord
///   mathdefault mtight">m</span><span class="mord mathdefault mtight">e</span><span class="mord
///   mathdefault mtight">n</span><span class="mord mathdefault mtight">t</span><span
///   style="margin-right:0.02778em;" class="mord mathdefault mtight">D</span><span class="mord
///   mathdefault mtight">e</span><span class="mord mathdefault mtight">n</span><span class="mord
///   mathdefault mtight">s</span><span class="mord mathdefault mtight">i</span><span class="mord
///   mathdefault mtight">t</span><span class="mord mathdefault mtight"
///   style="margin-right:0.03588em;">y</span><span style="margin-right:0.13889em;" class="mord
///   mathdefault mtight">T</span><span class="mord mathdefault mtight">e</span><span class="mord
///   mathdefault mtight">x</span><span class="mord mathdefault mtight">e</span><span class="mord
///   mathdefault mtight" style="margin-right:0.01968em;">l</span><span
///   style="margin-right:0.05764em;" class="mord mathdefault mtight">S</span><span class="mord
///   mathdefault mtight">i</span><span style="margin-right:0.04398em;" class="mord mathdefault
///   mtight">z</span><span class="mord mtight"><span class="mord mathdefault mtight">e</span><span
///   class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist"
///   style="height:0.3448em;"><span
///   style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span
///   class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1
///   mtight"><span class="mord mtight"><span class="mord mathdefault mtight"
///   style="margin-right:0.02691em;">w</span><span class="mord mathdefault mtight">i</span><span
///   class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">t</span><span
///   class="mord mathdefault mtight">h</span></span></span></span></span><span
///   class="vlist-s">​</span></span><span class="vlist-r"><span
///   style="height:0.15122857142857138em;"
///   class="vlist"><span></span></span></span></span></span></span></span></span></span><span
///   style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span
///   style="border-bottom-width:0.04em;" class="frac-line"></span></span><span
///   style="top:-3.446108em;"><span class="pstrut" style="height:3em;"></span><span class="sizing
///   reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault
///   mtight">m</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault
///   mtight">x</span><span class="mord mathdefault mtight"
///   style="margin-right:0.13889em;">F</span><span class="mord mathdefault mtight"
///   style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">a</span><span
///   class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">e</span><span
///   class="mord mathdefault mtight">b</span><span class="mord mathdefault mtight">u</span><span
///   class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord
///   mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault
///   mtight">e</span><span style="margin-right:0.02778em;" class="mord mathdefault
///   mtight">r</span><span class="mord mathdefault mtight"
///   style="margin-right:0.13889em;">W</span><span class="mord mathdefault mtight">i</span><span
///   class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">t</span><span
///   class="mord mathdefault mtight">h</span></span></span></span></span><span
///   class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist"
///   style="height:0.481108em;"><span></span></span></span></span></span><span class="mclose
///   nulldelimiter"></span></span></span><span style="top:0em;" class="mclose delimcenter"><span
///   class="delimsizing size2">⌉</span></span></span></span></span></span>
/// - If [`fragmentDensityMapOffset`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-fragmentDensityMapOffset)
///   is not enabled and [`usage`] includes `VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT`,
///   `extent.height` **must**  be less than or equal to <span class="katex"><span
///   class="katex-html" aria-hidden="true"><span class="base"><span
///   style="height:1.80002em;vertical-align:-0.65002em;" class="strut"></span><span
///   class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing
///   size2">⌈</span></span><span class="mord"><span class="mord"><span class="mopen
///   nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span
///   class="vlist-r"><span class="vlist" style="height:0.9322159999999999em;"><span
///   style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span
///   class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord
///   mathdefault mtight">m</span><span class="mord mathdefault mtight">i</span><span class="mord
///   mathdefault mtight">n</span><span class="mord mathdefault mtight"
///   style="margin-right:0.13889em;">F</span><span class="mord mathdefault mtight"
///   style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">a</span><span
///   class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mord
///   mathdefault mtight">m</span><span class="mord mathdefault mtight">e</span><span class="mord
///   mathdefault mtight">n</span><span class="mord mathdefault mtight">t</span><span
///   style="margin-right:0.02778em;" class="mord mathdefault mtight">D</span><span class="mord
///   mathdefault mtight">e</span><span class="mord mathdefault mtight">n</span><span class="mord
///   mathdefault mtight">s</span><span class="mord mathdefault mtight">i</span><span class="mord
///   mathdefault mtight">t</span><span class="mord mathdefault mtight"
///   style="margin-right:0.03588em;">y</span><span class="mord mathdefault mtight"
///   style="margin-right:0.13889em;">T</span><span class="mord mathdefault mtight">e</span><span
///   class="mord mathdefault mtight">x</span><span class="mord mathdefault mtight">e</span><span
///   style="margin-right:0.01968em;" class="mord mathdefault mtight">l</span><span class="mord
///   mathdefault mtight" style="margin-right:0.05764em;">S</span><span class="mord mathdefault
///   mtight">i</span><span class="mord mathdefault mtight"
///   style="margin-right:0.04398em;">z</span><span class="mord mtight"><span class="mord
///   mathdefault mtight">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span
///   class="vlist-r"><span class="vlist" style="height:0.3448em;"><span
///   style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span
///   style="height:2.5em;" class="pstrut"></span><span class="sizing reset-size3 size1
///   mtight"><span class="mord mtight"><span class="mord mathdefault mtight">h</span><span
///   class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">i</span><span
///   class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mord
///   mathdefault mtight">h</span><span class="mord mathdefault
///   mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span
///   class="vlist-r"><span style="height:0.29011428571428566em;"
///   class="vlist"><span></span></span></span></span></span></span></span></span></span><span
///   style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span
///   style="border-bottom-width:0.04em;" class="frac-line"></span></span><span
///   style="top:-3.446108em;"><span style="height:3em;" class="pstrut"></span><span class="sizing
///   reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault
///   mtight">m</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault
///   mtight">x</span><span class="mord mathdefault mtight"
///   style="margin-right:0.13889em;">F</span><span class="mord mathdefault mtight"
///   style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">a</span><span
///   class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">e</span><span
///   class="mord mathdefault mtight">b</span><span class="mord mathdefault mtight">u</span><span
///   class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord
///   mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault
///   mtight">e</span><span style="margin-right:0.02778em;" class="mord mathdefault
///   mtight">r</span><span class="mord mathdefault mtight"
///   style="margin-right:0.08125em;">H</span><span class="mord mathdefault mtight">e</span><span
///   class="mord mathdefault mtight">i</span><span style="margin-right:0.03588em;" class="mord
///   mathdefault mtight">g</span><span class="mord mathdefault mtight">h</span><span class="mord
///   mathdefault mtight">t</span></span></span></span></span><span
///   class="vlist-s">​</span></span><span class="vlist-r"><span style="height:0.5480799999999999em;"
///   class="vlist"><span></span></span></span></span></span><span class="mclose
///   nulldelimiter"></span></span></span><span class="mclose delimcenter" style="top:0em;"><span
///   class="delimsizing size2">⌉</span></span></span></span></span></span>
/// - If [`usage`] includes `VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT`, [`usage`] **must**  also
///   contain at least one of `VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT`,
///   `VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT`, or `VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT`
/// -  [`samples`] **must**  be a bit value that is set in `imageCreateSampleCounts` (as defined in [Image Creation Limits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#resources-image-creation-limits))
/// - If the [multisampled storage images](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-shaderStorageImageMultisample)
///   feature is not enabled, and [`usage`] contains `VK_IMAGE_USAGE_STORAGE_BIT`, [`samples`]
///   **must**  be `VK_SAMPLE_COUNT_1_BIT`
/// - If the [sparse bindings](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-sparseBinding)
///   feature is not enabled, [`flags`] **must**  not contain `VK_IMAGE_CREATE_SPARSE_BINDING_BIT`
/// - If the [sparse aliased residency](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-sparseResidencyAliased)
///   feature is not enabled, [`flags`] **must**  not contain `VK_IMAGE_CREATE_SPARSE_ALIASED_BIT`
/// - If [`tiling`] is `VK_IMAGE_TILING_LINEAR`, [`flags`] **must**  not contain
///   `VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT`
/// - If [`image_type`] is `VK_IMAGE_TYPE_1D`, [`flags`] **must**  not contain
///   `VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT`
/// - If the [sparse residency for 2D images](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-sparseResidencyImage2D)
///   feature is not enabled, and [`image_type`] is `VK_IMAGE_TYPE_2D`, [`flags`] **must**  not
///   contain `VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT`
/// - If the [sparse residency for 3D images](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-sparseResidencyImage3D)
///   feature is not enabled, and [`image_type`] is `VK_IMAGE_TYPE_3D`, [`flags`] **must**  not
///   contain `VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT`
/// - If the [sparse residency for images with 2 samples](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-sparseResidency2Samples)
///   feature is not enabled, [`image_type`] is `VK_IMAGE_TYPE_2D`, and [`samples`] is
///   `VK_SAMPLE_COUNT_2_BIT`, [`flags`] **must**  not contain
///   `VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT`
/// - If the [sparse residency for images with 4 samples](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-sparseResidency4Samples)
///   feature is not enabled, [`image_type`] is `VK_IMAGE_TYPE_2D`, and [`samples`] is
///   `VK_SAMPLE_COUNT_4_BIT`, [`flags`] **must**  not contain
///   `VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT`
/// - If the [sparse residency for images with 8 samples](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-sparseResidency8Samples)
///   feature is not enabled, [`image_type`] is `VK_IMAGE_TYPE_2D`, and [`samples`] is
///   `VK_SAMPLE_COUNT_8_BIT`, [`flags`] **must**  not contain
///   `VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT`
/// - If the [sparse residency for images with 16 samples](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-sparseResidency16Samples)
///   feature is not enabled, [`image_type`] is `VK_IMAGE_TYPE_2D`, and [`samples`] is
///   `VK_SAMPLE_COUNT_16_BIT`, [`flags`] **must**  not contain
///   `VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT`
/// - If [`flags`] contains `VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT` or
///   `VK_IMAGE_CREATE_SPARSE_ALIASED_BIT`, it  **must**  also contain
///   `VK_IMAGE_CREATE_SPARSE_BINDING_BIT`
/// - If any of the bits `VK_IMAGE_CREATE_SPARSE_BINDING_BIT`,
///   `VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT`, or `VK_IMAGE_CREATE_SPARSE_ALIASED_BIT` are set,
///   `VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT` **must**  not also be set
/// - If the protected memory feature is not enabled, [`flags`] **must**  not contain
///   `VK_IMAGE_CREATE_PROTECTED_BIT`
/// - If any of the bits `VK_IMAGE_CREATE_SPARSE_BINDING_BIT`,
///   `VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT`, or `VK_IMAGE_CREATE_SPARSE_ALIASED_BIT` are set,
///   `VK_IMAGE_CREATE_PROTECTED_BIT` **must**  not also be set
/// - If the [`p_next`] chain includes a [`ExternalMemoryImageCreateInfoNV`] structure, it  **must**
///   not contain a [`ExternalMemoryImageCreateInfo`] structure
/// - If the [`p_next`] chain includes a [`ExternalMemoryImageCreateInfo`] structure, its
///   `handleTypes` member  **must**  only contain bits that are also in
///   [`ExternalImageFormatProperties`]::`externalMemoryProperties.compatibleHandleTypes`, as
///   returned by [`GetPhysicalDeviceImageFormatProperties2`] with [`format`], [`image_type`],
///   [`tiling`], [`usage`], and [`flags`] equal to those in this structure, and with a
///   [`PhysicalDeviceExternalImageFormatInfo`] structure included in the [`p_next`] chain, with a
///   `handleType` equal to any one of the handle types specified in
///   [`ExternalMemoryImageCreateInfo::handle_types`]
/// - If the [`p_next`] chain includes a [`ExternalMemoryImageCreateInfoNV`] structure, its
///   `handleTypes` member  **must**  only contain bits that are also in
///   [`ExternalImageFormatPropertiesNV`]::`externalMemoryProperties.compatibleHandleTypes`, as
///   returned by [`GetPhysicalDeviceExternalImageFormatPropertiesNV`] with [`format`],
///   [`image_type`], [`tiling`], [`usage`], and [`flags`] equal to those in this structure, and
///   with `externalHandleType` equal to any one of the handle types specified in
///   [`ExternalMemoryImageCreateInfoNV::handle_types`]
/// - If the logical device was created with [`DeviceGroupDeviceCreateInfo::physical_device_count`]
///   equal to 1, [`flags`] **must**  not contain `VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT`
/// -    If [`flags`] contains `VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT`, then [`mip_levels`] **must**  be one, [`array_layers`] **must**  be one, [`image_type`] **must**  be `VK_IMAGE_TYPE_2D`. and `imageCreateMaybeLinear` (as defined in [Image Creation Limits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#resources-image-creation-limits))  **must**  be [`FALSE`]
/// -    If [`flags`] contains `VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT`, then [`format`] **must**  be a [compressed image format](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#compressed_image_formats)
/// - If [`flags`] contains `VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT`, then [`flags`]
///   **must**  also contain `VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT`
/// - [`initial_layout`] **must**  be `VK_IMAGE_LAYOUT_UNDEFINED` or
///   `VK_IMAGE_LAYOUT_PREINITIALIZED`
/// - If the [`p_next`] chain includes a [`ExternalMemoryImageCreateInfo`] or
///   [`ExternalMemoryImageCreateInfoNV`] structure whose `handleTypes` member is not `0`,
///   [`initial_layout`] **must**  be `VK_IMAGE_LAYOUT_UNDEFINED`
/// -    If the image [`format`] is one of the [formats that require a sampler Y′C<sub>B</sub>C<sub>R</sub> conversion](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#formats-requiring-sampler-ycbcr-conversion), [`mip_levels`] **must**  be 1
/// -    If the image [`format`] is one of the [formats that require a sampler Y′C<sub>B</sub>C<sub>R</sub> conversion](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#formats-requiring-sampler-ycbcr-conversion), [`samples`] **must**  be `VK_SAMPLE_COUNT_1_BIT`
/// -    If the image [`format`] is one of the [formats that require a sampler Y′C<sub>B</sub>C<sub>R</sub> conversion](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#formats-requiring-sampler-ycbcr-conversion), [`image_type`] **must**  be `VK_IMAGE_TYPE_2D`
/// -    If the image [`format`] is one of the [formats that require a sampler Y′C<sub>B</sub>C<sub>R</sub> conversion](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#formats-requiring-sampler-ycbcr-conversion), and the `ycbcrImageArrays` feature is not enabled, [`array_layers`] **must**  be 1
/// -    If [`format`] is a *multi-planar* format, and if `imageCreateFormatFeatures` (as defined in [Image Creation Limits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#resources-image-creation-limits)) does not contain `VK_FORMAT_FEATURE_DISJOINT_BIT`, then [`flags`] **must**  not contain `VK_IMAGE_CREATE_DISJOINT_BIT`
/// - If [`format`] is not a *multi-planar* format, and [`flags`] does not include
///   `VK_IMAGE_CREATE_ALIAS_BIT`, [`flags`] **must**  not contain `VK_IMAGE_CREATE_DISJOINT_BIT`
/// - If [`format`] has a `_422` or `_420` suffix, `width` **must**  be a multiple of 2
/// - If [`format`] has a `_420` suffix, `height` **must**  be a multiple of 2
/// - If [`tiling`] is `VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT`, then the [`p_next`] chain
///   **must**  include exactly one of [`ImageDrmFormatModifierListCreateInfoEXT`] or
///   [`ImageDrmFormatModifierExplicitCreateInfoEXT`] structures
/// - If the [`p_next`] chain includes a [`ImageDrmFormatModifierListCreateInfoEXT`] or
///   [`ImageDrmFormatModifierExplicitCreateInfoEXT`] structure, then [`tiling`] **must**  be
///   `VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT`
/// - If [`tiling`] is `VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT` and [`flags`] contains
///   `VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT`, then the [`p_next`] chain  **must**  include a
///   [`ImageFormatListCreateInfo`] structure with non-zero `viewFormatCount`
/// - If [`flags`] contains `VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT`[`format`]
///   **must**  be a depth or depth/stencil format
/// - If the [`p_next`] chain includes a [`ExternalMemoryImageCreateInfo`] structure whose
///   `handleTypes` member includes
///   `VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID`, [`image_type`] **must**
///   be `VK_IMAGE_TYPE_2D`
/// - If the [`p_next`] chain includes a [`ExternalMemoryImageCreateInfo`] structure whose
///   `handleTypes` member includes
///   `VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID`, [`mip_levels`] **must**
///   either be `1` or equal to the number of levels in the complete mipmap chain based on
///   `extent.width`, `extent.height`, and `extent.depth`
/// - If the [`p_next`] chain includes a [`ExternalFormatANDROID`] structure whose `externalFormat`
///   member is not `0`, [`flags`] **must**  not include `VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT`
/// - If the [`p_next`] chain includes a [`ExternalFormatANDROID`] structure whose `externalFormat`
///   member is not `0`, [`usage`] **must**  not include any usages except
///   `VK_IMAGE_USAGE_SAMPLED_BIT`
/// - If the [`p_next`] chain includes a [`ExternalFormatANDROID`] structure whose `externalFormat`
///   member is not `0`, [`tiling`] **must**  be `VK_IMAGE_TILING_OPTIMAL`
/// - If [`format`] is a depth-stencil format, [`usage`] includes
///   `VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT`, and the [`p_next`] chain includes a
///   [`ImageStencilUsageCreateInfo`] structure, then its
///   [`ImageStencilUsageCreateInfo::stencil_usage`] member  **must**  also include
///   `VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT`
/// - If [`format`] is a depth-stencil format, [`usage`] does not include
///   `VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT`, and the [`p_next`] chain includes a
///   [`ImageStencilUsageCreateInfo`] structure, then its
///   [`ImageStencilUsageCreateInfo::stencil_usage`] member  **must**  also not include
///   `VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT`
/// - If [`format`] is a depth-stencil format, [`usage`] includes
///   `VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT`, and the [`p_next`] chain includes a
///   [`ImageStencilUsageCreateInfo`] structure, then its
///   [`ImageStencilUsageCreateInfo::stencil_usage`] member  **must**  also include
///   `VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT`
/// - If [`format`] is a depth-stencil format, [`usage`] does not include
///   `VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT`, and the [`p_next`] chain includes a
///   [`ImageStencilUsageCreateInfo`] structure, then its
///   [`ImageStencilUsageCreateInfo::stencil_usage`] member  **must**  also not include
///   `VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT`
/// - If [`Format`] is a depth-stencil format and the [`p_next`] chain includes a
///   [`ImageStencilUsageCreateInfo`] structure with its `stencilUsage` member including
///   `VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT`, `extent.width` **must**  be less than or equal to
///   [`PhysicalDeviceLimits::max_framebuffer_width`]
/// - If [`format`] is a depth-stencil format and the [`p_next`] chain includes a
///   [`ImageStencilUsageCreateInfo`] structure with its `stencilUsage` member including
///   `VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT`, `extent.height` **must**  be less than or equal to
///   [`PhysicalDeviceLimits::max_framebuffer_height`]
/// - If the [multisampled storage images](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-shaderStorageImageMultisample)
///   feature is not enabled, [`format`] is a depth-stencil format and the [`p_next`] chain includes
///   a [`ImageStencilUsageCreateInfo`] structure with its `stencilUsage` including
///   `VK_IMAGE_USAGE_STORAGE_BIT`, [`samples`] **must**  be `VK_SAMPLE_COUNT_1_BIT`
/// - If [`flags`] contains `VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV`, [`image_type`] **must**  be
///   `VK_IMAGE_TYPE_2D` or `VK_IMAGE_TYPE_3D`
/// - If [`flags`] contains `VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV`, it  **must**  not contain
///   `VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT` and the [`format`] **must**  not be a depth/stencil
///   format
/// - If [`flags`] contains `VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV` and [`image_type`] is
///   `VK_IMAGE_TYPE_2D`, `extent.width` and `extent.height` **must**  be greater than `1`
/// - If [`flags`] contains `VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV` and [`image_type`] is
///   `VK_IMAGE_TYPE_3D`, `extent.width`, `extent.height`, and `extent.depth` **must**  be greater
///   than `1`
/// - If [`usage`] includes `VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR`,
///   [`image_type`] **must**  be `VK_IMAGE_TYPE_2D`
/// - If [`usage`] includes `VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR`, [`samples`]
///   **must**  be `VK_SAMPLE_COUNT_1_BIT`
/// - If [`usage`] includes `VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV`, [`tiling`] **must**  be
///   `VK_IMAGE_TILING_OPTIMAL`
/// - If [`flags`] contains `VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT`, [`tiling`] **must**  be
///   `VK_IMAGE_TILING_OPTIMAL`
/// - If [`flags`] contains `VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT`, [`image_type`] **must**  be
///   `VK_IMAGE_TYPE_2D`
/// - If [`flags`] contains `VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT`, [`flags`] **must**  not contain
///   `VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT`
/// - If [`flags`] contains `VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT`, [`mip_levels`] **must**  be `1`
/// - If [`usage`] includes `VK_IMAGE_USAGE_INVOCATION_MASK_BIT_HUAWEI`, [`tiling`] **must**  be
///   `VK_IMAGE_TILING_LINEAR`
/// - If the `[`VK_KHR_portability_subset`]` extension is enabled, and
///   [`PhysicalDevicePortabilitySubsetFeaturesKHR::image_view_2_d_on_3_d_image`] is [`FALSE`],
///   [`flags`] **must**  not contain `VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT`
/// - If the `[`VK_KHR_portability_subset`]` extension is enabled, and
///   [`PhysicalDevicePortabilitySubsetFeaturesKHR::multisample_array_image`] is [`FALSE`], and
///   [`samples`] is not `VK_SAMPLE_COUNT_1_BIT`, then [`array_layers`] **must**  be `1`
/// -    If a [`ImageFormatListCreateInfo`] structure was included in the [`p_next`] chain and [`ImageFormatListCreateInfo::view_format_count`] is not zero, then all of the formats in [`ImageFormatListCreateInfo::view_formats`] **must**  be compatible with the [`format`] as described in the [compatibility table](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#formats-compatibility)
/// - If [`flags`] does not contain `VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT` and the [`p_next`] chain
///   includes a [`ImageFormatListCreateInfo`] structure, then
///   [`ImageFormatListCreateInfo::view_format_count`] **must**  be `0` or `1`
/// - If [`usage`] includes `VK_IMAGE_USAGE_VIDEO_DECODE_DST_BIT_KHR`,
///   `VK_IMAGE_USAGE_VIDEO_DECODE_DPB_BIT_KHR`, then the [`p_next`] chain  **must**  include a
///   valid [`VideoProfilesKHR`] structure which includes at least one [`VideoProfileKHR`] with a
///   decode codec-operation
/// - If [`usage`] includes `VK_IMAGE_USAGE_VIDEO_ENCODE_DST_BIT_KHR`,
///   `VK_IMAGE_USAGE_VIDEO_ENCODE_SRC_BIT_KHR`, `VK_IMAGE_USAGE_VIDEO_ENCODE_DPB_BIT_KHR`, then the
///   [`p_next`] chain  **must**  include a valid [`VideoProfilesKHR`] structure which includes at
///   least one [`VideoProfileKHR`] with a encode codec-operation
/// - If the [`Image`] is to be used to import memory from a [`BufferCollectionFUCHSIA`], a
///   [`BufferCollectionImageCreateInfoFUCHSIA`] structure  **must**  be chained to [`p_next`].
///
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be `VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO`
/// - Each [`p_next`] member of any structure (including this one) in the [`p_next`] chain  **must**
///   be either `NULL` or a pointer to a valid instance of
///   [`BufferCollectionImageCreateInfoFUCHSIA`], [`DedicatedAllocationImageCreateInfoNV`],
///   [`ExternalFormatANDROID`], [`ExternalMemoryImageCreateInfo`],
///   [`ExternalMemoryImageCreateInfoNV`], [`ImageDrmFormatModifierExplicitCreateInfoEXT`],
///   [`ImageDrmFormatModifierListCreateInfoEXT`], [`ImageFormatListCreateInfo`],
///   [`ImageStencilUsageCreateInfo`], [`ImageSwapchainCreateInfoKHR`],
///   [`VideoDecodeH264ProfileEXT`], [`VideoDecodeH265ProfileEXT`], [`VideoEncodeH264ProfileEXT`],
///   [`VideoEncodeH265ProfileEXT`], [`VideoProfileKHR`], or [`VideoProfilesKHR`]
/// - The [`s_type`] value of each struct in the [`p_next`] chain  **must**  be unique
/// - [`flags`] **must**  be a valid combination of [`ImageCreateFlagBits`] values
/// - [`image_type`] **must**  be a valid [`ImageType`] value
/// - [`format`] **must**  be a valid [`Format`] value
/// - [`samples`] **must**  be a valid [`SampleCountFlagBits`] value
/// - [`tiling`] **must**  be a valid [`ImageTiling`] value
/// - [`usage`] **must**  be a valid combination of [`ImageUsageFlagBits`] values
/// - [`usage`] **must**  not be `0`
/// - [`sharing_mode`] **must**  be a valid [`SharingMode`] value
/// - [`initial_layout`] **must**  be a valid [`ImageLayout`] value
///# Related
/// - [`crate::vulkan1_0`]
/// - [`DeviceImageMemoryRequirements`]
/// - [`Extent3D`]
/// - [`Format`]
/// - [`ImageCreateFlags`]
/// - [`ImageFormatConstraintsInfoFUCHSIA`]
/// - [`ImageLayout`]
/// - [`ImageTiling`]
/// - [`ImageType`]
/// - [`ImageUsageFlags`]
/// - [`SampleCountFlagBits`]
/// - [`SharingMode`]
/// - [`StructureType`]
/// - [`CreateImage`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[repr(C)]
pub struct ImageCreateInfo<'lt> {
    _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] is the type of this structure.
    s_type: StructureType,
    ///[`p_next`] is `NULL` or a pointer to a structure extending this
    ///structure.
    p_next: *const BaseInStructure<'lt>,
    ///[`flags`] is a bitmask of [`ImageCreateFlagBits`] describing
    ///additional parameters of the image.
    flags: ImageCreateFlags,
    ///[`image_type`] is a [`ImageType`] value specifying the basic
    ///dimensionality of the image.
    ///Layers in array textures do not count as a dimension for the purposes of
    ///the image type.
    image_type: ImageType,
    ///[`format`] is a [`Format`] describing the format and type of the
    ///texel blocks that will be contained in the image.
    format: Format,
    ///[`extent`] is a [`Extent3D`] describing the number of data
    ///elements in each dimension of the base level.
    extent: Extent3D,
    ///[`mip_levels`] describes the number of levels of detail available for
    ///minified sampling of the image.
    mip_levels: u32,
    ///[`array_layers`] is the number of layers in the image.
    array_layers: u32,
    ///[`samples`] is a [`SampleCountFlagBits`] value specifying the
    ///number of [samples per texel](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#primsrast-multisampling).
    samples: SampleCountFlagBits,
    ///[`tiling`] is a [`ImageTiling`] value specifying the tiling
    ///arrangement of the texel blocks in memory.
    tiling: ImageTiling,
    ///[`usage`] is a bitmask of [`ImageUsageFlagBits`] describing the
    ///intended usage of the image.
    usage: ImageUsageFlags,
    ///[`sharing_mode`] is a [`SharingMode`] value specifying the sharing
    ///mode of the image when it will be accessed by multiple queue families.
    sharing_mode: SharingMode,
    ///[`queue_family_index_count`] is the number of entries in the
    ///[`queue_family_indices`] array.
    queue_family_index_count: u32,
    ///[`queue_family_indices`] is a pointer to an array of queue families
    ///that will access this image.
    ///It is ignored if [`sharing_mode`] is not
    ///`VK_SHARING_MODE_CONCURRENT`.
    queue_family_indices: *const u32,
    ///[`initial_layout`] is a [`ImageLayout`] value specifying the
    ///initial [`ImageLayout`] of all image subresources of the image.
    ///See [Image Layouts](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#resources-image-layouts).
    initial_layout: ImageLayout,
}
impl<'lt> Default for ImageCreateInfo<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: Default::default(),
            p_next: std::ptr::null(),
            flags: Default::default(),
            image_type: Default::default(),
            format: Default::default(),
            extent: Default::default(),
            mip_levels: 0,
            array_layers: 0,
            samples: Default::default(),
            tiling: Default::default(),
            usage: Default::default(),
            sharing_mode: Default::default(),
            queue_family_index_count: 0,
            queue_family_indices: std::ptr::null(),
            initial_layout: Default::default(),
        }
    }
}
impl<'lt> ImageCreateInfo<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *const BaseInStructure<'lt> {
        self.p_next
    }
    ///Gets the raw value of [`Self::queue_family_indices`]
    pub fn queue_family_indices_raw(&self) -> *const u32 {
        self.queue_family_indices
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *const BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::queue_family_indices`]
    pub fn set_queue_family_indices_raw(&mut self, value: *const u32) -> &mut Self {
        self.queue_family_indices = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseInStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::flags`]
    pub fn flags(&self) -> ImageCreateFlags {
        self.flags
    }
    ///Gets the value of [`Self::image_type`]
    pub fn image_type(&self) -> ImageType {
        self.image_type
    }
    ///Gets the value of [`Self::format`]
    pub fn format(&self) -> Format {
        self.format
    }
    ///Gets the value of [`Self::extent`]
    pub fn extent(&self) -> Extent3D {
        self.extent
    }
    ///Gets the value of [`Self::mip_levels`]
    pub fn mip_levels(&self) -> u32 {
        self.mip_levels
    }
    ///Gets the value of [`Self::array_layers`]
    pub fn array_layers(&self) -> u32 {
        self.array_layers
    }
    ///Gets the value of [`Self::samples`]
    pub fn samples(&self) -> SampleCountFlagBits {
        self.samples
    }
    ///Gets the value of [`Self::tiling`]
    pub fn tiling(&self) -> ImageTiling {
        self.tiling
    }
    ///Gets the value of [`Self::usage`]
    pub fn usage(&self) -> ImageUsageFlags {
        self.usage
    }
    ///Gets the value of [`Self::sharing_mode`]
    pub fn sharing_mode(&self) -> SharingMode {
        self.sharing_mode
    }
    ///Gets the value of [`Self::queue_family_index_count`]
    pub fn queue_family_index_count(&self) -> u32 {
        self.queue_family_index_count
    }
    ///Gets the value of [`Self::queue_family_indices`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn queue_family_indices(&self) -> &[u32] {
        std::slice::from_raw_parts(self.queue_family_indices, self.queue_family_index_count as usize)
    }
    ///Gets the value of [`Self::initial_layout`]
    pub fn initial_layout(&self) -> ImageLayout {
        self.initial_layout
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::flags`]
    pub fn flags_mut(&mut self) -> &mut ImageCreateFlags {
        &mut self.flags
    }
    ///Gets a mutable reference to the value of [`Self::image_type`]
    pub fn image_type_mut(&mut self) -> &mut ImageType {
        &mut self.image_type
    }
    ///Gets a mutable reference to the value of [`Self::format`]
    pub fn format_mut(&mut self) -> &mut Format {
        &mut self.format
    }
    ///Gets a mutable reference to the value of [`Self::extent`]
    pub fn extent_mut(&mut self) -> &mut Extent3D {
        &mut self.extent
    }
    ///Gets a mutable reference to the value of [`Self::mip_levels`]
    pub fn mip_levels_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::array_layers`]
    pub fn array_layers_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::samples`]
    pub fn samples_mut(&mut self) -> &mut SampleCountFlagBits {
        &mut self.samples
    }
    ///Gets a mutable reference to the value of [`Self::tiling`]
    pub fn tiling_mut(&mut self) -> &mut ImageTiling {
        &mut self.tiling
    }
    ///Gets a mutable reference to the value of [`Self::usage`]
    pub fn usage_mut(&mut self) -> &mut ImageUsageFlags {
        &mut self.usage
    }
    ///Gets a mutable reference to the value of [`Self::sharing_mode`]
    pub fn sharing_mode_mut(&mut self) -> &mut SharingMode {
        &mut self.sharing_mode
    }
    ///Gets a mutable reference to the value of [`Self::queue_family_index_count`]
    pub fn queue_family_index_count_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::initial_layout`]
    pub fn initial_layout_mut(&mut self) -> &mut ImageLayout {
        &mut self.initial_layout
    }
    ///Sets the raw value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the raw value of [`Self::flags`]
    pub fn set_flags(&mut self, value: crate::vulkan1_0::ImageCreateFlags) -> &mut Self {
        self.flags = value;
        self
    }
    ///Sets the raw value of [`Self::image_type`]
    pub fn set_image_type(&mut self, value: crate::vulkan1_0::ImageType) -> &mut Self {
        self.image_type = value;
        self
    }
    ///Sets the raw value of [`Self::format`]
    pub fn set_format(&mut self, value: crate::vulkan1_0::Format) -> &mut Self {
        self.format = value;
        self
    }
    ///Sets the raw value of [`Self::extent`]
    pub fn set_extent(&mut self, value: crate::vulkan1_0::Extent3D) -> &mut Self {
        self.extent = value;
        self
    }
    ///Sets the raw value of [`Self::mip_levels`]
    pub fn set_mip_levels(&mut self, value: u32) -> &mut Self {
        self.mip_levels = value;
        self
    }
    ///Sets the raw value of [`Self::array_layers`]
    pub fn set_array_layers(&mut self, value: u32) -> &mut Self {
        self.array_layers = value;
        self
    }
    ///Sets the raw value of [`Self::samples`]
    pub fn set_samples(&mut self, value: crate::vulkan1_0::SampleCountFlagBits) -> &mut Self {
        self.samples = value;
        self
    }
    ///Sets the raw value of [`Self::tiling`]
    pub fn set_tiling(&mut self, value: crate::vulkan1_0::ImageTiling) -> &mut Self {
        self.tiling = value;
        self
    }
    ///Sets the raw value of [`Self::usage`]
    pub fn set_usage(&mut self, value: crate::vulkan1_0::ImageUsageFlags) -> &mut Self {
        self.usage = value;
        self
    }
    ///Sets the raw value of [`Self::sharing_mode`]
    pub fn set_sharing_mode(&mut self, value: crate::vulkan1_0::SharingMode) -> &mut Self {
        self.sharing_mode = value;
        self
    }
    ///Sets the raw value of [`Self::queue_family_index_count`]
    pub fn set_queue_family_index_count(&mut self, value: u32) -> &mut Self {
        self.queue_family_index_count = value;
        self
    }
    ///Sets the raw value of [`Self::queue_family_indices`]
    pub fn set_queue_family_indices(&mut self, value: &'lt [u32]) -> &mut Self {
        let len_ = value.len() as u32;
        let len_ = len_;
        self.queue_family_indices = value.as_ptr();
        self.queue_family_index_count = len_;
        self
    }
    ///Sets the raw value of [`Self::initial_layout`]
    pub fn set_initial_layout(&mut self, value: crate::vulkan1_0::ImageLayout) -> &mut Self {
        self.initial_layout = value;
        self
    }
}
///[VkSubresourceLayout](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSubresourceLayout.html) - Structure specifying subresource layout
///# C Specifications
///Information about the layout of the image subresource is returned in a
///[`SubresourceLayout`] structure:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkSubresourceLayout {
///    VkDeviceSize    offset;
///    VkDeviceSize    size;
///    VkDeviceSize    rowPitch;
///    VkDeviceSize    arrayPitch;
///    VkDeviceSize    depthPitch;
///} VkSubresourceLayout;
///```
///# Members
/// - [`offset`] is the byte offset from the start of the image or the plane where the image
///   subresource begins.
/// - [`size`] is the size in bytes of the image subresource. [`size`] includes any extra memory
///   that is required based on [`row_pitch`].
/// - [`row_pitch`] describes the number of bytes between each row of texels in an image.
/// - [`array_pitch`] describes the number of bytes between each array layer of an image.
/// - [`depth_pitch`] describes the number of bytes between each slice of 3D image.
///# Description
///If the image is [linear](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#glossary-linear-resource), then [`row_pitch`],
///[`array_pitch`] and [`depth_pitch`] describe the layout of the image
///subresource in linear memory.
///For uncompressed formats, [`row_pitch`] is the number of bytes between
///texels with the same x coordinate in adjacent rows (y coordinates differ by
///one).
///[`array_pitch`] is the number of bytes between texels with the same x and y
///coordinate in adjacent array layers of the image (array layer values differ
///by one).
///[`depth_pitch`] is the number of bytes between texels with the same x and y
///coordinate in adjacent slices of a 3D image (z coordinates differ by one).
///Expressed as an addressing formula, the starting byte of a texel in the
///image subresource has address:
///```c
///// (x,y,z,layer) are in texel coordinates
///address(x,y,z,layer) = layer*arrayPitch + z*depthPitch + y*rowPitch + x*elementSize + offset
///```
///For compressed formats, the [`row_pitch`] is the number of bytes between
///compressed texel blocks in adjacent rows.
///[`array_pitch`] is the number of bytes between compressed texel blocks in
///adjacent array layers.
///[`depth_pitch`] is the number of bytes between compressed texel blocks in
///adjacent slices of a 3D image.
///```c
///// (x,y,z,layer) are in compressed texel block coordinates
///address(x,y,z,layer) = layer*arrayPitch + z*depthPitch + y*rowPitch +
/// x*compressedTexelBlockByteSize + offset;
///```
///The value of [`array_pitch`] is undefined for images that were not created
///as arrays.
///[`depth_pitch`] is defined only for 3D images.If the image has a
///*single-plane*
///color format
///and its tiling is `VK_IMAGE_TILING_LINEAR`
///, then the `aspectMask` member of [`ImageSubresource`] **must**  be
///`VK_IMAGE_ASPECT_COLOR_BIT`.If the image has a depth/stencil format
///and its tiling is `VK_IMAGE_TILING_LINEAR`
///, then `aspectMask` **must**  be either `VK_IMAGE_ASPECT_DEPTH_BIT` or
///`VK_IMAGE_ASPECT_STENCIL_BIT`.
///On implementations that store depth and stencil aspects separately, querying
///each of these image subresource layouts will return a different [`offset`]
///and [`size`] representing the region of memory used for that aspect.
///On implementations that store depth and stencil aspects interleaved, the
///same [`offset`] and [`size`] are returned and represent the interleaved
///memory allocation.If the image has a [multi-planar
///format](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#formats-requiring-sampler-ycbcr-conversion)
///and its tiling is `VK_IMAGE_TILING_LINEAR`
///, then the `aspectMask` member of [`ImageSubresource`] **must**  be
///`VK_IMAGE_ASPECT_PLANE_0_BIT`, `VK_IMAGE_ASPECT_PLANE_1_BIT`, or
///(for 3-plane formats only) `VK_IMAGE_ASPECT_PLANE_2_BIT`.
///Querying each of these image subresource layouts will return a different
///[`offset`] and [`size`] representing the region of memory used for that
///plane.
///If the image is *disjoint*, then the [`offset`] is relative to the base
///address of the plane.
///If the image is *non-disjoint*, then the [`offset`] is relative to the
///base address of the image.If the image’s tiling is `VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT`,
/// then
///the `aspectMask` member of [`ImageSubresource`] **must**  be one of
///`VK_IMAGE_ASPECT_MEMORY_PLANE*_i_*BIT_EXT`, where the maximum allowed
///plane index *i* is defined by the
///[`DrmFormatModifierPropertiesEXT::drm_format_modifier_plane_count`]
///associated with the image’s [`ImageCreateInfo::format`] and
///[modifier](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#glossary-drm-format-modifier).
///The memory range used by the subresource is described by [`offset`] and
///[`size`].
///If the image is *disjoint*, then the [`offset`] is relative to the base
///address of the *memory plane*.
///If the image is *non-disjoint*, then the [`offset`] is relative to the
///base address of the image.
///If the image is [non-linear](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#glossary-linear-resource), then
///[`row_pitch`], [`array_pitch`], and [`depth_pitch`] have an
///implementation-dependent meaning.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`DeviceSize`]
/// - [`ImageDrmFormatModifierExplicitCreateInfoEXT`]
/// - [`GetImageSubresourceLayout`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct SubresourceLayout {
    ///[`offset`] is the byte offset from the start of the image
    ///or the plane
    ///where the image subresource begins.
    offset: DeviceSize,
    ///[`size`] is the size in bytes of the image subresource.
    ///[`size`] includes any extra memory that is required based on
    ///[`row_pitch`].
    size: DeviceSize,
    ///[`row_pitch`] describes the number of bytes between each row of texels
    ///in an image.
    row_pitch: DeviceSize,
    ///[`array_pitch`] describes the number of bytes between each array layer
    ///of an image.
    array_pitch: DeviceSize,
    ///[`depth_pitch`] describes the number of bytes between each slice of 3D
    ///image.
    depth_pitch: DeviceSize,
}
impl Default for SubresourceLayout {
    fn default() -> Self {
        Self {
            offset: Default::default(),
            size: Default::default(),
            row_pitch: Default::default(),
            array_pitch: Default::default(),
            depth_pitch: Default::default(),
        }
    }
}
impl SubresourceLayout {
    ///Gets the value of [`Self::offset`]
    pub fn offset(&self) -> DeviceSize {
        self.offset
    }
    ///Gets the value of [`Self::size`]
    pub fn size(&self) -> DeviceSize {
        self.size
    }
    ///Gets the value of [`Self::row_pitch`]
    pub fn row_pitch(&self) -> DeviceSize {
        self.row_pitch
    }
    ///Gets the value of [`Self::array_pitch`]
    pub fn array_pitch(&self) -> DeviceSize {
        self.array_pitch
    }
    ///Gets the value of [`Self::depth_pitch`]
    pub fn depth_pitch(&self) -> DeviceSize {
        self.depth_pitch
    }
    ///Gets a mutable reference to the value of [`Self::offset`]
    pub fn offset_mut(&mut self) -> &mut DeviceSize {
        &mut self.offset
    }
    ///Gets a mutable reference to the value of [`Self::size`]
    pub fn size_mut(&mut self) -> &mut DeviceSize {
        &mut self.size
    }
    ///Gets a mutable reference to the value of [`Self::row_pitch`]
    pub fn row_pitch_mut(&mut self) -> &mut DeviceSize {
        &mut self.row_pitch
    }
    ///Gets a mutable reference to the value of [`Self::array_pitch`]
    pub fn array_pitch_mut(&mut self) -> &mut DeviceSize {
        &mut self.array_pitch
    }
    ///Gets a mutable reference to the value of [`Self::depth_pitch`]
    pub fn depth_pitch_mut(&mut self) -> &mut DeviceSize {
        &mut self.depth_pitch
    }
    ///Sets the raw value of [`Self::offset`]
    pub fn set_offset(&mut self, value: crate::vulkan1_0::DeviceSize) -> &mut Self {
        self.offset = value;
        self
    }
    ///Sets the raw value of [`Self::size`]
    pub fn set_size(&mut self, value: crate::vulkan1_0::DeviceSize) -> &mut Self {
        self.size = value;
        self
    }
    ///Sets the raw value of [`Self::row_pitch`]
    pub fn set_row_pitch(&mut self, value: crate::vulkan1_0::DeviceSize) -> &mut Self {
        self.row_pitch = value;
        self
    }
    ///Sets the raw value of [`Self::array_pitch`]
    pub fn set_array_pitch(&mut self, value: crate::vulkan1_0::DeviceSize) -> &mut Self {
        self.array_pitch = value;
        self
    }
    ///Sets the raw value of [`Self::depth_pitch`]
    pub fn set_depth_pitch(&mut self, value: crate::vulkan1_0::DeviceSize) -> &mut Self {
        self.depth_pitch = value;
        self
    }
}
///[VkImageViewCreateInfo](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageViewCreateInfo.html) - Structure specifying parameters of a newly created image view
///# C Specifications
///The [`ImageViewCreateInfo`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkImageViewCreateInfo {
///    VkStructureType            sType;
///    const void*                pNext;
///    VkImageViewCreateFlags     flags;
///    VkImage                    image;
///    VkImageViewType            viewType;
///    VkFormat                   format;
///    VkComponentMapping         components;
///    VkImageSubresourceRange    subresourceRange;
///} VkImageViewCreateInfo;
///```
///# Members
/// - [`s_type`] is the type of this structure.
/// - [`p_next`] is `NULL` or a pointer to a structure extending this structure.
/// - [`flags`] is a bitmask of [`ImageViewCreateFlagBits`] describing additional parameters of the
///   image view.
/// - [`image`] is a [`Image`] on which the view will be created.
/// - [`view_type`] is a [`ImageViewType`] value specifying the type of the image view.
/// - [`format`] is a [`Format`] describing the format and type used to interpret texel blocks in
///   the image.
/// - [`components`] is a [`ComponentMapping`] structure specifying a remapping of color components
///   (or of depth or stencil components after they have been converted into color components).
/// - [`subresource_range`] is a [`ImageSubresourceRange`] structure selecting the set of mipmap
///   levels and array layers to be accessible to the view.
///# Description
///Some of the [`image`] creation parameters are inherited by the view.
///In particular, image view creation inherits the implicit parameter
///`usage` specifying the allowed usages of the image view that, by
///default, takes the value of the corresponding `usage` parameter
///specified in [`ImageCreateInfo`] at image creation time.
///The implicit `usage` **can**  be overriden by adding a
///[`ImageViewUsageCreateInfo`] structure to the [`p_next`] chain, but the
///view usage  **must**  be a subset of the image usage.
///If [`image`] has a depth-stencil format and was created with a
///[`ImageStencilUsageCreateInfo`] structure included in the [`p_next`]
///chain of [`ImageCreateInfo`], the usage is calculated based on the
///`subresource.aspectMask` provided:
/// - If `aspectMask` includes only `VK_IMAGE_ASPECT_STENCIL_BIT`, the implicit `usage` is equal to
///   [`ImageStencilUsageCreateInfo::stencil_usage`].
/// - If `aspectMask` includes only `VK_IMAGE_ASPECT_DEPTH_BIT`, the implicit `usage` is equal to
///   [`ImageCreateInfo::usage`].
/// - If both aspects are included in `aspectMask`, the implicit `usage` is equal to the
///   intersection of [`ImageCreateInfo::usage`] and [`ImageStencilUsageCreateInfo::stencil_usage`].
///If [`image`] was created with the `VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT`
///flag,
///and if the [`format`] of the image is not
///[multi-planar](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#formats-requiring-sampler-ycbcr-conversion),
///[`format`] **can**  be different from the image’s format, but if
///[`image`] was created without the
///`VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT` flag and
///they are not equal they  **must**  be *compatible*.
///Image format compatibility is defined in the
///[Format Compatibility Classes](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#formats-compatibility-classes) section.
///Views of compatible formats will have the same mapping between texel
///coordinates and memory locations irrespective of the [`format`], with only
///the interpretation of the bit pattern changing.If [`image`] was created with the
///`VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT` flag, [`format`] **must**  be *compatible*
/// with the image’s format as described above, or  **must**
///be an uncompressed format in which case it  **must**  be *size-compatible* with
///the image’s format, as defined for
///[copying data between images](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#copies-images-format-size-compatibility).
///In this case, the resulting image view’s texel dimensions equal the
///dimensions of the selected mip level divided by the compressed texel block
///size and rounded up.The [`ComponentMapping`][`components`] member describes a remapping
///from components of the image to components of the vector returned by shader
///image instructions.
///This remapping  **must**  be the identity swizzle for storage image descriptors,
///input attachment descriptors,
///framebuffer attachments, and any [`ImageView`] used with a combined
///image sampler that enables [sampler Y′C<sub>B</sub>C<sub>R</sub>
///conversion](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#samplers-YCbCr-conversion).If the image view is to be used with a sampler which supports
///[sampler Y′C<sub>B</sub>C<sub>R</sub> conversion](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#samplers-YCbCr-conversion), an *identically
///defined object* of type [`SamplerYcbcrConversion`] to that used to
///create the sampler  **must**  be passed to [`CreateImageView`] in a
///[`SamplerYcbcrConversionInfo`] included in the [`p_next`] chain of
///[`ImageViewCreateInfo`].
///Conversely, if a [`SamplerYcbcrConversion`] object is passed to
///[`CreateImageView`], an identically defined
///[`SamplerYcbcrConversion`] object  **must**  be used when sampling the image.If the image has a
///[multi-planar](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#formats-requiring-sampler-ycbcr-conversion)[`format`] and
///`subresourceRange.aspectMask` is `VK_IMAGE_ASPECT_COLOR_BIT`,
///    and it was created with `usage` value containing flags other than
///    `VK_IMAGE_USAGE_VIDEO_DECODE_DST_BIT_KHR`,
///    `VK_IMAGE_USAGE_VIDEO_DECODE_DPB_BIT_KHR`
///    , `VK_IMAGE_USAGE_VIDEO_ENCODE_SRC_BIT_KHR`,
///    `VK_IMAGE_USAGE_VIDEO_ENCODE_DPB_BIT_KHR`,
///then the [`format`] **must**  be identical to the image [`format`], and the
///sampler to be used with the image view  **must**  enable
///[sampler Y′C<sub>B</sub>C<sub>R</sub> conversion](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#samplers-YCbCr-conversion).If the image has a
///[multi-planar](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#formats-requiring-sampler-ycbcr-conversion)[`format`] and
///the [`image`] has been created with a `usage` value containing any of
///the `VK_IMAGE_USAGE_VIDEO_DECODE_DST_BIT_KHR`,
///`VK_IMAGE_USAGE_VIDEO_DECODE_SRC_BIT_KHR`, and
///`VK_IMAGE_USAGE_VIDEO_DECODE_DPB_BIT_KHR` flags, then all of the
///[video decode operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-decode-operations) would ignore the
///[`SamplerYcbcrConversionInfo`] structure and/or
///[sampler Y′C<sub>B</sub>C<sub>R</sub> conversion](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#samplers-YCbCr-conversion) object, associated
///with the image view.
///If the image has a
///[multi-planar](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#formats-requiring-sampler-ycbcr-conversion)[`format`] and
///the [`image`] has been created with a `usage` value containing any of
///the `VK_IMAGE_USAGE_VIDEO_ENCODE_DST_BIT_KHR`,
///`VK_IMAGE_USAGE_VIDEO_ENCODE_SRC_BIT_KHR`, and
///`VK_IMAGE_USAGE_VIDEO_ENCODE_DPB_BIT_KHR` flags, then all of the
///[video encode operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#video-encode-operations) would ignore the
///[`SamplerYcbcrConversionInfo`] structure and/or
///[sampler Y′C<sub>B</sub>C<sub>R</sub> conversion](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#samplers-YCbCr-conversion) object, associated
///with the image view.If [`image`] was created with the `VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT`
///and the image has a
///[multi-planar](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#formats-requiring-sampler-ycbcr-conversion)[`format`],
///and if `subresourceRange.aspectMask` is
///`VK_IMAGE_ASPECT_PLANE_0_BIT`, `VK_IMAGE_ASPECT_PLANE_1_BIT`, or
///`VK_IMAGE_ASPECT_PLANE_2_BIT`, [`format`] **must**  be
///[compatible](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#formats-compatible-planes) with the corresponding plane of the
///image, and the sampler to be used with the image view  **must**  not enable
///[sampler Y′C<sub>B</sub>C<sub>R</sub> conversion](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#samplers-YCbCr-conversion).
///The `width` and `height` of the single-plane image view  **must**  be
///derived from the multi-planar image’s dimensions in the manner listed for
///[plane compatibility](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#formats-compatible-planes) for the plane.Any view of an image plane will have the same mapping between texel
///coordinates and memory locations as used by the components of the color
///aspect, subject to the formulae relating texel coordinates to
///lower-resolution planes as described in [Chroma Reconstruction](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#textures-chroma-reconstruction).
///That is, if an R or B plane has a reduced resolution relative to the G plane
///of the multi-planar image, the image view operates using the (*u<sub>plane</sub>*,
///*v<sub>plane</sub>*) unnormalized coordinates of the reduced-resolution plane, and
///these coordinates access the same memory locations as the (*u<sub>color</sub>*,
///*v<sub>color</sub>*) unnormalized coordinates of the color aspect for which chroma
///reconstruction operations operate on the same (*u<sub>plane</sub>*, *v<sub>plane</sub>*) or
///(*i<sub>plane</sub>*, *j<sub>plane</sub>*) coordinates.
///## Valid Usage
/// - If [`image`] was not created with `VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT` then [`view_type`]
///   **must**  not be `VK_IMAGE_VIEW_TYPE_CUBE` or `VK_IMAGE_VIEW_TYPE_CUBE_ARRAY`
/// - If the [image cube map arrays](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-imageCubeArray)
///   feature is not enabled, [`view_type`] **must**  not be `VK_IMAGE_VIEW_TYPE_CUBE_ARRAY`
/// - If [`image`] was created with `VK_IMAGE_TYPE_3D` but without
///   `VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT` set then [`view_type`] **must**  not be
///   `VK_IMAGE_VIEW_TYPE_2D` or `VK_IMAGE_VIEW_TYPE_2D_ARRAY`
/// - If [`image`] was created with `VK_IMAGE_TYPE_3D` and [`view_type`] is `VK_IMAGE_VIEW_TYPE_2D`
///   or `VK_IMAGE_VIEW_TYPE_2D_ARRAY` then `subresourceRange.levelCount` **must**  be 1
/// - If [`image`] was created with `VK_IMAGE_TYPE_3D` and [`view_type`] is `VK_IMAGE_VIEW_TYPE_2D`
///   or `VK_IMAGE_VIEW_TYPE_2D_ARRAY` then [`ImageCreateInfo`]::[`flags`] **must**  not contain any
///   of `VK_IMAGE_CREATE_SPARSE_BINDING_BIT`, `VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT`, and
///   `VK_IMAGE_CREATE_SPARSE_ALIASED_BIT`
/// - If [`image`] was created with a `samples` value not equal to `VK_SAMPLE_COUNT_1_BIT` then
///   [`view_type`] **must**  be either `VK_IMAGE_VIEW_TYPE_2D` or `VK_IMAGE_VIEW_TYPE_2D_ARRAY`
/// -  [`image`] **must**  have been created with a `usage` value containing at least one of the usages defined in the [valid image usage](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#valid-imageview-imageusage) list for image views
/// - The [format features](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#resources-image-view-format-features)
///   of the resultant image view  **must**  contain at least one bit
/// - If `usage` contains `VK_IMAGE_USAGE_SAMPLED_BIT`, then the [format features](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#resources-image-view-format-features)
///   of the resultant image view  **must**  contain `VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT`
/// - If `usage` contains `VK_IMAGE_USAGE_STORAGE_BIT`, then the image view’s [format features](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#resources-image-view-format-features)
///   **must**  contain `VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT`
/// - If `usage` contains `VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT`, then the image view’s [format features](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#resources-image-view-format-features)
///   **must**  contain `VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT`
/// -    If `usage` contains `VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT`, then the image view’s [format features](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#resources-image-view-format-features) **must**  contain `VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT`
/// -    If `usage` contains `VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT`, then the image view’s [format features](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#resources-image-view-format-features) **must**  contain `VK_FORMAT_FEATURE_2_LINEAR_COLOR_ATTACHMENT_BIT_NV`, if the image is created with `VK_IMAGE_TILING_LINEAR` and the [`linearColorAttachment`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-linearColorAttachment) feature is enabled
/// -    If `usage` contains `VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT`, then the image view’s [format features](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#resources-image-view-format-features) must contain `VK_FORMAT_FEATURE_2_LINEAR_COLOR_ATTACHMENT_BIT_NV`, if the image is created with `VK_IMAGE_TILING_LINEAR` and the [`linearColorAttachment`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-linearColorAttachment) feature is enabled
/// - If `usage` contains `VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT`, then the image view’s [format features](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#resources-image-view-format-features)
///   **must**  contain at least one of `VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT` or
///   `VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT`
/// - `subresourceRange.baseMipLevel` **must**  be less than the `mipLevels` specified in
///   [`ImageCreateInfo`] when [`image`] was created
/// - If `subresourceRange.levelCount` is not [`REMAINING_MIP_LEVELS`],
///   `subresourceRange.baseMipLevel` +  `subresourceRange.levelCount` **must**  be less than or
///   equal to the `mipLevels` specified in [`ImageCreateInfo`] when [`image`] was created
/// - If [`image`] was created with `usage` containing
///   `VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT`, `subresourceRange.levelCount` **must**  be `1`
/// - If [`image`] is not a 3D image created with `VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT` set, or
///   [`view_type`] is not `VK_IMAGE_VIEW_TYPE_2D` or `VK_IMAGE_VIEW_TYPE_2D_ARRAY`,
///   `subresourceRange.baseArrayLayer` **must**  be less than the `arrayLayers` specified in
///   [`ImageCreateInfo`] when [`image`] was created
/// - If `subresourceRange.layerCount` is not [`REMAINING_ARRAY_LAYERS`], [`image`] is not a 3D
///   image created with `VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT` set, or [`view_type`] is not
///   `VK_IMAGE_VIEW_TYPE_2D` or `VK_IMAGE_VIEW_TYPE_2D_ARRAY`, `subresourceRange.layerCount`
///   **must**  be non-zero and `subresourceRange.baseArrayLayer` +  `subresourceRange.layerCount`
///   **must**  be less than or equal to the `arrayLayers` specified in [`ImageCreateInfo`] when
///   [`image`] was created
/// -    If [`image`] is a 3D image created with `VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT` set, and [`view_type`] is `VK_IMAGE_VIEW_TYPE_2D` or `VK_IMAGE_VIEW_TYPE_2D_ARRAY`, `subresourceRange.baseArrayLayer` **must**  be less than the depth computed from `baseMipLevel` and `extent.depth` specified in [`ImageCreateInfo`] when [`image`] was created, according to the formula defined in [Image Miplevel Sizing](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#resources-image-miplevel-sizing)
/// -    If `subresourceRange.layerCount` is not [`REMAINING_ARRAY_LAYERS`], [`image`] is a 3D image created with `VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT` set, and [`view_type`] is `VK_IMAGE_VIEW_TYPE_2D` or `VK_IMAGE_VIEW_TYPE_2D_ARRAY`, `subresourceRange.layerCount` **must**  be non-zero and `subresourceRange.baseArrayLayer` +  `subresourceRange.layerCount` **must**  be less than or equal to the depth computed from `baseMipLevel` and `extent.depth` specified in [`ImageCreateInfo`] when [`image`] was created, according to the formula defined in [Image Miplevel Sizing](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#resources-image-miplevel-sizing)
/// -    If [`image`] was created with the `VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT` flag, but without the `VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT` flag, and if the [`format`] of the [`image`] is not a [multi-planar](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#formats-requiring-sampler-ycbcr-conversion) format, [`format`] **must**  be compatible with the [`format`] used to create [`image`], as defined in [Format Compatibility Classes](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#formats-compatibility-classes)
/// - If [`image`] was created with the `VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT` flag,
///   [`format`] **must**  be compatible with, or  **must**  be an uncompressed format that is
///   size-compatible with, the [`format`] used to create [`image`]
/// - If [`image`] was created with the `VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT` flag, the
///   `levelCount` and `layerCount` members of [`subresource_range`] **must**  both be `1`
/// - If [`image`] was created with the `VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT` flag and
///   [`format`] is a non-compressed format, [`view_type`] **must**  not be `VK_IMAGE_VIEW_TYPE_3D`
/// - If a [`ImageFormatListCreateInfo`] structure was included in the [`p_next`] chain of the
///   [`ImageCreateInfo`] structure used when creating [`image`] and
///   [`ImageFormatListCreateInfo::view_format_count`] is not zero then [`format`] **must**  be one
///   of the formats in [`ImageFormatListCreateInfo::view_formats`]
/// - If [`image`] was created with the `VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT` flag, if the [`format`]
///   of the [`image`] is a [multi-planar](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#formats-requiring-sampler-ycbcr-conversion)
///   format, and if `subresourceRange.aspectMask` is one of `VK_IMAGE_ASPECT_PLANE_0_BIT`, `VK_IMAGE_ASPECT_PLANE_1_BIT`,
///   or `VK_IMAGE_ASPECT_PLANE_2_BIT`, then [`format`] **must**  be compatible with the [`Format`] for
///   the plane of the [`image`][`format`] indicated by `subresourceRange.aspectMask`, as defined in
///   [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#formats-compatible-planes](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#formats-compatible-planes)
/// -    If [`image`] was not created with the `VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT` flag, or if the [`format`] of the [`image`] is a [multi-planar](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#formats-requiring-sampler-ycbcr-conversion) format and if `subresourceRange.aspectMask` is `VK_IMAGE_ASPECT_COLOR_BIT`, [`format`] **must**  be identical to the [`format`] used to create [`image`]
/// - If the image view [requires a sampler Y′C<sub>B</sub>C<sub>R</sub> conversion](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#image-views-requiring-sampler-ycbcr-conversion),
///   the [`p_next`] chain must include a [`SamplerYcbcrConversionInfo`] structure with a conversion
///   value other than [`crate::utils::Handle::null`]
/// - If [`format`] has a `_422` or `_420` suffix then [`image`] **must**  have been created with a
///   width that is a multiple of 2
/// - If [`format`] has a `_420` suffix then [`image`] **must**  have been created with a height
///   that is a multiple of 2
/// -    If the [`p_next`] chain includes a [`SamplerYcbcrConversionInfo`] structure with a `conversion` value other than [`crate::utils::Handle::null`], all members of [`components`] **must**  have the [identity swizzle](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#resources-image-views-identity-mappings)
/// - If [`image`] is non-sparse then it  **must**  be bound completely and contiguously to a single
///   [`DeviceMemory`] object
/// -  [`view_type`] **must**  be compatible with the type of [`image`] as shown in the [view type compatibility table](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#resources-image-views-compatibility)
/// - If [`image`] has an [external format](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#memory-external-android-hardware-buffer-external-formats),
///   [`format`] **must**  be `VK_FORMAT_UNDEFINED`
/// - If [`image`] has an [external format](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#memory-external-android-hardware-buffer-external-formats),
///   the [`p_next`] chain  **must**  include a [`SamplerYcbcrConversionInfo`] structure with a
///   `conversion` object created with the same external format as [`image`]
/// - If [`image`] has an [external format](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#memory-external-android-hardware-buffer-external-formats),
///   all members of [`components`] **must**  be the [identity swizzle](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#resources-image-views-identity-mappings)
/// - If [`image`] was created with `usage` containing
///   `VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR`, [`view_type`] **must**  be
///   `VK_IMAGE_VIEW_TYPE_2D` or `VK_IMAGE_VIEW_TYPE_2D_ARRAY`
/// - If the [`shadingRateImage` feature](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-shadingRateImage)
///   is enabled, and If [`image`] was created with `usage` containing
///   `VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV`, [`format`] **must**  be `VK_FORMAT_R8_UINT`
/// -    If the [`attachmentFragmentShadingRate` feature](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-attachmentFragmentShadingRate) is enabled, and the `usage` for the image view includes `VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR`, then the image view’s [format features](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#resources-image-view-format-features) **must**  contain `VK_FORMAT_FEATURE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR`
/// -    If the [`attachmentFragmentShadingRate` feature](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-attachmentFragmentShadingRate) is enabled, the `usage` for the image view includes `VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR`, and [`layeredShadingRateAttachments`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#limits-layeredShadingRateAttachments) is [`FALSE`], `subresourceRange.layerCount` **must**  be `1`
/// - If [dynamic fragment density map](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-fragmentDensityMapDynamic)
///   feature is not enabled, [`flags`] **must**  not contain
///   `VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT`
/// - If [deferred fragment density map](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-fragmentDensityMapDeferred)
///   feature is not enabled, [`flags`] **must**  not contain
///   `VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DEFERRED_BIT_EXT`
/// - If [`flags`] contains `VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DEFERRED_BIT_EXT`, [`flags`]
///   **must**  not contain `VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT`
/// -    If [`image`] was created with [`flags`] containing `VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT` and `usage` containing `VK_IMAGE_USAGE_SAMPLED_BIT`, `subresourceRange.layerCount` **must**  be less than or equal to [[`PhysicalDeviceFragmentDensityMap2PropertiesEXT::max_subsampled_array_layers`]](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#limits-maxSubsampledArrayLayers)
/// - If the [`invocationMask` feature](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-invocationMask)
///   is enabled, and if [`image`] was created with `usage` containing
///   `VK_IMAGE_USAGE_INVOCATION_MASK_BIT_HUAWEI`, [`format`] **must**  be `VK_FORMAT_R8_UINT`
/// - If [`flags`] does not contain `VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT` and
///   [`image`] was created with `usage` containing `VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT`,
///   its [`flags`] **must**  not contain any of `VK_IMAGE_CREATE_PROTECTED_BIT`,
///   `VK_IMAGE_CREATE_SPARSE_BINDING_BIT`, `VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT`, or
///   `VK_IMAGE_CREATE_SPARSE_ALIASED_BIT`
/// - If the [`p_next`] chain includes a [`ImageViewUsageCreateInfo`] structure, and [`image`] was
///   not created with a [`ImageStencilUsageCreateInfo`] structure included in the [`p_next`] chain
///   of [`ImageCreateInfo`], its `usage` member  **must**  not include any bits that were not set
///   in the `usage` member of the [`ImageCreateInfo`] structure used to create [`image`]
/// - If the [`p_next`] chain includes a [`ImageViewUsageCreateInfo`] structure, [`image`] was
///   created with a [`ImageStencilUsageCreateInfo`] structure included in the [`p_next`] chain of
///   [`ImageCreateInfo`], and `subresourceRange.aspectMask` includes `VK_IMAGE_ASPECT_STENCIL_BIT`,
///   the `usage` member of the [`ImageViewUsageCreateInfo`] structure  **must**  not include any
///   bits that were not set in the `usage` member of the [`ImageStencilUsageCreateInfo`] structure
///   used to create [`image`]
/// - If the [`p_next`] chain includes a [`ImageViewUsageCreateInfo`] structure, [`image`] was
///   created with a [`ImageStencilUsageCreateInfo`] structure included in the [`p_next`] chain of
///   [`ImageCreateInfo`], and `subresourceRange.aspectMask` includes bits other than
///   `VK_IMAGE_ASPECT_STENCIL_BIT`, the `usage` member of the [`ImageViewUsageCreateInfo`]
///   structure  **must**  not include any bits that were not set in the `usage` member of the
///   [`ImageCreateInfo`] structure used to create [`image`]
/// - If [`view_type`] is `VK_IMAGE_VIEW_TYPE_1D`, `VK_IMAGE_VIEW_TYPE_2D`, or
///   `VK_IMAGE_VIEW_TYPE_3D`; and `subresourceRange.layerCount` is not [`REMAINING_ARRAY_LAYERS`],
///   then `subresourceRange.layerCount` **must**  be 1
/// - If [`view_type`] is `VK_IMAGE_VIEW_TYPE_1D`, `VK_IMAGE_VIEW_TYPE_2D`, or
///   `VK_IMAGE_VIEW_TYPE_3D`; and `subresourceRange.layerCount` is [`REMAINING_ARRAY_LAYERS`], then
///   the remaining number of layers  **must**  be 1
/// - If [`view_type`] is `VK_IMAGE_VIEW_TYPE_CUBE` and `subresourceRange.layerCount` is not
///   [`REMAINING_ARRAY_LAYERS`], `subresourceRange.layerCount` **must**  be `6`
/// - If [`view_type`] is `VK_IMAGE_VIEW_TYPE_CUBE_ARRAY` and `subresourceRange.layerCount` is not
///   [`REMAINING_ARRAY_LAYERS`], `subresourceRange.layerCount` **must**  be a multiple of `6`
/// - If [`view_type`] is `VK_IMAGE_VIEW_TYPE_CUBE` and `subresourceRange.layerCount` is
///   [`REMAINING_ARRAY_LAYERS`], the remaining number of layers  **must**  be `6`
/// - If [`view_type`] is `VK_IMAGE_VIEW_TYPE_CUBE_ARRAY` and `subresourceRange.layerCount` is
///   [`REMAINING_ARRAY_LAYERS`], the remaining number of layers  **must**  be a multiple of `6`
/// -    If the `[`VK_KHR_portability_subset`]` extension is enabled, and [`PhysicalDevicePortabilitySubsetFeaturesKHR::image_view_format_swizzle`] is [`FALSE`], all elements of [`components`] **must**  have the [identity swizzle](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#resources-image-views-identity-mappings)
/// - If the `[`VK_KHR_portability_subset`]` extension is enabled, and
///   [`PhysicalDevicePortabilitySubsetFeaturesKHR::image_view_format_reinterpretation`] is
///   [`FALSE`], the [`Format`] in [`format`] **must**  not contain a different number of
///   components, or a different number of bits in each component, than the format of the [`Image`]
///   in [`image`]
/// -    If [`image`] was created with `usage` containing `VK_IMAGE_USAGE_VIDEO_DECODE_DST_BIT_KHR`, `VK_IMAGE_USAGE_VIDEO_DECODE_SRC_BIT_KHR`, `VK_IMAGE_USAGE_VIDEO_DECODE_DPB_BIT_KHR`, then the [`view_type`] **must**  be `VK_IMAGE_VIEW_TYPE_2D` or `VK_IMAGE_VIEW_TYPE_2D_ARRAY` and all members of [`components`] **must**  have the [identity swizzle](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#resources-image-views-identity-mappings)
/// -    If [`image`] was created with `usage` containing `VK_IMAGE_USAGE_VIDEO_ENCODE_DST_BIT_KHR`, `VK_IMAGE_USAGE_VIDEO_ENCODE_SRC_BIT_KHR`, `VK_IMAGE_USAGE_VIDEO_ENCODE_DPB_BIT_KHR`, then the [`view_type`] **must**  be `VK_IMAGE_VIEW_TYPE_2D` or `VK_IMAGE_VIEW_TYPE_2D_ARRAY` and all members of [`components`] **must**  have the [identity swizzle](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#resources-image-views-identity-mappings)
///
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be `VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO`
/// - Each [`p_next`] member of any structure (including this one) in the [`p_next`] chain  **must**
///   be either `NULL` or a pointer to a valid instance of [`ImageViewAstcDecodeModeEXT`],
///   [`ImageViewMinLodCreateInfoEXT`], [`ImageViewUsageCreateInfo`],
///   [`SamplerYcbcrConversionInfo`], [`VideoDecodeH264ProfileEXT`], [`VideoDecodeH265ProfileEXT`],
///   [`VideoEncodeH264ProfileEXT`], [`VideoEncodeH265ProfileEXT`], [`VideoProfileKHR`], or
///   [`VideoProfilesKHR`]
/// - The [`s_type`] value of each struct in the [`p_next`] chain  **must**  be unique
/// - [`flags`] **must**  be a valid combination of [`ImageViewCreateFlagBits`] values
/// - [`image`] **must**  be a valid [`Image`] handle
/// - [`view_type`] **must**  be a valid [`ImageViewType`] value
/// - [`format`] **must**  be a valid [`Format`] value
/// - [`components`] **must**  be a valid [`ComponentMapping`] structure
/// - [`subresource_range`] **must**  be a valid [`ImageSubresourceRange`] structure
///# Related
/// - [`crate::vulkan1_0`]
/// - [`ComponentMapping`]
/// - [`Format`]
/// - [`Image`]
/// - [`ImageSubresourceRange`]
/// - [`ImageViewCreateFlags`]
/// - [`ImageViewType`]
/// - [`StructureType`]
/// - [`CreateImageView`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[repr(C)]
pub struct ImageViewCreateInfo<'lt> {
    _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] is the type of this structure.
    s_type: StructureType,
    ///[`p_next`] is `NULL` or a pointer to a structure extending this
    ///structure.
    p_next: *const BaseInStructure<'lt>,
    ///[`flags`] is a bitmask of [`ImageViewCreateFlagBits`] describing
    ///additional parameters of the image view.
    flags: ImageViewCreateFlags,
    ///[`image`] is a [`Image`] on which the view will be created.
    image: Image,
    ///[`view_type`] is a [`ImageViewType`] value specifying the type of
    ///the image view.
    view_type: ImageViewType,
    ///[`format`] is a [`Format`] describing the format and type used to
    ///interpret texel blocks in the image.
    format: Format,
    ///[`components`] is a [`ComponentMapping`] structure specifying a
    ///remapping of color components (or of depth or stencil components after
    ///they have been converted into color components).
    components: ComponentMapping,
    ///[`subresource_range`] is a [`ImageSubresourceRange`] structure
    ///selecting the set of mipmap levels and array layers to be accessible to
    ///the view.
    subresource_range: ImageSubresourceRange,
}
impl<'lt> Default for ImageViewCreateInfo<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: Default::default(),
            p_next: std::ptr::null(),
            flags: Default::default(),
            image: Default::default(),
            view_type: Default::default(),
            format: Default::default(),
            components: Default::default(),
            subresource_range: Default::default(),
        }
    }
}
impl<'lt> ImageViewCreateInfo<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *const BaseInStructure<'lt> {
        self.p_next
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *const BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseInStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::flags`]
    pub fn flags(&self) -> ImageViewCreateFlags {
        self.flags
    }
    ///Gets the value of [`Self::image`]
    pub fn image(&self) -> Image {
        self.image
    }
    ///Gets the value of [`Self::view_type`]
    pub fn view_type(&self) -> ImageViewType {
        self.view_type
    }
    ///Gets the value of [`Self::format`]
    pub fn format(&self) -> Format {
        self.format
    }
    ///Gets the value of [`Self::components`]
    pub fn components(&self) -> ComponentMapping {
        self.components
    }
    ///Gets the value of [`Self::subresource_range`]
    pub fn subresource_range(&self) -> ImageSubresourceRange {
        self.subresource_range
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::flags`]
    pub fn flags_mut(&mut self) -> &mut ImageViewCreateFlags {
        &mut self.flags
    }
    ///Gets a mutable reference to the value of [`Self::image`]
    pub fn image_mut(&mut self) -> &mut Image {
        &mut self.image
    }
    ///Gets a mutable reference to the value of [`Self::view_type`]
    pub fn view_type_mut(&mut self) -> &mut ImageViewType {
        &mut self.view_type
    }
    ///Gets a mutable reference to the value of [`Self::format`]
    pub fn format_mut(&mut self) -> &mut Format {
        &mut self.format
    }
    ///Gets a mutable reference to the value of [`Self::components`]
    pub fn components_mut(&mut self) -> &mut ComponentMapping {
        &mut self.components
    }
    ///Gets a mutable reference to the value of [`Self::subresource_range`]
    pub fn subresource_range_mut(&mut self) -> &mut ImageSubresourceRange {
        &mut self.subresource_range
    }
    ///Sets the raw value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the raw value of [`Self::flags`]
    pub fn set_flags(&mut self, value: crate::vulkan1_0::ImageViewCreateFlags) -> &mut Self {
        self.flags = value;
        self
    }
    ///Sets the raw value of [`Self::image`]
    pub fn set_image(&mut self, value: crate::vulkan1_0::Image) -> &mut Self {
        self.image = value;
        self
    }
    ///Sets the raw value of [`Self::view_type`]
    pub fn set_view_type(&mut self, value: crate::vulkan1_0::ImageViewType) -> &mut Self {
        self.view_type = value;
        self
    }
    ///Sets the raw value of [`Self::format`]
    pub fn set_format(&mut self, value: crate::vulkan1_0::Format) -> &mut Self {
        self.format = value;
        self
    }
    ///Sets the raw value of [`Self::components`]
    pub fn set_components(&mut self, value: crate::vulkan1_0::ComponentMapping) -> &mut Self {
        self.components = value;
        self
    }
    ///Sets the raw value of [`Self::subresource_range`]
    pub fn set_subresource_range(&mut self, value: crate::vulkan1_0::ImageSubresourceRange) -> &mut Self {
        self.subresource_range = value;
        self
    }
}
///[VkBufferCopy](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferCopy.html) - Structure specifying a buffer copy operation
///# C Specifications
///The [`BufferCopy`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkBufferCopy {
///    VkDeviceSize    srcOffset;
///    VkDeviceSize    dstOffset;
///    VkDeviceSize    size;
///} VkBufferCopy;
///```
///# Members
/// - [`src_offset`] is the starting offset in bytes from the start of `srcBuffer`.
/// - [`dst_offset`] is the starting offset in bytes from the start of `dstBuffer`.
/// - [`size`] is the number of bytes to copy.
///# Description
///## Valid Usage
/// - The [`size`] **must**  be greater than `0`
///# Related
/// - [`crate::vulkan1_0`]
/// - [`DeviceSize`]
/// - [`CmdCopyBuffer`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct BufferCopy {
    ///[`src_offset`] is the starting offset in bytes from the start of
    ///`srcBuffer`.
    src_offset: DeviceSize,
    ///[`dst_offset`] is the starting offset in bytes from the start of
    ///`dstBuffer`.
    dst_offset: DeviceSize,
    ///[`size`] is the number of bytes to copy.
    size: DeviceSize,
}
impl Default for BufferCopy {
    fn default() -> Self {
        Self {
            src_offset: Default::default(),
            dst_offset: Default::default(),
            size: Default::default(),
        }
    }
}
impl BufferCopy {
    ///Gets the value of [`Self::src_offset`]
    pub fn src_offset(&self) -> DeviceSize {
        self.src_offset
    }
    ///Gets the value of [`Self::dst_offset`]
    pub fn dst_offset(&self) -> DeviceSize {
        self.dst_offset
    }
    ///Gets the value of [`Self::size`]
    pub fn size(&self) -> DeviceSize {
        self.size
    }
    ///Gets a mutable reference to the value of [`Self::src_offset`]
    pub fn src_offset_mut(&mut self) -> &mut DeviceSize {
        &mut self.src_offset
    }
    ///Gets a mutable reference to the value of [`Self::dst_offset`]
    pub fn dst_offset_mut(&mut self) -> &mut DeviceSize {
        &mut self.dst_offset
    }
    ///Gets a mutable reference to the value of [`Self::size`]
    pub fn size_mut(&mut self) -> &mut DeviceSize {
        &mut self.size
    }
    ///Sets the raw value of [`Self::src_offset`]
    pub fn set_src_offset(&mut self, value: crate::vulkan1_0::DeviceSize) -> &mut Self {
        self.src_offset = value;
        self
    }
    ///Sets the raw value of [`Self::dst_offset`]
    pub fn set_dst_offset(&mut self, value: crate::vulkan1_0::DeviceSize) -> &mut Self {
        self.dst_offset = value;
        self
    }
    ///Sets the raw value of [`Self::size`]
    pub fn set_size(&mut self, value: crate::vulkan1_0::DeviceSize) -> &mut Self {
        self.size = value;
        self
    }
}
///[VkSparseMemoryBind](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSparseMemoryBind.html) - Structure specifying a sparse memory bind operation
///# C Specifications
///The [`SparseMemoryBind`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkSparseMemoryBind {
///    VkDeviceSize               resourceOffset;
///    VkDeviceSize               size;
///    VkDeviceMemory             memory;
///    VkDeviceSize               memoryOffset;
///    VkSparseMemoryBindFlags    flags;
///} VkSparseMemoryBind;
///```
///# Members
/// - [`resource_offset`] is the offset into the resource.
/// - [`size`] is the size of the memory region to be bound.
/// - [`memory`] is the [`DeviceMemory`] object that the range of the resource is bound to. If
///   [`memory`] is [`crate::utils::Handle::null`], the range is unbound.
/// - [`memory_offset`] is the offset into the [`DeviceMemory`] object to bind the resource range
///   to. If [`memory`] is [`crate::utils::Handle::null`], this value is ignored.
/// - [`flags`] is a bitmask of [`SparseMemoryBindFlagBits`] specifying usage of the binding
///   operation.
///# Description
///The *binding range*[[`resource_offset`], [`resource_offset`] +
///[`size`]) has different constraints based on [`flags`].
///If [`flags`] contains `VK_SPARSE_MEMORY_BIND_METADATA_BIT`, the
///binding range  **must**  be within the mip tail region of the metadata aspect.
///This metadata region is defined by:
/// * metadataRegion = [base, base +  `imageMipTailSize`)
/// * base = `imageMipTailOffset` +  `imageMipTailStride` × n
///and `imageMipTailOffset`, `imageMipTailSize`, and
///`imageMipTailStride` values are from the
///[`SparseImageMemoryRequirements`] corresponding to the metadata aspect
///of the image, and n is a valid array layer index for the image,`imageMipTailStride` is
/// considered to be zero for aspects where
///[`SparseImageMemoryRequirements`]::`formatProperties.flags` contains
///`VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT`.If [`flags`] does not contain
/// `VK_SPARSE_MEMORY_BIND_METADATA_BIT`,
///the binding range  **must**  be within the range
///[0,[`MemoryRequirements`]::[`size`]).
///## Valid Usage
/// - If [`memory`] is not [`crate::utils::Handle::null`], [`memory`] and [`memory_offset`] **must**
///   match the memory requirements of the resource, as described in section [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#resources-association](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#resources-association)
/// - If [`memory`] is not [`crate::utils::Handle::null`], [`memory`] **must**  not have been
///   created with a memory type that reports `VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT` bit set
/// - [`size`] **must**  be greater than `0`
/// - [`resource_offset`] **must**  be less than the size of the resource
/// - [`size`] **must**  be less than or equal to the size of the resource minus [`resource_offset`]
/// - [`memory_offset`] **must**  be less than the size of [`memory`]
/// - [`size`] **must**  be less than or equal to the size of [`memory`] minus [`memory_offset`]
/// - If [`memory`] was created with [`ExportMemoryAllocateInfo::handle_types`] not equal to `0`, at
///   least one handle type it contained  **must**  also have been set in
///   [`ExternalMemoryBufferCreateInfo::handle_types`] or
///   [`ExternalMemoryImageCreateInfo::handle_types`] when the resource was created
/// - If [`memory`] was created by a memory import operation, the external handle type of the
///   imported memory  **must**  also have been set in
///   [`ExternalMemoryBufferCreateInfo::handle_types`] or
///   [`ExternalMemoryImageCreateInfo::handle_types`] when the resource was created
///
///## Valid Usage (Implicit)
/// - If [`memory`] is not [`crate::utils::Handle::null`], [`memory`] **must**  be a valid
///   [`DeviceMemory`] handle
/// - [`flags`] **must**  be a valid combination of [`SparseMemoryBindFlagBits`] values
///# Related
/// - [`crate::vulkan1_0`]
/// - [`DeviceMemory`]
/// - [`DeviceSize`]
/// - [`SparseBufferMemoryBindInfo`]
/// - [`SparseImageOpaqueMemoryBindInfo`]
/// - [`SparseMemoryBindFlags`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[repr(C)]
pub struct SparseMemoryBind {
    ///[`resource_offset`] is the offset into the resource.
    resource_offset: DeviceSize,
    ///[`size`] is the size of the memory region to be bound.
    size: DeviceSize,
    ///[`memory`] is the [`DeviceMemory`] object that the range of the
    ///resource is bound to.
    ///If [`memory`] is [`crate::utils::Handle::null`], the range is unbound.
    memory: DeviceMemory,
    ///[`memory_offset`] is the offset into the [`DeviceMemory`] object to
    ///bind the resource range to.
    ///If [`memory`] is [`crate::utils::Handle::null`], this value is ignored.
    memory_offset: DeviceSize,
    ///[`flags`] is a bitmask of [`SparseMemoryBindFlagBits`] specifying
    ///usage of the binding operation.
    flags: SparseMemoryBindFlags,
}
impl Default for SparseMemoryBind {
    fn default() -> Self {
        Self {
            resource_offset: Default::default(),
            size: Default::default(),
            memory: Default::default(),
            memory_offset: Default::default(),
            flags: Default::default(),
        }
    }
}
impl SparseMemoryBind {
    ///Gets the value of [`Self::resource_offset`]
    pub fn resource_offset(&self) -> DeviceSize {
        self.resource_offset
    }
    ///Gets the value of [`Self::size`]
    pub fn size(&self) -> DeviceSize {
        self.size
    }
    ///Gets the value of [`Self::memory`]
    pub fn memory(&self) -> DeviceMemory {
        self.memory
    }
    ///Gets the value of [`Self::memory_offset`]
    pub fn memory_offset(&self) -> DeviceSize {
        self.memory_offset
    }
    ///Gets the value of [`Self::flags`]
    pub fn flags(&self) -> SparseMemoryBindFlags {
        self.flags
    }
    ///Gets a mutable reference to the value of [`Self::resource_offset`]
    pub fn resource_offset_mut(&mut self) -> &mut DeviceSize {
        &mut self.resource_offset
    }
    ///Gets a mutable reference to the value of [`Self::size`]
    pub fn size_mut(&mut self) -> &mut DeviceSize {
        &mut self.size
    }
    ///Gets a mutable reference to the value of [`Self::memory`]
    pub fn memory_mut(&mut self) -> &mut DeviceMemory {
        &mut self.memory
    }
    ///Gets a mutable reference to the value of [`Self::memory_offset`]
    pub fn memory_offset_mut(&mut self) -> &mut DeviceSize {
        &mut self.memory_offset
    }
    ///Gets a mutable reference to the value of [`Self::flags`]
    pub fn flags_mut(&mut self) -> &mut SparseMemoryBindFlags {
        &mut self.flags
    }
    ///Sets the raw value of [`Self::resource_offset`]
    pub fn set_resource_offset(&mut self, value: crate::vulkan1_0::DeviceSize) -> &mut Self {
        self.resource_offset = value;
        self
    }
    ///Sets the raw value of [`Self::size`]
    pub fn set_size(&mut self, value: crate::vulkan1_0::DeviceSize) -> &mut Self {
        self.size = value;
        self
    }
    ///Sets the raw value of [`Self::memory`]
    pub fn set_memory(&mut self, value: crate::vulkan1_0::DeviceMemory) -> &mut Self {
        self.memory = value;
        self
    }
    ///Sets the raw value of [`Self::memory_offset`]
    pub fn set_memory_offset(&mut self, value: crate::vulkan1_0::DeviceSize) -> &mut Self {
        self.memory_offset = value;
        self
    }
    ///Sets the raw value of [`Self::flags`]
    pub fn set_flags(&mut self, value: crate::vulkan1_0::SparseMemoryBindFlags) -> &mut Self {
        self.flags = value;
        self
    }
}
///[VkSparseImageMemoryBind](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSparseImageMemoryBind.html) - Structure specifying sparse image memory bind
///# C Specifications
///The [`SparseImageMemoryBind`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkSparseImageMemoryBind {
///    VkImageSubresource         subresource;
///    VkOffset3D                 offset;
///    VkExtent3D                 extent;
///    VkDeviceMemory             memory;
///    VkDeviceSize               memoryOffset;
///    VkSparseMemoryBindFlags    flags;
///} VkSparseImageMemoryBind;
///```
///# Members
/// - [`subresource`] is the image *aspect* and region of interest in the image.
/// - [`offset`] are the coordinates of the first texel within the image subresource to bind.
/// - [`extent`] is the size in texels of the region within the image subresource to bind. The
///   extent  **must**  be a multiple of the sparse image block dimensions, except when binding
///   sparse image blocks along the edge of an image subresource it  **can**  instead be such that
///   any coordinate of [`offset`] +  [`extent`] equals the corresponding dimensions of the image
///   subresource.
/// - [`memory`] is the [`DeviceMemory`] object that the sparse image blocks of the image are bound
///   to. If [`memory`] is [`crate::utils::Handle::null`], the sparse image blocks are unbound.
/// - [`memory_offset`] is an offset into [`DeviceMemory`] object. If [`memory`] is
///   [`crate::utils::Handle::null`], this value is ignored.
/// - [`flags`] are sparse memory binding flags.
///# Description
///## Valid Usage
/// - If the [sparse aliased residency](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-sparseResidencyAliased)
///   feature is not enabled, and if any other resources are bound to ranges of [`memory`], the
///   range of [`memory`] being bound  **must**  not overlap with those bound ranges
/// -  [`memory`] and [`memory_offset`] **must**  match the memory requirements of the calling command’s `image`, as described in section [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#resources-association](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#resources-association)
/// - [`subresource`] **must**  be a valid image subresource for `image` (see [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#resources-image-views](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#resources-image-views))
/// - `offset.x` **must**  be a multiple of the sparse image block width
///   ([`SparseImageFormatProperties`]::`imageGranularity.width`) of the image
/// - `extent.width` **must**  either be a multiple of the sparse image block width of the image, or
///   else (`extent.width` +  `offset.x`) **must**  equal the width of the image subresource
/// - `offset.y` **must**  be a multiple of the sparse image block height
///   ([`SparseImageFormatProperties`]::`imageGranularity.height`) of the image
/// - `extent.height` **must**  either be a multiple of the sparse image block height of the image,
///   or else (`extent.height` +  `offset.y`) **must**  equal the height of the image subresource
/// - `offset.z` **must**  be a multiple of the sparse image block depth
///   ([`SparseImageFormatProperties`]::`imageGranularity.depth`) of the image
/// - `extent.depth` **must**  either be a multiple of the sparse image block depth of the image, or
///   else (`extent.depth` +  `offset.z`) **must**  equal the depth of the image subresource
/// - If [`memory`] was created with [`ExportMemoryAllocateInfo::handle_types`] not equal to `0`, at
///   least one handle type it contained  **must**  also have been set in
///   [`ExternalMemoryImageCreateInfo::handle_types`] when the image was created
/// - If [`memory`] was created by a memory import operation, the external handle type of the
///   imported memory  **must**  also have been set in
///   [`ExternalMemoryImageCreateInfo::handle_types`] when `image` was created
///
///## Valid Usage (Implicit)
/// - [`subresource`] **must**  be a valid [`ImageSubresource`] structure
/// - If [`memory`] is not [`crate::utils::Handle::null`], [`memory`] **must**  be a valid
///   [`DeviceMemory`] handle
/// - [`flags`] **must**  be a valid combination of [`SparseMemoryBindFlagBits`] values
///# Related
/// - [`crate::vulkan1_0`]
/// - [`DeviceMemory`]
/// - [`DeviceSize`]
/// - [`Extent3D`]
/// - [`ImageSubresource`]
/// - [`Offset3D`]
/// - [`SparseImageMemoryBindInfo`]
/// - [`SparseMemoryBindFlags`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[repr(C)]
pub struct SparseImageMemoryBind {
    ///[`subresource`] is the image *aspect* and region of interest in the
    ///image.
    subresource: ImageSubresource,
    ///[`offset`] are the coordinates of the first texel within the image
    ///subresource to bind.
    offset: Offset3D,
    ///[`extent`] is the size in texels of the region within the image
    ///subresource to bind.
    ///The extent  **must**  be a multiple of the sparse image block dimensions,
    ///except when binding sparse image blocks along the edge of an image
    ///subresource it  **can**  instead be such that any coordinate of
    ///[`offset`] +  [`extent`] equals the corresponding
    ///dimensions of the image subresource.
    extent: Extent3D,
    ///[`memory`] is the [`DeviceMemory`] object that the sparse image
    ///blocks of the image are bound to.
    ///If [`memory`] is [`crate::utils::Handle::null`], the sparse image blocks are
    ///unbound.
    memory: DeviceMemory,
    ///[`memory_offset`] is an offset into [`DeviceMemory`] object.
    ///If [`memory`] is [`crate::utils::Handle::null`], this value is ignored.
    memory_offset: DeviceSize,
    ///[`flags`] are sparse memory binding flags.
    flags: SparseMemoryBindFlags,
}
impl Default for SparseImageMemoryBind {
    fn default() -> Self {
        Self {
            subresource: Default::default(),
            offset: Default::default(),
            extent: Default::default(),
            memory: Default::default(),
            memory_offset: Default::default(),
            flags: Default::default(),
        }
    }
}
impl SparseImageMemoryBind {
    ///Gets the value of [`Self::subresource`]
    pub fn subresource(&self) -> ImageSubresource {
        self.subresource
    }
    ///Gets the value of [`Self::offset`]
    pub fn offset(&self) -> Offset3D {
        self.offset
    }
    ///Gets the value of [`Self::extent`]
    pub fn extent(&self) -> Extent3D {
        self.extent
    }
    ///Gets the value of [`Self::memory`]
    pub fn memory(&self) -> DeviceMemory {
        self.memory
    }
    ///Gets the value of [`Self::memory_offset`]
    pub fn memory_offset(&self) -> DeviceSize {
        self.memory_offset
    }
    ///Gets the value of [`Self::flags`]
    pub fn flags(&self) -> SparseMemoryBindFlags {
        self.flags
    }
    ///Gets a mutable reference to the value of [`Self::subresource`]
    pub fn subresource_mut(&mut self) -> &mut ImageSubresource {
        &mut self.subresource
    }
    ///Gets a mutable reference to the value of [`Self::offset`]
    pub fn offset_mut(&mut self) -> &mut Offset3D {
        &mut self.offset
    }
    ///Gets a mutable reference to the value of [`Self::extent`]
    pub fn extent_mut(&mut self) -> &mut Extent3D {
        &mut self.extent
    }
    ///Gets a mutable reference to the value of [`Self::memory`]
    pub fn memory_mut(&mut self) -> &mut DeviceMemory {
        &mut self.memory
    }
    ///Gets a mutable reference to the value of [`Self::memory_offset`]
    pub fn memory_offset_mut(&mut self) -> &mut DeviceSize {
        &mut self.memory_offset
    }
    ///Gets a mutable reference to the value of [`Self::flags`]
    pub fn flags_mut(&mut self) -> &mut SparseMemoryBindFlags {
        &mut self.flags
    }
    ///Sets the raw value of [`Self::subresource`]
    pub fn set_subresource(&mut self, value: crate::vulkan1_0::ImageSubresource) -> &mut Self {
        self.subresource = value;
        self
    }
    ///Sets the raw value of [`Self::offset`]
    pub fn set_offset(&mut self, value: crate::vulkan1_0::Offset3D) -> &mut Self {
        self.offset = value;
        self
    }
    ///Sets the raw value of [`Self::extent`]
    pub fn set_extent(&mut self, value: crate::vulkan1_0::Extent3D) -> &mut Self {
        self.extent = value;
        self
    }
    ///Sets the raw value of [`Self::memory`]
    pub fn set_memory(&mut self, value: crate::vulkan1_0::DeviceMemory) -> &mut Self {
        self.memory = value;
        self
    }
    ///Sets the raw value of [`Self::memory_offset`]
    pub fn set_memory_offset(&mut self, value: crate::vulkan1_0::DeviceSize) -> &mut Self {
        self.memory_offset = value;
        self
    }
    ///Sets the raw value of [`Self::flags`]
    pub fn set_flags(&mut self, value: crate::vulkan1_0::SparseMemoryBindFlags) -> &mut Self {
        self.flags = value;
        self
    }
}
///[VkSparseBufferMemoryBindInfo](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSparseBufferMemoryBindInfo.html) - Structure specifying a sparse buffer memory bind operation
///# C Specifications
///Memory is bound to [`Buffer`] objects created with the
///`VK_BUFFER_CREATE_SPARSE_BINDING_BIT` flag using the following
///structure:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkSparseBufferMemoryBindInfo {
///    VkBuffer                     buffer;
///    uint32_t                     bindCount;
///    const VkSparseMemoryBind*    pBinds;
///} VkSparseBufferMemoryBindInfo;
///```
///# Members
/// - [`buffer`] is the [`Buffer`] object to be bound.
/// - [`bind_count`] is the number of [`SparseMemoryBind`] structures in the [`binds`] array.
/// - [`binds`] is a pointer to an array of [`SparseMemoryBind`] structures.
///# Description
///## Valid Usage (Implicit)
/// - [`buffer`] **must**  be a valid [`Buffer`] handle
/// - [`binds`] **must**  be a valid pointer to an array of [`bind_count`] valid
///   [`SparseMemoryBind`] structures
/// - [`bind_count`] **must**  be greater than `0`
///# Related
/// - [`crate::vulkan1_0`]
/// - [`BindSparseInfo`]
/// - [`Buffer`]
/// - [`SparseMemoryBind`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[repr(C)]
pub struct SparseBufferMemoryBindInfo<'lt> {
    _lifetime: PhantomData<&'lt ()>,
    ///[`buffer`] is the [`Buffer`] object to be bound.
    buffer: Buffer,
    ///[`bind_count`] is the number of [`SparseMemoryBind`] structures in
    ///the [`binds`] array.
    bind_count: u32,
    ///[`binds`] is a pointer to an array of [`SparseMemoryBind`]
    ///structures.
    binds: *const SparseMemoryBind,
}
impl<'lt> Default for SparseBufferMemoryBindInfo<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            buffer: Default::default(),
            bind_count: 0,
            binds: std::ptr::null(),
        }
    }
}
impl<'lt> SparseBufferMemoryBindInfo<'lt> {
    ///Gets the raw value of [`Self::binds`]
    pub fn binds_raw(&self) -> *const SparseMemoryBind {
        self.binds
    }
    ///Sets the raw value of [`Self::binds`]
    pub fn set_binds_raw(&mut self, value: *const SparseMemoryBind) -> &mut Self {
        self.binds = value;
        self
    }
    ///Gets the value of [`Self::buffer`]
    pub fn buffer(&self) -> Buffer {
        self.buffer
    }
    ///Gets the value of [`Self::bind_count`]
    pub fn bind_count(&self) -> u32 {
        self.bind_count
    }
    ///Gets the value of [`Self::binds`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn binds(&self) -> &[SparseMemoryBind] {
        std::slice::from_raw_parts(self.binds, self.bind_count as usize)
    }
    ///Gets a mutable reference to the value of [`Self::buffer`]
    pub fn buffer_mut(&mut self) -> &mut Buffer {
        &mut self.buffer
    }
    ///Gets a mutable reference to the value of [`Self::bind_count`]
    pub fn bind_count_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Sets the raw value of [`Self::buffer`]
    pub fn set_buffer(&mut self, value: crate::vulkan1_0::Buffer) -> &mut Self {
        self.buffer = value;
        self
    }
    ///Sets the raw value of [`Self::bind_count`]
    pub fn set_bind_count(&mut self, value: u32) -> &mut Self {
        self.bind_count = value;
        self
    }
    ///Sets the raw value of [`Self::binds`]
    pub fn set_binds(&mut self, value: &'lt [crate::vulkan1_0::SparseMemoryBind]) -> &mut Self {
        let len_ = value.len() as u32;
        let len_ = len_;
        self.binds = value.as_ptr();
        self.bind_count = len_;
        self
    }
}
///[VkSparseImageOpaqueMemoryBindInfo](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSparseImageOpaqueMemoryBindInfo.html) - Structure specifying sparse image opaque memory bind information
///# C Specifications
///Memory is bound to opaque regions of [`Image`] objects created with the
///`VK_IMAGE_CREATE_SPARSE_BINDING_BIT` flag using the following structure:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkSparseImageOpaqueMemoryBindInfo {
///    VkImage                      image;
///    uint32_t                     bindCount;
///    const VkSparseMemoryBind*    pBinds;
///} VkSparseImageOpaqueMemoryBindInfo;
///```
///# Members
/// - [`image`] is the [`Image`] object to be bound.
/// - [`bind_count`] is the number of [`SparseMemoryBind`] structures in the [`binds`] array.
/// - [`binds`] is a pointer to an array of [`SparseMemoryBind`] structures.
///# Description
///## Valid Usage
/// - If the `flags` member of any element of [`binds`] contains
///   `VK_SPARSE_MEMORY_BIND_METADATA_BIT`, the binding range defined  **must**  be within the mip
///   tail region of the metadata aspect of [`image`]
///
///## Valid Usage (Implicit)
/// - [`image`] **must**  be a valid [`Image`] handle
/// - [`binds`] **must**  be a valid pointer to an array of [`bind_count`] valid
///   [`SparseMemoryBind`] structures
/// - [`bind_count`] **must**  be greater than `0`
///# Related
/// - [`crate::vulkan1_0`]
/// - [`BindSparseInfo`]
/// - [`Image`]
/// - [`SparseMemoryBind`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[repr(C)]
pub struct SparseImageOpaqueMemoryBindInfo<'lt> {
    _lifetime: PhantomData<&'lt ()>,
    ///[`image`] is the [`Image`] object to be bound.
    image: Image,
    ///[`bind_count`] is the number of [`SparseMemoryBind`] structures in
    ///the [`binds`] array.
    bind_count: u32,
    ///[`binds`] is a pointer to an array of [`SparseMemoryBind`]
    ///structures.
    binds: *const SparseMemoryBind,
}
impl<'lt> Default for SparseImageOpaqueMemoryBindInfo<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            image: Default::default(),
            bind_count: 0,
            binds: std::ptr::null(),
        }
    }
}
impl<'lt> SparseImageOpaqueMemoryBindInfo<'lt> {
    ///Gets the raw value of [`Self::binds`]
    pub fn binds_raw(&self) -> *const SparseMemoryBind {
        self.binds
    }
    ///Sets the raw value of [`Self::binds`]
    pub fn set_binds_raw(&mut self, value: *const SparseMemoryBind) -> &mut Self {
        self.binds = value;
        self
    }
    ///Gets the value of [`Self::image`]
    pub fn image(&self) -> Image {
        self.image
    }
    ///Gets the value of [`Self::bind_count`]
    pub fn bind_count(&self) -> u32 {
        self.bind_count
    }
    ///Gets the value of [`Self::binds`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn binds(&self) -> &[SparseMemoryBind] {
        std::slice::from_raw_parts(self.binds, self.bind_count as usize)
    }
    ///Gets a mutable reference to the value of [`Self::image`]
    pub fn image_mut(&mut self) -> &mut Image {
        &mut self.image
    }
    ///Gets a mutable reference to the value of [`Self::bind_count`]
    pub fn bind_count_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Sets the raw value of [`Self::image`]
    pub fn set_image(&mut self, value: crate::vulkan1_0::Image) -> &mut Self {
        self.image = value;
        self
    }
    ///Sets the raw value of [`Self::bind_count`]
    pub fn set_bind_count(&mut self, value: u32) -> &mut Self {
        self.bind_count = value;
        self
    }
    ///Sets the raw value of [`Self::binds`]
    pub fn set_binds(&mut self, value: &'lt [crate::vulkan1_0::SparseMemoryBind]) -> &mut Self {
        let len_ = value.len() as u32;
        let len_ = len_;
        self.binds = value.as_ptr();
        self.bind_count = len_;
        self
    }
}
///[VkSparseImageMemoryBindInfo](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSparseImageMemoryBindInfo.html) - Structure specifying sparse image memory bind information
///# C Specifications
///Memory  **can**  be bound to sparse image blocks of [`Image`] objects created
///with the `VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT` flag using the following
///structure:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkSparseImageMemoryBindInfo {
///    VkImage                           image;
///    uint32_t                          bindCount;
///    const VkSparseImageMemoryBind*    pBinds;
///} VkSparseImageMemoryBindInfo;
///```
///# Members
/// - [`image`] is the [`Image`] object to be bound
/// - [`bind_count`] is the number of [`SparseImageMemoryBind`] structures in [`binds`] array
/// - [`binds`] is a pointer to an array of [`SparseImageMemoryBind`] structures
///# Description
///## Valid Usage
/// - The `subresource.mipLevel` member of each element of [`binds`] **must**  be less than the
///   `mipLevels` specified in [`ImageCreateInfo`] when [`image`] was created
/// - The `subresource.arrayLayer` member of each element of [`binds`] **must**  be less than the
///   `arrayLayers` specified in [`ImageCreateInfo`] when [`image`] was created
/// - [`image`] **must**  have been created with `VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT` set
///
///## Valid Usage (Implicit)
/// - [`image`] **must**  be a valid [`Image`] handle
/// - [`binds`] **must**  be a valid pointer to an array of [`bind_count`] valid
///   [`SparseImageMemoryBind`] structures
/// - [`bind_count`] **must**  be greater than `0`
///# Related
/// - [`crate::vulkan1_0`]
/// - [`BindSparseInfo`]
/// - [`Image`]
/// - [`SparseImageMemoryBind`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[repr(C)]
pub struct SparseImageMemoryBindInfo<'lt> {
    _lifetime: PhantomData<&'lt ()>,
    ///[`image`] is the [`Image`] object to be bound
    image: Image,
    ///[`bind_count`] is the number of [`SparseImageMemoryBind`]
    ///structures in [`binds`] array
    bind_count: u32,
    ///[`binds`] is a pointer to an array of [`SparseImageMemoryBind`]
    ///structures
    binds: *const SparseImageMemoryBind,
}
impl<'lt> Default for SparseImageMemoryBindInfo<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            image: Default::default(),
            bind_count: 0,
            binds: std::ptr::null(),
        }
    }
}
impl<'lt> SparseImageMemoryBindInfo<'lt> {
    ///Gets the raw value of [`Self::binds`]
    pub fn binds_raw(&self) -> *const SparseImageMemoryBind {
        self.binds
    }
    ///Sets the raw value of [`Self::binds`]
    pub fn set_binds_raw(&mut self, value: *const SparseImageMemoryBind) -> &mut Self {
        self.binds = value;
        self
    }
    ///Gets the value of [`Self::image`]
    pub fn image(&self) -> Image {
        self.image
    }
    ///Gets the value of [`Self::bind_count`]
    pub fn bind_count(&self) -> u32 {
        self.bind_count
    }
    ///Gets the value of [`Self::binds`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn binds(&self) -> &[SparseImageMemoryBind] {
        std::slice::from_raw_parts(self.binds, self.bind_count as usize)
    }
    ///Gets a mutable reference to the value of [`Self::image`]
    pub fn image_mut(&mut self) -> &mut Image {
        &mut self.image
    }
    ///Gets a mutable reference to the value of [`Self::bind_count`]
    pub fn bind_count_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Sets the raw value of [`Self::image`]
    pub fn set_image(&mut self, value: crate::vulkan1_0::Image) -> &mut Self {
        self.image = value;
        self
    }
    ///Sets the raw value of [`Self::bind_count`]
    pub fn set_bind_count(&mut self, value: u32) -> &mut Self {
        self.bind_count = value;
        self
    }
    ///Sets the raw value of [`Self::binds`]
    pub fn set_binds(&mut self, value: &'lt [crate::vulkan1_0::SparseImageMemoryBind]) -> &mut Self {
        let len_ = value.len() as u32;
        let len_ = len_;
        self.binds = value.as_ptr();
        self.bind_count = len_;
        self
    }
}
///[VkBindSparseInfo](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBindSparseInfo.html) - Structure specifying a sparse binding operation
///# C Specifications
///The [`BindSparseInfo`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkBindSparseInfo {
///    VkStructureType                             sType;
///    const void*                                 pNext;
///    uint32_t                                    waitSemaphoreCount;
///    const VkSemaphore*                          pWaitSemaphores;
///    uint32_t                                    bufferBindCount;
///    const VkSparseBufferMemoryBindInfo*         pBufferBinds;
///    uint32_t                                    imageOpaqueBindCount;
///    const VkSparseImageOpaqueMemoryBindInfo*    pImageOpaqueBinds;
///    uint32_t                                    imageBindCount;
///    const VkSparseImageMemoryBindInfo*          pImageBinds;
///    uint32_t                                    signalSemaphoreCount;
///    const VkSemaphore*                          pSignalSemaphores;
///} VkBindSparseInfo;
///```
///# Members
/// - [`s_type`] is the type of this structure.
/// - [`p_next`] is `NULL` or a pointer to a structure extending this structure.
/// - [`wait_semaphore_count`] is the number of semaphores upon which to wait before executing the
///   sparse binding operations for the batch.
/// - [`wait_semaphores`] is a pointer to an array of semaphores upon which to wait on before the sparse binding operations for this batch begin execution. If semaphores to wait on are provided, they define a [semaphore wait operation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-semaphores-waiting).
/// - [`buffer_bind_count`] is the number of sparse buffer bindings to perform in the batch.
/// - [`buffer_binds`] is a pointer to an array of [`SparseBufferMemoryBindInfo`] structures.
/// - [`image_opaque_bind_count`] is the number of opaque sparse image bindings to perform.
/// - [`image_opaque_binds`] is a pointer to an array of [`SparseImageOpaqueMemoryBindInfo`]
///   structures, indicating opaque sparse image bindings to perform.
/// - [`image_bind_count`] is the number of sparse image bindings to perform.
/// - [`image_binds`] is a pointer to an array of [`SparseImageMemoryBindInfo`] structures,
///   indicating sparse image bindings to perform.
/// - [`signal_semaphore_count`] is the number of semaphores to be signaled once the sparse binding
///   operations specified by the structure have completed execution.
/// - [`signal_semaphores`] is a pointer to an array of semaphores which will be signaled when the sparse binding operations for this batch have completed execution. If semaphores to be signaled are provided, they define a [semaphore signal operation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-semaphores-signaling).
///# Description
///## Valid Usage
/// - If any element of [`wait_semaphores`] or [`signal_semaphores`] was created with a
///   [`SemaphoreType`] of `VK_SEMAPHORE_TYPE_TIMELINE` then the [`p_next`] chain  **must**  include
///   a [`TimelineSemaphoreSubmitInfo`] structure
/// - If the [`p_next`] chain of this structure includes a [`TimelineSemaphoreSubmitInfo`] structure
///   and any element of [`wait_semaphores`] was created with a [`SemaphoreType`] of
///   `VK_SEMAPHORE_TYPE_TIMELINE` then its `waitSemaphoreValueCount` member  **must**  equal
///   [`wait_semaphore_count`]
/// - If the [`p_next`] chain of this structure includes a [`TimelineSemaphoreSubmitInfo`] structure
///   and any element of [`signal_semaphores`] was created with a [`SemaphoreType`] of
///   `VK_SEMAPHORE_TYPE_TIMELINE` then its `signalSemaphoreValueCount` member  **must**  equal
///   [`signal_semaphore_count`]
/// -    For each element of [`signal_semaphores`] created with a [`SemaphoreType`] of `VK_SEMAPHORE_TYPE_TIMELINE` the corresponding element of [`TimelineSemaphoreSubmitInfo::signal_semaphore_values`] **must**  have a value greater than the current value of the semaphore when the [semaphore signal operation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-semaphores-signaling) is executed
/// -    For each element of [`wait_semaphores`] created with a [`SemaphoreType`] of `VK_SEMAPHORE_TYPE_TIMELINE` the corresponding element of [`TimelineSemaphoreSubmitInfo::wait_semaphore_values`] **must**  have a value which does not differ from the current value of the semaphore or from the value of any outstanding semaphore wait or signal operation on that semaphore by more than [`maxTimelineSemaphoreValueDifference`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#limits-maxTimelineSemaphoreValueDifference)
/// -    For each element of [`signal_semaphores`] created with a [`SemaphoreType`] of `VK_SEMAPHORE_TYPE_TIMELINE` the corresponding element of [`TimelineSemaphoreSubmitInfo::signal_semaphore_values`] **must**  have a value which does not differ from the current value of the semaphore or from the value of any outstanding semaphore wait or signal operation on that semaphore by more than [`maxTimelineSemaphoreValueDifference`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#limits-maxTimelineSemaphoreValueDifference)
///
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be `VK_STRUCTURE_TYPE_BIND_SPARSE_INFO`
/// - Each [`p_next`] member of any structure (including this one) in the [`p_next`] chain  **must**
///   be either `NULL` or a pointer to a valid instance of [`DeviceGroupBindSparseInfo`] or
///   [`TimelineSemaphoreSubmitInfo`]
/// - The [`s_type`] value of each struct in the [`p_next`] chain  **must**  be unique
/// - If [`wait_semaphore_count`] is not `0`, [`wait_semaphores`] **must**  be a valid pointer to an
///   array of [`wait_semaphore_count`] valid [`Semaphore`] handles
/// - If [`buffer_bind_count`] is not `0`, [`buffer_binds`] **must**  be a valid pointer to an array
///   of [`buffer_bind_count`] valid [`SparseBufferMemoryBindInfo`] structures
/// - If [`image_opaque_bind_count`] is not `0`, [`image_opaque_binds`] **must**  be a valid pointer
///   to an array of [`image_opaque_bind_count`] valid [`SparseImageOpaqueMemoryBindInfo`]
///   structures
/// - If [`image_bind_count`] is not `0`, [`image_binds`] **must**  be a valid pointer to an array
///   of [`image_bind_count`] valid [`SparseImageMemoryBindInfo`] structures
/// - If [`signal_semaphore_count`] is not `0`, [`signal_semaphores`] **must**  be a valid pointer
///   to an array of [`signal_semaphore_count`] valid [`Semaphore`] handles
/// - Both of the elements of [`signal_semaphores`], and the elements of [`wait_semaphores`] that
///   are valid handles of non-ignored parameters  **must**  have been created, allocated, or
///   retrieved from the same [`Device`]
///# Related
/// - [`crate::vulkan1_0`]
/// - [`Semaphore`]
/// - [`SparseBufferMemoryBindInfo`]
/// - [`SparseImageMemoryBindInfo`]
/// - [`SparseImageOpaqueMemoryBindInfo`]
/// - [`StructureType`]
/// - [`QueueBindSparse`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[repr(C)]
pub struct BindSparseInfo<'lt> {
    _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] is the type of this structure.
    s_type: StructureType,
    ///[`p_next`] is `NULL` or a pointer to a structure extending this
    ///structure.
    p_next: *const BaseInStructure<'lt>,
    ///[`wait_semaphore_count`] is the number of semaphores upon which to wait
    ///before executing the sparse binding operations for the batch.
    wait_semaphore_count: u32,
    ///[`wait_semaphores`] is a pointer to an array of semaphores upon which
    ///to wait on before the sparse binding operations for this batch begin
    ///execution.
    ///If semaphores to wait on are provided, they define a
    ///[semaphore wait operation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-semaphores-waiting).
    wait_semaphores: *const Semaphore,
    ///[`buffer_bind_count`] is the number of sparse buffer bindings to perform
    ///in the batch.
    buffer_bind_count: u32,
    ///[`buffer_binds`] is a pointer to an array of
    ///[`SparseBufferMemoryBindInfo`] structures.
    buffer_binds: *const SparseBufferMemoryBindInfo<'lt>,
    ///[`image_opaque_bind_count`] is the number of opaque sparse image bindings
    ///to perform.
    image_opaque_bind_count: u32,
    ///[`image_opaque_binds`] is a pointer to an array of
    ///[`SparseImageOpaqueMemoryBindInfo`] structures, indicating opaque
    ///sparse image bindings to perform.
    image_opaque_binds: *const SparseImageOpaqueMemoryBindInfo<'lt>,
    ///[`image_bind_count`] is the number of sparse image bindings to perform.
    image_bind_count: u32,
    ///[`image_binds`] is a pointer to an array of
    ///[`SparseImageMemoryBindInfo`] structures, indicating sparse image
    ///bindings to perform.
    image_binds: *const SparseImageMemoryBindInfo<'lt>,
    ///[`signal_semaphore_count`] is the number of semaphores to be signaled
    ///once the sparse binding operations specified by the structure have
    ///completed execution.
    signal_semaphore_count: u32,
    ///[`signal_semaphores`] is a pointer to an array of semaphores which
    ///will be signaled when the sparse binding operations for this batch have
    ///completed execution.
    ///If semaphores to be signaled are provided, they define a
    ///[semaphore signal operation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-semaphores-signaling).
    signal_semaphores: *const Semaphore,
}
impl<'lt> Default for BindSparseInfo<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: Default::default(),
            p_next: std::ptr::null(),
            wait_semaphore_count: 0,
            wait_semaphores: std::ptr::null(),
            buffer_bind_count: 0,
            buffer_binds: std::ptr::null(),
            image_opaque_bind_count: 0,
            image_opaque_binds: std::ptr::null(),
            image_bind_count: 0,
            image_binds: std::ptr::null(),
            signal_semaphore_count: 0,
            signal_semaphores: std::ptr::null(),
        }
    }
}
impl<'lt> BindSparseInfo<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *const BaseInStructure<'lt> {
        self.p_next
    }
    ///Gets the raw value of [`Self::wait_semaphores`]
    pub fn wait_semaphores_raw(&self) -> *const Semaphore {
        self.wait_semaphores
    }
    ///Gets the raw value of [`Self::buffer_binds`]
    pub fn buffer_binds_raw(&self) -> *const SparseBufferMemoryBindInfo<'lt> {
        self.buffer_binds
    }
    ///Gets the raw value of [`Self::image_opaque_binds`]
    pub fn image_opaque_binds_raw(&self) -> *const SparseImageOpaqueMemoryBindInfo<'lt> {
        self.image_opaque_binds
    }
    ///Gets the raw value of [`Self::image_binds`]
    pub fn image_binds_raw(&self) -> *const SparseImageMemoryBindInfo<'lt> {
        self.image_binds
    }
    ///Gets the raw value of [`Self::signal_semaphores`]
    pub fn signal_semaphores_raw(&self) -> *const Semaphore {
        self.signal_semaphores
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *const BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::wait_semaphores`]
    pub fn set_wait_semaphores_raw(&mut self, value: *const Semaphore) -> &mut Self {
        self.wait_semaphores = value;
        self
    }
    ///Sets the raw value of [`Self::buffer_binds`]
    pub fn set_buffer_binds_raw(&mut self, value: *const SparseBufferMemoryBindInfo<'lt>) -> &mut Self {
        self.buffer_binds = value;
        self
    }
    ///Sets the raw value of [`Self::image_opaque_binds`]
    pub fn set_image_opaque_binds_raw(&mut self, value: *const SparseImageOpaqueMemoryBindInfo<'lt>) -> &mut Self {
        self.image_opaque_binds = value;
        self
    }
    ///Sets the raw value of [`Self::image_binds`]
    pub fn set_image_binds_raw(&mut self, value: *const SparseImageMemoryBindInfo<'lt>) -> &mut Self {
        self.image_binds = value;
        self
    }
    ///Sets the raw value of [`Self::signal_semaphores`]
    pub fn set_signal_semaphores_raw(&mut self, value: *const Semaphore) -> &mut Self {
        self.signal_semaphores = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseInStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::wait_semaphore_count`]
    pub fn wait_semaphore_count(&self) -> u32 {
        self.wait_semaphore_count
    }
    ///Gets the value of [`Self::wait_semaphores`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn wait_semaphores(&self) -> &[Semaphore] {
        std::slice::from_raw_parts(self.wait_semaphores, self.wait_semaphore_count as usize)
    }
    ///Gets the value of [`Self::buffer_bind_count`]
    pub fn buffer_bind_count(&self) -> u32 {
        self.buffer_bind_count
    }
    ///Gets the value of [`Self::buffer_binds`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn buffer_binds(&self) -> &[SparseBufferMemoryBindInfo<'lt>] {
        std::slice::from_raw_parts(self.buffer_binds, self.buffer_bind_count as usize)
    }
    ///Gets the value of [`Self::image_opaque_bind_count`]
    pub fn image_opaque_bind_count(&self) -> u32 {
        self.image_opaque_bind_count
    }
    ///Gets the value of [`Self::image_opaque_binds`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn image_opaque_binds(&self) -> &[SparseImageOpaqueMemoryBindInfo<'lt>] {
        std::slice::from_raw_parts(self.image_opaque_binds, self.image_opaque_bind_count as usize)
    }
    ///Gets the value of [`Self::image_bind_count`]
    pub fn image_bind_count(&self) -> u32 {
        self.image_bind_count
    }
    ///Gets the value of [`Self::image_binds`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn image_binds(&self) -> &[SparseImageMemoryBindInfo<'lt>] {
        std::slice::from_raw_parts(self.image_binds, self.image_bind_count as usize)
    }
    ///Gets the value of [`Self::signal_semaphore_count`]
    pub fn signal_semaphore_count(&self) -> u32 {
        self.signal_semaphore_count
    }
    ///Gets the value of [`Self::signal_semaphores`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn signal_semaphores(&self) -> &[Semaphore] {
        std::slice::from_raw_parts(self.signal_semaphores, self.signal_semaphore_count as usize)
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::wait_semaphore_count`]
    pub fn wait_semaphore_count_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::buffer_bind_count`]
    pub fn buffer_bind_count_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::image_opaque_bind_count`]
    pub fn image_opaque_bind_count_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::image_bind_count`]
    pub fn image_bind_count_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::signal_semaphore_count`]
    pub fn signal_semaphore_count_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Sets the raw value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the raw value of [`Self::wait_semaphore_count`]
    pub fn set_wait_semaphore_count(&mut self, value: u32) -> &mut Self {
        self.wait_semaphore_count = value;
        self
    }
    ///Sets the raw value of [`Self::wait_semaphores`]
    pub fn set_wait_semaphores(&mut self, value: &'lt [crate::vulkan1_0::Semaphore]) -> &mut Self {
        let len_ = value.len() as u32;
        let len_ = len_;
        self.wait_semaphores = value.as_ptr();
        self.wait_semaphore_count = len_;
        self
    }
    ///Sets the raw value of [`Self::buffer_bind_count`]
    pub fn set_buffer_bind_count(&mut self, value: u32) -> &mut Self {
        self.buffer_bind_count = value;
        self
    }
    ///Sets the raw value of [`Self::buffer_binds`]
    pub fn set_buffer_binds(&mut self, value: &'lt [crate::vulkan1_0::SparseBufferMemoryBindInfo<'lt>]) -> &mut Self {
        let len_ = value.len() as u32;
        let len_ = len_;
        self.buffer_binds = value.as_ptr();
        self.buffer_bind_count = len_;
        self
    }
    ///Sets the raw value of [`Self::image_opaque_bind_count`]
    pub fn set_image_opaque_bind_count(&mut self, value: u32) -> &mut Self {
        self.image_opaque_bind_count = value;
        self
    }
    ///Sets the raw value of [`Self::image_opaque_binds`]
    pub fn set_image_opaque_binds(
        &mut self,
        value: &'lt [crate::vulkan1_0::SparseImageOpaqueMemoryBindInfo<'lt>],
    ) -> &mut Self {
        let len_ = value.len() as u32;
        let len_ = len_;
        self.image_opaque_binds = value.as_ptr();
        self.image_opaque_bind_count = len_;
        self
    }
    ///Sets the raw value of [`Self::image_bind_count`]
    pub fn set_image_bind_count(&mut self, value: u32) -> &mut Self {
        self.image_bind_count = value;
        self
    }
    ///Sets the raw value of [`Self::image_binds`]
    pub fn set_image_binds(&mut self, value: &'lt [crate::vulkan1_0::SparseImageMemoryBindInfo<'lt>]) -> &mut Self {
        let len_ = value.len() as u32;
        let len_ = len_;
        self.image_binds = value.as_ptr();
        self.image_bind_count = len_;
        self
    }
    ///Sets the raw value of [`Self::signal_semaphore_count`]
    pub fn set_signal_semaphore_count(&mut self, value: u32) -> &mut Self {
        self.signal_semaphore_count = value;
        self
    }
    ///Sets the raw value of [`Self::signal_semaphores`]
    pub fn set_signal_semaphores(&mut self, value: &'lt [crate::vulkan1_0::Semaphore]) -> &mut Self {
        let len_ = value.len() as u32;
        let len_ = len_;
        self.signal_semaphores = value.as_ptr();
        self.signal_semaphore_count = len_;
        self
    }
}
///[VkImageCopy](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageCopy.html) - Structure specifying an image copy operation
///# C Specifications
///The [`ImageCopy`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkImageCopy {
///    VkImageSubresourceLayers    srcSubresource;
///    VkOffset3D                  srcOffset;
///    VkImageSubresourceLayers    dstSubresource;
///    VkOffset3D                  dstOffset;
///    VkExtent3D                  extent;
///} VkImageCopy;
///```
///# Members
/// - [`src_subresource`] and [`dst_subresource`] are [`ImageSubresourceLayers`] structures
///   specifying the image subresources of the images used for the source and destination image
///   data, respectively.
/// - [`src_offset`] and [`dst_offset`] select the initial `x`, `y`, and `z` offsets in texels of
///   the sub-regions of the source and destination image data.
/// - [`extent`] is the size in texels of the image to copy in `width`, `height` and `depth`.
///# Description
///For `VK_IMAGE_TYPE_3D` images, copies are performed slice by slice
///starting with the `z` member of the [`src_offset`] or [`dst_offset`],
///and copying `depth` slices.
///For images with multiple layers, copies are performed layer by layer
///starting with the `baseArrayLayer` member of the [`src_subresource`] or
///[`dst_subresource`] and copying `layerCount` layers.
///Image data  **can**  be copied between images with different image types.
///If one image is `VK_IMAGE_TYPE_3D` and the other image is
///`VK_IMAGE_TYPE_2D` with multiple layers, then each slice is copied to or
///from a different layer.Copies involving a [multi-planar image format](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#formats-requiring-sampler-ycbcr-conversion) specify the region to be copied in terms of the
///*plane* to be copied, not the coordinates of the multi-planar image.
///This means that copies accessing the R/B planes of “`_422`” format
///images  **must**  fit the copied region within half the `width` of the parent
///image, and that copies accessing the R/B planes of “`_420`” format
///images  **must**  fit the copied region within half the `width` and
///`height` of the parent image.
///## Valid Usage
/// - The number of slices of the [`extent`] (for 3D) or layers of the [`src_subresource`] (for
///   non-3D)  **must**  match the number of slices of the [`extent`] (for 3D) or layers of the
///   [`dst_subresource`] (for non-3D)
///
///## Valid Usage (Implicit)
/// - [`src_subresource`] **must**  be a valid [`ImageSubresourceLayers`] structure
/// - [`dst_subresource`] **must**  be a valid [`ImageSubresourceLayers`] structure
///# Related
/// - [`crate::vulkan1_0`]
/// - [`Extent3D`]
/// - [`ImageSubresourceLayers`]
/// - [`Offset3D`]
/// - [`CmdCopyImage`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct ImageCopy {
    ///[`src_subresource`] and [`dst_subresource`] are
    ///[`ImageSubresourceLayers`] structures specifying the image
    ///subresources of the images used for the source and destination image
    ///data, respectively.
    src_subresource: ImageSubresourceLayers,
    ///[`src_offset`] and [`dst_offset`] select the initial `x`, `y`,
    ///and `z` offsets in texels of the sub-regions of the source and
    ///destination image data.
    src_offset: Offset3D,
    ///No documentation found
    dst_subresource: ImageSubresourceLayers,
    ///No documentation found
    dst_offset: Offset3D,
    ///[`extent`] is the size in texels of the image to copy in `width`,
    ///`height` and `depth`.
    extent: Extent3D,
}
impl Default for ImageCopy {
    fn default() -> Self {
        Self {
            src_subresource: Default::default(),
            src_offset: Default::default(),
            dst_subresource: Default::default(),
            dst_offset: Default::default(),
            extent: Default::default(),
        }
    }
}
impl ImageCopy {
    ///Gets the value of [`Self::src_subresource`]
    pub fn src_subresource(&self) -> ImageSubresourceLayers {
        self.src_subresource
    }
    ///Gets the value of [`Self::src_offset`]
    pub fn src_offset(&self) -> Offset3D {
        self.src_offset
    }
    ///Gets the value of [`Self::dst_subresource`]
    pub fn dst_subresource(&self) -> ImageSubresourceLayers {
        self.dst_subresource
    }
    ///Gets the value of [`Self::dst_offset`]
    pub fn dst_offset(&self) -> Offset3D {
        self.dst_offset
    }
    ///Gets the value of [`Self::extent`]
    pub fn extent(&self) -> Extent3D {
        self.extent
    }
    ///Gets a mutable reference to the value of [`Self::src_subresource`]
    pub fn src_subresource_mut(&mut self) -> &mut ImageSubresourceLayers {
        &mut self.src_subresource
    }
    ///Gets a mutable reference to the value of [`Self::src_offset`]
    pub fn src_offset_mut(&mut self) -> &mut Offset3D {
        &mut self.src_offset
    }
    ///Gets a mutable reference to the value of [`Self::dst_subresource`]
    pub fn dst_subresource_mut(&mut self) -> &mut ImageSubresourceLayers {
        &mut self.dst_subresource
    }
    ///Gets a mutable reference to the value of [`Self::dst_offset`]
    pub fn dst_offset_mut(&mut self) -> &mut Offset3D {
        &mut self.dst_offset
    }
    ///Gets a mutable reference to the value of [`Self::extent`]
    pub fn extent_mut(&mut self) -> &mut Extent3D {
        &mut self.extent
    }
    ///Sets the raw value of [`Self::src_subresource`]
    pub fn set_src_subresource(&mut self, value: crate::vulkan1_0::ImageSubresourceLayers) -> &mut Self {
        self.src_subresource = value;
        self
    }
    ///Sets the raw value of [`Self::src_offset`]
    pub fn set_src_offset(&mut self, value: crate::vulkan1_0::Offset3D) -> &mut Self {
        self.src_offset = value;
        self
    }
    ///Sets the raw value of [`Self::dst_subresource`]
    pub fn set_dst_subresource(&mut self, value: crate::vulkan1_0::ImageSubresourceLayers) -> &mut Self {
        self.dst_subresource = value;
        self
    }
    ///Sets the raw value of [`Self::dst_offset`]
    pub fn set_dst_offset(&mut self, value: crate::vulkan1_0::Offset3D) -> &mut Self {
        self.dst_offset = value;
        self
    }
    ///Sets the raw value of [`Self::extent`]
    pub fn set_extent(&mut self, value: crate::vulkan1_0::Extent3D) -> &mut Self {
        self.extent = value;
        self
    }
}
///[VkImageBlit](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageBlit.html) - Structure specifying an image blit operation
///# C Specifications
///The [`ImageBlit`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkImageBlit {
///    VkImageSubresourceLayers    srcSubresource;
///    VkOffset3D                  srcOffsets[2];
///    VkImageSubresourceLayers    dstSubresource;
///    VkOffset3D                  dstOffsets[2];
///} VkImageBlit;
///```
///# Members
/// - [`src_subresource`] is the subresource to blit from.
/// - [`src_offsets`] is a pointer to an array of two [`Offset3D`] structures specifying the bounds
///   of the source region within [`src_subresource`].
/// - [`dst_subresource`] is the subresource to blit into.
/// - [`dst_offsets`] is a pointer to an array of two [`Offset3D`] structures specifying the bounds
///   of the destination region within [`dst_subresource`].
///# Description
///For each element of the `pRegions` array, a blit operation is performed
///for the specified source and destination regions.
///## Valid Usage
/// - The `aspectMask` member of [`src_subresource`] and [`dst_subresource`] **must**  match
/// - The `layerCount` member of [`src_subresource`] and [`dst_subresource`] **must**  match
///
///## Valid Usage (Implicit)
/// - [`src_subresource`] **must**  be a valid [`ImageSubresourceLayers`] structure
/// - [`dst_subresource`] **must**  be a valid [`ImageSubresourceLayers`] structure
///# Related
/// - [`crate::vulkan1_0`]
/// - [`ImageSubresourceLayers`]
/// - [`Offset3D`]
/// - [`CmdBlitImage`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct ImageBlit {
    ///[`src_subresource`] is the subresource to blit from.
    src_subresource: ImageSubresourceLayers,
    ///[`src_offsets`] is a pointer to an array of two [`Offset3D`]
    ///structures specifying the bounds of the source region within
    ///[`src_subresource`].
    src_offsets: [Offset3D; 2],
    ///[`dst_subresource`] is the subresource to blit into.
    dst_subresource: ImageSubresourceLayers,
    ///[`dst_offsets`] is a pointer to an array of two [`Offset3D`]
    ///structures specifying the bounds of the destination region within
    ///[`dst_subresource`].
    dst_offsets: [Offset3D; 2],
}
impl Default for ImageBlit {
    fn default() -> Self {
        Self {
            src_subresource: Default::default(),
            src_offsets: [Default::default(); 2],
            dst_subresource: Default::default(),
            dst_offsets: [Default::default(); 2],
        }
    }
}
impl ImageBlit {
    ///Gets the value of [`Self::src_subresource`]
    pub fn src_subresource(&self) -> ImageSubresourceLayers {
        self.src_subresource
    }
    ///Gets the value of [`Self::src_offsets`]
    pub fn src_offsets(&self) -> &[Offset3D; 2] {
        &getter
    }
    ///Gets the value of [`Self::dst_subresource`]
    pub fn dst_subresource(&self) -> ImageSubresourceLayers {
        self.dst_subresource
    }
    ///Gets the value of [`Self::dst_offsets`]
    pub fn dst_offsets(&self) -> &[Offset3D; 2] {
        &getter
    }
    ///Gets a mutable reference to the value of [`Self::src_subresource`]
    pub fn src_subresource_mut(&mut self) -> &mut ImageSubresourceLayers {
        &mut self.src_subresource
    }
    ///Gets a mutable reference to the value of [`Self::src_offsets`]
    pub fn src_offsets_mut(&mut self) -> &mut [Offset3D; 2] {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::dst_subresource`]
    pub fn dst_subresource_mut(&mut self) -> &mut ImageSubresourceLayers {
        &mut self.dst_subresource
    }
    ///Gets a mutable reference to the value of [`Self::dst_offsets`]
    pub fn dst_offsets_mut(&mut self) -> &mut [Offset3D; 2] {
        &mut getter
    }
    ///Sets the raw value of [`Self::src_subresource`]
    pub fn set_src_subresource(&mut self, value: crate::vulkan1_0::ImageSubresourceLayers) -> &mut Self {
        self.src_subresource = value;
        self
    }
    ///Sets the raw value of [`Self::src_offsets`]
    pub fn set_src_offsets(&mut self, value: [crate::vulkan1_0::Offset3D; 2]) -> &mut Self {
        self.src_offsets = value;
        self
    }
    ///Sets the raw value of [`Self::dst_subresource`]
    pub fn set_dst_subresource(&mut self, value: crate::vulkan1_0::ImageSubresourceLayers) -> &mut Self {
        self.dst_subresource = value;
        self
    }
    ///Sets the raw value of [`Self::dst_offsets`]
    pub fn set_dst_offsets(&mut self, value: [crate::vulkan1_0::Offset3D; 2]) -> &mut Self {
        self.dst_offsets = value;
        self
    }
}
///[VkBufferImageCopy](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferImageCopy.html) - Structure specifying a buffer image copy operation
///# C Specifications
///For both [`CmdCopyBufferToImage`] and [`CmdCopyImageToBuffer`], each
///element of `pRegions` is a structure defined as:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkBufferImageCopy {
///    VkDeviceSize                bufferOffset;
///    uint32_t                    bufferRowLength;
///    uint32_t                    bufferImageHeight;
///    VkImageSubresourceLayers    imageSubresource;
///    VkOffset3D                  imageOffset;
///    VkExtent3D                  imageExtent;
///} VkBufferImageCopy;
///```
///# Members
/// - [`buffer_offset`] is the offset in bytes from the start of the buffer object where the image
///   data is copied from or to.
/// - [`buffer_row_length`] and [`buffer_image_height`] specify in texels a subregion of a larger
///   two- or three-dimensional image in buffer memory, and control the addressing calculations. If
///   either of these values is zero, that aspect of the buffer memory is considered to be tightly
///   packed according to the [`image_extent`].
/// - [`image_subresource`] is a [`ImageSubresourceLayers`] used to specify the specific image
///   subresources of the image used for the source or destination image data.
/// - [`image_offset`] selects the initial `x`, `y`, `z` offsets in texels of the sub-region of the
///   source or destination image data.
/// - [`image_extent`] is the size in texels of the image to copy in `width`, `height` and `depth`.
///# Description
///When copying to or from a depth or stencil aspect, the data in buffer memory
///uses a layout that is a (mostly) tightly packed representation of the depth
///or stencil data.
///Specifically:
/// - data copied to or from the stencil aspect of any depth/stencil format is tightly packed with
///   one `VK_FORMAT_S8_UINT` value per texel.
/// - data copied to or from the depth aspect of a `VK_FORMAT_D16_UNORM` or
///   `VK_FORMAT_D16_UNORM_S8_UINT` format is tightly packed with one `VK_FORMAT_D16_UNORM` value
///   per texel.
/// - data copied to or from the depth aspect of a `VK_FORMAT_D32_SFLOAT` or
///   `VK_FORMAT_D32_SFLOAT_S8_UINT` format is tightly packed with one `VK_FORMAT_D32_SFLOAT` value
///   per texel.
/// - data copied to or from the depth aspect of a `VK_FORMAT_X8_D24_UNORM_PACK32` or
///   `VK_FORMAT_D24_UNORM_S8_UINT` format is packed with one 32-bit word per texel with the D24
///   value in the LSBs of the word, and undefined values in the eight MSBs.
///Because depth or stencil aspect buffer to image copies  **may**  require format
///conversions on some implementations, they are not supported on queues that
///do not support graphics.When copying to a depth aspect,
///and the `[`VK_EXT_depth_range_unrestricted`]` extension is not enabled,
///the data in buffer memory  **must**  be in the range [0,1], or the
///resulting values are undefined.Copies are done layer by layer starting with image layer
///`baseArrayLayer` member of [`image_subresource`].
///`layerCount` layers are copied from the source image or to the
///destination image.For purpose of valid usage statements here and in related copy commands, a
///*blocked image* is defined as:
/// - an image with a *single-plane*, “`_422`” format, which is treated as a format with a 2 × 1
///   compressed texel block, or
/// - a compressed image.
///
///## Valid Usage
/// - [`buffer_row_length`] **must**  be `0`, or greater than or equal to the `width` member of
///   [`image_extent`]
/// - [`buffer_image_height`] **must**  be `0`, or greater than or equal to the `height` member of
///   [`image_extent`]
/// - The `aspectMask` member of [`image_subresource`] **must**  only have a single bit set
///
///## Valid Usage (Implicit)
/// - [`image_subresource`] **must**  be a valid [`ImageSubresourceLayers`] structure
///# Related
/// - [`crate::vulkan1_0`]
/// - [`DeviceSize`]
/// - [`Extent3D`]
/// - [`ImageSubresourceLayers`]
/// - [`Offset3D`]
/// - [`CmdCopyBufferToImage`]
/// - [`CmdCopyImageToBuffer`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct BufferImageCopy {
    ///[`buffer_offset`] is the offset in bytes from the start of the buffer
    ///object where the image data is copied from or to.
    buffer_offset: DeviceSize,
    ///[`buffer_row_length`] and [`buffer_image_height`] specify in texels a
    ///subregion of a larger two- or three-dimensional image in buffer memory,
    ///and control the addressing calculations.
    ///If either of these values is zero, that aspect of the buffer memory is
    ///considered to be tightly packed according to the [`image_extent`].
    buffer_row_length: u32,
    ///No documentation found
    buffer_image_height: u32,
    ///[`image_subresource`] is a [`ImageSubresourceLayers`] used to
    ///specify the specific image subresources of the image used for the source
    ///or destination image data.
    image_subresource: ImageSubresourceLayers,
    ///[`image_offset`] selects the initial `x`, `y`, `z` offsets
    ///in texels of the sub-region of the source or destination image data.
    image_offset: Offset3D,
    ///[`image_extent`] is the size in texels of the image to copy in
    ///`width`, `height` and `depth`.
    image_extent: Extent3D,
}
impl Default for BufferImageCopy {
    fn default() -> Self {
        Self {
            buffer_offset: Default::default(),
            buffer_row_length: 0,
            buffer_image_height: 0,
            image_subresource: Default::default(),
            image_offset: Default::default(),
            image_extent: Default::default(),
        }
    }
}
impl BufferImageCopy {
    ///Gets the value of [`Self::buffer_offset`]
    pub fn buffer_offset(&self) -> DeviceSize {
        self.buffer_offset
    }
    ///Gets the value of [`Self::buffer_row_length`]
    pub fn buffer_row_length(&self) -> u32 {
        self.buffer_row_length
    }
    ///Gets the value of [`Self::buffer_image_height`]
    pub fn buffer_image_height(&self) -> u32 {
        self.buffer_image_height
    }
    ///Gets the value of [`Self::image_subresource`]
    pub fn image_subresource(&self) -> ImageSubresourceLayers {
        self.image_subresource
    }
    ///Gets the value of [`Self::image_offset`]
    pub fn image_offset(&self) -> Offset3D {
        self.image_offset
    }
    ///Gets the value of [`Self::image_extent`]
    pub fn image_extent(&self) -> Extent3D {
        self.image_extent
    }
    ///Gets a mutable reference to the value of [`Self::buffer_offset`]
    pub fn buffer_offset_mut(&mut self) -> &mut DeviceSize {
        &mut self.buffer_offset
    }
    ///Gets a mutable reference to the value of [`Self::buffer_row_length`]
    pub fn buffer_row_length_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::buffer_image_height`]
    pub fn buffer_image_height_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::image_subresource`]
    pub fn image_subresource_mut(&mut self) -> &mut ImageSubresourceLayers {
        &mut self.image_subresource
    }
    ///Gets a mutable reference to the value of [`Self::image_offset`]
    pub fn image_offset_mut(&mut self) -> &mut Offset3D {
        &mut self.image_offset
    }
    ///Gets a mutable reference to the value of [`Self::image_extent`]
    pub fn image_extent_mut(&mut self) -> &mut Extent3D {
        &mut self.image_extent
    }
    ///Sets the raw value of [`Self::buffer_offset`]
    pub fn set_buffer_offset(&mut self, value: crate::vulkan1_0::DeviceSize) -> &mut Self {
        self.buffer_offset = value;
        self
    }
    ///Sets the raw value of [`Self::buffer_row_length`]
    pub fn set_buffer_row_length(&mut self, value: u32) -> &mut Self {
        self.buffer_row_length = value;
        self
    }
    ///Sets the raw value of [`Self::buffer_image_height`]
    pub fn set_buffer_image_height(&mut self, value: u32) -> &mut Self {
        self.buffer_image_height = value;
        self
    }
    ///Sets the raw value of [`Self::image_subresource`]
    pub fn set_image_subresource(&mut self, value: crate::vulkan1_0::ImageSubresourceLayers) -> &mut Self {
        self.image_subresource = value;
        self
    }
    ///Sets the raw value of [`Self::image_offset`]
    pub fn set_image_offset(&mut self, value: crate::vulkan1_0::Offset3D) -> &mut Self {
        self.image_offset = value;
        self
    }
    ///Sets the raw value of [`Self::image_extent`]
    pub fn set_image_extent(&mut self, value: crate::vulkan1_0::Extent3D) -> &mut Self {
        self.image_extent = value;
        self
    }
}
///[VkImageResolve](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageResolve.html) - Structure specifying an image resolve operation
///# C Specifications
///The [`ImageResolve`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkImageResolve {
///    VkImageSubresourceLayers    srcSubresource;
///    VkOffset3D                  srcOffset;
///    VkImageSubresourceLayers    dstSubresource;
///    VkOffset3D                  dstOffset;
///    VkExtent3D                  extent;
///} VkImageResolve;
///```
///# Members
/// - [`src_subresource`] and [`dst_subresource`] are [`ImageSubresourceLayers`] structures
///   specifying the image subresources of the images used for the source and destination image
///   data, respectively. Resolve of depth/stencil images is not supported.
/// - [`src_offset`] and [`dst_offset`] select the initial `x`, `y`, and `z` offsets in texels of
///   the sub-regions of the source and destination image data.
/// - [`extent`] is the size in texels of the source image to resolve in `width`, `height` and
///   `depth`.
///# Description
///## Valid Usage
/// - The `aspectMask` member of [`src_subresource`] and [`dst_subresource`] **must**  only contain
///   `VK_IMAGE_ASPECT_COLOR_BIT`
/// - The `layerCount` member of [`src_subresource`] and [`dst_subresource`] **must**  match
///
///## Valid Usage (Implicit)
/// - [`src_subresource`] **must**  be a valid [`ImageSubresourceLayers`] structure
/// - [`dst_subresource`] **must**  be a valid [`ImageSubresourceLayers`] structure
///# Related
/// - [`crate::vulkan1_0`]
/// - [`Extent3D`]
/// - [`ImageSubresourceLayers`]
/// - [`Offset3D`]
/// - [`CmdResolveImage`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct ImageResolve {
    ///[`src_subresource`] and [`dst_subresource`] are
    ///[`ImageSubresourceLayers`] structures specifying the image
    ///subresources of the images used for the source and destination image
    ///data, respectively.
    ///Resolve of depth/stencil images is not supported.
    src_subresource: ImageSubresourceLayers,
    ///[`src_offset`] and [`dst_offset`] select the initial `x`, `y`,
    ///and `z` offsets in texels of the sub-regions of the source and
    ///destination image data.
    src_offset: Offset3D,
    ///No documentation found
    dst_subresource: ImageSubresourceLayers,
    ///No documentation found
    dst_offset: Offset3D,
    ///[`extent`] is the size in texels of the source image to resolve in
    ///`width`, `height` and `depth`.
    extent: Extent3D,
}
impl Default for ImageResolve {
    fn default() -> Self {
        Self {
            src_subresource: Default::default(),
            src_offset: Default::default(),
            dst_subresource: Default::default(),
            dst_offset: Default::default(),
            extent: Default::default(),
        }
    }
}
impl ImageResolve {
    ///Gets the value of [`Self::src_subresource`]
    pub fn src_subresource(&self) -> ImageSubresourceLayers {
        self.src_subresource
    }
    ///Gets the value of [`Self::src_offset`]
    pub fn src_offset(&self) -> Offset3D {
        self.src_offset
    }
    ///Gets the value of [`Self::dst_subresource`]
    pub fn dst_subresource(&self) -> ImageSubresourceLayers {
        self.dst_subresource
    }
    ///Gets the value of [`Self::dst_offset`]
    pub fn dst_offset(&self) -> Offset3D {
        self.dst_offset
    }
    ///Gets the value of [`Self::extent`]
    pub fn extent(&self) -> Extent3D {
        self.extent
    }
    ///Gets a mutable reference to the value of [`Self::src_subresource`]
    pub fn src_subresource_mut(&mut self) -> &mut ImageSubresourceLayers {
        &mut self.src_subresource
    }
    ///Gets a mutable reference to the value of [`Self::src_offset`]
    pub fn src_offset_mut(&mut self) -> &mut Offset3D {
        &mut self.src_offset
    }
    ///Gets a mutable reference to the value of [`Self::dst_subresource`]
    pub fn dst_subresource_mut(&mut self) -> &mut ImageSubresourceLayers {
        &mut self.dst_subresource
    }
    ///Gets a mutable reference to the value of [`Self::dst_offset`]
    pub fn dst_offset_mut(&mut self) -> &mut Offset3D {
        &mut self.dst_offset
    }
    ///Gets a mutable reference to the value of [`Self::extent`]
    pub fn extent_mut(&mut self) -> &mut Extent3D {
        &mut self.extent
    }
    ///Sets the raw value of [`Self::src_subresource`]
    pub fn set_src_subresource(&mut self, value: crate::vulkan1_0::ImageSubresourceLayers) -> &mut Self {
        self.src_subresource = value;
        self
    }
    ///Sets the raw value of [`Self::src_offset`]
    pub fn set_src_offset(&mut self, value: crate::vulkan1_0::Offset3D) -> &mut Self {
        self.src_offset = value;
        self
    }
    ///Sets the raw value of [`Self::dst_subresource`]
    pub fn set_dst_subresource(&mut self, value: crate::vulkan1_0::ImageSubresourceLayers) -> &mut Self {
        self.dst_subresource = value;
        self
    }
    ///Sets the raw value of [`Self::dst_offset`]
    pub fn set_dst_offset(&mut self, value: crate::vulkan1_0::Offset3D) -> &mut Self {
        self.dst_offset = value;
        self
    }
    ///Sets the raw value of [`Self::extent`]
    pub fn set_extent(&mut self, value: crate::vulkan1_0::Extent3D) -> &mut Self {
        self.extent = value;
        self
    }
}
///[VkShaderModuleCreateInfo](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkShaderModuleCreateInfo.html) - Structure specifying parameters of a newly created shader module
///# C Specifications
///The [`ShaderModuleCreateInfo`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkShaderModuleCreateInfo {
///    VkStructureType              sType;
///    const void*                  pNext;
///    VkShaderModuleCreateFlags    flags;
///    size_t                       codeSize;
///    const uint32_t*              pCode;
///} VkShaderModuleCreateInfo;
///```
///# Members
/// - [`s_type`] is the type of this structure.
/// - [`p_next`] is `NULL` or a pointer to a structure extending this structure.
/// - [`flags`] is reserved for future use.
/// - [`code_size`] is the size, in bytes, of the code pointed to by [`code`].
/// - [`code`] is a pointer to code that is used to create the shader module. The type and format of
///   the code is determined from the content of the memory addressed by [`code`].
///# Description
///## Valid Usage
/// - [`code_size`] **must**  be greater than 0
/// - If [`code`] is a pointer to SPIR-V code, [`code_size`] **must**  be a multiple of 4
/// - [`code`] **must**  point to either valid SPIR-V code, formatted and packed as described by the
///   [Khronos SPIR-V Specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#spirv-spec)
///   or valid GLSL code which  **must**  be written to the `GL_KHR_vulkan_glsl` extension
///   specification
/// -    If [`code`] is a pointer to SPIR-V code, that code  **must**  adhere to the validation rules described by the [Validation Rules within a Module](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#spirvenv-module-validation) section of the [SPIR-V Environment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#spirvenv-capabilities) appendix
/// - If [`code`] is a pointer to GLSL code, it  **must**  be valid GLSL code written to the
///   `GL_KHR_vulkan_glsl` GLSL extension specification
/// - [`code`] **must**  declare the `Shader` capability for SPIR-V code
/// -  [`code`] **must**  not declare any capability that is not supported by the API, as described by the [Capabilities](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#spirvenv-module-validation) section of the [SPIR-V Environment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#spirvenv-capabilities) appendix
/// - If [`code`] declares any of the capabilities listed in the [SPIR-V Environment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#spirvenv-capabilities-table)
///   appendix, one of the corresponding requirements  **must**  be satisfied
/// -  [`code`] **must**  not declare any SPIR-V extension that is not supported by the API, as described by the [Extension](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#spirvenv-extensions) section of the [SPIR-V Environment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#spirvenv-capabilities) appendix
/// - If [`code`] declares any of the SPIR-V extensions listed in the [SPIR-V Environment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#spirvenv-extensions-table)
///   appendix, one of the corresponding requirements  **must**  be satisfied
///
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be `VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO`
/// - [`p_next`] **must**  be `NULL` or a pointer to a valid instance of
///   [`ShaderModuleValidationCacheCreateInfoEXT`]
/// - The [`s_type`] value of each struct in the [`p_next`] chain  **must**  be unique
/// - [`flags`] **must**  be `0`
/// - [`code`] **must**  be a valid pointer to an array of <span class="katex"><span
///   aria-hidden="true" class="katex-html"><span class="base"><span class="strut"
///   style="height:1.2251079999999999em;vertical-align:-0.345em;"></span><span class="mord"><span
///   class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span
///   class="vlist-r"><span style="height:0.8801079999999999em;" class="vlist"><span
///   style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span
///   class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord
///   mtight">4</span></span></span></span><span style="top:-3.23em;"><span style="height:3em;"
///   class="pstrut"></span><span style="border-bottom-width:0.04em;"
///   class="frac-line"></span></span><span style="top:-3.394em;"><span style="height:3em;"
///   class="pstrut"></span><span class="sizing reset-size6 size3 mtight"><span class="mord
///   mtight"><span class="mord text mtight"><span class="mord textrm
///   mtight">codeSize</span></span></span></span></span></span><span
///   class="vlist-s">​</span></span><span class="vlist-r"><span style="height:0.345em;"
///   class="vlist"><span></span></span></span></span></span><span class="mclose
///   nulldelimiter"></span></span></span></span></span>`uint32_t` values
///# Related
/// - [`crate::vulkan1_0`]
/// - [`ShaderModuleCreateFlags`]
/// - [`StructureType`]
/// - [`CreateShaderModule`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[repr(C)]
pub struct ShaderModuleCreateInfo<'lt> {
    _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] is the type of this structure.
    s_type: StructureType,
    ///[`p_next`] is `NULL` or a pointer to a structure extending this
    ///structure.
    p_next: *const BaseInStructure<'lt>,
    ///[`flags`] is reserved for future use.
    flags: ShaderModuleCreateFlags,
    ///[`code_size`] is the size, in bytes, of the code pointed to by
    ///[`code`].
    code_size: usize,
    ///[`code`] is a pointer to code that is used to create the shader
    ///module.
    ///The type and format of the code is determined from the content of the
    ///memory addressed by [`code`].
    code: *const u32,
}
impl<'lt> Default for ShaderModuleCreateInfo<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: Default::default(),
            p_next: std::ptr::null(),
            flags: Default::default(),
            code_size: 0,
            code: std::ptr::null(),
        }
    }
}
impl<'lt> ShaderModuleCreateInfo<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *const BaseInStructure<'lt> {
        self.p_next
    }
    ///Gets the raw value of [`Self::code`]
    pub fn code_raw(&self) -> *const u32 {
        self.code
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *const BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::code`]
    pub fn set_code_raw(&mut self, value: *const u32) -> &mut Self {
        self.code = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseInStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::flags`]
    pub fn flags(&self) -> ShaderModuleCreateFlags {
        self.flags
    }
    ///Gets the value of [`Self::code_size`]
    pub fn code_size(&self) -> usize {
        self.code_size
    }
    ///Gets the value of [`Self::code`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn code(&self) -> &[u32] {
        std::slice::from_raw_parts(self.code, self.code_size / 4 as usize)
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::flags`]
    pub fn flags_mut(&mut self) -> &mut ShaderModuleCreateFlags {
        &mut self.flags
    }
    ///Gets a mutable reference to the value of [`Self::code_size`]
    pub fn code_size_mut(&mut self) -> &mut usize {
        &mut getter
    }
    ///Sets the raw value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the raw value of [`Self::flags`]
    pub fn set_flags(&mut self, value: crate::vulkan1_0::ShaderModuleCreateFlags) -> &mut Self {
        self.flags = value;
        self
    }
    ///Sets the raw value of [`Self::code_size`]
    pub fn set_code_size(&mut self, value: usize) -> &mut Self {
        self.code_size = value;
        self
    }
    ///Sets the raw value of [`Self::code`]
    pub fn set_code(&mut self, value: &'lt [u32]) -> &mut Self {
        let len_ = value.len() as u32;
        let len_ = len_ / 4;
        self.code = value.as_ptr();
        self.code_size = len_;
        self
    }
}
///[VkDescriptorSetLayoutBinding](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorSetLayoutBinding.html) - Structure specifying a descriptor set layout binding
///# C Specifications
///The [`DescriptorSetLayoutBinding`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkDescriptorSetLayoutBinding {
///    uint32_t              binding;
///    VkDescriptorType      descriptorType;
///    uint32_t              descriptorCount;
///    VkShaderStageFlags    stageFlags;
///    const VkSampler*      pImmutableSamplers;
///} VkDescriptorSetLayoutBinding;
///```
///# Members
/// - [`binding`] is the binding number of this entry and corresponds to a resource of the same
///   binding number in the shader stages.
/// - [`descriptor_type`] is a [`DescriptorType`] specifying which type of resource descriptors are
///   used for this binding.
/// - [`descriptor_count`] is the number of descriptors contained in the binding, accessed in a
///   shader as an array, except if [`descriptor_type`] is `VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK`
///   in which case [`descriptor_count`] is the size in bytes of the inline uniform block. If
///   [`descriptor_count`] is zero this binding entry is reserved and the resource  **must**  not be
///   accessed from any stage via this binding within any pipeline using the set layout.
/// - [`stage_flags`] member is a bitmask of [`ShaderStageFlagBits`] specifying which pipeline
///   shader stages  **can**  access a resource for this binding. `VK_SHADER_STAGE_ALL` is a
///   shorthand specifying that all defined shader stages, including any additional stages defined
///   by extensions,  **can**  access the resource.If a shader stage is not included in
///   [`stage_flags`], then a resource  **must**  not be accessed from that stage via this binding
///   within any pipeline using the set layout. Other than input attachments which are limited to
///   the fragment shader, there are no limitations on what combinations of stages  **can**  use a
///   descriptor binding, and in particular a binding  **can**  be used by both graphics stages and
///   the compute stage.
///# Description
/// - [`immutable_samplers`] affects initialization of samplers. If [`descriptor_type`] specifies a
///   `VK_DESCRIPTOR_TYPE_SAMPLER` or `VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER` type descriptor,
///   then [`immutable_samplers`] **can**  be used to initialize a set of *immutable samplers*.
///   Immutable samplers are permanently bound into the set layout and  **must**  not be changed;
///   updating a `VK_DESCRIPTOR_TYPE_SAMPLER` descriptor with immutable samplers is not allowed and
///   updates to a `VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER` descriptor with immutable samplers
///   does not modify the samplers (the image views are updated, but the sampler updates are
///   ignored). If [`immutable_samplers`] is not `NULL`, then it is a pointer to an array of sampler
///   handles that will be copied into the set layout and used for the corresponding binding. Only
///   the sampler handles are copied; the sampler objects  **must**  not be destroyed before the
///   final use of the set layout and any descriptor pools and sets created using it. If
///   [`immutable_samplers`] is `NULL`, then the sampler slots are dynamic and sampler handles
///   **must**  be bound into descriptor sets using this layout. If [`descriptor_type`] is not one
///   of these descriptor types, then [`immutable_samplers`] is ignored.
///The above layout definition allows the descriptor bindings to be specified
///sparsely such that not all binding numbers between 0 and the maximum binding
///number need to be specified in the `pBindings` array.
///Bindings that are not specified have a [`descriptor_count`] and
///[`stage_flags`] of zero, and the value of [`descriptor_type`] is
///undefined.
///However, all binding numbers between 0 and the maximum binding number in the
///[`DescriptorSetLayoutCreateInfo::bindings`] array  **may**  consume
///memory in the descriptor set layout even if not all descriptor bindings are
///used, though it  **should**  not consume additional memory from the descriptor
///pool.
///## Valid Usage
/// - If [`descriptor_type`] is `VK_DESCRIPTOR_TYPE_SAMPLER` or
///   `VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER`, and [`descriptor_count`] is not `0` and
///   [`immutable_samplers`] is not `NULL`, [`immutable_samplers`] **must**  be a valid pointer to
///   an array of [`descriptor_count`] valid [`Sampler`] handles
/// - If the [inlineUniformBlock](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-inlineUniformBlock)
///   feature is not enabled, [`descriptor_type`] **must**  not be
///   `VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK`
/// - If [`descriptor_type`] is `VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK` then [`descriptor_count`]
///   **must**  be a multiple of `4`
/// - If [`descriptor_type`] is `VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK` then [`descriptor_count`]
///   **must**  be less than or equal to
///   [`PhysicalDeviceInlineUniformBlockProperties::max_inline_uniform_block_size`]
/// - If [`descriptor_count`] is not `0`, [`stage_flags`] **must**  be a valid combination of
///   [`ShaderStageFlagBits`] values
/// - If [`descriptor_type`] is `VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT` and [`descriptor_count`] is
///   not `0`, then [`stage_flags`] **must**  be `0` or `VK_SHADER_STAGE_FRAGMENT_BIT`
/// - The sampler objects indicated by [`immutable_samplers`] **must**  not have a `borderColor`
///   with one of the values `VK_BORDER_COLOR_FLOAT_CUSTOM_EXT` or `VK_BORDER_COLOR_INT_CUSTOM_EXT`
/// - If [`descriptor_type`] is `VK_DESCRIPTOR_TYPE_MUTABLE_VALVE`, then [`immutable_samplers`]
///   **must**  be `NULL`
///
///## Valid Usage (Implicit)
/// - [`descriptor_type`] **must**  be a valid [`DescriptorType`] value
///# Related
/// - [`crate::vulkan1_0`]
/// - [`DescriptorSetLayoutCreateInfo`]
/// - [`DescriptorType`]
/// - [`Sampler`]
/// - [`ShaderStageFlags`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[repr(C)]
pub struct DescriptorSetLayoutBinding<'lt> {
    _lifetime: PhantomData<&'lt ()>,
    ///[`binding`] is the binding number of this entry and corresponds to a
    ///resource of the same binding number in the shader stages.
    binding: u32,
    ///[`descriptor_type`] is a [`DescriptorType`] specifying which type
    ///of resource descriptors are used for this binding.
    descriptor_type: DescriptorType,
    ///[`descriptor_count`] is the number of descriptors contained in the
    ///binding, accessed in a shader as an
    ///array, except if [`descriptor_type`] is
    ///`VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK` in which case
    ///[`descriptor_count`] is the size in bytes of the inline uniform block.
    ///If [`descriptor_count`] is zero this binding entry is reserved and the
    ///resource  **must**  not be accessed from any stage via this binding within
    ///any pipeline using the set layout.
    descriptor_count: u32,
    ///[`stage_flags`] member is a bitmask of [`ShaderStageFlagBits`]
    ///specifying which pipeline shader stages  **can**  access a resource for this
    ///binding.
    ///`VK_SHADER_STAGE_ALL` is a shorthand specifying that all defined
    ///shader stages, including any additional stages defined by extensions,
    /// **can**  access the resource.If a shader stage is not included in [`stage_flags`], then a
    /// resource  **must** not be accessed from that stage via this binding within any pipeline
    /// using the set layout.
    ///Other than input attachments which are limited to the fragment shader, there
    ///are no limitations on what combinations of stages  **can**  use a descriptor
    ///binding, and in particular a binding  **can**  be used by both graphics stages
    ///and the compute stage.
    stage_flags: ShaderStageFlags,
    ///No documentation found
    immutable_samplers: *const Sampler,
}
impl<'lt> Default for DescriptorSetLayoutBinding<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            binding: 0,
            descriptor_type: Default::default(),
            descriptor_count: 0,
            stage_flags: Default::default(),
            immutable_samplers: std::ptr::null(),
        }
    }
}
impl<'lt> DescriptorSetLayoutBinding<'lt> {
    ///Gets the raw value of [`Self::immutable_samplers`]
    pub fn immutable_samplers_raw(&self) -> *const Sampler {
        self.immutable_samplers
    }
    ///Sets the raw value of [`Self::immutable_samplers`]
    pub fn set_immutable_samplers_raw(&mut self, value: *const Sampler) -> &mut Self {
        self.immutable_samplers = value;
        self
    }
    ///Gets the value of [`Self::binding`]
    pub fn binding(&self) -> u32 {
        self.binding
    }
    ///Gets the value of [`Self::descriptor_type`]
    pub fn descriptor_type(&self) -> DescriptorType {
        self.descriptor_type
    }
    ///Gets the value of [`Self::descriptor_count`]
    pub fn descriptor_count(&self) -> u32 {
        self.descriptor_count
    }
    ///Gets the value of [`Self::stage_flags`]
    pub fn stage_flags(&self) -> ShaderStageFlags {
        self.stage_flags
    }
    ///Gets the value of [`Self::immutable_samplers`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn immutable_samplers(&self) -> &[Sampler] {
        std::slice::from_raw_parts(self.immutable_samplers, self.descriptor_count as usize)
    }
    ///Gets a mutable reference to the value of [`Self::binding`]
    pub fn binding_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::descriptor_type`]
    pub fn descriptor_type_mut(&mut self) -> &mut DescriptorType {
        &mut self.descriptor_type
    }
    ///Gets a mutable reference to the value of [`Self::descriptor_count`]
    pub fn descriptor_count_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::stage_flags`]
    pub fn stage_flags_mut(&mut self) -> &mut ShaderStageFlags {
        &mut self.stage_flags
    }
    ///Sets the raw value of [`Self::binding`]
    pub fn set_binding(&mut self, value: u32) -> &mut Self {
        self.binding = value;
        self
    }
    ///Sets the raw value of [`Self::descriptor_type`]
    pub fn set_descriptor_type(&mut self, value: crate::vulkan1_0::DescriptorType) -> &mut Self {
        self.descriptor_type = value;
        self
    }
    ///Sets the raw value of [`Self::descriptor_count`]
    pub fn set_descriptor_count(&mut self, value: u32) -> &mut Self {
        self.descriptor_count = value;
        self
    }
    ///Sets the raw value of [`Self::stage_flags`]
    pub fn set_stage_flags(&mut self, value: crate::vulkan1_0::ShaderStageFlags) -> &mut Self {
        self.stage_flags = value;
        self
    }
    ///Sets the raw value of [`Self::immutable_samplers`]
    pub fn set_immutable_samplers(&mut self, value: &'lt [crate::vulkan1_0::Sampler]) -> &mut Self {
        let len_ = value.len() as u32;
        let len_ = len_;
        self.immutable_samplers = value.as_ptr();
        self.descriptor_count = len_;
        self
    }
}
///[VkDescriptorSetLayoutCreateInfo](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorSetLayoutCreateInfo.html) - Structure specifying parameters of a newly created descriptor set layout
///# C Specifications
///Information about the descriptor set layout is passed in a
///[`DescriptorSetLayoutCreateInfo`] structure:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkDescriptorSetLayoutCreateInfo {
///    VkStructureType                        sType;
///    const void*                            pNext;
///    VkDescriptorSetLayoutCreateFlags       flags;
///    uint32_t                               bindingCount;
///    const VkDescriptorSetLayoutBinding*    pBindings;
///} VkDescriptorSetLayoutCreateInfo;
///```
///# Members
/// - [`s_type`] is the type of this structure.
/// - [`p_next`] is `NULL` or a pointer to a structure extending this structure.
/// - [`flags`] is a bitmask of [`DescriptorSetLayoutCreateFlagBits`] specifying options for
///   descriptor set layout creation.
/// - [`binding_count`] is the number of elements in [`bindings`].
/// - [`bindings`] is a pointer to an array of [`DescriptorSetLayoutBinding`] structures.
///# Description
///## Valid Usage
/// - The [`DescriptorSetLayoutBinding::binding`] members of the elements of the [`bindings`] array
///   **must**  each have different values
/// - If [`flags`] contains `VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR`, then all
///   elements of [`bindings`] **must**  not have a `descriptorType` of
///   `VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC` or `VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC`
/// - If [`flags`] contains `VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR`, then all
///   elements of [`bindings`] **must**  not have a `descriptorType` of
///   `VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK`
/// - If [`flags`] contains `VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR`, then the
///   total number of elements of all bindings  **must**  be less than or equal to
///   [`PhysicalDevicePushDescriptorPropertiesKHR::max_push_descriptors`]
/// - If [`flags`] contains `VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR`, [`flags`]
///   **must**  not contain `VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_VALVE`
/// - If [`flags`] contains `VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR`, [`bindings`]
///   **must**  not have a `descriptorType` of `VK_DESCRIPTOR_TYPE_MUTABLE_VALVE`
/// - If any binding has the `VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT` bit set, [`flags`]
///   **must**  include `VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT`
/// - If any binding has the `VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT` bit set, then all
///   bindings  **must**  not have `descriptorType` of `VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC`
///   or `VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC`
/// - If [`flags`] contains `VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT`, [`flags`]
///   **must**  not contain `VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_VALVE`
/// - If any binding has a `descriptorType` of `VK_DESCRIPTOR_TYPE_MUTABLE_VALVE`, then a
///   [`MutableDescriptorTypeCreateInfoVALVE`] **must**  be present in the [`p_next`] chain
/// - If a binding has a `descriptorType` value of `VK_DESCRIPTOR_TYPE_MUTABLE_VALVE`, then
///   `pImmutableSamplers` **must**  be `NULL`
/// - If [`PhysicalDeviceMutableDescriptorTypeFeaturesVALVE::mutable_descriptor_type`] is not
///   enabled, [`bindings`] **must**  not contain a `descriptorType` of
///   `VK_DESCRIPTOR_TYPE_MUTABLE_VALVE`
/// - If [`flags`] contains `VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_VALVE`,
///   [`PhysicalDeviceMutableDescriptorTypeFeaturesVALVE::mutable_descriptor_type`] **must**  be
///   enabled
///
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be `VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO`
/// - Each [`p_next`] member of any structure (including this one) in the [`p_next`] chain  **must**
///   be either `NULL` or a pointer to a valid instance of
///   [`DescriptorSetLayoutBindingFlagsCreateInfo`] or [`MutableDescriptorTypeCreateInfoVALVE`]
/// - The [`s_type`] value of each struct in the [`p_next`] chain  **must**  be unique
/// - [`flags`] **must**  be a valid combination of [`DescriptorSetLayoutCreateFlagBits`] values
/// - If [`binding_count`] is not `0`, [`bindings`] **must**  be a valid pointer to an array of
///   [`binding_count`] valid [`DescriptorSetLayoutBinding`] structures
///# Related
/// - [`crate::vulkan1_0`]
/// - [`DescriptorSetLayoutBinding`]
/// - [`DescriptorSetLayoutCreateFlags`]
/// - [`StructureType`]
/// - [`CreateDescriptorSetLayout`]
/// - [`GetDescriptorSetLayoutSupport`]
/// - [`GetDescriptorSetLayoutSupportKHR`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[repr(C)]
pub struct DescriptorSetLayoutCreateInfo<'lt> {
    _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] is the type of this structure.
    s_type: StructureType,
    ///[`p_next`] is `NULL` or a pointer to a structure extending this
    ///structure.
    p_next: *const BaseInStructure<'lt>,
    ///[`flags`] is a bitmask
    ///of [`DescriptorSetLayoutCreateFlagBits`]
    ///specifying options for descriptor set layout creation.
    flags: DescriptorSetLayoutCreateFlags,
    ///[`binding_count`] is the number of elements in [`bindings`].
    binding_count: u32,
    ///[`bindings`] is a pointer to an array of
    ///[`DescriptorSetLayoutBinding`] structures.
    bindings: *const DescriptorSetLayoutBinding<'lt>,
}
impl<'lt> Default for DescriptorSetLayoutCreateInfo<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: Default::default(),
            p_next: std::ptr::null(),
            flags: Default::default(),
            binding_count: 0,
            bindings: std::ptr::null(),
        }
    }
}
impl<'lt> DescriptorSetLayoutCreateInfo<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *const BaseInStructure<'lt> {
        self.p_next
    }
    ///Gets the raw value of [`Self::bindings`]
    pub fn bindings_raw(&self) -> *const DescriptorSetLayoutBinding<'lt> {
        self.bindings
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *const BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::bindings`]
    pub fn set_bindings_raw(&mut self, value: *const DescriptorSetLayoutBinding<'lt>) -> &mut Self {
        self.bindings = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseInStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::flags`]
    pub fn flags(&self) -> DescriptorSetLayoutCreateFlags {
        self.flags
    }
    ///Gets the value of [`Self::binding_count`]
    pub fn binding_count(&self) -> u32 {
        self.binding_count
    }
    ///Gets the value of [`Self::bindings`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn bindings(&self) -> &[DescriptorSetLayoutBinding<'lt>] {
        std::slice::from_raw_parts(self.bindings, self.binding_count as usize)
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::flags`]
    pub fn flags_mut(&mut self) -> &mut DescriptorSetLayoutCreateFlags {
        &mut self.flags
    }
    ///Gets a mutable reference to the value of [`Self::binding_count`]
    pub fn binding_count_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Sets the raw value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the raw value of [`Self::flags`]
    pub fn set_flags(&mut self, value: crate::vulkan1_0::DescriptorSetLayoutCreateFlags) -> &mut Self {
        self.flags = value;
        self
    }
    ///Sets the raw value of [`Self::binding_count`]
    pub fn set_binding_count(&mut self, value: u32) -> &mut Self {
        self.binding_count = value;
        self
    }
    ///Sets the raw value of [`Self::bindings`]
    pub fn set_bindings(&mut self, value: &'lt [crate::vulkan1_0::DescriptorSetLayoutBinding<'lt>]) -> &mut Self {
        let len_ = value.len() as u32;
        let len_ = len_;
        self.bindings = value.as_ptr();
        self.binding_count = len_;
        self
    }
}
///[VkDescriptorPoolSize](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorPoolSize.html) - Structure specifying descriptor pool size
///# C Specifications
///The [`DescriptorPoolSize`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkDescriptorPoolSize {
///    VkDescriptorType    type;
///    uint32_t            descriptorCount;
///} VkDescriptorPoolSize;
///```
///# Members
/// - [`type_`] is the type of descriptor.
/// - [`descriptor_count`] is the number of descriptors of that type to allocate. If [`type_`] is
///   `VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK` then [`descriptor_count`] is the number of bytes to
///   allocate for descriptors of this type.
///# Description
///## Valid Usage
/// - [`descriptor_count`] **must**  be greater than `0`
/// - If [`type_`] is `VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK` then [`descriptor_count`] **must**
///   be a multiple of `4`
///
///## Valid Usage (Implicit)
/// - [`type_`] **must**  be a valid [`DescriptorType`] value
///# Related
/// - [`crate::vulkan1_0`]
/// - [`DescriptorPoolCreateInfo`]
/// - [`DescriptorType`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct DescriptorPoolSize {
    ///[`type_`] is the type of descriptor.
    type_: DescriptorType,
    ///[`descriptor_count`] is the number of descriptors of that type to
    ///allocate.
    ///If [`type_`] is `VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK` then
    ///[`descriptor_count`] is the number of bytes to allocate for descriptors
    ///of this type.
    descriptor_count: u32,
}
impl Default for DescriptorPoolSize {
    fn default() -> Self {
        Self {
            type_: Default::default(),
            descriptor_count: 0,
        }
    }
}
impl DescriptorPoolSize {
    ///Gets the value of [`Self::type_`]
    pub fn type_(&self) -> DescriptorType {
        self.type_
    }
    ///Gets the value of [`Self::descriptor_count`]
    pub fn descriptor_count(&self) -> u32 {
        self.descriptor_count
    }
    ///Gets a mutable reference to the value of [`Self::type_`]
    pub fn type__mut(&mut self) -> &mut DescriptorType {
        &mut self.type_
    }
    ///Gets a mutable reference to the value of [`Self::descriptor_count`]
    pub fn descriptor_count_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Sets the raw value of [`Self::type_`]
    pub fn set_type_(&mut self, value: crate::vulkan1_0::DescriptorType) -> &mut Self {
        self.type_ = value;
        self
    }
    ///Sets the raw value of [`Self::descriptor_count`]
    pub fn set_descriptor_count(&mut self, value: u32) -> &mut Self {
        self.descriptor_count = value;
        self
    }
}
///[VkDescriptorPoolCreateInfo](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorPoolCreateInfo.html) - Structure specifying parameters of a newly created descriptor pool
///# C Specifications
///Additional information about the pool is passed in a
///[`DescriptorPoolCreateInfo`] structure:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkDescriptorPoolCreateInfo {
///    VkStructureType                sType;
///    const void*                    pNext;
///    VkDescriptorPoolCreateFlags    flags;
///    uint32_t                       maxSets;
///    uint32_t                       poolSizeCount;
///    const VkDescriptorPoolSize*    pPoolSizes;
///} VkDescriptorPoolCreateInfo;
///```
///# Members
/// - [`s_type`] is the type of this structure.
/// - [`p_next`] is `NULL` or a pointer to a structure extending this structure.
/// - [`flags`] is a bitmask of [`DescriptorPoolCreateFlagBits`] specifying certain supported
///   operations on the pool.
/// - [`max_sets`] is the maximum number of descriptor sets that  **can**  be allocated from the
///   pool.
/// - [`pool_size_count`] is the number of elements in [`pool_sizes`].
/// - [`pool_sizes`] is a pointer to an array of [`DescriptorPoolSize`] structures, each containing
///   a descriptor type and number of descriptors of that type to be allocated in the pool.
///# Description
///If multiple [`DescriptorPoolSize`] structures containing the same
///descriptor type appear in the [`pool_sizes`] array then the pool will be
///created with enough storage for the total number of descriptors of each
///type.Fragmentation of a descriptor pool is possible and  **may**  lead to descriptor
///set allocation failures.
///A failure due to fragmentation is defined as failing a descriptor set
///allocation despite the sum of all outstanding descriptor set allocations
///from the pool plus the requested allocation requiring no more than the total
///number of descriptors requested at pool creation.
///Implementations provide certain guarantees of when fragmentation  **must**  not
///cause allocation failure, as described below.If a descriptor pool has not had any descriptor
/// sets freed since it was
///created or most recently reset then fragmentation  **must**  not cause an
///allocation failure (note that this is always the case for a pool created
///without the `VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT` bit
///set).
///Additionally, if all sets allocated from the pool since it was created or
///most recently reset use the same number of descriptors (of each type) and
///the requested allocation also uses that same number of descriptors (of each
///type), then fragmentation  **must**  not cause an allocation failure.If an allocation failure
/// occurs due to fragmentation, an application  **can**
///create an additional descriptor pool to perform further descriptor set
///allocations.If [`flags`] has the `VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT`
///bit set, descriptor pool creation  **may**  fail with the error
///`VK_ERROR_FRAGMENTATION` if the total number of descriptors across all
///pools (including this one) created with this bit set exceeds
///`maxUpdateAfterBindDescriptorsInAllPools`, or if fragmentation of the
///underlying hardware resources occurs.If a [`pool_sizes`][i]::`type` is
///`VK_DESCRIPTOR_TYPE_MUTABLE_VALVE`, a
///[`MutableDescriptorTypeCreateInfoVALVE`] struct in the [`p_next`] chain
/// **can**  be used to specify which mutable descriptor types  **can**  be allocated
///from the pool.
///If present in the [`p_next`] chain,
///[`MutableDescriptorTypeCreateInfoVALVE::mutable_descriptor_type_lists`][i]
///specifies which kind of `VK_DESCRIPTOR_TYPE_MUTABLE_VALVE` descriptors
/// **can**  be allocated from this pool entry.
///If [`MutableDescriptorTypeCreateInfoVALVE`] does not exist in the
///[`p_next`] chain, or
///[`MutableDescriptorTypeCreateInfoVALVE::mutable_descriptor_type_lists`][i]
///is out of range, the descriptor pool allocates enough memory to be able to
///allocate a `VK_DESCRIPTOR_TYPE_MUTABLE_VALVE` descriptor with any
///supported [`DescriptorType`] as a mutable descriptor.
///A mutable descriptor  **can**  be allocated from a pool entry if the type list in
///[`DescriptorSetLayoutCreateInfo`] is a subset of the type list declared
///in the descriptor pool, or if the pool entry is created without a descriptor
///type list.
///Multiple [`pool_sizes`] entries with
///`VK_DESCRIPTOR_TYPE_MUTABLE_VALVE` **can**  be declared.
///When multiple such pool entries are present in [`pool_sizes`], they
///specify sets of supported descriptor types which either fully overlap,
///partially overlap, or are disjoint.
///Two sets fully overlap if the sets of supported descriptor types are equal.
///If the sets are not disjoint they partially overlap.
///A pool entry without a [`MutableDescriptorTypeListVALVE`] assigned to it
///is considered to partially overlap any other pool entry which has a
///[`MutableDescriptorTypeListVALVE`] assigned to it.
///The application  **must**  ensure that partial overlap does not exist in
///[`pool_sizes`].
///## Valid Usage
/// - [`max_sets`] **must**  be greater than `0`
/// - If [`flags`] has the `VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_VALVE` bit set, then the
///   `VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT` bit  **must**  not be set
/// - If [`PhysicalDeviceMutableDescriptorTypeFeaturesVALVE::mutable_descriptor_type`] is not
///   enabled, [`pool_sizes`] **must**  not contain a `descriptorType` of
///   `VK_DESCRIPTOR_TYPE_MUTABLE_VALVE`
/// - If [`flags`] has the `VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_VALVE` bit set,
///   [`PhysicalDeviceMutableDescriptorTypeFeaturesVALVE::mutable_descriptor_type`] **must**  be
///   enabled
/// - If [`pool_sizes`] contains a `descriptorType` of `VK_DESCRIPTOR_TYPE_MUTABLE_VALVE`, any other
///   `VK_DESCRIPTOR_TYPE_MUTABLE_VALVE` element in [`pool_sizes`] **must**  not have sets of
///   supported descriptor types which partially overlap
///
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be `VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO`
/// - Each [`p_next`] member of any structure (including this one) in the [`p_next`] chain  **must**
///   be either `NULL` or a pointer to a valid instance of
///   [`DescriptorPoolInlineUniformBlockCreateInfo`] or [`MutableDescriptorTypeCreateInfoVALVE`]
/// - The [`s_type`] value of each struct in the [`p_next`] chain  **must**  be unique
/// - [`flags`] **must**  be a valid combination of [`DescriptorPoolCreateFlagBits`] values
/// - [`pool_sizes`] **must**  be a valid pointer to an array of [`pool_size_count`] valid
///   [`DescriptorPoolSize`] structures
/// - [`pool_size_count`] **must**  be greater than `0`
///# Related
/// - [`crate::vulkan1_0`]
/// - [`DescriptorPoolCreateFlags`]
/// - [`DescriptorPoolSize`]
/// - [`StructureType`]
/// - [`CreateDescriptorPool`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[repr(C)]
pub struct DescriptorPoolCreateInfo<'lt> {
    _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] is the type of this structure.
    s_type: StructureType,
    ///[`p_next`] is `NULL` or a pointer to a structure extending this
    ///structure.
    p_next: *const BaseInStructure<'lt>,
    ///[`flags`] is a bitmask of [`DescriptorPoolCreateFlagBits`]
    ///specifying certain supported operations on the pool.
    flags: DescriptorPoolCreateFlags,
    ///[`max_sets`] is the maximum number of descriptor sets that  **can**  be
    ///allocated from the pool.
    max_sets: u32,
    ///[`pool_size_count`] is the number of elements in [`pool_sizes`].
    pool_size_count: u32,
    ///[`pool_sizes`] is a pointer to an array of [`DescriptorPoolSize`]
    ///structures, each containing a descriptor type and number of descriptors
    ///of that type to be allocated in the pool.
    pool_sizes: *const DescriptorPoolSize,
}
impl<'lt> Default for DescriptorPoolCreateInfo<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: Default::default(),
            p_next: std::ptr::null(),
            flags: Default::default(),
            max_sets: 0,
            pool_size_count: 0,
            pool_sizes: std::ptr::null(),
        }
    }
}
impl<'lt> DescriptorPoolCreateInfo<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *const BaseInStructure<'lt> {
        self.p_next
    }
    ///Gets the raw value of [`Self::pool_sizes`]
    pub fn pool_sizes_raw(&self) -> *const DescriptorPoolSize {
        self.pool_sizes
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *const BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::pool_sizes`]
    pub fn set_pool_sizes_raw(&mut self, value: *const DescriptorPoolSize) -> &mut Self {
        self.pool_sizes = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseInStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::flags`]
    pub fn flags(&self) -> DescriptorPoolCreateFlags {
        self.flags
    }
    ///Gets the value of [`Self::max_sets`]
    pub fn max_sets(&self) -> u32 {
        self.max_sets
    }
    ///Gets the value of [`Self::pool_size_count`]
    pub fn pool_size_count(&self) -> u32 {
        self.pool_size_count
    }
    ///Gets the value of [`Self::pool_sizes`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn pool_sizes(&self) -> &[DescriptorPoolSize] {
        std::slice::from_raw_parts(self.pool_sizes, self.pool_size_count as usize)
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::flags`]
    pub fn flags_mut(&mut self) -> &mut DescriptorPoolCreateFlags {
        &mut self.flags
    }
    ///Gets a mutable reference to the value of [`Self::max_sets`]
    pub fn max_sets_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::pool_size_count`]
    pub fn pool_size_count_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Sets the raw value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the raw value of [`Self::flags`]
    pub fn set_flags(&mut self, value: crate::vulkan1_0::DescriptorPoolCreateFlags) -> &mut Self {
        self.flags = value;
        self
    }
    ///Sets the raw value of [`Self::max_sets`]
    pub fn set_max_sets(&mut self, value: u32) -> &mut Self {
        self.max_sets = value;
        self
    }
    ///Sets the raw value of [`Self::pool_size_count`]
    pub fn set_pool_size_count(&mut self, value: u32) -> &mut Self {
        self.pool_size_count = value;
        self
    }
    ///Sets the raw value of [`Self::pool_sizes`]
    pub fn set_pool_sizes(&mut self, value: &'lt [crate::vulkan1_0::DescriptorPoolSize]) -> &mut Self {
        let len_ = value.len() as u32;
        let len_ = len_;
        self.pool_sizes = value.as_ptr();
        self.pool_size_count = len_;
        self
    }
}
///[VkDescriptorSetAllocateInfo](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorSetAllocateInfo.html) - Structure specifying the allocation parameters for descriptor sets
///# C Specifications
///The [`DescriptorSetAllocateInfo`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkDescriptorSetAllocateInfo {
///    VkStructureType                 sType;
///    const void*                     pNext;
///    VkDescriptorPool                descriptorPool;
///    uint32_t                        descriptorSetCount;
///    const VkDescriptorSetLayout*    pSetLayouts;
///} VkDescriptorSetAllocateInfo;
///```
///# Members
/// - [`s_type`] is the type of this structure.
/// - [`p_next`] is `NULL` or a pointer to a structure extending this structure.
/// - [`descriptor_pool`] is the pool which the sets will be allocated from.
/// - [`descriptor_set_count`] determines the number of descriptor sets to be allocated from the
///   pool.
/// - [`set_layouts`] is a pointer to an array of descriptor set layouts, with each member
///   specifying how the corresponding descriptor set is allocated.
///# Description
///## Valid Usage
/// - Each element of [`set_layouts`] **must**  not have been created with
///   `VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR` set
/// - If any element of [`set_layouts`] was created with the
///   `VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT` bit set, [`descriptor_pool`]
///   **must**  have been created with the `VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT` flag
///   set
/// - If any element of [`set_layouts`] was created with the
///   `VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_VALVE` bit set, [`descriptor_pool`]
///   **must**  have been created with the `VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_VALVE` flag set
///
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be `VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO`
/// - [`p_next`] **must**  be `NULL` or a pointer to a valid instance of
///   [`DescriptorSetVariableDescriptorCountAllocateInfo`]
/// - The [`s_type`] value of each struct in the [`p_next`] chain  **must**  be unique
/// - [`descriptor_pool`] **must**  be a valid [`DescriptorPool`] handle
/// - [`set_layouts`] **must**  be a valid pointer to an array of [`descriptor_set_count`] valid
///   [`DescriptorSetLayout`] handles
/// - [`descriptor_set_count`] **must**  be greater than `0`
/// - Both of [`descriptor_pool`], and the elements of [`set_layouts`] **must**  have been created,
///   allocated, or retrieved from the same [`Device`]
///# Related
/// - [`crate::vulkan1_0`]
/// - [`DescriptorPool`]
/// - [`DescriptorSetLayout`]
/// - [`StructureType`]
/// - [`AllocateDescriptorSets`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[repr(C)]
pub struct DescriptorSetAllocateInfo<'lt> {
    _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] is the type of this structure.
    s_type: StructureType,
    ///[`p_next`] is `NULL` or a pointer to a structure extending this
    ///structure.
    p_next: *const BaseInStructure<'lt>,
    ///[`descriptor_pool`] is the pool which the sets will be allocated from.
    descriptor_pool: DescriptorPool,
    ///[`descriptor_set_count`] determines the number of descriptor sets to be
    ///allocated from the pool.
    descriptor_set_count: u32,
    ///[`set_layouts`] is a pointer to an array of descriptor set layouts,
    ///with each member specifying how the corresponding descriptor set is
    ///allocated.
    set_layouts: *const DescriptorSetLayout,
}
impl<'lt> Default for DescriptorSetAllocateInfo<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: Default::default(),
            p_next: std::ptr::null(),
            descriptor_pool: Default::default(),
            descriptor_set_count: 0,
            set_layouts: std::ptr::null(),
        }
    }
}
impl<'lt> DescriptorSetAllocateInfo<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *const BaseInStructure<'lt> {
        self.p_next
    }
    ///Gets the raw value of [`Self::set_layouts`]
    pub fn set_layouts_raw(&self) -> *const DescriptorSetLayout {
        self.set_layouts
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *const BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::set_layouts`]
    pub fn set_set_layouts_raw(&mut self, value: *const DescriptorSetLayout) -> &mut Self {
        self.set_layouts = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseInStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::descriptor_pool`]
    pub fn descriptor_pool(&self) -> DescriptorPool {
        self.descriptor_pool
    }
    ///Gets the value of [`Self::descriptor_set_count`]
    pub fn descriptor_set_count(&self) -> u32 {
        self.descriptor_set_count
    }
    ///Gets the value of [`Self::set_layouts`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn set_layouts(&self) -> &[DescriptorSetLayout] {
        std::slice::from_raw_parts(self.set_layouts, self.descriptor_set_count as usize)
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::descriptor_pool`]
    pub fn descriptor_pool_mut(&mut self) -> &mut DescriptorPool {
        &mut self.descriptor_pool
    }
    ///Gets a mutable reference to the value of [`Self::descriptor_set_count`]
    pub fn descriptor_set_count_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Sets the raw value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the raw value of [`Self::descriptor_pool`]
    pub fn set_descriptor_pool(&mut self, value: crate::vulkan1_0::DescriptorPool) -> &mut Self {
        self.descriptor_pool = value;
        self
    }
    ///Sets the raw value of [`Self::descriptor_set_count`]
    pub fn set_descriptor_set_count(&mut self, value: u32) -> &mut Self {
        self.descriptor_set_count = value;
        self
    }
    ///Sets the raw value of [`Self::set_layouts`]
    pub fn set_set_layouts(&mut self, value: &'lt [crate::vulkan1_0::DescriptorSetLayout]) -> &mut Self {
        let len_ = value.len() as u32;
        let len_ = len_;
        self.set_layouts = value.as_ptr();
        self.descriptor_set_count = len_;
        self
    }
}
///[VkSpecializationMapEntry](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSpecializationMapEntry.html) - Structure specifying a specialization map entry
///# C Specifications
///The [`SpecializationMapEntry`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkSpecializationMapEntry {
///    uint32_t    constantID;
///    uint32_t    offset;
///    size_t      size;
///} VkSpecializationMapEntry;
///```
///# Members
/// - [`constant_id`] is the ID of the specialization constant in SPIR-V.
/// - [`offset`] is the byte offset of the specialization constant value within the supplied data
///   buffer.
/// - [`size`] is the byte size of the specialization constant value within the supplied data
///   buffer.
///# Description
///If a [`constant_id`] value is not a specialization constant ID used in the
///shader, that map entry does not affect the behavior of the pipeline.
///## Valid Usage
/// - For a [`constant_id`] specialization constant declared in a shader, [`size`] **must**  match
///   the byte size of the [`constant_id`]. If the specialization constant is of type `boolean`,
///   [`size`] **must**  be the byte size of [`Bool32`]
///# Related
/// - [`crate::vulkan1_0`]
/// - [`SpecializationInfo`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct SpecializationMapEntry {
    ///[`constant_id`] is the ID of the specialization constant in SPIR-V.
    constant_id: u32,
    ///[`offset`] is the byte offset of the specialization constant value
    ///within the supplied data buffer.
    offset: u32,
    ///[`size`] is the byte size of the specialization constant value within
    ///the supplied data buffer.
    size: usize,
}
impl Default for SpecializationMapEntry {
    fn default() -> Self {
        Self {
            constant_id: 0,
            offset: 0,
            size: 0,
        }
    }
}
impl SpecializationMapEntry {
    ///Gets the value of [`Self::constant_id`]
    pub fn constant_id(&self) -> u32 {
        self.constant_id
    }
    ///Gets the value of [`Self::offset`]
    pub fn offset(&self) -> u32 {
        self.offset
    }
    ///Gets the value of [`Self::size`]
    pub fn size(&self) -> usize {
        self.size
    }
    ///Gets a mutable reference to the value of [`Self::constant_id`]
    pub fn constant_id_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::offset`]
    pub fn offset_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::size`]
    pub fn size_mut(&mut self) -> &mut usize {
        &mut getter
    }
    ///Sets the raw value of [`Self::constant_id`]
    pub fn set_constant_id(&mut self, value: u32) -> &mut Self {
        self.constant_id = value;
        self
    }
    ///Sets the raw value of [`Self::offset`]
    pub fn set_offset(&mut self, value: u32) -> &mut Self {
        self.offset = value;
        self
    }
    ///Sets the raw value of [`Self::size`]
    pub fn set_size(&mut self, value: usize) -> &mut Self {
        self.size = value;
        self
    }
}
///[VkSpecializationInfo](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSpecializationInfo.html) - Structure specifying specialization information
///# C Specifications
///The [`SpecializationInfo`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkSpecializationInfo {
///    uint32_t                           mapEntryCount;
///    const VkSpecializationMapEntry*    pMapEntries;
///    size_t                             dataSize;
///    const void*                        pData;
///} VkSpecializationInfo;
///```
///# Members
/// - [`map_entry_count`] is the number of entries in the [`map_entries`] array.
/// - [`map_entries`] is a pointer to an array of [`SpecializationMapEntry`] structures which map
///   constant IDs to offsets in [`data`].
/// - [`data_size`] is the byte size of the [`data`] buffer.
/// - [`data`] contains the actual constant values to specialize with.
///# Description
///## Valid Usage
/// - The `offset` member of each element of [`map_entries`] **must**  be less than [`data_size`]
/// - The `size` member of each element of [`map_entries`] **must**  be less than or equal to
///   [`data_size`] minus `offset`
/// - The `constantID` value of each element of [`map_entries`] **must**  be unique within
///   [`map_entries`]
///
///## Valid Usage (Implicit)
/// - If [`map_entry_count`] is not `0`, [`map_entries`] **must**  be a valid pointer to an array of
///   [`map_entry_count`] valid [`SpecializationMapEntry`] structures
/// - If [`data_size`] is not `0`, [`data`] **must**  be a valid pointer to an array of
///   [`data_size`] bytes
///# Related
/// - [`crate::vulkan1_0`]
/// - [`PipelineShaderStageCreateInfo`]
/// - [`SpecializationMapEntry`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[repr(C)]
pub struct SpecializationInfo<'lt> {
    _lifetime: PhantomData<&'lt ()>,
    ///[`map_entry_count`] is the number of entries in the [`map_entries`]
    ///array.
    map_entry_count: u32,
    ///[`map_entries`] is a pointer to an array of
    ///[`SpecializationMapEntry`] structures which map constant IDs to
    ///offsets in [`data`].
    map_entries: *const SpecializationMapEntry,
    ///[`data_size`] is the byte size of the [`data`] buffer.
    data_size: usize,
    ///[`data`] contains the actual constant values to specialize with.
    data: *const c_void,
}
impl<'lt> Default for SpecializationInfo<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            map_entry_count: 0,
            map_entries: std::ptr::null(),
            data_size: 0,
            data: std::ptr::null(),
        }
    }
}
impl<'lt> SpecializationInfo<'lt> {
    ///Gets the raw value of [`Self::map_entries`]
    pub fn map_entries_raw(&self) -> *const SpecializationMapEntry {
        self.map_entries
    }
    ///Gets the raw value of [`Self::data`]
    pub fn data_raw(&self) -> *const c_void {
        self.data
    }
    ///Sets the raw value of [`Self::map_entries`]
    pub fn set_map_entries_raw(&mut self, value: *const SpecializationMapEntry) -> &mut Self {
        self.map_entries = value;
        self
    }
    ///Sets the raw value of [`Self::data`]
    pub fn set_data_raw(&mut self, value: *const c_void) -> &mut Self {
        self.data = value;
        self
    }
    ///Gets the value of [`Self::map_entry_count`]
    pub fn map_entry_count(&self) -> u32 {
        self.map_entry_count
    }
    ///Gets the value of [`Self::map_entries`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn map_entries(&self) -> &[SpecializationMapEntry] {
        std::slice::from_raw_parts(self.map_entries, self.map_entry_count as usize)
    }
    ///Gets the value of [`Self::data_size`]
    pub fn data_size(&self) -> usize {
        self.data_size
    }
    ///Gets the value of [`Self::data`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn data(&self) -> &[c_void] {
        std::slice::from_raw_parts(self.data, self.data_size as usize)
    }
    ///Gets a mutable reference to the value of [`Self::map_entry_count`]
    pub fn map_entry_count_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::data_size`]
    pub fn data_size_mut(&mut self) -> &mut usize {
        &mut getter
    }
    ///Sets the raw value of [`Self::map_entry_count`]
    pub fn set_map_entry_count(&mut self, value: u32) -> &mut Self {
        self.map_entry_count = value;
        self
    }
    ///Sets the raw value of [`Self::map_entries`]
    pub fn set_map_entries(&mut self, value: &'lt [crate::vulkan1_0::SpecializationMapEntry]) -> &mut Self {
        let len_ = value.len() as u32;
        let len_ = len_;
        self.map_entries = value.as_ptr();
        self.map_entry_count = len_;
        self
    }
    ///Sets the raw value of [`Self::data_size`]
    pub fn set_data_size(&mut self, value: usize) -> &mut Self {
        self.data_size = value;
        self
    }
    ///Sets the raw value of [`Self::data`]
    pub fn set_data(&mut self, value: &'lt [std::ffi::c_void]) -> &mut Self {
        let len_ = value.len() as u32;
        let len_ = len_;
        self.data = value.as_ptr();
        self.data_size = len_;
        self
    }
}
///[VkPipelineShaderStageCreateInfo](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineShaderStageCreateInfo.html) - Structure specifying parameters of a newly created pipeline shader stage
///# C Specifications
///The [`PipelineShaderStageCreateInfo`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkPipelineShaderStageCreateInfo {
///    VkStructureType                     sType;
///    const void*                         pNext;
///    VkPipelineShaderStageCreateFlags    flags;
///    VkShaderStageFlagBits               stage;
///    VkShaderModule                      module;
///    const char*                         pName;
///    const VkSpecializationInfo*         pSpecializationInfo;
///} VkPipelineShaderStageCreateInfo;
///```
///# Members
/// - [`s_type`] is the type of this structure.
/// - [`p_next`] is `NULL` or a pointer to a structure extending this structure.
/// - [`flags`] is a bitmask of [`PipelineShaderStageCreateFlagBits`] specifying how the pipeline
///   shader stage will be generated.
/// - [`stage`] is a [`ShaderStageFlagBits`] value specifying a single pipeline stage.
/// - [`module`] is a [`ShaderModule`] object containing the shader for this stage.
/// - [`name`] is a pointer to a null-terminated UTF-8 string specifying the entry point name of the
///   shader for this stage.
/// - [`specialization_info`] is a pointer to a [`SpecializationInfo`] structure, as described in [Specialization Constants](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipelines-specialization-constants), or `NULL`.
///# Description
///## Valid Usage
/// - If the [geometry shaders](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-geometryShader)
///   feature is not enabled, [`stage`] **must**  not be `VK_SHADER_STAGE_GEOMETRY_BIT`
/// - If the [tessellation shaders](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-tessellationShader)
///   feature is not enabled, [`stage`] **must**  not be `VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT`
///   or `VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT`
/// - If the [mesh shader](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-meshShader)
///   feature is not enabled, [`stage`] **must**  not be `VK_SHADER_STAGE_MESH_BIT_NV`
/// - If the [task shader](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-taskShader)
///   feature is not enabled, [`stage`] **must**  not be `VK_SHADER_STAGE_TASK_BIT_NV`
/// - [`stage`] **must**  not be `VK_SHADER_STAGE_ALL_GRAPHICS`, or `VK_SHADER_STAGE_ALL`
/// - [`name`] **must**  be the name of an `OpEntryPoint` in [`module`] with an execution model that
///   matches [`stage`]
/// - If the identified entry point includes any variable in its interface that is declared with the
///   `ClipDistance``BuiltIn` decoration, that variable  **must**  not have an array size greater
///   than [`PhysicalDeviceLimits::max_clip_distances`]
/// - If the identified entry point includes any variable in its interface that is declared with the
///   `CullDistance``BuiltIn` decoration, that variable  **must**  not have an array size greater
///   than [`PhysicalDeviceLimits::max_cull_distances`]
/// - If the identified entry point includes any variables in its interface that are declared with
///   the `ClipDistance` or `CullDistance``BuiltIn` decoration, those variables  **must**  not have
///   array sizes which sum to more than
///   [`PhysicalDeviceLimits::max_combined_clip_and_cull_distances`]
/// - If the identified entry point includes any variable in its interface that is declared with the
///   [`SampleMask`]`BuiltIn` decoration, that variable  **must**  not have an array size greater
///   than [`PhysicalDeviceLimits::max_sample_mask_words`]
/// - If [`stage`] is `VK_SHADER_STAGE_VERTEX_BIT`, the identified entry point  **must**  not
///   include any input variable in its interface that is decorated with `CullDistance`
/// - If [`stage`] is `VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT` or
///   `VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT`, and the identified entry point has an
///   `OpExecutionMode` instruction specifying a patch size with `OutputVertices`, the patch size
///   **must**  be greater than `0` and less than or equal to
///   [`PhysicalDeviceLimits::max_tessellation_patch_size`]
/// - If [`stage`] is `VK_SHADER_STAGE_GEOMETRY_BIT`, the identified entry point  **must**  have an
///   `OpExecutionMode` instruction specifying a maximum output vertex count that is greater than
///   `0` and less than or equal to [`PhysicalDeviceLimits::max_geometry_output_vertices`]
/// - If [`stage`] is `VK_SHADER_STAGE_GEOMETRY_BIT`, the identified entry point  **must**  have an
///   `OpExecutionMode` instruction specifying an invocation count that is greater than `0` and less
///   than or equal to [`PhysicalDeviceLimits::max_geometry_shader_invocations`]
/// - If [`stage`] is a [pre-rasterization shader stage](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-pre-rasterization),
///   and the identified entry point writes to `Layer` for any primitive, it  **must**  write the
///   same value to `Layer` for all vertices of a given primitive
/// - If [`stage`] is a [pre-rasterization shader stage](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-pre-rasterization),
///   and the identified entry point writes to `ViewportIndex` for any primitive, it  **must**
///   write the same value to `ViewportIndex` for all vertices of a given primitive
/// - If [`stage`] is `VK_SHADER_STAGE_FRAGMENT_BIT`, the identified entry point  **must**  not
///   include any output variables in its interface decorated with `CullDistance`
/// - If [`stage`] is `VK_SHADER_STAGE_FRAGMENT_BIT`, and the identified entry point writes to
///   `FragDepth` in any execution path, it  **must**  write to `FragDepth` in all execution paths
/// - If [`stage`] is `VK_SHADER_STAGE_FRAGMENT_BIT`, and the identified entry point writes to
///   `FragStencilRefEXT` in any execution path, it  **must**  write to `FragStencilRefEXT` in all
///   execution paths
/// - If [`stage`] is `VK_SHADER_STAGE_MESH_BIT_NV`, the identified entry point  **must**  have an
///   `OpExecutionMode` instruction specifying a maximum output vertex count, `OutputVertices`, that
///   is greater than `0` and less than or equal to
///   [`PhysicalDeviceMeshShaderPropertiesNV::max_mesh_output_vertices`]
/// - If [`stage`] is `VK_SHADER_STAGE_MESH_BIT_NV`, the identified entry point  **must**  have an
///   `OpExecutionMode` instruction specifying a maximum output primitive count,
///   `OutputPrimitivesNV`, that is greater than `0` and less than or equal to
///   [`PhysicalDeviceMeshShaderPropertiesNV::max_mesh_output_primitives`]
/// -    If [`flags`] has the `VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT` flag set, the [`subgroupSizeControl`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-subgroupSizeControl) feature  **must**  be enabled
/// -    If [`flags`] has the `VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT` flag set, the [`computeFullSubgroups`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-computeFullSubgroups) feature  **must**  be enabled
/// - If a [`PipelineShaderStageRequiredSubgroupSizeCreateInfo`] structure is included in the
///   [`p_next`] chain, [`flags`] **must**  not have the
///   `VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT` flag set
/// -    If a [`PipelineShaderStageRequiredSubgroupSizeCreateInfo`] structure is included in the [`p_next`] chain, the [`subgroupSizeControl`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-subgroupSizeControl) feature  **must**  be enabled, and [`stage`] **must**  be a valid bit specified in [`requiredSubgroupSizeStages`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#limits-requiredSubgroupSizeStages)
/// -    If a [`PipelineShaderStageRequiredSubgroupSizeCreateInfo`] structure is included in the [`p_next`] chain and [`stage`] is `VK_SHADER_STAGE_COMPUTE_BIT`, the local workgroup size of the shader  **must**  be less than or equal to the product of [`PipelineShaderStageRequiredSubgroupSizeCreateInfo::required_subgroup_size`] and [`maxComputeWorkgroupSubgroups`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#limits-maxComputeWorkgroupSubgroups)
/// - If a [`PipelineShaderStageRequiredSubgroupSizeCreateInfo`] structure is included in the
///   [`p_next`] chain, and [`flags`] has the
///   `VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT` flag set, the local workgroup
///   size in the X dimension of the pipeline  **must**  be a multiple of
///   [`PipelineShaderStageRequiredSubgroupSizeCreateInfo::required_subgroup_size`]
/// -    If [`flags`] has both the `VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT` and `VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT` flags set, the local workgroup size in the X dimension of the pipeline  **must**  be a multiple of [`maxSubgroupSize`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#limits-maxSubgroupSize)
/// - If [`flags`] has the `VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT` flag set and
///   [`flags`] does not have the `VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT` flag
///   set and no [`PipelineShaderStageRequiredSubgroupSizeCreateInfo`] structure is included in the [`p_next`]
///   chain, the local workgroup size in the X dimension of the pipeline  **must**  be a multiple of
///   [`subgroupSize`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#limits-subgroup-size)
/// -    The SPIR-V code that was used to create [`module`] **must**  be valid as described by the [Khronos SPIR-V Specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#spirv-spec) after applying the specializations provided in [`specialization_info`], if any, and then converting all specialization constants into fixed constants
///
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be `VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO`
/// - [`p_next`] **must**  be `NULL` or a pointer to a valid instance of
///   [`PipelineShaderStageRequiredSubgroupSizeCreateInfo`]
/// - The [`s_type`] value of each struct in the [`p_next`] chain  **must**  be unique
/// - [`flags`] **must**  be a valid combination of [`PipelineShaderStageCreateFlagBits`] values
/// - [`stage`] **must**  be a valid [`ShaderStageFlagBits`] value
/// - [`module`] **must**  be a valid [`ShaderModule`] handle
/// - [`name`] **must**  be a null-terminated UTF-8 string
/// - If [`specialization_info`] is not `NULL`, [`specialization_info`] **must**  be a valid pointer
///   to a valid [`SpecializationInfo`] structure
///# Related
/// - [`crate::vulkan1_0`]
/// - [`ComputePipelineCreateInfo`]
/// - [`GraphicsPipelineCreateInfo`]
/// - [`GraphicsShaderGroupCreateInfoNV`]
/// - [`PipelineShaderStageCreateFlags`]
/// - [`RayTracingPipelineCreateInfoKHR`]
/// - [`RayTracingPipelineCreateInfoNV`]
/// - [`ShaderModule`]
/// - [`ShaderStageFlagBits`]
/// - [`SpecializationInfo`]
/// - [`StructureType`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[repr(C)]
pub struct PipelineShaderStageCreateInfo<'lt> {
    _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] is the type of this structure.
    s_type: StructureType,
    ///[`p_next`] is `NULL` or a pointer to a structure extending this
    ///structure.
    p_next: *const BaseInStructure<'lt>,
    ///[`flags`] is a bitmask of [`PipelineShaderStageCreateFlagBits`]
    ///specifying how the pipeline shader stage will be generated.
    flags: PipelineShaderStageCreateFlags,
    ///[`stage`] is a [`ShaderStageFlagBits`] value specifying a single
    ///pipeline stage.
    stage: ShaderStageFlagBits,
    ///[`module`] is a [`ShaderModule`] object containing the shader for
    ///this stage.
    module: ShaderModule,
    ///[`name`] is a pointer to a null-terminated UTF-8 string specifying
    ///the entry point name of the shader for this stage.
    name: &'lt CStr,
    ///[`specialization_info`] is a pointer to a [`SpecializationInfo`]
    ///structure, as described in
    ///[Specialization Constants](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipelines-specialization-constants), or
    ///`NULL`.
    specialization_info: *const SpecializationInfo<'lt>,
}
impl<'lt> Default for PipelineShaderStageCreateInfo<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: Default::default(),
            p_next: std::ptr::null(),
            flags: Default::default(),
            stage: Default::default(),
            module: Default::default(),
            name: std::ptr::null(),
            specialization_info: std::ptr::null(),
        }
    }
}
impl<'lt> PipelineShaderStageCreateInfo<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *const BaseInStructure<'lt> {
        self.p_next
    }
    ///Gets the raw value of [`Self::specialization_info`]
    pub fn specialization_info_raw(&self) -> *const SpecializationInfo<'lt> {
        self.specialization_info
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *const BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::specialization_info`]
    pub fn set_specialization_info_raw(&mut self, value: *const SpecializationInfo<'lt>) -> &mut Self {
        self.specialization_info = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseInStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::flags`]
    pub fn flags(&self) -> PipelineShaderStageCreateFlags {
        self.flags
    }
    ///Gets the value of [`Self::stage`]
    pub fn stage(&self) -> ShaderStageFlagBits {
        self.stage
    }
    ///Gets the value of [`Self::module`]
    pub fn module(&self) -> ShaderModule {
        self.module
    }
    ///Gets the value of [`Self::name`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn name(&self) -> &'lt CStr {
        self.name
    }
    ///Gets the value of [`Self::specialization_info`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn specialization_info(&self) -> &SpecializationInfo<'lt> {
        &*self.specialization_info
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::flags`]
    pub fn flags_mut(&mut self) -> &mut PipelineShaderStageCreateFlags {
        &mut self.flags
    }
    ///Gets a mutable reference to the value of [`Self::stage`]
    pub fn stage_mut(&mut self) -> &mut ShaderStageFlagBits {
        &mut self.stage
    }
    ///Gets a mutable reference to the value of [`Self::module`]
    pub fn module_mut(&mut self) -> &mut ShaderModule {
        &mut self.module
    }
    ///Sets the raw value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the raw value of [`Self::flags`]
    pub fn set_flags(&mut self, value: crate::vulkan1_0::PipelineShaderStageCreateFlags) -> &mut Self {
        self.flags = value;
        self
    }
    ///Sets the raw value of [`Self::stage`]
    pub fn set_stage(&mut self, value: crate::vulkan1_0::ShaderStageFlagBits) -> &mut Self {
        self.stage = value;
        self
    }
    ///Sets the raw value of [`Self::module`]
    pub fn set_module(&mut self, value: crate::vulkan1_0::ShaderModule) -> &mut Self {
        self.module = value;
        self
    }
    ///Sets the raw value of [`Self::name`]
    pub fn set_name(&mut self, value: &'lt std::ffi::CStr) -> &mut Self {
        self.name = value;
        self
    }
    ///Sets the raw value of [`Self::specialization_info`]
    pub fn set_specialization_info(&mut self, value: &'lt crate::vulkan1_0::SpecializationInfo<'lt>) -> &mut Self {
        self.specialization_info = value as *const _;
        self
    }
}
///[VkComputePipelineCreateInfo](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkComputePipelineCreateInfo.html) - Structure specifying parameters of a newly created compute pipeline
///# C Specifications
///The [`ComputePipelineCreateInfo`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkComputePipelineCreateInfo {
///    VkStructureType                    sType;
///    const void*                        pNext;
///    VkPipelineCreateFlags              flags;
///    VkPipelineShaderStageCreateInfo    stage;
///    VkPipelineLayout                   layout;
///    VkPipeline                         basePipelineHandle;
///    int32_t                            basePipelineIndex;
///} VkComputePipelineCreateInfo;
///```
///# Members
/// - [`s_type`] is the type of this structure.
/// - [`p_next`] is `NULL` or a pointer to a structure extending this structure.
/// - [`flags`] is a bitmask of [`PipelineCreateFlagBits`] specifying how the pipeline will be
///   generated.
/// - [`stage`] is a [`PipelineShaderStageCreateInfo`] structure describing the compute shader.
/// - [`layout`] is the description of binding locations used by both the pipeline and descriptor
///   sets used with the pipeline.
/// - [`base_pipeline_handle`] is a pipeline to derive from
/// - [`base_pipeline_index`] is an index into the `pCreateInfos` parameter to use as a pipeline to
///   derive from
///# Description
///The parameters [`base_pipeline_handle`] and [`base_pipeline_index`] are
///described in more detail in [Pipeline
///Derivatives](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipelines-pipeline-derivatives).
///## Valid Usage
/// - If [`flags`] contains the `VK_PIPELINE_CREATE_DERIVATIVE_BIT` flag, and
///   [`base_pipeline_index`] is -1, [`base_pipeline_handle`] **must**  be a valid handle to a
///   compute [`Pipeline`]
/// - If [`flags`] contains the `VK_PIPELINE_CREATE_DERIVATIVE_BIT` flag, and
///   [`base_pipeline_handle`] is [`crate::utils::Handle::null`], [`base_pipeline_index`] **must**
///   be a valid index into the calling command’s `pCreateInfos` parameter
/// - If [`flags`] contains the `VK_PIPELINE_CREATE_DERIVATIVE_BIT` flag, and
///   [`base_pipeline_index`] is not -1, [`base_pipeline_handle`] **must**  be
///   [`crate::utils::Handle::null`]
/// - If [`flags`] contains the `VK_PIPELINE_CREATE_DERIVATIVE_BIT` flag, and
///   [`base_pipeline_handle`] is not [`crate::utils::Handle::null`], [`base_pipeline_index`]
///   **must**  be -1
/// - The [`stage`] member of [`stage`] **must**  be `VK_SHADER_STAGE_COMPUTE_BIT`
/// -    The shader code for the entry point identified by [`stage`] and the rest of the state identified by this structure  **must**  adhere to the pipeline linking rules described in the [Shader Interfaces](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#interfaces) chapter
/// - [`layout`] **must**  be [consistent](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-pipelinelayout-consistency)
///   with the layout of the compute shader specified in [`stage`]
/// - The number of resources in [`layout`] accessible to the compute shader stage  **must**  be
///   less than or equal to [`PhysicalDeviceLimits::max_per_stage_resources`]
/// - [`flags`] **must**  not include `VK_PIPELINE_CREATE_LIBRARY_BIT_KHR`
/// - [`flags`] **must**  not include
///   `VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR`
/// - [`flags`] **must**  not include
///   `VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR`
/// - [`flags`] **must**  not include `VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR`
/// - [`flags`] **must**  not include
///   `VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR`
/// - [`flags`] **must**  not include `VK_PIPELINE_CREATE_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR`
/// - [`flags`] **must**  not include `VK_PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR`
/// - [`flags`] **must**  not include
///   `VK_PIPELINE_CREATE_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR`
/// - [`flags`] **must**  not include `VK_PIPELINE_CREATE_RAY_TRACING_ALLOW_MOTION_BIT_NV`
/// - [`flags`] **must**  not include `VK_PIPELINE_CREATE_INDIRECT_BINDABLE_BIT_NV`
/// - If the [`pipelineCreationCacheControl`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-pipelineCreationCacheControl)
///   feature is not enabled, [`flags`] **must**  not include
///   `VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT` or
///   `VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT`
///
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be `VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO`
/// - Each [`p_next`] member of any structure (including this one) in the [`p_next`] chain  **must**
///   be either `NULL` or a pointer to a valid instance of [`PipelineCompilerControlCreateInfoAMD`],
///   [`PipelineCreationFeedbackCreateInfo`], or [`SubpassShadingPipelineCreateInfoHUAWEI`]
/// - The [`s_type`] value of each struct in the [`p_next`] chain  **must**  be unique
/// - [`flags`] **must**  be a valid combination of [`PipelineCreateFlagBits`] values
/// - [`stage`] **must**  be a valid [`PipelineShaderStageCreateInfo`] structure
/// - [`layout`] **must**  be a valid [`PipelineLayout`] handle
/// - Both of [`base_pipeline_handle`], and [`layout`] that are valid handles of non-ignored
///   parameters  **must**  have been created, allocated, or retrieved from the same [`Device`]
///# Related
/// - [`crate::vulkan1_0`]
/// - [`Pipeline`]
/// - [`PipelineCreateFlags`]
/// - [`PipelineLayout`]
/// - [`PipelineShaderStageCreateInfo`]
/// - [`StructureType`]
/// - [`CreateComputePipelines`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[repr(C)]
pub struct ComputePipelineCreateInfo<'lt> {
    _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] is the type of this structure.
    s_type: StructureType,
    ///[`p_next`] is `NULL` or a pointer to a structure extending this
    ///structure.
    p_next: *const BaseInStructure<'lt>,
    ///[`flags`] is a bitmask of [`PipelineCreateFlagBits`] specifying
    ///how the pipeline will be generated.
    flags: PipelineCreateFlags,
    ///[`stage`] is a [`PipelineShaderStageCreateInfo`] structure
    ///describing the compute shader.
    stage: PipelineShaderStageCreateInfo<'lt>,
    ///[`layout`] is the description of binding locations used by both the
    ///pipeline and descriptor sets used with the pipeline.
    layout: PipelineLayout,
    ///[`base_pipeline_handle`] is a pipeline to derive from
    base_pipeline_handle: Pipeline,
    ///[`base_pipeline_index`] is an index into the `pCreateInfos`
    ///parameter to use as a pipeline to derive from
    base_pipeline_index: i32,
}
impl<'lt> Default for ComputePipelineCreateInfo<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: Default::default(),
            p_next: std::ptr::null(),
            flags: Default::default(),
            stage: Default::default(),
            layout: Default::default(),
            base_pipeline_handle: Default::default(),
            base_pipeline_index: 0,
        }
    }
}
impl<'lt> ComputePipelineCreateInfo<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *const BaseInStructure<'lt> {
        self.p_next
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *const BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseInStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::flags`]
    pub fn flags(&self) -> PipelineCreateFlags {
        self.flags
    }
    ///Gets the value of [`Self::stage`]
    pub fn stage(&self) -> PipelineShaderStageCreateInfo<'lt> {
        self.stage
    }
    ///Gets the value of [`Self::layout`]
    pub fn layout(&self) -> PipelineLayout {
        self.layout
    }
    ///Gets the value of [`Self::base_pipeline_handle`]
    pub fn base_pipeline_handle(&self) -> Pipeline {
        self.base_pipeline_handle
    }
    ///Gets the value of [`Self::base_pipeline_index`]
    pub fn base_pipeline_index(&self) -> i32 {
        self.base_pipeline_index
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::flags`]
    pub fn flags_mut(&mut self) -> &mut PipelineCreateFlags {
        &mut self.flags
    }
    ///Gets a mutable reference to the value of [`Self::stage`]
    pub fn stage_mut(&mut self) -> &mut PipelineShaderStageCreateInfo<'lt> {
        &mut self.stage
    }
    ///Gets a mutable reference to the value of [`Self::layout`]
    pub fn layout_mut(&mut self) -> &mut PipelineLayout {
        &mut self.layout
    }
    ///Gets a mutable reference to the value of [`Self::base_pipeline_handle`]
    pub fn base_pipeline_handle_mut(&mut self) -> &mut Pipeline {
        &mut self.base_pipeline_handle
    }
    ///Gets a mutable reference to the value of [`Self::base_pipeline_index`]
    pub fn base_pipeline_index_mut(&mut self) -> &mut i32 {
        &mut getter
    }
    ///Sets the raw value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the raw value of [`Self::flags`]
    pub fn set_flags(&mut self, value: crate::vulkan1_0::PipelineCreateFlags) -> &mut Self {
        self.flags = value;
        self
    }
    ///Sets the raw value of [`Self::stage`]
    pub fn set_stage(&mut self, value: crate::vulkan1_0::PipelineShaderStageCreateInfo<'lt>) -> &mut Self {
        self.stage = value;
        self
    }
    ///Sets the raw value of [`Self::layout`]
    pub fn set_layout(&mut self, value: crate::vulkan1_0::PipelineLayout) -> &mut Self {
        self.layout = value;
        self
    }
    ///Sets the raw value of [`Self::base_pipeline_handle`]
    pub fn set_base_pipeline_handle(&mut self, value: crate::vulkan1_0::Pipeline) -> &mut Self {
        self.base_pipeline_handle = value;
        self
    }
    ///Sets the raw value of [`Self::base_pipeline_index`]
    pub fn set_base_pipeline_index(&mut self, value: i32) -> &mut Self {
        self.base_pipeline_index = value;
        self
    }
}
///[VkVertexInputBindingDescription](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVertexInputBindingDescription.html) - Structure specifying vertex input binding description
///# C Specifications
///Each vertex input binding is specified by the
///[`VertexInputBindingDescription`] structure, defined as:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkVertexInputBindingDescription {
///    uint32_t             binding;
///    uint32_t             stride;
///    VkVertexInputRate    inputRate;
///} VkVertexInputBindingDescription;
///```
///# Members
/// - [`binding`] is the binding number that this structure describes.
/// - [`stride`] is the byte stride between consecutive elements within the buffer.
/// - [`input_rate`] is a [`VertexInputRate`] value specifying whether vertex attribute addressing
///   is a function of the vertex index or of the instance index.
///# Description
///## Valid Usage
/// - [`binding`] **must**  be less than [`PhysicalDeviceLimits::max_vertex_input_bindings`]
/// - [`stride`] **must**  be less than or equal to
///   [`PhysicalDeviceLimits::max_vertex_input_binding_stride`]
/// - If the `[`VK_KHR_portability_subset`]` extension is enabled, [`stride`] **must**  be a
///   multiple of, and at least as large as,
///   [`PhysicalDevicePortabilitySubsetPropertiesKHR::min_vertex_input_binding_stride_alignment`]
///
///## Valid Usage (Implicit)
/// - [`input_rate`] **must**  be a valid [`VertexInputRate`] value
///# Related
/// - [`crate::vulkan1_0`]
/// - [`PipelineVertexInputStateCreateInfo`]
/// - [`VertexInputRate`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct VertexInputBindingDescription {
    ///[`binding`] is the binding number that this structure describes.
    binding: u32,
    ///[`stride`] is the byte stride between consecutive elements within the
    ///buffer.
    stride: u32,
    ///[`input_rate`] is a [`VertexInputRate`] value specifying whether
    ///vertex attribute addressing is a function of the vertex index or of the
    ///instance index.
    input_rate: VertexInputRate,
}
impl Default for VertexInputBindingDescription {
    fn default() -> Self {
        Self {
            binding: 0,
            stride: 0,
            input_rate: Default::default(),
        }
    }
}
impl VertexInputBindingDescription {
    ///Gets the value of [`Self::binding`]
    pub fn binding(&self) -> u32 {
        self.binding
    }
    ///Gets the value of [`Self::stride`]
    pub fn stride(&self) -> u32 {
        self.stride
    }
    ///Gets the value of [`Self::input_rate`]
    pub fn input_rate(&self) -> VertexInputRate {
        self.input_rate
    }
    ///Gets a mutable reference to the value of [`Self::binding`]
    pub fn binding_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::stride`]
    pub fn stride_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::input_rate`]
    pub fn input_rate_mut(&mut self) -> &mut VertexInputRate {
        &mut self.input_rate
    }
    ///Sets the raw value of [`Self::binding`]
    pub fn set_binding(&mut self, value: u32) -> &mut Self {
        self.binding = value;
        self
    }
    ///Sets the raw value of [`Self::stride`]
    pub fn set_stride(&mut self, value: u32) -> &mut Self {
        self.stride = value;
        self
    }
    ///Sets the raw value of [`Self::input_rate`]
    pub fn set_input_rate(&mut self, value: crate::vulkan1_0::VertexInputRate) -> &mut Self {
        self.input_rate = value;
        self
    }
}
///[VkVertexInputAttributeDescription](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVertexInputAttributeDescription.html) - Structure specifying vertex input attribute description
///# C Specifications
///Each vertex input attribute is specified by the
///[`VertexInputAttributeDescription`] structure, defined as:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkVertexInputAttributeDescription {
///    uint32_t    location;
///    uint32_t    binding;
///    VkFormat    format;
///    uint32_t    offset;
///} VkVertexInputAttributeDescription;
///```
///# Members
/// - [`location`] is the shader input location number for this attribute.
/// - [`binding`] is the binding number which this attribute takes its data from.
/// - [`format`] is the size and type of the vertex attribute data.
/// - [`offset`] is a byte offset of this attribute relative to the start of an element in the
///   vertex input binding.
///# Description
///## Valid Usage
/// - [`location`] **must**  be less than [`PhysicalDeviceLimits::max_vertex_input_attributes`]
/// - [`binding`] **must**  be less than [`PhysicalDeviceLimits::max_vertex_input_bindings`]
/// - [`offset`] **must**  be less than or equal to
///   [`PhysicalDeviceLimits::max_vertex_input_attribute_offset`]
/// - [`format`] **must**  be allowed as a vertex buffer format, as specified by the
///   `VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT` flag in [`FormatProperties::buffer_features`] returned
///   by [`GetPhysicalDeviceFormatProperties`]
/// - If the `[`VK_KHR_portability_subset`]` extension is enabled, and
///   [`PhysicalDevicePortabilitySubsetFeaturesKHR::vertex_attribute_access_beyond_stride`] is
///   [`FALSE`], the sum of [`offset`] plus the size of the vertex attribute data described by
///   [`format`] **must**  not be greater than `stride` in the [`VertexInputBindingDescription`]
///   referenced in [`binding`]
///
///## Valid Usage (Implicit)
/// - [`format`] **must**  be a valid [`Format`] value
///# Related
/// - [`crate::vulkan1_0`]
/// - [`Format`]
/// - [`PipelineVertexInputStateCreateInfo`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct VertexInputAttributeDescription {
    ///[`location`] is the shader input location number for this attribute.
    location: u32,
    ///[`binding`] is the binding number which this attribute takes its data
    ///from.
    binding: u32,
    ///[`format`] is the size and type of the vertex attribute data.
    format: Format,
    ///[`offset`] is a byte offset of this attribute relative to the start of
    ///an element in the vertex input binding.
    offset: u32,
}
impl Default for VertexInputAttributeDescription {
    fn default() -> Self {
        Self {
            location: 0,
            binding: 0,
            format: Default::default(),
            offset: 0,
        }
    }
}
impl VertexInputAttributeDescription {
    ///Gets the value of [`Self::location`]
    pub fn location(&self) -> u32 {
        self.location
    }
    ///Gets the value of [`Self::binding`]
    pub fn binding(&self) -> u32 {
        self.binding
    }
    ///Gets the value of [`Self::format`]
    pub fn format(&self) -> Format {
        self.format
    }
    ///Gets the value of [`Self::offset`]
    pub fn offset(&self) -> u32 {
        self.offset
    }
    ///Gets a mutable reference to the value of [`Self::location`]
    pub fn location_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::binding`]
    pub fn binding_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::format`]
    pub fn format_mut(&mut self) -> &mut Format {
        &mut self.format
    }
    ///Gets a mutable reference to the value of [`Self::offset`]
    pub fn offset_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Sets the raw value of [`Self::location`]
    pub fn set_location(&mut self, value: u32) -> &mut Self {
        self.location = value;
        self
    }
    ///Sets the raw value of [`Self::binding`]
    pub fn set_binding(&mut self, value: u32) -> &mut Self {
        self.binding = value;
        self
    }
    ///Sets the raw value of [`Self::format`]
    pub fn set_format(&mut self, value: crate::vulkan1_0::Format) -> &mut Self {
        self.format = value;
        self
    }
    ///Sets the raw value of [`Self::offset`]
    pub fn set_offset(&mut self, value: u32) -> &mut Self {
        self.offset = value;
        self
    }
}
///[VkPipelineVertexInputStateCreateInfo](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineVertexInputStateCreateInfo.html) - Structure specifying parameters of a newly created pipeline vertex input state
///# C Specifications
///The [`PipelineVertexInputStateCreateInfo`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkPipelineVertexInputStateCreateInfo {
///    VkStructureType                             sType;
///    const void*                                 pNext;
///    VkPipelineVertexInputStateCreateFlags       flags;
///    uint32_t                                    vertexBindingDescriptionCount;
///    const VkVertexInputBindingDescription*      pVertexBindingDescriptions;
///    uint32_t                                    vertexAttributeDescriptionCount;
///    const VkVertexInputAttributeDescription*    pVertexAttributeDescriptions;
///} VkPipelineVertexInputStateCreateInfo;
///```
///# Members
/// - [`s_type`] is the type of this structure.
/// - [`p_next`] is `NULL` or a pointer to a structure extending this structure.
/// - [`flags`] is reserved for future use.
/// - [`vertex_binding_description_count`] is the number of vertex binding descriptions provided in
///   [`vertex_binding_descriptions`].
/// - [`vertex_binding_descriptions`] is a pointer to an array of [`VertexInputBindingDescription`]
///   structures.
/// - [`vertex_attribute_description_count`] is the number of vertex attribute descriptions provided
///   in [`vertex_attribute_descriptions`].
/// - [`vertex_attribute_descriptions`] is a pointer to an array of
///   [`VertexInputAttributeDescription`] structures.
///# Description
///## Valid Usage
/// - [`vertex_binding_description_count`] **must**  be less than or equal to
///   [`PhysicalDeviceLimits::max_vertex_input_bindings`]
/// - [`vertex_attribute_description_count`] **must**  be less than or equal to
///   [`PhysicalDeviceLimits::max_vertex_input_attributes`]
/// - For every `binding` specified by each element of [`vertex_attribute_descriptions`], a
///   [`VertexInputBindingDescription`] **must**  exist in [`vertex_binding_descriptions`] with the
///   same value of `binding`
/// - All elements of [`vertex_binding_descriptions`] **must**  describe distinct binding numbers
/// - All elements of [`vertex_attribute_descriptions`] **must**  describe distinct attribute
///   locations
///
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be `VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO`
/// - [`p_next`] **must**  be `NULL` or a pointer to a valid instance of
///   [`PipelineVertexInputDivisorStateCreateInfoEXT`]
/// - The [`s_type`] value of each struct in the [`p_next`] chain  **must**  be unique
/// - [`flags`] **must**  be `0`
/// - If [`vertex_binding_description_count`] is not `0`, [`vertex_binding_descriptions`] **must**
///   be a valid pointer to an array of [`vertex_binding_description_count`] valid
///   [`VertexInputBindingDescription`] structures
/// - If [`vertex_attribute_description_count`] is not `0`, [`vertex_attribute_descriptions`]
///   **must**  be a valid pointer to an array of [`vertex_attribute_description_count`] valid
///   [`VertexInputAttributeDescription`] structures
///# Related
/// - [`crate::vulkan1_0`]
/// - [`GraphicsPipelineCreateInfo`]
/// - [`GraphicsShaderGroupCreateInfoNV`]
/// - [`PipelineVertexInputStateCreateFlags`]
/// - [`StructureType`]
/// - [`VertexInputAttributeDescription`]
/// - [`VertexInputBindingDescription`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[repr(C)]
pub struct PipelineVertexInputStateCreateInfo<'lt> {
    _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] is the type of this structure.
    s_type: StructureType,
    ///[`p_next`] is `NULL` or a pointer to a structure extending this
    ///structure.
    p_next: *const BaseInStructure<'lt>,
    ///[`flags`] is reserved for future use.
    flags: PipelineVertexInputStateCreateFlags,
    ///[`vertex_binding_description_count`] is the number of vertex binding
    ///descriptions provided in [`vertex_binding_descriptions`].
    vertex_binding_description_count: u32,
    ///[`vertex_binding_descriptions`] is a pointer to an array of
    ///[`VertexInputBindingDescription`] structures.
    vertex_binding_descriptions: *const VertexInputBindingDescription,
    ///[`vertex_attribute_description_count`] is the number of vertex attribute
    ///descriptions provided in [`vertex_attribute_descriptions`].
    vertex_attribute_description_count: u32,
    ///[`vertex_attribute_descriptions`] is a pointer to an array of
    ///[`VertexInputAttributeDescription`] structures.
    vertex_attribute_descriptions: *const VertexInputAttributeDescription,
}
impl<'lt> Default for PipelineVertexInputStateCreateInfo<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: Default::default(),
            p_next: std::ptr::null(),
            flags: Default::default(),
            vertex_binding_description_count: 0,
            vertex_binding_descriptions: std::ptr::null(),
            vertex_attribute_description_count: 0,
            vertex_attribute_descriptions: std::ptr::null(),
        }
    }
}
impl<'lt> PipelineVertexInputStateCreateInfo<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *const BaseInStructure<'lt> {
        self.p_next
    }
    ///Gets the raw value of [`Self::vertex_binding_descriptions`]
    pub fn vertex_binding_descriptions_raw(&self) -> *const VertexInputBindingDescription {
        self.vertex_binding_descriptions
    }
    ///Gets the raw value of [`Self::vertex_attribute_descriptions`]
    pub fn vertex_attribute_descriptions_raw(&self) -> *const VertexInputAttributeDescription {
        self.vertex_attribute_descriptions
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *const BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::vertex_binding_descriptions`]
    pub fn set_vertex_binding_descriptions_raw(&mut self, value: *const VertexInputBindingDescription) -> &mut Self {
        self.vertex_binding_descriptions = value;
        self
    }
    ///Sets the raw value of [`Self::vertex_attribute_descriptions`]
    pub fn set_vertex_attribute_descriptions_raw(
        &mut self,
        value: *const VertexInputAttributeDescription,
    ) -> &mut Self {
        self.vertex_attribute_descriptions = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseInStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::flags`]
    pub fn flags(&self) -> PipelineVertexInputStateCreateFlags {
        self.flags
    }
    ///Gets the value of [`Self::vertex_binding_description_count`]
    pub fn vertex_binding_description_count(&self) -> u32 {
        self.vertex_binding_description_count
    }
    ///Gets the value of [`Self::vertex_binding_descriptions`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn vertex_binding_descriptions(&self) -> &[VertexInputBindingDescription] {
        std::slice::from_raw_parts(
            self.vertex_binding_descriptions,
            self.vertex_binding_description_count as usize,
        )
    }
    ///Gets the value of [`Self::vertex_attribute_description_count`]
    pub fn vertex_attribute_description_count(&self) -> u32 {
        self.vertex_attribute_description_count
    }
    ///Gets the value of [`Self::vertex_attribute_descriptions`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn vertex_attribute_descriptions(&self) -> &[VertexInputAttributeDescription] {
        std::slice::from_raw_parts(
            self.vertex_attribute_descriptions,
            self.vertex_attribute_description_count as usize,
        )
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::flags`]
    pub fn flags_mut(&mut self) -> &mut PipelineVertexInputStateCreateFlags {
        &mut self.flags
    }
    ///Gets a mutable reference to the value of [`Self::vertex_binding_description_count`]
    pub fn vertex_binding_description_count_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::vertex_attribute_description_count`]
    pub fn vertex_attribute_description_count_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Sets the raw value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the raw value of [`Self::flags`]
    pub fn set_flags(&mut self, value: crate::vulkan1_0::PipelineVertexInputStateCreateFlags) -> &mut Self {
        self.flags = value;
        self
    }
    ///Sets the raw value of [`Self::vertex_binding_description_count`]
    pub fn set_vertex_binding_description_count(&mut self, value: u32) -> &mut Self {
        self.vertex_binding_description_count = value;
        self
    }
    ///Sets the raw value of [`Self::vertex_binding_descriptions`]
    pub fn set_vertex_binding_descriptions(
        &mut self,
        value: &'lt [crate::vulkan1_0::VertexInputBindingDescription],
    ) -> &mut Self {
        let len_ = value.len() as u32;
        let len_ = len_;
        self.vertex_binding_descriptions = value.as_ptr();
        self.vertex_binding_description_count = len_;
        self
    }
    ///Sets the raw value of [`Self::vertex_attribute_description_count`]
    pub fn set_vertex_attribute_description_count(&mut self, value: u32) -> &mut Self {
        self.vertex_attribute_description_count = value;
        self
    }
    ///Sets the raw value of [`Self::vertex_attribute_descriptions`]
    pub fn set_vertex_attribute_descriptions(
        &mut self,
        value: &'lt [crate::vulkan1_0::VertexInputAttributeDescription],
    ) -> &mut Self {
        let len_ = value.len() as u32;
        let len_ = len_;
        self.vertex_attribute_descriptions = value.as_ptr();
        self.vertex_attribute_description_count = len_;
        self
    }
}
///[VkPipelineInputAssemblyStateCreateInfo](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineInputAssemblyStateCreateInfo.html) - Structure specifying parameters of a newly created pipeline input assembly state
///# C Specifications
///Drawing can be achieved in two modes:
/// - [Programmable Mesh Shading](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#drawing-mesh-shading),
///   the mesh shader assembles primitives, or
/// - [Programmable Primitive Shading](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#drawing-primitive-shading),
///   the input primitives are assembled
///as follows.Each draw is made up of zero or more vertices and zero or more instances,
///which are processed by the device and result in the assembly of primitives.
///Primitives are assembled according to the `pInputAssemblyState` member
///of the [`GraphicsPipelineCreateInfo`] structure, which is of type
///[`PipelineInputAssemblyStateCreateInfo`]:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkPipelineInputAssemblyStateCreateInfo {
///    VkStructureType                            sType;
///    const void*                                pNext;
///    VkPipelineInputAssemblyStateCreateFlags    flags;
///    VkPrimitiveTopology                        topology;
///    VkBool32                                   primitiveRestartEnable;
///} VkPipelineInputAssemblyStateCreateInfo;
///```
///# Members
/// - [`s_type`] is the type of this structure.
/// - [`p_next`] is `NULL` or a pointer to a structure extending this structure.
/// - [`flags`] is reserved for future use.
/// - [`topology`] is a [`PrimitiveTopology`] defining the primitive topology, as described below.
/// - [`primitive_restart_enable`] controls whether a special vertex index value is treated as restarting the assembly of primitives. This enable only applies to indexed draws ([`CmdDrawIndexed`], [`CmdDrawMultiIndexedEXT`], and [`CmdDrawIndexedIndirect`]), and the special index value is either 0xFFFFFFFF when the `indexType` parameter of [`CmdBindIndexBuffer`] is equal to `VK_INDEX_TYPE_UINT32`, 0xFF when `indexType` is equal to `VK_INDEX_TYPE_UINT8_EXT`, or 0xFFFF when `indexType` is equal to `VK_INDEX_TYPE_UINT16`. Primitive restart is not allowed for “list” topologies, unless one of the features [`primitiveTopologyPatchListRestart`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-primitiveTopologyPatchListRestart) (for `VK_PRIMITIVE_TOPOLOGY_PATCH_LIST`) or [`primitiveTopologyListRestart`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-primitiveTopologyListRestart) (for all other list topologies) is enabled.
///# Description
///Restarting the assembly of primitives discards the most recent index values
///if those elements formed an incomplete primitive, and restarts the primitive
///assembly using the subsequent indices, but only assembling the immediately
///following element through the end of the originally specified elements.
///The primitive restart index value comparison is performed before adding the
///`vertexOffset` value to the index value.
///## Valid Usage
/// -    If [`topology`] is `VK_PRIMITIVE_TOPOLOGY_POINT_LIST`, `VK_PRIMITIVE_TOPOLOGY_LINE_LIST`, `VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST`, `VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY` or `VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY`, and [`primitive_restart_enable`] is [`TRUE`], the [`primitiveTopologyListRestart`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-primitiveTopologyListRestart) feature  **must**  be enabled
/// -    If [`topology`] is `VK_PRIMITIVE_TOPOLOGY_PATCH_LIST`, and [`primitive_restart_enable`] is [`TRUE`], the [`primitiveTopologyPatchListRestart`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-primitiveTopologyPatchListRestart) feature  **must**  be enabled
/// - If the [geometry shaders](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-geometryShader)
///   feature is not enabled, [`topology`] **must**  not be any of
///   `VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY`,
///   `VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY`,
///   `VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY` or
///   `VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY`
/// - If the [tessellation shaders](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-tessellationShader)
///   feature is not enabled, [`topology`] **must**  not be `VK_PRIMITIVE_TOPOLOGY_PATCH_LIST`
/// - If the `[`VK_KHR_portability_subset`]` extension is enabled, and
///   [`PhysicalDevicePortabilitySubsetFeaturesKHR::triangle_fans`] is [`FALSE`], [`topology`]
///   **must**  not be `VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN`
///
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be `VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO`
/// - [`p_next`] **must**  be `NULL`
/// - [`flags`] **must**  be `0`
/// - [`topology`] **must**  be a valid [`PrimitiveTopology`] value
///# Related
/// - [`crate::vulkan1_0`]
/// - [`Bool32`]
/// - [`GraphicsPipelineCreateInfo`]
/// - [`PipelineInputAssemblyStateCreateFlags`]
/// - [`PrimitiveTopology`]
/// - [`StructureType`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[repr(C)]
pub struct PipelineInputAssemblyStateCreateInfo<'lt> {
    _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] is the type of this structure.
    s_type: StructureType,
    ///[`p_next`] is `NULL` or a pointer to a structure extending this
    ///structure.
    p_next: *const BaseInStructure<'lt>,
    ///[`flags`] is reserved for future use.
    flags: PipelineInputAssemblyStateCreateFlags,
    ///[`topology`] is a [`PrimitiveTopology`] defining the primitive
    ///topology, as described below.
    topology: PrimitiveTopology,
    ///[`primitive_restart_enable`] controls whether a special vertex index
    ///value is treated as restarting the assembly of primitives.
    ///This enable only applies to indexed draws ([`CmdDrawIndexed`],
    ///[`CmdDrawMultiIndexedEXT`],
    ///and [`CmdDrawIndexedIndirect`]), and the special index value is
    ///either 0xFFFFFFFF when the `indexType` parameter of
    ///[`CmdBindIndexBuffer`] is equal to `VK_INDEX_TYPE_UINT32`,
    ///0xFF when `indexType` is equal to `VK_INDEX_TYPE_UINT8_EXT`,
    ///or 0xFFFF when `indexType` is equal to `VK_INDEX_TYPE_UINT16`.
    ///Primitive restart is not allowed for “list” topologies, unless one of
    ///the features
    ///[`primitiveTopologyPatchListRestart`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-primitiveTopologyPatchListRestart)
    ///(for `VK_PRIMITIVE_TOPOLOGY_PATCH_LIST`) or
    ///[`primitiveTopologyListRestart`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-primitiveTopologyListRestart)
    ///(for all other list topologies) is enabled.
    primitive_restart_enable: Bool32,
}
impl<'lt> Default for PipelineInputAssemblyStateCreateInfo<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: Default::default(),
            p_next: std::ptr::null(),
            flags: Default::default(),
            topology: Default::default(),
            primitive_restart_enable: 0,
        }
    }
}
impl<'lt> PipelineInputAssemblyStateCreateInfo<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *const BaseInStructure<'lt> {
        self.p_next
    }
    ///Gets the raw value of [`Self::primitive_restart_enable`]
    pub fn primitive_restart_enable_raw(&self) -> Bool32 {
        self.primitive_restart_enable
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *const BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::primitive_restart_enable`]
    pub fn set_primitive_restart_enable_raw(&mut self, value: Bool32) -> &mut Self {
        self.primitive_restart_enable = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseInStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::flags`]
    pub fn flags(&self) -> PipelineInputAssemblyStateCreateFlags {
        self.flags
    }
    ///Gets the value of [`Self::topology`]
    pub fn topology(&self) -> PrimitiveTopology {
        self.topology
    }
    ///Gets the value of [`Self::primitive_restart_enable`]
    pub fn primitive_restart_enable(&self) -> bool {
        unsafe { std::mem::transmute(self.primitive_restart_enable as u8) }
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::flags`]
    pub fn flags_mut(&mut self) -> &mut PipelineInputAssemblyStateCreateFlags {
        &mut self.flags
    }
    ///Gets a mutable reference to the value of [`Self::topology`]
    pub fn topology_mut(&mut self) -> &mut PrimitiveTopology {
        &mut self.topology
    }
    ///Gets a mutable reference to the value of [`Self::primitive_restart_enable`]
    pub fn primitive_restart_enable_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.primitive_restart_enable as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.primitive_restart_enable as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Sets the raw value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the raw value of [`Self::flags`]
    pub fn set_flags(&mut self, value: crate::vulkan1_0::PipelineInputAssemblyStateCreateFlags) -> &mut Self {
        self.flags = value;
        self
    }
    ///Sets the raw value of [`Self::topology`]
    pub fn set_topology(&mut self, value: crate::vulkan1_0::PrimitiveTopology) -> &mut Self {
        self.topology = value;
        self
    }
    ///Sets the raw value of [`Self::primitive_restart_enable`]
    pub fn set_primitive_restart_enable(&mut self, value: bool) -> &mut Self {
        self.primitive_restart_enable = value as u8 as u32;
        self
    }
}
///[VkPipelineTessellationStateCreateInfo](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineTessellationStateCreateInfo.html) - Structure specifying parameters of a newly created pipeline tessellation state
///# C Specifications
///The [`PipelineTessellationStateCreateInfo`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkPipelineTessellationStateCreateInfo {
///    VkStructureType                           sType;
///    const void*                               pNext;
///    VkPipelineTessellationStateCreateFlags    flags;
///    uint32_t                                  patchControlPoints;
///} VkPipelineTessellationStateCreateInfo;
///```
///# Members
/// - [`s_type`] is the type of this structure.
/// - [`p_next`] is `NULL` or a pointer to a structure extending this structure.
/// - [`flags`] is reserved for future use.
/// - [`patch_control_points`] is the number of control points per patch.
///# Description
///## Valid Usage
/// - [`patch_control_points`] **must**  be greater than zero and less than or equal to
///   [`PhysicalDeviceLimits::max_tessellation_patch_size`]
///
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be `VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO`
/// - [`p_next`] **must**  be `NULL` or a pointer to a valid instance of
///   [`PipelineTessellationDomainOriginStateCreateInfo`]
/// - The [`s_type`] value of each struct in the [`p_next`] chain  **must**  be unique
/// - [`flags`] **must**  be `0`
///# Related
/// - [`crate::vulkan1_0`]
/// - [`GraphicsPipelineCreateInfo`]
/// - [`GraphicsShaderGroupCreateInfoNV`]
/// - [`PipelineTessellationStateCreateFlags`]
/// - [`StructureType`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[repr(C)]
pub struct PipelineTessellationStateCreateInfo<'lt> {
    _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] is the type of this structure.
    s_type: StructureType,
    ///[`p_next`] is `NULL` or a pointer to a structure extending this
    ///structure.
    p_next: *const BaseInStructure<'lt>,
    ///[`flags`] is reserved for future use.
    flags: PipelineTessellationStateCreateFlags,
    ///[`patch_control_points`] is the number of control points per patch.
    patch_control_points: u32,
}
impl<'lt> Default for PipelineTessellationStateCreateInfo<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: Default::default(),
            p_next: std::ptr::null(),
            flags: Default::default(),
            patch_control_points: 0,
        }
    }
}
impl<'lt> PipelineTessellationStateCreateInfo<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *const BaseInStructure<'lt> {
        self.p_next
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *const BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseInStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::flags`]
    pub fn flags(&self) -> PipelineTessellationStateCreateFlags {
        self.flags
    }
    ///Gets the value of [`Self::patch_control_points`]
    pub fn patch_control_points(&self) -> u32 {
        self.patch_control_points
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::flags`]
    pub fn flags_mut(&mut self) -> &mut PipelineTessellationStateCreateFlags {
        &mut self.flags
    }
    ///Gets a mutable reference to the value of [`Self::patch_control_points`]
    pub fn patch_control_points_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Sets the raw value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the raw value of [`Self::flags`]
    pub fn set_flags(&mut self, value: crate::vulkan1_0::PipelineTessellationStateCreateFlags) -> &mut Self {
        self.flags = value;
        self
    }
    ///Sets the raw value of [`Self::patch_control_points`]
    pub fn set_patch_control_points(&mut self, value: u32) -> &mut Self {
        self.patch_control_points = value;
        self
    }
}
///[VkPipelineViewportStateCreateInfo](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineViewportStateCreateInfo.html) - Structure specifying parameters of a newly created pipeline viewport state
///# C Specifications
///The [`PipelineViewportStateCreateInfo`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkPipelineViewportStateCreateInfo {
///    VkStructureType                       sType;
///    const void*                           pNext;
///    VkPipelineViewportStateCreateFlags    flags;
///    uint32_t                              viewportCount;
///    const VkViewport*                     pViewports;
///    uint32_t                              scissorCount;
///    const VkRect2D*                       pScissors;
///} VkPipelineViewportStateCreateInfo;
///```
///# Members
/// - [`s_type`] is the type of this structure.
/// - [`p_next`] is `NULL` or a pointer to a structure extending this structure.
/// - [`flags`] is reserved for future use.
/// - [`viewport_count`] is the number of viewports used by the pipeline.
/// - [`viewports`] is a pointer to an array of [`Viewport`] structures, defining the viewport
///   transforms. If the viewport state is dynamic, this member is ignored.
/// - [`scissor_count`] is the number of [scissors](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fragops-scissor)
///   and  **must**  match the number of viewports.
/// - [`scissors`] is a pointer to an array of [`Rect2D`] structures defining the rectangular bounds
///   of the scissor for the corresponding viewport. If the scissor state is dynamic, this member is
///   ignored.
///# Description
///## Valid Usage
/// - If the [multiple viewports](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-multiViewport)
///   feature is not enabled, [`viewport_count`] **must**  not be greater than `1`
/// - If the [multiple viewports](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-multiViewport)
///   feature is not enabled, [`scissor_count`] **must**  not be greater than `1`
/// - [`viewport_count`] **must**  be less than or equal to [`PhysicalDeviceLimits::max_viewports`]
/// - [`scissor_count`] **must**  be less than or equal to [`PhysicalDeviceLimits::max_viewports`]
/// - The `x` and `y` members of `offset` member of any element of [`scissors`] **must**  be greater
///   than or equal to `0`
/// - Evaluation of (`offset.x` +  `extent.width`) **must**  not cause a signed integer addition
///   overflow for any element of [`scissors`]
/// - Evaluation of (`offset.y` +  `extent.height`) **must**  not cause a signed integer addition
///   overflow for any element of [`scissors`]
/// - If the graphics pipeline is being created without `VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT` and
///   `VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT` set then [`scissor_count`] and [`viewport_count`]
///   **must**  be identical
/// - If the graphics pipeline is being created with `VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT` set then
///   [`viewport_count`] **must**  be `0`, otherwise it  **must**  be greater than `0`
/// - If the graphics pipeline is being created with `VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT` set then
///   [`scissor_count`] **must**  be `0`, otherwise it  **must**  be greater than `0`
/// - If the `viewportWScalingEnable` member of a [`PipelineViewportWScalingStateCreateInfoNV`]
///   structure included in the [`p_next`] chain is [`TRUE`], the [`viewport_count`] member of the
///   [`PipelineViewportWScalingStateCreateInfoNV`] structure  **must**  be greater than or equal to
///   [`PipelineViewportStateCreateInfo`]::[`viewport_count`]
///
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be `VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO`
/// - Each [`p_next`] member of any structure (including this one) in the [`p_next`] chain  **must**
///   be either `NULL` or a pointer to a valid instance of
///   [`PipelineViewportCoarseSampleOrderStateCreateInfoNV`],
///   [`PipelineViewportDepthClipControlCreateInfoEXT`],
///   [`PipelineViewportExclusiveScissorStateCreateInfoNV`],
///   [`PipelineViewportShadingRateImageStateCreateInfoNV`],
///   [`PipelineViewportSwizzleStateCreateInfoNV`], or [`PipelineViewportWScalingStateCreateInfoNV`]
/// - The [`s_type`] value of each struct in the [`p_next`] chain  **must**  be unique
/// - [`flags`] **must**  be `0`
///# Related
/// - [`crate::vulkan1_0`]
/// - [`GraphicsPipelineCreateInfo`]
/// - [`PipelineViewportStateCreateFlags`]
/// - [`Rect2D`]
/// - [`StructureType`]
/// - [`Viewport`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[repr(C)]
pub struct PipelineViewportStateCreateInfo<'lt> {
    _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] is the type of this structure.
    s_type: StructureType,
    ///[`p_next`] is `NULL` or a pointer to a structure extending this
    ///structure.
    p_next: *const BaseInStructure<'lt>,
    ///[`flags`] is reserved for future use.
    flags: PipelineViewportStateCreateFlags,
    ///[`viewport_count`] is the number of viewports used by the pipeline.
    viewport_count: u32,
    ///[`viewports`] is a pointer to an array of [`Viewport`]
    ///structures, defining the viewport transforms.
    ///If the viewport state is dynamic, this member is ignored.
    viewports: *const Viewport,
    ///[`scissor_count`] is the number of [scissors](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fragops-scissor) and
    /// **must**  match the number of viewports.
    scissor_count: u32,
    ///[`scissors`] is a pointer to an array of [`Rect2D`] structures
    ///defining the rectangular bounds of the scissor for the corresponding
    ///viewport.
    ///If the scissor state is dynamic, this member is ignored.
    scissors: *const Rect2D,
}
impl<'lt> Default for PipelineViewportStateCreateInfo<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: Default::default(),
            p_next: std::ptr::null(),
            flags: Default::default(),
            viewport_count: 0,
            viewports: std::ptr::null(),
            scissor_count: 0,
            scissors: std::ptr::null(),
        }
    }
}
impl<'lt> PipelineViewportStateCreateInfo<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *const BaseInStructure<'lt> {
        self.p_next
    }
    ///Gets the raw value of [`Self::viewports`]
    pub fn viewports_raw(&self) -> *const Viewport {
        self.viewports
    }
    ///Gets the raw value of [`Self::scissors`]
    pub fn scissors_raw(&self) -> *const Rect2D {
        self.scissors
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *const BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::viewports`]
    pub fn set_viewports_raw(&mut self, value: *const Viewport) -> &mut Self {
        self.viewports = value;
        self
    }
    ///Sets the raw value of [`Self::scissors`]
    pub fn set_scissors_raw(&mut self, value: *const Rect2D) -> &mut Self {
        self.scissors = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseInStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::flags`]
    pub fn flags(&self) -> PipelineViewportStateCreateFlags {
        self.flags
    }
    ///Gets the value of [`Self::viewport_count`]
    pub fn viewport_count(&self) -> u32 {
        self.viewport_count
    }
    ///Gets the value of [`Self::viewports`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn viewports(&self) -> &[Viewport] {
        std::slice::from_raw_parts(self.viewports, self.viewport_count as usize)
    }
    ///Gets the value of [`Self::scissor_count`]
    pub fn scissor_count(&self) -> u32 {
        self.scissor_count
    }
    ///Gets the value of [`Self::scissors`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn scissors(&self) -> &[Rect2D] {
        std::slice::from_raw_parts(self.scissors, self.scissor_count as usize)
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::flags`]
    pub fn flags_mut(&mut self) -> &mut PipelineViewportStateCreateFlags {
        &mut self.flags
    }
    ///Gets a mutable reference to the value of [`Self::viewport_count`]
    pub fn viewport_count_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::scissor_count`]
    pub fn scissor_count_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Sets the raw value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the raw value of [`Self::flags`]
    pub fn set_flags(&mut self, value: crate::vulkan1_0::PipelineViewportStateCreateFlags) -> &mut Self {
        self.flags = value;
        self
    }
    ///Sets the raw value of [`Self::viewport_count`]
    pub fn set_viewport_count(&mut self, value: u32) -> &mut Self {
        self.viewport_count = value;
        self
    }
    ///Sets the raw value of [`Self::viewports`]
    pub fn set_viewports(&mut self, value: &'lt [crate::vulkan1_0::Viewport]) -> &mut Self {
        let len_ = value.len() as u32;
        let len_ = len_;
        self.viewports = value.as_ptr();
        self.viewport_count = len_;
        self
    }
    ///Sets the raw value of [`Self::scissor_count`]
    pub fn set_scissor_count(&mut self, value: u32) -> &mut Self {
        self.scissor_count = value;
        self
    }
    ///Sets the raw value of [`Self::scissors`]
    pub fn set_scissors(&mut self, value: &'lt [crate::vulkan1_0::Rect2D]) -> &mut Self {
        let len_ = value.len() as u32;
        let len_ = len_;
        self.scissors = value.as_ptr();
        self.scissor_count = len_;
        self
    }
}
///[VkPipelineRasterizationStateCreateInfo](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineRasterizationStateCreateInfo.html) - Structure specifying parameters of a newly created pipeline rasterization state
///# C Specifications
///The [`PipelineRasterizationStateCreateInfo`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkPipelineRasterizationStateCreateInfo {
///    VkStructureType                            sType;
///    const void*                                pNext;
///    VkPipelineRasterizationStateCreateFlags    flags;
///    VkBool32                                   depthClampEnable;
///    VkBool32                                   rasterizerDiscardEnable;
///    VkPolygonMode                              polygonMode;
///    VkCullModeFlags                            cullMode;
///    VkFrontFace                                frontFace;
///    VkBool32                                   depthBiasEnable;
///    float                                      depthBiasConstantFactor;
///    float                                      depthBiasClamp;
///    float                                      depthBiasSlopeFactor;
///    float                                      lineWidth;
///} VkPipelineRasterizationStateCreateInfo;
///```
///# Members
/// - [`s_type`] is the type of this structure.
/// - [`p_next`] is `NULL` or a pointer to a structure extending this structure.
/// - [`flags`] is reserved for future use.
/// - [`depth_clamp_enable`] controls whether to clamp the fragment’s depth values as described in [Depth Test](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fragops-depth). If the pipeline is not created with [`PipelineRasterizationDepthClipStateCreateInfoEXT`] present then enabling depth clamp will also disable clipping primitives to the z planes of the frustrum as described in [Primitive Clipping](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#vertexpostproc-clipping). Otherwise depth clipping is controlled by the state set in [`PipelineRasterizationDepthClipStateCreateInfoEXT`].
/// - [`rasterizer_discard_enable`] controls whether primitives are discarded immediately before the
///   rasterization stage.
/// - [`polygon_mode`] is the triangle rendering mode. See [`PolygonMode`].
/// - [`cull_mode`] is the triangle facing direction used for primitive culling. See
///   [`CullModeFlagBits`].
/// - [`front_face`] is a [`FrontFace`] value specifying the front-facing triangle orientation to be
///   used for culling.
/// - [`depth_bias_enable`] controls whether to bias fragment depth values.
/// - [`depth_bias_constant_factor`] is a scalar factor controlling the constant depth value added
///   to each fragment.
/// - [`depth_bias_clamp`] is the maximum (or minimum) depth bias of a fragment.
/// - [`depth_bias_slope_factor`] is a scalar factor applied to a fragment’s slope in depth bias
///   calculations.
/// - [`line_width`] is the width of rasterized line segments.
///# Description
///The application  **can**  also add a
///[`PipelineRasterizationStateRasterizationOrderAMD`] structure to the
///[`p_next`] chain of a [`PipelineRasterizationStateCreateInfo`]
///structure.
///This structure enables selecting the rasterization order to use when
///rendering with the corresponding graphics pipeline as described in
///[Rasterization Order](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#primsrast-order).
///## Valid Usage
/// - If the [depth clamping](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-depthClamp)
///   feature is not enabled, [`depth_clamp_enable`] **must**  be [`FALSE`]
/// - If the [non-solid fill modes](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-fillModeNonSolid)
///   feature is not enabled, [`polygon_mode`] **must**  be `VK_POLYGON_MODE_FILL` or
///   `VK_POLYGON_MODE_FILL_RECTANGLE_NV`
/// - If the `[`VK_NV_fill_rectangle`]` extension is not enabled, [`polygon_mode`] **must**  not be
///   `VK_POLYGON_MODE_FILL_RECTANGLE_NV`
/// - If the `[`VK_KHR_portability_subset`]` extension is enabled, and
///   [`PhysicalDevicePortabilitySubsetFeaturesKHR::point_polygons`] is [`FALSE`], and
///   [`rasterizer_discard_enable`] is [`FALSE`], [`polygon_mode`] **must**  not be
///   `VK_POLYGON_MODE_POINT`
///
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be `VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO`
/// - Each [`p_next`] member of any structure (including this one) in the [`p_next`] chain  **must**
///   be either `NULL` or a pointer to a valid instance of
///   [`PipelineRasterizationConservativeStateCreateInfoEXT`],
///   [`PipelineRasterizationDepthClipStateCreateInfoEXT`],
///   [`PipelineRasterizationLineStateCreateInfoEXT`],
///   [`PipelineRasterizationProvokingVertexStateCreateInfoEXT`],
///   [`PipelineRasterizationStateRasterizationOrderAMD`], or
///   [`PipelineRasterizationStateStreamCreateInfoEXT`]
/// - The [`s_type`] value of each struct in the [`p_next`] chain  **must**  be unique
/// - [`flags`] **must**  be `0`
/// - [`polygon_mode`] **must**  be a valid [`PolygonMode`] value
/// - [`cull_mode`] **must**  be a valid combination of [`CullModeFlagBits`] values
/// - [`front_face`] **must**  be a valid [`FrontFace`] value
///# Related
/// - [`crate::vulkan1_0`]
/// - [`Bool32`]
/// - [`CullModeFlags`]
/// - [`FrontFace`]
/// - [`GraphicsPipelineCreateInfo`]
/// - [`PipelineRasterizationStateCreateFlags`]
/// - [`PolygonMode`]
/// - [`StructureType`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, PartialEq, PartialOrd)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[repr(C)]
pub struct PipelineRasterizationStateCreateInfo<'lt> {
    _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] is the type of this structure.
    s_type: StructureType,
    ///[`p_next`] is `NULL` or a pointer to a structure extending this
    ///structure.
    p_next: *const BaseInStructure<'lt>,
    ///[`flags`] is reserved for future use.
    flags: PipelineRasterizationStateCreateFlags,
    ///[`depth_clamp_enable`] controls whether to clamp the fragment’s depth
    ///values as described in [Depth Test](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fragops-depth).
    ///If the pipeline is not created with
    ///[`PipelineRasterizationDepthClipStateCreateInfoEXT`] present then
    ///enabling depth clamp will also disable clipping primitives to the z
    ///planes of the frustrum as described in [Primitive Clipping](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#vertexpostproc-clipping).
    ///Otherwise depth clipping is controlled by the state set in
    ///[`PipelineRasterizationDepthClipStateCreateInfoEXT`].
    depth_clamp_enable: Bool32,
    ///[`rasterizer_discard_enable`] controls whether primitives are discarded
    ///immediately before the rasterization stage.
    rasterizer_discard_enable: Bool32,
    ///[`polygon_mode`] is the triangle rendering mode.
    ///See [`PolygonMode`].
    polygon_mode: PolygonMode,
    ///[`cull_mode`] is the triangle facing direction used for primitive
    ///culling.
    ///See [`CullModeFlagBits`].
    cull_mode: CullModeFlags,
    ///[`front_face`] is a [`FrontFace`] value specifying the front-facing
    ///triangle orientation to be used for culling.
    front_face: FrontFace,
    ///[`depth_bias_enable`] controls whether to bias fragment depth values.
    depth_bias_enable: Bool32,
    ///[`depth_bias_constant_factor`] is a scalar factor controlling the
    ///constant depth value added to each fragment.
    depth_bias_constant_factor: f32,
    ///[`depth_bias_clamp`] is the maximum (or minimum) depth bias of a
    ///fragment.
    depth_bias_clamp: f32,
    ///[`depth_bias_slope_factor`] is a scalar factor applied to a fragment’s
    ///slope in depth bias calculations.
    depth_bias_slope_factor: f32,
    ///[`line_width`] is the width of rasterized line segments.
    line_width: f32,
}
impl<'lt> Default for PipelineRasterizationStateCreateInfo<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: Default::default(),
            p_next: std::ptr::null(),
            flags: Default::default(),
            depth_clamp_enable: 0,
            rasterizer_discard_enable: 0,
            polygon_mode: Default::default(),
            cull_mode: Default::default(),
            front_face: Default::default(),
            depth_bias_enable: 0,
            depth_bias_constant_factor: 0.0,
            depth_bias_clamp: 0.0,
            depth_bias_slope_factor: 0.0,
            line_width: 0.0,
        }
    }
}
impl<'lt> PipelineRasterizationStateCreateInfo<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *const BaseInStructure<'lt> {
        self.p_next
    }
    ///Gets the raw value of [`Self::depth_clamp_enable`]
    pub fn depth_clamp_enable_raw(&self) -> Bool32 {
        self.depth_clamp_enable
    }
    ///Gets the raw value of [`Self::rasterizer_discard_enable`]
    pub fn rasterizer_discard_enable_raw(&self) -> Bool32 {
        self.rasterizer_discard_enable
    }
    ///Gets the raw value of [`Self::depth_bias_enable`]
    pub fn depth_bias_enable_raw(&self) -> Bool32 {
        self.depth_bias_enable
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *const BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::depth_clamp_enable`]
    pub fn set_depth_clamp_enable_raw(&mut self, value: Bool32) -> &mut Self {
        self.depth_clamp_enable = value;
        self
    }
    ///Sets the raw value of [`Self::rasterizer_discard_enable`]
    pub fn set_rasterizer_discard_enable_raw(&mut self, value: Bool32) -> &mut Self {
        self.rasterizer_discard_enable = value;
        self
    }
    ///Sets the raw value of [`Self::depth_bias_enable`]
    pub fn set_depth_bias_enable_raw(&mut self, value: Bool32) -> &mut Self {
        self.depth_bias_enable = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseInStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::flags`]
    pub fn flags(&self) -> PipelineRasterizationStateCreateFlags {
        self.flags
    }
    ///Gets the value of [`Self::depth_clamp_enable`]
    pub fn depth_clamp_enable(&self) -> bool {
        unsafe { std::mem::transmute(self.depth_clamp_enable as u8) }
    }
    ///Gets the value of [`Self::rasterizer_discard_enable`]
    pub fn rasterizer_discard_enable(&self) -> bool {
        unsafe { std::mem::transmute(self.rasterizer_discard_enable as u8) }
    }
    ///Gets the value of [`Self::polygon_mode`]
    pub fn polygon_mode(&self) -> PolygonMode {
        self.polygon_mode
    }
    ///Gets the value of [`Self::cull_mode`]
    pub fn cull_mode(&self) -> CullModeFlags {
        self.cull_mode
    }
    ///Gets the value of [`Self::front_face`]
    pub fn front_face(&self) -> FrontFace {
        self.front_face
    }
    ///Gets the value of [`Self::depth_bias_enable`]
    pub fn depth_bias_enable(&self) -> bool {
        unsafe { std::mem::transmute(self.depth_bias_enable as u8) }
    }
    ///Gets the value of [`Self::depth_bias_constant_factor`]
    pub fn depth_bias_constant_factor(&self) -> f32 {
        self.depth_bias_constant_factor
    }
    ///Gets the value of [`Self::depth_bias_clamp`]
    pub fn depth_bias_clamp(&self) -> f32 {
        self.depth_bias_clamp
    }
    ///Gets the value of [`Self::depth_bias_slope_factor`]
    pub fn depth_bias_slope_factor(&self) -> f32 {
        self.depth_bias_slope_factor
    }
    ///Gets the value of [`Self::line_width`]
    pub fn line_width(&self) -> f32 {
        self.line_width
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::flags`]
    pub fn flags_mut(&mut self) -> &mut PipelineRasterizationStateCreateFlags {
        &mut self.flags
    }
    ///Gets a mutable reference to the value of [`Self::depth_clamp_enable`]
    pub fn depth_clamp_enable_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.depth_clamp_enable as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.depth_clamp_enable as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of [`Self::rasterizer_discard_enable`]
    pub fn rasterizer_discard_enable_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.rasterizer_discard_enable as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.rasterizer_discard_enable as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of [`Self::polygon_mode`]
    pub fn polygon_mode_mut(&mut self) -> &mut PolygonMode {
        &mut self.polygon_mode
    }
    ///Gets a mutable reference to the value of [`Self::cull_mode`]
    pub fn cull_mode_mut(&mut self) -> &mut CullModeFlags {
        &mut self.cull_mode
    }
    ///Gets a mutable reference to the value of [`Self::front_face`]
    pub fn front_face_mut(&mut self) -> &mut FrontFace {
        &mut self.front_face
    }
    ///Gets a mutable reference to the value of [`Self::depth_bias_enable`]
    pub fn depth_bias_enable_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.depth_bias_enable as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.depth_bias_enable as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of [`Self::depth_bias_constant_factor`]
    pub fn depth_bias_constant_factor_mut(&mut self) -> &mut f32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::depth_bias_clamp`]
    pub fn depth_bias_clamp_mut(&mut self) -> &mut f32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::depth_bias_slope_factor`]
    pub fn depth_bias_slope_factor_mut(&mut self) -> &mut f32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::line_width`]
    pub fn line_width_mut(&mut self) -> &mut f32 {
        &mut getter
    }
    ///Sets the raw value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the raw value of [`Self::flags`]
    pub fn set_flags(&mut self, value: crate::vulkan1_0::PipelineRasterizationStateCreateFlags) -> &mut Self {
        self.flags = value;
        self
    }
    ///Sets the raw value of [`Self::depth_clamp_enable`]
    pub fn set_depth_clamp_enable(&mut self, value: bool) -> &mut Self {
        self.depth_clamp_enable = value as u8 as u32;
        self
    }
    ///Sets the raw value of [`Self::rasterizer_discard_enable`]
    pub fn set_rasterizer_discard_enable(&mut self, value: bool) -> &mut Self {
        self.rasterizer_discard_enable = value as u8 as u32;
        self
    }
    ///Sets the raw value of [`Self::polygon_mode`]
    pub fn set_polygon_mode(&mut self, value: crate::vulkan1_0::PolygonMode) -> &mut Self {
        self.polygon_mode = value;
        self
    }
    ///Sets the raw value of [`Self::cull_mode`]
    pub fn set_cull_mode(&mut self, value: crate::vulkan1_0::CullModeFlags) -> &mut Self {
        self.cull_mode = value;
        self
    }
    ///Sets the raw value of [`Self::front_face`]
    pub fn set_front_face(&mut self, value: crate::vulkan1_0::FrontFace) -> &mut Self {
        self.front_face = value;
        self
    }
    ///Sets the raw value of [`Self::depth_bias_enable`]
    pub fn set_depth_bias_enable(&mut self, value: bool) -> &mut Self {
        self.depth_bias_enable = value as u8 as u32;
        self
    }
    ///Sets the raw value of [`Self::depth_bias_constant_factor`]
    pub fn set_depth_bias_constant_factor(&mut self, value: f32) -> &mut Self {
        self.depth_bias_constant_factor = value;
        self
    }
    ///Sets the raw value of [`Self::depth_bias_clamp`]
    pub fn set_depth_bias_clamp(&mut self, value: f32) -> &mut Self {
        self.depth_bias_clamp = value;
        self
    }
    ///Sets the raw value of [`Self::depth_bias_slope_factor`]
    pub fn set_depth_bias_slope_factor(&mut self, value: f32) -> &mut Self {
        self.depth_bias_slope_factor = value;
        self
    }
    ///Sets the raw value of [`Self::line_width`]
    pub fn set_line_width(&mut self, value: f32) -> &mut Self {
        self.line_width = value;
        self
    }
}
///[VkPipelineMultisampleStateCreateInfo](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineMultisampleStateCreateInfo.html) - Structure specifying parameters of a newly created pipeline multisample state
///# C Specifications
///The [`PipelineMultisampleStateCreateInfo`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkPipelineMultisampleStateCreateInfo {
///    VkStructureType                          sType;
///    const void*                              pNext;
///    VkPipelineMultisampleStateCreateFlags    flags;
///    VkSampleCountFlagBits                    rasterizationSamples;
///    VkBool32                                 sampleShadingEnable;
///    float                                    minSampleShading;
///    const VkSampleMask*                      pSampleMask;
///    VkBool32                                 alphaToCoverageEnable;
///    VkBool32                                 alphaToOneEnable;
///} VkPipelineMultisampleStateCreateInfo;
///```
///# Members
/// - [`s_type`] is the type of this structure.
/// - [`p_next`] is `NULL` or a pointer to a structure extending this structure.
/// - [`flags`] is reserved for future use.
/// - [`rasterization_samples`] is a [`SampleCountFlagBits`] value specifying the number of samples
///   used in rasterization.
/// - [`sample_shading_enable`] **can**  be used to enable [Sample Shading](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#primsrast-sampleshading).
/// - [`min_sample_shading`] specifies a minimum fraction of sample shading if
///   [`sample_shading_enable`] is set to [`TRUE`].
/// - [`sample_mask`] is a pointer to an array of [`SampleMask`] values used in the [sample mask test](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fragops-samplemask).
/// - [`alpha_to_coverage_enable`] controls whether a temporary coverage value is generated based on
///   the alpha component of the fragment’s first color output as specified in the [Multisample Coverage](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fragops-covg)
///   section.
/// - [`alpha_to_one_enable`] controls whether the alpha component of the fragment’s first color output is replaced with one as described in [Multisample Coverage](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fragops-covg).
///# Description
///Each bit in the sample mask is associated with a unique
///[sample index](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#primsrast-multisampling-coverage-mask) as defined for the
///[coverage mask](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#primsrast-multisampling-coverage-mask).
///Each bit b for mask word w in the sample mask corresponds to
///sample index i, where i = 32 × w +  b.
///[`sample_mask`] has a length equal to ⌈
///[`rasterization_samples`] / 32 ⌉ words.If [`sample_mask`] is `NULL`, it is treated as if the
/// mask has all bits
///set to `1`.
///## Valid Usage
/// - If the [sample rate shading](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-sampleRateShading)
///   feature is not enabled, [`sample_shading_enable`] **must**  be [`FALSE`]
/// - If the [alpha to one](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-alphaToOne)
///   feature is not enabled, [`alpha_to_one_enable`] **must**  be [`FALSE`]
/// - [`min_sample_shading`] **must**  be in the range [0,1]
/// - If the `[`VK_NV_framebuffer_mixed_samples`]` extension is enabled, and if the subpass has any
///   color attachments and [`rasterization_samples`] is greater than the number of color samples,
///   then [`sample_shading_enable`] **must**  be [`FALSE`]
///
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be `VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO`
/// - Each [`p_next`] member of any structure (including this one) in the [`p_next`] chain  **must**
///   be either `NULL` or a pointer to a valid instance of
///   [`PipelineCoverageModulationStateCreateInfoNV`],
///   [`PipelineCoverageReductionStateCreateInfoNV`], [`PipelineCoverageToColorStateCreateInfoNV`],
///   or [`PipelineSampleLocationsStateCreateInfoEXT`]
/// - The [`s_type`] value of each struct in the [`p_next`] chain  **must**  be unique
/// - [`flags`] **must**  be `0`
/// - [`rasterization_samples`] **must**  be a valid [`SampleCountFlagBits`] value
/// - If [`sample_mask`] is not `NULL`, [`sample_mask`] **must**  be a valid pointer to an array of
///   <span class="katex"><span aria-hidden="true" class="katex-html"><span class="base"><span
///   style="height:1.277216em;vertical-align:-0.345em;" class="strut"></span><span
///   class="mopen">⌈</span><span class="mord"><span class="mord"><span class="mopen
///   nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span
///   class="vlist-r"><span class="vlist" style="height:0.9322159999999999em;"><span
///   style="top:-2.6550000000000002em;"><span style="height:3em;" class="pstrut"></span><span
///   class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord
///   mtight">3</span><span class="mord mtight">2</span></span></span></span><span
///   style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span
///   style="border-bottom-width:0.04em;" class="frac-line"></span></span><span
///   style="top:-3.446108em;"><span style="height:3em;" class="pstrut"></span><span class="sizing
///   reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span
///   class="mord mathit mtight">r</span><span class="mord mathit mtight">a</span><span class="mord
///   mathit mtight">s</span><span class="mord mathit mtight">t</span><span class="mord mathit
///   mtight">e</span><span class="mord mathit mtight">r</span><span class="mord mathit
///   mtight">i</span><span class="mord mathit mtight">z</span><span class="mord mathit
///   mtight">a</span><span class="mord mathit mtight">t</span><span class="mord mathit
///   mtight">i</span><span class="mord mathit mtight">o</span><span class="mord mathit
///   mtight">n</span><span class="mord mathit mtight">S</span><span class="mord mathit
///   mtight">a</span><span class="mord mathit mtight">m</span><span class="mord mathit
///   mtight">p</span><span class="mord mathit mtight">l</span><span class="mord mathit
///   mtight">e</span><span class="mord mathit
///   mtight">s</span></span></span></span></span></span><span class="vlist-s">​</span></span><span
///   class="vlist-r"><span class="vlist"
///   style="height:0.345em;"><span></span></span></span></span></span><span class="mclose
///   nulldelimiter"></span></span></span><span
///   class="mclose">⌉</span></span></span></span>[`SampleMask`] values
///# Related
/// - [`crate::vulkan1_0`]
/// - [`Bool32`]
/// - [`GraphicsPipelineCreateInfo`]
/// - [`PipelineMultisampleStateCreateFlags`]
/// - [`SampleCountFlagBits`]
/// - [`SampleMask`]
/// - [`StructureType`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, PartialEq, PartialOrd)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[repr(C)]
pub struct PipelineMultisampleStateCreateInfo<'lt> {
    _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] is the type of this structure.
    s_type: StructureType,
    ///[`p_next`] is `NULL` or a pointer to a structure extending this
    ///structure.
    p_next: *const BaseInStructure<'lt>,
    ///[`flags`] is reserved for future use.
    flags: PipelineMultisampleStateCreateFlags,
    ///[`rasterization_samples`] is a [`SampleCountFlagBits`] value
    ///specifying the number of samples used in rasterization.
    rasterization_samples: SampleCountFlagBits,
    ///[`sample_shading_enable`] **can**  be used to enable
    ///[Sample Shading](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#primsrast-sampleshading).
    sample_shading_enable: Bool32,
    ///[`min_sample_shading`] specifies a minimum fraction of sample shading if
    ///[`sample_shading_enable`] is set to [`TRUE`].
    min_sample_shading: f32,
    ///[`sample_mask`] is a pointer to an array of [`SampleMask`]
    ///values used in the [sample mask test](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fragops-samplemask).
    sample_mask: *const SampleMask,
    ///[`alpha_to_coverage_enable`] controls whether a temporary coverage value
    ///is generated based on the alpha component of the fragment’s first color
    ///output as specified in the [Multisample Coverage](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fragops-covg)
    ///section.
    alpha_to_coverage_enable: Bool32,
    ///[`alpha_to_one_enable`] controls whether the alpha component of the
    ///fragment’s first color output is replaced with one as described in
    ///[Multisample Coverage](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fragops-covg).
    alpha_to_one_enable: Bool32,
}
impl<'lt> Default for PipelineMultisampleStateCreateInfo<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: Default::default(),
            p_next: std::ptr::null(),
            flags: Default::default(),
            rasterization_samples: Default::default(),
            sample_shading_enable: 0,
            min_sample_shading: 0.0,
            sample_mask: std::ptr::null(),
            alpha_to_coverage_enable: 0,
            alpha_to_one_enable: 0,
        }
    }
}
impl<'lt> PipelineMultisampleStateCreateInfo<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *const BaseInStructure<'lt> {
        self.p_next
    }
    ///Gets the raw value of [`Self::sample_shading_enable`]
    pub fn sample_shading_enable_raw(&self) -> Bool32 {
        self.sample_shading_enable
    }
    ///Gets the raw value of [`Self::sample_mask`]
    pub fn sample_mask_raw(&self) -> *const SampleMask {
        self.sample_mask
    }
    ///Gets the raw value of [`Self::alpha_to_coverage_enable`]
    pub fn alpha_to_coverage_enable_raw(&self) -> Bool32 {
        self.alpha_to_coverage_enable
    }
    ///Gets the raw value of [`Self::alpha_to_one_enable`]
    pub fn alpha_to_one_enable_raw(&self) -> Bool32 {
        self.alpha_to_one_enable
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *const BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::sample_shading_enable`]
    pub fn set_sample_shading_enable_raw(&mut self, value: Bool32) -> &mut Self {
        self.sample_shading_enable = value;
        self
    }
    ///Sets the raw value of [`Self::sample_mask`]
    pub fn set_sample_mask_raw(&mut self, value: *const SampleMask) -> &mut Self {
        self.sample_mask = value;
        self
    }
    ///Sets the raw value of [`Self::alpha_to_coverage_enable`]
    pub fn set_alpha_to_coverage_enable_raw(&mut self, value: Bool32) -> &mut Self {
        self.alpha_to_coverage_enable = value;
        self
    }
    ///Sets the raw value of [`Self::alpha_to_one_enable`]
    pub fn set_alpha_to_one_enable_raw(&mut self, value: Bool32) -> &mut Self {
        self.alpha_to_one_enable = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseInStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::flags`]
    pub fn flags(&self) -> PipelineMultisampleStateCreateFlags {
        self.flags
    }
    ///Gets the value of [`Self::rasterization_samples`]
    pub fn rasterization_samples(&self) -> SampleCountFlagBits {
        self.rasterization_samples
    }
    ///Gets the value of [`Self::sample_shading_enable`]
    pub fn sample_shading_enable(&self) -> bool {
        unsafe { std::mem::transmute(self.sample_shading_enable as u8) }
    }
    ///Gets the value of [`Self::min_sample_shading`]
    pub fn min_sample_shading(&self) -> f32 {
        self.min_sample_shading
    }
    ///Gets the value of [`Self::sample_mask`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn sample_mask(&self) -> &[SampleMask] {
        std::slice::from_raw_parts(self.sample_mask, self.rasterization_samples + 31 / 32 as usize)
    }
    ///Gets the value of [`Self::alpha_to_coverage_enable`]
    pub fn alpha_to_coverage_enable(&self) -> bool {
        unsafe { std::mem::transmute(self.alpha_to_coverage_enable as u8) }
    }
    ///Gets the value of [`Self::alpha_to_one_enable`]
    pub fn alpha_to_one_enable(&self) -> bool {
        unsafe { std::mem::transmute(self.alpha_to_one_enable as u8) }
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::flags`]
    pub fn flags_mut(&mut self) -> &mut PipelineMultisampleStateCreateFlags {
        &mut self.flags
    }
    ///Gets a mutable reference to the value of [`Self::rasterization_samples`]
    pub fn rasterization_samples_mut(&mut self) -> &mut SampleCountFlagBits {
        &mut self.rasterization_samples
    }
    ///Gets a mutable reference to the value of [`Self::sample_shading_enable`]
    pub fn sample_shading_enable_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.sample_shading_enable as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.sample_shading_enable as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of [`Self::min_sample_shading`]
    pub fn min_sample_shading_mut(&mut self) -> &mut f32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::alpha_to_coverage_enable`]
    pub fn alpha_to_coverage_enable_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.alpha_to_coverage_enable as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.alpha_to_coverage_enable as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of [`Self::alpha_to_one_enable`]
    pub fn alpha_to_one_enable_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.alpha_to_one_enable as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.alpha_to_one_enable as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Sets the raw value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the raw value of [`Self::flags`]
    pub fn set_flags(&mut self, value: crate::vulkan1_0::PipelineMultisampleStateCreateFlags) -> &mut Self {
        self.flags = value;
        self
    }
    ///Sets the raw value of [`Self::rasterization_samples`]
    pub fn set_rasterization_samples(&mut self, value: crate::vulkan1_0::SampleCountFlagBits) -> &mut Self {
        self.rasterization_samples = value;
        self
    }
    ///Sets the raw value of [`Self::sample_shading_enable`]
    pub fn set_sample_shading_enable(&mut self, value: bool) -> &mut Self {
        self.sample_shading_enable = value as u8 as u32;
        self
    }
    ///Sets the raw value of [`Self::min_sample_shading`]
    pub fn set_min_sample_shading(&mut self, value: f32) -> &mut Self {
        self.min_sample_shading = value;
        self
    }
    ///Sets the raw value of [`Self::sample_mask`]
    pub fn set_sample_mask(&mut self, value: &'lt [crate::vulkan1_0::SampleMask]) -> &mut Self {
        let len_ = value.len() as u32;
        let len_ = len_ / 32 + 31 / 32;
        self.sample_mask = value.as_ptr();
        self.rasterization_samples = len_;
        self
    }
    ///Sets the raw value of [`Self::alpha_to_coverage_enable`]
    pub fn set_alpha_to_coverage_enable(&mut self, value: bool) -> &mut Self {
        self.alpha_to_coverage_enable = value as u8 as u32;
        self
    }
    ///Sets the raw value of [`Self::alpha_to_one_enable`]
    pub fn set_alpha_to_one_enable(&mut self, value: bool) -> &mut Self {
        self.alpha_to_one_enable = value as u8 as u32;
        self
    }
}
///[VkPipelineColorBlendAttachmentState](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineColorBlendAttachmentState.html) - Structure specifying a pipeline color blend attachment state
///# C Specifications
///The [`PipelineColorBlendAttachmentState`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkPipelineColorBlendAttachmentState {
///    VkBool32                 blendEnable;
///    VkBlendFactor            srcColorBlendFactor;
///    VkBlendFactor            dstColorBlendFactor;
///    VkBlendOp                colorBlendOp;
///    VkBlendFactor            srcAlphaBlendFactor;
///    VkBlendFactor            dstAlphaBlendFactor;
///    VkBlendOp                alphaBlendOp;
///    VkColorComponentFlags    colorWriteMask;
///} VkPipelineColorBlendAttachmentState;
///```
///# Members
/// - [`blend_enable`] controls whether blending is enabled for the corresponding color attachment.
///   If blending is not enabled, the source fragment’s color for that attachment is passed through
///   unmodified.
/// - [`src_color_blend_factor`] selects which blend factor is used to determine the source factors
///   (S<sub>r</sub>,S<sub>g</sub>,S<sub>b</sub>).
/// - [`dst_color_blend_factor`] selects which blend factor is used to determine the destination
///   factors (D<sub>r</sub>,D<sub>g</sub>,D<sub>b</sub>).
/// - [`color_blend_op`] selects which blend operation is used to calculate the RGB values to write
///   to the color attachment.
/// - [`src_alpha_blend_factor`] selects which blend factor is used to determine the source factor
///   S<sub>a</sub>.
/// - [`dst_alpha_blend_factor`] selects which blend factor is used to determine the destination
///   factor D<sub>a</sub>.
/// - [`alpha_blend_op`] selects which blend operation is use to calculate the alpha values to write
///   to the color attachment.
/// - [`color_write_mask`] is a bitmask of [`ColorComponentFlagBits`] specifying which of the R, G, B, and/or A components are enabled for writing, as described for the [Color Write Mask](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#framebuffer-color-write-mask).
///# Description
///## Valid Usage
/// - If the [dual source blending](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-dualSrcBlend)
///   feature is not enabled, [`src_color_blend_factor`] **must**  not be
///   `VK_BLEND_FACTOR_SRC1_COLOR`, `VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR`,
///   `VK_BLEND_FACTOR_SRC1_ALPHA`, or `VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA`
/// - If the [dual source blending](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-dualSrcBlend)
///   feature is not enabled, [`dst_color_blend_factor`] **must**  not be
///   `VK_BLEND_FACTOR_SRC1_COLOR`, `VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR`,
///   `VK_BLEND_FACTOR_SRC1_ALPHA`, or `VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA`
/// - If the [dual source blending](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-dualSrcBlend)
///   feature is not enabled, [`src_alpha_blend_factor`] **must**  not be
///   `VK_BLEND_FACTOR_SRC1_COLOR`, `VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR`,
///   `VK_BLEND_FACTOR_SRC1_ALPHA`, or `VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA`
/// - If the [dual source blending](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-dualSrcBlend)
///   feature is not enabled, [`dst_alpha_blend_factor`] **must**  not be
///   `VK_BLEND_FACTOR_SRC1_COLOR`, `VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR`,
///   `VK_BLEND_FACTOR_SRC1_ALPHA`, or `VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA`
/// - If either of [`color_blend_op`] or [`alpha_blend_op`] is an [advanced blend operation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#framebuffer-blend-advanced),
///   then [`color_blend_op`] **must**  equal [`alpha_blend_op`]
/// -    If [`PhysicalDeviceBlendOperationAdvancedPropertiesEXT::advanced_blend_independent_blend`] is [`FALSE`] and [`color_blend_op`] is an [advanced blend operation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#framebuffer-blend-advanced), then [`color_blend_op`] **must**  be the same for all attachments
/// -    If [`PhysicalDeviceBlendOperationAdvancedPropertiesEXT::advanced_blend_independent_blend`] is [`FALSE`] and [`alpha_blend_op`] is an [advanced blend operation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#framebuffer-blend-advanced), then [`alpha_blend_op`] **must**  be the same for all attachments
/// - If [`PhysicalDeviceBlendOperationAdvancedPropertiesEXT::advanced_blend_all_operations`] is
///   [`FALSE`], then [`color_blend_op`] **must**  not be `VK_BLEND_OP_ZERO_EXT`,
///   `VK_BLEND_OP_SRC_EXT`, `VK_BLEND_OP_DST_EXT`, `VK_BLEND_OP_SRC_OVER_EXT`,
///   `VK_BLEND_OP_DST_OVER_EXT`, `VK_BLEND_OP_SRC_IN_EXT`, `VK_BLEND_OP_DST_IN_EXT`,
///   `VK_BLEND_OP_SRC_OUT_EXT`, `VK_BLEND_OP_DST_OUT_EXT`, `VK_BLEND_OP_SRC_ATOP_EXT`,
///   `VK_BLEND_OP_DST_ATOP_EXT`, `VK_BLEND_OP_XOR_EXT`, `VK_BLEND_OP_INVERT_EXT`,
///   `VK_BLEND_OP_INVERT_RGB_EXT`, `VK_BLEND_OP_LINEARDODGE_EXT`, `VK_BLEND_OP_LINEARBURN_EXT`,
///   `VK_BLEND_OP_VIVIDLIGHT_EXT`, `VK_BLEND_OP_LINEARLIGHT_EXT`, `VK_BLEND_OP_PINLIGHT_EXT`,
///   `VK_BLEND_OP_HARDMIX_EXT`, `VK_BLEND_OP_PLUS_EXT`, `VK_BLEND_OP_PLUS_CLAMPED_EXT`,
///   `VK_BLEND_OP_PLUS_CLAMPED_ALPHA_EXT`, `VK_BLEND_OP_PLUS_DARKER_EXT`, `VK_BLEND_OP_MINUS_EXT`,
///   `VK_BLEND_OP_MINUS_CLAMPED_EXT`, `VK_BLEND_OP_CONTRAST_EXT`, `VK_BLEND_OP_INVERT_OVG_EXT`,
///   `VK_BLEND_OP_RED_EXT`, `VK_BLEND_OP_GREEN_EXT`, or `VK_BLEND_OP_BLUE_EXT`
/// - If [`color_blend_op`] or [`alpha_blend_op`] is an [advanced blend operation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#framebuffer-blend-advanced),
///   then `colorAttachmentCount` of the subpass this pipeline is compiled against  **must**  be
///   less than or equal to
///   [`PhysicalDeviceBlendOperationAdvancedPropertiesEXT::advanced_blend_max_color_attachments`]
/// - If the `[`VK_KHR_portability_subset`]` extension is enabled, and
///   [`PhysicalDevicePortabilitySubsetFeaturesKHR::constant_alpha_color_blend_factors`] is
///   [`FALSE`], [`src_color_blend_factor`] **must**  not be `VK_BLEND_FACTOR_CONSTANT_ALPHA` or
///   `VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA`
/// - If the `[`VK_KHR_portability_subset`]` extension is enabled, and
///   [`PhysicalDevicePortabilitySubsetFeaturesKHR::constant_alpha_color_blend_factors`] is
///   [`FALSE`], [`dst_color_blend_factor`] **must**  not be `VK_BLEND_FACTOR_CONSTANT_ALPHA` or
///   `VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA`
///
///## Valid Usage (Implicit)
/// - [`src_color_blend_factor`] **must**  be a valid [`BlendFactor`] value
/// - [`dst_color_blend_factor`] **must**  be a valid [`BlendFactor`] value
/// - [`color_blend_op`] **must**  be a valid [`BlendOp`] value
/// - [`src_alpha_blend_factor`] **must**  be a valid [`BlendFactor`] value
/// - [`dst_alpha_blend_factor`] **must**  be a valid [`BlendFactor`] value
/// - [`alpha_blend_op`] **must**  be a valid [`BlendOp`] value
/// - [`color_write_mask`] **must**  be a valid combination of [`ColorComponentFlagBits`] values
///# Related
/// - [`crate::vulkan1_0`]
/// - [`BlendFactor`]
/// - [`BlendOp`]
/// - [`Bool32`]
/// - [`ColorComponentFlags`]
/// - [`PipelineColorBlendStateCreateInfo`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct PipelineColorBlendAttachmentState {
    ///[`blend_enable`] controls whether blending is enabled for the
    ///corresponding color attachment.
    ///If blending is not enabled, the source fragment’s color for that
    ///attachment is passed through unmodified.
    blend_enable: Bool32,
    ///[`src_color_blend_factor`] selects which blend factor is used to
    ///determine the source factors (S<sub>r</sub>,S<sub>g</sub>,S<sub>b</sub>).
    src_color_blend_factor: BlendFactor,
    ///[`dst_color_blend_factor`] selects which blend factor is used to
    ///determine the destination factors (D<sub>r</sub>,D<sub>g</sub>,D<sub>b</sub>).
    dst_color_blend_factor: BlendFactor,
    ///[`color_blend_op`] selects which blend operation is used to calculate
    ///the RGB values to write to the color attachment.
    color_blend_op: BlendOp,
    ///[`src_alpha_blend_factor`] selects which blend factor is used to
    ///determine the source factor S<sub>a</sub>.
    src_alpha_blend_factor: BlendFactor,
    ///[`dst_alpha_blend_factor`] selects which blend factor is used to
    ///determine the destination factor D<sub>a</sub>.
    dst_alpha_blend_factor: BlendFactor,
    ///[`alpha_blend_op`] selects which blend operation is use to calculate the
    ///alpha values to write to the color attachment.
    alpha_blend_op: BlendOp,
    ///[`color_write_mask`] is a bitmask of [`ColorComponentFlagBits`]
    ///specifying which of the R, G, B, and/or A components are enabled for
    ///writing, as described for the [Color Write
    ///Mask](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#framebuffer-color-write-mask).
    color_write_mask: ColorComponentFlags,
}
impl Default for PipelineColorBlendAttachmentState {
    fn default() -> Self {
        Self {
            blend_enable: 0,
            src_color_blend_factor: Default::default(),
            dst_color_blend_factor: Default::default(),
            color_blend_op: Default::default(),
            src_alpha_blend_factor: Default::default(),
            dst_alpha_blend_factor: Default::default(),
            alpha_blend_op: Default::default(),
            color_write_mask: Default::default(),
        }
    }
}
impl PipelineColorBlendAttachmentState {
    ///Gets the raw value of [`Self::blend_enable`]
    pub fn blend_enable_raw(&self) -> Bool32 {
        self.blend_enable
    }
    ///Sets the raw value of [`Self::blend_enable`]
    pub fn set_blend_enable_raw(&mut self, value: Bool32) -> &mut Self {
        self.blend_enable = value;
        self
    }
    ///Gets the value of [`Self::blend_enable`]
    pub fn blend_enable(&self) -> bool {
        unsafe { std::mem::transmute(self.blend_enable as u8) }
    }
    ///Gets the value of [`Self::src_color_blend_factor`]
    pub fn src_color_blend_factor(&self) -> BlendFactor {
        self.src_color_blend_factor
    }
    ///Gets the value of [`Self::dst_color_blend_factor`]
    pub fn dst_color_blend_factor(&self) -> BlendFactor {
        self.dst_color_blend_factor
    }
    ///Gets the value of [`Self::color_blend_op`]
    pub fn color_blend_op(&self) -> BlendOp {
        self.color_blend_op
    }
    ///Gets the value of [`Self::src_alpha_blend_factor`]
    pub fn src_alpha_blend_factor(&self) -> BlendFactor {
        self.src_alpha_blend_factor
    }
    ///Gets the value of [`Self::dst_alpha_blend_factor`]
    pub fn dst_alpha_blend_factor(&self) -> BlendFactor {
        self.dst_alpha_blend_factor
    }
    ///Gets the value of [`Self::alpha_blend_op`]
    pub fn alpha_blend_op(&self) -> BlendOp {
        self.alpha_blend_op
    }
    ///Gets the value of [`Self::color_write_mask`]
    pub fn color_write_mask(&self) -> ColorComponentFlags {
        self.color_write_mask
    }
    ///Gets a mutable reference to the value of [`Self::blend_enable`]
    pub fn blend_enable_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.blend_enable as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.blend_enable as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of [`Self::src_color_blend_factor`]
    pub fn src_color_blend_factor_mut(&mut self) -> &mut BlendFactor {
        &mut self.src_color_blend_factor
    }
    ///Gets a mutable reference to the value of [`Self::dst_color_blend_factor`]
    pub fn dst_color_blend_factor_mut(&mut self) -> &mut BlendFactor {
        &mut self.dst_color_blend_factor
    }
    ///Gets a mutable reference to the value of [`Self::color_blend_op`]
    pub fn color_blend_op_mut(&mut self) -> &mut BlendOp {
        &mut self.color_blend_op
    }
    ///Gets a mutable reference to the value of [`Self::src_alpha_blend_factor`]
    pub fn src_alpha_blend_factor_mut(&mut self) -> &mut BlendFactor {
        &mut self.src_alpha_blend_factor
    }
    ///Gets a mutable reference to the value of [`Self::dst_alpha_blend_factor`]
    pub fn dst_alpha_blend_factor_mut(&mut self) -> &mut BlendFactor {
        &mut self.dst_alpha_blend_factor
    }
    ///Gets a mutable reference to the value of [`Self::alpha_blend_op`]
    pub fn alpha_blend_op_mut(&mut self) -> &mut BlendOp {
        &mut self.alpha_blend_op
    }
    ///Gets a mutable reference to the value of [`Self::color_write_mask`]
    pub fn color_write_mask_mut(&mut self) -> &mut ColorComponentFlags {
        &mut self.color_write_mask
    }
    ///Sets the raw value of [`Self::blend_enable`]
    pub fn set_blend_enable(&mut self, value: bool) -> &mut Self {
        self.blend_enable = value as u8 as u32;
        self
    }
    ///Sets the raw value of [`Self::src_color_blend_factor`]
    pub fn set_src_color_blend_factor(&mut self, value: crate::vulkan1_0::BlendFactor) -> &mut Self {
        self.src_color_blend_factor = value;
        self
    }
    ///Sets the raw value of [`Self::dst_color_blend_factor`]
    pub fn set_dst_color_blend_factor(&mut self, value: crate::vulkan1_0::BlendFactor) -> &mut Self {
        self.dst_color_blend_factor = value;
        self
    }
    ///Sets the raw value of [`Self::color_blend_op`]
    pub fn set_color_blend_op(&mut self, value: crate::vulkan1_0::BlendOp) -> &mut Self {
        self.color_blend_op = value;
        self
    }
    ///Sets the raw value of [`Self::src_alpha_blend_factor`]
    pub fn set_src_alpha_blend_factor(&mut self, value: crate::vulkan1_0::BlendFactor) -> &mut Self {
        self.src_alpha_blend_factor = value;
        self
    }
    ///Sets the raw value of [`Self::dst_alpha_blend_factor`]
    pub fn set_dst_alpha_blend_factor(&mut self, value: crate::vulkan1_0::BlendFactor) -> &mut Self {
        self.dst_alpha_blend_factor = value;
        self
    }
    ///Sets the raw value of [`Self::alpha_blend_op`]
    pub fn set_alpha_blend_op(&mut self, value: crate::vulkan1_0::BlendOp) -> &mut Self {
        self.alpha_blend_op = value;
        self
    }
    ///Sets the raw value of [`Self::color_write_mask`]
    pub fn set_color_write_mask(&mut self, value: crate::vulkan1_0::ColorComponentFlags) -> &mut Self {
        self.color_write_mask = value;
        self
    }
}
///[VkPipelineColorBlendStateCreateInfo](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineColorBlendStateCreateInfo.html) - Structure specifying parameters of a newly created pipeline color blend state
///# C Specifications
///The [`PipelineColorBlendStateCreateInfo`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkPipelineColorBlendStateCreateInfo {
///    VkStructureType                               sType;
///    const void*                                   pNext;
///    VkPipelineColorBlendStateCreateFlags          flags;
///    VkBool32                                      logicOpEnable;
///    VkLogicOp                                     logicOp;
///    uint32_t                                      attachmentCount;
///    const VkPipelineColorBlendAttachmentState*    pAttachments;
///    float                                         blendConstants[4];
///} VkPipelineColorBlendStateCreateInfo;
///```
///# Members
/// - [`s_type`] is the type of this structure.
/// - [`p_next`] is `NULL` or a pointer to a structure extending this structure.
/// - [`flags`] is a bitmask of [`PipelineColorBlendStateCreateFlagBits`] specifying additional
///   color blending information.
/// - [`logic_op_enable`] controls whether to apply [Logical Operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#framebuffer-logicop).
/// - [`logic_op`] selects which logical operation to apply.
/// - [`attachment_count`] is the number of [`PipelineColorBlendAttachmentState`] elements in
///   [`attachments`].
/// - [`attachments`] is a pointer to an array of [`PipelineColorBlendAttachmentState`] structures
///   defining blend state for each color attachment.
/// - [`blend_constants`] is a pointer to an array of four values used as the R, G, B, and A components of the blend constant that are used in blending, depending on the [blend factor](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#framebuffer-blendfactors).
///# Description
///## Valid Usage
/// - If the [independent blending](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-independentBlend)
///   feature is not enabled, all elements of [`attachments`] **must**  be identical
/// - If the [logic operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-logicOp)
///   feature is not enabled, [`logic_op_enable`] **must**  be [`FALSE`]
/// - If [`logic_op_enable`] is [`TRUE`], [`logic_op`] **must**  be a valid [`LogicOp`] value
/// - If the [`rasterizationOrderColorAttachmentAccess`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-rasterizationOrderColorAttachmentAccess)
///   feature is not enabled, [`flags`] **must**  not include
///   `VK_PIPELINE_COLOR_BLEND_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_ARM`
///
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be `VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO`
/// - Each [`p_next`] member of any structure (including this one) in the [`p_next`] chain  **must**
///   be either `NULL` or a pointer to a valid instance of
///   [`PipelineColorBlendAdvancedStateCreateInfoEXT`] or [`PipelineColorWriteCreateInfoEXT`]
/// - The [`s_type`] value of each struct in the [`p_next`] chain  **must**  be unique
/// - [`flags`] **must**  be a valid combination of [`PipelineColorBlendStateCreateFlagBits`] values
/// - If [`attachment_count`] is not `0`, [`attachments`] **must**  be a valid pointer to an array
///   of [`attachment_count`] valid [`PipelineColorBlendAttachmentState`] structures
///# Related
/// - [`crate::vulkan1_0`]
/// - [`Bool32`]
/// - [`GraphicsPipelineCreateInfo`]
/// - [`LogicOp`]
/// - [`PipelineColorBlendAttachmentState`]
/// - [`PipelineColorBlendStateCreateFlags`]
/// - [`StructureType`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, PartialEq, PartialOrd)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[repr(C)]
pub struct PipelineColorBlendStateCreateInfo<'lt> {
    _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] is the type of this structure.
    s_type: StructureType,
    ///[`p_next`] is `NULL` or a pointer to a structure extending this
    ///structure.
    p_next: *const BaseInStructure<'lt>,
    ///[`flags`] is a bitmask of
    ///[`PipelineColorBlendStateCreateFlagBits`] specifying additional
    ///color blending information.
    flags: PipelineColorBlendStateCreateFlags,
    ///[`logic_op_enable`] controls whether to apply [Logical Operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#framebuffer-logicop).
    logic_op_enable: Bool32,
    ///[`logic_op`] selects which logical operation to apply.
    logic_op: LogicOp,
    ///[`attachment_count`] is the number of
    ///[`PipelineColorBlendAttachmentState`] elements in
    ///[`attachments`].
    attachment_count: u32,
    ///[`attachments`] is a pointer to an array of
    ///[`PipelineColorBlendAttachmentState`] structures defining blend
    ///state for each color attachment.
    attachments: *const PipelineColorBlendAttachmentState,
    ///[`blend_constants`] is a pointer to an array of four values used as the
    ///R, G, B, and A components of the blend constant that are used in
    ///blending, depending on the [blend factor](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#framebuffer-blendfactors).
    blend_constants: [f32; 4],
}
impl<'lt> Default for PipelineColorBlendStateCreateInfo<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: Default::default(),
            p_next: std::ptr::null(),
            flags: Default::default(),
            logic_op_enable: 0,
            logic_op: Default::default(),
            attachment_count: 0,
            attachments: std::ptr::null(),
            blend_constants: [0.0; 4],
        }
    }
}
impl<'lt> PipelineColorBlendStateCreateInfo<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *const BaseInStructure<'lt> {
        self.p_next
    }
    ///Gets the raw value of [`Self::logic_op_enable`]
    pub fn logic_op_enable_raw(&self) -> Bool32 {
        self.logic_op_enable
    }
    ///Gets the raw value of [`Self::attachments`]
    pub fn attachments_raw(&self) -> *const PipelineColorBlendAttachmentState {
        self.attachments
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *const BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::logic_op_enable`]
    pub fn set_logic_op_enable_raw(&mut self, value: Bool32) -> &mut Self {
        self.logic_op_enable = value;
        self
    }
    ///Sets the raw value of [`Self::attachments`]
    pub fn set_attachments_raw(&mut self, value: *const PipelineColorBlendAttachmentState) -> &mut Self {
        self.attachments = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseInStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::flags`]
    pub fn flags(&self) -> PipelineColorBlendStateCreateFlags {
        self.flags
    }
    ///Gets the value of [`Self::logic_op_enable`]
    pub fn logic_op_enable(&self) -> bool {
        unsafe { std::mem::transmute(self.logic_op_enable as u8) }
    }
    ///Gets the value of [`Self::logic_op`]
    pub fn logic_op(&self) -> LogicOp {
        self.logic_op
    }
    ///Gets the value of [`Self::attachment_count`]
    pub fn attachment_count(&self) -> u32 {
        self.attachment_count
    }
    ///Gets the value of [`Self::attachments`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn attachments(&self) -> &[PipelineColorBlendAttachmentState] {
        std::slice::from_raw_parts(self.attachments, self.attachment_count as usize)
    }
    ///Gets the value of [`Self::blend_constants`]
    pub fn blend_constants(&self) -> &[f32; 4] {
        &getter
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::flags`]
    pub fn flags_mut(&mut self) -> &mut PipelineColorBlendStateCreateFlags {
        &mut self.flags
    }
    ///Gets a mutable reference to the value of [`Self::logic_op_enable`]
    pub fn logic_op_enable_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.logic_op_enable as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.logic_op_enable as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of [`Self::logic_op`]
    pub fn logic_op_mut(&mut self) -> &mut LogicOp {
        &mut self.logic_op
    }
    ///Gets a mutable reference to the value of [`Self::attachment_count`]
    pub fn attachment_count_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::blend_constants`]
    pub fn blend_constants_mut(&mut self) -> &mut [f32; 4] {
        &mut getter
    }
    ///Sets the raw value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the raw value of [`Self::flags`]
    pub fn set_flags(&mut self, value: crate::vulkan1_0::PipelineColorBlendStateCreateFlags) -> &mut Self {
        self.flags = value;
        self
    }
    ///Sets the raw value of [`Self::logic_op_enable`]
    pub fn set_logic_op_enable(&mut self, value: bool) -> &mut Self {
        self.logic_op_enable = value as u8 as u32;
        self
    }
    ///Sets the raw value of [`Self::logic_op`]
    pub fn set_logic_op(&mut self, value: crate::vulkan1_0::LogicOp) -> &mut Self {
        self.logic_op = value;
        self
    }
    ///Sets the raw value of [`Self::attachment_count`]
    pub fn set_attachment_count(&mut self, value: u32) -> &mut Self {
        self.attachment_count = value;
        self
    }
    ///Sets the raw value of [`Self::attachments`]
    pub fn set_attachments(&mut self, value: &'lt [crate::vulkan1_0::PipelineColorBlendAttachmentState]) -> &mut Self {
        let len_ = value.len() as u32;
        let len_ = len_;
        self.attachments = value.as_ptr();
        self.attachment_count = len_;
        self
    }
    ///Sets the raw value of [`Self::blend_constants`]
    pub fn set_blend_constants(&mut self, value: [f32; 4]) -> &mut Self {
        self.blend_constants = value;
        self
    }
}
///[VkPipelineDynamicStateCreateInfo](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineDynamicStateCreateInfo.html) - Structure specifying parameters of a newly created pipeline dynamic state
///# C Specifications
///The [`PipelineDynamicStateCreateInfo`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkPipelineDynamicStateCreateInfo {
///    VkStructureType                      sType;
///    const void*                          pNext;
///    VkPipelineDynamicStateCreateFlags    flags;
///    uint32_t                             dynamicStateCount;
///    const VkDynamicState*                pDynamicStates;
///} VkPipelineDynamicStateCreateInfo;
///```
///# Members
/// - [`s_type`] is the type of this structure.
/// - [`p_next`] is `NULL` or a pointer to a structure extending this structure.
/// - [`flags`] is reserved for future use.
/// - [`dynamic_state_count`] is the number of elements in the [`dynamic_states`] array.
/// - [`dynamic_states`] is a pointer to an array of [`DynamicState`] values specifying which pieces
///   of pipeline state will use the values from dynamic state commands rather than from pipeline
///   state creation information.
///# Description
///## Valid Usage
/// - Each element of [`dynamic_states`] **must**  be unique
///
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be `VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO`
/// - [`p_next`] **must**  be `NULL`
/// - [`flags`] **must**  be `0`
/// - If [`dynamic_state_count`] is not `0`, [`dynamic_states`] **must**  be a valid pointer to an
///   array of [`dynamic_state_count`] valid [`DynamicState`] values
///# Related
/// - [`crate::vulkan1_0`]
/// - [`DynamicState`]
/// - [`GraphicsPipelineCreateInfo`]
/// - [`PipelineDynamicStateCreateFlags`]
/// - [`RayTracingPipelineCreateInfoKHR`]
/// - [`StructureType`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[repr(C)]
pub struct PipelineDynamicStateCreateInfo<'lt> {
    _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] is the type of this structure.
    s_type: StructureType,
    ///[`p_next`] is `NULL` or a pointer to a structure extending this
    ///structure.
    p_next: *const BaseInStructure<'lt>,
    ///[`flags`] is reserved for future use.
    flags: PipelineDynamicStateCreateFlags,
    ///[`dynamic_state_count`] is the number of elements in the
    ///[`dynamic_states`] array.
    dynamic_state_count: u32,
    ///[`dynamic_states`] is a pointer to an array of [`DynamicState`]
    ///values specifying which pieces of pipeline state will use the values
    ///from dynamic state commands rather than from pipeline state creation
    ///information.
    dynamic_states: *const DynamicState,
}
impl<'lt> Default for PipelineDynamicStateCreateInfo<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: Default::default(),
            p_next: std::ptr::null(),
            flags: Default::default(),
            dynamic_state_count: 0,
            dynamic_states: std::ptr::null(),
        }
    }
}
impl<'lt> PipelineDynamicStateCreateInfo<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *const BaseInStructure<'lt> {
        self.p_next
    }
    ///Gets the raw value of [`Self::dynamic_states`]
    pub fn dynamic_states_raw(&self) -> *const DynamicState {
        self.dynamic_states
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *const BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::dynamic_states`]
    pub fn set_dynamic_states_raw(&mut self, value: *const DynamicState) -> &mut Self {
        self.dynamic_states = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseInStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::flags`]
    pub fn flags(&self) -> PipelineDynamicStateCreateFlags {
        self.flags
    }
    ///Gets the value of [`Self::dynamic_state_count`]
    pub fn dynamic_state_count(&self) -> u32 {
        self.dynamic_state_count
    }
    ///Gets the value of [`Self::dynamic_states`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn dynamic_states(&self) -> &[DynamicState] {
        std::slice::from_raw_parts(self.dynamic_states, self.dynamic_state_count as usize)
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::flags`]
    pub fn flags_mut(&mut self) -> &mut PipelineDynamicStateCreateFlags {
        &mut self.flags
    }
    ///Gets a mutable reference to the value of [`Self::dynamic_state_count`]
    pub fn dynamic_state_count_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Sets the raw value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the raw value of [`Self::flags`]
    pub fn set_flags(&mut self, value: crate::vulkan1_0::PipelineDynamicStateCreateFlags) -> &mut Self {
        self.flags = value;
        self
    }
    ///Sets the raw value of [`Self::dynamic_state_count`]
    pub fn set_dynamic_state_count(&mut self, value: u32) -> &mut Self {
        self.dynamic_state_count = value;
        self
    }
    ///Sets the raw value of [`Self::dynamic_states`]
    pub fn set_dynamic_states(&mut self, value: &'lt [crate::vulkan1_0::DynamicState]) -> &mut Self {
        let len_ = value.len() as u32;
        let len_ = len_;
        self.dynamic_states = value.as_ptr();
        self.dynamic_state_count = len_;
        self
    }
}
///[VkStencilOpState](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkStencilOpState.html) - Structure specifying stencil operation state
///# C Specifications
///The [`StencilOpState`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkStencilOpState {
///    VkStencilOp    failOp;
///    VkStencilOp    passOp;
///    VkStencilOp    depthFailOp;
///    VkCompareOp    compareOp;
///    uint32_t       compareMask;
///    uint32_t       writeMask;
///    uint32_t       reference;
///} VkStencilOpState;
///```
///# Members
/// - [`fail_op`] is a [`StencilOp`] value specifying the action performed on samples that fail the
///   stencil test.
/// - [`pass_op`] is a [`StencilOp`] value specifying the action performed on samples that pass both
///   the depth and stencil tests.
/// - [`depth_fail_op`] is a [`StencilOp`] value specifying the action performed on samples that
///   pass the stencil test and fail the depth test.
/// - [`compare_op`] is a [`CompareOp`] value specifying the comparison operator used in the stencil
///   test.
/// - [`compare_mask`] selects the bits of the unsigned integer stencil values participating in the
///   stencil test.
/// - [`write_mask`] selects the bits of the unsigned integer stencil values updated by the stencil
///   test in the stencil framebuffer attachment.
/// - [`reference`] is an integer reference value that is used in the unsigned stencil comparison.
///# Description
///## Valid Usage (Implicit)
/// - [`fail_op`] **must**  be a valid [`StencilOp`] value
/// - [`pass_op`] **must**  be a valid [`StencilOp`] value
/// - [`depth_fail_op`] **must**  be a valid [`StencilOp`] value
/// - [`compare_op`] **must**  be a valid [`CompareOp`] value
///# Related
/// - [`crate::vulkan1_0`]
/// - [`CompareOp`]
/// - [`PipelineDepthStencilStateCreateInfo`]
/// - [`StencilOp`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct StencilOpState {
    ///[`fail_op`] is a [`StencilOp`] value specifying the action
    ///performed on samples that fail the stencil test.
    fail_op: StencilOp,
    ///[`pass_op`] is a [`StencilOp`] value specifying the action
    ///performed on samples that pass both the depth and stencil tests.
    pass_op: StencilOp,
    ///[`depth_fail_op`] is a [`StencilOp`] value specifying the action
    ///performed on samples that pass the stencil test and fail the depth test.
    depth_fail_op: StencilOp,
    ///[`compare_op`] is a [`CompareOp`] value specifying the comparison
    ///operator used in the stencil test.
    compare_op: CompareOp,
    ///[`compare_mask`] selects the bits of the unsigned integer stencil
    ///values participating in the stencil test.
    compare_mask: u32,
    ///[`write_mask`] selects the bits of the unsigned integer stencil values
    ///updated by the stencil test in the stencil framebuffer attachment.
    write_mask: u32,
    ///[`reference`] is an integer reference value that is used in the
    ///unsigned stencil comparison.
    reference: u32,
}
impl Default for StencilOpState {
    fn default() -> Self {
        Self {
            fail_op: Default::default(),
            pass_op: Default::default(),
            depth_fail_op: Default::default(),
            compare_op: Default::default(),
            compare_mask: 0,
            write_mask: 0,
            reference: 0,
        }
    }
}
impl StencilOpState {
    ///Gets the value of [`Self::fail_op`]
    pub fn fail_op(&self) -> StencilOp {
        self.fail_op
    }
    ///Gets the value of [`Self::pass_op`]
    pub fn pass_op(&self) -> StencilOp {
        self.pass_op
    }
    ///Gets the value of [`Self::depth_fail_op`]
    pub fn depth_fail_op(&self) -> StencilOp {
        self.depth_fail_op
    }
    ///Gets the value of [`Self::compare_op`]
    pub fn compare_op(&self) -> CompareOp {
        self.compare_op
    }
    ///Gets the value of [`Self::compare_mask`]
    pub fn compare_mask(&self) -> u32 {
        self.compare_mask
    }
    ///Gets the value of [`Self::write_mask`]
    pub fn write_mask(&self) -> u32 {
        self.write_mask
    }
    ///Gets the value of [`Self::reference`]
    pub fn reference(&self) -> u32 {
        self.reference
    }
    ///Gets a mutable reference to the value of [`Self::fail_op`]
    pub fn fail_op_mut(&mut self) -> &mut StencilOp {
        &mut self.fail_op
    }
    ///Gets a mutable reference to the value of [`Self::pass_op`]
    pub fn pass_op_mut(&mut self) -> &mut StencilOp {
        &mut self.pass_op
    }
    ///Gets a mutable reference to the value of [`Self::depth_fail_op`]
    pub fn depth_fail_op_mut(&mut self) -> &mut StencilOp {
        &mut self.depth_fail_op
    }
    ///Gets a mutable reference to the value of [`Self::compare_op`]
    pub fn compare_op_mut(&mut self) -> &mut CompareOp {
        &mut self.compare_op
    }
    ///Gets a mutable reference to the value of [`Self::compare_mask`]
    pub fn compare_mask_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::write_mask`]
    pub fn write_mask_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::reference`]
    pub fn reference_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Sets the raw value of [`Self::fail_op`]
    pub fn set_fail_op(&mut self, value: crate::vulkan1_0::StencilOp) -> &mut Self {
        self.fail_op = value;
        self
    }
    ///Sets the raw value of [`Self::pass_op`]
    pub fn set_pass_op(&mut self, value: crate::vulkan1_0::StencilOp) -> &mut Self {
        self.pass_op = value;
        self
    }
    ///Sets the raw value of [`Self::depth_fail_op`]
    pub fn set_depth_fail_op(&mut self, value: crate::vulkan1_0::StencilOp) -> &mut Self {
        self.depth_fail_op = value;
        self
    }
    ///Sets the raw value of [`Self::compare_op`]
    pub fn set_compare_op(&mut self, value: crate::vulkan1_0::CompareOp) -> &mut Self {
        self.compare_op = value;
        self
    }
    ///Sets the raw value of [`Self::compare_mask`]
    pub fn set_compare_mask(&mut self, value: u32) -> &mut Self {
        self.compare_mask = value;
        self
    }
    ///Sets the raw value of [`Self::write_mask`]
    pub fn set_write_mask(&mut self, value: u32) -> &mut Self {
        self.write_mask = value;
        self
    }
    ///Sets the raw value of [`Self::reference`]
    pub fn set_reference(&mut self, value: u32) -> &mut Self {
        self.reference = value;
        self
    }
}
///[VkPipelineDepthStencilStateCreateInfo](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineDepthStencilStateCreateInfo.html) - Structure specifying parameters of a newly created pipeline depth stencil state
///# C Specifications
///The [`PipelineDepthStencilStateCreateInfo`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkPipelineDepthStencilStateCreateInfo {
///    VkStructureType                           sType;
///    const void*                               pNext;
///    VkPipelineDepthStencilStateCreateFlags    flags;
///    VkBool32                                  depthTestEnable;
///    VkBool32                                  depthWriteEnable;
///    VkCompareOp                               depthCompareOp;
///    VkBool32                                  depthBoundsTestEnable;
///    VkBool32                                  stencilTestEnable;
///    VkStencilOpState                          front;
///    VkStencilOpState                          back;
///    float                                     minDepthBounds;
///    float                                     maxDepthBounds;
///} VkPipelineDepthStencilStateCreateInfo;
///```
///# Members
/// - [`s_type`] is the type of this structure.
/// - [`p_next`] is `NULL` or a pointer to a structure extending this structure.
/// - [`flags`] is a bitmask of [`PipelineDepthStencilStateCreateFlagBits`] specifying additional
///   depth/stencil state information.
/// - [`depth_test_enable`] controls whether [depth testing](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fragops-depth)
///   is enabled.
/// - [`depth_write_enable`] controls whether [depth writes](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fragops-depth-write)
///   are enabled when [`depth_test_enable`] is [`TRUE`]. Depth writes are always disabled when
///   [`depth_test_enable`] is [`FALSE`].
/// - [`depth_compare_op`] is the comparison operator used in the [depth test](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fragops-depth).
/// - [`depth_bounds_test_enable`] controls whether [depth bounds testing](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fragops-dbt)
///   is enabled.
/// - [`stencil_test_enable`] controls whether [stencil testing](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fragops-stencil)
///   is enabled.
/// - [`front`] and [`back`] control the parameters of the [stencil test](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fragops-stencil).
/// - [`min_depth_bounds`] is the minimum depth bound used in the [depth bounds test](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fragops-dbt).
/// - [`max_depth_bounds`] is the maximum depth bound used in the [depth bounds test](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fragops-dbt).
///# Description
///## Valid Usage
/// - If the [depth bounds testing](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-depthBounds)
///   feature is not enabled, [`depth_bounds_test_enable`] **must**  be [`FALSE`]
/// - If the `[`VK_KHR_portability_subset`]` extension is enabled, and
///   [`PhysicalDevicePortabilitySubsetFeaturesKHR::separate_stencil_mask_ref`] is [`FALSE`], and
///   the value of [`PipelineDepthStencilStateCreateInfo`]::[`stencil_test_enable`] is [`TRUE`], and
///   the value of [`PipelineRasterizationStateCreateInfo::cull_mode`] is `VK_CULL_MODE_NONE`, the
///   value of `reference` in each of the [`StencilOpState`] structs in [`front`] and [`back`]
///   **must**  be the same
/// - If the [`rasterizationOrderDepthAttachmentAccess`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-rasterizationOrderDepthAttachmentAccess)
///   feature is not enabled, [`flags`] **must**  not include
///   `VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_ARM`
/// - If the [`rasterizationOrderStencilAttachmentAccess`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-rasterizationOrderStencilAttachmentAccess)
///   feature is not enabled, [`flags`] **must**  not include
///   `VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_ARM`
///
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be `VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO`
/// - [`p_next`] **must**  be `NULL`
/// - [`flags`] **must**  be a valid combination of [`PipelineDepthStencilStateCreateFlagBits`]
///   values
/// - [`depth_compare_op`] **must**  be a valid [`CompareOp`] value
/// - [`front`] **must**  be a valid [`StencilOpState`] structure
/// - [`back`] **must**  be a valid [`StencilOpState`] structure
///# Related
/// - [`crate::vulkan1_0`]
/// - [`Bool32`]
/// - [`CompareOp`]
/// - [`GraphicsPipelineCreateInfo`]
/// - [`PipelineDepthStencilStateCreateFlags`]
/// - [`StencilOpState`]
/// - [`StructureType`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, PartialEq, PartialOrd)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[repr(C)]
pub struct PipelineDepthStencilStateCreateInfo<'lt> {
    _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] is the type of this structure.
    s_type: StructureType,
    ///[`p_next`] is `NULL` or a pointer to a structure extending this
    ///structure.
    p_next: *const BaseInStructure<'lt>,
    ///[`flags`] is a bitmask of
    ///[`PipelineDepthStencilStateCreateFlagBits`] specifying additional
    ///depth/stencil state information.
    flags: PipelineDepthStencilStateCreateFlags,
    ///[`depth_test_enable`] controls whether [depth testing](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fragops-depth)
    ///is enabled.
    depth_test_enable: Bool32,
    ///[`depth_write_enable`] controls whether [depth
    ///writes](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fragops-depth-write) are enabled when [`depth_test_enable`] is [`TRUE`].
    ///Depth writes are always disabled when [`depth_test_enable`] is
    ///[`FALSE`].
    depth_write_enable: Bool32,
    ///[`depth_compare_op`] is the comparison operator used in the
    ///[depth test](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fragops-depth).
    depth_compare_op: CompareOp,
    ///[`depth_bounds_test_enable`] controls whether [depth bounds
    ///testing](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fragops-dbt) is enabled.
    depth_bounds_test_enable: Bool32,
    ///[`stencil_test_enable`] controls whether [stencil
    ///testing](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fragops-stencil) is enabled.
    stencil_test_enable: Bool32,
    ///[`front`] and [`back`] control the parameters of the
    ///[stencil test](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fragops-stencil).
    front: StencilOpState,
    ///No documentation found
    back: StencilOpState,
    ///[`min_depth_bounds`] is the minimum depth bound used in the
    ///[depth bounds test](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fragops-dbt).
    min_depth_bounds: f32,
    ///[`max_depth_bounds`] is the maximum depth bound used in the
    ///[depth bounds test](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fragops-dbt).
    max_depth_bounds: f32,
}
impl<'lt> Default for PipelineDepthStencilStateCreateInfo<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: Default::default(),
            p_next: std::ptr::null(),
            flags: Default::default(),
            depth_test_enable: 0,
            depth_write_enable: 0,
            depth_compare_op: Default::default(),
            depth_bounds_test_enable: 0,
            stencil_test_enable: 0,
            front: Default::default(),
            back: Default::default(),
            min_depth_bounds: 0.0,
            max_depth_bounds: 0.0,
        }
    }
}
impl<'lt> PipelineDepthStencilStateCreateInfo<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *const BaseInStructure<'lt> {
        self.p_next
    }
    ///Gets the raw value of [`Self::depth_test_enable`]
    pub fn depth_test_enable_raw(&self) -> Bool32 {
        self.depth_test_enable
    }
    ///Gets the raw value of [`Self::depth_write_enable`]
    pub fn depth_write_enable_raw(&self) -> Bool32 {
        self.depth_write_enable
    }
    ///Gets the raw value of [`Self::depth_bounds_test_enable`]
    pub fn depth_bounds_test_enable_raw(&self) -> Bool32 {
        self.depth_bounds_test_enable
    }
    ///Gets the raw value of [`Self::stencil_test_enable`]
    pub fn stencil_test_enable_raw(&self) -> Bool32 {
        self.stencil_test_enable
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *const BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::depth_test_enable`]
    pub fn set_depth_test_enable_raw(&mut self, value: Bool32) -> &mut Self {
        self.depth_test_enable = value;
        self
    }
    ///Sets the raw value of [`Self::depth_write_enable`]
    pub fn set_depth_write_enable_raw(&mut self, value: Bool32) -> &mut Self {
        self.depth_write_enable = value;
        self
    }
    ///Sets the raw value of [`Self::depth_bounds_test_enable`]
    pub fn set_depth_bounds_test_enable_raw(&mut self, value: Bool32) -> &mut Self {
        self.depth_bounds_test_enable = value;
        self
    }
    ///Sets the raw value of [`Self::stencil_test_enable`]
    pub fn set_stencil_test_enable_raw(&mut self, value: Bool32) -> &mut Self {
        self.stencil_test_enable = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseInStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::flags`]
    pub fn flags(&self) -> PipelineDepthStencilStateCreateFlags {
        self.flags
    }
    ///Gets the value of [`Self::depth_test_enable`]
    pub fn depth_test_enable(&self) -> bool {
        unsafe { std::mem::transmute(self.depth_test_enable as u8) }
    }
    ///Gets the value of [`Self::depth_write_enable`]
    pub fn depth_write_enable(&self) -> bool {
        unsafe { std::mem::transmute(self.depth_write_enable as u8) }
    }
    ///Gets the value of [`Self::depth_compare_op`]
    pub fn depth_compare_op(&self) -> CompareOp {
        self.depth_compare_op
    }
    ///Gets the value of [`Self::depth_bounds_test_enable`]
    pub fn depth_bounds_test_enable(&self) -> bool {
        unsafe { std::mem::transmute(self.depth_bounds_test_enable as u8) }
    }
    ///Gets the value of [`Self::stencil_test_enable`]
    pub fn stencil_test_enable(&self) -> bool {
        unsafe { std::mem::transmute(self.stencil_test_enable as u8) }
    }
    ///Gets the value of [`Self::front`]
    pub fn front(&self) -> StencilOpState {
        self.front
    }
    ///Gets the value of [`Self::back`]
    pub fn back(&self) -> StencilOpState {
        self.back
    }
    ///Gets the value of [`Self::min_depth_bounds`]
    pub fn min_depth_bounds(&self) -> f32 {
        self.min_depth_bounds
    }
    ///Gets the value of [`Self::max_depth_bounds`]
    pub fn max_depth_bounds(&self) -> f32 {
        self.max_depth_bounds
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::flags`]
    pub fn flags_mut(&mut self) -> &mut PipelineDepthStencilStateCreateFlags {
        &mut self.flags
    }
    ///Gets a mutable reference to the value of [`Self::depth_test_enable`]
    pub fn depth_test_enable_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.depth_test_enable as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.depth_test_enable as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of [`Self::depth_write_enable`]
    pub fn depth_write_enable_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.depth_write_enable as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.depth_write_enable as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of [`Self::depth_compare_op`]
    pub fn depth_compare_op_mut(&mut self) -> &mut CompareOp {
        &mut self.depth_compare_op
    }
    ///Gets a mutable reference to the value of [`Self::depth_bounds_test_enable`]
    pub fn depth_bounds_test_enable_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.depth_bounds_test_enable as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.depth_bounds_test_enable as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of [`Self::stencil_test_enable`]
    pub fn stencil_test_enable_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.stencil_test_enable as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.stencil_test_enable as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of [`Self::front`]
    pub fn front_mut(&mut self) -> &mut StencilOpState {
        &mut self.front
    }
    ///Gets a mutable reference to the value of [`Self::back`]
    pub fn back_mut(&mut self) -> &mut StencilOpState {
        &mut self.back
    }
    ///Gets a mutable reference to the value of [`Self::min_depth_bounds`]
    pub fn min_depth_bounds_mut(&mut self) -> &mut f32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::max_depth_bounds`]
    pub fn max_depth_bounds_mut(&mut self) -> &mut f32 {
        &mut getter
    }
    ///Sets the raw value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the raw value of [`Self::flags`]
    pub fn set_flags(&mut self, value: crate::vulkan1_0::PipelineDepthStencilStateCreateFlags) -> &mut Self {
        self.flags = value;
        self
    }
    ///Sets the raw value of [`Self::depth_test_enable`]
    pub fn set_depth_test_enable(&mut self, value: bool) -> &mut Self {
        self.depth_test_enable = value as u8 as u32;
        self
    }
    ///Sets the raw value of [`Self::depth_write_enable`]
    pub fn set_depth_write_enable(&mut self, value: bool) -> &mut Self {
        self.depth_write_enable = value as u8 as u32;
        self
    }
    ///Sets the raw value of [`Self::depth_compare_op`]
    pub fn set_depth_compare_op(&mut self, value: crate::vulkan1_0::CompareOp) -> &mut Self {
        self.depth_compare_op = value;
        self
    }
    ///Sets the raw value of [`Self::depth_bounds_test_enable`]
    pub fn set_depth_bounds_test_enable(&mut self, value: bool) -> &mut Self {
        self.depth_bounds_test_enable = value as u8 as u32;
        self
    }
    ///Sets the raw value of [`Self::stencil_test_enable`]
    pub fn set_stencil_test_enable(&mut self, value: bool) -> &mut Self {
        self.stencil_test_enable = value as u8 as u32;
        self
    }
    ///Sets the raw value of [`Self::front`]
    pub fn set_front(&mut self, value: crate::vulkan1_0::StencilOpState) -> &mut Self {
        self.front = value;
        self
    }
    ///Sets the raw value of [`Self::back`]
    pub fn set_back(&mut self, value: crate::vulkan1_0::StencilOpState) -> &mut Self {
        self.back = value;
        self
    }
    ///Sets the raw value of [`Self::min_depth_bounds`]
    pub fn set_min_depth_bounds(&mut self, value: f32) -> &mut Self {
        self.min_depth_bounds = value;
        self
    }
    ///Sets the raw value of [`Self::max_depth_bounds`]
    pub fn set_max_depth_bounds(&mut self, value: f32) -> &mut Self {
        self.max_depth_bounds = value;
        self
    }
}
///[VkGraphicsPipelineCreateInfo](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkGraphicsPipelineCreateInfo.html) - Structure specifying parameters of a newly created graphics pipeline
///# C Specifications
///The [`GraphicsPipelineCreateInfo`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkGraphicsPipelineCreateInfo {
///    VkStructureType                                  sType;
///    const void*                                      pNext;
///    VkPipelineCreateFlags                            flags;
///    uint32_t                                         stageCount;
///    const VkPipelineShaderStageCreateInfo*           pStages;
///    const VkPipelineVertexInputStateCreateInfo*      pVertexInputState;
///    const VkPipelineInputAssemblyStateCreateInfo*    pInputAssemblyState;
///    const VkPipelineTessellationStateCreateInfo*     pTessellationState;
///    const VkPipelineViewportStateCreateInfo*         pViewportState;
///    const VkPipelineRasterizationStateCreateInfo*    pRasterizationState;
///    const VkPipelineMultisampleStateCreateInfo*      pMultisampleState;
///    const VkPipelineDepthStencilStateCreateInfo*     pDepthStencilState;
///    const VkPipelineColorBlendStateCreateInfo*       pColorBlendState;
///    const VkPipelineDynamicStateCreateInfo*          pDynamicState;
///    VkPipelineLayout                                 layout;
///    VkRenderPass                                     renderPass;
///    uint32_t                                         subpass;
///    VkPipeline                                       basePipelineHandle;
///    int32_t                                          basePipelineIndex;
///} VkGraphicsPipelineCreateInfo;
///```
///# Members
/// - [`s_type`] is the type of this structure.
/// - [`p_next`] is `NULL` or a pointer to a structure extending this structure.
/// - [`flags`] is a bitmask of [`PipelineCreateFlagBits`] specifying how the pipeline will be
///   generated.
/// - [`stage_count`] is the number of entries in the [`stages`] array.
/// - [`stages`] is a pointer to an array of [`stage_count`][`PipelineShaderStageCreateInfo`]
///   structures describing the set of the shader stages to be included in the graphics pipeline.
/// - [`vertex_input_state`] is a pointer to a [`PipelineVertexInputStateCreateInfo`] structure
///   defining vertex input state for use with vertex shading.
/// - [`input_assembly_state`] is a pointer to a [`PipelineInputAssemblyStateCreateInfo`] structure which determines input assembly behavior for vertex shading, as described in [Drawing Commands](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#drawing).
/// - [`tessellation_state`] is a pointer to a [`PipelineTessellationStateCreateInfo`] structure
///   defining tessellation state used by tessellation shaders.
/// - [`viewport_state`] is a pointer to a [`PipelineViewportStateCreateInfo`] structure defining
///   viewport state used when rasterization is enabled.
/// - [`rasterization_state`] is a pointer to a [`PipelineRasterizationStateCreateInfo`] structure
///   defining rasterization state.
/// - [`multisample_state`] is a pointer to a [`PipelineMultisampleStateCreateInfo`] structure
///   defining multisample state used when rasterization is enabled.
/// - [`depth_stencil_state`] is a pointer to a [`PipelineDepthStencilStateCreateInfo`] structure
///   defining depth/stencil state used when rasterization is enabled for depth or stencil
///   attachments accessed during rendering.
/// - [`color_blend_state`] is a pointer to a [`PipelineColorBlendStateCreateInfo`] structure
///   defining color blend state used when rasterization is enabled for any color attachments
///   accessed during rendering.
/// - [`dynamic_state`] is a pointer to a [`PipelineDynamicStateCreateInfo`] structure defining
///   which properties of the pipeline state object are dynamic and  **can**  be changed
///   independently of the pipeline state. This  **can**  be `NULL`, which means no state in the
///   pipeline is considered dynamic.
/// - [`layout`] is the description of binding locations used by both the pipeline and descriptor
///   sets used with the pipeline.
/// - [`render_pass`] is a handle to a render pass object describing the environment in which the pipeline will be used. The pipeline  **must**  only be used with a render pass instance compatible with the one provided. See [Render Pass Compatibility](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-compatibility) for more information.
/// - [`subpass`] is the index of the subpass in the render pass where this pipeline will be used.
/// - [`base_pipeline_handle`] is a pipeline to derive from.
/// - [`base_pipeline_index`] is an index into the `pCreateInfos` parameter to use as a pipeline to
///   derive from.
///# Description
///The parameters [`base_pipeline_handle`] and [`base_pipeline_index`] are
///described in more detail in [Pipeline
///Derivatives](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipelines-pipeline-derivatives).If any shader stage fails to compile,
///the compile log will be reported back to the application, and
///`VK_ERROR_INVALID_SHADER_NV` will be generated.The state required for a graphics pipeline is
/// divided into
///[vertex input state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-vertex-input),
///[pre-rasterization shader
///state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-pre-rasterization), [fragment shader
///state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-fragment-shader), and [fragment output
///state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-fragment-output).Vertex input state is defined by:
/// - [`PipelineVertexInputStateCreateInfo`]
/// - [`PipelineInputAssemblyStateCreateInfo`]
///Pre-rasterization shader state is defined by:
/// - [`PipelineShaderStageCreateInfo`] entries for:  - Vertex shaders  - Tessellation control
///   shaders  - Tessellation evaluation shaders  - Geometry shaders  - Task shaders  - Mesh shaders
/// - Within the [`PipelineLayout`], all bindings that affect the specified shader stages
/// - [`PipelineViewportStateCreateInfo`]
/// - [`PipelineRasterizationStateCreateInfo`]
/// - [`PipelineTessellationStateCreateInfo`]
/// - [`RenderPass`] and [`subpass`] parameter
/// - [`PipelineDiscardRectangleStateCreateInfoEXT`]
/// - [`PipelineFragmentShadingRateStateCreateInfoKHR`]
/// - [`PipelineFragmentShadingRateEnumStateCreateInfoNV`]
///Fragment shader state is defined by:
/// - A [`PipelineShaderStageCreateInfo`] entry for the fragment shader
/// - Within the [`PipelineLayout`], all bindings that affect the fragment shader
/// - [`PipelineMultisampleStateCreateInfo`]
/// - [`PipelineDepthStencilStateCreateInfo`]
/// - [`RenderPass`] and [`subpass`] parameter
/// - [`PipelineFragmentShadingRateStateCreateInfoKHR`]
/// - [`PipelineFragmentShadingRateEnumStateCreateInfoNV`]
///Fragment output state is defined by:
/// - [`PipelineColorBlendStateCreateInfo`]
/// - The `alphaToCoverageEnable` and `alphaToOneEnable` members of
///   [`PipelineMultisampleStateCreateInfo`].
/// - [`RenderPass`] and [`subpass`] parameter
///A complete graphics pipeline always includes
///[pre-rasterization shader
///state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-pre-rasterization), with other subsets included depending on that state.
///If the [pre-rasterization
///shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-pre-rasterization) includes a vertex shader, then
///[vertex input state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-vertex-input) is included
///in a complete graphics pipeline.
///If the value of
///[`PipelineRasterizationStateCreateInfo::rasterizer_discard_enable`]
///in the [pre-rasterization
///shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-pre-rasterization) is [`FALSE`]
///or the `VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE` dynamic state is
///enabled
///[fragment shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-fragment-shader) and
///[fragment output interface
///state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-fragment-output) is included in a complete graphics pipeline.Pipelines  **must**  be created with a complete set of pipeline state.
///## Valid Usage
/// - If [`flags`] contains the `VK_PIPELINE_CREATE_DERIVATIVE_BIT` flag, and
///   [`base_pipeline_index`] is -1, [`base_pipeline_handle`] **must**  be a valid handle to a
///   graphics [`Pipeline`]
/// - If [`flags`] contains the `VK_PIPELINE_CREATE_DERIVATIVE_BIT` flag, and
///   [`base_pipeline_handle`] is [`crate::utils::Handle::null`], [`base_pipeline_index`] **must**
///   be a valid index into the calling command’s `pCreateInfos` parameter
/// - If [`flags`] contains the `VK_PIPELINE_CREATE_DERIVATIVE_BIT` flag, and
///   [`base_pipeline_index`] is not -1, [`base_pipeline_handle`] **must**  be
///   [`crate::utils::Handle::null`]
/// - If [`flags`] contains the `VK_PIPELINE_CREATE_DERIVATIVE_BIT` flag, and
///   [`base_pipeline_handle`] is not [`crate::utils::Handle::null`], [`base_pipeline_index`]
///   **must**  be -1
/// - The `stage` member of each element of [`stages`] **must**  be unique
/// - If the pipeline is being created with [pre-rasterization shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-pre-rasterization)
///   the geometric shader stages provided in [`stages`] **must**  be either from the mesh shading
///   pipeline (`stage` is `VK_SHADER_STAGE_TASK_BIT_NV` or `VK_SHADER_STAGE_MESH_BIT_NV`) or from
///   the primitive shading pipeline (`stage` is `VK_SHADER_STAGE_VERTEX_BIT`,
///   `VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT`, `VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT`, or
///   `VK_SHADER_STAGE_GEOMETRY_BIT`)
/// - If the pipeline is being created with [pre-rasterization shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-pre-rasterization)
///   the `stage` member of one element of [`stages`] **must**  be either
///   `VK_SHADER_STAGE_VERTEX_BIT` or `VK_SHADER_STAGE_MESH_BIT_NV`
/// - The `stage` member of each element of [`stages`] **must**  not be
///   `VK_SHADER_STAGE_COMPUTE_BIT`
/// - If the pipeline is being created with [pre-rasterization shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-pre-rasterization)
///   and [`stages`] includes a tessellation control shader stage, it  **must**  include a
///   tessellation evaluation shader stage
/// - If the pipeline is being created with [pre-rasterization shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-pre-rasterization)
///   and [`stages`] includes a tessellation evaluation shader stage, it  **must**  include a
///   tessellation control shader stage
/// - If the pipeline is being created with [pre-rasterization shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-pre-rasterization)
///   and [`stages`] includes a tessellation control shader stage and a tessellation evaluation
///   shader stage, [`tessellation_state`] **must**  be a valid pointer to a valid
///   [`PipelineTessellationStateCreateInfo`] structure
/// - If the pipeline is being created with [pre-rasterization shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-pre-rasterization)
///   and [`stages`] includes tessellation shader stages, the shader code of at least one stage
///   **must**  contain an `OpExecutionMode` instruction specifying the type of subdivision in the
///   pipeline
/// - If the pipeline is being created with [pre-rasterization shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-pre-rasterization)
///   and [`stages`] includes tessellation shader stages, and the shader code of both stages contain
///   an `OpExecutionMode` instruction specifying the type of subdivision in the pipeline, they
///   **must**  both specify the same subdivision mode
/// - If the pipeline is being created with [pre-rasterization shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-pre-rasterization)
///   and [`stages`] includes tessellation shader stages, the shader code of at least one stage
///   **must**  contain an `OpExecutionMode` instruction specifying the output patch size in the
///   pipeline
/// - If the pipeline is being created with [pre-rasterization shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-pre-rasterization)
///   and [`stages`] includes tessellation shader stages, and the shader code of both contain an
///   `OpExecutionMode` instruction specifying the out patch size in the pipeline, they  **must**
///   both specify the same patch size
/// - If the pipeline is being created with [pre-rasterization shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-pre-rasterization)
///   and [`stages`] includes tessellation shader stages, the `topology` member of `pInputAssembly`
///   **must**  be `VK_PRIMITIVE_TOPOLOGY_PATCH_LIST`
/// - If the pipeline is being created with [pre-rasterization shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-pre-rasterization)
///   and the `topology` member of `pInputAssembly` is `VK_PRIMITIVE_TOPOLOGY_PATCH_LIST`,
///   [`stages`] **must**  include tessellation shader stages
/// -    If the pipeline is being created with [pre-rasterization shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-pre-rasterization) and [`stages`] includes a geometry shader stage, and does not include any tessellation shader stages, its shader code  **must**  contain an `OpExecutionMode` instruction specifying an input primitive type that is [compatible](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#shaders-geometry-execution) with the primitive topology specified in `pInputAssembly`
/// - If the pipeline is being created with [pre-rasterization shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-pre-rasterization)
///   and [`stages`] includes a geometry shader stage, and also includes tessellation shader stages,
///   its shader code  **must**  contain an `OpExecutionMode` instruction specifying an input primitive
///   type that is [compatible](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#shaders-geometry-execution)
///   with the primitive topology that is output by the tessellation stages
/// - If the pipeline is being created with [pre-rasterization shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-pre-rasterization)
///   and [fragment shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-fragment-shader),
///   it includes both a fragment shader and a geometry shader, and the fragment shader code reads
///   from an input variable that is decorated with `PrimitiveId`, then the geometry shader code
///   **must**  write to a matching output variable, decorated with `PrimitiveId`, in all execution
///   paths
/// - If the pipeline is being created with [pre-rasterization shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-pre-rasterization),
///   it includes a mesh shader and the fragment shader code reads from an input variable that is
///   decorated with `PrimitiveId`, then the mesh shader code  **must**  write to a matching output
///   variable, decorated with `PrimitiveId`, in all execution paths
/// -    If [`render_pass`] is not [`crate::utils::Handle::null`] and the pipeline is being created with [fragment shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-fragment-shader) the fragment shader  **must**  not read from any input attachment that is defined as [`ATTACHMENT_UNUSED`] in [`subpass`]
/// -    If the pipeline is being created with [pre-rasterization shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-pre-rasterization) and multiple pre-rasterization shader stages are included in [`stages`], the shader code for the entry points identified by those [`stages`] and the rest of the state identified by this structure  **must**  adhere to the pipeline linking rules described in the [Shader Interfaces](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#interfaces) chapter
/// -    If the pipeline is being created with [pre-rasterization shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-pre-rasterization) and [fragment shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-fragment-shader), the fragment shader and last [pre-rasterization shader stage](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-pre-rasterization) and any relevant state  **must**  adhere to the pipeline linking rules described in the [Shader Interfaces](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#interfaces) chapter
/// -    If [`render_pass`] is not [`crate::utils::Handle::null`], the pipeline is being created with [fragment shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-fragment-shader), and [`subpass`] uses a depth/stencil attachment in [`render_pass`] with a read-only layout for the depth aspect in the [`AttachmentReference`] defined by [`subpass`], the `depthWriteEnable` member of [`depth_stencil_state`] **must**  be [`FALSE`]
/// -    If [`render_pass`] is not [`crate::utils::Handle::null`], the pipeline is being created with [fragment shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-fragment-shader), and [`subpass`] uses a depth/stencil attachment in [`render_pass`] with a read-only layout for the stencil aspect in the [`AttachmentReference`] defined by [`subpass`], the `failOp`, `passOp` and `depthFailOp` members of each of the `front` and `back` members of [`depth_stencil_state`] **must**  be `VK_STENCIL_OP_KEEP`
/// -    If [`render_pass`] is not [`crate::utils::Handle::null`], and the pipeline is being created with [fragment output interface state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-fragment-output), then for each color attachment in the subpass, if the [potential format features](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#potential-format-features) of the format of the corresponding attachment description do not contain `VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT`, then the `blendEnable` member of the corresponding element of the `pAttachments` member of [`color_blend_state`] **must**  be [`FALSE`]
/// -    If [`render_pass`] is not [`crate::utils::Handle::null`], and the pipeline is being created with [fragment output interface state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-fragment-output), and the subpass uses color attachments, the `attachmentCount` member of [`color_blend_state`] **must**  be equal to the `colorAttachmentCount` used to create [`subpass`]
/// - If the pipeline is being created with [pre-rasterization shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-pre-rasterization),
///   and no element of the `pDynamicStates` member of [`dynamic_state`] is
///   `VK_DYNAMIC_STATE_VIEWPORT` or `VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT`, the `pViewports` member
///   of [`viewport_state`] **must**  be a valid pointer to an array of
///   `pViewportState->viewportCount` valid [`Viewport`] structures
/// - If the pipeline is being created with [pre-rasterization shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-pre-rasterization),
///   and no element of the `pDynamicStates` member of [`dynamic_state`] is
///   `VK_DYNAMIC_STATE_SCISSOR` or `VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT`, the `pScissors` member of
///   [`viewport_state`] **must**  be a valid pointer to an array of
///   `pViewportState->scissorCount`[`Rect2D`] structures
/// - If the pipeline is being created with [pre-rasterization shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-pre-rasterization),
///   and the wide lines feature is not enabled, and no element of the `pDynamicStates` member of
///   [`dynamic_state`] is `VK_DYNAMIC_STATE_LINE_WIDTH`, the `lineWidth` member of
///   [`rasterization_state`] **must**  be `1.0`
/// - If the pipeline is being created with [pre-rasterization shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-pre-rasterization),
///   and the `rasterizerDiscardEnable` member of [`rasterization_state`] is [`FALSE`],
///   [`viewport_state`] **must**  be a valid pointer to a valid [`PipelineViewportStateCreateInfo`]
///   structure
/// - If the pipeline is being created with [pre-rasterization shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-pre-rasterization),
///   and the graphics pipeline state was created with the
///   `VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE` dynamic state enabled, [`viewport_state`]
///   **must**  be a valid pointer to a valid [`PipelineViewportStateCreateInfo`] structure
/// - If the pipeline is being created with [fragment shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-fragment-shader),
///   [`multisample_state`] **must**  be a valid pointer to a valid
///   [`PipelineMultisampleStateCreateInfo`] structure
/// -    If [`render_pass`] is not [`crate::utils::Handle::null`], the pipeline is being created with [fragment shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-fragment-shader), and [`subpass`] uses a depth/stencil attachment, [`depth_stencil_state`] **must**  be a valid pointer to a valid [`PipelineDepthStencilStateCreateInfo`] structure
/// -    If [`render_pass`] is not [`crate::utils::Handle::null`], the pipeline is being created with [fragment output interface state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-fragment-output), and [`subpass`] uses color attachments, [`color_blend_state`] **must**  be a valid pointer to a valid [`PipelineColorBlendStateCreateInfo`] structure
/// - If the pipeline is being created with [pre-rasterization shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-pre-rasterization),
///   the depth bias clamping feature is not enabled, no element of the `pDynamicStates` member of
///   [`dynamic_state`] is `VK_DYNAMIC_STATE_DEPTH_BIAS`, and the `depthBiasEnable` member of
///   [`rasterization_state`] is [`TRUE`], the `depthBiasClamp` member of [`rasterization_state`]
///   **must**  be `0.0`
/// - If the pipeline is being created with [fragment shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-fragment-shader),
///   and the `[`VK_EXT_depth_range_unrestricted`]` extension is not enabled and no element of the
///   `pDynamicStates` member of [`dynamic_state`] is `VK_DYNAMIC_STATE_DEPTH_BOUNDS`, and the
///   `depthBoundsTestEnable` member of [`depth_stencil_state`] is [`TRUE`], the `minDepthBounds`
///   and `maxDepthBounds` members of [`depth_stencil_state`] **must**  be between `0.0` and `1.0`,
///   inclusive
/// - If the pipeline is being created with [fragment shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-fragment-shader),
///   and no element of the `pDynamicStates` member of [`dynamic_state`] is
///   `VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT`, and the `sampleLocationsEnable` member of a
///   [`PipelineSampleLocationsStateCreateInfoEXT`] structure included in the [`p_next`] chain of
///   [`multisample_state`] is [`TRUE`], `sampleLocationsInfo.sampleLocationGridSize.width` **must**
///   evenly divide [`MultisamplePropertiesEXT`]::`sampleLocationGridSize.width` as returned by
///   [`GetPhysicalDeviceMultisamplePropertiesEXT`] with a `samples` parameter equaling
///   `rasterizationSamples`
/// - If the pipeline is being created with [fragment shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-fragment-shader),
///   and no element of the `pDynamicStates` member of [`dynamic_state`] is
///   `VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT`, and the `sampleLocationsEnable` member of a
///   [`PipelineSampleLocationsStateCreateInfoEXT`] structure included in the [`p_next`] chain of
///   [`multisample_state`] is [`TRUE`], `sampleLocationsInfo.sampleLocationGridSize.height`
///   **must**  evenly divide [`MultisamplePropertiesEXT`]::`sampleLocationGridSize.height` as
///   returned by [`GetPhysicalDeviceMultisamplePropertiesEXT`] with a `samples` parameter equaling
///   `rasterizationSamples`
/// - If the pipeline is being created with [fragment shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-fragment-shader),
///   and no element of the `pDynamicStates` member of [`dynamic_state`] is
///   `VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT`, and the `sampleLocationsEnable` member of a
///   [`PipelineSampleLocationsStateCreateInfoEXT`] structure included in the [`p_next`] chain of
///   [`multisample_state`] is [`TRUE`], `sampleLocationsInfo.sampleLocationsPerPixel` **must**
///   equal `rasterizationSamples`
/// - If the pipeline is being created with [fragment shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-fragment-shader),
///   and the `sampleLocationsEnable` member of a [`PipelineSampleLocationsStateCreateInfoEXT`]
///   structure included in the [`p_next`] chain of [`multisample_state`] is [`TRUE`], the fragment
///   shader code  **must**  not statically use the extended instruction `InterpolateAtSample`
/// - [`layout`] **must**  be [consistent](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-pipelinelayout-consistency)
///   with all shaders specified in [`stages`]
/// - If the pipeline is being created with [fragment shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-fragment-shader),
///   and neither the `[`VK_AMD_mixed_attachment_samples`]` nor the
///   `[`VK_NV_framebuffer_mixed_samples`]` extensions are enabled, and if [`subpass`] uses color
///   and/or depth/stencil attachments, then the `rasterizationSamples` member of
///   [`multisample_state`] **must**  be the same as the sample count for those subpass attachments
/// - If the pipeline is being created with [fragment shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-fragment-shader),
///   and the `[`VK_AMD_mixed_attachment_samples`]` extension is enabled, and if [`subpass`] uses
///   color and/or depth/stencil attachments, then the `rasterizationSamples` member of
///   [`multisample_state`] **must**  equal the maximum of the sample counts of those subpass
///   attachments
/// - If the pipeline is being created with [fragment shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-fragment-shader),
///   and the `[`VK_NV_framebuffer_mixed_samples`]` extension is enabled, and if [`subpass`] has a
///   depth/stencil attachment and depth test, stencil test, or depth bounds test are enabled, then
///   the `rasterizationSamples` member of [`multisample_state`] **must**  be the same as the sample
///   count of the depth/stencil attachment
/// - If the pipeline is being created with [fragment shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-fragment-shader),
///   and the `[`VK_NV_framebuffer_mixed_samples`]` extension is enabled, and if [`subpass`] has any
///   color attachments, then the `rasterizationSamples` member of [`multisample_state`] **must**
///   be greater than or equal to the sample count for those subpass attachments
/// - If the pipeline is being created with [fragment shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-fragment-shader),
///   and the `[`VK_NV_coverage_reduction_mode`]` extension is enabled, the coverage reduction mode
///   specified by [`PipelineCoverageReductionStateCreateInfoNV::coverage_reduction_mode`], the
///   `rasterizationSamples` member of [`multisample_state`] and the sample counts for the color and
///   depth/stencil attachments (if the subpass has them)  **must**  be a valid combination returned
///   by [`GetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV`]
/// -    If the pipeline is being created with [fragment shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-fragment-shader) and [`subpass`] does not use any color and/or depth/stencil attachments, then the `rasterizationSamples` member of [`multisample_state`] **must**  follow the rules for a [zero-attachment subpass](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-noattachments)
/// - If [`render_pass`] is a valid renderPass, [`subpass`] **must**  be a valid subpass within
///   [`render_pass`]
/// -    If [`render_pass`] is a valid renderPass, the pipeline is being created with [pre-rasterization shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-pre-rasterization), and the [`render_pass`] has multiview enabled and [`subpass`] has more than one bit set in the view mask and `multiviewTessellationShader` is not enabled, then [`stages`] **must**  not include tessellation shaders
/// -    If [`render_pass`] is a valid renderPass, the pipeline is being created with [pre-rasterization shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-pre-rasterization), and the [`render_pass`] has multiview enabled and [`subpass`] has more than one bit set in the view mask and `multiviewGeometryShader` is not enabled, then [`stages`] **must**  not include a geometry shader
/// -    If [`render_pass`] is a valid renderPass, the pipeline is being created with [pre-rasterization shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-pre-rasterization), and the [`render_pass`] has multiview enabled and [`subpass`] has more than one bit set in the view mask, shaders in the pipeline  **must**  not write to the `Layer` built-in output
/// -    If [`render_pass`] is a valid renderPass and the pipeline is being created with [pre-rasterization shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-pre-rasterization), and the [`render_pass`] has multiview enabled, then all shaders  **must**  not include variables decorated with the `Layer` built-in decoration in their interfaces
/// - [`flags`] **must**  not contain the `VK_PIPELINE_CREATE_DISPATCH_BASE` flag
/// - If the pipeline is being created with [fragment shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-fragment-shader)
///   and an input attachment was referenced by an `aspectMask` at [`render_pass`] creation time,
///   the fragment shader  **must**  only read from the aspects that were specified for that input
///   attachment
/// - The number of resources in [`layout`] accessible to each shader stage that is used by the
///   pipeline  **must**  be less than or equal to [`PhysicalDeviceLimits::max_per_stage_resources`]
/// - If the pipeline is being created with [pre-rasterization shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-pre-rasterization),
///   and no element of the `pDynamicStates` member of [`dynamic_state`] is
///   `VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV`, and the `viewportWScalingEnable` member of a
///   [`PipelineViewportWScalingStateCreateInfoNV`] structure, included in the [`p_next`] chain of
///   [`viewport_state`], is [`TRUE`], the `pViewportWScalings` member of the
///   [`PipelineViewportWScalingStateCreateInfoNV`] **must**  be a pointer to an array of
///   [`PipelineViewportWScalingStateCreateInfoNV::viewport_count`] valid [`ViewportWScalingNV`]
///   structures
/// - If the pipeline is being created with [pre-rasterization shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-pre-rasterization),
///   and no element of the `pDynamicStates` member of [`dynamic_state`] is
///   `VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_NV`, and if `pViewportState->pNext` chain includes a
///   [`PipelineViewportExclusiveScissorStateCreateInfoNV`] structure, and if its
///   `exclusiveScissorCount` member is not `0`, then its `pExclusiveScissors` member  **must**  be
///   a valid pointer to an array of `exclusiveScissorCount`[`Rect2D`] structures
/// - If the pipeline is being created with [pre-rasterization shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-pre-rasterization),
///   and no element of the `pDynamicStates` member of [`dynamic_state`] is
///   `VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV`, and if `pViewportState->pNext` chain
///   includes a [`PipelineViewportShadingRateImageStateCreateInfoNV`] structure, then its
///   `pShadingRatePalettes` member  **must**  be a valid pointer to an array of `viewportCount`
///   valid [`ShadingRatePaletteNV`] structures
/// - If the pipeline is being created with [pre-rasterization shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-pre-rasterization),
///   and no element of the `pDynamicStates` member of [`dynamic_state`] is
///   `VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT`, and if [`p_next`] chain includes a
///   [`PipelineDiscardRectangleStateCreateInfoEXT`] structure, and if its `discardRectangleCount`
///   member is not `0`, then its `pDiscardRectangles` member  **must**  be a valid pointer to an
///   array of `discardRectangleCount`[`Rect2D`] structures
/// - If the pipeline is being created with [vertex input state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-vertex-input),
///   and `VK_DYNAMIC_STATE_VERTEX_INPUT_EXT` is not set, [`vertex_input_state`] **must**  be a
///   valid pointer to a valid [`PipelineVertexInputStateCreateInfo`] structure
/// - If the pipeline is being created with [vertex input state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-vertex-input),
///   [`input_assembly_state`] **must**  be a valid pointer to a valid
///   [`PipelineInputAssemblyStateCreateInfo`] structure
/// - If the pipeline is being created with [pre-rasterization shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-pre-rasterization),
///   the `Xfb` execution mode  **can**  be specified by no more than one shader stage in [`stages`]
/// -    If the pipeline is being created with [pre-rasterization shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-pre-rasterization), and any shader stage in [`stages`] specifies `Xfb` execution mode it  **must**  be the last [pre-rasterization shader stage](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-pre-rasterization)
/// - If the pipeline is being created with [pre-rasterization shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-pre-rasterization),
///   and a [`PipelineRasterizationStateStreamCreateInfoEXT::rasterization_stream`] value other than
///   zero is specified, all variables in the output interface of the entry point being compiled
///   decorated with `Position`, `PointSize`, `ClipDistance`, or `CullDistance` **must**  be
///   decorated with identical `Stream` values that match the `rasterizationStream`
/// - If the pipeline is being created with [pre-rasterization shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-pre-rasterization),
///   and [`PipelineRasterizationStateStreamCreateInfoEXT::rasterization_stream`] is zero, or not
///   specified, all variables in the output interface of the entry point being compiled decorated
///   with `Position`, `PointSize`, `ClipDistance`, or `CullDistance` **must**  be decorated with a
///   `Stream` value of zero, or  **must**  not specify the `Stream` decoration
/// - If the pipeline is being created with [pre-rasterization shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-pre-rasterization),
///   and the last [pre-rasterization shader stage](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-pre-rasterization)
///   is a geometry shader, and that geometry shader uses the `GeometryStreams` capability, then
///   [`PhysicalDeviceTransformFeedbackFeaturesEXT::geometry_streams`] feature  **must**  be enabled
/// - If the pipeline is being created with [pre-rasterization shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-pre-rasterization),
///   and there are any mesh shader stages in the pipeline there  **must**  not be any shader stage
///   in the pipeline with a `Xfb` execution mode
/// - If the pipeline is being created with [pre-rasterization shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-pre-rasterization)
///   and at least one of [fragment output interface state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-fragment-output)
///   or [fragment shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-fragment-shader),
///   the `lineRasterizationMode` member of a [`PipelineRasterizationLineStateCreateInfoEXT`]
///   structure included in the [`p_next`] chain of [`rasterization_state`] is
///   `VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT` or
///   `VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_EXT`, then the `alphaToCoverageEnable`,
///   `alphaToOneEnable`, and `sampleShadingEnable` members of [`multisample_state`] **must**  all
///   be [`FALSE`]
/// - If the pipeline is being created with [pre-rasterization shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-pre-rasterization),
///   the `stippledLineEnable` member of [`PipelineRasterizationLineStateCreateInfoEXT`] is
///   [`TRUE`], and no element of the `pDynamicStates` member of [`dynamic_state`] is
///   `VK_DYNAMIC_STATE_LINE_STIPPLE_EXT`, then the `lineStippleFactor` member of
///   [`PipelineRasterizationLineStateCreateInfoEXT`] **must**  be in the range [1,256]
/// - [`flags`] **must**  not include `VK_PIPELINE_CREATE_LIBRARY_BIT_KHR`
/// - [`flags`] **must**  not include
///   `VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR`
/// - [`flags`] **must**  not include
///   `VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR`
/// - [`flags`] **must**  not include `VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR`
/// - [`flags`] **must**  not include
///   `VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR`
/// - [`flags`] **must**  not include `VK_PIPELINE_CREATE_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR`
/// - [`flags`] **must**  not include `VK_PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR`
/// - [`flags`] **must**  not include
///   `VK_PIPELINE_CREATE_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR`
/// - [`flags`] **must**  not include `VK_PIPELINE_CREATE_RAY_TRACING_ALLOW_MOTION_BIT_NV`
/// - If the pipeline is being created with [pre-rasterization shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-pre-rasterization),
///   and `VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT` is included in the `pDynamicStates` array then
///   `viewportCount` **must**  be zero
/// - If the pipeline is being created with [pre-rasterization shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-pre-rasterization),
///   and `VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT` is included in the `pDynamicStates` array then
///   `scissorCount` **must**  be zero
/// - If the pipeline is being created with [pre-rasterization shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-pre-rasterization),
///   and `VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT` is included in the `pDynamicStates` array then
///   `VK_DYNAMIC_STATE_VIEWPORT` **must**  not be present
/// - If the pipeline is being created with [pre-rasterization shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-pre-rasterization),
///   and `VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT` is included in the `pDynamicStates` array then
///   `VK_DYNAMIC_STATE_SCISSOR` **must**  not be present
/// - If the [extendedDynamicState2LogicOp](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-extendedDynamicState2LogicOp)
///   feature is not enabled, there  **must**  be no element of the `pDynamicStates` member of
///   [`dynamic_state`] set to `VK_DYNAMIC_STATE_LOGIC_OP_EXT`
/// - If the [extendedDynamicState2PatchControlPoints](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-extendedDynamicState2PatchControlPoints)
///   feature is not enabled, there  **must**  be no element of the `pDynamicStates` member of
///   [`dynamic_state`] set to `VK_DYNAMIC_STATE_PATCH_CONTROL_POINTS_EXT`
/// - If [`flags`] includes `VK_PIPELINE_CREATE_INDIRECT_BINDABLE_BIT_NV`, then the [[`PhysicalDeviceDeviceGeneratedCommandsFeaturesNV::device_generated_commands`]](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-deviceGeneratedCommands)
///   feature  **must**  be enabled
/// - If the pipeline is being created with [pre-rasterization shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-pre-rasterization)
///   and [`flags`] includes `VK_PIPELINE_CREATE_INDIRECT_BINDABLE_BIT_NV`, then all stages
///   **must**  not specify `Xfb` execution mode
/// - If the [`pipelineCreationCacheControl`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-pipelineCreationCacheControl)
///   feature is not enabled, [`flags`] **must**  not include
///   `VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT` or
///   `VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT`
/// - If the pipeline is being created with [pre-rasterization shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-pre-rasterization)
///   or [fragment shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-fragment-shader)
///   and `VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR` is not included in
///   `pDynamicState->pDynamicStates`,
///   [`PipelineFragmentShadingRateStateCreateInfoKHR`]::`fragmentSize.width` **must**  be greater
///   than or equal to `1`
/// - If the pipeline is being created with [pre-rasterization shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-pre-rasterization)
///   or [fragment shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-fragment-shader)
///   and `VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR` is not included in
///   `pDynamicState->pDynamicStates`,
///   [`PipelineFragmentShadingRateStateCreateInfoKHR`]::`fragmentSize.height` **must**  be greater
///   than or equal to `1`
/// - If the pipeline is being created with [pre-rasterization shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-pre-rasterization)
///   or [fragment shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-fragment-shader)
///   and `VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR` is not included in
///   `pDynamicState->pDynamicStates`,
///   [`PipelineFragmentShadingRateStateCreateInfoKHR`]::`fragmentSize.width` **must**  be a
///   power-of-two value
/// - If the pipeline is being created with [pre-rasterization shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-pre-rasterization)
///   or [fragment shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-fragment-shader)
///   and `VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR` is not included in
///   `pDynamicState->pDynamicStates`,
///   [`PipelineFragmentShadingRateStateCreateInfoKHR`]::`fragmentSize.height` **must**  be a
///   power-of-two value
/// - If the pipeline is being created with [pre-rasterization shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-pre-rasterization)
///   or [fragment shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-fragment-shader)
///   and `VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR` is not included in
///   `pDynamicState->pDynamicStates`,
///   [`PipelineFragmentShadingRateStateCreateInfoKHR`]::`fragmentSize.width` **must**  be less than
///   or equal to `4`
/// - If the pipeline is being created with [pre-rasterization shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-pre-rasterization)
///   or [fragment shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-fragment-shader)
///   and `VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR` is not included in
///   `pDynamicState->pDynamicStates`,
///   [`PipelineFragmentShadingRateStateCreateInfoKHR`]::`fragmentSize.height` **must**  be less
///   than or equal to `4`
/// -    If the pipeline is being created with [pre-rasterization shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-pre-rasterization) or [fragment shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-fragment-shader) and `VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR` is not included in `pDynamicState->pDynamicStates`, and the [`pipelineFragmentShadingRate` feature](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-pipelineFragmentShadingRate) is not enabled, [`PipelineFragmentShadingRateStateCreateInfoKHR`]::`fragmentSize.width` and [`PipelineFragmentShadingRateStateCreateInfoKHR`]::`fragmentSize.height` **must**  both be equal to `1`
/// -    If the pipeline is being created with [pre-rasterization shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-pre-rasterization) or [fragment shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-fragment-shader) and `VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR` is not included in `pDynamicState->pDynamicStates`, and the [`primitiveFragmentShadingRate` feature](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-primitiveFragmentShadingRate) is not enabled, [`PipelineFragmentShadingRateStateCreateInfoKHR::combiner_ops`][0]  **must**  be `VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR`
/// -    If the pipeline is being created with [pre-rasterization shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-pre-rasterization) or [fragment shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-fragment-shader) and `VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR` is not included in `pDynamicState->pDynamicStates`, and the [`attachmentFragmentShadingRate` feature](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-attachmentFragmentShadingRate) is not enabled, [`PipelineFragmentShadingRateStateCreateInfoKHR::combiner_ops`][1]  **must**  be `VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR`
/// - If the pipeline is being created with [pre-rasterization shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-pre-rasterization)
///   and the [`primitiveFragmentShadingRateWithMultipleViewports`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#limits-primitiveFragmentShadingRateWithMultipleViewports)
///   limit is not supported, `VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT` is not included in
///   `pDynamicState->pDynamicStates`, and [`PipelineViewportStateCreateInfo::viewport_count`] is
///   greater than `1`, entry points specified in [`stages`] **must**  not write to the
///   `PrimitiveShadingRateKHR` built-in
/// - If the pipeline is being created with [pre-rasterization shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-pre-rasterization)
///   and the [`primitiveFragmentShadingRateWithMultipleViewports`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#limits-primitiveFragmentShadingRateWithMultipleViewports)
///   limit is not supported, and entry points specified in [`stages`] write to the `ViewportIndex`
///   built-in, they  **must**  not also write to the `PrimitiveShadingRateKHR` built-in
/// - If the pipeline is being created with [pre-rasterization shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-pre-rasterization)
///   and the [`primitiveFragmentShadingRateWithMultipleViewports`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#limits-primitiveFragmentShadingRateWithMultipleViewports)
///   limit is not supported, and entry points specified in [`stages`] write to the `ViewportMaskNV`
///   built-in, they  **must**  not also write to the `PrimitiveShadingRateKHR` built-in
/// - If the pipeline is being created with [pre-rasterization shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-pre-rasterization)
///   or [fragment shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-fragment-shader),
///   the [`fragmentShadingRateNonTrivialCombinerOps`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#limits-fragmentShadingRateNonTrivialCombinerOps)
///   limit is not supported, and `VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR` is not included in
///   `pDynamicState->pDynamicStates`, elements of
///   [`PipelineFragmentShadingRateStateCreateInfoKHR::combiner_ops`] **must**  be
///   `VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR` or
///   `VK_FRAGMENT_SHADING_RATE_COMBINER_OP_REPLACE_KHR`
/// -    If the pipeline is being created with [pre-rasterization shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-pre-rasterization) or [fragment shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-fragment-shader), and `VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR` is not included in `pDynamicState->pDynamicStates`, and the [`fragmentShadingRateEnums` feature](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-fragmentShadingRateEnums) is not enabled, [`PipelineFragmentShadingRateEnumStateCreateInfoNV::shading_rate_type`] **must**  be equal to `VK_FRAGMENT_SHADING_RATE_TYPE_FRAGMENT_SIZE_NV`
/// -    If the pipeline is being created with [pre-rasterization shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-pre-rasterization) or [fragment shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-fragment-shader), and `VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR` is not included in `pDynamicState->pDynamicStates`, and the [`pipelineFragmentShadingRate` feature](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-pipelineFragmentShadingRate) is not enabled, [`PipelineFragmentShadingRateEnumStateCreateInfoNV::shading_rate`] **must**  be equal to `VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_PIXEL_NV`
/// -    If the pipeline is being created with [pre-rasterization shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-pre-rasterization) or [fragment shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-fragment-shader), and `VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR` is not included in `pDynamicState->pDynamicStates`, and the [`primitiveFragmentShadingRate` feature](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-primitiveFragmentShadingRate) is not enabled, [`PipelineFragmentShadingRateEnumStateCreateInfoNV::combiner_ops`][0]  **must**  be `VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR`
/// -    If the pipeline is being created with [pre-rasterization shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-pre-rasterization) or [fragment shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-fragment-shader), and `VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR` is not included in `pDynamicState->pDynamicStates`, and the [`attachmentFragmentShadingRate` feature](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-attachmentFragmentShadingRate) is not enabled, [`PipelineFragmentShadingRateEnumStateCreateInfoNV::combiner_ops`][1]  **must**  be `VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR`
/// - If the pipeline is being created with [pre-rasterization shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-pre-rasterization)
///   or [fragment shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-fragment-shader),
///   and the [`fragmentShadingRateNonTrivialCombinerOps`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#limits-fragmentShadingRateNonTrivialCombinerOps)
///   limit is not supported and `VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR` is not included in
///   `pDynamicState->pDynamicStates`, elements of
///   [`PipelineFragmentShadingRateEnumStateCreateInfoNV::combiner_ops`] **must**  be
///   `VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR` or
///   `VK_FRAGMENT_SHADING_RATE_COMBINER_OP_REPLACE_KHR`
/// - If the pipeline is being created with [pre-rasterization shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-pre-rasterization)
///   or [fragment shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-fragment-shader),
///   and the [supersampleFragmentShadingRates feature](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-supersampleFragmentShadingRates)
///   is not enabled, [`PipelineFragmentShadingRateEnumStateCreateInfoNV::shading_rate`] **must**
///   not be equal to `VK_FRAGMENT_SHADING_RATE_2_INVOCATIONS_PER_PIXEL_NV`,
///   `VK_FRAGMENT_SHADING_RATE_4_INVOCATIONS_PER_PIXEL_NV`,
///   `VK_FRAGMENT_SHADING_RATE_8_INVOCATIONS_PER_PIXEL_NV`, or
///   `VK_FRAGMENT_SHADING_RATE_16_INVOCATIONS_PER_PIXEL_NV`
/// - If the pipeline is being created with [pre-rasterization shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-pre-rasterization)
///   or [fragment shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-fragment-shader),
///   and the [noInvocationFragmentShadingRates feature](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-noInvocationFragmentShadingRates)
///   is not enabled, [`PipelineFragmentShadingRateEnumStateCreateInfoNV::shading_rate`] **must**
///   not be equal to `VK_FRAGMENT_SHADING_RATE_NO_INVOCATIONS_NV`
/// - All elements of the `pDynamicStates` member of [`dynamic_state`] **must**  not be
///   `VK_DYNAMIC_STATE_RAY_TRACING_PIPELINE_STACK_SIZE_KHR`
/// - If the pipeline is being created with [pre-rasterization shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-pre-rasterization)
///   and the [vertexInputDynamicState](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-vertexInputDynamicState)
///   feature is not enabled, there  **must**  be no element of the `pDynamicStates` member of
///   [`dynamic_state`] set to `VK_DYNAMIC_STATE_VERTEX_INPUT_EXT`
/// - The pipeline  **must**  be created with a [complete set of state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-complete)
/// - If the [colorWriteEnable](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-colorWriteEnable)
///   feature is not enabled, there  **must**  be no element of the `pDynamicStates` member of
///   [`dynamic_state`] set to `VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT`
/// - If the pipeline is being created with fragment shader state, and the
///   [`VK_QCOM_render_pass_shader_resolve`] extension is enabled, and if subpass has any input
///   attachments, and if the subpass description contains
///   `VK_SUBPASS_DESCRIPTION_FRAGMENT_REGION_BIT_QCOM`, then the sample count of the input
///   attachments  **must**  equal `rasterizationSamples`
/// - If the pipeline is being created with fragment shader state, and the
///   [`VK_QCOM_render_pass_shader_resolve`] extension is enabled, and if the subpass description
///   contains `VK_SUBPASS_DESCRIPTION_FRAGMENT_REGION_BIT_QCOM`, then `sampleShadingEnable`
///   **must**  be false
/// - If [`flags`] includes `VK_SUBPASS_DESCRIPTION_SHADER_RESOLVE_BIT_QCOM`, then the subpass
///   **must**  be the last subpass in a subpass dependency chain
/// - If [`flags`] includes `VK_SUBPASS_DESCRIPTION_SHADER_RESOLVE_BIT_QCOM`, and if
///   `pResolveAttachments` is not `NULL`, then each resolve attachment  **must**  be
///   [`ATTACHMENT_UNUSED`]
/// - If the [`dynamicRendering`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-dynamicRendering)
///   feature is not enabled, [`render_pass`] **must**  not be [`crate::utils::Handle::null`]
/// -    If [`render_pass`] is [`crate::utils::Handle::null`], the pipeline is being created with [fragment shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-fragment-shader), and either of [`PipelineRenderingCreateInfo`]::depthAttachmentFormat or [`PipelineRenderingCreateInfo`]::stencilAttachmentFormat are not `VK_FORMAT_UNDEFINED`, [`depth_stencil_state`] **must**  be a valid pointer to a valid [`PipelineDepthStencilStateCreateInfo`] structure
/// -    If [`render_pass`] is [`crate::utils::Handle::null`], the pipeline is being created with [fragment output interface state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-fragment-output), and [`PipelineRenderingCreateInfo`]::colorAttachmentCount is not equal to `0`, [`color_blend_state`] **must**  be a valid pointer to a valid [`PipelineColorBlendStateCreateInfo`] structure
/// -    If [`render_pass`] is [`crate::utils::Handle::null`] and the pipeline is being created with [fragment output interface state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-fragment-output), `pColorBlendState->attachmentCount` **must**  be equal to [`PipelineRenderingCreateInfo`]::colorAttachmentCount
/// -    If [`render_pass`] is [`crate::utils::Handle::null`] and the pipeline is being created with [fragment shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-fragment-shader) the fragment shader  **must**  not read from any input attachment
/// -    If [`render_pass`] is [`crate::utils::Handle::null`], the pipeline is being created with [pre-rasterization shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-pre-rasterization), the `viewMask` member of a [`PipelineRenderingCreateInfo`] structure included in the [`p_next`] chain is not `0`, and the [`multiviewTessellationShader`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-multiview-tess) feature is not enabled, then [`stages`] **must**  not include tessellation shaders
/// -    If [`render_pass`] is [`crate::utils::Handle::null`], the pipeline is being created with [pre-rasterization shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-pre-rasterization), the `viewMask` member of a [`PipelineRenderingCreateInfo`] structure included in the [`p_next`] chain is not `0`, and the [`multiviewGeometryShader`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-multiview-gs) feature is not enabled, then [`stages`] **must**  not include a geometry shader
/// -    If [`render_pass`] is [`crate::utils::Handle::null`], the pipeline is being created with [pre-rasterization shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-pre-rasterization), and the `viewMask` member of a [`PipelineRenderingCreateInfo`] structure included in the [`p_next`] chain is not `0`, shaders in [`stages`] **must**  not include variables decorated with the `Layer` built-in decoration in their interfaces
/// - If the pipeline is being created with [fragment output interface state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-fragment-output)
///   and [`render_pass`] is [`crate::utils::Handle::null`], `pColorBlendState->attachmentCount`
///   **must**  be equal to the `colorAttachmentCount` member of the [`PipelineRenderingCreateInfo`]
///   structure included in the [`p_next`] chain
/// - If the pipeline is being created with [fragment shader state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-fragment-shader)
///   and [`render_pass`] is [`crate::utils::Handle::null`], fragment shaders in [`stages`] **must**
///   not include the `InputAttachment` capability
/// -    If the pipeline is being created with [fragment output interface state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-fragment-output) and [`render_pass`] is [`crate::utils::Handle::null`], for each color attachment format defined by the `pColorAttachmentFormats` member of [`PipelineRenderingCreateInfo`], if its [potential format features](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#potential-format-features) do not contain `VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT`, then the `blendEnable` member of the corresponding element of the `pAttachments` member of [`color_blend_state`] **must**  be [`FALSE`]
/// - If the pipeline is being created with [fragment output interface state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-fragment-output)
///   and [`render_pass`] is [`crate::utils::Handle::null`], if the [`p_next`] chain includes
///   [`AttachmentSampleCountInfoAMD`] or [`AttachmentSampleCountInfoNV`], the
///   `colorAttachmentCount` member of that structure  **must**  be equal to the value of
///   [`PipelineRenderingCreateInfo::color_attachment_count`]
/// -    If [`stages`] includes a fragment shader stage, and the fragment shader code enables [early fragment tests](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#shaders-fragment-earlytest), the [`flags`] member of [`PipelineDepthStencilStateCreateInfo`] **must**  not include `VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_ARM` or `VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_ARM`
/// - If the pipeline is being created with [fragment output interface state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-fragment-output)
///   and the [`flags`] member of [`PipelineColorBlendStateCreateInfo`] includes
///   `VK_PIPELINE_COLOR_BLEND_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_ARM`,
///   `renderpass` **must**  not be [`crate::utils::Handle::null`]
/// - If the pipeline is being created with [fragment output interface state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-fragment-output)
///   and the [`flags`] member of [`PipelineDepthStencilStateCreateInfo`] includes
///   `VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_ARM`
///   or `VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_ARM`,
///   `renderpass` **must**  not be [`crate::utils::Handle::null`]
/// - If the pipeline is being created with [fragment output interface state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-fragment-output)
///   and the [`flags`] member of [`PipelineColorBlendStateCreateInfo`] includes
///   `VK_PIPELINE_COLOR_BLEND_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_ARM`[`subpass`]
///   **must**  have been created with
///   `VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_COLOR_ACCESS_BIT_ARM`
/// - If the pipeline is being created with [fragment output interface state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-fragment-output)
///   and the [`flags`] member of [`PipelineDepthStencilStateCreateInfo`] includes
///   `VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_ARM`,
///   [`subpass`] **must**  have been created with
///   `VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_ARM`
/// - If the pipeline is being created with [fragment output interface state](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-fragment-output)
///   and the [`flags`] member of [`PipelineDepthStencilStateCreateInfo`] includes
///   `VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_ARM`,
///   [`subpass`] **must**  have been created with
///   `VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_ARM`
///
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be `VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO`
/// - Each [`p_next`] member of any structure (including this one) in the [`p_next`] chain  **must**
///   be either `NULL` or a pointer to a valid instance of [`AttachmentSampleCountInfoAMD`],
///   [`GraphicsPipelineShaderGroupsCreateInfoNV`], [`MultiviewPerViewAttributesInfoNVX`],
///   [`PipelineCompilerControlCreateInfoAMD`], [`PipelineCreationFeedbackCreateInfo`],
///   [`PipelineDiscardRectangleStateCreateInfoEXT`],
///   [`PipelineFragmentShadingRateEnumStateCreateInfoNV`],
///   [`PipelineFragmentShadingRateStateCreateInfoKHR`], [`PipelineRenderingCreateInfo`], or
///   [`PipelineRepresentativeFragmentTestStateCreateInfoNV`]
/// - The [`s_type`] value of each struct in the [`p_next`] chain  **must**  be unique
/// - [`flags`] **must**  be a valid combination of [`PipelineCreateFlagBits`] values
/// - [`stages`] **must**  be a valid pointer to an array of [`stage_count`] valid
///   [`PipelineShaderStageCreateInfo`] structures
/// - [`rasterization_state`] **must**  be a valid pointer to a valid
///   [`PipelineRasterizationStateCreateInfo`] structure
/// - If [`dynamic_state`] is not `NULL`, [`dynamic_state`] **must**  be a valid pointer to a valid
///   [`PipelineDynamicStateCreateInfo`] structure
/// - [`layout`] **must**  be a valid [`PipelineLayout`] handle
/// - If [`render_pass`] is not [`crate::utils::Handle::null`], [`render_pass`] **must**  be a valid
///   [`RenderPass`] handle
/// - [`stage_count`] **must**  be greater than `0`
/// - Each of [`base_pipeline_handle`], [`layout`], and [`render_pass`] that are valid handles of
///   non-ignored parameters  **must**  have been created, allocated, or retrieved from the same
///   [`Device`]
///# Related
/// - [`crate::vulkan1_0`]
/// - [`Pipeline`]
/// - [`PipelineColorBlendStateCreateInfo`]
/// - [`PipelineCreateFlags`]
/// - [`PipelineDepthStencilStateCreateInfo`]
/// - [`PipelineDynamicStateCreateInfo`]
/// - [`PipelineInputAssemblyStateCreateInfo`]
/// - [`PipelineLayout`]
/// - [`PipelineMultisampleStateCreateInfo`]
/// - [`PipelineRasterizationStateCreateInfo`]
/// - [`PipelineShaderStageCreateInfo`]
/// - [`PipelineTessellationStateCreateInfo`]
/// - [`PipelineVertexInputStateCreateInfo`]
/// - [`PipelineViewportStateCreateInfo`]
/// - [`RenderPass`]
/// - [`StructureType`]
/// - [`CreateGraphicsPipelines`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[repr(C)]
pub struct GraphicsPipelineCreateInfo<'lt> {
    _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] is the type of this structure.
    s_type: StructureType,
    ///[`p_next`] is `NULL` or a pointer to a structure extending this
    ///structure.
    p_next: *const BaseInStructure<'lt>,
    ///[`flags`] is a bitmask of [`PipelineCreateFlagBits`] specifying
    ///how the pipeline will be generated.
    flags: PipelineCreateFlags,
    ///[`stage_count`] is the number of entries in the [`stages`] array.
    stage_count: u32,
    ///[`stages`] is a pointer to an array of [`stage_count`][`PipelineShaderStageCreateInfo`]
    /// structures describing the set of the shader stages to be included in the graphics
    /// pipeline.
    stages: *const PipelineShaderStageCreateInfo<'lt>,
    ///[`vertex_input_state`] is a pointer to a
    ///[`PipelineVertexInputStateCreateInfo`] structure defining vertex
    ///input state for use with vertex shading.
    vertex_input_state: *const PipelineVertexInputStateCreateInfo<'lt>,
    ///[`input_assembly_state`] is a pointer to a
    ///[`PipelineInputAssemblyStateCreateInfo`] structure which determines
    ///input assembly behavior for vertex shading, as described in [Drawing Commands](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#drawing).
    input_assembly_state: *const PipelineInputAssemblyStateCreateInfo<'lt>,
    ///[`tessellation_state`] is a pointer to a
    ///[`PipelineTessellationStateCreateInfo`] structure defining
    ///tessellation state used by tessellation shaders.
    tessellation_state: *const PipelineTessellationStateCreateInfo<'lt>,
    ///[`viewport_state`] is a pointer to a
    ///[`PipelineViewportStateCreateInfo`] structure defining viewport
    ///state used when rasterization is enabled.
    viewport_state: *const PipelineViewportStateCreateInfo<'lt>,
    ///[`rasterization_state`] is a pointer to a
    ///[`PipelineRasterizationStateCreateInfo`] structure defining
    ///rasterization state.
    rasterization_state: *const PipelineRasterizationStateCreateInfo<'lt>,
    ///[`multisample_state`] is a pointer to a
    ///[`PipelineMultisampleStateCreateInfo`] structure defining
    ///multisample state used when rasterization is enabled.
    multisample_state: *const PipelineMultisampleStateCreateInfo<'lt>,
    ///[`depth_stencil_state`] is a pointer to a
    ///[`PipelineDepthStencilStateCreateInfo`] structure defining
    ///depth/stencil state used when rasterization is enabled for depth or
    ///stencil attachments accessed during rendering.
    depth_stencil_state: *const PipelineDepthStencilStateCreateInfo<'lt>,
    ///[`color_blend_state`] is a pointer to a
    ///[`PipelineColorBlendStateCreateInfo`] structure defining color blend
    ///state used when rasterization is enabled for any color attachments
    ///accessed during rendering.
    color_blend_state: *const PipelineColorBlendStateCreateInfo<'lt>,
    ///[`dynamic_state`] is a pointer to a
    ///[`PipelineDynamicStateCreateInfo`] structure defining which
    ///properties of the pipeline state object are dynamic and  **can**  be changed
    ///independently of the pipeline state.
    ///This  **can**  be `NULL`, which means no state in the pipeline is considered
    ///dynamic.
    dynamic_state: *const PipelineDynamicStateCreateInfo<'lt>,
    ///[`layout`] is the description of binding locations used by both the
    ///pipeline and descriptor sets used with the pipeline.
    layout: PipelineLayout,
    ///[`render_pass`] is a handle to a render pass object describing the
    ///environment in which the pipeline will be used.
    ///The pipeline  **must**  only be used with a render pass instance compatible
    ///with the one provided.
    ///See [Render Pass Compatibility](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-compatibility) for more
    ///information.
    render_pass: RenderPass,
    ///[`subpass`] is the index of the subpass in the render pass where this
    ///pipeline will be used.
    subpass: u32,
    ///[`base_pipeline_handle`] is a pipeline to derive from.
    base_pipeline_handle: Pipeline,
    ///[`base_pipeline_index`] is an index into the `pCreateInfos`
    ///parameter to use as a pipeline to derive from.
    base_pipeline_index: i32,
}
impl<'lt> Default for GraphicsPipelineCreateInfo<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: Default::default(),
            p_next: std::ptr::null(),
            flags: Default::default(),
            stage_count: 0,
            stages: std::ptr::null(),
            vertex_input_state: std::ptr::null(),
            input_assembly_state: std::ptr::null(),
            tessellation_state: std::ptr::null(),
            viewport_state: std::ptr::null(),
            rasterization_state: std::ptr::null(),
            multisample_state: std::ptr::null(),
            depth_stencil_state: std::ptr::null(),
            color_blend_state: std::ptr::null(),
            dynamic_state: std::ptr::null(),
            layout: Default::default(),
            render_pass: Default::default(),
            subpass: 0,
            base_pipeline_handle: Default::default(),
            base_pipeline_index: 0,
        }
    }
}
impl<'lt> GraphicsPipelineCreateInfo<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *const BaseInStructure<'lt> {
        self.p_next
    }
    ///Gets the raw value of [`Self::stages`]
    pub fn stages_raw(&self) -> *const PipelineShaderStageCreateInfo<'lt> {
        self.stages
    }
    ///Gets the raw value of [`Self::vertex_input_state`]
    pub fn vertex_input_state_raw(&self) -> *const PipelineVertexInputStateCreateInfo<'lt> {
        self.vertex_input_state
    }
    ///Gets the raw value of [`Self::input_assembly_state`]
    pub fn input_assembly_state_raw(&self) -> *const PipelineInputAssemblyStateCreateInfo<'lt> {
        self.input_assembly_state
    }
    ///Gets the raw value of [`Self::tessellation_state`]
    pub fn tessellation_state_raw(&self) -> *const PipelineTessellationStateCreateInfo<'lt> {
        self.tessellation_state
    }
    ///Gets the raw value of [`Self::viewport_state`]
    pub fn viewport_state_raw(&self) -> *const PipelineViewportStateCreateInfo<'lt> {
        self.viewport_state
    }
    ///Gets the raw value of [`Self::rasterization_state`]
    pub fn rasterization_state_raw(&self) -> *const PipelineRasterizationStateCreateInfo<'lt> {
        self.rasterization_state
    }
    ///Gets the raw value of [`Self::multisample_state`]
    pub fn multisample_state_raw(&self) -> *const PipelineMultisampleStateCreateInfo<'lt> {
        self.multisample_state
    }
    ///Gets the raw value of [`Self::depth_stencil_state`]
    pub fn depth_stencil_state_raw(&self) -> *const PipelineDepthStencilStateCreateInfo<'lt> {
        self.depth_stencil_state
    }
    ///Gets the raw value of [`Self::color_blend_state`]
    pub fn color_blend_state_raw(&self) -> *const PipelineColorBlendStateCreateInfo<'lt> {
        self.color_blend_state
    }
    ///Gets the raw value of [`Self::dynamic_state`]
    pub fn dynamic_state_raw(&self) -> *const PipelineDynamicStateCreateInfo<'lt> {
        self.dynamic_state
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *const BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::stages`]
    pub fn set_stages_raw(&mut self, value: *const PipelineShaderStageCreateInfo<'lt>) -> &mut Self {
        self.stages = value;
        self
    }
    ///Sets the raw value of [`Self::vertex_input_state`]
    pub fn set_vertex_input_state_raw(&mut self, value: *const PipelineVertexInputStateCreateInfo<'lt>) -> &mut Self {
        self.vertex_input_state = value;
        self
    }
    ///Sets the raw value of [`Self::input_assembly_state`]
    pub fn set_input_assembly_state_raw(
        &mut self,
        value: *const PipelineInputAssemblyStateCreateInfo<'lt>,
    ) -> &mut Self {
        self.input_assembly_state = value;
        self
    }
    ///Sets the raw value of [`Self::tessellation_state`]
    pub fn set_tessellation_state_raw(&mut self, value: *const PipelineTessellationStateCreateInfo<'lt>) -> &mut Self {
        self.tessellation_state = value;
        self
    }
    ///Sets the raw value of [`Self::viewport_state`]
    pub fn set_viewport_state_raw(&mut self, value: *const PipelineViewportStateCreateInfo<'lt>) -> &mut Self {
        self.viewport_state = value;
        self
    }
    ///Sets the raw value of [`Self::rasterization_state`]
    pub fn set_rasterization_state_raw(
        &mut self,
        value: *const PipelineRasterizationStateCreateInfo<'lt>,
    ) -> &mut Self {
        self.rasterization_state = value;
        self
    }
    ///Sets the raw value of [`Self::multisample_state`]
    pub fn set_multisample_state_raw(&mut self, value: *const PipelineMultisampleStateCreateInfo<'lt>) -> &mut Self {
        self.multisample_state = value;
        self
    }
    ///Sets the raw value of [`Self::depth_stencil_state`]
    pub fn set_depth_stencil_state_raw(&mut self, value: *const PipelineDepthStencilStateCreateInfo<'lt>) -> &mut Self {
        self.depth_stencil_state = value;
        self
    }
    ///Sets the raw value of [`Self::color_blend_state`]
    pub fn set_color_blend_state_raw(&mut self, value: *const PipelineColorBlendStateCreateInfo<'lt>) -> &mut Self {
        self.color_blend_state = value;
        self
    }
    ///Sets the raw value of [`Self::dynamic_state`]
    pub fn set_dynamic_state_raw(&mut self, value: *const PipelineDynamicStateCreateInfo<'lt>) -> &mut Self {
        self.dynamic_state = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseInStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::flags`]
    pub fn flags(&self) -> PipelineCreateFlags {
        self.flags
    }
    ///Gets the value of [`Self::stage_count`]
    pub fn stage_count(&self) -> u32 {
        self.stage_count
    }
    ///Gets the value of [`Self::stages`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn stages(&self) -> &[PipelineShaderStageCreateInfo<'lt>] {
        std::slice::from_raw_parts(self.stages, self.stage_count as usize)
    }
    ///Gets the value of [`Self::vertex_input_state`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn vertex_input_state(&self) -> &PipelineVertexInputStateCreateInfo<'lt> {
        &*self.vertex_input_state
    }
    ///Gets the value of [`Self::input_assembly_state`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn input_assembly_state(&self) -> &PipelineInputAssemblyStateCreateInfo<'lt> {
        &*self.input_assembly_state
    }
    ///Gets the value of [`Self::tessellation_state`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn tessellation_state(&self) -> &PipelineTessellationStateCreateInfo<'lt> {
        &*self.tessellation_state
    }
    ///Gets the value of [`Self::viewport_state`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn viewport_state(&self) -> &PipelineViewportStateCreateInfo<'lt> {
        &*self.viewport_state
    }
    ///Gets the value of [`Self::rasterization_state`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn rasterization_state(&self) -> &PipelineRasterizationStateCreateInfo<'lt> {
        &*self.rasterization_state
    }
    ///Gets the value of [`Self::multisample_state`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn multisample_state(&self) -> &PipelineMultisampleStateCreateInfo<'lt> {
        &*self.multisample_state
    }
    ///Gets the value of [`Self::depth_stencil_state`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn depth_stencil_state(&self) -> &PipelineDepthStencilStateCreateInfo<'lt> {
        &*self.depth_stencil_state
    }
    ///Gets the value of [`Self::color_blend_state`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn color_blend_state(&self) -> &PipelineColorBlendStateCreateInfo<'lt> {
        &*self.color_blend_state
    }
    ///Gets the value of [`Self::dynamic_state`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn dynamic_state(&self) -> &PipelineDynamicStateCreateInfo<'lt> {
        &*self.dynamic_state
    }
    ///Gets the value of [`Self::layout`]
    pub fn layout(&self) -> PipelineLayout {
        self.layout
    }
    ///Gets the value of [`Self::render_pass`]
    pub fn render_pass(&self) -> RenderPass {
        self.render_pass
    }
    ///Gets the value of [`Self::subpass`]
    pub fn subpass(&self) -> u32 {
        self.subpass
    }
    ///Gets the value of [`Self::base_pipeline_handle`]
    pub fn base_pipeline_handle(&self) -> Pipeline {
        self.base_pipeline_handle
    }
    ///Gets the value of [`Self::base_pipeline_index`]
    pub fn base_pipeline_index(&self) -> i32 {
        self.base_pipeline_index
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::flags`]
    pub fn flags_mut(&mut self) -> &mut PipelineCreateFlags {
        &mut self.flags
    }
    ///Gets a mutable reference to the value of [`Self::stage_count`]
    pub fn stage_count_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::layout`]
    pub fn layout_mut(&mut self) -> &mut PipelineLayout {
        &mut self.layout
    }
    ///Gets a mutable reference to the value of [`Self::render_pass`]
    pub fn render_pass_mut(&mut self) -> &mut RenderPass {
        &mut self.render_pass
    }
    ///Gets a mutable reference to the value of [`Self::subpass`]
    pub fn subpass_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::base_pipeline_handle`]
    pub fn base_pipeline_handle_mut(&mut self) -> &mut Pipeline {
        &mut self.base_pipeline_handle
    }
    ///Gets a mutable reference to the value of [`Self::base_pipeline_index`]
    pub fn base_pipeline_index_mut(&mut self) -> &mut i32 {
        &mut getter
    }
    ///Sets the raw value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the raw value of [`Self::flags`]
    pub fn set_flags(&mut self, value: crate::vulkan1_0::PipelineCreateFlags) -> &mut Self {
        self.flags = value;
        self
    }
    ///Sets the raw value of [`Self::stage_count`]
    pub fn set_stage_count(&mut self, value: u32) -> &mut Self {
        self.stage_count = value;
        self
    }
    ///Sets the raw value of [`Self::stages`]
    pub fn set_stages(&mut self, value: &'lt [crate::vulkan1_0::PipelineShaderStageCreateInfo<'lt>]) -> &mut Self {
        let len_ = value.len() as u32;
        let len_ = len_;
        self.stages = value.as_ptr();
        self.stage_count = len_;
        self
    }
    ///Sets the raw value of [`Self::vertex_input_state`]
    pub fn set_vertex_input_state(
        &mut self,
        value: &'lt crate::vulkan1_0::PipelineVertexInputStateCreateInfo<'lt>,
    ) -> &mut Self {
        self.vertex_input_state = value as *const _;
        self
    }
    ///Sets the raw value of [`Self::input_assembly_state`]
    pub fn set_input_assembly_state(
        &mut self,
        value: &'lt crate::vulkan1_0::PipelineInputAssemblyStateCreateInfo<'lt>,
    ) -> &mut Self {
        self.input_assembly_state = value as *const _;
        self
    }
    ///Sets the raw value of [`Self::tessellation_state`]
    pub fn set_tessellation_state(
        &mut self,
        value: &'lt crate::vulkan1_0::PipelineTessellationStateCreateInfo<'lt>,
    ) -> &mut Self {
        self.tessellation_state = value as *const _;
        self
    }
    ///Sets the raw value of [`Self::viewport_state`]
    pub fn set_viewport_state(
        &mut self,
        value: &'lt crate::vulkan1_0::PipelineViewportStateCreateInfo<'lt>,
    ) -> &mut Self {
        self.viewport_state = value as *const _;
        self
    }
    ///Sets the raw value of [`Self::rasterization_state`]
    pub fn set_rasterization_state(
        &mut self,
        value: &'lt crate::vulkan1_0::PipelineRasterizationStateCreateInfo<'lt>,
    ) -> &mut Self {
        self.rasterization_state = value as *const _;
        self
    }
    ///Sets the raw value of [`Self::multisample_state`]
    pub fn set_multisample_state(
        &mut self,
        value: &'lt crate::vulkan1_0::PipelineMultisampleStateCreateInfo<'lt>,
    ) -> &mut Self {
        self.multisample_state = value as *const _;
        self
    }
    ///Sets the raw value of [`Self::depth_stencil_state`]
    pub fn set_depth_stencil_state(
        &mut self,
        value: &'lt crate::vulkan1_0::PipelineDepthStencilStateCreateInfo<'lt>,
    ) -> &mut Self {
        self.depth_stencil_state = value as *const _;
        self
    }
    ///Sets the raw value of [`Self::color_blend_state`]
    pub fn set_color_blend_state(
        &mut self,
        value: &'lt crate::vulkan1_0::PipelineColorBlendStateCreateInfo<'lt>,
    ) -> &mut Self {
        self.color_blend_state = value as *const _;
        self
    }
    ///Sets the raw value of [`Self::dynamic_state`]
    pub fn set_dynamic_state(
        &mut self,
        value: &'lt crate::vulkan1_0::PipelineDynamicStateCreateInfo<'lt>,
    ) -> &mut Self {
        self.dynamic_state = value as *const _;
        self
    }
    ///Sets the raw value of [`Self::layout`]
    pub fn set_layout(&mut self, value: crate::vulkan1_0::PipelineLayout) -> &mut Self {
        self.layout = value;
        self
    }
    ///Sets the raw value of [`Self::render_pass`]
    pub fn set_render_pass(&mut self, value: crate::vulkan1_0::RenderPass) -> &mut Self {
        self.render_pass = value;
        self
    }
    ///Sets the raw value of [`Self::subpass`]
    pub fn set_subpass(&mut self, value: u32) -> &mut Self {
        self.subpass = value;
        self
    }
    ///Sets the raw value of [`Self::base_pipeline_handle`]
    pub fn set_base_pipeline_handle(&mut self, value: crate::vulkan1_0::Pipeline) -> &mut Self {
        self.base_pipeline_handle = value;
        self
    }
    ///Sets the raw value of [`Self::base_pipeline_index`]
    pub fn set_base_pipeline_index(&mut self, value: i32) -> &mut Self {
        self.base_pipeline_index = value;
        self
    }
}
///[VkPipelineCacheCreateInfo](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineCacheCreateInfo.html) - Structure specifying parameters of a newly created pipeline cache
///# C Specifications
///The [`PipelineCacheCreateInfo`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkPipelineCacheCreateInfo {
///    VkStructureType               sType;
///    const void*                   pNext;
///    VkPipelineCacheCreateFlags    flags;
///    size_t                        initialDataSize;
///    const void*                   pInitialData;
///} VkPipelineCacheCreateInfo;
///```
///# Members
/// - [`s_type`] is the type of this structure.
/// - [`p_next`] is `NULL` or a pointer to a structure extending this structure.
/// - [`flags`] is a bitmask of [`PipelineCacheCreateFlagBits`] specifying the behavior of the
///   pipeline cache.
/// - [`initial_data_size`] is the number of bytes in [`initial_data`]. If [`initial_data_size`] is
///   zero, the pipeline cache will initially be empty.
/// - [`initial_data`] is a pointer to previously retrieved pipeline cache data. If the pipeline
///   cache data is incompatible (as defined below) with the device, the pipeline cache will be
///   initially empty. If [`initial_data_size`] is zero, [`initial_data`] is ignored.
///# Description
///## Valid Usage
/// - If [`initial_data_size`] is not `0`, it  **must**  be equal to the size of [`initial_data`],
///   as returned by [`GetPipelineCacheData`] when [`initial_data`] was originally retrieved
/// - If [`initial_data_size`] is not `0`, [`initial_data`] **must**  have been retrieved from a
///   previous call to [`GetPipelineCacheData`]
/// - If the [`pipelineCreationCacheControl`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-pipelineCreationCacheControl)
///   feature is not enabled, [`flags`] **must**  not include
///   `VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT`
///
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be `VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO`
/// - [`p_next`] **must**  be `NULL`
/// - [`flags`] **must**  be a valid combination of [`PipelineCacheCreateFlagBits`] values
/// - If [`initial_data_size`] is not `0`, [`initial_data`] **must**  be a valid pointer to an array
///   of [`initial_data_size`] bytes
///# Related
/// - [`crate::vulkan1_0`]
/// - [`PipelineCacheCreateFlags`]
/// - [`StructureType`]
/// - [`CreatePipelineCache`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[repr(C)]
pub struct PipelineCacheCreateInfo<'lt> {
    _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] is the type of this structure.
    s_type: StructureType,
    ///[`p_next`] is `NULL` or a pointer to a structure extending this
    ///structure.
    p_next: *const BaseInStructure<'lt>,
    ///[`flags`] is a bitmask of [`PipelineCacheCreateFlagBits`]
    ///specifying the behavior of the pipeline cache.
    flags: PipelineCacheCreateFlags,
    ///[`initial_data_size`] is the number of bytes in [`initial_data`].
    ///If [`initial_data_size`] is zero, the pipeline cache will initially be
    ///empty.
    initial_data_size: usize,
    ///[`initial_data`] is a pointer to previously retrieved pipeline cache
    ///data.
    ///If the pipeline cache data is incompatible (as defined below) with the
    ///device, the pipeline cache will be initially empty.
    ///If [`initial_data_size`] is zero, [`initial_data`] is ignored.
    initial_data: *const c_void,
}
impl<'lt> Default for PipelineCacheCreateInfo<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: Default::default(),
            p_next: std::ptr::null(),
            flags: Default::default(),
            initial_data_size: 0,
            initial_data: std::ptr::null(),
        }
    }
}
impl<'lt> PipelineCacheCreateInfo<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *const BaseInStructure<'lt> {
        self.p_next
    }
    ///Gets the raw value of [`Self::initial_data`]
    pub fn initial_data_raw(&self) -> *const c_void {
        self.initial_data
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *const BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::initial_data`]
    pub fn set_initial_data_raw(&mut self, value: *const c_void) -> &mut Self {
        self.initial_data = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseInStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::flags`]
    pub fn flags(&self) -> PipelineCacheCreateFlags {
        self.flags
    }
    ///Gets the value of [`Self::initial_data_size`]
    pub fn initial_data_size(&self) -> usize {
        self.initial_data_size
    }
    ///Gets the value of [`Self::initial_data`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn initial_data(&self) -> &[c_void] {
        std::slice::from_raw_parts(self.initial_data, self.initial_data_size as usize)
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::flags`]
    pub fn flags_mut(&mut self) -> &mut PipelineCacheCreateFlags {
        &mut self.flags
    }
    ///Gets a mutable reference to the value of [`Self::initial_data_size`]
    pub fn initial_data_size_mut(&mut self) -> &mut usize {
        &mut getter
    }
    ///Sets the raw value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the raw value of [`Self::flags`]
    pub fn set_flags(&mut self, value: crate::vulkan1_0::PipelineCacheCreateFlags) -> &mut Self {
        self.flags = value;
        self
    }
    ///Sets the raw value of [`Self::initial_data_size`]
    pub fn set_initial_data_size(&mut self, value: usize) -> &mut Self {
        self.initial_data_size = value;
        self
    }
    ///Sets the raw value of [`Self::initial_data`]
    pub fn set_initial_data(&mut self, value: &'lt [std::ffi::c_void]) -> &mut Self {
        let len_ = value.len() as u32;
        let len_ = len_;
        self.initial_data = value.as_ptr();
        self.initial_data_size = len_;
        self
    }
}
///[VkPipelineCacheHeaderVersionOne](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineCacheHeaderVersionOne.html) - Structure describing the layout of the pipeline cache header
///# C Specifications
///Version one of the pipeline cache header is defined as:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkPipelineCacheHeaderVersionOne {
///    uint32_t                        headerSize;
///    VkPipelineCacheHeaderVersion    headerVersion;
///    uint32_t                        vendorID;
///    uint32_t                        deviceID;
///    uint8_t                         pipelineCacheUUID[VK_UUID_SIZE];
///} VkPipelineCacheHeaderVersionOne;
///```
///# Members
/// - [`header_size`] is the length in bytes of the pipeline cache header.
/// - [`header_version`] is a [`PipelineCacheHeaderVersion`] enum value specifying the version of
///   the header. A consumer of the pipeline cache  **should**  use the cache version to interpret
///   the remainder of the cache header.
/// - [`vendor_id`] is the [`PhysicalDeviceProperties`]::[`vendor_id`] of the implementation.
/// - [`device_id`] is the [`PhysicalDeviceProperties`]::[`device_id`] of the implementation.
/// - [`pipeline_cache_uuid`] is the [`PhysicalDeviceProperties`]::[`pipeline_cache_uuid`] of the
///   implementation.
///# Description
///Unlike most structures declared by the Vulkan API, all fields of this
///structure are written with the least significant byte first, regardless of
///host byte-order.The C language specification does not define the packing of structure
///members.
///This layout assumes tight structure member packing, with members laid out in
///the order listed in the structure, and the intended size of the structure is
///32 bytes.
///If a compiler produces code that diverges from that pattern, applications
/// **must**  employ another method to set values at the correct offsets.
///## Valid Usage
/// - [`header_size`] **must**  be 32
/// - [`header_version`] **must**  be `VK_PIPELINE_CACHE_HEADER_VERSION_ONE`
///
///## Valid Usage (Implicit)
/// - [`header_version`] **must**  be a valid [`PipelineCacheHeaderVersion`] value
///# Related
/// - [`crate::vulkan1_0`]
/// - [`PipelineCacheHeaderVersion`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct PipelineCacheHeaderVersionOne {
    ///[`header_size`] is the length in bytes of the pipeline cache header.
    header_size: u32,
    ///[`header_version`] is a [`PipelineCacheHeaderVersion`] enum value
    ///specifying the version of the header.
    ///A consumer of the pipeline cache  **should**  use the cache version to
    ///interpret the remainder of the cache header.
    header_version: PipelineCacheHeaderVersion,
    ///[`vendor_id`] is the [`PhysicalDeviceProperties`]::[`vendor_id`]
    ///of the implementation.
    vendor_id: u32,
    ///[`device_id`] is the [`PhysicalDeviceProperties`]::[`device_id`]
    ///of the implementation.
    device_id: u32,
    ///[`pipeline_cache_uuid`] is the
    ///[`PhysicalDeviceProperties`]::[`pipeline_cache_uuid`] of the
    ///implementation.
    pipeline_cache_uuid: [u8; UUID_SIZE],
}
impl Default for PipelineCacheHeaderVersionOne {
    fn default() -> Self {
        Self {
            header_size: 0,
            header_version: Default::default(),
            vendor_id: 0,
            device_id: 0,
            pipeline_cache_uuid: [0; UUID_SIZE],
        }
    }
}
impl PipelineCacheHeaderVersionOne {
    ///Gets the value of [`Self::header_size`]
    pub fn header_size(&self) -> u32 {
        self.header_size
    }
    ///Gets the value of [`Self::header_version`]
    pub fn header_version(&self) -> PipelineCacheHeaderVersion {
        self.header_version
    }
    ///Gets the value of [`Self::vendor_id`]
    pub fn vendor_id(&self) -> u32 {
        self.vendor_id
    }
    ///Gets the value of [`Self::device_id`]
    pub fn device_id(&self) -> u32 {
        self.device_id
    }
    ///Gets the value of [`Self::pipeline_cache_uuid`]
    pub fn pipeline_cache_uuid(&self) -> &[u8; UUID_SIZE] {
        &getter
    }
    ///Gets a mutable reference to the value of [`Self::header_size`]
    pub fn header_size_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::header_version`]
    pub fn header_version_mut(&mut self) -> &mut PipelineCacheHeaderVersion {
        &mut self.header_version
    }
    ///Gets a mutable reference to the value of [`Self::vendor_id`]
    pub fn vendor_id_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::device_id`]
    pub fn device_id_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::pipeline_cache_uuid`]
    pub fn pipeline_cache_uuid_mut(&mut self) -> &mut [u8; UUID_SIZE] {
        &mut getter
    }
    ///Sets the raw value of [`Self::header_size`]
    pub fn set_header_size(&mut self, value: u32) -> &mut Self {
        self.header_size = value;
        self
    }
    ///Sets the raw value of [`Self::header_version`]
    pub fn set_header_version(&mut self, value: crate::vulkan1_0::PipelineCacheHeaderVersion) -> &mut Self {
        self.header_version = value;
        self
    }
    ///Sets the raw value of [`Self::vendor_id`]
    pub fn set_vendor_id(&mut self, value: u32) -> &mut Self {
        self.vendor_id = value;
        self
    }
    ///Sets the raw value of [`Self::device_id`]
    pub fn set_device_id(&mut self, value: u32) -> &mut Self {
        self.device_id = value;
        self
    }
    ///Sets the raw value of [`Self::pipeline_cache_uuid`]
    pub fn set_pipeline_cache_uuid(&mut self, value: [u8; crate::core::UUID_SIZE]) -> &mut Self {
        self.pipeline_cache_uuid = value;
        self
    }
}
///[VkPushConstantRange](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPushConstantRange.html) - Structure specifying a push constant range
///# C Specifications
///The [`PushConstantRange`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkPushConstantRange {
///    VkShaderStageFlags    stageFlags;
///    uint32_t              offset;
///    uint32_t              size;
///} VkPushConstantRange;
///```
///# Members
/// - [`stage_flags`] is a set of stage flags describing the shader stages that will access a range
///   of push constants. If a particular stage is not included in the range, then accessing members
///   of that range of push constants from the corresponding shader stage will return undefined
///   values.
/// - [`offset`] and [`size`] are the start offset and size, respectively, consumed by the range.
///   Both [`offset`] and [`size`] are in units of bytes and  **must**  be a multiple of 4. The
///   layout of the push constant variables is specified in the shader.
///# Description
///## Valid Usage
/// - [`offset`] **must**  be less than [`PhysicalDeviceLimits::max_push_constants_size`]
/// - [`offset`] **must**  be a multiple of `4`
/// - [`size`] **must**  be greater than `0`
/// - [`size`] **must**  be a multiple of `4`
/// - [`size`] **must**  be less than or equal to [`PhysicalDeviceLimits::max_push_constants_size`]
///   minus [`offset`]
///
///## Valid Usage (Implicit)
/// - [`stage_flags`] **must**  be a valid combination of [`ShaderStageFlagBits`] values
/// - [`stage_flags`] **must**  not be `0`
///# Related
/// - [`crate::vulkan1_0`]
/// - [`PipelineLayoutCreateInfo`]
/// - [`ShaderStageFlags`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct PushConstantRange {
    ///[`stage_flags`] is a set of stage flags describing the shader stages
    ///that will access a range of push constants.
    ///If a particular stage is not included in the range, then accessing
    ///members of that range of push constants from the corresponding shader
    ///stage will return undefined values.
    stage_flags: ShaderStageFlags,
    ///[`offset`] and [`size`] are the start offset and size, respectively,
    ///consumed by the range.
    ///Both [`offset`] and [`size`] are in units of bytes and  **must**  be a
    ///multiple of 4.
    ///The layout of the push constant variables is specified in the shader.
    offset: u32,
    ///No documentation found
    size: u32,
}
impl Default for PushConstantRange {
    fn default() -> Self {
        Self {
            stage_flags: Default::default(),
            offset: 0,
            size: 0,
        }
    }
}
impl PushConstantRange {
    ///Gets the value of [`Self::stage_flags`]
    pub fn stage_flags(&self) -> ShaderStageFlags {
        self.stage_flags
    }
    ///Gets the value of [`Self::offset`]
    pub fn offset(&self) -> u32 {
        self.offset
    }
    ///Gets the value of [`Self::size`]
    pub fn size(&self) -> u32 {
        self.size
    }
    ///Gets a mutable reference to the value of [`Self::stage_flags`]
    pub fn stage_flags_mut(&mut self) -> &mut ShaderStageFlags {
        &mut self.stage_flags
    }
    ///Gets a mutable reference to the value of [`Self::offset`]
    pub fn offset_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::size`]
    pub fn size_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Sets the raw value of [`Self::stage_flags`]
    pub fn set_stage_flags(&mut self, value: crate::vulkan1_0::ShaderStageFlags) -> &mut Self {
        self.stage_flags = value;
        self
    }
    ///Sets the raw value of [`Self::offset`]
    pub fn set_offset(&mut self, value: u32) -> &mut Self {
        self.offset = value;
        self
    }
    ///Sets the raw value of [`Self::size`]
    pub fn set_size(&mut self, value: u32) -> &mut Self {
        self.size = value;
        self
    }
}
///[VkPipelineLayoutCreateInfo](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineLayoutCreateInfo.html) - Structure specifying the parameters of a newly created pipeline layout object
///# C Specifications
///The [`PipelineLayoutCreateInfo`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkPipelineLayoutCreateInfo {
///    VkStructureType                 sType;
///    const void*                     pNext;
///    VkPipelineLayoutCreateFlags     flags;
///    uint32_t                        setLayoutCount;
///    const VkDescriptorSetLayout*    pSetLayouts;
///    uint32_t                        pushConstantRangeCount;
///    const VkPushConstantRange*      pPushConstantRanges;
///} VkPipelineLayoutCreateInfo;
///```
///# Members
/// - [`s_type`] is the type of this structure.
/// - [`p_next`] is `NULL` or a pointer to a structure extending this structure.
/// - [`flags`] is reserved for future use.
/// - [`set_layout_count`] is the number of descriptor sets included in the pipeline layout.
/// - [`set_layouts`] is a pointer to an array of [`DescriptorSetLayout`] objects.
/// - [`push_constant_range_count`] is the number of push constant ranges included in the pipeline
///   layout.
/// - [`push_constant_ranges`] is a pointer to an array of [`PushConstantRange`] structures defining
///   a set of push constant ranges for use in a single pipeline layout. In addition to descriptor
///   set layouts, a pipeline layout also describes how many push constants  **can**  be accessed by
///   each stage of the pipeline.
///# Description
///## Valid Usage
/// - [`set_layout_count`] **must**  be less than or equal to
///   [`PhysicalDeviceLimits::max_bound_descriptor_sets`]
/// - The total number of descriptors in descriptor set layouts created without the
///   `VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT` bit set with a `descriptorType`
///   of `VK_DESCRIPTOR_TYPE_SAMPLER` and `VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER` accessible to
///   any given shader stage across all elements of [`set_layouts`] **must**  be less than or equal
///   to [`PhysicalDeviceLimits::max_per_stage_descriptor_samplers`]
/// - The total number of descriptors in descriptor set layouts created without the
///   `VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT` bit set with a `descriptorType`
///   of `VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER` and `VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC`
///   accessible to any given shader stage across all elements of [`set_layouts`] **must**  be less
///   than or equal to [`PhysicalDeviceLimits::max_per_stage_descriptor_uniform_buffers`]
/// - The total number of descriptors in descriptor set layouts created without the
///   `VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT` bit set with a `descriptorType`
///   of `VK_DESCRIPTOR_TYPE_STORAGE_BUFFER` and `VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC`
///   accessible to any given shader stage across all elements of [`set_layouts`] **must**  be less
///   than or equal to [`PhysicalDeviceLimits::max_per_stage_descriptor_storage_buffers`]
/// - The total number of descriptors in descriptor set layouts created without the
///   `VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT` bit set with a `descriptorType`
///   of `VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER`, `VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE`, and
///   `VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER` accessible to any given shader stage across all
///   elements of [`set_layouts`] **must**  be less than or equal to
///   [`PhysicalDeviceLimits::max_per_stage_descriptor_sampled_images`]
/// - The total number of descriptors in descriptor set layouts created without the
///   `VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT` bit set with a `descriptorType`
///   of `VK_DESCRIPTOR_TYPE_STORAGE_IMAGE`, and `VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER`
///   accessible to any given shader stage across all elements of [`set_layouts`] **must**  be less
///   than or equal to [`PhysicalDeviceLimits::max_per_stage_descriptor_storage_images`]
/// - The total number of descriptors in descriptor set layouts created without the
///   `VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT` bit set with a `descriptorType`
///   of `VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT` accessible to any given shader stage across all
///   elements of [`set_layouts`] **must**  be less than or equal to
///   [`PhysicalDeviceLimits::max_per_stage_descriptor_input_attachments`]
/// - The total number of bindings in descriptor set layouts created without the
///   `VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT` bit set with a `descriptorType`
///   of `VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK` accessible to any given shader stage across all
///   elements of [`set_layouts`] **must**  be less than or equal to
///   [`PhysicalDeviceInlineUniformBlockProperties::max_per_stage_descriptor_inline_uniform_blocks`]
/// - The total number of descriptors with a `descriptorType` of `VK_DESCRIPTOR_TYPE_SAMPLER` and
///   `VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER` accessible to any given shader stage across all
///   elements of [`set_layouts`] **must**  be less than or equal to
///   [`PhysicalDeviceDescriptorIndexingProperties::
///   max_per_stage_descriptor_update_after_bind_samplers`]
/// - The total number of descriptors with a `descriptorType` of `VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER`
///   and `VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC` accessible to any given shader stage across
///   all elements of [`set_layouts`] **must**  be less than or equal to
///   [`PhysicalDeviceDescriptorIndexingProperties::
///   max_per_stage_descriptor_update_after_bind_uniform_buffers`]
/// - The total number of descriptors with a `descriptorType` of `VK_DESCRIPTOR_TYPE_STORAGE_BUFFER`
///   and `VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC` accessible to any given shader stage across
///   all elements of [`set_layouts`] **must**  be less than or equal to
///   [`PhysicalDeviceDescriptorIndexingProperties::
///   max_per_stage_descriptor_update_after_bind_storage_buffers`]
/// - The total number of descriptors with a `descriptorType` of
///   `VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER`, `VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE`, and
///   `VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER` accessible to any given shader stage across all
///   elements of [`set_layouts`] **must**  be less than or equal to
///   [`PhysicalDeviceDescriptorIndexingProperties::
///   max_per_stage_descriptor_update_after_bind_sampled_images`]
/// - The total number of descriptors with a `descriptorType` of `VK_DESCRIPTOR_TYPE_STORAGE_IMAGE`,
///   and `VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER` accessible to any given shader stage across all
///   elements of [`set_layouts`] **must**  be less than or equal to
///   [`PhysicalDeviceDescriptorIndexingProperties::
///   max_per_stage_descriptor_update_after_bind_storage_images`]
/// - The total number of descriptors with a `descriptorType` of
///   `VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT` accessible to any given shader stage across all elements
///   of [`set_layouts`] **must**  be less than or equal to
///   [`PhysicalDeviceDescriptorIndexingProperties::
///   max_per_stage_descriptor_update_after_bind_input_attachments`]
/// - The total number of bindings with a `descriptorType` of
///   `VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK` accessible to any given shader stage across all
///   elements of [`set_layouts`] **must**  be less than or equal to
///   [`PhysicalDeviceInlineUniformBlockProperties::
///   max_per_stage_descriptor_update_after_bind_inline_uniform_blocks`]
/// - The total number of descriptors in descriptor set layouts created without the
///   `VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT` bit set with a `descriptorType`
///   of `VK_DESCRIPTOR_TYPE_SAMPLER` and `VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER` accessible
///   across all shader stages and across all elements of [`set_layouts`] **must**  be less than or
///   equal to [`PhysicalDeviceLimits::max_descriptor_set_samplers`]
/// - The total number of descriptors in descriptor set layouts created without the
///   `VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT` bit set with a `descriptorType`
///   of `VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER` accessible across all shader stages and across all
///   elements of [`set_layouts`] **must**  be less than or equal to
///   [`PhysicalDeviceLimits::max_descriptor_set_uniform_buffers`]
/// - The total number of descriptors in descriptor set layouts created without the
///   `VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT` bit set with a `descriptorType`
///   of `VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC` accessible across all shader stages and across
///   all elements of [`set_layouts`] **must**  be less than or equal to
///   [`PhysicalDeviceLimits::max_descriptor_set_uniform_buffers_dynamic`]
/// - The total number of descriptors in descriptor set layouts created without the
///   `VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT` bit set with a `descriptorType`
///   of `VK_DESCRIPTOR_TYPE_STORAGE_BUFFER` accessible across all shader stages and across all
///   elements of [`set_layouts`] **must**  be less than or equal to
///   [`PhysicalDeviceLimits::max_descriptor_set_storage_buffers`]
/// - The total number of descriptors in descriptor set layouts created without the
///   `VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT` bit set with a `descriptorType`
///   of `VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC` accessible across all shader stages and across
///   all elements of [`set_layouts`] **must**  be less than or equal to
///   [`PhysicalDeviceLimits::max_descriptor_set_storage_buffers_dynamic`]
/// - The total number of descriptors in descriptor set layouts created without the
///   `VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT` bit set with a `descriptorType`
///   of `VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER`, `VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE`, and
///   `VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER` accessible across all shader stages and across all
///   elements of [`set_layouts`] **must**  be less than or equal to
///   [`PhysicalDeviceLimits::max_descriptor_set_sampled_images`]
/// - The total number of descriptors in descriptor set layouts created without the
///   `VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT` bit set with a `descriptorType`
///   of `VK_DESCRIPTOR_TYPE_STORAGE_IMAGE`, and `VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER`
///   accessible across all shader stages and across all elements of [`set_layouts`] **must**  be
///   less than or equal to [`PhysicalDeviceLimits::max_descriptor_set_storage_images`]
/// - The total number of descriptors in descriptor set layouts created without the
///   `VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT` bit set with a `descriptorType`
///   of `VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT` accessible across all shader stages and across all
///   elements of [`set_layouts`] **must**  be less than or equal to
///   [`PhysicalDeviceLimits::max_descriptor_set_input_attachments`]
/// - The total number of bindings in descriptor set layouts created without the
///   `VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT` bit set with a `descriptorType`
///   of `VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK` accessible across all shader stages and across
///   all elements of [`set_layouts`] **must**  be less than or equal to
///   [`PhysicalDeviceInlineUniformBlockProperties::max_descriptor_set_inline_uniform_blocks`]
/// - The total number of descriptors of the type `VK_DESCRIPTOR_TYPE_SAMPLER` and
///   `VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER` accessible across all shader stages and across all
///   elements of [`set_layouts`] **must**  be less than or equal to
///   [`PhysicalDeviceDescriptorIndexingProperties::max_descriptor_set_update_after_bind_samplers`]
/// - The total number of descriptors of the type `VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER` accessible
///   across all shader stages and across all elements of [`set_layouts`] **must**  be less than or
///   equal to [`PhysicalDeviceDescriptorIndexingProperties::
///   max_descriptor_set_update_after_bind_uniform_buffers`]
/// - The total number of descriptors of the type `VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC`
///   accessible across all shader stages and across all elements of [`set_layouts`] **must**  be
///   less than or equal to
///   [`PhysicalDeviceDescriptorIndexingProperties::
///   max_descriptor_set_update_after_bind_uniform_buffers_dynamic`]
/// - The total number of descriptors of the type `VK_DESCRIPTOR_TYPE_STORAGE_BUFFER` accessible
///   across all shader stages and across all elements of [`set_layouts`] **must**  be less than or
///   equal to [`PhysicalDeviceDescriptorIndexingProperties::
///   max_descriptor_set_update_after_bind_storage_buffers`]
/// - The total number of descriptors of the type `VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC`
///   accessible across all shader stages and across all elements of [`set_layouts`] **must**  be
///   less than or equal to
///   [`PhysicalDeviceDescriptorIndexingProperties::
///   max_descriptor_set_update_after_bind_storage_buffers_dynamic`]
/// - The total number of descriptors of the type `VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER`,
///   `VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE`, and `VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER` accessible
///   across all shader stages and across all elements of [`set_layouts`] **must**  be less than or
///   equal to [`PhysicalDeviceDescriptorIndexingProperties::
///   max_descriptor_set_update_after_bind_sampled_images`]
/// - The total number of descriptors of the type `VK_DESCRIPTOR_TYPE_STORAGE_IMAGE`, and
///   `VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER` accessible across all shader stages and across all
///   elements of [`set_layouts`] **must**  be less than or equal to
///   [`PhysicalDeviceDescriptorIndexingProperties::
///   max_descriptor_set_update_after_bind_storage_images`]
/// - The total number of descriptors of the type `VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT` accessible
///   across all shader stages and across all elements of [`set_layouts`] **must**  be less than or
///   equal to [`PhysicalDeviceDescriptorIndexingProperties::
///   max_descriptor_set_update_after_bind_input_attachments`]
/// - The total number of bindings with a `descriptorType` of
///   `VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK` accessible across all shader stages and across all
///   elements of [`set_layouts`] **must**  be less than or equal to
///   [`PhysicalDeviceInlineUniformBlockProperties::
///   max_descriptor_set_update_after_bind_inline_uniform_blocks`]
/// - Any two elements of [`push_constant_ranges`] **must**  not include the same stage in
///   `stageFlags`
/// - [`set_layouts`] **must**  not contain more than one descriptor set layout that was created
///   with `VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR` set
/// - The total number of bindings in descriptor set layouts created without the
///   `VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT` bit set with a `descriptorType`
///   of `VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR` accessible to any given shader stage across
///   all elements of [`set_layouts`] **must**  be less than or equal to
///   [`PhysicalDeviceAccelerationStructurePropertiesKHR::
///   max_per_stage_descriptor_acceleration_structures`]
/// - The total number of bindings with a `descriptorType` of
///   `VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR` accessible to any given shader stage across
///   all elements of [`set_layouts`] **must**  be less than or equal to
///   [`PhysicalDeviceAccelerationStructurePropertiesKHR::
///   max_per_stage_descriptor_update_after_bind_acceleration_structures`]
/// - The total number of bindings in descriptor set layouts created without the
///   `VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT` bit set with a `descriptorType`
///   of `VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR` accessible across all shader stages and
///   across all elements of [`set_layouts`] **must**  be less than or equal to
///   [`PhysicalDeviceAccelerationStructurePropertiesKHR::
///   max_descriptor_set_acceleration_structures`]
/// - The total number of bindings with a `descriptorType` of
///   `VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR` accessible across all shader stages and across
///   all elements of [`set_layouts`] **must**  be less than or equal to
///   [`PhysicalDeviceAccelerationStructurePropertiesKHR::
///   max_descriptor_set_update_after_bind_acceleration_structures`]
/// - The total number of bindings with a `descriptorType` of
///   `VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV` accessible across all shader stages and across
///   all elements of [`set_layouts`] **must**  be less than or equal to
///   [`PhysicalDeviceRayTracingPropertiesNV::max_descriptor_set_acceleration_structures`]
/// -    The total number of `pImmutableSamplers` created with [`flags`] containing `VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT` or `VK_SAMPLER_CREATE_SUBSAMPLED_COARSE_RECONSTRUCTION_BIT_EXT` across all shader stages and across all elements of [`set_layouts`] **must**  be less than or equal to [[`PhysicalDeviceFragmentDensityMap2PropertiesEXT::max_descriptor_set_subsampled_samplers`]](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#limits-maxDescriptorSetSubsampledSamplers)
/// - Any element of [`set_layouts`] **must**  not have been created with the
///   `VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_VALVE` bit set
///
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be `VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO`
/// - [`p_next`] **must**  be `NULL`
/// - [`flags`] **must**  be `0`
/// - If [`set_layout_count`] is not `0`, [`set_layouts`] **must**  be a valid pointer to an array
///   of [`set_layout_count`] valid [`DescriptorSetLayout`] handles
/// - If [`push_constant_range_count`] is not `0`, [`push_constant_ranges`] **must**  be a valid
///   pointer to an array of [`push_constant_range_count`] valid [`PushConstantRange`] structures
///# Related
/// - [`crate::vulkan1_0`]
/// - [`DescriptorSetLayout`]
/// - [`PipelineLayoutCreateFlags`]
/// - [`PushConstantRange`]
/// - [`StructureType`]
/// - [`CreatePipelineLayout`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[repr(C)]
pub struct PipelineLayoutCreateInfo<'lt> {
    _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] is the type of this structure.
    s_type: StructureType,
    ///[`p_next`] is `NULL` or a pointer to a structure extending this
    ///structure.
    p_next: *const BaseInStructure<'lt>,
    ///[`flags`] is reserved for future use.
    flags: PipelineLayoutCreateFlags,
    ///[`set_layout_count`] is the number of descriptor sets included in the
    ///pipeline layout.
    set_layout_count: u32,
    ///[`set_layouts`] is a pointer to an array of
    ///[`DescriptorSetLayout`] objects.
    set_layouts: *const DescriptorSetLayout,
    ///[`push_constant_range_count`] is the number of push constant ranges
    ///included in the pipeline layout.
    push_constant_range_count: u32,
    ///[`push_constant_ranges`] is a pointer to an array of
    ///[`PushConstantRange`] structures defining a set of push constant
    ///ranges for use in a single pipeline layout.
    ///In addition to descriptor set layouts, a pipeline layout also describes
    ///how many push constants  **can**  be accessed by each stage of the pipeline.
    push_constant_ranges: *const PushConstantRange,
}
impl<'lt> Default for PipelineLayoutCreateInfo<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: Default::default(),
            p_next: std::ptr::null(),
            flags: Default::default(),
            set_layout_count: 0,
            set_layouts: std::ptr::null(),
            push_constant_range_count: 0,
            push_constant_ranges: std::ptr::null(),
        }
    }
}
impl<'lt> PipelineLayoutCreateInfo<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *const BaseInStructure<'lt> {
        self.p_next
    }
    ///Gets the raw value of [`Self::set_layouts`]
    pub fn set_layouts_raw(&self) -> *const DescriptorSetLayout {
        self.set_layouts
    }
    ///Gets the raw value of [`Self::push_constant_ranges`]
    pub fn push_constant_ranges_raw(&self) -> *const PushConstantRange {
        self.push_constant_ranges
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *const BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::set_layouts`]
    pub fn set_set_layouts_raw(&mut self, value: *const DescriptorSetLayout) -> &mut Self {
        self.set_layouts = value;
        self
    }
    ///Sets the raw value of [`Self::push_constant_ranges`]
    pub fn set_push_constant_ranges_raw(&mut self, value: *const PushConstantRange) -> &mut Self {
        self.push_constant_ranges = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseInStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::flags`]
    pub fn flags(&self) -> PipelineLayoutCreateFlags {
        self.flags
    }
    ///Gets the value of [`Self::set_layout_count`]
    pub fn set_layout_count(&self) -> u32 {
        self.set_layout_count
    }
    ///Gets the value of [`Self::set_layouts`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn set_layouts(&self) -> &[DescriptorSetLayout] {
        std::slice::from_raw_parts(self.set_layouts, self.set_layout_count as usize)
    }
    ///Gets the value of [`Self::push_constant_range_count`]
    pub fn push_constant_range_count(&self) -> u32 {
        self.push_constant_range_count
    }
    ///Gets the value of [`Self::push_constant_ranges`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn push_constant_ranges(&self) -> &[PushConstantRange] {
        std::slice::from_raw_parts(self.push_constant_ranges, self.push_constant_range_count as usize)
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::flags`]
    pub fn flags_mut(&mut self) -> &mut PipelineLayoutCreateFlags {
        &mut self.flags
    }
    ///Gets a mutable reference to the value of [`Self::set_layout_count`]
    pub fn set_layout_count_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::push_constant_range_count`]
    pub fn push_constant_range_count_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Sets the raw value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the raw value of [`Self::flags`]
    pub fn set_flags(&mut self, value: crate::vulkan1_0::PipelineLayoutCreateFlags) -> &mut Self {
        self.flags = value;
        self
    }
    ///Sets the raw value of [`Self::set_layout_count`]
    pub fn set_set_layout_count(&mut self, value: u32) -> &mut Self {
        self.set_layout_count = value;
        self
    }
    ///Sets the raw value of [`Self::set_layouts`]
    pub fn set_set_layouts(&mut self, value: &'lt [crate::vulkan1_0::DescriptorSetLayout]) -> &mut Self {
        let len_ = value.len() as u32;
        let len_ = len_;
        self.set_layouts = value.as_ptr();
        self.set_layout_count = len_;
        self
    }
    ///Sets the raw value of [`Self::push_constant_range_count`]
    pub fn set_push_constant_range_count(&mut self, value: u32) -> &mut Self {
        self.push_constant_range_count = value;
        self
    }
    ///Sets the raw value of [`Self::push_constant_ranges`]
    pub fn set_push_constant_ranges(&mut self, value: &'lt [crate::vulkan1_0::PushConstantRange]) -> &mut Self {
        let len_ = value.len() as u32;
        let len_ = len_;
        self.push_constant_ranges = value.as_ptr();
        self.push_constant_range_count = len_;
        self
    }
}
///[VkSamplerCreateInfo](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSamplerCreateInfo.html) - Structure specifying parameters of a newly created sampler
///# C Specifications
///The [`SamplerCreateInfo`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkSamplerCreateInfo {
///    VkStructureType         sType;
///    const void*             pNext;
///    VkSamplerCreateFlags    flags;
///    VkFilter                magFilter;
///    VkFilter                minFilter;
///    VkSamplerMipmapMode     mipmapMode;
///    VkSamplerAddressMode    addressModeU;
///    VkSamplerAddressMode    addressModeV;
///    VkSamplerAddressMode    addressModeW;
///    float                   mipLodBias;
///    VkBool32                anisotropyEnable;
///    float                   maxAnisotropy;
///    VkBool32                compareEnable;
///    VkCompareOp             compareOp;
///    float                   minLod;
///    float                   maxLod;
///    VkBorderColor           borderColor;
///    VkBool32                unnormalizedCoordinates;
///} VkSamplerCreateInfo;
///```
///# Members
/// - [`s_type`] is the type of this structure.
/// - [`p_next`] is `NULL` or a pointer to a structure extending this structure.
/// - [`flags`] is a bitmask of [`SamplerCreateFlagBits`] describing additional parameters of the
///   sampler.
/// - [`mag_filter`] is a [`Filter`] value specifying the magnification filter to apply to lookups.
/// - [`min_filter`] is a [`Filter`] value specifying the minification filter to apply to lookups.
/// - [`mipmap_mode`] is a [`SamplerMipmapMode`] value specifying the mipmap filter to apply to
///   lookups.
/// - [`address_mode_u`] is a [`SamplerAddressMode`] value specifying the addressing mode for U
///   coordinates outside [0,1).
/// - [`address_mode_v`] is a [`SamplerAddressMode`] value specifying the addressing mode for V
///   coordinates outside [0,1).
/// - [`address_mode_w`] is a [`SamplerAddressMode`] value specifying the addressing mode for W
///   coordinates outside [0,1).
/// - [`mip_lod_bias`] is the bias to be added to mipmap LOD (level-of-detail) calculation and bias provided by image sampling functions in SPIR-V, as described in the [Level-of-Detail Operation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#textures-level-of-detail-operation) section.
/// - [`anisotropy_enable`] is [`TRUE`] to enable anisotropic filtering, as described in the [Texel Anisotropic Filtering](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#textures-texel-anisotropic-filtering) section, or [`FALSE`] otherwise.
/// - [`max_anisotropy`] is the anisotropy value clamp used by the sampler when
///   [`anisotropy_enable`] is [`TRUE`]. If [`anisotropy_enable`] is [`FALSE`], [`max_anisotropy`]
///   is ignored.
/// - [`compare_enable`] is [`TRUE`] to enable comparison against a reference value during lookups,
///   or [`FALSE`] otherwise.  - Note: Some implementations will default to shader state if this
///   member does not match.
/// - [`compare_op`] is a [`CompareOp`] value specifying the comparison function to apply to fetched
///   data before filtering as described in the [Depth Compare Operation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#textures-depth-compare-operation)
///   section.
/// - [`min_lod`] is used to clamp the [minimum of the computed LOD value](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#textures-level-of-detail-operation).
/// - [`max_lod`] is used to clamp the [maximum of the computed LOD value](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#textures-level-of-detail-operation).
///   To avoid clamping the maximum value, set [`max_lod`] to the constant [`LOD_CLAMP_NONE`].
/// - [`border_color`] is a [`BorderColor`] value specifying the predefined border color to use.
/// - [`unnormalized_coordinates`] controls whether to use unnormalized or normalized texel
///   coordinates to address texels of the image. When set to [`TRUE`], the range of the image
///   coordinates used to lookup the texel is in the range of zero to the image size in each
///   dimension. When set to [`FALSE`] the range of image coordinates is zero to one.When
///   [`unnormalized_coordinates`] is [`TRUE`], images the sampler is used with in the shader have
///   the following requirements:  - The `viewType` **must**  be either `VK_IMAGE_VIEW_TYPE_1D` or
///   `VK_IMAGE_VIEW_TYPE_2D`.  - The image view  **must**  have a single layer and a single mip
///   level. When [`unnormalized_coordinates`] is [`TRUE`], image built-in functions in the shader
///   that use the sampler have the following requirements:  - The functions  **must**  not use
///   projection.  - The functions  **must**  not use offsets.
///# Description
///The maximum number of sampler objects which  **can**  be simultaneously created
///on a device is implementation-dependent and specified by the
///[maxSamplerAllocationCount](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#limits-maxSamplerAllocationCount) member of the
///[`PhysicalDeviceLimits`] structure.Since [`Sampler`] is a non-dispatchable handle type,
/// implementations
/// **may**  return the same handle for sampler state vectors that are identical.
///In such cases, all such objects would only count once against the
///`maxSamplerAllocationCount` limit.
///## Valid Usage
/// - The absolute value of [`mip_lod_bias`] **must**  be less than or equal to
///   [`PhysicalDeviceLimits::max_sampler_lod_bias`]
/// - If the `[`VK_KHR_portability_subset`]` extension is enabled, and
///   [`PhysicalDevicePortabilitySubsetFeaturesKHR::sampler_mip_lod_bias`] is [`FALSE`],
///   [`mip_lod_bias`] **must**  be zero
/// - [`max_lod`] **must**  be greater than or equal to [`min_lod`]
/// - If the [anisotropic sampling](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-samplerAnisotropy)
///   feature is not enabled, [`anisotropy_enable`] **must**  be [`FALSE`]
/// - If [`anisotropy_enable`] is [`TRUE`], [`max_anisotropy`] **must**  be between `1.0` and
///   [`PhysicalDeviceLimits::max_sampler_anisotropy`], inclusive
/// - If [sampler Y′C<sub>B</sub>C<sub>R</sub> conversion](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#samplers-YCbCr-conversion)
///   is enabled and the [potential format features](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#potential-format-features)
///   of the sampler Y′C<sub>B</sub>C<sub>R</sub> conversion do not support
///   `VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT`,
///   [`min_filter`] and [`mag_filter`] **must**  be equal to the sampler
///   Y′C<sub>B</sub>C<sub>R</sub> conversion’s `chromaFilter`
/// - If [`unnormalized_coordinates`] is [`TRUE`], [`min_filter`] and [`mag_filter`] **must**  be
///   equal
/// - If [`unnormalized_coordinates`] is [`TRUE`], [`mipmap_mode`] **must**  be
///   `VK_SAMPLER_MIPMAP_MODE_NEAREST`
/// - If [`unnormalized_coordinates`] is [`TRUE`], [`min_lod`] and [`max_lod`] **must**  be zero
/// - If [`unnormalized_coordinates`] is [`TRUE`], [`address_mode_u`] and [`address_mode_v`]
///   **must**  each be either `VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE` or
///   `VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER`
/// - If [`unnormalized_coordinates`] is [`TRUE`], [`anisotropy_enable`] **must**  be [`FALSE`]
/// - If [`unnormalized_coordinates`] is [`TRUE`], [`compare_enable`] **must**  be [`FALSE`]
/// - If any of [`address_mode_u`], [`address_mode_v`] or [`address_mode_w`] are
///   `VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER`, [`border_color`] **must**  be a valid
///   [`BorderColor`] value
/// - If [sampler Y′C<sub>B</sub>C<sub>R</sub> conversion](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#samplers-YCbCr-conversion)
///   is enabled, [`address_mode_u`], [`address_mode_v`], and [`address_mode_w`] **must**  be
///   `VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE`, [`anisotropy_enable`] **must**  be [`FALSE`], and
///   [`unnormalized_coordinates`] **must**  be [`FALSE`]
/// -    The sampler reduction mode  **must**  be set to `VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE` if [sampler Y′C<sub>B</sub>C<sub>R</sub> conversion](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#samplers-YCbCr-conversion) is enabled
/// - If [samplerMirrorClampToEdge](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-samplerMirrorClampToEdge)
///   is not enabled, and if the `[`VK_KHR_sampler_mirror_clamp_to_edge`]` extension is not enabled,
///   [`address_mode_u`], [`address_mode_v`] and [`address_mode_w`] **must**  not be
///   `VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE`
/// - If [`compare_enable`] is [`TRUE`], [`compare_op`] **must**  be a valid [`CompareOp`] value
/// - If either [`mag_filter`] or [`min_filter`] is `VK_FILTER_CUBIC_EXT`, [`anisotropy_enable`]
///   **must**  be [`FALSE`]
/// - If [`compare_enable`] is [`TRUE`], the `reductionMode` member of
///   [`SamplerReductionModeCreateInfo`] **must**  be `VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE`
/// - If [`flags`] includes `VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT`, then [`min_filter`] and
///   [`mag_filter`] **must**  be equal
/// - If [`flags`] includes `VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT`, then [`mipmap_mode`] **must**
///   be `VK_SAMPLER_MIPMAP_MODE_NEAREST`
/// - If [`flags`] includes `VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT`, then [`min_lod`] and [`max_lod`]
///   **must**  be zero
/// - If [`flags`] includes `VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT`, then [`address_mode_u`] and
///   [`address_mode_v`] **must**  each be either `VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE` or
///   `VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER`
/// - If [`flags`] includes `VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT`, then [`anisotropy_enable`]
///   **must**  be [`FALSE`]
/// - If [`flags`] includes `VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT`, then [`compare_enable`] **must**
///   be [`FALSE`]
/// - If [`flags`] includes `VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT`, then
///   [`unnormalized_coordinates`] **must**  be [`FALSE`]
/// - If [`border_color`] is one of `VK_BORDER_COLOR_FLOAT_CUSTOM_EXT` or
///   `VK_BORDER_COLOR_INT_CUSTOM_EXT`, then a [`SamplerCustomBorderColorCreateInfoEXT`] **must**
///   be included in the [`p_next`] chain
/// - If the [`customBorderColors`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-customBorderColors)
///   feature is not enabled, [`border_color`] **must**  not be `VK_BORDER_COLOR_FLOAT_CUSTOM_EXT`
///   or `VK_BORDER_COLOR_INT_CUSTOM_EXT`
/// - If [`border_color`] is one of `VK_BORDER_COLOR_FLOAT_CUSTOM_EXT` or
///   `VK_BORDER_COLOR_INT_CUSTOM_EXT`, and [`SamplerCustomBorderColorCreateInfoEXT::format`] is not
///   `VK_FORMAT_UNDEFINED`, [`SamplerCustomBorderColorCreateInfoEXT::custom_border_color`] **must**
///   be within the range of values representable in `format`
/// -    The maximum number of samplers with custom border colors which  **can**  be simultaneously created on a device is implementation-dependent and specified by the [maxCustomBorderColorSamplers](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#limits-maxCustomBorderColorSamplers) member of the [`PhysicalDeviceCustomBorderColorPropertiesEXT`] structure
///
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be `VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO`
/// - Each [`p_next`] member of any structure (including this one) in the [`p_next`] chain  **must**
///   be either `NULL` or a pointer to a valid instance of
///   [`SamplerBorderColorComponentMappingCreateInfoEXT`],
///   [`SamplerCustomBorderColorCreateInfoEXT`], [`SamplerReductionModeCreateInfo`], or
///   [`SamplerYcbcrConversionInfo`]
/// - The [`s_type`] value of each struct in the [`p_next`] chain  **must**  be unique
/// - [`flags`] **must**  be a valid combination of [`SamplerCreateFlagBits`] values
/// - [`mag_filter`] **must**  be a valid [`Filter`] value
/// - [`min_filter`] **must**  be a valid [`Filter`] value
/// - [`mipmap_mode`] **must**  be a valid [`SamplerMipmapMode`] value
/// - [`address_mode_u`] **must**  be a valid [`SamplerAddressMode`] value
/// - [`address_mode_v`] **must**  be a valid [`SamplerAddressMode`] value
/// - [`address_mode_w`] **must**  be a valid [`SamplerAddressMode`] value
///# Related
/// - [`crate::vulkan1_0`]
/// - [`Bool32`]
/// - [`BorderColor`]
/// - [`CompareOp`]
/// - [`Filter`]
/// - [`SamplerAddressMode`]
/// - [`SamplerCreateFlags`]
/// - [`SamplerMipmapMode`]
/// - [`StructureType`]
/// - [`CreateSampler`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, PartialEq, PartialOrd)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[repr(C)]
pub struct SamplerCreateInfo<'lt> {
    _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] is the type of this structure.
    s_type: StructureType,
    ///[`p_next`] is `NULL` or a pointer to a structure extending this
    ///structure.
    p_next: *const BaseInStructure<'lt>,
    ///[`flags`] is a bitmask of [`SamplerCreateFlagBits`] describing
    ///additional parameters of the sampler.
    flags: SamplerCreateFlags,
    ///[`mag_filter`] is a [`Filter`] value specifying the magnification
    ///filter to apply to lookups.
    mag_filter: Filter,
    ///[`min_filter`] is a [`Filter`] value specifying the minification
    ///filter to apply to lookups.
    min_filter: Filter,
    ///[`mipmap_mode`] is a [`SamplerMipmapMode`] value specifying the
    ///mipmap filter to apply to lookups.
    mipmap_mode: SamplerMipmapMode,
    ///[`address_mode_u`] is a [`SamplerAddressMode`] value specifying the
    ///addressing mode for U coordinates outside [0,1).
    address_mode_u: SamplerAddressMode,
    ///[`address_mode_v`] is a [`SamplerAddressMode`] value specifying the
    ///addressing mode for V coordinates outside [0,1).
    address_mode_v: SamplerAddressMode,
    ///[`address_mode_w`] is a [`SamplerAddressMode`] value specifying the
    ///addressing mode for W coordinates outside [0,1).
    address_mode_w: SamplerAddressMode,
    ///[`mip_lod_bias`] is the bias to be added to
    ///mipmap LOD (level-of-detail) calculation and bias provided by image
    ///sampling functions in SPIR-V, as described in the
    ///[Level-of-Detail Operation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#textures-level-of-detail-operation)
    ///section.
    mip_lod_bias: f32,
    ///[`anisotropy_enable`] is [`TRUE`] to
    ///enable anisotropic filtering, as described in the
    ///[Texel Anisotropic Filtering](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#textures-texel-anisotropic-filtering)
    ///section, or [`FALSE`] otherwise.
    anisotropy_enable: Bool32,
    ///[`max_anisotropy`] is the anisotropy value clamp used by the sampler
    ///when [`anisotropy_enable`] is [`TRUE`].
    ///If [`anisotropy_enable`] is [`FALSE`], [`max_anisotropy`] is
    ///ignored.
    max_anisotropy: f32,
    ///[`compare_enable`] is [`TRUE`] to enable comparison against a
    ///reference value during lookups, or [`FALSE`] otherwise.
    /// - Note: Some implementations will default to shader state if this member does not match.
    compare_enable: Bool32,
    ///[`compare_op`] is a [`CompareOp`] value specifying the comparison
    ///function to apply to fetched data before filtering as described in the
    ///[Depth Compare Operation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#textures-depth-compare-operation) section.
    compare_op: CompareOp,
    ///[`min_lod`] is used to clamp the [minimum of the computed LOD value](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#textures-level-of-detail-operation).
    min_lod: f32,
    ///[`max_lod`] is used to clamp the [maximum of the computed LOD value](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#textures-level-of-detail-operation).
    ///To avoid clamping the maximum value, set [`max_lod`] to the constant
    ///[`LOD_CLAMP_NONE`].
    max_lod: f32,
    ///[`border_color`] is a [`BorderColor`] value specifying the
    ///predefined border color to use.
    border_color: BorderColor,
    ///[`unnormalized_coordinates`]
    ///controls whether to use unnormalized or normalized texel coordinates to
    ///address texels of the image.
    ///When set to [`TRUE`], the range of the image coordinates used to
    ///lookup the texel is in the range of zero to the image size in each
    ///dimension.
    ///When set to [`FALSE`] the range of image coordinates is zero to
    ///one.When [`unnormalized_coordinates`] is [`TRUE`], images the sampler is
    ///used with in the shader have the following requirements:
    /// - The `viewType` **must**  be either `VK_IMAGE_VIEW_TYPE_1D` or `VK_IMAGE_VIEW_TYPE_2D`.
    /// - The image view  **must**  have a single layer and a single mip level.
    ///When [`unnormalized_coordinates`] is [`TRUE`], image built-in
    ///functions in the shader that use the sampler have the following
    ///requirements:
    /// - The functions  **must**  not use projection.
    /// - The functions  **must**  not use offsets.
    unnormalized_coordinates: Bool32,
}
impl<'lt> Default for SamplerCreateInfo<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: Default::default(),
            p_next: std::ptr::null(),
            flags: Default::default(),
            mag_filter: Default::default(),
            min_filter: Default::default(),
            mipmap_mode: Default::default(),
            address_mode_u: Default::default(),
            address_mode_v: Default::default(),
            address_mode_w: Default::default(),
            mip_lod_bias: 0.0,
            anisotropy_enable: 0,
            max_anisotropy: 0.0,
            compare_enable: 0,
            compare_op: Default::default(),
            min_lod: 0.0,
            max_lod: 0.0,
            border_color: Default::default(),
            unnormalized_coordinates: 0,
        }
    }
}
impl<'lt> SamplerCreateInfo<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *const BaseInStructure<'lt> {
        self.p_next
    }
    ///Gets the raw value of [`Self::anisotropy_enable`]
    pub fn anisotropy_enable_raw(&self) -> Bool32 {
        self.anisotropy_enable
    }
    ///Gets the raw value of [`Self::compare_enable`]
    pub fn compare_enable_raw(&self) -> Bool32 {
        self.compare_enable
    }
    ///Gets the raw value of [`Self::unnormalized_coordinates`]
    pub fn unnormalized_coordinates_raw(&self) -> Bool32 {
        self.unnormalized_coordinates
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *const BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::anisotropy_enable`]
    pub fn set_anisotropy_enable_raw(&mut self, value: Bool32) -> &mut Self {
        self.anisotropy_enable = value;
        self
    }
    ///Sets the raw value of [`Self::compare_enable`]
    pub fn set_compare_enable_raw(&mut self, value: Bool32) -> &mut Self {
        self.compare_enable = value;
        self
    }
    ///Sets the raw value of [`Self::unnormalized_coordinates`]
    pub fn set_unnormalized_coordinates_raw(&mut self, value: Bool32) -> &mut Self {
        self.unnormalized_coordinates = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseInStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::flags`]
    pub fn flags(&self) -> SamplerCreateFlags {
        self.flags
    }
    ///Gets the value of [`Self::mag_filter`]
    pub fn mag_filter(&self) -> Filter {
        self.mag_filter
    }
    ///Gets the value of [`Self::min_filter`]
    pub fn min_filter(&self) -> Filter {
        self.min_filter
    }
    ///Gets the value of [`Self::mipmap_mode`]
    pub fn mipmap_mode(&self) -> SamplerMipmapMode {
        self.mipmap_mode
    }
    ///Gets the value of [`Self::address_mode_u`]
    pub fn address_mode_u(&self) -> SamplerAddressMode {
        self.address_mode_u
    }
    ///Gets the value of [`Self::address_mode_v`]
    pub fn address_mode_v(&self) -> SamplerAddressMode {
        self.address_mode_v
    }
    ///Gets the value of [`Self::address_mode_w`]
    pub fn address_mode_w(&self) -> SamplerAddressMode {
        self.address_mode_w
    }
    ///Gets the value of [`Self::mip_lod_bias`]
    pub fn mip_lod_bias(&self) -> f32 {
        self.mip_lod_bias
    }
    ///Gets the value of [`Self::anisotropy_enable`]
    pub fn anisotropy_enable(&self) -> bool {
        unsafe { std::mem::transmute(self.anisotropy_enable as u8) }
    }
    ///Gets the value of [`Self::max_anisotropy`]
    pub fn max_anisotropy(&self) -> f32 {
        self.max_anisotropy
    }
    ///Gets the value of [`Self::compare_enable`]
    pub fn compare_enable(&self) -> bool {
        unsafe { std::mem::transmute(self.compare_enable as u8) }
    }
    ///Gets the value of [`Self::compare_op`]
    pub fn compare_op(&self) -> CompareOp {
        self.compare_op
    }
    ///Gets the value of [`Self::min_lod`]
    pub fn min_lod(&self) -> f32 {
        self.min_lod
    }
    ///Gets the value of [`Self::max_lod`]
    pub fn max_lod(&self) -> f32 {
        self.max_lod
    }
    ///Gets the value of [`Self::border_color`]
    pub fn border_color(&self) -> BorderColor {
        self.border_color
    }
    ///Gets the value of [`Self::unnormalized_coordinates`]
    pub fn unnormalized_coordinates(&self) -> bool {
        unsafe { std::mem::transmute(self.unnormalized_coordinates as u8) }
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::flags`]
    pub fn flags_mut(&mut self) -> &mut SamplerCreateFlags {
        &mut self.flags
    }
    ///Gets a mutable reference to the value of [`Self::mag_filter`]
    pub fn mag_filter_mut(&mut self) -> &mut Filter {
        &mut self.mag_filter
    }
    ///Gets a mutable reference to the value of [`Self::min_filter`]
    pub fn min_filter_mut(&mut self) -> &mut Filter {
        &mut self.min_filter
    }
    ///Gets a mutable reference to the value of [`Self::mipmap_mode`]
    pub fn mipmap_mode_mut(&mut self) -> &mut SamplerMipmapMode {
        &mut self.mipmap_mode
    }
    ///Gets a mutable reference to the value of [`Self::address_mode_u`]
    pub fn address_mode_u_mut(&mut self) -> &mut SamplerAddressMode {
        &mut self.address_mode_u
    }
    ///Gets a mutable reference to the value of [`Self::address_mode_v`]
    pub fn address_mode_v_mut(&mut self) -> &mut SamplerAddressMode {
        &mut self.address_mode_v
    }
    ///Gets a mutable reference to the value of [`Self::address_mode_w`]
    pub fn address_mode_w_mut(&mut self) -> &mut SamplerAddressMode {
        &mut self.address_mode_w
    }
    ///Gets a mutable reference to the value of [`Self::mip_lod_bias`]
    pub fn mip_lod_bias_mut(&mut self) -> &mut f32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::anisotropy_enable`]
    pub fn anisotropy_enable_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.anisotropy_enable as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.anisotropy_enable as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of [`Self::max_anisotropy`]
    pub fn max_anisotropy_mut(&mut self) -> &mut f32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::compare_enable`]
    pub fn compare_enable_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.compare_enable as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.compare_enable as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of [`Self::compare_op`]
    pub fn compare_op_mut(&mut self) -> &mut CompareOp {
        &mut self.compare_op
    }
    ///Gets a mutable reference to the value of [`Self::min_lod`]
    pub fn min_lod_mut(&mut self) -> &mut f32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::max_lod`]
    pub fn max_lod_mut(&mut self) -> &mut f32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::border_color`]
    pub fn border_color_mut(&mut self) -> &mut BorderColor {
        &mut self.border_color
    }
    ///Gets a mutable reference to the value of [`Self::unnormalized_coordinates`]
    pub fn unnormalized_coordinates_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.unnormalized_coordinates as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.unnormalized_coordinates as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Sets the raw value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the raw value of [`Self::flags`]
    pub fn set_flags(&mut self, value: crate::vulkan1_0::SamplerCreateFlags) -> &mut Self {
        self.flags = value;
        self
    }
    ///Sets the raw value of [`Self::mag_filter`]
    pub fn set_mag_filter(&mut self, value: crate::vulkan1_0::Filter) -> &mut Self {
        self.mag_filter = value;
        self
    }
    ///Sets the raw value of [`Self::min_filter`]
    pub fn set_min_filter(&mut self, value: crate::vulkan1_0::Filter) -> &mut Self {
        self.min_filter = value;
        self
    }
    ///Sets the raw value of [`Self::mipmap_mode`]
    pub fn set_mipmap_mode(&mut self, value: crate::vulkan1_0::SamplerMipmapMode) -> &mut Self {
        self.mipmap_mode = value;
        self
    }
    ///Sets the raw value of [`Self::address_mode_u`]
    pub fn set_address_mode_u(&mut self, value: crate::vulkan1_0::SamplerAddressMode) -> &mut Self {
        self.address_mode_u = value;
        self
    }
    ///Sets the raw value of [`Self::address_mode_v`]
    pub fn set_address_mode_v(&mut self, value: crate::vulkan1_0::SamplerAddressMode) -> &mut Self {
        self.address_mode_v = value;
        self
    }
    ///Sets the raw value of [`Self::address_mode_w`]
    pub fn set_address_mode_w(&mut self, value: crate::vulkan1_0::SamplerAddressMode) -> &mut Self {
        self.address_mode_w = value;
        self
    }
    ///Sets the raw value of [`Self::mip_lod_bias`]
    pub fn set_mip_lod_bias(&mut self, value: f32) -> &mut Self {
        self.mip_lod_bias = value;
        self
    }
    ///Sets the raw value of [`Self::anisotropy_enable`]
    pub fn set_anisotropy_enable(&mut self, value: bool) -> &mut Self {
        self.anisotropy_enable = value as u8 as u32;
        self
    }
    ///Sets the raw value of [`Self::max_anisotropy`]
    pub fn set_max_anisotropy(&mut self, value: f32) -> &mut Self {
        self.max_anisotropy = value;
        self
    }
    ///Sets the raw value of [`Self::compare_enable`]
    pub fn set_compare_enable(&mut self, value: bool) -> &mut Self {
        self.compare_enable = value as u8 as u32;
        self
    }
    ///Sets the raw value of [`Self::compare_op`]
    pub fn set_compare_op(&mut self, value: crate::vulkan1_0::CompareOp) -> &mut Self {
        self.compare_op = value;
        self
    }
    ///Sets the raw value of [`Self::min_lod`]
    pub fn set_min_lod(&mut self, value: f32) -> &mut Self {
        self.min_lod = value;
        self
    }
    ///Sets the raw value of [`Self::max_lod`]
    pub fn set_max_lod(&mut self, value: f32) -> &mut Self {
        self.max_lod = value;
        self
    }
    ///Sets the raw value of [`Self::border_color`]
    pub fn set_border_color(&mut self, value: crate::vulkan1_0::BorderColor) -> &mut Self {
        self.border_color = value;
        self
    }
    ///Sets the raw value of [`Self::unnormalized_coordinates`]
    pub fn set_unnormalized_coordinates(&mut self, value: bool) -> &mut Self {
        self.unnormalized_coordinates = value as u8 as u32;
        self
    }
}
///[VkCommandPoolCreateInfo](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandPoolCreateInfo.html) - Structure specifying parameters of a newly created command pool
///# C Specifications
///The [`CommandPoolCreateInfo`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkCommandPoolCreateInfo {
///    VkStructureType             sType;
///    const void*                 pNext;
///    VkCommandPoolCreateFlags    flags;
///    uint32_t                    queueFamilyIndex;
///} VkCommandPoolCreateInfo;
///```
///# Members
/// - [`s_type`] is the type of this structure.
/// - [`p_next`] is `NULL` or a pointer to a structure extending this structure.
/// - [`flags`] is a bitmask of [`CommandPoolCreateFlagBits`] indicating usage behavior for the pool
///   and command buffers allocated from it.
/// - [`queue_family_index`] designates a queue family as described in section [Queue Family Properties](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#devsandqueues-queueprops).
///   All command buffers allocated from this command pool  **must**  be submitted on queues from
///   the same queue family.
///# Description
///## Valid Usage
/// - If the protected memory feature is not enabled, the `VK_COMMAND_POOL_CREATE_PROTECTED_BIT` bit
///   of [`flags`] **must**  not be set
///
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be `VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO`
/// - [`p_next`] **must**  be `NULL`
/// - [`flags`] **must**  be a valid combination of [`CommandPoolCreateFlagBits`] values
///# Related
/// - [`crate::vulkan1_0`]
/// - [`CommandPoolCreateFlags`]
/// - [`StructureType`]
/// - [`CreateCommandPool`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[repr(C)]
pub struct CommandPoolCreateInfo<'lt> {
    _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] is the type of this structure.
    s_type: StructureType,
    ///[`p_next`] is `NULL` or a pointer to a structure extending this
    ///structure.
    p_next: *const BaseInStructure<'lt>,
    ///[`flags`] is a bitmask of [`CommandPoolCreateFlagBits`] indicating
    ///usage behavior for the pool and command buffers allocated from it.
    flags: CommandPoolCreateFlags,
    ///[`queue_family_index`] designates a queue family as described in section
    ///[Queue Family Properties](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#devsandqueues-queueprops).
    ///All command buffers allocated from this command pool  **must**  be submitted
    ///on queues from the same queue family.
    queue_family_index: u32,
}
impl<'lt> Default for CommandPoolCreateInfo<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: Default::default(),
            p_next: std::ptr::null(),
            flags: Default::default(),
            queue_family_index: 0,
        }
    }
}
impl<'lt> CommandPoolCreateInfo<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *const BaseInStructure<'lt> {
        self.p_next
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *const BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseInStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::flags`]
    pub fn flags(&self) -> CommandPoolCreateFlags {
        self.flags
    }
    ///Gets the value of [`Self::queue_family_index`]
    pub fn queue_family_index(&self) -> u32 {
        self.queue_family_index
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::flags`]
    pub fn flags_mut(&mut self) -> &mut CommandPoolCreateFlags {
        &mut self.flags
    }
    ///Gets a mutable reference to the value of [`Self::queue_family_index`]
    pub fn queue_family_index_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Sets the raw value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the raw value of [`Self::flags`]
    pub fn set_flags(&mut self, value: crate::vulkan1_0::CommandPoolCreateFlags) -> &mut Self {
        self.flags = value;
        self
    }
    ///Sets the raw value of [`Self::queue_family_index`]
    pub fn set_queue_family_index(&mut self, value: u32) -> &mut Self {
        self.queue_family_index = value;
        self
    }
}
///[VkCommandBufferAllocateInfo](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandBufferAllocateInfo.html) - Structure specifying the allocation parameters for command buffer object
///# C Specifications
///The [`CommandBufferAllocateInfo`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkCommandBufferAllocateInfo {
///    VkStructureType         sType;
///    const void*             pNext;
///    VkCommandPool           commandPool;
///    VkCommandBufferLevel    level;
///    uint32_t                commandBufferCount;
///} VkCommandBufferAllocateInfo;
///```
///# Members
/// - [`s_type`] is the type of this structure.
/// - [`p_next`] is `NULL` or a pointer to a structure extending this structure.
/// - [`command_pool`] is the command pool from which the command buffers are allocated.
/// - [`level`] is a [`CommandBufferLevel`] value specifying the command buffer level.
/// - [`command_buffer_count`] is the number of command buffers to allocate from the pool.
///# Description
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be `VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO`
/// - [`p_next`] **must**  be `NULL`
/// - [`command_pool`] **must**  be a valid [`CommandPool`] handle
/// - [`level`] **must**  be a valid [`CommandBufferLevel`] value
///# Related
/// - [`crate::vulkan1_0`]
/// - [`CommandBufferLevel`]
/// - [`CommandPool`]
/// - [`StructureType`]
/// - [`AllocateCommandBuffers`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[repr(C)]
pub struct CommandBufferAllocateInfo<'lt> {
    _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] is the type of this structure.
    s_type: StructureType,
    ///[`p_next`] is `NULL` or a pointer to a structure extending this
    ///structure.
    p_next: *const BaseInStructure<'lt>,
    ///[`command_pool`] is the command pool from which the command buffers are
    ///allocated.
    command_pool: CommandPool,
    ///[`level`] is a [`CommandBufferLevel`] value specifying the command
    ///buffer level.
    level: CommandBufferLevel,
    ///[`command_buffer_count`] is the number of command buffers to allocate
    ///from the pool.
    command_buffer_count: u32,
}
impl<'lt> Default for CommandBufferAllocateInfo<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: Default::default(),
            p_next: std::ptr::null(),
            command_pool: Default::default(),
            level: Default::default(),
            command_buffer_count: 0,
        }
    }
}
impl<'lt> CommandBufferAllocateInfo<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *const BaseInStructure<'lt> {
        self.p_next
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *const BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseInStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::command_pool`]
    pub fn command_pool(&self) -> CommandPool {
        self.command_pool
    }
    ///Gets the value of [`Self::level`]
    pub fn level(&self) -> CommandBufferLevel {
        self.level
    }
    ///Gets the value of [`Self::command_buffer_count`]
    pub fn command_buffer_count(&self) -> u32 {
        self.command_buffer_count
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::command_pool`]
    pub fn command_pool_mut(&mut self) -> &mut CommandPool {
        &mut self.command_pool
    }
    ///Gets a mutable reference to the value of [`Self::level`]
    pub fn level_mut(&mut self) -> &mut CommandBufferLevel {
        &mut self.level
    }
    ///Gets a mutable reference to the value of [`Self::command_buffer_count`]
    pub fn command_buffer_count_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Sets the raw value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the raw value of [`Self::command_pool`]
    pub fn set_command_pool(&mut self, value: crate::vulkan1_0::CommandPool) -> &mut Self {
        self.command_pool = value;
        self
    }
    ///Sets the raw value of [`Self::level`]
    pub fn set_level(&mut self, value: crate::vulkan1_0::CommandBufferLevel) -> &mut Self {
        self.level = value;
        self
    }
    ///Sets the raw value of [`Self::command_buffer_count`]
    pub fn set_command_buffer_count(&mut self, value: u32) -> &mut Self {
        self.command_buffer_count = value;
        self
    }
}
///[VkCommandBufferInheritanceInfo](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandBufferInheritanceInfo.html) - Structure specifying command buffer inheritance information
///# C Specifications
///If the command buffer is a secondary command buffer, then the
///[`CommandBufferInheritanceInfo`] structure defines any state that will
///be inherited from the primary command buffer:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkCommandBufferInheritanceInfo {
///    VkStructureType                  sType;
///    const void*                      pNext;
///    VkRenderPass                     renderPass;
///    uint32_t                         subpass;
///    VkFramebuffer                    framebuffer;
///    VkBool32                         occlusionQueryEnable;
///    VkQueryControlFlags              queryFlags;
///    VkQueryPipelineStatisticFlags    pipelineStatistics;
///} VkCommandBufferInheritanceInfo;
///```
///# Members
/// - [`s_type`] is the type of this structure.
/// - [`p_next`] is `NULL` or a pointer to a structure extending this structure.
/// - [`render_pass`] is a [`RenderPass`] object defining which render passes the [`CommandBuffer`] will be [compatible](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-compatibility) with and  **can**  be executed within.
/// - [`subpass`] is the index of the subpass within the render pass instance that the
///   [`CommandBuffer`] will be executed within.
/// - [`framebuffer`] **can**  refer to the [`Framebuffer`] object that the [`CommandBuffer`] will
///   be rendering to if it is executed within a render pass instance. It  **can**  be
///   [`crate::utils::Handle::null`] if the framebuffer is not known.
/// - [`occlusion_query_enable`] specifies whether the command buffer  **can**  be executed while an
///   occlusion query is active in the primary command buffer. If this is [`TRUE`], then this
///   command buffer  **can**  be executed whether the primary command buffer has an occlusion query
///   active or not. If this is [`FALSE`], then the primary command buffer  **must**  not have an
///   occlusion query active.
/// - [`query_flags`] specifies the query flags that  **can**  be used by an active occlusion query
///   in the primary command buffer when this secondary command buffer is executed. If this value
///   includes the `VK_QUERY_CONTROL_PRECISE_BIT` bit, then the active query  **can**  return
///   boolean results or actual sample counts. If this bit is not set, then the active query
///   **must**  not use the `VK_QUERY_CONTROL_PRECISE_BIT` bit.
/// - [`pipeline_statistics`] is a bitmask of [`QueryPipelineStatisticFlagBits`] specifying the set
///   of pipeline statistics that  **can**  be counted by an active query in the primary command
///   buffer when this secondary command buffer is executed. If this value includes a given bit,
///   then this command buffer  **can**  be executed whether the primary command buffer has a
///   pipeline statistics query active that includes this bit or not. If this value excludes a given
///   bit, then the active pipeline statistics query  **must**  not be from a query pool that counts
///   that statistic.
///# Description
///If the [`CommandBuffer`] will not be executed within a render pass
///instance,
///or if the render pass instance was begun with [`CmdBeginRendering`],
///[`render_pass`], [`subpass`], and [`framebuffer`] are ignored.
///## Valid Usage
/// - If the [inherited queries](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-inheritedQueries)
///   feature is not enabled, [`occlusion_query_enable`] **must**  be [`FALSE`]
/// - If the [inherited queries](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-inheritedQueries)
///   feature is enabled, [`query_flags`] **must**  be a valid combination of
///   [`QueryControlFlagBits`] values
/// - If the [inherited queries](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-inheritedQueries)
///   feature is not enabled, [`query_flags`] **must**  be `0`
/// - If the [pipeline statistics queries](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-pipelineStatisticsQuery)
///   feature is enabled, [`pipeline_statistics`] **must**  be a valid combination of
///   [`QueryPipelineStatisticFlagBits`] values
/// - If the [pipeline statistics queries](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-pipelineStatisticsQuery)
///   feature is not enabled, [`pipeline_statistics`] **must**  be `0`
///
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be `VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO`
/// - Each [`p_next`] member of any structure (including this one) in the [`p_next`] chain  **must**
///   be either `NULL` or a pointer to a valid instance of [`AttachmentSampleCountInfoAMD`],
///   [`CommandBufferInheritanceConditionalRenderingInfoEXT`],
///   [`CommandBufferInheritanceRenderPassTransformInfoQCOM`],
///   [`CommandBufferInheritanceRenderingInfo`], [`CommandBufferInheritanceViewportScissorInfoNV`],
///   or [`MultiviewPerViewAttributesInfoNVX`]
/// - The [`s_type`] value of each struct in the [`p_next`] chain  **must**  be unique
/// - Both of [`framebuffer`], and [`render_pass`] that are valid handles of non-ignored parameters
///   **must**  have been created, allocated, or retrieved from the same [`Device`]
///# Related
/// - [`crate::vulkan1_0`]
/// - [`Bool32`]
/// - [`CommandBufferBeginInfo`]
/// - [`Framebuffer`]
/// - [`QueryControlFlags`]
/// - [`QueryPipelineStatisticFlags`]
/// - [`RenderPass`]
/// - [`StructureType`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[repr(C)]
pub struct CommandBufferInheritanceInfo<'lt> {
    _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] is the type of this structure.
    s_type: StructureType,
    ///[`p_next`] is `NULL` or a pointer to a structure extending this
    ///structure.
    p_next: *const BaseInStructure<'lt>,
    ///[`render_pass`] is a [`RenderPass`] object defining which render
    ///passes the [`CommandBuffer`] will be [compatible](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-compatibility) with and  **can**  be executed within.
    render_pass: RenderPass,
    ///[`subpass`] is the index of the subpass within the render pass
    ///instance that the [`CommandBuffer`] will be executed within.
    subpass: u32,
    ///[`framebuffer`] **can**  refer to the [`Framebuffer`] object that the
    ///[`CommandBuffer`] will be rendering to if it is executed within a
    ///render pass instance.
    ///It  **can**  be [`crate::utils::Handle::null`] if the framebuffer is not known.
    framebuffer: Framebuffer,
    ///[`occlusion_query_enable`] specifies whether the command buffer  **can**  be
    ///executed while an occlusion query is active in the primary command
    ///buffer.
    ///If this is [`TRUE`], then this command buffer  **can**  be executed
    ///whether the primary command buffer has an occlusion query active or not.
    ///If this is [`FALSE`], then the primary command buffer  **must**  not
    ///have an occlusion query active.
    occlusion_query_enable: Bool32,
    ///[`query_flags`] specifies the query flags that  **can**  be used by an
    ///active occlusion query in the primary command buffer when this secondary
    ///command buffer is executed.
    ///If this value includes the `VK_QUERY_CONTROL_PRECISE_BIT` bit, then
    ///the active query  **can**  return boolean results or actual sample counts.
    ///If this bit is not set, then the active query  **must**  not use the
    ///`VK_QUERY_CONTROL_PRECISE_BIT` bit.
    query_flags: QueryControlFlags,
    ///[`pipeline_statistics`] is a bitmask of
    ///[`QueryPipelineStatisticFlagBits`] specifying the set of pipeline
    ///statistics that  **can**  be counted by an active query in the primary
    ///command buffer when this secondary command buffer is executed.
    ///If this value includes a given bit, then this command buffer  **can**  be
    ///executed whether the primary command buffer has a pipeline statistics
    ///query active that includes this bit or not.
    ///If this value excludes a given bit, then the active pipeline statistics
    ///query  **must**  not be from a query pool that counts that statistic.
    pipeline_statistics: QueryPipelineStatisticFlags,
}
impl<'lt> Default for CommandBufferInheritanceInfo<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: Default::default(),
            p_next: std::ptr::null(),
            render_pass: Default::default(),
            subpass: 0,
            framebuffer: Default::default(),
            occlusion_query_enable: 0,
            query_flags: Default::default(),
            pipeline_statistics: Default::default(),
        }
    }
}
impl<'lt> CommandBufferInheritanceInfo<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *const BaseInStructure<'lt> {
        self.p_next
    }
    ///Gets the raw value of [`Self::occlusion_query_enable`]
    pub fn occlusion_query_enable_raw(&self) -> Bool32 {
        self.occlusion_query_enable
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *const BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::occlusion_query_enable`]
    pub fn set_occlusion_query_enable_raw(&mut self, value: Bool32) -> &mut Self {
        self.occlusion_query_enable = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseInStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::render_pass`]
    pub fn render_pass(&self) -> RenderPass {
        self.render_pass
    }
    ///Gets the value of [`Self::subpass`]
    pub fn subpass(&self) -> u32 {
        self.subpass
    }
    ///Gets the value of [`Self::framebuffer`]
    pub fn framebuffer(&self) -> Framebuffer {
        self.framebuffer
    }
    ///Gets the value of [`Self::occlusion_query_enable`]
    pub fn occlusion_query_enable(&self) -> bool {
        unsafe { std::mem::transmute(self.occlusion_query_enable as u8) }
    }
    ///Gets the value of [`Self::query_flags`]
    pub fn query_flags(&self) -> QueryControlFlags {
        self.query_flags
    }
    ///Gets the value of [`Self::pipeline_statistics`]
    pub fn pipeline_statistics(&self) -> QueryPipelineStatisticFlags {
        self.pipeline_statistics
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::render_pass`]
    pub fn render_pass_mut(&mut self) -> &mut RenderPass {
        &mut self.render_pass
    }
    ///Gets a mutable reference to the value of [`Self::subpass`]
    pub fn subpass_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::framebuffer`]
    pub fn framebuffer_mut(&mut self) -> &mut Framebuffer {
        &mut self.framebuffer
    }
    ///Gets a mutable reference to the value of [`Self::occlusion_query_enable`]
    pub fn occlusion_query_enable_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.occlusion_query_enable as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.occlusion_query_enable as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of [`Self::query_flags`]
    pub fn query_flags_mut(&mut self) -> &mut QueryControlFlags {
        &mut self.query_flags
    }
    ///Gets a mutable reference to the value of [`Self::pipeline_statistics`]
    pub fn pipeline_statistics_mut(&mut self) -> &mut QueryPipelineStatisticFlags {
        &mut self.pipeline_statistics
    }
    ///Sets the raw value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the raw value of [`Self::render_pass`]
    pub fn set_render_pass(&mut self, value: crate::vulkan1_0::RenderPass) -> &mut Self {
        self.render_pass = value;
        self
    }
    ///Sets the raw value of [`Self::subpass`]
    pub fn set_subpass(&mut self, value: u32) -> &mut Self {
        self.subpass = value;
        self
    }
    ///Sets the raw value of [`Self::framebuffer`]
    pub fn set_framebuffer(&mut self, value: crate::vulkan1_0::Framebuffer) -> &mut Self {
        self.framebuffer = value;
        self
    }
    ///Sets the raw value of [`Self::occlusion_query_enable`]
    pub fn set_occlusion_query_enable(&mut self, value: bool) -> &mut Self {
        self.occlusion_query_enable = value as u8 as u32;
        self
    }
    ///Sets the raw value of [`Self::query_flags`]
    pub fn set_query_flags(&mut self, value: crate::vulkan1_0::QueryControlFlags) -> &mut Self {
        self.query_flags = value;
        self
    }
    ///Sets the raw value of [`Self::pipeline_statistics`]
    pub fn set_pipeline_statistics(&mut self, value: crate::vulkan1_0::QueryPipelineStatisticFlags) -> &mut Self {
        self.pipeline_statistics = value;
        self
    }
}
///[VkCommandBufferBeginInfo](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandBufferBeginInfo.html) - Structure specifying a command buffer begin operation
///# C Specifications
///The [`CommandBufferBeginInfo`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkCommandBufferBeginInfo {
///    VkStructureType                          sType;
///    const void*                              pNext;
///    VkCommandBufferUsageFlags                flags;
///    const VkCommandBufferInheritanceInfo*    pInheritanceInfo;
///} VkCommandBufferBeginInfo;
///```
///# Members
/// - [`s_type`] is the type of this structure.
/// - [`p_next`] is `NULL` or a pointer to a structure extending this structure.
/// - [`flags`] is a bitmask of [`CommandBufferUsageFlagBits`] specifying usage behavior for the
///   command buffer.
/// - [`inheritance_info`] is a pointer to a [`CommandBufferInheritanceInfo`] structure, used if
///   `commandBuffer` is a secondary command buffer. If this is a primary command buffer, then this
///   value is ignored.
///# Description
///## Valid Usage
/// - If [`flags`] contains `VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT`, the `framebuffer`
///   member of [`inheritance_info`] **must**  be either [`crate::utils::Handle::null`], or a valid
///   [`Framebuffer`] that is compatible with the `renderPass` member of [`inheritance_info`]
/// - If [`flags`] contains `VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT` and the `renderPass`
///   member of [`inheritance_info`] is not [`crate::utils::Handle::null`], `renderPass` **must**
///   be a valid [`RenderPass`]
/// - If [`flags`] contains `VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT` and the `renderPass`
///   member of [`inheritance_info`] is not [`crate::utils::Handle::null`], the `subpass` member of
///   [`inheritance_info`] **must**  be a valid subpass index within the `renderPass` member of
///   [`inheritance_info`]
/// - If [`flags`] contains `VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT` and the `renderPass`
///   member of [`inheritance_info`] is [`crate::utils::Handle::null`], the [`p_next`] chain of
///   [`inheritance_info`] **must**  include a [`CommandBufferInheritanceRenderingInfo`] structure
/// - If [`flags`] contains `VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT`, the `renderPass`
///   member of [`inheritance_info`] is [`crate::utils::Handle::null`], and the [`p_next`] chain of
///   [`inheritance_info`] includes a [`AttachmentSampleCountInfoAMD`] or
///   [`AttachmentSampleCountInfoNV`] structure, the `colorAttachmentCount` member of that structure
///   **must**  be equal to the value of
///   [`CommandBufferInheritanceRenderingInfo::color_attachment_count`]
///
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be `VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO`
/// - [`p_next`] **must**  be `NULL` or a pointer to a valid instance of
///   [`DeviceGroupCommandBufferBeginInfo`]
/// - The [`s_type`] value of each struct in the [`p_next`] chain  **must**  be unique
/// - [`flags`] **must**  be a valid combination of [`CommandBufferUsageFlagBits`] values
///# Related
/// - [`crate::vulkan1_0`]
/// - [`CommandBufferInheritanceInfo`]
/// - [`CommandBufferUsageFlags`]
/// - [`StructureType`]
/// - [`BeginCommandBuffer`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[repr(C)]
pub struct CommandBufferBeginInfo<'lt> {
    _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] is the type of this structure.
    s_type: StructureType,
    ///[`p_next`] is `NULL` or a pointer to a structure extending this
    ///structure.
    p_next: *const BaseInStructure<'lt>,
    ///[`flags`] is a bitmask of [`CommandBufferUsageFlagBits`]
    ///specifying usage behavior for the command buffer.
    flags: CommandBufferUsageFlags,
    ///[`inheritance_info`] is a pointer to a
    ///[`CommandBufferInheritanceInfo`] structure, used if
    ///`commandBuffer` is a secondary command buffer.
    ///If this is a primary command buffer, then this value is ignored.
    inheritance_info: *const CommandBufferInheritanceInfo<'lt>,
}
impl<'lt> Default for CommandBufferBeginInfo<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: Default::default(),
            p_next: std::ptr::null(),
            flags: Default::default(),
            inheritance_info: std::ptr::null(),
        }
    }
}
impl<'lt> CommandBufferBeginInfo<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *const BaseInStructure<'lt> {
        self.p_next
    }
    ///Gets the raw value of [`Self::inheritance_info`]
    pub fn inheritance_info_raw(&self) -> *const CommandBufferInheritanceInfo<'lt> {
        self.inheritance_info
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *const BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::inheritance_info`]
    pub fn set_inheritance_info_raw(&mut self, value: *const CommandBufferInheritanceInfo<'lt>) -> &mut Self {
        self.inheritance_info = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseInStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::flags`]
    pub fn flags(&self) -> CommandBufferUsageFlags {
        self.flags
    }
    ///Gets the value of [`Self::inheritance_info`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn inheritance_info(&self) -> &CommandBufferInheritanceInfo<'lt> {
        &*self.inheritance_info
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::flags`]
    pub fn flags_mut(&mut self) -> &mut CommandBufferUsageFlags {
        &mut self.flags
    }
    ///Sets the raw value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the raw value of [`Self::flags`]
    pub fn set_flags(&mut self, value: crate::vulkan1_0::CommandBufferUsageFlags) -> &mut Self {
        self.flags = value;
        self
    }
    ///Sets the raw value of [`Self::inheritance_info`]
    pub fn set_inheritance_info(
        &mut self,
        value: &'lt crate::vulkan1_0::CommandBufferInheritanceInfo<'lt>,
    ) -> &mut Self {
        self.inheritance_info = value as *const _;
        self
    }
}
///[VkRenderPassBeginInfo](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderPassBeginInfo.html) - Structure specifying render pass begin information
///# C Specifications
///The [`RenderPassBeginInfo`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkRenderPassBeginInfo {
///    VkStructureType        sType;
///    const void*            pNext;
///    VkRenderPass           renderPass;
///    VkFramebuffer          framebuffer;
///    VkRect2D               renderArea;
///    uint32_t               clearValueCount;
///    const VkClearValue*    pClearValues;
///} VkRenderPassBeginInfo;
///```
///# Members
/// - [`s_type`] is the type of this structure.
/// - [`p_next`] is `NULL` or a pointer to a structure extending this structure.
/// - [`render_pass`] is the render pass to begin an instance of.
/// - [`framebuffer`] is the framebuffer containing the attachments that are used with the render
///   pass.
/// - [`render_area`] is the render area that is affected by the render pass instance, and is
///   described in more detail below.
/// - [`clear_value_count`] is the number of elements in [`clear_values`].
/// - [`clear_values`] is a pointer to an array of [`clear_value_count`][`ClearValue`] structures
///   containing clear values for each attachment, if the attachment uses a `loadOp` value of
///   `VK_ATTACHMENT_LOAD_OP_CLEAR` or if the attachment has a depth/stencil format and uses a
///   `stencilLoadOp` value of `VK_ATTACHMENT_LOAD_OP_CLEAR`. The array is indexed by attachment
///   number. Only elements corresponding to cleared attachments are used. Other elements of
///   [`clear_values`] are ignored.
///# Description
///[`render_area`] is the render area that is affected by the render pass
///instance.
///The effects of attachment load, store and multisample resolve operations are
///restricted to the pixels whose x and y coordinates fall within the render
///area on all attachments.
///The render area extends to all layers of [`framebuffer`].
///The application  **must**  ensure (using scissor if necessary) that all rendering
///is contained within the render area.
///The render area, after any transform specified by
///[`RenderPassTransformBeginInfoQCOM::transform`] is applied,  **must**
///be contained within the framebuffer dimensions.If [render pass transform](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#vertexpostproc-renderpass-transform) is
///enabled, then [`render_area`] **must**  equal the framebuffer pre-transformed
///dimensions.
///After [`render_area`] has been transformed by
///[`RenderPassTransformBeginInfoQCOM::transform`], the resulting
///render area  **must**  be equal to the framebuffer dimensions.If [subpass shading](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-subpassShading) is enabled, then
///[`render_area`] **must**  equal the framebuffer dimensions.When multiview is enabled, the
/// resolve operation at the end of a subpass
///applies to all views in the view mask.
///## Valid Usage
/// - [`clear_value_count`] **must**  be greater than the largest attachment index in
///   [`render_pass`] specifying a `loadOp` (or `stencilLoadOp`, if the attachment has a
///   depth/stencil format) of `VK_ATTACHMENT_LOAD_OP_CLEAR`
/// - If [`clear_value_count`] is not `0`, [`clear_values`] **must**  be a valid pointer to an array
///   of [`clear_value_count`][`ClearValue`] unions
/// - [`render_pass`] **must**  be [compatible](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-compatibility)
///   with the [`render_pass`] member of the [`FramebufferCreateInfo`] structure specified when
///   creating [`framebuffer`]
/// - If the [`p_next`] chain does not contain [`DeviceGroupRenderPassBeginInfo`] or its
///   `deviceRenderAreaCount` member is equal to 0, `renderArea.offset.x` **must**  be greater than
///   or equal to 0
/// - If the [`p_next`] chain does not contain [`DeviceGroupRenderPassBeginInfo`] or its
///   `deviceRenderAreaCount` member is equal to 0, `renderArea.offset.y` **must**  be greater than
///   or equal to 0
/// - If the [`p_next`] chain does not contain [`DeviceGroupRenderPassBeginInfo`] or its
///   `deviceRenderAreaCount` member is equal to 0, `renderArea.offset.x` +
///   `renderArea.extent.width` **must**  be less than or equal to [`FramebufferCreateInfo::width`]
///   the [`framebuffer`] was created with
/// - If the [`p_next`] chain does not contain [`DeviceGroupRenderPassBeginInfo`] or its
///   `deviceRenderAreaCount` member is equal to 0, `renderArea.offset.y` +
///   `renderArea.extent.height` **must**  be less than or equal to
///   [`FramebufferCreateInfo::height`] the [`framebuffer`] was created with
/// - If the [`p_next`] chain contains [`DeviceGroupRenderPassBeginInfo`], `offset.x` +
///   `extent.width` of each element of `pDeviceRenderAreas` **must**  be less than or equal to
///   [`FramebufferCreateInfo::width`] the [`framebuffer`] was created with
/// - If the [`p_next`] chain contains [`DeviceGroupRenderPassBeginInfo`], `offset.y` +
///   `extent.height` of each element of `pDeviceRenderAreas` **must**  be less than or equal to
///   [`FramebufferCreateInfo::height`] the [`framebuffer`] was created with
/// - If [`framebuffer`] was created with a [`FramebufferCreateInfo::flags`] value that did not
///   include `VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT`, and the [`p_next`] chain includes a
///   [`RenderPassAttachmentBeginInfo`] structure, its `attachmentCount` **must**  be zero
/// - If [`framebuffer`] was created with a [`FramebufferCreateInfo::flags`] value that included
///   `VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT`, the `attachmentCount` of a
///   [`RenderPassAttachmentBeginInfo`] structure included in the [`p_next`] chain  **must**  be
///   equal to the value of [`FramebufferAttachmentsCreateInfo::attachment_image_info_count`] used
///   to create [`framebuffer`]
/// - If [`framebuffer`] was created with a [`FramebufferCreateInfo::flags`] value that included
///   `VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT`, each element of the `pAttachments` member of a
///   [`RenderPassAttachmentBeginInfo`] structure included in the [`p_next`] chain  **must**  have
///   been created on the same [`Device`] as [`framebuffer`] and [`render_pass`]
/// - If [`framebuffer`] was created with a [`FramebufferCreateInfo::flags`] value that included
///   `VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT`, each element of the `pAttachments` member of a
///   [`RenderPassAttachmentBeginInfo`] structure included in the [`p_next`] chain  **must**  be a
///   [`ImageView`] of an image created with a value of [`ImageCreateInfo::flags`] equal to the
///   `flags` member of the corresponding element of
///   [`FramebufferAttachmentsCreateInfo::attachment_image_infos`] used to create [`framebuffer`]
/// -    If [`framebuffer`] was created with a [`FramebufferCreateInfo::flags`] value that included `VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT`, each element of the `pAttachments` member of a [`RenderPassAttachmentBeginInfo`] structure included in the [`p_next`] chain  **must**  be a [`ImageView`] with [an inherited usage](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#resources-image-inherited-usage) equal to the `usage` member of the corresponding element of [`FramebufferAttachmentsCreateInfo::attachment_image_infos`] used to create [`framebuffer`]
/// - If [`framebuffer`] was created with a [`FramebufferCreateInfo::flags`] value that included
///   `VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT`, each element of the `pAttachments` member of a
///   [`RenderPassAttachmentBeginInfo`] structure included in the [`p_next`] chain  **must**  be a
///   [`ImageView`] with a width equal to the `width` member of the corresponding element of
///   [`FramebufferAttachmentsCreateInfo::attachment_image_infos`] used to create [`framebuffer`]
/// - If [`framebuffer`] was created with a [`FramebufferCreateInfo::flags`] value that included
///   `VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT`, each element of the `pAttachments` member of a
///   [`RenderPassAttachmentBeginInfo`] structure included in the [`p_next`] chain  **must**  be a
///   [`ImageView`] with a height equal to the `height` member of the corresponding element of
///   [`FramebufferAttachmentsCreateInfo::attachment_image_infos`] used to create [`framebuffer`]
/// - If [`framebuffer`] was created with a [`FramebufferCreateInfo::flags`] value that included
///   `VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT`, each element of the `pAttachments` member of a
///   [`RenderPassAttachmentBeginInfo`] structure included in the [`p_next`] chain  **must**  be a
///   [`ImageView`] of an image created with a value of
///   [`ImageViewCreateInfo`]::`subresourceRange.layerCount` equal to the `layerCount` member of the
///   corresponding element of [`FramebufferAttachmentsCreateInfo::attachment_image_infos`] used to
///   create [`framebuffer`]
/// - If [`framebuffer`] was created with a [`FramebufferCreateInfo::flags`] value that included
///   `VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT`, each element of the `pAttachments` member of a
///   [`RenderPassAttachmentBeginInfo`] structure included in the [`p_next`] chain  **must**  be a
///   [`ImageView`] of an image created with a value of
///   [`ImageFormatListCreateInfo::view_format_count`] equal to the `viewFormatCount` member of the
///   corresponding element of [`FramebufferAttachmentsCreateInfo::attachment_image_infos`] used to
///   create [`framebuffer`]
/// - If [`framebuffer`] was created with a [`FramebufferCreateInfo::flags`] value that included
///   `VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT`, each element of the `pAttachments` member of a
///   [`RenderPassAttachmentBeginInfo`] structure included in the [`p_next`] chain  **must**  be a
///   [`ImageView`] of an image created with a set of elements in
///   [`ImageFormatListCreateInfo::view_formats`] equal to the set of elements in the `pViewFormats`
///   member of the corresponding element of
///   [`FramebufferAttachmentsCreateInfo::attachment_image_infos`] used to create [`framebuffer`]
/// - If [`framebuffer`] was created with a [`FramebufferCreateInfo::flags`] value that included
///   `VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT`, each element of the `pAttachments` member of a
///   [`RenderPassAttachmentBeginInfo`] structure included in the [`p_next`] chain  **must**  be a
///   [`ImageView`] of an image created with a value of [`ImageViewCreateInfo::format`] equal to the
///   corresponding value of [`AttachmentDescription::format`] in [`render_pass`]
/// - If [`framebuffer`] was created with a [`FramebufferCreateInfo::flags`] value that included
///   `VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT`, each element of the `pAttachments` member of a
///   [`RenderPassAttachmentBeginInfo`] structure included in the [`p_next`] chain  **must**  be a
///   [`ImageView`] of an image created with a value of [`ImageCreateInfo::samples`] equal to the
///   corresponding value of [`AttachmentDescription::samples`] in [`render_pass`]
/// - If the [`p_next`] chain includes [`RenderPassTransformBeginInfoQCOM`], `renderArea.offset`
///   **must**  equal (0,0)
/// - If the [`p_next`] chain includes [`RenderPassTransformBeginInfoQCOM`], `renderArea.extent`
///   transformed by [`RenderPassTransformBeginInfoQCOM::transform`] **must**  equal the
///   [`framebuffer`] dimensions
///
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be `VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO`
/// - Each [`p_next`] member of any structure (including this one) in the [`p_next`] chain  **must**
///   be either `NULL` or a pointer to a valid instance of [`DeviceGroupRenderPassBeginInfo`],
///   [`RenderPassAttachmentBeginInfo`], [`RenderPassSampleLocationsBeginInfoEXT`], or
///   [`RenderPassTransformBeginInfoQCOM`]
/// - The [`s_type`] value of each struct in the [`p_next`] chain  **must**  be unique
/// - [`render_pass`] **must**  be a valid [`RenderPass`] handle
/// - [`framebuffer`] **must**  be a valid [`Framebuffer`] handle
/// - Both of [`framebuffer`], and [`render_pass`] **must**  have been created, allocated, or
///   retrieved from the same [`Device`]
///# Related
/// - [`crate::vulkan1_0`]
/// - [`ClearValue`]
/// - [`Framebuffer`]
/// - [`Rect2D`]
/// - [`RenderPass`]
/// - [`StructureType`]
/// - [`CmdBeginRenderPass`]
/// - [`CmdBeginRenderPass2`]
/// - [`CmdBeginRenderPass2KHR`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[repr(C)]
pub struct RenderPassBeginInfo<'lt> {
    _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] is the type of this structure.
    s_type: StructureType,
    ///[`p_next`] is `NULL` or a pointer to a structure extending this
    ///structure.
    p_next: *const BaseInStructure<'lt>,
    ///[`render_pass`] is the render pass to begin an instance of.
    render_pass: RenderPass,
    ///[`framebuffer`] is the framebuffer containing the attachments that are
    ///used with the render pass.
    framebuffer: Framebuffer,
    ///[`render_area`] is the render area that is affected by the render pass
    ///instance, and is described in more detail below.
    render_area: Rect2D,
    ///[`clear_value_count`] is the number of elements in [`clear_values`].
    clear_value_count: u32,
    ///[`clear_values`] is a pointer to an array of [`clear_value_count`][`ClearValue`] structures
    /// containing clear values for each attachment, if the attachment uses a `loadOp` value of
    ///`VK_ATTACHMENT_LOAD_OP_CLEAR` or if the attachment has a
    ///depth/stencil format and uses a `stencilLoadOp` value of
    ///`VK_ATTACHMENT_LOAD_OP_CLEAR`.
    ///The array is indexed by attachment number.
    ///Only elements corresponding to cleared attachments are used.
    ///Other elements of [`clear_values`] are ignored.
    clear_values: *const ClearValue,
}
impl<'lt> Default for RenderPassBeginInfo<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: Default::default(),
            p_next: std::ptr::null(),
            render_pass: Default::default(),
            framebuffer: Default::default(),
            render_area: Default::default(),
            clear_value_count: 0,
            clear_values: std::ptr::null(),
        }
    }
}
impl<'lt> RenderPassBeginInfo<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *const BaseInStructure<'lt> {
        self.p_next
    }
    ///Gets the raw value of [`Self::clear_values`]
    pub fn clear_values_raw(&self) -> *const ClearValue {
        self.clear_values
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *const BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::clear_values`]
    pub fn set_clear_values_raw(&mut self, value: *const ClearValue) -> &mut Self {
        self.clear_values = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseInStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::render_pass`]
    pub fn render_pass(&self) -> RenderPass {
        self.render_pass
    }
    ///Gets the value of [`Self::framebuffer`]
    pub fn framebuffer(&self) -> Framebuffer {
        self.framebuffer
    }
    ///Gets the value of [`Self::render_area`]
    pub fn render_area(&self) -> Rect2D {
        self.render_area
    }
    ///Gets the value of [`Self::clear_value_count`]
    pub fn clear_value_count(&self) -> u32 {
        self.clear_value_count
    }
    ///Gets the value of [`Self::clear_values`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn clear_values(&self) -> &[ClearValue] {
        std::slice::from_raw_parts(self.clear_values, self.clear_value_count as usize)
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::render_pass`]
    pub fn render_pass_mut(&mut self) -> &mut RenderPass {
        &mut self.render_pass
    }
    ///Gets a mutable reference to the value of [`Self::framebuffer`]
    pub fn framebuffer_mut(&mut self) -> &mut Framebuffer {
        &mut self.framebuffer
    }
    ///Gets a mutable reference to the value of [`Self::render_area`]
    pub fn render_area_mut(&mut self) -> &mut Rect2D {
        &mut self.render_area
    }
    ///Gets a mutable reference to the value of [`Self::clear_value_count`]
    pub fn clear_value_count_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Sets the raw value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the raw value of [`Self::render_pass`]
    pub fn set_render_pass(&mut self, value: crate::vulkan1_0::RenderPass) -> &mut Self {
        self.render_pass = value;
        self
    }
    ///Sets the raw value of [`Self::framebuffer`]
    pub fn set_framebuffer(&mut self, value: crate::vulkan1_0::Framebuffer) -> &mut Self {
        self.framebuffer = value;
        self
    }
    ///Sets the raw value of [`Self::render_area`]
    pub fn set_render_area(&mut self, value: crate::vulkan1_0::Rect2D) -> &mut Self {
        self.render_area = value;
        self
    }
    ///Sets the raw value of [`Self::clear_value_count`]
    pub fn set_clear_value_count(&mut self, value: u32) -> &mut Self {
        self.clear_value_count = value;
        self
    }
    ///Sets the raw value of [`Self::clear_values`]
    pub fn set_clear_values(&mut self, value: &'lt [crate::vulkan1_0::ClearValue]) -> &mut Self {
        let len_ = value.len() as u32;
        let len_ = len_;
        self.clear_values = value.as_ptr();
        self.clear_value_count = len_;
        self
    }
}
///[VkClearDepthStencilValue](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkClearDepthStencilValue.html) - Structure specifying a clear depth stencil value
///# C Specifications
///The [`ClearDepthStencilValue`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkClearDepthStencilValue {
///    float       depth;
///    uint32_t    stencil;
///} VkClearDepthStencilValue;
///```
///# Members
/// - [`depth`] is the clear value for the depth aspect of the depth/stencil attachment. It is a
///   floating-point value which is automatically converted to the attachment’s format.
/// - [`stencil`] is the clear value for the stencil aspect of the depth/stencil attachment. It is a
///   32-bit integer value which is converted to the attachment’s format by taking the appropriate
///   number of LSBs.
///# Description
///## Valid Usage
/// - Unless the `[`VK_EXT_depth_range_unrestricted`]` extension is enabled [`depth`] **must**  be
///   between `0.0` and `1.0`, inclusive
///# Related
/// - [`crate::vulkan1_0`]
/// - [`ClearValue`]
/// - [`CmdClearDepthStencilImage`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, PartialEq, PartialOrd)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct ClearDepthStencilValue {
    ///[`depth`] is the clear value for the depth aspect of the depth/stencil
    ///attachment.
    ///It is a floating-point value which is automatically converted to the
    ///attachment’s format.
    depth: f32,
    ///[`stencil`] is the clear value for the stencil aspect of the
    ///depth/stencil attachment.
    ///It is a 32-bit integer value which is converted to the attachment’s
    ///format by taking the appropriate number of LSBs.
    stencil: u32,
}
impl Default for ClearDepthStencilValue {
    fn default() -> Self {
        Self { depth: 0.0, stencil: 0 }
    }
}
impl ClearDepthStencilValue {
    ///Gets the value of [`Self::depth`]
    pub fn depth(&self) -> f32 {
        self.depth
    }
    ///Gets the value of [`Self::stencil`]
    pub fn stencil(&self) -> u32 {
        self.stencil
    }
    ///Gets a mutable reference to the value of [`Self::depth`]
    pub fn depth_mut(&mut self) -> &mut f32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::stencil`]
    pub fn stencil_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Sets the raw value of [`Self::depth`]
    pub fn set_depth(&mut self, value: f32) -> &mut Self {
        self.depth = value;
        self
    }
    ///Sets the raw value of [`Self::stencil`]
    pub fn set_stencil(&mut self, value: u32) -> &mut Self {
        self.stencil = value;
        self
    }
}
///[VkClearAttachment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkClearAttachment.html) - Structure specifying a clear attachment
///# C Specifications
///The [`ClearAttachment`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkClearAttachment {
///    VkImageAspectFlags    aspectMask;
///    uint32_t              colorAttachment;
///    VkClearValue          clearValue;
///} VkClearAttachment;
///```
///# Members
/// - [`aspect_mask`] is a mask selecting the color, depth and/or stencil aspects of the attachment
///   to be cleared.
/// - [`color_attachment`] is only meaningful if `VK_IMAGE_ASPECT_COLOR_BIT` is set in
///   [`aspect_mask`], in which case it is an index into the currently bound color attachments.
/// - [`clear_value`] is the color or depth/stencil value to clear the attachment to, as described in [Clear Values](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#clears-values) below.
///# Description
///## Valid Usage
/// - If [`aspect_mask`] includes `VK_IMAGE_ASPECT_COLOR_BIT`, it  **must**  not include
///   `VK_IMAGE_ASPECT_DEPTH_BIT` or `VK_IMAGE_ASPECT_STENCIL_BIT`
/// - [`aspect_mask`] **must**  not include `VK_IMAGE_ASPECT_METADATA_BIT`
/// - [`aspect_mask`] **must**  not include `VK_IMAGE_ASPECT_MEMORY_PLANE*_i_*BIT_EXT` for any index
///   *i*
/// - [`clear_value`] **must**  be a valid [`ClearValue`] union
///
///## Valid Usage (Implicit)
/// - [`aspect_mask`] **must**  be a valid combination of [`ImageAspectFlagBits`] values
/// - [`aspect_mask`] **must**  not be `0`
///# Related
/// - [`crate::vulkan1_0`]
/// - [`ClearValue`]
/// - [`ImageAspectFlags`]
/// - [`CmdClearAttachments`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, PartialEq, PartialOrd)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[repr(C)]
pub struct ClearAttachment {
    ///[`aspect_mask`] is a mask selecting the color, depth and/or stencil
    ///aspects of the attachment to be cleared.
    aspect_mask: ImageAspectFlags,
    ///[`color_attachment`] is only meaningful if
    ///`VK_IMAGE_ASPECT_COLOR_BIT` is set in [`aspect_mask`], in which
    ///case it is an index into the currently bound color attachments.
    color_attachment: u32,
    ///[`clear_value`] is the color or depth/stencil value to clear the
    ///attachment to, as described in [Clear Values](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#clears-values) below.
    clear_value: ClearValue,
}
impl Default for ClearAttachment {
    fn default() -> Self {
        Self {
            aspect_mask: Default::default(),
            color_attachment: 0,
            clear_value: Default::default(),
        }
    }
}
impl ClearAttachment {
    ///Gets the value of [`Self::aspect_mask`]
    pub fn aspect_mask(&self) -> ImageAspectFlags {
        self.aspect_mask
    }
    ///Gets the value of [`Self::color_attachment`]
    pub fn color_attachment(&self) -> u32 {
        self.color_attachment
    }
    ///Gets the value of [`Self::clear_value`]
    pub fn clear_value(&self) -> ClearValue {
        self.clear_value
    }
    ///Gets a mutable reference to the value of [`Self::aspect_mask`]
    pub fn aspect_mask_mut(&mut self) -> &mut ImageAspectFlags {
        &mut self.aspect_mask
    }
    ///Gets a mutable reference to the value of [`Self::color_attachment`]
    pub fn color_attachment_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::clear_value`]
    pub fn clear_value_mut(&mut self) -> &mut ClearValue {
        &mut self.clear_value
    }
    ///Sets the raw value of [`Self::aspect_mask`]
    pub fn set_aspect_mask(&mut self, value: crate::vulkan1_0::ImageAspectFlags) -> &mut Self {
        self.aspect_mask = value;
        self
    }
    ///Sets the raw value of [`Self::color_attachment`]
    pub fn set_color_attachment(&mut self, value: u32) -> &mut Self {
        self.color_attachment = value;
        self
    }
    ///Sets the raw value of [`Self::clear_value`]
    pub fn set_clear_value(&mut self, value: crate::vulkan1_0::ClearValue) -> &mut Self {
        self.clear_value = value;
        self
    }
}
///[VkAttachmentDescription](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAttachmentDescription.html) - Structure specifying an attachment description
///# C Specifications
///The [`AttachmentDescription`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkAttachmentDescription {
///    VkAttachmentDescriptionFlags    flags;
///    VkFormat                        format;
///    VkSampleCountFlagBits           samples;
///    VkAttachmentLoadOp              loadOp;
///    VkAttachmentStoreOp             storeOp;
///    VkAttachmentLoadOp              stencilLoadOp;
///    VkAttachmentStoreOp             stencilStoreOp;
///    VkImageLayout                   initialLayout;
///    VkImageLayout                   finalLayout;
///} VkAttachmentDescription;
///```
///# Members
/// - [`flags`] is a bitmask of [`AttachmentDescriptionFlagBits`] specifying additional properties
///   of the attachment.
/// - [`format`] is a [`Format`] value specifying the format of the image view that will be used for
///   the attachment.
/// - [`samples`] is a [`SampleCountFlagBits`] value specifying the number of samples of the image.
/// - [`load_op`] is a [`AttachmentLoadOp`] value specifying how the contents of color and depth
///   components of the attachment are treated at the beginning of the subpass where it is first
///   used.
/// - [`store_op`] is a [`AttachmentStoreOp`] value specifying how the contents of color and depth
///   components of the attachment are treated at the end of the subpass where it is last used.
/// - [`stencil_load_op`] is a [`AttachmentLoadOp`] value specifying how the contents of stencil
///   components of the attachment are treated at the beginning of the subpass where it is first
///   used.
/// - [`stencil_store_op`] is a [`AttachmentStoreOp`] value specifying how the contents of stencil
///   components of the attachment are treated at the end of the last subpass where it is used.
/// - [`initial_layout`] is the layout the attachment image subresource will be in when a render
///   pass instance begins.
/// - [`final_layout`] is the layout the attachment image subresource will be transitioned to when a
///   render pass instance ends.
///# Description
///If the attachment uses a color format, then [`load_op`] and [`store_op`]
///are used, and [`stencil_load_op`] and [`stencil_store_op`] are ignored.
///If the format has depth and/or stencil components, [`load_op`] and
///[`store_op`] apply only to the depth data, while [`stencil_load_op`] and
///[`stencil_store_op`] define how the stencil data is handled.
///[`load_op`] and [`stencil_load_op`] define the *load operations* that
///execute as part of the first subpass that uses the attachment.
///[`store_op`] and [`stencil_store_op`] define the *store operations* that
///execute as part of the last subpass that uses the attachment.The load operation for each sample
/// in an attachment happens-before any
///recorded command which accesses the sample in the first subpass where the
///attachment is used.
///Load operations for attachments with a depth/stencil format execute in the
///`VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT` pipeline stage.
///Load operations for attachments with a color format execute in the
///`VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT` pipeline stage.The store operation for each
/// sample in an attachment happens-after any
///recorded command which accesses the sample in the last subpass where the
///attachment is used.
///Store operations for attachments with a depth/stencil format execute in the
///`VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT` pipeline stage.
///Store operations for attachments with a color format execute in the
///`VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT` pipeline stage.If an attachment is not used by
/// any subpass, then [`load_op`],
///[`store_op`], [`stencil_store_op`], and [`stencil_load_op`] are ignored,
///and the attachment’s memory contents will not be modified by execution of a
///render pass instance.The load and store operations apply on the first and last use of each view
///in the render pass, respectively.
///If a view index of an attachment is not included in the view mask in any
///subpass that uses it, then the load and store operations are ignored, and
///the attachment’s memory contents will not be modified by execution of a
///render pass instance.During a render pass instance, input/color attachments with color formats
///that have a component size of 8, 16, or 32 bits  **must**  be represented in the
///attachment’s format throughout the instance.
///Attachments with other floating- or fixed-point color formats, or with depth
///components  **may**  be represented in a format with a precision higher than the
///attachment format, but  **must**  be represented with the same range.
///When such a component is loaded via the [`load_op`], it will be converted
///into an implementation-dependent format used by the render pass.
///Such components  **must**  be converted from the render pass format, to the
///format of the attachment, before they are resolved or stored at the end of a
///render pass instance via [`store_op`].
///Conversions occur as described in [Numeric
///Representation and Computation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fundamentals-numerics) and [Fixed-Point
///Data Conversions](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fundamentals-fixedconv).If [`flags`] includes `VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT`, then
///the attachment is treated as if it shares physical memory with another
///attachment in the same render pass.
///This information limits the ability of the implementation to reorder certain
///operations (like layout transitions and the [`load_op`]) such that it is
///not improperly reordered against other uses of the same physical memory via
///a different attachment.
///This is described in more detail below.If a render pass uses multiple attachments that alias the
/// same device
///memory, those attachments  **must**  each include the
///`VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT` bit in their attachment
///description flags.
///Attachments aliasing the same memory occurs in multiple ways:
/// - Multiple attachments being assigned the same image view as part of framebuffer creation.
/// - Attachments using distinct image views that correspond to the same image subresource of an
///   image.
/// - Attachments using views of distinct image subresources which are bound to overlapping memory
///   ranges.
///Multiple attachments that alias the same memory  **must**  not be used in a
///single subpass.
///A given attachment index  **must**  not be used multiple times in a single
///subpass, with one exception: two subpass attachments  **can**  use the same
///attachment index if at least one use is as an input attachment and neither
///use is as a resolve or preserve attachment.
///In other words, the same view  **can**  be used simultaneously as an input and
///color or depth/stencil attachment, but  **must**  not be used as multiple color
///or depth/stencil attachments nor as resolve or preserve attachments.
///The precise set of valid scenarios is described in more detail
///[below](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-feedbackloop).If a set of attachments alias each other, then all except the first to be
///used in the render pass  **must**  use an [`initial_layout`] of
///`VK_IMAGE_LAYOUT_UNDEFINED`, since the earlier uses of the other aliases
///make their contents undefined.
///Once an alias has been used and a different alias has been used after it,
///the first alias  **must**  not be used in any later subpasses.
///However, an application  **can**  assign the same image view to multiple aliasing
///attachment indices, which allows that image view to be used multiple times
///even if other aliases are used in between.
///## Valid Usage
/// - [`final_layout`] **must**  not be `VK_IMAGE_LAYOUT_UNDEFINED` or
///   `VK_IMAGE_LAYOUT_PREINITIALIZED`
/// - If [`format`] is a color format, [`initial_layout`] **must**  not be
///   `VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL` or
///   `VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL`
/// - If [`format`] is a color format, [`initial_layout`] **must**  not be
///   `VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL` or
///   `VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL`
/// - If [`format`] is a depth/stencil format, [`initial_layout`] **must**  not be
///   `VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL`
/// - If [`format`] is a color format, [`final_layout`] **must**  not be
///   `VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL` or
///   `VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL`
/// - If [`format`] is a color format, [`final_layout`] **must**  not be
///   `VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL` or
///   `VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL`
/// - If [`format`] is a depth/stencil format, [`final_layout`] **must**  not be
///   `VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL`
/// - If the [`separateDepthStencilLayouts`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-separateDepthStencilLayouts)
///   feature is not enabled, [`initial_layout`] **must**  not be
///   `VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL`, `VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL`,
///   `VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL`, or `VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL`
/// - If the [`separateDepthStencilLayouts`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-separateDepthStencilLayouts)
///   feature is not enabled, [`final_layout`] **must**  not be
///   `VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL`, `VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL`,
///   `VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL`, or `VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL`
/// - If [`format`] is a color format, [`initial_layout`] **must**  not be
///   `VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL`, `VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL`,
///   `VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL`, or `VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL`
/// - If [`format`] is a color format, [`final_layout`] **must**  not be
///   `VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL`, `VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL`,
///   `VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL`, or `VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL`
/// - If [`format`] is a depth/stencil format which includes both depth and stencil aspects,
///   [`initial_layout`] **must**  not be `VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL`,
///   `VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL`, `VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL`, or
///   `VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL`
/// - If [`format`] is a depth/stencil format which includes both depth and stencil aspects,
///   [`final_layout`] **must**  not be `VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL`,
///   `VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL`, `VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL`, or
///   `VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL`
/// - If [`format`] is a depth/stencil format which includes only the depth aspect,
///   [`initial_layout`] **must**  not be `VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL` or
///   `VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL`
/// - If [`format`] is a depth/stencil format which includes only the depth aspect, [`final_layout`]
///   **must**  not be `VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL` or
///   `VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL`
/// - If [`format`] is a depth/stencil format which includes only the stencil aspect,
///   [`initial_layout`] **must**  not be `VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL` or
///   `VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL`
/// - If [`format`] is a depth/stencil format which includes only the stencil aspect,
///   [`final_layout`] **must**  not be `VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL` or
///   `VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL`
///
///## Valid Usage (Implicit)
/// - [`flags`] **must**  be a valid combination of [`AttachmentDescriptionFlagBits`] values
/// - [`format`] **must**  be a valid [`Format`] value
/// - [`samples`] **must**  be a valid [`SampleCountFlagBits`] value
/// - [`load_op`] **must**  be a valid [`AttachmentLoadOp`] value
/// - [`store_op`] **must**  be a valid [`AttachmentStoreOp`] value
/// - [`stencil_load_op`] **must**  be a valid [`AttachmentLoadOp`] value
/// - [`stencil_store_op`] **must**  be a valid [`AttachmentStoreOp`] value
/// - [`initial_layout`] **must**  be a valid [`ImageLayout`] value
/// - [`final_layout`] **must**  be a valid [`ImageLayout`] value
///# Related
/// - [`crate::vulkan1_0`]
/// - [`AttachmentDescriptionFlags`]
/// - [`AttachmentLoadOp`]
/// - [`AttachmentStoreOp`]
/// - [`Format`]
/// - [`ImageLayout`]
/// - [`RenderPassCreateInfo`]
/// - [`SampleCountFlagBits`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct AttachmentDescription {
    ///[`flags`] is a bitmask of [`AttachmentDescriptionFlagBits`]
    ///specifying additional properties of the attachment.
    flags: AttachmentDescriptionFlags,
    ///[`format`] is a [`Format`] value specifying the format of the
    ///image view that will be used for the attachment.
    format: Format,
    ///[`samples`] is a [`SampleCountFlagBits`] value specifying the
    ///number of samples of the image.
    samples: SampleCountFlagBits,
    ///[`load_op`] is a [`AttachmentLoadOp`] value specifying how the
    ///contents of color and depth components of the attachment are treated at
    ///the beginning of the subpass where it is first used.
    load_op: AttachmentLoadOp,
    ///[`store_op`] is a [`AttachmentStoreOp`] value specifying how the
    ///contents of color and depth components of the attachment are treated at
    ///the end of the subpass where it is last used.
    store_op: AttachmentStoreOp,
    ///[`stencil_load_op`] is a [`AttachmentLoadOp`] value specifying how
    ///the contents of stencil components of the attachment are treated at the
    ///beginning of the subpass where it is first used.
    stencil_load_op: AttachmentLoadOp,
    ///[`stencil_store_op`] is a [`AttachmentStoreOp`] value specifying how
    ///the contents of stencil components of the attachment are treated at the
    ///end of the last subpass where it is used.
    stencil_store_op: AttachmentStoreOp,
    ///[`initial_layout`] is the layout the attachment image subresource will
    ///be in when a render pass instance begins.
    initial_layout: ImageLayout,
    ///[`final_layout`] is the layout the attachment image subresource will be
    ///transitioned to when a render pass instance ends.
    final_layout: ImageLayout,
}
impl Default for AttachmentDescription {
    fn default() -> Self {
        Self {
            flags: Default::default(),
            format: Default::default(),
            samples: Default::default(),
            load_op: Default::default(),
            store_op: Default::default(),
            stencil_load_op: Default::default(),
            stencil_store_op: Default::default(),
            initial_layout: Default::default(),
            final_layout: Default::default(),
        }
    }
}
impl AttachmentDescription {
    ///Gets the value of [`Self::flags`]
    pub fn flags(&self) -> AttachmentDescriptionFlags {
        self.flags
    }
    ///Gets the value of [`Self::format`]
    pub fn format(&self) -> Format {
        self.format
    }
    ///Gets the value of [`Self::samples`]
    pub fn samples(&self) -> SampleCountFlagBits {
        self.samples
    }
    ///Gets the value of [`Self::load_op`]
    pub fn load_op(&self) -> AttachmentLoadOp {
        self.load_op
    }
    ///Gets the value of [`Self::store_op`]
    pub fn store_op(&self) -> AttachmentStoreOp {
        self.store_op
    }
    ///Gets the value of [`Self::stencil_load_op`]
    pub fn stencil_load_op(&self) -> AttachmentLoadOp {
        self.stencil_load_op
    }
    ///Gets the value of [`Self::stencil_store_op`]
    pub fn stencil_store_op(&self) -> AttachmentStoreOp {
        self.stencil_store_op
    }
    ///Gets the value of [`Self::initial_layout`]
    pub fn initial_layout(&self) -> ImageLayout {
        self.initial_layout
    }
    ///Gets the value of [`Self::final_layout`]
    pub fn final_layout(&self) -> ImageLayout {
        self.final_layout
    }
    ///Gets a mutable reference to the value of [`Self::flags`]
    pub fn flags_mut(&mut self) -> &mut AttachmentDescriptionFlags {
        &mut self.flags
    }
    ///Gets a mutable reference to the value of [`Self::format`]
    pub fn format_mut(&mut self) -> &mut Format {
        &mut self.format
    }
    ///Gets a mutable reference to the value of [`Self::samples`]
    pub fn samples_mut(&mut self) -> &mut SampleCountFlagBits {
        &mut self.samples
    }
    ///Gets a mutable reference to the value of [`Self::load_op`]
    pub fn load_op_mut(&mut self) -> &mut AttachmentLoadOp {
        &mut self.load_op
    }
    ///Gets a mutable reference to the value of [`Self::store_op`]
    pub fn store_op_mut(&mut self) -> &mut AttachmentStoreOp {
        &mut self.store_op
    }
    ///Gets a mutable reference to the value of [`Self::stencil_load_op`]
    pub fn stencil_load_op_mut(&mut self) -> &mut AttachmentLoadOp {
        &mut self.stencil_load_op
    }
    ///Gets a mutable reference to the value of [`Self::stencil_store_op`]
    pub fn stencil_store_op_mut(&mut self) -> &mut AttachmentStoreOp {
        &mut self.stencil_store_op
    }
    ///Gets a mutable reference to the value of [`Self::initial_layout`]
    pub fn initial_layout_mut(&mut self) -> &mut ImageLayout {
        &mut self.initial_layout
    }
    ///Gets a mutable reference to the value of [`Self::final_layout`]
    pub fn final_layout_mut(&mut self) -> &mut ImageLayout {
        &mut self.final_layout
    }
    ///Sets the raw value of [`Self::flags`]
    pub fn set_flags(&mut self, value: crate::vulkan1_0::AttachmentDescriptionFlags) -> &mut Self {
        self.flags = value;
        self
    }
    ///Sets the raw value of [`Self::format`]
    pub fn set_format(&mut self, value: crate::vulkan1_0::Format) -> &mut Self {
        self.format = value;
        self
    }
    ///Sets the raw value of [`Self::samples`]
    pub fn set_samples(&mut self, value: crate::vulkan1_0::SampleCountFlagBits) -> &mut Self {
        self.samples = value;
        self
    }
    ///Sets the raw value of [`Self::load_op`]
    pub fn set_load_op(&mut self, value: crate::vulkan1_0::AttachmentLoadOp) -> &mut Self {
        self.load_op = value;
        self
    }
    ///Sets the raw value of [`Self::store_op`]
    pub fn set_store_op(&mut self, value: crate::vulkan1_0::AttachmentStoreOp) -> &mut Self {
        self.store_op = value;
        self
    }
    ///Sets the raw value of [`Self::stencil_load_op`]
    pub fn set_stencil_load_op(&mut self, value: crate::vulkan1_0::AttachmentLoadOp) -> &mut Self {
        self.stencil_load_op = value;
        self
    }
    ///Sets the raw value of [`Self::stencil_store_op`]
    pub fn set_stencil_store_op(&mut self, value: crate::vulkan1_0::AttachmentStoreOp) -> &mut Self {
        self.stencil_store_op = value;
        self
    }
    ///Sets the raw value of [`Self::initial_layout`]
    pub fn set_initial_layout(&mut self, value: crate::vulkan1_0::ImageLayout) -> &mut Self {
        self.initial_layout = value;
        self
    }
    ///Sets the raw value of [`Self::final_layout`]
    pub fn set_final_layout(&mut self, value: crate::vulkan1_0::ImageLayout) -> &mut Self {
        self.final_layout = value;
        self
    }
}
///[VkAttachmentReference](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAttachmentReference.html) - Structure specifying an attachment reference
///# C Specifications
///The [`AttachmentReference`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkAttachmentReference {
///    uint32_t         attachment;
///    VkImageLayout    layout;
///} VkAttachmentReference;
///```
///# Members
/// - [`attachment`] is either an integer value identifying an attachment at the corresponding index
///   in [`RenderPassCreateInfo::attachments`], or [`ATTACHMENT_UNUSED`] to signify that this
///   attachment is not used.
/// - [`layout`] is a [`ImageLayout`] value specifying the layout the attachment uses during the
///   subpass.
///# Description
///## Valid Usage
/// - If [`attachment`] is not [`ATTACHMENT_UNUSED`], [`layout`] **must**  not be
///   `VK_IMAGE_LAYOUT_UNDEFINED`, `VK_IMAGE_LAYOUT_PREINITIALIZED`,
///   `VK_IMAGE_LAYOUT_PRESENT_SRC_KHR`, `VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL`,
///   `VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL`, `VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL`, or
///   `VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL`
///
///## Valid Usage (Implicit)
/// - [`layout`] **must**  be a valid [`ImageLayout`] value
///# Related
/// - [`crate::vulkan1_0`]
/// - [`ImageLayout`]
/// - [`RenderPassFragmentDensityMapCreateInfoEXT`]
/// - [`SubpassDescription`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct AttachmentReference {
    ///[`attachment`] is either an integer value identifying an attachment at
    ///the corresponding index in
    ///[`RenderPassCreateInfo`]::`pAttachments`, or
    ///[`ATTACHMENT_UNUSED`] to signify that this attachment is not used.
    attachment: u32,
    ///[`layout`] is a [`ImageLayout`] value specifying the layout the
    ///attachment uses during the subpass.
    layout: ImageLayout,
}
impl Default for AttachmentReference {
    fn default() -> Self {
        Self {
            attachment: 0,
            layout: Default::default(),
        }
    }
}
impl AttachmentReference {
    ///Gets the value of [`Self::attachment`]
    pub fn attachment(&self) -> u32 {
        self.attachment
    }
    ///Gets the value of [`Self::layout`]
    pub fn layout(&self) -> ImageLayout {
        self.layout
    }
    ///Gets a mutable reference to the value of [`Self::attachment`]
    pub fn attachment_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::layout`]
    pub fn layout_mut(&mut self) -> &mut ImageLayout {
        &mut self.layout
    }
    ///Sets the raw value of [`Self::attachment`]
    pub fn set_attachment(&mut self, value: u32) -> &mut Self {
        self.attachment = value;
        self
    }
    ///Sets the raw value of [`Self::layout`]
    pub fn set_layout(&mut self, value: crate::vulkan1_0::ImageLayout) -> &mut Self {
        self.layout = value;
        self
    }
}
///[VkSubpassDescription](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSubpassDescription.html) - Structure specifying a subpass description
///# C Specifications
///The [`SubpassDescription`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkSubpassDescription {
///    VkSubpassDescriptionFlags       flags;
///    VkPipelineBindPoint             pipelineBindPoint;
///    uint32_t                        inputAttachmentCount;
///    const VkAttachmentReference*    pInputAttachments;
///    uint32_t                        colorAttachmentCount;
///    const VkAttachmentReference*    pColorAttachments;
///    const VkAttachmentReference*    pResolveAttachments;
///    const VkAttachmentReference*    pDepthStencilAttachment;
///    uint32_t                        preserveAttachmentCount;
///    const uint32_t*                 pPreserveAttachments;
///} VkSubpassDescription;
///```
///# Members
/// - [`flags`] is a bitmask of [`SubpassDescriptionFlagBits`] specifying usage of the subpass.
/// - [`pipeline_bind_point`] is a [`PipelineBindPoint`] value specifying the pipeline type
///   supported for this subpass.
/// - [`input_attachment_count`] is the number of input attachments.
/// - [`input_attachments`] is a pointer to an array of [`AttachmentReference`] structures defining
///   the input attachments for this subpass and their layouts.
/// - [`color_attachment_count`] is the number of color attachments.
/// - [`color_attachments`] is a pointer to an array of
///   [`color_attachment_count`][`AttachmentReference`] structures defining the color attachments
///   for this subpass and their layouts.
/// - [`resolve_attachments`] is `NULL` or a pointer to an array of
///   [`color_attachment_count`][`AttachmentReference`] structures defining the resolve attachments
///   for this subpass and their layouts.
/// - [`depth_stencil_attachment`] is a pointer to a [`AttachmentReference`] structure specifying
///   the depth/stencil attachment for this subpass and its layout.
/// - [`preserve_attachment_count`] is the number of preserved attachments.
/// - [`preserve_attachments`] is a pointer to an array of [`preserve_attachment_count`] render pass
///   attachment indices identifying attachments that are not used by this subpass, but whose
///   contents  **must**  be preserved throughout the subpass.
///# Description
///Each element of the [`input_attachments`] array corresponds to an input
///attachment index in a fragment shader, i.e. if a shader declares an image
///variable decorated with a `InputAttachmentIndex` value of  **X** , then it
///uses the attachment provided in [`input_attachments`][ **X** ].
///Input attachments  **must**  also be bound to the pipeline in a descriptor set.
///If the `attachment` member of any element of [`input_attachments`] is
///[`ATTACHMENT_UNUSED`], the application  **must**  not read from the
///corresponding input attachment index.
///Fragment shaders  **can**  use subpass input variables to access the contents of
///an input attachment at the fragment’s (x, y, layer) framebuffer coordinates.
///Input attachments  **must**  not be used by any subpasses within a render pass
///that enables [render pass transform](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#vertexpostproc-renderpass-transform).Each element of the [`color_attachments`] array corresponds to an output
///location in the shader, i.e. if the shader declares an output variable
///decorated with a `Location` value of  **X** , then it uses the attachment
///provided in [`color_attachments`][ **X** ].
///If the `attachment` member of any element of [`color_attachments`] is
///[`ATTACHMENT_UNUSED`],
///or if [Color Write Enable](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#framebuffer-color-write-enable) has been
///disabled for the corresponding attachment index,
///then writes to the corresponding location by a fragment shader are
///discarded.If
///[`flags`] does not include
///`VK_SUBPASS_DESCRIPTION_SHADER_RESOLVE_BIT_QCOM`, and if
///[`resolve_attachments`] is not `NULL`, each of its elements corresponds to
///a color attachment (the element in [`color_attachments`] at the same
///index), and a multisample resolve operation is defined for each attachment.
///At the end of each subpass, multisample resolve operations read the
///subpass’s color attachments, and resolve the samples for each pixel within
///the render area to the same pixel location in the corresponding resolve
///attachments, unless the resolve attachment index is
///[`ATTACHMENT_UNUSED`].Similarly, if
///[`flags`] does not include
///`VK_SUBPASS_DESCRIPTION_SHADER_RESOLVE_BIT_QCOM`, and
///[`SubpassDescriptionDepthStencilResolve::depth_stencil_resolve_attachment`]
///is not `NULL` and does not have the value [`ATTACHMENT_UNUSED`], it
///corresponds to the depth/stencil attachment in
///[`depth_stencil_attachment`], and multisample resolve operations for depth
///and stencil are defined by
///[`SubpassDescriptionDepthStencilResolve::depth_resolve_mode`] and
///[`SubpassDescriptionDepthStencilResolve::stencil_resolve_mode`],
///respectively.
///At the end of each subpass, multisample resolve operations read the
///subpass’s depth/stencil attachment, and resolve the samples for each pixel
///to the same pixel location in the corresponding resolve attachment.
///If [`SubpassDescriptionDepthStencilResolve::depth_resolve_mode`] is
///`VK_RESOLVE_MODE_NONE`, then the depth component of the resolve
///attachment is not written to and its contents are preserved.
///Similarly, if
///[`SubpassDescriptionDepthStencilResolve::stencil_resolve_mode`] is
///`VK_RESOLVE_MODE_NONE`, then the stencil component of the resolve
///attachment is not written to and its contents are preserved.
///[`SubpassDescriptionDepthStencilResolve::depth_resolve_mode`] is
///ignored if the [`Format`] of the `pDepthStencilResolveAttachment`
///does not have a depth component.
///Similarly,
///[`SubpassDescriptionDepthStencilResolve::stencil_resolve_mode`] is
///ignored if the [`Format`] of the `pDepthStencilResolveAttachment`
///does not have a stencil component.If the image subresource range referenced by the depth/stencil
/// attachment is
///created with
///`VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT`, then the
///multisample resolve operation uses the sample locations state specified in
///the `sampleLocationsInfo` member of the element of the
///[`RenderPassSampleLocationsBeginInfoEXT::post_subpass_sample_locations`]
///for the subpass.If [`depth_stencil_attachment`] is `NULL`, or if its attachment index is
///[`ATTACHMENT_UNUSED`], it indicates that no depth/stencil attachment
///will be used in the subpass.The contents of an attachment within the render area become
/// undefined at
///the start of a subpass  **S**  if all of the following conditions are true:
/// - The attachment is used as a color, depth/stencil, or resolve attachment in any subpass in the
///   render pass.
/// - There is a subpass  **S<sub>1</sub>**  that uses or preserves the attachment, and a subpass
///   dependency from  **S<sub>1</sub>**  to  **S** .
/// - The attachment is not used or preserved in subpass  **S** .
///In addition, the contents of an attachment within the render area become
///undefined at the start of a subpass  **S**  if all of the following conditions
///are true:
/// - `VK_SUBPASS_DESCRIPTION_SHADER_RESOLVE_BIT_QCOM` is set.
/// - The attachment is used as a color or depth/stencil in the subpass.
///Once the contents of an attachment become undefined in subpass  **S** , they
///remain undefined for subpasses in subpass dependency chains starting with
///subpass  **S**  until they are written again.
///However, they remain valid for subpasses in other subpass dependency chains
///starting with subpass  **S<sub>1</sub>**  if those subpasses use or preserve the
///attachment.
///## Valid Usage
/// - [`pipeline_bind_point`] **must**  be `VK_PIPELINE_BIND_POINT_GRAPHICS` or
///   `VK_PIPELINE_BIND_POINT_SUBPASS_SHADING_HUAWEI`
/// - [`color_attachment_count`] **must**  be less than or equal to
///   [`PhysicalDeviceLimits::max_color_attachments`]
/// - If the first use of an attachment in this render pass is as an input attachment, and the
///   attachment is not also used as a color or depth/stencil attachment in the same subpass, then
///   `loadOp` **must**  not be `VK_ATTACHMENT_LOAD_OP_CLEAR`
/// - If [`resolve_attachments`] is not `NULL`, for each resolve attachment that is not
///   [`ATTACHMENT_UNUSED`], the corresponding color attachment  **must**  not be
///   [`ATTACHMENT_UNUSED`]
/// - If [`resolve_attachments`] is not `NULL`, for each resolve attachment that is not
///   [`ATTACHMENT_UNUSED`], the corresponding color attachment  **must**  not have a sample count
///   of `VK_SAMPLE_COUNT_1_BIT`
/// - If [`resolve_attachments`] is not `NULL`, each resolve attachment that is not
///   [`ATTACHMENT_UNUSED`] **must**  have a sample count of `VK_SAMPLE_COUNT_1_BIT`
/// - If [`resolve_attachments`] is not `NULL`, each resolve attachment that is not
///   [`ATTACHMENT_UNUSED`] **must**  have the same [`Format`] as its corresponding color attachment
/// - All attachments in [`color_attachments`] that are not [`ATTACHMENT_UNUSED`] **must**  have the
///   same sample count
/// -    All attachments in [`input_attachments`] that are not [`ATTACHMENT_UNUSED`] **must**  have image formats whose [potential format features](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#potential-format-features) contain at least `VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT` or `VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT`
/// -    All attachments in [`color_attachments`] that are not [`ATTACHMENT_UNUSED`] **must**  have image formats whose [potential format features](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#potential-format-features) contain `VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT`
/// -    All attachments in [`resolve_attachments`] that are not [`ATTACHMENT_UNUSED`] **must**  have image formats whose [potential format features](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#potential-format-features) contain `VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT`
/// -    If [`depth_stencil_attachment`] is not `NULL` and the attachment is not [`ATTACHMENT_UNUSED`] then it  **must**  have an image format whose [potential format features](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#potential-format-features) contain `VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT`
/// -    If the [`linearColorAttachment`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-linearColorAttachment) feature is enabled and the image is created with `VK_IMAGE_TILING_LINEAR`, all attachments in [`input_attachments`] that are not [`ATTACHMENT_UNUSED`] **must**  have image formats whose [potential format features](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#potential-format-features) **must**  contain `VK_FORMAT_FEATURE_2_LINEAR_COLOR_ATTACHMENT_BIT_NV`
/// -    If the [`linearColorAttachment`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-linearColorAttachment) feature is enabled and the image is created with `VK_IMAGE_TILING_LINEAR`, all attachments in [`color_attachments`] that are not [`ATTACHMENT_UNUSED`] **must**  have image formats whose [potential format features](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#potential-format-features) **must**  contain `VK_FORMAT_FEATURE_2_LINEAR_COLOR_ATTACHMENT_BIT_NV`
/// -    If the [`linearColorAttachment`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-linearColorAttachment) feature is enabled and the image is created with `VK_IMAGE_TILING_LINEAR`, all attachments in [`resolve_attachments`] that are not [`ATTACHMENT_UNUSED`] **must**  have image formats whose [potential format features](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#potential-format-features) **must**  contain `VK_FORMAT_FEATURE_2_LINEAR_COLOR_ATTACHMENT_BIT_NV`
/// - If the `[`VK_AMD_mixed_attachment_samples`]` extension is enabled, and all attachments in
///   [`color_attachments`] that are not [`ATTACHMENT_UNUSED`] **must**  have a sample count that is
///   smaller than or equal to the sample count of [`depth_stencil_attachment`] if it is not
///   [`ATTACHMENT_UNUSED`]
/// - If neither the `[`VK_AMD_mixed_attachment_samples`]` nor the
///   `[`VK_NV_framebuffer_mixed_samples`]` extensions are enabled, and if
///   [`depth_stencil_attachment`] is not [`ATTACHMENT_UNUSED`] and any attachments in
///   [`color_attachments`] are not [`ATTACHMENT_UNUSED`], they  **must**  have the same sample
///   count
/// - Each element of [`preserve_attachments`] **must**  not be [`ATTACHMENT_UNUSED`]
/// - Each element of [`preserve_attachments`] **must**  not also be an element of any other member
///   of the subpass description
/// - If any attachment is used by more than one [`AttachmentReference`] member, then each use
///   **must**  use the same `layout`
/// - Each attachment  **must**  follow the [image layout requirements](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#attachment-type-imagelayout)
///   specified for its attachment type
/// - If [`flags`] includes `VK_SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX`, it  **must**
///   also include `VK_SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX`
/// - If [`flags`] includes `VK_SUBPASS_DESCRIPTION_SHADER_RESOLVE_BIT_QCOM`, and if
///   [`resolve_attachments`] is not `NULL`, then each resolve attachment  **must**  be
///   [`ATTACHMENT_UNUSED`]
/// - If [`flags`] includes `VK_SUBPASS_DESCRIPTION_SHADER_RESOLVE_BIT_QCOM`, then the subpass
///   **must**  be the last subpass in a subpass dependency chain
/// - If the render pass is created with `VK_RENDER_PASS_CREATE_TRANSFORM_BIT_QCOM` each of the
///   elements of [`input_attachments`] **must**  be [`ATTACHMENT_UNUSED`]
/// - [`depth_stencil_attachment`] and [`color_attachments`] must not contain references to the same
///   attachment
///
///## Valid Usage (Implicit)
/// - [`flags`] **must**  be a valid combination of [`SubpassDescriptionFlagBits`] values
/// - [`pipeline_bind_point`] **must**  be a valid [`PipelineBindPoint`] value
/// - If [`input_attachment_count`] is not `0`, [`input_attachments`] **must**  be a valid pointer
///   to an array of [`input_attachment_count`] valid [`AttachmentReference`] structures
/// - If [`color_attachment_count`] is not `0`, [`color_attachments`] **must**  be a valid pointer
///   to an array of [`color_attachment_count`] valid [`AttachmentReference`] structures
/// - If [`color_attachment_count`] is not `0`, and [`resolve_attachments`] is not `NULL`,
///   [`resolve_attachments`] **must**  be a valid pointer to an array of [`color_attachment_count`]
///   valid [`AttachmentReference`] structures
/// - If [`depth_stencil_attachment`] is not `NULL`, [`depth_stencil_attachment`] **must**  be a
///   valid pointer to a valid [`AttachmentReference`] structure
/// - If [`preserve_attachment_count`] is not `0`, [`preserve_attachments`] **must**  be a valid
///   pointer to an array of [`preserve_attachment_count`]`uint32_t` values
///# Related
/// - [`crate::vulkan1_0`]
/// - [`AttachmentReference`]
/// - [`PipelineBindPoint`]
/// - [`RenderPassCreateInfo`]
/// - [`SubpassDescriptionFlags`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[repr(C)]
pub struct SubpassDescription<'lt> {
    _lifetime: PhantomData<&'lt ()>,
    ///[`flags`] is a bitmask of [`SubpassDescriptionFlagBits`]
    ///specifying usage of the subpass.
    flags: SubpassDescriptionFlags,
    ///[`pipeline_bind_point`] is a [`PipelineBindPoint`] value specifying
    ///the pipeline type supported for this subpass.
    pipeline_bind_point: PipelineBindPoint,
    ///[`input_attachment_count`] is the number of input attachments.
    input_attachment_count: u32,
    ///[`input_attachments`] is a pointer to an array of
    ///[`AttachmentReference`] structures defining the input attachments
    ///for this subpass and their layouts.
    input_attachments: *const AttachmentReference,
    ///[`color_attachment_count`] is the number of color attachments.
    color_attachment_count: u32,
    ///[`color_attachments`] is a pointer to an array of
    ///[`color_attachment_count`][`AttachmentReference`] structures
    ///defining the color attachments for this subpass and their layouts.
    color_attachments: *const AttachmentReference,
    ///[`resolve_attachments`] is `NULL` or a pointer to an array of
    ///[`color_attachment_count`][`AttachmentReference`] structures
    ///defining the resolve attachments for this subpass and their layouts.
    resolve_attachments: *const AttachmentReference,
    ///[`depth_stencil_attachment`] is a pointer to a
    ///[`AttachmentReference`] structure specifying the depth/stencil
    ///attachment for this subpass and its layout.
    depth_stencil_attachment: *const AttachmentReference,
    ///[`preserve_attachment_count`] is the number of preserved attachments.
    preserve_attachment_count: u32,
    ///[`preserve_attachments`] is a pointer to an array of
    ///[`preserve_attachment_count`] render pass attachment indices identifying
    ///attachments that are not used by this subpass, but whose contents  **must**
    ///be preserved throughout the subpass.
    preserve_attachments: *const u32,
}
impl<'lt> Default for SubpassDescription<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            flags: Default::default(),
            pipeline_bind_point: Default::default(),
            input_attachment_count: 0,
            input_attachments: std::ptr::null(),
            color_attachment_count: 0,
            color_attachments: std::ptr::null(),
            resolve_attachments: std::ptr::null(),
            depth_stencil_attachment: std::ptr::null(),
            preserve_attachment_count: 0,
            preserve_attachments: std::ptr::null(),
        }
    }
}
impl<'lt> SubpassDescription<'lt> {
    ///Gets the raw value of [`Self::input_attachments`]
    pub fn input_attachments_raw(&self) -> *const AttachmentReference {
        self.input_attachments
    }
    ///Gets the raw value of [`Self::color_attachments`]
    pub fn color_attachments_raw(&self) -> *const AttachmentReference {
        self.color_attachments
    }
    ///Gets the raw value of [`Self::resolve_attachments`]
    pub fn resolve_attachments_raw(&self) -> *const AttachmentReference {
        self.resolve_attachments
    }
    ///Gets the raw value of [`Self::depth_stencil_attachment`]
    pub fn depth_stencil_attachment_raw(&self) -> *const AttachmentReference {
        self.depth_stencil_attachment
    }
    ///Gets the raw value of [`Self::preserve_attachments`]
    pub fn preserve_attachments_raw(&self) -> *const u32 {
        self.preserve_attachments
    }
    ///Sets the raw value of [`Self::input_attachments`]
    pub fn set_input_attachments_raw(&mut self, value: *const AttachmentReference) -> &mut Self {
        self.input_attachments = value;
        self
    }
    ///Sets the raw value of [`Self::color_attachments`]
    pub fn set_color_attachments_raw(&mut self, value: *const AttachmentReference) -> &mut Self {
        self.color_attachments = value;
        self
    }
    ///Sets the raw value of [`Self::resolve_attachments`]
    pub fn set_resolve_attachments_raw(&mut self, value: *const AttachmentReference) -> &mut Self {
        self.resolve_attachments = value;
        self
    }
    ///Sets the raw value of [`Self::depth_stencil_attachment`]
    pub fn set_depth_stencil_attachment_raw(&mut self, value: *const AttachmentReference) -> &mut Self {
        self.depth_stencil_attachment = value;
        self
    }
    ///Sets the raw value of [`Self::preserve_attachments`]
    pub fn set_preserve_attachments_raw(&mut self, value: *const u32) -> &mut Self {
        self.preserve_attachments = value;
        self
    }
    ///Gets the value of [`Self::flags`]
    pub fn flags(&self) -> SubpassDescriptionFlags {
        self.flags
    }
    ///Gets the value of [`Self::pipeline_bind_point`]
    pub fn pipeline_bind_point(&self) -> PipelineBindPoint {
        self.pipeline_bind_point
    }
    ///Gets the value of [`Self::input_attachment_count`]
    pub fn input_attachment_count(&self) -> u32 {
        self.input_attachment_count
    }
    ///Gets the value of [`Self::input_attachments`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn input_attachments(&self) -> &[AttachmentReference] {
        std::slice::from_raw_parts(self.input_attachments, self.input_attachment_count as usize)
    }
    ///Gets the value of [`Self::color_attachment_count`]
    pub fn color_attachment_count(&self) -> u32 {
        self.color_attachment_count
    }
    ///Gets the value of [`Self::color_attachments`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn color_attachments(&self) -> &[AttachmentReference] {
        std::slice::from_raw_parts(self.color_attachments, self.color_attachment_count as usize)
    }
    ///Gets the value of [`Self::resolve_attachments`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn resolve_attachments(&self) -> &[AttachmentReference] {
        std::slice::from_raw_parts(self.resolve_attachments, self.color_attachment_count as usize)
    }
    ///Gets the value of [`Self::depth_stencil_attachment`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn depth_stencil_attachment(&self) -> &AttachmentReference {
        &*self.depth_stencil_attachment
    }
    ///Gets the value of [`Self::preserve_attachment_count`]
    pub fn preserve_attachment_count(&self) -> u32 {
        self.preserve_attachment_count
    }
    ///Gets the value of [`Self::preserve_attachments`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn preserve_attachments(&self) -> &[u32] {
        std::slice::from_raw_parts(self.preserve_attachments, self.preserve_attachment_count as usize)
    }
    ///Gets a mutable reference to the value of [`Self::flags`]
    pub fn flags_mut(&mut self) -> &mut SubpassDescriptionFlags {
        &mut self.flags
    }
    ///Gets a mutable reference to the value of [`Self::pipeline_bind_point`]
    pub fn pipeline_bind_point_mut(&mut self) -> &mut PipelineBindPoint {
        &mut self.pipeline_bind_point
    }
    ///Gets a mutable reference to the value of [`Self::input_attachment_count`]
    pub fn input_attachment_count_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::color_attachment_count`]
    pub fn color_attachment_count_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::preserve_attachment_count`]
    pub fn preserve_attachment_count_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Sets the raw value of [`Self::flags`]
    pub fn set_flags(&mut self, value: crate::vulkan1_0::SubpassDescriptionFlags) -> &mut Self {
        self.flags = value;
        self
    }
    ///Sets the raw value of [`Self::pipeline_bind_point`]
    pub fn set_pipeline_bind_point(&mut self, value: crate::vulkan1_0::PipelineBindPoint) -> &mut Self {
        self.pipeline_bind_point = value;
        self
    }
    ///Sets the raw value of [`Self::input_attachment_count`]
    pub fn set_input_attachment_count(&mut self, value: u32) -> &mut Self {
        self.input_attachment_count = value;
        self
    }
    ///Sets the raw value of [`Self::input_attachments`]
    pub fn set_input_attachments(&mut self, value: &'lt [crate::vulkan1_0::AttachmentReference]) -> &mut Self {
        let len_ = value.len() as u32;
        let len_ = len_;
        self.input_attachments = value.as_ptr();
        self.input_attachment_count = len_;
        self
    }
    ///Sets the raw value of [`Self::color_attachment_count`]
    pub fn set_color_attachment_count(&mut self, value: u32) -> &mut Self {
        self.color_attachment_count = value;
        self
    }
    ///Sets the raw value of [`Self::color_attachments`]
    pub fn set_color_attachments(&mut self, value: &'lt [crate::vulkan1_0::AttachmentReference]) -> &mut Self {
        let len_ = value.len() as u32;
        let len_ = len_;
        self.color_attachments = value.as_ptr();
        self.color_attachment_count = len_;
        self
    }
    ///Sets the raw value of [`Self::resolve_attachments`]
    pub fn set_resolve_attachments(&mut self, value: &'lt [crate::vulkan1_0::AttachmentReference]) -> &mut Self {
        let len_ = value.len() as u32;
        let len_ = len_;
        self.resolve_attachments = value.as_ptr();
        self.color_attachment_count = len_;
        self
    }
    ///Sets the raw value of [`Self::depth_stencil_attachment`]
    pub fn set_depth_stencil_attachment(&mut self, value: &'lt crate::vulkan1_0::AttachmentReference) -> &mut Self {
        self.depth_stencil_attachment = value as *const _;
        self
    }
    ///Sets the raw value of [`Self::preserve_attachment_count`]
    pub fn set_preserve_attachment_count(&mut self, value: u32) -> &mut Self {
        self.preserve_attachment_count = value;
        self
    }
    ///Sets the raw value of [`Self::preserve_attachments`]
    pub fn set_preserve_attachments(&mut self, value: &'lt [u32]) -> &mut Self {
        let len_ = value.len() as u32;
        let len_ = len_;
        self.preserve_attachments = value.as_ptr();
        self.preserve_attachment_count = len_;
        self
    }
}
///[VkSubpassDependency](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSubpassDependency.html) - Structure specifying a subpass dependency
///# C Specifications
///The [`SubpassDependency`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkSubpassDependency {
///    uint32_t                srcSubpass;
///    uint32_t                dstSubpass;
///    VkPipelineStageFlags    srcStageMask;
///    VkPipelineStageFlags    dstStageMask;
///    VkAccessFlags           srcAccessMask;
///    VkAccessFlags           dstAccessMask;
///    VkDependencyFlags       dependencyFlags;
///} VkSubpassDependency;
///```
///# Members
/// - [`src_subpass`] is the subpass index of the first subpass in the dependency, or
///   [`SUBPASS_EXTERNAL`].
/// - [`dst_subpass`] is the subpass index of the second subpass in the dependency, or
///   [`SUBPASS_EXTERNAL`].
/// - [`src_stage_mask`] is a bitmask of [`PipelineStageFlagBits`] specifying the [source stage mask](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-pipeline-stages-masks).
/// - [`dst_stage_mask`] is a bitmask of [`PipelineStageFlagBits`] specifying the [destination stage
///   mask](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-pipeline-stages-masks)
/// - [`src_access_mask`] is a bitmask of [`AccessFlagBits`] specifying a [source access mask](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-access-masks).
/// - [`dst_access_mask`] is a bitmask of [`AccessFlagBits`] specifying a [destination access mask](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-access-masks).
/// - [`dependency_flags`] is a bitmask of [`DependencyFlagBits`].
///# Description
///If [`src_subpass`] is equal to [`dst_subpass`] then the
///[`SubpassDependency`] describes a
///[subpass
///self-dependency](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-pipeline-barriers-subpass-self-dependencies), and only constrains the pipeline barriers allowed within
///a subpass instance.
///Otherwise, when a render pass instance which includes a subpass dependency
///is submitted to a queue, it defines a memory dependency between the
///subpasses identified by [`src_subpass`] and [`dst_subpass`].If [`src_subpass`] is equal to
/// [`SUBPASS_EXTERNAL`], the first
///[synchronization scope](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-dependencies-scopes) includes
///commands that occur earlier in [submission
///order](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-submission-order) than the [`CmdBeginRenderPass`] used to begin the render pass
///instance.
///Otherwise, the first set of commands includes all commands submitted as part
///of the subpass instance identified by [`src_subpass`] and any load, store
///or multisample resolve operations on attachments used in [`src_subpass`].
///In either case, the first synchronization scope is limited to operations on
///the pipeline stages determined by the
///[source stage mask](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-pipeline-stages-masks) specified by
///[`src_stage_mask`].If [`dst_subpass`] is equal to [`SUBPASS_EXTERNAL`], the second
///[synchronization scope](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-dependencies-scopes) includes
///commands that occur later in [submission
///order](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-submission-order) than the [`CmdEndRenderPass`] used to end the render pass
///instance.
///Otherwise, the second set of commands includes all commands submitted as
///part of the subpass instance identified by [`dst_subpass`] and any load,
///store or multisample resolve operations on attachments used in
///[`dst_subpass`].
///In either case, the second synchronization scope is limited to operations on
///the pipeline stages determined by the
///[destination stage mask](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-pipeline-stages-masks) specified
///by [`dst_stage_mask`].The first [access scope](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-dependencies-access-scopes) is
///limited to accesses in the pipeline stages determined by the
///[source stage mask](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-pipeline-stages-masks) specified by
///[`src_stage_mask`].
///It is also limited to access types in the [source access mask](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-access-masks) specified by [`src_access_mask`].The second [access scope](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-dependencies-access-scopes) is
///limited to accesses in the pipeline stages determined by the
///[destination stage mask](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-pipeline-stages-masks) specified
///by [`dst_stage_mask`].
///It is also limited to access types in the [destination access mask](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-access-masks) specified by [`dst_access_mask`].The [availability and
///visibility operations](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-dependencies-available-and-visible) defined by a subpass dependency affect the execution
///of [image layout transitions](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-layout-transitions) within the
///render pass.
///## Valid Usage
/// - If the [geometry shaders](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-geometryShader)
///   feature is not enabled, [`src_stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT`
/// - If the [tessellation shaders](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-tessellationShader)
///   feature is not enabled, [`src_stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT` or
///   `VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT`
/// - If the [conditional rendering](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-conditionalRendering)
///   feature is not enabled, [`src_stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT`
/// - If the [fragment density map](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-fragmentDensityMap)
///   feature is not enabled, [`src_stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT`
/// - If the [transform feedback](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-transformFeedback)
///   feature is not enabled, [`src_stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT`
/// - If the [mesh shaders](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-meshShader)
///   feature is not enabled, [`src_stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV`
/// - If the [task shaders](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-taskShader)
///   feature is not enabled, [`src_stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV`
/// - If the [shading rate image](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-shadingRateImage)
///   feature is not enabled, [`src_stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_SHADING_RATE_IMAGE_BIT_NV`
/// - If the [`synchronization2`](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-synchronization2)
///   feature is not enabled, [`src_stage_mask`] **must**  not be `0`
///
/// - If the [geometry shaders](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-geometryShader)
///   feature is not enabled, [`dst_stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT`
/// - If the [tessellation shaders](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-tessellationShader)
///   feature is not enabled, [`dst_stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT` or
///   `VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT`
/// - If the [conditional rendering](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-conditionalRendering)
///   feature is not enabled, [`dst_stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT`
/// - If the [fragment density map](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-fragmentDensityMap)
///   feature is not enabled, [`dst_stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT`
/// - If the [transform feedback](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-transformFeedback)
///   feature is not enabled, [`dst_stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT`
/// - If the [mesh shaders](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-meshShader)
///   feature is not enabled, [`dst_stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV`
/// - If the [task shaders](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-taskShader)
///   feature is not enabled, [`dst_stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV`
/// - If the [shading rate image](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-shadingRateImage)
///   feature is not enabled, [`dst_stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_SHADING_RATE_IMAGE_BIT_NV`
/// - If the [`synchronization2`](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-synchronization2)
///   feature is not enabled, [`dst_stage_mask`] **must**  not be `0`
/// - [`src_subpass`] **must**  be less than or equal to [`dst_subpass`], unless one of them is
///   [`SUBPASS_EXTERNAL`], to avoid cyclic dependencies and ensure a valid execution order
/// - [`src_subpass`] and [`dst_subpass`] **must**  not both be equal to [`SUBPASS_EXTERNAL`]
/// - If [`src_subpass`] is equal to [`dst_subpass`] and not all of the stages in [`src_stage_mask`]
///   and [`dst_stage_mask`] are [framebuffer-space stages](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-framebuffer-regions),
///   the [logically latest](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-pipeline-stages-order)
///   pipeline stage in [`src_stage_mask`] **must**  be [logically earlier](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-pipeline-stages-order)
///   than or equal to the [logically earliest](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-pipeline-stages-order)
///   pipeline stage in [`dst_stage_mask`]
/// -    Any access flag included in [`src_access_mask`] **must**  be supported by one of the pipeline stages in [`src_stage_mask`], as specified in the [table of supported access types](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-access-types-supported)
/// -    Any access flag included in [`dst_access_mask`] **must**  be supported by one of the pipeline stages in [`dst_stage_mask`], as specified in the [table of supported access types](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-access-types-supported)
/// -    If [`src_subpass`] equals [`dst_subpass`], and [`src_stage_mask`] and [`dst_stage_mask`] both include a [framebuffer-space stage](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-framebuffer-regions), then [`dependency_flags`] **must**  include `VK_DEPENDENCY_BY_REGION_BIT`
/// - If [`dependency_flags`] includes `VK_DEPENDENCY_VIEW_LOCAL_BIT`, [`src_subpass`] **must**  not
///   be equal to [`SUBPASS_EXTERNAL`]
/// - If [`dependency_flags`] includes `VK_DEPENDENCY_VIEW_LOCAL_BIT`, [`dst_subpass`] **must**  not
///   be equal to [`SUBPASS_EXTERNAL`]
/// - If [`src_subpass`] equals [`dst_subpass`] and that subpass has more than one bit set in the
///   view mask, then [`dependency_flags`] **must**  include `VK_DEPENDENCY_VIEW_LOCAL_BIT`
///
///## Valid Usage (Implicit)
/// - [`src_stage_mask`] **must**  be a valid combination of [`PipelineStageFlagBits`] values
/// - [`dst_stage_mask`] **must**  be a valid combination of [`PipelineStageFlagBits`] values
/// - [`src_access_mask`] **must**  be a valid combination of [`AccessFlagBits`] values
/// - [`dst_access_mask`] **must**  be a valid combination of [`AccessFlagBits`] values
/// - [`dependency_flags`] **must**  be a valid combination of [`DependencyFlagBits`] values
///# Related
/// - [`crate::vulkan1_0`]
/// - [`AccessFlags`]
/// - [`DependencyFlags`]
/// - [`PipelineStageFlags`]
/// - [`RenderPassCreateInfo`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct SubpassDependency {
    ///[`src_subpass`] is the subpass index of the first subpass in the
    ///dependency, or [`SUBPASS_EXTERNAL`].
    src_subpass: u32,
    ///[`dst_subpass`] is the subpass index of the second subpass in the
    ///dependency, or [`SUBPASS_EXTERNAL`].
    dst_subpass: u32,
    ///[`src_stage_mask`] is a bitmask of [`PipelineStageFlagBits`]
    ///specifying the [source stage
    ///mask](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-pipeline-stages-masks).
    src_stage_mask: PipelineStageFlags,
    ///[`dst_stage_mask`] is a bitmask of [`PipelineStageFlagBits`]
    ///specifying the [destination
    ///stage mask](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-pipeline-stages-masks)
    dst_stage_mask: PipelineStageFlags,
    ///[`src_access_mask`] is a bitmask of [`AccessFlagBits`] specifying a
    ///[source access mask](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-access-masks).
    src_access_mask: AccessFlags,
    ///[`dst_access_mask`] is a bitmask of [`AccessFlagBits`] specifying a
    ///[destination access mask](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-access-masks).
    dst_access_mask: AccessFlags,
    ///[`dependency_flags`] is a bitmask of [`DependencyFlagBits`].
    dependency_flags: DependencyFlags,
}
impl Default for SubpassDependency {
    fn default() -> Self {
        Self {
            src_subpass: 0,
            dst_subpass: 0,
            src_stage_mask: Default::default(),
            dst_stage_mask: Default::default(),
            src_access_mask: Default::default(),
            dst_access_mask: Default::default(),
            dependency_flags: Default::default(),
        }
    }
}
impl SubpassDependency {
    ///Gets the value of [`Self::src_subpass`]
    pub fn src_subpass(&self) -> u32 {
        self.src_subpass
    }
    ///Gets the value of [`Self::dst_subpass`]
    pub fn dst_subpass(&self) -> u32 {
        self.dst_subpass
    }
    ///Gets the value of [`Self::src_stage_mask`]
    pub fn src_stage_mask(&self) -> PipelineStageFlags {
        self.src_stage_mask
    }
    ///Gets the value of [`Self::dst_stage_mask`]
    pub fn dst_stage_mask(&self) -> PipelineStageFlags {
        self.dst_stage_mask
    }
    ///Gets the value of [`Self::src_access_mask`]
    pub fn src_access_mask(&self) -> AccessFlags {
        self.src_access_mask
    }
    ///Gets the value of [`Self::dst_access_mask`]
    pub fn dst_access_mask(&self) -> AccessFlags {
        self.dst_access_mask
    }
    ///Gets the value of [`Self::dependency_flags`]
    pub fn dependency_flags(&self) -> DependencyFlags {
        self.dependency_flags
    }
    ///Gets a mutable reference to the value of [`Self::src_subpass`]
    pub fn src_subpass_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::dst_subpass`]
    pub fn dst_subpass_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::src_stage_mask`]
    pub fn src_stage_mask_mut(&mut self) -> &mut PipelineStageFlags {
        &mut self.src_stage_mask
    }
    ///Gets a mutable reference to the value of [`Self::dst_stage_mask`]
    pub fn dst_stage_mask_mut(&mut self) -> &mut PipelineStageFlags {
        &mut self.dst_stage_mask
    }
    ///Gets a mutable reference to the value of [`Self::src_access_mask`]
    pub fn src_access_mask_mut(&mut self) -> &mut AccessFlags {
        &mut self.src_access_mask
    }
    ///Gets a mutable reference to the value of [`Self::dst_access_mask`]
    pub fn dst_access_mask_mut(&mut self) -> &mut AccessFlags {
        &mut self.dst_access_mask
    }
    ///Gets a mutable reference to the value of [`Self::dependency_flags`]
    pub fn dependency_flags_mut(&mut self) -> &mut DependencyFlags {
        &mut self.dependency_flags
    }
    ///Sets the raw value of [`Self::src_subpass`]
    pub fn set_src_subpass(&mut self, value: u32) -> &mut Self {
        self.src_subpass = value;
        self
    }
    ///Sets the raw value of [`Self::dst_subpass`]
    pub fn set_dst_subpass(&mut self, value: u32) -> &mut Self {
        self.dst_subpass = value;
        self
    }
    ///Sets the raw value of [`Self::src_stage_mask`]
    pub fn set_src_stage_mask(&mut self, value: crate::vulkan1_0::PipelineStageFlags) -> &mut Self {
        self.src_stage_mask = value;
        self
    }
    ///Sets the raw value of [`Self::dst_stage_mask`]
    pub fn set_dst_stage_mask(&mut self, value: crate::vulkan1_0::PipelineStageFlags) -> &mut Self {
        self.dst_stage_mask = value;
        self
    }
    ///Sets the raw value of [`Self::src_access_mask`]
    pub fn set_src_access_mask(&mut self, value: crate::vulkan1_0::AccessFlags) -> &mut Self {
        self.src_access_mask = value;
        self
    }
    ///Sets the raw value of [`Self::dst_access_mask`]
    pub fn set_dst_access_mask(&mut self, value: crate::vulkan1_0::AccessFlags) -> &mut Self {
        self.dst_access_mask = value;
        self
    }
    ///Sets the raw value of [`Self::dependency_flags`]
    pub fn set_dependency_flags(&mut self, value: crate::vulkan1_0::DependencyFlags) -> &mut Self {
        self.dependency_flags = value;
        self
    }
}
///[VkRenderPassCreateInfo](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderPassCreateInfo.html) - Structure specifying parameters of a newly created render pass
///# C Specifications
///The [`RenderPassCreateInfo`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkRenderPassCreateInfo {
///    VkStructureType                   sType;
///    const void*                       pNext;
///    VkRenderPassCreateFlags           flags;
///    uint32_t                          attachmentCount;
///    const VkAttachmentDescription*    pAttachments;
///    uint32_t                          subpassCount;
///    const VkSubpassDescription*       pSubpasses;
///    uint32_t                          dependencyCount;
///    const VkSubpassDependency*        pDependencies;
///} VkRenderPassCreateInfo;
///```
///# Members
/// - [`s_type`] is the type of this structure.
/// - [`p_next`] is `NULL` or a pointer to a structure extending this structure.
/// - [`flags`] is a bitmask of [`RenderPassCreateFlagBits`]
/// - [`attachment_count`] is the number of attachments used by this render pass.
/// - [`attachments`] is a pointer to an array of [`attachment_count`][`AttachmentDescription`]
///   structures describing the attachments used by the render pass.
/// - [`subpass_count`] is the number of subpasses to create.
/// - [`subpasses`] is a pointer to an array of [`subpass_count`][`SubpassDescription`] structures
///   describing each subpass.
/// - [`dependency_count`] is the number of memory dependencies between pairs of subpasses.
/// - [`dependencies`] is a pointer to an array of [`dependency_count`][`SubpassDependency`]
///   structures describing dependencies between pairs of subpasses.
///# Description
///## Valid Usage
/// - If the `attachment` member of any element of `pInputAttachments`, `pColorAttachments`,
///   `pResolveAttachments` or `pDepthStencilAttachment`, or any element of `pPreserveAttachments`
///   in any element of [`subpasses`] is not [`ATTACHMENT_UNUSED`], then it  **must**  be less than
///   [`attachment_count`]
/// - If the pNext chain includes a [`RenderPassFragmentDensityMapCreateInfoEXT`] structure and the
///   `fragmentDensityMapAttachment` member is not [`ATTACHMENT_UNUSED`], then `attachment` **must**
///   be less than [`attachment_count`]
/// - For any member of [`attachments`] with a `loadOp` equal to `VK_ATTACHMENT_LOAD_OP_CLEAR`, the
///   first use of that attachment  **must**  not specify a `layout` equal to
///   `VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL` or
///   `VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL`
/// - For any member of [`attachments`] with a `stencilLoadOp` equal to
///   `VK_ATTACHMENT_LOAD_OP_CLEAR`, the first use of that attachment  **must**  not specify a
///   `layout` equal to `VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL` or
///   `VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL`
/// - For any member of [`attachments`] with a `loadOp` equal to `VK_ATTACHMENT_LOAD_OP_CLEAR`, the
///   first use of that attachment  **must**  not specify a `layout` equal to
///   `VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL`
/// - For any member of [`attachments`] with a `stencilLoadOp` equal to
///   `VK_ATTACHMENT_LOAD_OP_CLEAR`, the first use of that attachment  **must**  not specify a
///   `layout` equal to `VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL`
/// - If the [`p_next`] chain includes a [`RenderPassInputAttachmentAspectCreateInfo`] structure,
///   the `subpass` member of each element of its `pAspectReferences` member  **must**  be less than
///   [`subpass_count`]
/// - If the [`p_next`] chain includes a [`RenderPassInputAttachmentAspectCreateInfo`] structure,
///   the `inputAttachmentIndex` member of each element of its `pAspectReferences` member  **must**
///   be less than the value of `inputAttachmentCount` in the element of [`subpasses`] identified by
///   its `subpass` member
/// - If the [`p_next`] chain includes a [`RenderPassInputAttachmentAspectCreateInfo`] structure,
///   for any element of the `pInputAttachments` member of any element of [`subpasses`] where the
///   `attachment` member is not [`ATTACHMENT_UNUSED`], the `aspectMask` member of the corresponding
///   element of [`RenderPassInputAttachmentAspectCreateInfo::aspect_references`] **must**  only
///   include aspects that are present in images of the format specified by the element of
///   [`attachments`] at `attachment`
/// - If the [`p_next`] chain includes a [`RenderPassMultiviewCreateInfo`] structure, and its
///   [`subpass_count`] member is not zero, that member  **must**  be equal to the value of
///   [`subpass_count`]
/// - If the [`p_next`] chain includes a [`RenderPassMultiviewCreateInfo`] structure, if its
///   [`dependency_count`] member is not zero, it  **must**  be equal to [`dependency_count`]
/// - If the [`p_next`] chain includes a [`RenderPassMultiviewCreateInfo`] structure, for each
///   non-zero element of `pViewOffsets`, the `srcSubpass` and `dstSubpass` members of
///   [`dependencies`] at the same index  **must**  not be equal
/// - If the [`p_next`] chain includes a [`RenderPassMultiviewCreateInfo`] structure, for any
///   element of [`dependencies`] with a `dependencyFlags` member that does not include
///   `VK_DEPENDENCY_VIEW_LOCAL_BIT`, the corresponding element of the `pViewOffsets` member of that
///   [`RenderPassMultiviewCreateInfo`] instance  **must**  be `0`
/// - If the [`p_next`] chain includes a [`RenderPassMultiviewCreateInfo`] structure, elements of
///   its `pViewMasks` member  **must**  either all be `0`, or all not be `0`
/// - If the [`p_next`] chain includes a [`RenderPassMultiviewCreateInfo`] structure, and each
///   element of its `pViewMasks` member is `0`, the `dependencyFlags` member of each element of
///   [`dependencies`] **must**  not include `VK_DEPENDENCY_VIEW_LOCAL_BIT`
/// - If the [`p_next`] chain includes a [`RenderPassMultiviewCreateInfo`] structure, and each
///   element of its `pViewMasks` member is `0`, its `correlationMaskCount` member  **must**  be `0`
/// -    For any element of [`dependencies`], if the `srcSubpass` is not [`SUBPASS_EXTERNAL`], all stage flags included in the `srcStageMask` member of that dependency  **must**  be a pipeline stage supported by the [pipeline](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-pipeline-stages-types) identified by the `pipelineBindPoint` member of the source subpass
/// -    For any element of [`dependencies`], if the `dstSubpass` is not [`SUBPASS_EXTERNAL`], all stage flags included in the `dstStageMask` member of that dependency  **must**  be a pipeline stage supported by the [pipeline](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-pipeline-stages-types) identified by the `pipelineBindPoint` member of the destination subpass
/// - The `srcSubpass` member of each element of [`dependencies`] **must**  be less than
///   [`subpass_count`]
/// - The `dstSubpass` member of each element of [`dependencies`] **must**  be less than
///   [`subpass_count`]
///
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be `VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO`
/// - Each [`p_next`] member of any structure (including this one) in the [`p_next`] chain  **must**
///   be either `NULL` or a pointer to a valid instance of
///   [`RenderPassFragmentDensityMapCreateInfoEXT`], [`RenderPassInputAttachmentAspectCreateInfo`],
///   or [`RenderPassMultiviewCreateInfo`]
/// - The [`s_type`] value of each struct in the [`p_next`] chain  **must**  be unique
/// - [`flags`] **must**  be a valid combination of [`RenderPassCreateFlagBits`] values
/// - If [`attachment_count`] is not `0`, [`attachments`] **must**  be a valid pointer to an array
///   of [`attachment_count`] valid [`AttachmentDescription`] structures
/// - [`subpasses`] **must**  be a valid pointer to an array of [`subpass_count`] valid
///   [`SubpassDescription`] structures
/// - If [`dependency_count`] is not `0`, [`dependencies`] **must**  be a valid pointer to an array
///   of [`dependency_count`] valid [`SubpassDependency`] structures
/// - [`subpass_count`] **must**  be greater than `0`
///# Related
/// - [`crate::vulkan1_0`]
/// - [`AttachmentDescription`]
/// - [`RenderPassCreateFlags`]
/// - [`StructureType`]
/// - [`SubpassDependency`]
/// - [`SubpassDescription`]
/// - [`CreateRenderPass`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[repr(C)]
pub struct RenderPassCreateInfo<'lt> {
    _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] is the type of this structure.
    s_type: StructureType,
    ///[`p_next`] is `NULL` or a pointer to a structure extending this
    ///structure.
    p_next: *const BaseInStructure<'lt>,
    ///[`flags`] is a bitmask of [`RenderPassCreateFlagBits`]
    flags: RenderPassCreateFlags,
    ///[`attachment_count`] is the number of attachments used by this render
    ///pass.
    attachment_count: u32,
    ///[`attachments`] is a pointer to an array of [`attachment_count`][`AttachmentDescription`]
    /// structures describing the attachments used by the render pass.
    attachments: *const AttachmentDescription,
    ///[`subpass_count`] is the number of subpasses to create.
    subpass_count: u32,
    ///[`subpasses`] is a pointer to an array of [`subpass_count`][`SubpassDescription`] structures
    /// describing each subpass.
    subpasses: *const SubpassDescription<'lt>,
    ///[`dependency_count`] is the number of memory dependencies between pairs
    ///of subpasses.
    dependency_count: u32,
    ///[`dependencies`] is a pointer to an array of [`dependency_count`][`SubpassDependency`]
    /// structures describing dependencies between pairs of subpasses.
    dependencies: *const SubpassDependency,
}
impl<'lt> Default for RenderPassCreateInfo<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: Default::default(),
            p_next: std::ptr::null(),
            flags: Default::default(),
            attachment_count: 0,
            attachments: std::ptr::null(),
            subpass_count: 0,
            subpasses: std::ptr::null(),
            dependency_count: 0,
            dependencies: std::ptr::null(),
        }
    }
}
impl<'lt> RenderPassCreateInfo<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *const BaseInStructure<'lt> {
        self.p_next
    }
    ///Gets the raw value of [`Self::attachments`]
    pub fn attachments_raw(&self) -> *const AttachmentDescription {
        self.attachments
    }
    ///Gets the raw value of [`Self::subpasses`]
    pub fn subpasses_raw(&self) -> *const SubpassDescription<'lt> {
        self.subpasses
    }
    ///Gets the raw value of [`Self::dependencies`]
    pub fn dependencies_raw(&self) -> *const SubpassDependency {
        self.dependencies
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *const BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::attachments`]
    pub fn set_attachments_raw(&mut self, value: *const AttachmentDescription) -> &mut Self {
        self.attachments = value;
        self
    }
    ///Sets the raw value of [`Self::subpasses`]
    pub fn set_subpasses_raw(&mut self, value: *const SubpassDescription<'lt>) -> &mut Self {
        self.subpasses = value;
        self
    }
    ///Sets the raw value of [`Self::dependencies`]
    pub fn set_dependencies_raw(&mut self, value: *const SubpassDependency) -> &mut Self {
        self.dependencies = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseInStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::flags`]
    pub fn flags(&self) -> RenderPassCreateFlags {
        self.flags
    }
    ///Gets the value of [`Self::attachment_count`]
    pub fn attachment_count(&self) -> u32 {
        self.attachment_count
    }
    ///Gets the value of [`Self::attachments`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn attachments(&self) -> &[AttachmentDescription] {
        std::slice::from_raw_parts(self.attachments, self.attachment_count as usize)
    }
    ///Gets the value of [`Self::subpass_count`]
    pub fn subpass_count(&self) -> u32 {
        self.subpass_count
    }
    ///Gets the value of [`Self::subpasses`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn subpasses(&self) -> &[SubpassDescription<'lt>] {
        std::slice::from_raw_parts(self.subpasses, self.subpass_count as usize)
    }
    ///Gets the value of [`Self::dependency_count`]
    pub fn dependency_count(&self) -> u32 {
        self.dependency_count
    }
    ///Gets the value of [`Self::dependencies`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn dependencies(&self) -> &[SubpassDependency] {
        std::slice::from_raw_parts(self.dependencies, self.dependency_count as usize)
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::flags`]
    pub fn flags_mut(&mut self) -> &mut RenderPassCreateFlags {
        &mut self.flags
    }
    ///Gets a mutable reference to the value of [`Self::attachment_count`]
    pub fn attachment_count_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::subpass_count`]
    pub fn subpass_count_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::dependency_count`]
    pub fn dependency_count_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Sets the raw value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the raw value of [`Self::flags`]
    pub fn set_flags(&mut self, value: crate::vulkan1_0::RenderPassCreateFlags) -> &mut Self {
        self.flags = value;
        self
    }
    ///Sets the raw value of [`Self::attachment_count`]
    pub fn set_attachment_count(&mut self, value: u32) -> &mut Self {
        self.attachment_count = value;
        self
    }
    ///Sets the raw value of [`Self::attachments`]
    pub fn set_attachments(&mut self, value: &'lt [crate::vulkan1_0::AttachmentDescription]) -> &mut Self {
        let len_ = value.len() as u32;
        let len_ = len_;
        self.attachments = value.as_ptr();
        self.attachment_count = len_;
        self
    }
    ///Sets the raw value of [`Self::subpass_count`]
    pub fn set_subpass_count(&mut self, value: u32) -> &mut Self {
        self.subpass_count = value;
        self
    }
    ///Sets the raw value of [`Self::subpasses`]
    pub fn set_subpasses(&mut self, value: &'lt [crate::vulkan1_0::SubpassDescription<'lt>]) -> &mut Self {
        let len_ = value.len() as u32;
        let len_ = len_;
        self.subpasses = value.as_ptr();
        self.subpass_count = len_;
        self
    }
    ///Sets the raw value of [`Self::dependency_count`]
    pub fn set_dependency_count(&mut self, value: u32) -> &mut Self {
        self.dependency_count = value;
        self
    }
    ///Sets the raw value of [`Self::dependencies`]
    pub fn set_dependencies(&mut self, value: &'lt [crate::vulkan1_0::SubpassDependency]) -> &mut Self {
        let len_ = value.len() as u32;
        let len_ = len_;
        self.dependencies = value.as_ptr();
        self.dependency_count = len_;
        self
    }
}
///[VkEventCreateInfo](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkEventCreateInfo.html) - Structure specifying parameters of a newly created event
///# C Specifications
///The [`EventCreateInfo`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkEventCreateInfo {
///    VkStructureType       sType;
///    const void*           pNext;
///    VkEventCreateFlags    flags;
///} VkEventCreateInfo;
///```
///# Members
/// - [`s_type`] is the type of this structure.
/// - [`p_next`] is `NULL` or a pointer to a structure extending this structure.
/// - [`flags`] is a bitmask of [`EventCreateFlagBits`] defining additional creation parameters.
///# Description
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be `VK_STRUCTURE_TYPE_EVENT_CREATE_INFO`
/// - [`p_next`] **must**  be `NULL`
/// - [`flags`] **must**  be a valid combination of [`EventCreateFlagBits`] values
///# Related
/// - [`crate::vulkan1_0`]
/// - [`EventCreateFlags`]
/// - [`StructureType`]
/// - [`CreateEvent`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[repr(C)]
pub struct EventCreateInfo<'lt> {
    _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] is the type of this structure.
    s_type: StructureType,
    ///[`p_next`] is `NULL` or a pointer to a structure extending this
    ///structure.
    p_next: *const BaseInStructure<'lt>,
    ///[`flags`] is a bitmask of [`EventCreateFlagBits`] defining
    ///additional creation parameters.
    flags: EventCreateFlags,
}
impl<'lt> Default for EventCreateInfo<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: Default::default(),
            p_next: std::ptr::null(),
            flags: Default::default(),
        }
    }
}
impl<'lt> EventCreateInfo<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *const BaseInStructure<'lt> {
        self.p_next
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *const BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseInStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::flags`]
    pub fn flags(&self) -> EventCreateFlags {
        self.flags
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::flags`]
    pub fn flags_mut(&mut self) -> &mut EventCreateFlags {
        &mut self.flags
    }
    ///Sets the raw value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the raw value of [`Self::flags`]
    pub fn set_flags(&mut self, value: crate::vulkan1_0::EventCreateFlags) -> &mut Self {
        self.flags = value;
        self
    }
}
///[VkFenceCreateInfo](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFenceCreateInfo.html) - Structure specifying parameters of a newly created fence
///# C Specifications
///The [`FenceCreateInfo`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkFenceCreateInfo {
///    VkStructureType       sType;
///    const void*           pNext;
///    VkFenceCreateFlags    flags;
///} VkFenceCreateInfo;
///```
///# Members
/// - [`s_type`] is the type of this structure.
/// - [`p_next`] is `NULL` or a pointer to a structure extending this structure.
/// - [`flags`] is a bitmask of [`FenceCreateFlagBits`] specifying the initial state and behavior of
///   the fence.
///# Description
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be `VK_STRUCTURE_TYPE_FENCE_CREATE_INFO`
/// - Each [`p_next`] member of any structure (including this one) in the [`p_next`] chain  **must**
///   be either `NULL` or a pointer to a valid instance of [`ExportFenceCreateInfo`] or
///   [`ExportFenceWin32HandleInfoKHR`]
/// - The [`s_type`] value of each struct in the [`p_next`] chain  **must**  be unique
/// - [`flags`] **must**  be a valid combination of [`FenceCreateFlagBits`] values
///# Related
/// - [`crate::vulkan1_0`]
/// - [`FenceCreateFlags`]
/// - [`StructureType`]
/// - [`CreateFence`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[repr(C)]
pub struct FenceCreateInfo<'lt> {
    _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] is the type of this structure.
    s_type: StructureType,
    ///[`p_next`] is `NULL` or a pointer to a structure extending this
    ///structure.
    p_next: *const BaseInStructure<'lt>,
    ///[`flags`] is a bitmask of [`FenceCreateFlagBits`] specifying the
    ///initial state and behavior of the fence.
    flags: FenceCreateFlags,
}
impl<'lt> Default for FenceCreateInfo<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: Default::default(),
            p_next: std::ptr::null(),
            flags: Default::default(),
        }
    }
}
impl<'lt> FenceCreateInfo<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *const BaseInStructure<'lt> {
        self.p_next
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *const BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseInStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::flags`]
    pub fn flags(&self) -> FenceCreateFlags {
        self.flags
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::flags`]
    pub fn flags_mut(&mut self) -> &mut FenceCreateFlags {
        &mut self.flags
    }
    ///Sets the raw value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the raw value of [`Self::flags`]
    pub fn set_flags(&mut self, value: crate::vulkan1_0::FenceCreateFlags) -> &mut Self {
        self.flags = value;
        self
    }
}
///[VkPhysicalDeviceFeatures](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFeatures.html) - Structure describing the fine-grained features that can be supported by an implementation
///# C Specifications
///The [`PhysicalDeviceFeatures`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkPhysicalDeviceFeatures {
///    VkBool32    robustBufferAccess;
///    VkBool32    fullDrawIndexUint32;
///    VkBool32    imageCubeArray;
///    VkBool32    independentBlend;
///    VkBool32    geometryShader;
///    VkBool32    tessellationShader;
///    VkBool32    sampleRateShading;
///    VkBool32    dualSrcBlend;
///    VkBool32    logicOp;
///    VkBool32    multiDrawIndirect;
///    VkBool32    drawIndirectFirstInstance;
///    VkBool32    depthClamp;
///    VkBool32    depthBiasClamp;
///    VkBool32    fillModeNonSolid;
///    VkBool32    depthBounds;
///    VkBool32    wideLines;
///    VkBool32    largePoints;
///    VkBool32    alphaToOne;
///    VkBool32    multiViewport;
///    VkBool32    samplerAnisotropy;
///    VkBool32    textureCompressionETC2;
///    VkBool32    textureCompressionASTC_LDR;
///    VkBool32    textureCompressionBC;
///    VkBool32    occlusionQueryPrecise;
///    VkBool32    pipelineStatisticsQuery;
///    VkBool32    vertexPipelineStoresAndAtomics;
///    VkBool32    fragmentStoresAndAtomics;
///    VkBool32    shaderTessellationAndGeometryPointSize;
///    VkBool32    shaderImageGatherExtended;
///    VkBool32    shaderStorageImageExtendedFormats;
///    VkBool32    shaderStorageImageMultisample;
///    VkBool32    shaderStorageImageReadWithoutFormat;
///    VkBool32    shaderStorageImageWriteWithoutFormat;
///    VkBool32    shaderUniformBufferArrayDynamicIndexing;
///    VkBool32    shaderSampledImageArrayDynamicIndexing;
///    VkBool32    shaderStorageBufferArrayDynamicIndexing;
///    VkBool32    shaderStorageImageArrayDynamicIndexing;
///    VkBool32    shaderClipDistance;
///    VkBool32    shaderCullDistance;
///    VkBool32    shaderFloat64;
///    VkBool32    shaderInt64;
///    VkBool32    shaderInt16;
///    VkBool32    shaderResourceResidency;
///    VkBool32    shaderResourceMinLod;
///    VkBool32    sparseBinding;
///    VkBool32    sparseResidencyBuffer;
///    VkBool32    sparseResidencyImage2D;
///    VkBool32    sparseResidencyImage3D;
///    VkBool32    sparseResidency2Samples;
///    VkBool32    sparseResidency4Samples;
///    VkBool32    sparseResidency8Samples;
///    VkBool32    sparseResidency16Samples;
///    VkBool32    sparseResidencyAliased;
///    VkBool32    variableMultisampleRate;
///    VkBool32    inheritedQueries;
///} VkPhysicalDeviceFeatures;
///```
///# Members
///This structure describes the following features:
///# Description
/// - [`robust_buffer_access`] specifies that accesses to buffers are bounds-checked against the range of the buffer descriptor (as determined by [`DescriptorBufferInfo::range`], [`BufferViewCreateInfo::range`], or the size of the buffer). Out of bounds accesses  **must**  not cause application termination, and the effects of shader loads, stores, and atomics  **must**  conform to an implementation-dependent behavior as described below.  - A buffer access is considered to be out of bounds if any of the following are true:   - The pointer was formed by `OpImageTexelPointer` and the coordinate is less than zero or greater than or equal to the number of whole elements in the bound range.   - The pointer was not formed by `OpImageTexelPointer` and the object pointed to is not wholly contained within the bound range. This includes accesses performed via *variable pointers* where the buffer descriptor being accessed cannot be statically determined. Uninitialized pointers and pointers equal to `OpConstantNull` are treated as pointing to a zero-sized object, so all accesses through such pointers are considered to be out of bounds. Buffer accesses through buffer device addresses are not bounds-checked. If the [`cooperativeMatrixRobustBufferAccess`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-cooperativeMatrixRobustBufferAccess) feature is not enabled, then accesses using `OpCooperativeMatrixLoadNV` and `OpCooperativeMatrixStoreNV` **may**  not be bounds-checked.   - If [`robustBufferAccess2`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-robustBufferAccess2) is not enabled and any buffer access is determined to be out of bounds, then any other access of the same type (load, store, or atomic) to the same buffer that accesses an address less than 16 bytes away from the out of bounds address  **may**  also be considered out of bounds.   - If the access is a load that reads from the same memory locations as a prior store in the same shader invocation, with no other intervening accesses to the same memory locations in that shader invocation, then the result of the load  **may**  be the value stored by the store instruction, even if the access is out of bounds. If the load is `Volatile`, then an out of bounds load  **must**  return the appropriate out of bounds value.   - Accesses to descriptors written with a [`crate::utils::Handle::null`] resource or view are not considered to be out of bounds. Instead, each type of descriptor access defines a specific behavior for accesses to a null descriptor.  - Out-of-bounds buffer loads will return any of the following values:   - If the access is to a uniform buffer and [`robustBufferAccess2`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-robustBufferAccess2) is enabled, loads of offsets between the end of the descriptor range and the end of the descriptor range rounded up to a multiple of [robustUniformBufferAccessSizeAlignment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#limits-robustUniformBufferAccessSizeAlignment) bytes  **must**  return either zero values or the contents of the memory at the offset being loaded. Loads of offsets past the descriptor range rounded up to a multiple of [robustUniformBufferAccessSizeAlignment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#limits-robustUniformBufferAccessSizeAlignment) bytes  **must**  return zero values.   - If the access is to a storage buffer and [`robustBufferAccess2`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-robustBufferAccess2) is enabled, loads of offsets between the end of the descriptor range and the end of the descriptor range rounded up to a multiple of [robustStorageBufferAccessSizeAlignment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#limits-robustStorageBufferAccessSizeAlignment) bytes  **must**  return either zero values or the contents of the memory at the offset being loaded. Loads of offsets past the descriptor range rounded up to a multiple of [robustStorageBufferAccessSizeAlignment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#limits-robustStorageBufferAccessSizeAlignment) bytes  **must**  return zero values. Similarly, stores to addresses between the end of the descriptor range and the end of the descriptor range rounded up to a multiple of [robustStorageBufferAccessSizeAlignment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#limits-robustStorageBufferAccessSizeAlignment) bytes  **may**  be discarded.   - Non-atomic accesses to storage buffers that are a multiple of 32 bits  **may**  be decomposed into 32-bit accesses that are individually bounds-checked.   - If the access is to an index buffer and [`robustBufferAccess2`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-robustBufferAccess2) is enabled, zero values  **must**  be returned.   - If the access is to a uniform texel buffer or storage texel buffer and [`robustBufferAccess2`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-robustBufferAccess2) is enabled, zero values  **must**  be returned, and then [Conversion to RGBA](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#textures-conversion-to-rgba) is applied based on the buffer view’s format.   - Values from anywhere within the memory range(s) bound to the buffer (possibly including bytes of memory past the end of the buffer, up to the end of the bound range).   - Zero values, or (0,0,0,x) vectors for vector reads where x is a valid value represented in the type of the vector components and  **may**  be any of:    - 0, 1, or the maximum representable positive integer value, for signed or unsigned integer components    - 0.0 or 1.0, for floating-point components    - Out-of-bounds writes  **may**  modify values within the memory range(s) bound to the buffer, but  **must**  not modify any other memory.   - If [`robustBufferAccess2`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-robustBufferAccess2) is enabled, out of bounds writes  **must**  not modify any memory.   - Out-of-bounds atomics  **may**  modify values within the memory range(s) bound to the buffer, but  **must**  not modify any other memory, and return an undefined value.   - If [`robustBufferAccess2`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-robustBufferAccess2) is enabled, out of bounds atomics  **must**  not modify any memory, and return an undefined value.   - If [`robustBufferAccess2`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-robustBufferAccess2) is disabled, vertex input attributes are considered out of bounds if the offset of the attribute in the bound vertex buffer range plus the size of the attribute is greater than either:   - `vertexBufferRangeSize`, if `bindingStride` == 0; or   - (`vertexBufferRangeSize` - (`vertexBufferRangeSize` % `bindingStride`)) where `vertexBufferRangeSize` is the byte size of the memory range bound to the vertex buffer binding and `bindingStride` is the byte stride of the corresponding vertex input binding. Further, if any vertex input attribute using a specific vertex input binding is out of bounds, then all vertex input attributes using that vertex input binding for that vertex shader invocation are considered out of bounds.   - If a vertex input attribute is out of bounds, it will be assigned one of the following values:    - Values from anywhere within the memory range(s) bound to the buffer, converted according to the format of the attribute.    - Zero values, format converted according to the format of the attribute.    - Zero values, or (0,0,0,x) vectors, as described above.    - If [`robustBufferAccess2`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-robustBufferAccess2) is enabled, vertex input attributes are considered out of bounds if the offset of the attribute in the bound vertex buffer range plus the size of the attribute is greater than the byte size of the memory range bound to the vertex buffer binding.   - If a vertex input attribute is out of bounds, the [raw data](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fxvertex-input-extraction) extracted are zero values, and missing G, B, or A components are [filled with (0,0,1)](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#fxvertex-input-extraction).   - If [`robust_buffer_access`] is not enabled, applications  **must**  not perform out of bounds accesses.
/// - [`full_draw_index_uint_32`] specifies the full 32-bit range of indices is supported for indexed draw calls when using a [`IndexType`] of `VK_INDEX_TYPE_UINT32`. `maxDrawIndexedIndexValue` is the maximum index value that  **may**  be used (aside from the primitive restart index, which is always 2<sup>32</sup>-1 when the [`IndexType`] is `VK_INDEX_TYPE_UINT32`). If this feature is supported, `maxDrawIndexedIndexValue` **must**  be 2<sup>32</sup>-1; otherwise it  **must**  be no smaller than 2<sup>24</sup>-1. See [maxDrawIndexedIndexValue](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#limits-maxDrawIndexedIndexValue).
/// - [`image_cube_array`] specifies whether image views with a [`ImageViewType`] of
///   `VK_IMAGE_VIEW_TYPE_CUBE_ARRAY` **can**  be created, and that the corresponding
///   `SampledCubeArray` and `ImageCubeArray` SPIR-V capabilities  **can**  be used in shader code.
/// - [`independent_blend`] specifies whether the [`PipelineColorBlendAttachmentState`] settings are
///   controlled independently per-attachment. If this feature is not enabled, the
///   [`PipelineColorBlendAttachmentState`] settings for all color attachments  **must**  be
///   identical. Otherwise, a different [`PipelineColorBlendAttachmentState`] **can**  be provided
///   for each bound color attachment.
/// - [`geometry_shader`] specifies whether geometry shaders are supported. If this feature is not
///   enabled, the `VK_SHADER_STAGE_GEOMETRY_BIT` and `VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT` enum
///   values  **must**  not be used. This also specifies whether shader modules  **can**  declare
///   the `Geometry` capability.
/// - [`tessellation_shader`] specifies whether tessellation control and evaluation shaders are
///   supported. If this feature is not enabled, the `VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT`,
///   `VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT`,
///   `VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT`,
///   `VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT`, and
///   `VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO` enum values  **must**  not be
///   used. This also specifies whether shader modules  **can**  declare the `Tessellation`
///   capability.
/// - [`sample_rate_shading`] specifies whether [Sample Shading](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#primsrast-sampleshading)
///   and multisample interpolation are supported. If this feature is not enabled, the
///   `sampleShadingEnable` member of the [`PipelineMultisampleStateCreateInfo`] structure  **must**
///   be set to [`FALSE`] and the `minSampleShading` member is ignored. This also specifies whether
///   shader modules  **can**  declare the `SampleRateShading` capability.
/// - [`dual_src_blend`] specifies whether blend operations which take two sources are supported. If
///   this feature is not enabled, the `VK_BLEND_FACTOR_SRC1_COLOR`, `VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR`,
///   `VK_BLEND_FACTOR_SRC1_ALPHA`, and `VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA` enum values  **must**
///   not be used as source or destination blending factors. See [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#framebuffer-dsb](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#framebuffer-dsb).
/// - [`logic_op`] specifies whether logic operations are supported. If this feature is not enabled,
///   the `logicOpEnable` member of the [`PipelineColorBlendStateCreateInfo`] structure  **must**
///   be set to [`FALSE`], and the [`logic_op`] member is ignored.
/// - [`multi_draw_indirect`] specifies whether multiple draw indirect is supported. If this feature
///   is not enabled, the `drawCount` parameter to the [`CmdDrawIndirect`] and [`CmdDrawIndexedIndirect`]
///   commands  **must**  be 0 or 1. The `maxDrawIndirectCount` member of the [`PhysicalDeviceLimits`]
///   structure  **must**  also be 1 if this feature is not supported. See [maxDrawIndirectCount](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#limits-maxDrawIndirectCount).
/// - [`draw_indirect_first_instance`] specifies whether indirect drawing calls support the
///   `firstInstance` parameter. If this feature is not enabled, the `firstInstance` member of all
///   [`DrawIndirectCommand`] and [`DrawIndexedIndirectCommand`] structures that are provided to the
///   [`CmdDrawIndirect`] and [`CmdDrawIndexedIndirect`] commands  **must**  be 0.
/// - [`depth_clamp`] specifies whether depth clamping is supported. If this feature is not enabled,
///   the `depthClampEnable` member of the [`PipelineRasterizationStateCreateInfo`] structure
///   **must**  be set to [`FALSE`]. Otherwise, setting `depthClampEnable` to [`TRUE`] will enable
///   depth clamping.
/// - [`depth_bias_clamp`] specifies whether depth bias clamping is supported. If this feature is
///   not enabled, the [`depth_bias_clamp`] member of the [`PipelineRasterizationStateCreateInfo`]
///   structure  **must**  be set to 0.0 unless the `VK_DYNAMIC_STATE_DEPTH_BIAS` dynamic state is
///   enabled, and the [`depth_bias_clamp`] parameter to [`CmdSetDepthBias`] **must**  be set to
///   0.0.
/// - [`fill_mode_non_solid`] specifies whether point and wireframe fill modes are supported. If
///   this feature is not enabled, the `VK_POLYGON_MODE_POINT` and `VK_POLYGON_MODE_LINE` enum
///   values  **must**  not be used.
/// - [`depth_bounds`] specifies whether depth bounds tests are supported. If this feature is not
///   enabled, the `depthBoundsTestEnable` member of the [`PipelineDepthStencilStateCreateInfo`]
///   structure  **must**  be set to [`FALSE`]. When `depthBoundsTestEnable` is set to [`FALSE`],
///   the `minDepthBounds` and `maxDepthBounds` members of the
///   [`PipelineDepthStencilStateCreateInfo`] structure are ignored.
/// - [`wide_lines`] specifies whether lines with width other than 1.0 are supported. If this
///   feature is not enabled, the `lineWidth` member of the [`PipelineRasterizationStateCreateInfo`]
///   structure  **must**  be set to 1.0 unless the `VK_DYNAMIC_STATE_LINE_WIDTH` dynamic state is
///   enabled, and the `lineWidth` parameter to [`CmdSetLineWidth`] **must**  be set to 1.0. When
///   this feature is supported, the range and granularity of supported line widths are indicated by
///   the `lineWidthRange` and `lineWidthGranularity` members of the [`PhysicalDeviceLimits`]
///   structure, respectively.
/// - [`large_points`] specifies whether points with size greater than 1.0 are supported. If this
///   feature is not enabled, only a point size of 1.0 written by a shader is supported. The range
///   and granularity of supported point sizes are indicated by the `pointSizeRange` and
///   `pointSizeGranularity` members of the [`PhysicalDeviceLimits`] structure, respectively.
/// - [`alpha_to_one`] specifies whether the implementation is able to replace the alpha value of the fragment shader color output in the [Multisample Coverage](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fragops-covg) fragment operation. If this feature is not enabled, then the `alphaToOneEnable` member of the [`PipelineMultisampleStateCreateInfo`] structure  **must**  be set to [`FALSE`]. Otherwise setting `alphaToOneEnable` to [`TRUE`] will enable alpha-to-one behavior.
/// - [`multi_viewport`] specifies whether more than one viewport is supported. If this feature is
///   not enabled:  - The `viewportCount` and `scissorCount` members of the
///   [`PipelineViewportStateCreateInfo`] structure  **must**  be set to 1.  - The `firstViewport`
///   and `viewportCount` parameters to the [`CmdSetViewport`] command  **must**  be set to 0 and 1,
///   respectively.  - The `firstScissor` and `scissorCount` parameters to the [`CmdSetScissor`]
///   command  **must**  be set to 0 and 1, respectively.  - The `exclusiveScissorCount` member of
///   the [`PipelineViewportExclusiveScissorStateCreateInfoNV`] structure  **must**  be set to 0 or
///   1.  - The `firstExclusiveScissor` and `exclusiveScissorCount` parameters to the
///   [`CmdSetExclusiveScissorNV`] command  **must**  be set to 0 and 1, respectively.
/// - [`sampler_anisotropy`] specifies whether anisotropic filtering is supported. If this feature
///   is not enabled, the `anisotropyEnable` member of the [`SamplerCreateInfo`] structure  **must**
///   be [`FALSE`].
/// - [`texture_compression_etc_2`] specifies whether all of the ETC2 and EAC compressed texture
///   formats are supported. If this feature is enabled, then the
///   `VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT`, `VK_FORMAT_FEATURE_BLIT_SRC_BIT` and
///   `VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT` features  **must**  be supported in
///   `optimalTilingFeatures` for the following formats:  - `VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK`  -
///   `VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK`  - `VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK`  -
///   `VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK`  - `VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK`  -
///   `VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK`  - `VK_FORMAT_EAC_R11_UNORM_BLOCK`  -
///   `VK_FORMAT_EAC_R11_SNORM_BLOCK`  - `VK_FORMAT_EAC_R11G11_UNORM_BLOCK`  -
///   `VK_FORMAT_EAC_R11G11_SNORM_BLOCK` To query for additional properties, or if the feature is
///   not enabled, [`GetPhysicalDeviceFormatProperties`] and
///   [`GetPhysicalDeviceImageFormatProperties`] **can**  be used to check for supported properties
///   of individual formats as normal.
/// - [`texture_compression_astc_ldr`] specifies whether all of the ASTC LDR compressed texture
///   formats are supported. If this feature is enabled, then the
///   `VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT`, `VK_FORMAT_FEATURE_BLIT_SRC_BIT` and
///   `VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT` features  **must**  be supported in
///   `optimalTilingFeatures` for the following formats:  - `VK_FORMAT_ASTC_4x4_UNORM_BLOCK`  -
///   `VK_FORMAT_ASTC_4x4_SRGB_BLOCK`  - `VK_FORMAT_ASTC_5x4_UNORM_BLOCK`  -
///   `VK_FORMAT_ASTC_5x4_SRGB_BLOCK`  - `VK_FORMAT_ASTC_5x5_UNORM_BLOCK`  -
///   `VK_FORMAT_ASTC_5x5_SRGB_BLOCK`  - `VK_FORMAT_ASTC_6x5_UNORM_BLOCK`  -
///   `VK_FORMAT_ASTC_6x5_SRGB_BLOCK`  - `VK_FORMAT_ASTC_6x6_UNORM_BLOCK`  -
///   `VK_FORMAT_ASTC_6x6_SRGB_BLOCK`  - `VK_FORMAT_ASTC_8x5_UNORM_BLOCK`  -
///   `VK_FORMAT_ASTC_8x5_SRGB_BLOCK`  - `VK_FORMAT_ASTC_8x6_UNORM_BLOCK`  -
///   `VK_FORMAT_ASTC_8x6_SRGB_BLOCK`  - `VK_FORMAT_ASTC_8x8_UNORM_BLOCK`  -
///   `VK_FORMAT_ASTC_8x8_SRGB_BLOCK`  - `VK_FORMAT_ASTC_10x5_UNORM_BLOCK`  -
///   `VK_FORMAT_ASTC_10x5_SRGB_BLOCK`  - `VK_FORMAT_ASTC_10x6_UNORM_BLOCK`  -
///   `VK_FORMAT_ASTC_10x6_SRGB_BLOCK`  - `VK_FORMAT_ASTC_10x8_UNORM_BLOCK`  -
///   `VK_FORMAT_ASTC_10x8_SRGB_BLOCK`  - `VK_FORMAT_ASTC_10x10_UNORM_BLOCK`  -
///   `VK_FORMAT_ASTC_10x10_SRGB_BLOCK`  - `VK_FORMAT_ASTC_12x10_UNORM_BLOCK`  -
///   `VK_FORMAT_ASTC_12x10_SRGB_BLOCK`  - `VK_FORMAT_ASTC_12x12_UNORM_BLOCK`  -
///   `VK_FORMAT_ASTC_12x12_SRGB_BLOCK` To query for additional properties, or if the feature is not
///   enabled, [`GetPhysicalDeviceFormatProperties`] and [`GetPhysicalDeviceImageFormatProperties`]
///   **can**  be used to check for supported properties of individual formats as normal.
/// - [`texture_compression_bc`] specifies whether all of the BC compressed texture formats are
///   supported. If this feature is enabled, then the `VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT`,
///   `VK_FORMAT_FEATURE_BLIT_SRC_BIT` and `VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT`
///   features  **must**  be supported in `optimalTilingFeatures` for the following formats:  -
///   `VK_FORMAT_BC1_RGB_UNORM_BLOCK`  - `VK_FORMAT_BC1_RGB_SRGB_BLOCK`  -
///   `VK_FORMAT_BC1_RGBA_UNORM_BLOCK`  - `VK_FORMAT_BC1_RGBA_SRGB_BLOCK`  -
///   `VK_FORMAT_BC2_UNORM_BLOCK`  - `VK_FORMAT_BC2_SRGB_BLOCK`  - `VK_FORMAT_BC3_UNORM_BLOCK`  -
///   `VK_FORMAT_BC3_SRGB_BLOCK`  - `VK_FORMAT_BC4_UNORM_BLOCK`  - `VK_FORMAT_BC4_SNORM_BLOCK`  -
///   `VK_FORMAT_BC5_UNORM_BLOCK`  - `VK_FORMAT_BC5_SNORM_BLOCK`  - `VK_FORMAT_BC6H_UFLOAT_BLOCK`  -
///   `VK_FORMAT_BC6H_SFLOAT_BLOCK`  - `VK_FORMAT_BC7_UNORM_BLOCK`  - `VK_FORMAT_BC7_SRGB_BLOCK` To
///   query for additional properties, or if the feature is not enabled,
///   [`GetPhysicalDeviceFormatProperties`] and [`GetPhysicalDeviceImageFormatProperties`] **can**
///   be used to check for supported properties of individual formats as normal.
/// - [`occlusion_query_precise`] specifies whether occlusion queries returning actual sample counts
///   are supported. Occlusion queries are created in a [`QueryPool`] by specifying the `queryType`
///   of `VK_QUERY_TYPE_OCCLUSION` in the [`QueryPoolCreateInfo`] structure which is passed to
///   [`CreateQueryPool`]. If this feature is enabled, queries of this type  **can**  enable
///   `VK_QUERY_CONTROL_PRECISE_BIT` in the `flags` parameter to [`CmdBeginQuery`]. If this feature
///   is not supported, the implementation supports only boolean occlusion queries. When any samples
///   are passed, boolean queries will return a non-zero result value, otherwise a result value of
///   zero is returned. When this feature is enabled and `VK_QUERY_CONTROL_PRECISE_BIT` is set,
///   occlusion queries will report the actual number of samples passed.
/// - [`pipeline_statistics_query`] specifies whether the pipeline statistics queries are supported.
///   If this feature is not enabled, queries of type `VK_QUERY_TYPE_PIPELINE_STATISTICS` **cannot**
///   be created, and none of the [`QueryPipelineStatisticFlagBits`] bits  **can**  be set in the
///   `pipelineStatistics` member of the [`QueryPoolCreateInfo`] structure.
/// - [`vertex_pipeline_stores_and_atomics`] specifies whether storage buffers and images support
///   stores and atomic operations in the vertex, tessellation, and geometry shader stages. If this
///   feature is not enabled, all storage image, storage texel buffer, and storage buffer variables
///   used by these stages in shader modules  **must**  be decorated with the `NonWritable`
///   decoration (or the `readonly` memory qualifier in GLSL).
/// - [`fragment_stores_and_atomics`] specifies whether storage buffers and images support stores
///   and atomic operations in the fragment shader stage. If this feature is not enabled, all
///   storage image, storage texel buffer, and storage buffer variables used by the fragment stage
///   in shader modules  **must**  be decorated with the `NonWritable` decoration (or the `readonly`
///   memory qualifier in GLSL).
/// - [`shader_tessellation_and_geometry_point_size`] specifies whether the `PointSize` built-in decoration is available in the tessellation control, tessellation evaluation, and geometry shader stages. If this feature is not enabled, members decorated with the `PointSize` built-in decoration  **must**  not be read from or written to and all points written from a tessellation or geometry shader will have a size of 1.0. This also specifies whether shader modules  **can**  declare the `TessellationPointSize` capability for tessellation control and evaluation shaders, or if the shader modules  **can**  declare the `GeometryPointSize` capability for geometry shaders. An implementation supporting this feature  **must**  also support one or both of the [[`tessellation_shader`]](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-tessellationShader) or [[`geometry_shader`]](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-geometryShader) features.
/// - [`shader_image_gather_extended`] specifies whether the extended set of image gather
///   instructions are available in shader code. If this feature is not enabled, the
///   `OpImage*Gather` instructions do not support the `Offset` and `ConstOffsets` operands. This
///   also specifies whether shader modules  **can**  declare the `ImageGatherExtended` capability.
/// - [`shader_storage_image_extended_formats`] specifies whether all the “storage image extended
///   formats” below are supported; if this feature is supported, then the
///   `VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT` **must**  be supported in `optimalTilingFeatures` for
///   the following formats:  - `VK_FORMAT_R16G16_SFLOAT`  - `VK_FORMAT_B10G11R11_UFLOAT_PACK32`  -
///   `VK_FORMAT_R16_SFLOAT`  - `VK_FORMAT_R16G16B16A16_UNORM`  -
///   `VK_FORMAT_A2B10G10R10_UNORM_PACK32`  - `VK_FORMAT_R16G16_UNORM`  - `VK_FORMAT_R8G8_UNORM`  -
///   `VK_FORMAT_R16_UNORM`  - `VK_FORMAT_R8_UNORM`  - `VK_FORMAT_R16G16B16A16_SNORM`  -
///   `VK_FORMAT_R16G16_SNORM`  - `VK_FORMAT_R8G8_SNORM`  - `VK_FORMAT_R16_SNORM`  -
///   `VK_FORMAT_R8_SNORM`  - `VK_FORMAT_R16G16_SINT`  - `VK_FORMAT_R8G8_SINT`  -
///   `VK_FORMAT_R16_SINT`  - `VK_FORMAT_R8_SINT`  - `VK_FORMAT_A2B10G10R10_UINT_PACK32`  -
///   `VK_FORMAT_R16G16_UINT`  - `VK_FORMAT_R8G8_UINT`  - `VK_FORMAT_R16_UINT`  -
///   `VK_FORMAT_R8_UINT`
/// - [`shader_storage_image_multisample`] specifies whether multisampled storage images are
///   supported. If this feature is not enabled, images that are created with a `usage` that
///   includes `VK_IMAGE_USAGE_STORAGE_BIT` **must**  be created with `samples` equal to
///   `VK_SAMPLE_COUNT_1_BIT`. This also specifies whether shader modules  **can**  declare the
///   `StorageImageMultisample` and `ImageMSArray` capabilities.
/// - [`shader_storage_image_read_without_format`] specifies whether storage images require a format
///   qualifier to be specified when reading. [`shader_storage_image_read_without_format`] applies only
///   to formats listed in the [storage without format](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#formats-without-shader-storage-format)
///   list.
/// - [`shader_storage_image_write_without_format`] specifies whether storage images require a format qualifier to be specified when writing. [`shader_storage_image_write_without_format`] applies only to formats listed in the [storage without format](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#formats-without-shader-storage-format) list.
/// - [`shader_uniform_buffer_array_dynamic_indexing`] specifies whether arrays of uniform buffers
///   **can**  be indexed by *dynamically uniform* integer expressions in shader code. If this
///   feature is not enabled, resources with a descriptor type of
///   `VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER` or `VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC` **must**
///   be indexed only by constant integral expressions when aggregated into arrays in shader code.
///   This also specifies whether shader modules  **can**  declare the
///   `UniformBufferArrayDynamicIndexing` capability.
/// - [`shader_sampled_image_array_dynamic_indexing`] specifies whether arrays of samplers or
///   sampled images  **can**  be indexed by dynamically uniform integer expressions in shader code.
///   If this feature is not enabled, resources with a descriptor type of
///   `VK_DESCRIPTOR_TYPE_SAMPLER`, `VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER`, or
///   `VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE` **must**  be indexed only by constant integral expressions
///   when aggregated into arrays in shader code. This also specifies whether shader modules
///   **can**  declare the `SampledImageArrayDynamicIndexing` capability.
/// - [`shader_storage_buffer_array_dynamic_indexing`] specifies whether arrays of storage buffers
///   **can**  be indexed by dynamically uniform integer expressions in shader code. If this feature
///   is not enabled, resources with a descriptor type of `VK_DESCRIPTOR_TYPE_STORAGE_BUFFER` or
///   `VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC` **must**  be indexed only by constant integral
///   expressions when aggregated into arrays in shader code. This also specifies whether shader
///   modules  **can**  declare the `StorageBufferArrayDynamicIndexing` capability.
/// - [`shader_storage_image_array_dynamic_indexing`] specifies whether arrays of storage images
///   **can**  be indexed by dynamically uniform integer expressions in shader code. If this feature
///   is not enabled, resources with a descriptor type of `VK_DESCRIPTOR_TYPE_STORAGE_IMAGE`
///   **must**  be indexed only by constant integral expressions when aggregated into arrays in
///   shader code. This also specifies whether shader modules  **can**  declare the
///   `StorageImageArrayDynamicIndexing` capability.
/// - [`shader_clip_distance`] specifies whether clip distances are supported in shader code. If
///   this feature is not enabled, any members decorated with the `ClipDistance` built-in decoration
///   **must**  not be read from or written to in shader modules. This also specifies whether shader
///   modules  **can**  declare the `ClipDistance` capability.
/// - [`shader_cull_distance`] specifies whether cull distances are supported in shader code. If
///   this feature is not enabled, any members decorated with the `CullDistance` built-in decoration
///   **must**  not be read from or written to in shader modules. This also specifies whether shader
///   modules  **can**  declare the `CullDistance` capability.
/// - [`shader_float_64`] specifies whether 64-bit floats (doubles) are supported in shader code. If
///   this feature is not enabled, 64-bit floating-point types  **must**  not be used in shader
///   code. This also specifies whether shader modules  **can**  declare the `Float64` capability.
///   Declaring and using 64-bit floats is enabled for all storage classes that SPIR-V allows with
///   the `Float64` capability.
/// - [`shader_int_64`] specifies whether 64-bit integers (signed and unsigned) are supported in
///   shader code. If this feature is not enabled, 64-bit integer types  **must**  not be used in
///   shader code. This also specifies whether shader modules  **can**  declare the `Int64`
///   capability. Declaring and using 64-bit integers is enabled for all storage classes that SPIR-V
///   allows with the `Int64` capability.
/// - [`shader_int_16`] specifies whether 16-bit integers (signed and unsigned) are supported in
///   shader code. If this feature is not enabled, 16-bit integer types  **must**  not be used in
///   shader code. This also specifies whether shader modules  **can**  declare the `Int16`
///   capability. However, this only enables a subset of the storage classes that SPIR-V allows for
///   the `Int16` SPIR-V capability: Declaring and using 16-bit integers in the `Private`,
///   `Workgroup` (for non-Block variables), and `Function` storage classes is enabled, while
///   declaring them in the interface storage classes (e.g., `UniformConstant`, `Uniform`,
///   `StorageBuffer`, `Input`, `Output`, and `PushConstant`) is not enabled.
/// - [`shader_resource_residency`] specifies whether image operations that return resource
///   residency information are supported in shader code. If this feature is not enabled, the
///   `OpImageSparse*` instructions  **must**  not be used in shader code. This also specifies
///   whether shader modules  **can**  declare the `SparseResidency` capability. The feature
///   requires at least one of the `sparseResidency*` features to be supported.
/// - [`shader_resource_min_lod`] specifies whether image operations specifying the minimum resource
///   LOD are supported in shader code. If this feature is not enabled, the `MinLod` image operand
///   **must**  not be used in shader code. This also specifies whether shader modules  **can**
///   declare the `MinLod` capability.
/// - [`sparse_binding`] specifies whether resource memory  **can**  be managed at opaque sparse block level instead of at the object level. If this feature is not enabled, resource memory  **must**  be bound only on a per-object basis using the [`BindBufferMemory`] and [`BindImageMemory`] commands. In this case, buffers and images  **must**  not be created with `VK_BUFFER_CREATE_SPARSE_BINDING_BIT` and `VK_IMAGE_CREATE_SPARSE_BINDING_BIT` set in the `flags` member of the [`BufferCreateInfo`] and [`ImageCreateInfo`] structures, respectively. Otherwise resource memory  **can**  be managed as described in [Sparse Resource Features](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#sparsememory-sparseresourcefeatures).
/// - [`sparse_residency_buffer`] specifies whether the device  **can**  access partially resident
///   buffers. If this feature is not enabled, buffers  **must**  not be created with
///   `VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT` set in the `flags` member of the [`BufferCreateInfo`]
///   structure.
/// - [`sparse_residency_image_2_d`] specifies whether the device  **can**  access partially
///   resident 2D images with 1 sample per pixel. If this feature is not enabled, images with an
///   `imageType` of `VK_IMAGE_TYPE_2D` and `samples` set to `VK_SAMPLE_COUNT_1_BIT` **must**  not
///   be created with `VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT` set in the `flags` member of the
///   [`ImageCreateInfo`] structure.
/// - [`sparse_residency_image_3_d`] specifies whether the device  **can**  access partially
///   resident 3D images. If this feature is not enabled, images with an `imageType` of
///   `VK_IMAGE_TYPE_3D` **must**  not be created with `VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT` set in
///   the `flags` member of the [`ImageCreateInfo`] structure.
/// - [`sparse_residency_2_samples`] specifies whether the physical device  **can**  access
///   partially resident 2D images with 2 samples per pixel. If this feature is not enabled, images
///   with an `imageType` of `VK_IMAGE_TYPE_2D` and `samples` set to `VK_SAMPLE_COUNT_2_BIT`
///   **must**  not be created with `VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT` set in the `flags` member
///   of the [`ImageCreateInfo`] structure.
/// - [`sparse_residency_4_samples`] specifies whether the physical device  **can**  access
///   partially resident 2D images with 4 samples per pixel. If this feature is not enabled, images
///   with an `imageType` of `VK_IMAGE_TYPE_2D` and `samples` set to `VK_SAMPLE_COUNT_4_BIT`
///   **must**  not be created with `VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT` set in the `flags` member
///   of the [`ImageCreateInfo`] structure.
/// - [`sparse_residency_8_samples`] specifies whether the physical device  **can**  access
///   partially resident 2D images with 8 samples per pixel. If this feature is not enabled, images
///   with an `imageType` of `VK_IMAGE_TYPE_2D` and `samples` set to `VK_SAMPLE_COUNT_8_BIT`
///   **must**  not be created with `VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT` set in the `flags` member
///   of the [`ImageCreateInfo`] structure.
/// - [`sparse_residency_16_samples`] specifies whether the physical device  **can**  access
///   partially resident 2D images with 16 samples per pixel. If this feature is not enabled, images
///   with an `imageType` of `VK_IMAGE_TYPE_2D` and `samples` set to `VK_SAMPLE_COUNT_16_BIT`
///   **must**  not be created with `VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT` set in the `flags` member
///   of the [`ImageCreateInfo`] structure.
/// - [`sparse_residency_aliased`] specifies whether the physical device  **can**  correctly access
///   data aliased into multiple locations. If this feature is not enabled, the
///   `VK_BUFFER_CREATE_SPARSE_ALIASED_BIT` and `VK_IMAGE_CREATE_SPARSE_ALIASED_BIT` enum values
///   **must**  not be used in `flags` members of the [`BufferCreateInfo`] and [`ImageCreateInfo`]
///   structures, respectively.
/// - [`variable_multisample_rate`] specifies whether all pipelines that will be bound to a command buffer during a [subpass which uses no attachments](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-noattachments) **must**  have the same value for [`PipelineMultisampleStateCreateInfo::rasterization_samples`]. If set to [`TRUE`], the implementation supports variable multisample rates in a subpass which uses no attachments. If set to [`FALSE`], then all pipelines bound in such a subpass  **must**  have the same multisample rate. This has no effect in situations where a subpass uses any attachments.
/// - [`inherited_queries`] specifies whether a secondary command buffer  **may**  be executed while
///   a query is active.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`Bool32`]
/// - [`DeviceCreateInfo`]
/// - [`PhysicalDeviceFeatures2`]
/// - [`GetPhysicalDeviceFeatures`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct PhysicalDeviceFeatures {
    ///If [`robust_buffer_access`] is not enabled, applications  **must**  not
    ///perform out of bounds accesses.
    robust_buffer_access: Bool32,
    ///[`full_draw_index_uint_32`] specifies the
    ///full 32-bit range of indices is supported for indexed draw calls when
    ///using a [`IndexType`] of `VK_INDEX_TYPE_UINT32`.
    ///`maxDrawIndexedIndexValue` is the maximum index value that  **may**  be
    ///used (aside from the primitive restart index, which is always 2<sup>32</sup>-1
    ///when the [`IndexType`] is `VK_INDEX_TYPE_UINT32`).
    ///If this feature is supported, `maxDrawIndexedIndexValue` **must**  be
    ///2<sup>32</sup>-1; otherwise it  **must**  be no smaller than 2<sup>24</sup>-1.
    ///See [maxDrawIndexedIndexValue](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#limits-maxDrawIndexedIndexValue).
    full_draw_index_uint_32: Bool32,
    ///[`image_cube_array`] specifies whether image
    ///views with a [`ImageViewType`] of
    ///`VK_IMAGE_VIEW_TYPE_CUBE_ARRAY` **can**  be created, and that the
    ///corresponding `SampledCubeArray` and `ImageCubeArray` SPIR-V
    ///capabilities  **can**  be used in shader code.
    image_cube_array: Bool32,
    ///[`independent_blend`] specifies whether
    ///the [`PipelineColorBlendAttachmentState`] settings are controlled
    ///independently per-attachment.
    ///If this feature is not enabled, the
    ///[`PipelineColorBlendAttachmentState`] settings for all color
    ///attachments  **must**  be identical.
    ///Otherwise, a different [`PipelineColorBlendAttachmentState`] **can**  be
    ///provided for each bound color attachment.
    independent_blend: Bool32,
    ///[`geometry_shader`] specifies whether
    ///geometry shaders are supported.
    ///If this feature is not enabled, the `VK_SHADER_STAGE_GEOMETRY_BIT`
    ///and `VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT` enum values  **must**  not be
    ///used.
    ///This also specifies whether shader modules  **can**  declare the
    ///`Geometry` capability.
    geometry_shader: Bool32,
    ///[`tessellation_shader`] specifies
    ///whether tessellation control and evaluation shaders are supported.
    ///If this feature is not enabled, the
    ///`VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT`,
    ///`VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT`,
    ///`VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT`,
    ///`VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT`, and
    ///`VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO` enum
    ///values  **must**  not be used.
    ///This also specifies whether shader modules  **can**  declare the
    ///`Tessellation` capability.
    tessellation_shader: Bool32,
    ///[`sample_rate_shading`] specifies whether
    ///[Sample Shading](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#primsrast-sampleshading) and multisample interpolation
    ///are supported.
    ///If this feature is not enabled, the `sampleShadingEnable` member of
    ///the [`PipelineMultisampleStateCreateInfo`] structure  **must**  be set to
    ///[`FALSE`] and the `minSampleShading` member is ignored.
    ///This also specifies whether shader modules  **can**  declare the
    ///`SampleRateShading` capability.
    sample_rate_shading: Bool32,
    ///[`dual_src_blend`] specifies whether blend
    ///operations which take two sources are supported.
    ///If this feature is not enabled, the `VK_BLEND_FACTOR_SRC1_COLOR`,
    ///`VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR`,
    ///`VK_BLEND_FACTOR_SRC1_ALPHA`, and
    ///`VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA` enum values  **must**  not be used
    ///as source or destination blending factors.
    ///See [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#framebuffer-dsb](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#framebuffer-dsb).
    dual_src_blend: Bool32,
    ///[`logic_op`] specifies whether logic operations
    ///are supported.
    ///If this feature is not enabled, the `logicOpEnable` member of the
    ///[`PipelineColorBlendStateCreateInfo`] structure  **must**  be set to
    ///[`FALSE`], and the [`logic_op`] member is ignored.
    logic_op: Bool32,
    ///[`multi_draw_indirect`] specifies whether
    ///multiple draw indirect is supported.
    ///If this feature is not enabled, the `drawCount` parameter to the
    ///[`CmdDrawIndirect`] and [`CmdDrawIndexedIndirect`] commands
    /// **must**  be 0 or 1.
    ///The `maxDrawIndirectCount` member of the
    ///[`PhysicalDeviceLimits`] structure  **must**  also be 1 if this feature
    ///is not supported.
    ///See [maxDrawIndirectCount](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#limits-maxDrawIndirectCount).
    multi_draw_indirect: Bool32,
    ///[`draw_indirect_first_instance`]
    ///specifies whether indirect drawing calls support the `firstInstance`
    ///parameter.
    ///If this feature is not enabled, the `firstInstance` member of all
    ///[`DrawIndirectCommand`] and [`DrawIndexedIndirectCommand`]
    ///structures that are provided to the [`CmdDrawIndirect`] and
    ///[`CmdDrawIndexedIndirect`] commands  **must**  be 0.
    draw_indirect_first_instance: Bool32,
    ///[`depth_clamp`] specifies whether depth
    ///clamping is supported.
    ///If this feature is not enabled, the `depthClampEnable` member of the
    ///[`PipelineRasterizationStateCreateInfo`] structure  **must**  be set to
    ///[`FALSE`].
    ///Otherwise, setting `depthClampEnable` to [`TRUE`] will enable
    ///depth clamping.
    depth_clamp: Bool32,
    ///[`depth_bias_clamp`] specifies whether depth
    ///bias clamping is supported.
    ///If this feature is not enabled, the [`depth_bias_clamp`] member of the
    ///[`PipelineRasterizationStateCreateInfo`] structure  **must**  be set to
    ///0.0 unless the `VK_DYNAMIC_STATE_DEPTH_BIAS` dynamic state is
    ///enabled, and the [`depth_bias_clamp`] parameter to
    ///[`CmdSetDepthBias`] **must**  be set to 0.0.
    depth_bias_clamp: Bool32,
    ///[`fill_mode_non_solid`] specifies whether
    ///point and wireframe fill modes are supported.
    ///If this feature is not enabled, the `VK_POLYGON_MODE_POINT` and
    ///`VK_POLYGON_MODE_LINE` enum values  **must**  not be used.
    fill_mode_non_solid: Bool32,
    ///[`depth_bounds`] specifies whether depth
    ///bounds tests are supported.
    ///If this feature is not enabled, the `depthBoundsTestEnable` member
    ///of the [`PipelineDepthStencilStateCreateInfo`] structure  **must**  be
    ///set to [`FALSE`].
    ///When `depthBoundsTestEnable` is set to [`FALSE`], the
    ///`minDepthBounds` and `maxDepthBounds` members of the
    ///[`PipelineDepthStencilStateCreateInfo`] structure are ignored.
    depth_bounds: Bool32,
    ///[`wide_lines`] specifies whether lines with
    ///width other than 1.0 are supported.
    ///If this feature is not enabled, the `lineWidth` member of the
    ///[`PipelineRasterizationStateCreateInfo`] structure  **must**  be set to
    ///1.0 unless the `VK_DYNAMIC_STATE_LINE_WIDTH` dynamic state is
    ///enabled, and the `lineWidth` parameter to [`CmdSetLineWidth`] **must**  be set to 1.0.
    ///When this feature is supported, the range and granularity of supported
    ///line widths are indicated by the `lineWidthRange` and
    ///`lineWidthGranularity` members of the [`PhysicalDeviceLimits`]
    ///structure, respectively.
    wide_lines: Bool32,
    ///[`large_points`] specifies whether points with
    ///size greater than 1.0 are supported.
    ///If this feature is not enabled, only a point size of 1.0 written by a
    ///shader is supported.
    ///The range and granularity of supported point sizes are indicated by the
    ///`pointSizeRange` and `pointSizeGranularity` members of the
    ///[`PhysicalDeviceLimits`] structure, respectively.
    large_points: Bool32,
    ///[`alpha_to_one`] specifies whether the
    ///implementation is able to replace the alpha value of the fragment shader
    ///color output in the [Multisample Coverage](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fragops-covg) fragment
    ///operation.
    ///If this feature is not enabled, then the `alphaToOneEnable` member
    ///of the [`PipelineMultisampleStateCreateInfo`] structure  **must**  be set
    ///to [`FALSE`].
    ///Otherwise setting `alphaToOneEnable` to [`TRUE`] will enable
    ///alpha-to-one behavior.
    alpha_to_one: Bool32,
    ///[`multi_viewport`] specifies whether more
    ///than one viewport is supported.
    ///If this feature is not enabled:
    /// - The `viewportCount` and `scissorCount` members of the [`PipelineViewportStateCreateInfo`]
    ///   structure  **must**  be set to 1.
    /// - The `firstViewport` and `viewportCount` parameters to the [`CmdSetViewport`] command
    ///   **must**  be set to 0 and 1, respectively.
    /// - The `firstScissor` and `scissorCount` parameters to the [`CmdSetScissor`] command
    ///   **must**  be set to 0 and 1, respectively.
    /// - The `exclusiveScissorCount` member of the
    ///   [`PipelineViewportExclusiveScissorStateCreateInfoNV`] structure  **must**  be set to 0 or
    ///   1.
    /// - The `firstExclusiveScissor` and `exclusiveScissorCount` parameters to the
    ///   [`CmdSetExclusiveScissorNV`] command  **must**  be set to 0 and 1, respectively.
    multi_viewport: Bool32,
    ///[`sampler_anisotropy`] specifies whether
    ///anisotropic filtering is supported.
    ///If this feature is not enabled, the `anisotropyEnable` member of the
    ///[`SamplerCreateInfo`] structure  **must**  be [`FALSE`].
    sampler_anisotropy: Bool32,
    ///[`texture_compression_etc_2`]
    ///specifies whether all of the ETC2 and EAC compressed texture formats are
    ///supported.
    ///If this feature is enabled, then the
    ///`VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT`,
    ///`VK_FORMAT_FEATURE_BLIT_SRC_BIT` and
    ///`VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT` features  **must**
    ///be supported in `optimalTilingFeatures` for the following formats:
    /// - `VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK`
    /// - `VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK`
    /// - `VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK`
    /// - `VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK`
    /// - `VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK`
    /// - `VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK`
    /// - `VK_FORMAT_EAC_R11_UNORM_BLOCK`
    /// - `VK_FORMAT_EAC_R11_SNORM_BLOCK`
    /// - `VK_FORMAT_EAC_R11G11_UNORM_BLOCK`
    /// - `VK_FORMAT_EAC_R11G11_SNORM_BLOCK`
    ///To query for additional properties, or if the feature is not enabled,
    ///[`GetPhysicalDeviceFormatProperties`] and
    ///[`GetPhysicalDeviceImageFormatProperties`] **can**  be used to check for
    ///supported properties of individual formats as normal.
    texture_compression_etc_2: Bool32,
    ///[`texture_compression_astc_ldr`]
    ///specifies whether all of the ASTC LDR compressed texture formats are
    ///supported.
    ///If this feature is enabled, then the
    ///`VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT`,
    ///`VK_FORMAT_FEATURE_BLIT_SRC_BIT` and
    ///`VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT` features  **must**
    ///be supported in `optimalTilingFeatures` for the following formats:
    /// - `VK_FORMAT_ASTC_4x4_UNORM_BLOCK`
    /// - `VK_FORMAT_ASTC_4x4_SRGB_BLOCK`
    /// - `VK_FORMAT_ASTC_5x4_UNORM_BLOCK`
    /// - `VK_FORMAT_ASTC_5x4_SRGB_BLOCK`
    /// - `VK_FORMAT_ASTC_5x5_UNORM_BLOCK`
    /// - `VK_FORMAT_ASTC_5x5_SRGB_BLOCK`
    /// - `VK_FORMAT_ASTC_6x5_UNORM_BLOCK`
    /// - `VK_FORMAT_ASTC_6x5_SRGB_BLOCK`
    /// - `VK_FORMAT_ASTC_6x6_UNORM_BLOCK`
    /// - `VK_FORMAT_ASTC_6x6_SRGB_BLOCK`
    /// - `VK_FORMAT_ASTC_8x5_UNORM_BLOCK`
    /// - `VK_FORMAT_ASTC_8x5_SRGB_BLOCK`
    /// - `VK_FORMAT_ASTC_8x6_UNORM_BLOCK`
    /// - `VK_FORMAT_ASTC_8x6_SRGB_BLOCK`
    /// - `VK_FORMAT_ASTC_8x8_UNORM_BLOCK`
    /// - `VK_FORMAT_ASTC_8x8_SRGB_BLOCK`
    /// - `VK_FORMAT_ASTC_10x5_UNORM_BLOCK`
    /// - `VK_FORMAT_ASTC_10x5_SRGB_BLOCK`
    /// - `VK_FORMAT_ASTC_10x6_UNORM_BLOCK`
    /// - `VK_FORMAT_ASTC_10x6_SRGB_BLOCK`
    /// - `VK_FORMAT_ASTC_10x8_UNORM_BLOCK`
    /// - `VK_FORMAT_ASTC_10x8_SRGB_BLOCK`
    /// - `VK_FORMAT_ASTC_10x10_UNORM_BLOCK`
    /// - `VK_FORMAT_ASTC_10x10_SRGB_BLOCK`
    /// - `VK_FORMAT_ASTC_12x10_UNORM_BLOCK`
    /// - `VK_FORMAT_ASTC_12x10_SRGB_BLOCK`
    /// - `VK_FORMAT_ASTC_12x12_UNORM_BLOCK`
    /// - `VK_FORMAT_ASTC_12x12_SRGB_BLOCK`
    ///To query for additional properties, or if the feature is not enabled,
    ///[`GetPhysicalDeviceFormatProperties`] and
    ///[`GetPhysicalDeviceImageFormatProperties`] **can**  be used to check for
    ///supported properties of individual formats as normal.
    texture_compression_astc_ldr: Bool32,
    ///[`texture_compression_bc`] specifies
    ///whether all of the BC compressed texture formats are supported.
    ///If this feature is enabled, then the
    ///`VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT`,
    ///`VK_FORMAT_FEATURE_BLIT_SRC_BIT` and
    ///`VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT` features  **must**
    ///be supported in `optimalTilingFeatures` for the following formats:
    /// - `VK_FORMAT_BC1_RGB_UNORM_BLOCK`
    /// - `VK_FORMAT_BC1_RGB_SRGB_BLOCK`
    /// - `VK_FORMAT_BC1_RGBA_UNORM_BLOCK`
    /// - `VK_FORMAT_BC1_RGBA_SRGB_BLOCK`
    /// - `VK_FORMAT_BC2_UNORM_BLOCK`
    /// - `VK_FORMAT_BC2_SRGB_BLOCK`
    /// - `VK_FORMAT_BC3_UNORM_BLOCK`
    /// - `VK_FORMAT_BC3_SRGB_BLOCK`
    /// - `VK_FORMAT_BC4_UNORM_BLOCK`
    /// - `VK_FORMAT_BC4_SNORM_BLOCK`
    /// - `VK_FORMAT_BC5_UNORM_BLOCK`
    /// - `VK_FORMAT_BC5_SNORM_BLOCK`
    /// - `VK_FORMAT_BC6H_UFLOAT_BLOCK`
    /// - `VK_FORMAT_BC6H_SFLOAT_BLOCK`
    /// - `VK_FORMAT_BC7_UNORM_BLOCK`
    /// - `VK_FORMAT_BC7_SRGB_BLOCK`
    ///To query for additional properties, or if the feature is not enabled,
    ///[`GetPhysicalDeviceFormatProperties`] and
    ///[`GetPhysicalDeviceImageFormatProperties`] **can**  be used to check for
    ///supported properties of individual formats as normal.
    texture_compression_bc: Bool32,
    ///[`occlusion_query_precise`] specifies
    ///whether occlusion queries returning actual sample counts are supported.
    ///Occlusion queries are created in a [`QueryPool`] by specifying the
    ///`queryType` of `VK_QUERY_TYPE_OCCLUSION` in the
    ///[`QueryPoolCreateInfo`] structure which is passed to
    ///[`CreateQueryPool`].
    ///If this feature is enabled, queries of this type  **can**  enable
    ///`VK_QUERY_CONTROL_PRECISE_BIT` in the `flags` parameter to
    ///[`CmdBeginQuery`].
    ///If this feature is not supported, the implementation supports only
    ///boolean occlusion queries.
    ///When any samples are passed, boolean queries will return a non-zero
    ///result value, otherwise a result value of zero is returned.
    ///When this feature is enabled and `VK_QUERY_CONTROL_PRECISE_BIT` is
    ///set, occlusion queries will report the actual number of samples passed.
    occlusion_query_precise: Bool32,
    ///[`pipeline_statistics_query`]
    ///specifies whether the pipeline statistics queries are supported.
    ///If this feature is not enabled, queries of type
    ///`VK_QUERY_TYPE_PIPELINE_STATISTICS` **cannot**  be created, and none of
    ///the [`QueryPipelineStatisticFlagBits`] bits  **can**  be set in the
    ///`pipelineStatistics` member of the [`QueryPoolCreateInfo`]
    ///structure.
    pipeline_statistics_query: Bool32,
    ///[`vertex_pipeline_stores_and_atomics`] specifies whether storage buffers
    ///and images support stores and atomic operations in the vertex,
    ///tessellation, and geometry shader stages.
    ///If this feature is not enabled, all storage image, storage texel buffer,
    ///and storage buffer variables used by these stages in shader modules
    /// **must**  be decorated with the `NonWritable` decoration (or the
    ///`readonly` memory qualifier in GLSL).
    vertex_pipeline_stores_and_atomics: Bool32,
    ///[`fragment_stores_and_atomics`]
    ///specifies whether storage buffers and images support stores and atomic
    ///operations in the fragment shader stage.
    ///If this feature is not enabled, all storage image, storage texel buffer,
    ///and storage buffer variables used by the fragment stage in shader
    ///modules  **must**  be decorated with the `NonWritable` decoration (or the
    ///`readonly` memory qualifier in GLSL).
    fragment_stores_and_atomics: Bool32,
    ///[`shader_tessellation_and_geometry_point_size`] specifies whether the
    ///`PointSize` built-in decoration is available in the tessellation
    ///control, tessellation evaluation, and geometry shader stages.
    ///If this feature is not enabled, members decorated with the
    ///`PointSize` built-in decoration  **must**  not be read from or written to
    ///and all points written from a tessellation or geometry shader will have
    ///a size of 1.0.
    ///This also specifies whether shader modules  **can**  declare the
    ///`TessellationPointSize` capability for tessellation control and
    ///evaluation shaders, or if the shader modules  **can**  declare the
    ///`GeometryPointSize` capability for geometry shaders.
    ///An implementation supporting this feature  **must**  also support one or both
    ///of the [[`tessellation_shader`]](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-tessellationShader) or
    ///[[`geometry_shader`]](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-geometryShader) features.
    shader_tessellation_and_geometry_point_size: Bool32,
    ///[`shader_image_gather_extended`]
    ///specifies whether the extended set of image gather instructions are
    ///available in shader code.
    ///If this feature is not enabled, the `OpImage*Gather` instructions do
    ///not support the `Offset` and `ConstOffsets` operands.
    ///This also specifies whether shader modules  **can**  declare the
    ///`ImageGatherExtended` capability.
    shader_image_gather_extended: Bool32,
    ///[`shader_storage_image_extended_formats`] specifies whether all the
    ///“storage image extended formats” below are supported; if this feature
    ///is supported, then the `VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT` **must**
    ///be supported in `optimalTilingFeatures` for the following formats:
    /// - `VK_FORMAT_R16G16_SFLOAT`
    /// - `VK_FORMAT_B10G11R11_UFLOAT_PACK32`
    /// - `VK_FORMAT_R16_SFLOAT`
    /// - `VK_FORMAT_R16G16B16A16_UNORM`
    /// - `VK_FORMAT_A2B10G10R10_UNORM_PACK32`
    /// - `VK_FORMAT_R16G16_UNORM`
    /// - `VK_FORMAT_R8G8_UNORM`
    /// - `VK_FORMAT_R16_UNORM`
    /// - `VK_FORMAT_R8_UNORM`
    /// - `VK_FORMAT_R16G16B16A16_SNORM`
    /// - `VK_FORMAT_R16G16_SNORM`
    /// - `VK_FORMAT_R8G8_SNORM`
    /// - `VK_FORMAT_R16_SNORM`
    /// - `VK_FORMAT_R8_SNORM`
    /// - `VK_FORMAT_R16G16_SINT`
    /// - `VK_FORMAT_R8G8_SINT`
    /// - `VK_FORMAT_R16_SINT`
    /// - `VK_FORMAT_R8_SINT`
    /// - `VK_FORMAT_A2B10G10R10_UINT_PACK32`
    /// - `VK_FORMAT_R16G16_UINT`
    /// - `VK_FORMAT_R8G8_UINT`
    /// - `VK_FORMAT_R16_UINT`
    /// - `VK_FORMAT_R8_UINT`
    shader_storage_image_extended_formats: Bool32,
    ///[`shader_storage_image_multisample`] specifies whether multisampled
    ///storage images are supported.
    ///If this feature is not enabled, images that are created with a
    ///`usage` that includes `VK_IMAGE_USAGE_STORAGE_BIT` **must**  be
    ///created with `samples` equal to `VK_SAMPLE_COUNT_1_BIT`.
    ///This also specifies whether shader modules  **can**  declare the
    ///`StorageImageMultisample` and `ImageMSArray` capabilities.
    shader_storage_image_multisample: Bool32,
    ///[`shader_storage_image_read_without_format`] specifies whether storage
    ///images require a format qualifier to be specified when reading.
    ///[`shader_storage_image_read_without_format`] applies only to formats listed
    ///in the [storage without format](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#formats-without-shader-storage-format)
    ///list.
    shader_storage_image_read_without_format: Bool32,
    ///[`shader_storage_image_write_without_format`] specifies whether storage
    ///images require a format qualifier to be specified when writing.
    ///[`shader_storage_image_write_without_format`] applies only to formats
    ///listed in the [storage without
    ///format](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#formats-without-shader-storage-format) list.
    shader_storage_image_write_without_format: Bool32,
    ///[`shader_uniform_buffer_array_dynamic_indexing`] specifies whether arrays
    ///of uniform buffers  **can**  be indexed by *dynamically uniform* integer
    ///expressions in shader code.
    ///If this feature is not enabled, resources with a descriptor type of
    ///`VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER` or
    ///`VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC` **must**  be indexed only by
    ///constant integral expressions when aggregated into arrays in shader
    ///code.
    ///This also specifies whether shader modules  **can**  declare the
    ///`UniformBufferArrayDynamicIndexing` capability.
    shader_uniform_buffer_array_dynamic_indexing: Bool32,
    ///[`shader_sampled_image_array_dynamic_indexing`] specifies whether arrays of
    ///samplers or sampled images  **can**  be indexed by dynamically uniform
    ///integer expressions in shader code.
    ///If this feature is not enabled, resources with a descriptor type of
    ///`VK_DESCRIPTOR_TYPE_SAMPLER`,
    ///`VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER`, or
    ///`VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE` **must**  be indexed only by constant
    ///integral expressions when aggregated into arrays in shader code.
    ///This also specifies whether shader modules  **can**  declare the
    ///`SampledImageArrayDynamicIndexing` capability.
    shader_sampled_image_array_dynamic_indexing: Bool32,
    ///[`shader_storage_buffer_array_dynamic_indexing`] specifies whether arrays
    ///of storage buffers  **can**  be indexed by dynamically uniform integer
    ///expressions in shader code.
    ///If this feature is not enabled, resources with a descriptor type of
    ///`VK_DESCRIPTOR_TYPE_STORAGE_BUFFER` or
    ///`VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC` **must**  be indexed only by
    ///constant integral expressions when aggregated into arrays in shader
    ///code.
    ///This also specifies whether shader modules  **can**  declare the
    ///`StorageBufferArrayDynamicIndexing` capability.
    shader_storage_buffer_array_dynamic_indexing: Bool32,
    ///[`shader_storage_image_array_dynamic_indexing`] specifies whether arrays of
    ///storage images  **can**  be indexed by dynamically uniform integer
    ///expressions in shader code.
    ///If this feature is not enabled, resources with a descriptor type of
    ///`VK_DESCRIPTOR_TYPE_STORAGE_IMAGE` **must**  be indexed only by constant
    ///integral expressions when aggregated into arrays in shader code.
    ///This also specifies whether shader modules  **can**  declare the
    ///`StorageImageArrayDynamicIndexing` capability.
    shader_storage_image_array_dynamic_indexing: Bool32,
    ///[`shader_clip_distance`] specifies
    ///whether clip distances are supported in shader code.
    ///If this feature is not enabled, any members decorated with the
    ///`ClipDistance` built-in decoration  **must**  not be read from or written
    ///to in shader modules.
    ///This also specifies whether shader modules  **can**  declare the
    ///`ClipDistance` capability.
    shader_clip_distance: Bool32,
    ///[`shader_cull_distance`] specifies
    ///whether cull distances are supported in shader code.
    ///If this feature is not enabled, any members decorated with the
    ///`CullDistance` built-in decoration  **must**  not be read from or written
    ///to in shader modules.
    ///This also specifies whether shader modules  **can**  declare the
    ///`CullDistance` capability.
    shader_cull_distance: Bool32,
    ///[`shader_float_64`] specifies whether 64-bit
    ///floats (doubles) are supported in shader code.
    ///If this feature is not enabled, 64-bit floating-point types  **must**  not be
    ///used in shader code.
    ///This also specifies whether shader modules  **can**  declare the `Float64`
    ///capability.
    ///Declaring and using 64-bit floats is enabled for all storage classes
    ///that SPIR-V allows with the `Float64` capability.
    shader_float_64: Bool32,
    ///[`shader_int_64`] specifies whether 64-bit
    ///integers (signed and unsigned) are supported in shader code.
    ///If this feature is not enabled, 64-bit integer types  **must**  not be used
    ///in shader code.
    ///This also specifies whether shader modules  **can**  declare the `Int64`
    ///capability.
    ///Declaring and using 64-bit integers is enabled for all storage classes
    ///that SPIR-V allows with the `Int64` capability.
    shader_int_64: Bool32,
    ///[`shader_int_16`] specifies whether 16-bit
    ///integers (signed and unsigned) are supported in shader code.
    ///If this feature is not enabled, 16-bit integer types  **must**  not be used
    ///in shader code.
    ///This also specifies whether shader modules  **can**  declare the `Int16`
    ///capability.
    ///However, this only enables a subset of the storage classes that SPIR-V
    ///allows for the `Int16` SPIR-V capability: Declaring and using 16-bit
    ///integers in the `Private`,
    ///`Workgroup` (for non-Block variables),
    ///and `Function` storage classes is enabled, while declaring them in
    ///the interface storage classes (e.g., `UniformConstant`, `Uniform`,
    ///`StorageBuffer`, `Input`, `Output`, and `PushConstant`) is
    ///not enabled.
    shader_int_16: Bool32,
    ///[`shader_resource_residency`]
    ///specifies whether image operations that return resource residency
    ///information are supported in shader code.
    ///If this feature is not enabled, the `OpImageSparse*` instructions
    /// **must**  not be used in shader code.
    ///This also specifies whether shader modules  **can**  declare the
    ///`SparseResidency` capability.
    ///The feature requires at least one of the `sparseResidency*` features
    ///to be supported.
    shader_resource_residency: Bool32,
    ///[`shader_resource_min_lod`] specifies
    ///whether image operations specifying the minimum resource LOD are
    ///supported in shader code.
    ///If this feature is not enabled, the `MinLod` image operand  **must**  not
    ///be used in shader code.
    ///This also specifies whether shader modules  **can**  declare the `MinLod`
    ///capability.
    shader_resource_min_lod: Bool32,
    ///[`sparse_binding`] specifies whether
    ///resource memory  **can**  be managed at opaque sparse block level instead of
    ///at the object level.
    ///If this feature is not enabled, resource memory  **must**  be bound only on a
    ///per-object basis using the [`BindBufferMemory`] and
    ///[`BindImageMemory`] commands.
    ///In this case, buffers and images  **must**  not be created with
    ///`VK_BUFFER_CREATE_SPARSE_BINDING_BIT` and
    ///`VK_IMAGE_CREATE_SPARSE_BINDING_BIT` set in the `flags` member
    ///of the [`BufferCreateInfo`] and [`ImageCreateInfo`] structures,
    ///respectively.
    ///Otherwise resource memory  **can**  be managed as described in
    ///[Sparse Resource Features](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#sparsememory-sparseresourcefeatures).
    sparse_binding: Bool32,
    ///[`sparse_residency_buffer`] specifies
    ///whether the device  **can**  access partially resident buffers.
    ///If this feature is not enabled, buffers  **must**  not be created with
    ///`VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT` set in the `flags`
    ///member of the [`BufferCreateInfo`] structure.
    sparse_residency_buffer: Bool32,
    ///[`sparse_residency_image_2_d`]
    ///specifies whether the device  **can**  access partially resident 2D images
    ///with 1 sample per pixel.
    ///If this feature is not enabled, images with an `imageType` of
    ///`VK_IMAGE_TYPE_2D` and `samples` set to
    ///`VK_SAMPLE_COUNT_1_BIT` **must**  not be created with
    ///`VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT` set in the `flags` member
    ///of the [`ImageCreateInfo`] structure.
    sparse_residency_image_2_d: Bool32,
    ///[`sparse_residency_image_3_d`]
    ///specifies whether the device  **can**  access partially resident 3D images.
    ///If this feature is not enabled, images with an `imageType` of
    ///`VK_IMAGE_TYPE_3D` **must**  not be created with
    ///`VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT` set in the `flags` member
    ///of the [`ImageCreateInfo`] structure.
    sparse_residency_image_3_d: Bool32,
    ///[`sparse_residency_2_samples`]
    ///specifies whether the physical device  **can**  access partially resident 2D
    ///images with 2 samples per pixel.
    ///If this feature is not enabled, images with an `imageType` of
    ///`VK_IMAGE_TYPE_2D` and `samples` set to
    ///`VK_SAMPLE_COUNT_2_BIT` **must**  not be created with
    ///`VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT` set in the `flags` member
    ///of the [`ImageCreateInfo`] structure.
    sparse_residency_2_samples: Bool32,
    ///[`sparse_residency_4_samples`]
    ///specifies whether the physical device  **can**  access partially resident 2D
    ///images with 4 samples per pixel.
    ///If this feature is not enabled, images with an `imageType` of
    ///`VK_IMAGE_TYPE_2D` and `samples` set to
    ///`VK_SAMPLE_COUNT_4_BIT` **must**  not be created with
    ///`VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT` set in the `flags` member
    ///of the [`ImageCreateInfo`] structure.
    sparse_residency_4_samples: Bool32,
    ///[`sparse_residency_8_samples`]
    ///specifies whether the physical device  **can**  access partially resident 2D
    ///images with 8 samples per pixel.
    ///If this feature is not enabled, images with an `imageType` of
    ///`VK_IMAGE_TYPE_2D` and `samples` set to
    ///`VK_SAMPLE_COUNT_8_BIT` **must**  not be created with
    ///`VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT` set in the `flags` member
    ///of the [`ImageCreateInfo`] structure.
    sparse_residency_8_samples: Bool32,
    ///[`sparse_residency_16_samples`]
    ///specifies whether the physical device  **can**  access partially resident 2D
    ///images with 16 samples per pixel.
    ///If this feature is not enabled, images with an `imageType` of
    ///`VK_IMAGE_TYPE_2D` and `samples` set to
    ///`VK_SAMPLE_COUNT_16_BIT` **must**  not be created with
    ///`VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT` set in the `flags` member
    ///of the [`ImageCreateInfo`] structure.
    sparse_residency_16_samples: Bool32,
    ///[`sparse_residency_aliased`]
    ///specifies whether the physical device  **can**  correctly access data aliased
    ///into multiple locations.
    ///If this feature is not enabled, the
    ///`VK_BUFFER_CREATE_SPARSE_ALIASED_BIT` and
    ///`VK_IMAGE_CREATE_SPARSE_ALIASED_BIT` enum values  **must**  not be used
    ///in `flags` members of the [`BufferCreateInfo`] and
    ///[`ImageCreateInfo`] structures, respectively.
    sparse_residency_aliased: Bool32,
    ///[`variable_multisample_rate`]
    ///specifies whether all pipelines that will be bound to a command buffer
    ///during a [subpass which uses no attachments](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-noattachments) **must**  have the same value for
    ///[`PipelineMultisampleStateCreateInfo`]::`rasterizationSamples`.
    ///If set to [`TRUE`], the implementation supports variable
    ///multisample rates in a subpass which uses no attachments.
    ///If set to [`FALSE`], then all pipelines bound in such a subpass
    /// **must**  have the same multisample rate.
    ///This has no effect in situations where a subpass uses any attachments.
    variable_multisample_rate: Bool32,
    ///[`inherited_queries`] specifies whether a
    ///secondary command buffer  **may**  be executed while a query is active.
    inherited_queries: Bool32,
}
impl Default for PhysicalDeviceFeatures {
    fn default() -> Self {
        Self {
            robust_buffer_access: 0,
            full_draw_index_uint_32: 0,
            image_cube_array: 0,
            independent_blend: 0,
            geometry_shader: 0,
            tessellation_shader: 0,
            sample_rate_shading: 0,
            dual_src_blend: 0,
            logic_op: 0,
            multi_draw_indirect: 0,
            draw_indirect_first_instance: 0,
            depth_clamp: 0,
            depth_bias_clamp: 0,
            fill_mode_non_solid: 0,
            depth_bounds: 0,
            wide_lines: 0,
            large_points: 0,
            alpha_to_one: 0,
            multi_viewport: 0,
            sampler_anisotropy: 0,
            texture_compression_etc_2: 0,
            texture_compression_astc_ldr: 0,
            texture_compression_bc: 0,
            occlusion_query_precise: 0,
            pipeline_statistics_query: 0,
            vertex_pipeline_stores_and_atomics: 0,
            fragment_stores_and_atomics: 0,
            shader_tessellation_and_geometry_point_size: 0,
            shader_image_gather_extended: 0,
            shader_storage_image_extended_formats: 0,
            shader_storage_image_multisample: 0,
            shader_storage_image_read_without_format: 0,
            shader_storage_image_write_without_format: 0,
            shader_uniform_buffer_array_dynamic_indexing: 0,
            shader_sampled_image_array_dynamic_indexing: 0,
            shader_storage_buffer_array_dynamic_indexing: 0,
            shader_storage_image_array_dynamic_indexing: 0,
            shader_clip_distance: 0,
            shader_cull_distance: 0,
            shader_float_64: 0,
            shader_int_64: 0,
            shader_int_16: 0,
            shader_resource_residency: 0,
            shader_resource_min_lod: 0,
            sparse_binding: 0,
            sparse_residency_buffer: 0,
            sparse_residency_image_2_d: 0,
            sparse_residency_image_3_d: 0,
            sparse_residency_2_samples: 0,
            sparse_residency_4_samples: 0,
            sparse_residency_8_samples: 0,
            sparse_residency_16_samples: 0,
            sparse_residency_aliased: 0,
            variable_multisample_rate: 0,
            inherited_queries: 0,
        }
    }
}
impl PhysicalDeviceFeatures {
    ///Gets the raw value of [`Self::robust_buffer_access`]
    pub fn robust_buffer_access_raw(&self) -> Bool32 {
        self.robust_buffer_access
    }
    ///Gets the raw value of [`Self::full_draw_index_uint_32`]
    pub fn full_draw_index_uint_32_raw(&self) -> Bool32 {
        self.full_draw_index_uint_32
    }
    ///Gets the raw value of [`Self::image_cube_array`]
    pub fn image_cube_array_raw(&self) -> Bool32 {
        self.image_cube_array
    }
    ///Gets the raw value of [`Self::independent_blend`]
    pub fn independent_blend_raw(&self) -> Bool32 {
        self.independent_blend
    }
    ///Gets the raw value of [`Self::geometry_shader`]
    pub fn geometry_shader_raw(&self) -> Bool32 {
        self.geometry_shader
    }
    ///Gets the raw value of [`Self::tessellation_shader`]
    pub fn tessellation_shader_raw(&self) -> Bool32 {
        self.tessellation_shader
    }
    ///Gets the raw value of [`Self::sample_rate_shading`]
    pub fn sample_rate_shading_raw(&self) -> Bool32 {
        self.sample_rate_shading
    }
    ///Gets the raw value of [`Self::dual_src_blend`]
    pub fn dual_src_blend_raw(&self) -> Bool32 {
        self.dual_src_blend
    }
    ///Gets the raw value of [`Self::logic_op`]
    pub fn logic_op_raw(&self) -> Bool32 {
        self.logic_op
    }
    ///Gets the raw value of [`Self::multi_draw_indirect`]
    pub fn multi_draw_indirect_raw(&self) -> Bool32 {
        self.multi_draw_indirect
    }
    ///Gets the raw value of [`Self::draw_indirect_first_instance`]
    pub fn draw_indirect_first_instance_raw(&self) -> Bool32 {
        self.draw_indirect_first_instance
    }
    ///Gets the raw value of [`Self::depth_clamp`]
    pub fn depth_clamp_raw(&self) -> Bool32 {
        self.depth_clamp
    }
    ///Gets the raw value of [`Self::depth_bias_clamp`]
    pub fn depth_bias_clamp_raw(&self) -> Bool32 {
        self.depth_bias_clamp
    }
    ///Gets the raw value of [`Self::fill_mode_non_solid`]
    pub fn fill_mode_non_solid_raw(&self) -> Bool32 {
        self.fill_mode_non_solid
    }
    ///Gets the raw value of [`Self::depth_bounds`]
    pub fn depth_bounds_raw(&self) -> Bool32 {
        self.depth_bounds
    }
    ///Gets the raw value of [`Self::wide_lines`]
    pub fn wide_lines_raw(&self) -> Bool32 {
        self.wide_lines
    }
    ///Gets the raw value of [`Self::large_points`]
    pub fn large_points_raw(&self) -> Bool32 {
        self.large_points
    }
    ///Gets the raw value of [`Self::alpha_to_one`]
    pub fn alpha_to_one_raw(&self) -> Bool32 {
        self.alpha_to_one
    }
    ///Gets the raw value of [`Self::multi_viewport`]
    pub fn multi_viewport_raw(&self) -> Bool32 {
        self.multi_viewport
    }
    ///Gets the raw value of [`Self::sampler_anisotropy`]
    pub fn sampler_anisotropy_raw(&self) -> Bool32 {
        self.sampler_anisotropy
    }
    ///Gets the raw value of [`Self::texture_compression_etc_2`]
    pub fn texture_compression_etc_2_raw(&self) -> Bool32 {
        self.texture_compression_etc_2
    }
    ///Gets the raw value of [`Self::texture_compression_astc_ldr`]
    pub fn texture_compression_astc_ldr_raw(&self) -> Bool32 {
        self.texture_compression_astc_ldr
    }
    ///Gets the raw value of [`Self::texture_compression_bc`]
    pub fn texture_compression_bc_raw(&self) -> Bool32 {
        self.texture_compression_bc
    }
    ///Gets the raw value of [`Self::occlusion_query_precise`]
    pub fn occlusion_query_precise_raw(&self) -> Bool32 {
        self.occlusion_query_precise
    }
    ///Gets the raw value of [`Self::pipeline_statistics_query`]
    pub fn pipeline_statistics_query_raw(&self) -> Bool32 {
        self.pipeline_statistics_query
    }
    ///Gets the raw value of [`Self::vertex_pipeline_stores_and_atomics`]
    pub fn vertex_pipeline_stores_and_atomics_raw(&self) -> Bool32 {
        self.vertex_pipeline_stores_and_atomics
    }
    ///Gets the raw value of [`Self::fragment_stores_and_atomics`]
    pub fn fragment_stores_and_atomics_raw(&self) -> Bool32 {
        self.fragment_stores_and_atomics
    }
    ///Gets the raw value of [`Self::shader_tessellation_and_geometry_point_size`]
    pub fn shader_tessellation_and_geometry_point_size_raw(&self) -> Bool32 {
        self.shader_tessellation_and_geometry_point_size
    }
    ///Gets the raw value of [`Self::shader_image_gather_extended`]
    pub fn shader_image_gather_extended_raw(&self) -> Bool32 {
        self.shader_image_gather_extended
    }
    ///Gets the raw value of [`Self::shader_storage_image_extended_formats`]
    pub fn shader_storage_image_extended_formats_raw(&self) -> Bool32 {
        self.shader_storage_image_extended_formats
    }
    ///Gets the raw value of [`Self::shader_storage_image_multisample`]
    pub fn shader_storage_image_multisample_raw(&self) -> Bool32 {
        self.shader_storage_image_multisample
    }
    ///Gets the raw value of [`Self::shader_storage_image_read_without_format`]
    pub fn shader_storage_image_read_without_format_raw(&self) -> Bool32 {
        self.shader_storage_image_read_without_format
    }
    ///Gets the raw value of [`Self::shader_storage_image_write_without_format`]
    pub fn shader_storage_image_write_without_format_raw(&self) -> Bool32 {
        self.shader_storage_image_write_without_format
    }
    ///Gets the raw value of [`Self::shader_uniform_buffer_array_dynamic_indexing`]
    pub fn shader_uniform_buffer_array_dynamic_indexing_raw(&self) -> Bool32 {
        self.shader_uniform_buffer_array_dynamic_indexing
    }
    ///Gets the raw value of [`Self::shader_sampled_image_array_dynamic_indexing`]
    pub fn shader_sampled_image_array_dynamic_indexing_raw(&self) -> Bool32 {
        self.shader_sampled_image_array_dynamic_indexing
    }
    ///Gets the raw value of [`Self::shader_storage_buffer_array_dynamic_indexing`]
    pub fn shader_storage_buffer_array_dynamic_indexing_raw(&self) -> Bool32 {
        self.shader_storage_buffer_array_dynamic_indexing
    }
    ///Gets the raw value of [`Self::shader_storage_image_array_dynamic_indexing`]
    pub fn shader_storage_image_array_dynamic_indexing_raw(&self) -> Bool32 {
        self.shader_storage_image_array_dynamic_indexing
    }
    ///Gets the raw value of [`Self::shader_clip_distance`]
    pub fn shader_clip_distance_raw(&self) -> Bool32 {
        self.shader_clip_distance
    }
    ///Gets the raw value of [`Self::shader_cull_distance`]
    pub fn shader_cull_distance_raw(&self) -> Bool32 {
        self.shader_cull_distance
    }
    ///Gets the raw value of [`Self::shader_float_64`]
    pub fn shader_float_64_raw(&self) -> Bool32 {
        self.shader_float_64
    }
    ///Gets the raw value of [`Self::shader_int_64`]
    pub fn shader_int_64_raw(&self) -> Bool32 {
        self.shader_int_64
    }
    ///Gets the raw value of [`Self::shader_int_16`]
    pub fn shader_int_16_raw(&self) -> Bool32 {
        self.shader_int_16
    }
    ///Gets the raw value of [`Self::shader_resource_residency`]
    pub fn shader_resource_residency_raw(&self) -> Bool32 {
        self.shader_resource_residency
    }
    ///Gets the raw value of [`Self::shader_resource_min_lod`]
    pub fn shader_resource_min_lod_raw(&self) -> Bool32 {
        self.shader_resource_min_lod
    }
    ///Gets the raw value of [`Self::sparse_binding`]
    pub fn sparse_binding_raw(&self) -> Bool32 {
        self.sparse_binding
    }
    ///Gets the raw value of [`Self::sparse_residency_buffer`]
    pub fn sparse_residency_buffer_raw(&self) -> Bool32 {
        self.sparse_residency_buffer
    }
    ///Gets the raw value of [`Self::sparse_residency_image_2_d`]
    pub fn sparse_residency_image_2_d_raw(&self) -> Bool32 {
        self.sparse_residency_image_2_d
    }
    ///Gets the raw value of [`Self::sparse_residency_image_3_d`]
    pub fn sparse_residency_image_3_d_raw(&self) -> Bool32 {
        self.sparse_residency_image_3_d
    }
    ///Gets the raw value of [`Self::sparse_residency_2_samples`]
    pub fn sparse_residency_2_samples_raw(&self) -> Bool32 {
        self.sparse_residency_2_samples
    }
    ///Gets the raw value of [`Self::sparse_residency_4_samples`]
    pub fn sparse_residency_4_samples_raw(&self) -> Bool32 {
        self.sparse_residency_4_samples
    }
    ///Gets the raw value of [`Self::sparse_residency_8_samples`]
    pub fn sparse_residency_8_samples_raw(&self) -> Bool32 {
        self.sparse_residency_8_samples
    }
    ///Gets the raw value of [`Self::sparse_residency_16_samples`]
    pub fn sparse_residency_16_samples_raw(&self) -> Bool32 {
        self.sparse_residency_16_samples
    }
    ///Gets the raw value of [`Self::sparse_residency_aliased`]
    pub fn sparse_residency_aliased_raw(&self) -> Bool32 {
        self.sparse_residency_aliased
    }
    ///Gets the raw value of [`Self::variable_multisample_rate`]
    pub fn variable_multisample_rate_raw(&self) -> Bool32 {
        self.variable_multisample_rate
    }
    ///Gets the raw value of [`Self::inherited_queries`]
    pub fn inherited_queries_raw(&self) -> Bool32 {
        self.inherited_queries
    }
    ///Sets the raw value of [`Self::robust_buffer_access`]
    pub fn set_robust_buffer_access_raw(&mut self, value: Bool32) -> &mut Self {
        self.robust_buffer_access = value;
        self
    }
    ///Sets the raw value of [`Self::full_draw_index_uint_32`]
    pub fn set_full_draw_index_uint_32_raw(&mut self, value: Bool32) -> &mut Self {
        self.full_draw_index_uint_32 = value;
        self
    }
    ///Sets the raw value of [`Self::image_cube_array`]
    pub fn set_image_cube_array_raw(&mut self, value: Bool32) -> &mut Self {
        self.image_cube_array = value;
        self
    }
    ///Sets the raw value of [`Self::independent_blend`]
    pub fn set_independent_blend_raw(&mut self, value: Bool32) -> &mut Self {
        self.independent_blend = value;
        self
    }
    ///Sets the raw value of [`Self::geometry_shader`]
    pub fn set_geometry_shader_raw(&mut self, value: Bool32) -> &mut Self {
        self.geometry_shader = value;
        self
    }
    ///Sets the raw value of [`Self::tessellation_shader`]
    pub fn set_tessellation_shader_raw(&mut self, value: Bool32) -> &mut Self {
        self.tessellation_shader = value;
        self
    }
    ///Sets the raw value of [`Self::sample_rate_shading`]
    pub fn set_sample_rate_shading_raw(&mut self, value: Bool32) -> &mut Self {
        self.sample_rate_shading = value;
        self
    }
    ///Sets the raw value of [`Self::dual_src_blend`]
    pub fn set_dual_src_blend_raw(&mut self, value: Bool32) -> &mut Self {
        self.dual_src_blend = value;
        self
    }
    ///Sets the raw value of [`Self::logic_op`]
    pub fn set_logic_op_raw(&mut self, value: Bool32) -> &mut Self {
        self.logic_op = value;
        self
    }
    ///Sets the raw value of [`Self::multi_draw_indirect`]
    pub fn set_multi_draw_indirect_raw(&mut self, value: Bool32) -> &mut Self {
        self.multi_draw_indirect = value;
        self
    }
    ///Sets the raw value of [`Self::draw_indirect_first_instance`]
    pub fn set_draw_indirect_first_instance_raw(&mut self, value: Bool32) -> &mut Self {
        self.draw_indirect_first_instance = value;
        self
    }
    ///Sets the raw value of [`Self::depth_clamp`]
    pub fn set_depth_clamp_raw(&mut self, value: Bool32) -> &mut Self {
        self.depth_clamp = value;
        self
    }
    ///Sets the raw value of [`Self::depth_bias_clamp`]
    pub fn set_depth_bias_clamp_raw(&mut self, value: Bool32) -> &mut Self {
        self.depth_bias_clamp = value;
        self
    }
    ///Sets the raw value of [`Self::fill_mode_non_solid`]
    pub fn set_fill_mode_non_solid_raw(&mut self, value: Bool32) -> &mut Self {
        self.fill_mode_non_solid = value;
        self
    }
    ///Sets the raw value of [`Self::depth_bounds`]
    pub fn set_depth_bounds_raw(&mut self, value: Bool32) -> &mut Self {
        self.depth_bounds = value;
        self
    }
    ///Sets the raw value of [`Self::wide_lines`]
    pub fn set_wide_lines_raw(&mut self, value: Bool32) -> &mut Self {
        self.wide_lines = value;
        self
    }
    ///Sets the raw value of [`Self::large_points`]
    pub fn set_large_points_raw(&mut self, value: Bool32) -> &mut Self {
        self.large_points = value;
        self
    }
    ///Sets the raw value of [`Self::alpha_to_one`]
    pub fn set_alpha_to_one_raw(&mut self, value: Bool32) -> &mut Self {
        self.alpha_to_one = value;
        self
    }
    ///Sets the raw value of [`Self::multi_viewport`]
    pub fn set_multi_viewport_raw(&mut self, value: Bool32) -> &mut Self {
        self.multi_viewport = value;
        self
    }
    ///Sets the raw value of [`Self::sampler_anisotropy`]
    pub fn set_sampler_anisotropy_raw(&mut self, value: Bool32) -> &mut Self {
        self.sampler_anisotropy = value;
        self
    }
    ///Sets the raw value of [`Self::texture_compression_etc_2`]
    pub fn set_texture_compression_etc_2_raw(&mut self, value: Bool32) -> &mut Self {
        self.texture_compression_etc_2 = value;
        self
    }
    ///Sets the raw value of [`Self::texture_compression_astc_ldr`]
    pub fn set_texture_compression_astc_ldr_raw(&mut self, value: Bool32) -> &mut Self {
        self.texture_compression_astc_ldr = value;
        self
    }
    ///Sets the raw value of [`Self::texture_compression_bc`]
    pub fn set_texture_compression_bc_raw(&mut self, value: Bool32) -> &mut Self {
        self.texture_compression_bc = value;
        self
    }
    ///Sets the raw value of [`Self::occlusion_query_precise`]
    pub fn set_occlusion_query_precise_raw(&mut self, value: Bool32) -> &mut Self {
        self.occlusion_query_precise = value;
        self
    }
    ///Sets the raw value of [`Self::pipeline_statistics_query`]
    pub fn set_pipeline_statistics_query_raw(&mut self, value: Bool32) -> &mut Self {
        self.pipeline_statistics_query = value;
        self
    }
    ///Sets the raw value of [`Self::vertex_pipeline_stores_and_atomics`]
    pub fn set_vertex_pipeline_stores_and_atomics_raw(&mut self, value: Bool32) -> &mut Self {
        self.vertex_pipeline_stores_and_atomics = value;
        self
    }
    ///Sets the raw value of [`Self::fragment_stores_and_atomics`]
    pub fn set_fragment_stores_and_atomics_raw(&mut self, value: Bool32) -> &mut Self {
        self.fragment_stores_and_atomics = value;
        self
    }
    ///Sets the raw value of [`Self::shader_tessellation_and_geometry_point_size`]
    pub fn set_shader_tessellation_and_geometry_point_size_raw(&mut self, value: Bool32) -> &mut Self {
        self.shader_tessellation_and_geometry_point_size = value;
        self
    }
    ///Sets the raw value of [`Self::shader_image_gather_extended`]
    pub fn set_shader_image_gather_extended_raw(&mut self, value: Bool32) -> &mut Self {
        self.shader_image_gather_extended = value;
        self
    }
    ///Sets the raw value of [`Self::shader_storage_image_extended_formats`]
    pub fn set_shader_storage_image_extended_formats_raw(&mut self, value: Bool32) -> &mut Self {
        self.shader_storage_image_extended_formats = value;
        self
    }
    ///Sets the raw value of [`Self::shader_storage_image_multisample`]
    pub fn set_shader_storage_image_multisample_raw(&mut self, value: Bool32) -> &mut Self {
        self.shader_storage_image_multisample = value;
        self
    }
    ///Sets the raw value of [`Self::shader_storage_image_read_without_format`]
    pub fn set_shader_storage_image_read_without_format_raw(&mut self, value: Bool32) -> &mut Self {
        self.shader_storage_image_read_without_format = value;
        self
    }
    ///Sets the raw value of [`Self::shader_storage_image_write_without_format`]
    pub fn set_shader_storage_image_write_without_format_raw(&mut self, value: Bool32) -> &mut Self {
        self.shader_storage_image_write_without_format = value;
        self
    }
    ///Sets the raw value of [`Self::shader_uniform_buffer_array_dynamic_indexing`]
    pub fn set_shader_uniform_buffer_array_dynamic_indexing_raw(&mut self, value: Bool32) -> &mut Self {
        self.shader_uniform_buffer_array_dynamic_indexing = value;
        self
    }
    ///Sets the raw value of [`Self::shader_sampled_image_array_dynamic_indexing`]
    pub fn set_shader_sampled_image_array_dynamic_indexing_raw(&mut self, value: Bool32) -> &mut Self {
        self.shader_sampled_image_array_dynamic_indexing = value;
        self
    }
    ///Sets the raw value of [`Self::shader_storage_buffer_array_dynamic_indexing`]
    pub fn set_shader_storage_buffer_array_dynamic_indexing_raw(&mut self, value: Bool32) -> &mut Self {
        self.shader_storage_buffer_array_dynamic_indexing = value;
        self
    }
    ///Sets the raw value of [`Self::shader_storage_image_array_dynamic_indexing`]
    pub fn set_shader_storage_image_array_dynamic_indexing_raw(&mut self, value: Bool32) -> &mut Self {
        self.shader_storage_image_array_dynamic_indexing = value;
        self
    }
    ///Sets the raw value of [`Self::shader_clip_distance`]
    pub fn set_shader_clip_distance_raw(&mut self, value: Bool32) -> &mut Self {
        self.shader_clip_distance = value;
        self
    }
    ///Sets the raw value of [`Self::shader_cull_distance`]
    pub fn set_shader_cull_distance_raw(&mut self, value: Bool32) -> &mut Self {
        self.shader_cull_distance = value;
        self
    }
    ///Sets the raw value of [`Self::shader_float_64`]
    pub fn set_shader_float_64_raw(&mut self, value: Bool32) -> &mut Self {
        self.shader_float_64 = value;
        self
    }
    ///Sets the raw value of [`Self::shader_int_64`]
    pub fn set_shader_int_64_raw(&mut self, value: Bool32) -> &mut Self {
        self.shader_int_64 = value;
        self
    }
    ///Sets the raw value of [`Self::shader_int_16`]
    pub fn set_shader_int_16_raw(&mut self, value: Bool32) -> &mut Self {
        self.shader_int_16 = value;
        self
    }
    ///Sets the raw value of [`Self::shader_resource_residency`]
    pub fn set_shader_resource_residency_raw(&mut self, value: Bool32) -> &mut Self {
        self.shader_resource_residency = value;
        self
    }
    ///Sets the raw value of [`Self::shader_resource_min_lod`]
    pub fn set_shader_resource_min_lod_raw(&mut self, value: Bool32) -> &mut Self {
        self.shader_resource_min_lod = value;
        self
    }
    ///Sets the raw value of [`Self::sparse_binding`]
    pub fn set_sparse_binding_raw(&mut self, value: Bool32) -> &mut Self {
        self.sparse_binding = value;
        self
    }
    ///Sets the raw value of [`Self::sparse_residency_buffer`]
    pub fn set_sparse_residency_buffer_raw(&mut self, value: Bool32) -> &mut Self {
        self.sparse_residency_buffer = value;
        self
    }
    ///Sets the raw value of [`Self::sparse_residency_image_2_d`]
    pub fn set_sparse_residency_image_2_d_raw(&mut self, value: Bool32) -> &mut Self {
        self.sparse_residency_image_2_d = value;
        self
    }
    ///Sets the raw value of [`Self::sparse_residency_image_3_d`]
    pub fn set_sparse_residency_image_3_d_raw(&mut self, value: Bool32) -> &mut Self {
        self.sparse_residency_image_3_d = value;
        self
    }
    ///Sets the raw value of [`Self::sparse_residency_2_samples`]
    pub fn set_sparse_residency_2_samples_raw(&mut self, value: Bool32) -> &mut Self {
        self.sparse_residency_2_samples = value;
        self
    }
    ///Sets the raw value of [`Self::sparse_residency_4_samples`]
    pub fn set_sparse_residency_4_samples_raw(&mut self, value: Bool32) -> &mut Self {
        self.sparse_residency_4_samples = value;
        self
    }
    ///Sets the raw value of [`Self::sparse_residency_8_samples`]
    pub fn set_sparse_residency_8_samples_raw(&mut self, value: Bool32) -> &mut Self {
        self.sparse_residency_8_samples = value;
        self
    }
    ///Sets the raw value of [`Self::sparse_residency_16_samples`]
    pub fn set_sparse_residency_16_samples_raw(&mut self, value: Bool32) -> &mut Self {
        self.sparse_residency_16_samples = value;
        self
    }
    ///Sets the raw value of [`Self::sparse_residency_aliased`]
    pub fn set_sparse_residency_aliased_raw(&mut self, value: Bool32) -> &mut Self {
        self.sparse_residency_aliased = value;
        self
    }
    ///Sets the raw value of [`Self::variable_multisample_rate`]
    pub fn set_variable_multisample_rate_raw(&mut self, value: Bool32) -> &mut Self {
        self.variable_multisample_rate = value;
        self
    }
    ///Sets the raw value of [`Self::inherited_queries`]
    pub fn set_inherited_queries_raw(&mut self, value: Bool32) -> &mut Self {
        self.inherited_queries = value;
        self
    }
    ///Gets the value of [`Self::robust_buffer_access`]
    pub fn robust_buffer_access(&self) -> bool {
        unsafe { std::mem::transmute(self.robust_buffer_access as u8) }
    }
    ///Gets the value of [`Self::full_draw_index_uint_32`]
    pub fn full_draw_index_uint_32(&self) -> bool {
        unsafe { std::mem::transmute(self.full_draw_index_uint_32 as u8) }
    }
    ///Gets the value of [`Self::image_cube_array`]
    pub fn image_cube_array(&self) -> bool {
        unsafe { std::mem::transmute(self.image_cube_array as u8) }
    }
    ///Gets the value of [`Self::independent_blend`]
    pub fn independent_blend(&self) -> bool {
        unsafe { std::mem::transmute(self.independent_blend as u8) }
    }
    ///Gets the value of [`Self::geometry_shader`]
    pub fn geometry_shader(&self) -> bool {
        unsafe { std::mem::transmute(self.geometry_shader as u8) }
    }
    ///Gets the value of [`Self::tessellation_shader`]
    pub fn tessellation_shader(&self) -> bool {
        unsafe { std::mem::transmute(self.tessellation_shader as u8) }
    }
    ///Gets the value of [`Self::sample_rate_shading`]
    pub fn sample_rate_shading(&self) -> bool {
        unsafe { std::mem::transmute(self.sample_rate_shading as u8) }
    }
    ///Gets the value of [`Self::dual_src_blend`]
    pub fn dual_src_blend(&self) -> bool {
        unsafe { std::mem::transmute(self.dual_src_blend as u8) }
    }
    ///Gets the value of [`Self::logic_op`]
    pub fn logic_op(&self) -> bool {
        unsafe { std::mem::transmute(self.logic_op as u8) }
    }
    ///Gets the value of [`Self::multi_draw_indirect`]
    pub fn multi_draw_indirect(&self) -> bool {
        unsafe { std::mem::transmute(self.multi_draw_indirect as u8) }
    }
    ///Gets the value of [`Self::draw_indirect_first_instance`]
    pub fn draw_indirect_first_instance(&self) -> bool {
        unsafe { std::mem::transmute(self.draw_indirect_first_instance as u8) }
    }
    ///Gets the value of [`Self::depth_clamp`]
    pub fn depth_clamp(&self) -> bool {
        unsafe { std::mem::transmute(self.depth_clamp as u8) }
    }
    ///Gets the value of [`Self::depth_bias_clamp`]
    pub fn depth_bias_clamp(&self) -> bool {
        unsafe { std::mem::transmute(self.depth_bias_clamp as u8) }
    }
    ///Gets the value of [`Self::fill_mode_non_solid`]
    pub fn fill_mode_non_solid(&self) -> bool {
        unsafe { std::mem::transmute(self.fill_mode_non_solid as u8) }
    }
    ///Gets the value of [`Self::depth_bounds`]
    pub fn depth_bounds(&self) -> bool {
        unsafe { std::mem::transmute(self.depth_bounds as u8) }
    }
    ///Gets the value of [`Self::wide_lines`]
    pub fn wide_lines(&self) -> bool {
        unsafe { std::mem::transmute(self.wide_lines as u8) }
    }
    ///Gets the value of [`Self::large_points`]
    pub fn large_points(&self) -> bool {
        unsafe { std::mem::transmute(self.large_points as u8) }
    }
    ///Gets the value of [`Self::alpha_to_one`]
    pub fn alpha_to_one(&self) -> bool {
        unsafe { std::mem::transmute(self.alpha_to_one as u8) }
    }
    ///Gets the value of [`Self::multi_viewport`]
    pub fn multi_viewport(&self) -> bool {
        unsafe { std::mem::transmute(self.multi_viewport as u8) }
    }
    ///Gets the value of [`Self::sampler_anisotropy`]
    pub fn sampler_anisotropy(&self) -> bool {
        unsafe { std::mem::transmute(self.sampler_anisotropy as u8) }
    }
    ///Gets the value of [`Self::texture_compression_etc_2`]
    pub fn texture_compression_etc_2(&self) -> bool {
        unsafe { std::mem::transmute(self.texture_compression_etc_2 as u8) }
    }
    ///Gets the value of [`Self::texture_compression_astc_ldr`]
    pub fn texture_compression_astc_ldr(&self) -> bool {
        unsafe { std::mem::transmute(self.texture_compression_astc_ldr as u8) }
    }
    ///Gets the value of [`Self::texture_compression_bc`]
    pub fn texture_compression_bc(&self) -> bool {
        unsafe { std::mem::transmute(self.texture_compression_bc as u8) }
    }
    ///Gets the value of [`Self::occlusion_query_precise`]
    pub fn occlusion_query_precise(&self) -> bool {
        unsafe { std::mem::transmute(self.occlusion_query_precise as u8) }
    }
    ///Gets the value of [`Self::pipeline_statistics_query`]
    pub fn pipeline_statistics_query(&self) -> bool {
        unsafe { std::mem::transmute(self.pipeline_statistics_query as u8) }
    }
    ///Gets the value of [`Self::vertex_pipeline_stores_and_atomics`]
    pub fn vertex_pipeline_stores_and_atomics(&self) -> bool {
        unsafe { std::mem::transmute(self.vertex_pipeline_stores_and_atomics as u8) }
    }
    ///Gets the value of [`Self::fragment_stores_and_atomics`]
    pub fn fragment_stores_and_atomics(&self) -> bool {
        unsafe { std::mem::transmute(self.fragment_stores_and_atomics as u8) }
    }
    ///Gets the value of [`Self::shader_tessellation_and_geometry_point_size`]
    pub fn shader_tessellation_and_geometry_point_size(&self) -> bool {
        unsafe { std::mem::transmute(self.shader_tessellation_and_geometry_point_size as u8) }
    }
    ///Gets the value of [`Self::shader_image_gather_extended`]
    pub fn shader_image_gather_extended(&self) -> bool {
        unsafe { std::mem::transmute(self.shader_image_gather_extended as u8) }
    }
    ///Gets the value of [`Self::shader_storage_image_extended_formats`]
    pub fn shader_storage_image_extended_formats(&self) -> bool {
        unsafe { std::mem::transmute(self.shader_storage_image_extended_formats as u8) }
    }
    ///Gets the value of [`Self::shader_storage_image_multisample`]
    pub fn shader_storage_image_multisample(&self) -> bool {
        unsafe { std::mem::transmute(self.shader_storage_image_multisample as u8) }
    }
    ///Gets the value of [`Self::shader_storage_image_read_without_format`]
    pub fn shader_storage_image_read_without_format(&self) -> bool {
        unsafe { std::mem::transmute(self.shader_storage_image_read_without_format as u8) }
    }
    ///Gets the value of [`Self::shader_storage_image_write_without_format`]
    pub fn shader_storage_image_write_without_format(&self) -> bool {
        unsafe { std::mem::transmute(self.shader_storage_image_write_without_format as u8) }
    }
    ///Gets the value of [`Self::shader_uniform_buffer_array_dynamic_indexing`]
    pub fn shader_uniform_buffer_array_dynamic_indexing(&self) -> bool {
        unsafe { std::mem::transmute(self.shader_uniform_buffer_array_dynamic_indexing as u8) }
    }
    ///Gets the value of [`Self::shader_sampled_image_array_dynamic_indexing`]
    pub fn shader_sampled_image_array_dynamic_indexing(&self) -> bool {
        unsafe { std::mem::transmute(self.shader_sampled_image_array_dynamic_indexing as u8) }
    }
    ///Gets the value of [`Self::shader_storage_buffer_array_dynamic_indexing`]
    pub fn shader_storage_buffer_array_dynamic_indexing(&self) -> bool {
        unsafe { std::mem::transmute(self.shader_storage_buffer_array_dynamic_indexing as u8) }
    }
    ///Gets the value of [`Self::shader_storage_image_array_dynamic_indexing`]
    pub fn shader_storage_image_array_dynamic_indexing(&self) -> bool {
        unsafe { std::mem::transmute(self.shader_storage_image_array_dynamic_indexing as u8) }
    }
    ///Gets the value of [`Self::shader_clip_distance`]
    pub fn shader_clip_distance(&self) -> bool {
        unsafe { std::mem::transmute(self.shader_clip_distance as u8) }
    }
    ///Gets the value of [`Self::shader_cull_distance`]
    pub fn shader_cull_distance(&self) -> bool {
        unsafe { std::mem::transmute(self.shader_cull_distance as u8) }
    }
    ///Gets the value of [`Self::shader_float_64`]
    pub fn shader_float_64(&self) -> bool {
        unsafe { std::mem::transmute(self.shader_float_64 as u8) }
    }
    ///Gets the value of [`Self::shader_int_64`]
    pub fn shader_int_64(&self) -> bool {
        unsafe { std::mem::transmute(self.shader_int_64 as u8) }
    }
    ///Gets the value of [`Self::shader_int_16`]
    pub fn shader_int_16(&self) -> bool {
        unsafe { std::mem::transmute(self.shader_int_16 as u8) }
    }
    ///Gets the value of [`Self::shader_resource_residency`]
    pub fn shader_resource_residency(&self) -> bool {
        unsafe { std::mem::transmute(self.shader_resource_residency as u8) }
    }
    ///Gets the value of [`Self::shader_resource_min_lod`]
    pub fn shader_resource_min_lod(&self) -> bool {
        unsafe { std::mem::transmute(self.shader_resource_min_lod as u8) }
    }
    ///Gets the value of [`Self::sparse_binding`]
    pub fn sparse_binding(&self) -> bool {
        unsafe { std::mem::transmute(self.sparse_binding as u8) }
    }
    ///Gets the value of [`Self::sparse_residency_buffer`]
    pub fn sparse_residency_buffer(&self) -> bool {
        unsafe { std::mem::transmute(self.sparse_residency_buffer as u8) }
    }
    ///Gets the value of [`Self::sparse_residency_image_2_d`]
    pub fn sparse_residency_image_2_d(&self) -> bool {
        unsafe { std::mem::transmute(self.sparse_residency_image_2_d as u8) }
    }
    ///Gets the value of [`Self::sparse_residency_image_3_d`]
    pub fn sparse_residency_image_3_d(&self) -> bool {
        unsafe { std::mem::transmute(self.sparse_residency_image_3_d as u8) }
    }
    ///Gets the value of [`Self::sparse_residency_2_samples`]
    pub fn sparse_residency_2_samples(&self) -> bool {
        unsafe { std::mem::transmute(self.sparse_residency_2_samples as u8) }
    }
    ///Gets the value of [`Self::sparse_residency_4_samples`]
    pub fn sparse_residency_4_samples(&self) -> bool {
        unsafe { std::mem::transmute(self.sparse_residency_4_samples as u8) }
    }
    ///Gets the value of [`Self::sparse_residency_8_samples`]
    pub fn sparse_residency_8_samples(&self) -> bool {
        unsafe { std::mem::transmute(self.sparse_residency_8_samples as u8) }
    }
    ///Gets the value of [`Self::sparse_residency_16_samples`]
    pub fn sparse_residency_16_samples(&self) -> bool {
        unsafe { std::mem::transmute(self.sparse_residency_16_samples as u8) }
    }
    ///Gets the value of [`Self::sparse_residency_aliased`]
    pub fn sparse_residency_aliased(&self) -> bool {
        unsafe { std::mem::transmute(self.sparse_residency_aliased as u8) }
    }
    ///Gets the value of [`Self::variable_multisample_rate`]
    pub fn variable_multisample_rate(&self) -> bool {
        unsafe { std::mem::transmute(self.variable_multisample_rate as u8) }
    }
    ///Gets the value of [`Self::inherited_queries`]
    pub fn inherited_queries(&self) -> bool {
        unsafe { std::mem::transmute(self.inherited_queries as u8) }
    }
    ///Gets a mutable reference to the value of [`Self::robust_buffer_access`]
    pub fn robust_buffer_access_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.robust_buffer_access as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.robust_buffer_access as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of [`Self::full_draw_index_uint_32`]
    pub fn full_draw_index_uint_32_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.full_draw_index_uint_32 as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.full_draw_index_uint_32 as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of [`Self::image_cube_array`]
    pub fn image_cube_array_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.image_cube_array as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.image_cube_array as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of [`Self::independent_blend`]
    pub fn independent_blend_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.independent_blend as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.independent_blend as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of [`Self::geometry_shader`]
    pub fn geometry_shader_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.geometry_shader as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.geometry_shader as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of [`Self::tessellation_shader`]
    pub fn tessellation_shader_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.tessellation_shader as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.tessellation_shader as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of [`Self::sample_rate_shading`]
    pub fn sample_rate_shading_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.sample_rate_shading as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.sample_rate_shading as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of [`Self::dual_src_blend`]
    pub fn dual_src_blend_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.dual_src_blend as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.dual_src_blend as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of [`Self::logic_op`]
    pub fn logic_op_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.logic_op as *mut Bool32).cast::<u32>().cast::<u8>().cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.logic_op as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of [`Self::multi_draw_indirect`]
    pub fn multi_draw_indirect_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.multi_draw_indirect as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.multi_draw_indirect as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of [`Self::draw_indirect_first_instance`]
    pub fn draw_indirect_first_instance_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.draw_indirect_first_instance as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.draw_indirect_first_instance as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of [`Self::depth_clamp`]
    pub fn depth_clamp_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.depth_clamp as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.depth_clamp as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of [`Self::depth_bias_clamp`]
    pub fn depth_bias_clamp_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.depth_bias_clamp as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.depth_bias_clamp as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of [`Self::fill_mode_non_solid`]
    pub fn fill_mode_non_solid_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.fill_mode_non_solid as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.fill_mode_non_solid as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of [`Self::depth_bounds`]
    pub fn depth_bounds_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.depth_bounds as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.depth_bounds as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of [`Self::wide_lines`]
    pub fn wide_lines_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.wide_lines as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.wide_lines as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of [`Self::large_points`]
    pub fn large_points_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.large_points as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.large_points as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of [`Self::alpha_to_one`]
    pub fn alpha_to_one_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.alpha_to_one as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.alpha_to_one as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of [`Self::multi_viewport`]
    pub fn multi_viewport_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.multi_viewport as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.multi_viewport as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of [`Self::sampler_anisotropy`]
    pub fn sampler_anisotropy_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.sampler_anisotropy as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.sampler_anisotropy as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of [`Self::texture_compression_etc_2`]
    pub fn texture_compression_etc_2_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.texture_compression_etc_2 as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.texture_compression_etc_2 as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of [`Self::texture_compression_astc_ldr`]
    pub fn texture_compression_astc_ldr_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.texture_compression_astc_ldr as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.texture_compression_astc_ldr as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of [`Self::texture_compression_bc`]
    pub fn texture_compression_bc_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.texture_compression_bc as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.texture_compression_bc as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of [`Self::occlusion_query_precise`]
    pub fn occlusion_query_precise_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.occlusion_query_precise as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.occlusion_query_precise as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of [`Self::pipeline_statistics_query`]
    pub fn pipeline_statistics_query_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.pipeline_statistics_query as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.pipeline_statistics_query as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of [`Self::vertex_pipeline_stores_and_atomics`]
    pub fn vertex_pipeline_stores_and_atomics_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.vertex_pipeline_stores_and_atomics as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.vertex_pipeline_stores_and_atomics as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of [`Self::fragment_stores_and_atomics`]
    pub fn fragment_stores_and_atomics_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.fragment_stores_and_atomics as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.fragment_stores_and_atomics as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of
    /// [`Self::shader_tessellation_and_geometry_point_size`]
    pub fn shader_tessellation_and_geometry_point_size_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.shader_tessellation_and_geometry_point_size as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.shader_tessellation_and_geometry_point_size as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of [`Self::shader_image_gather_extended`]
    pub fn shader_image_gather_extended_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.shader_image_gather_extended as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.shader_image_gather_extended as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of [`Self::shader_storage_image_extended_formats`]
    pub fn shader_storage_image_extended_formats_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.shader_storage_image_extended_formats as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.shader_storage_image_extended_formats as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of [`Self::shader_storage_image_multisample`]
    pub fn shader_storage_image_multisample_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.shader_storage_image_multisample as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.shader_storage_image_multisample as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of [`Self::shader_storage_image_read_without_format`]
    pub fn shader_storage_image_read_without_format_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.shader_storage_image_read_without_format as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.shader_storage_image_read_without_format as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of [`Self::shader_storage_image_write_without_format`]
    pub fn shader_storage_image_write_without_format_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.shader_storage_image_write_without_format as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.shader_storage_image_write_without_format as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of
    /// [`Self::shader_uniform_buffer_array_dynamic_indexing`]
    pub fn shader_uniform_buffer_array_dynamic_indexing_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.shader_uniform_buffer_array_dynamic_indexing as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.shader_uniform_buffer_array_dynamic_indexing as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of
    /// [`Self::shader_sampled_image_array_dynamic_indexing`]
    pub fn shader_sampled_image_array_dynamic_indexing_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.shader_sampled_image_array_dynamic_indexing as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.shader_sampled_image_array_dynamic_indexing as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of
    /// [`Self::shader_storage_buffer_array_dynamic_indexing`]
    pub fn shader_storage_buffer_array_dynamic_indexing_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.shader_storage_buffer_array_dynamic_indexing as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.shader_storage_buffer_array_dynamic_indexing as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of
    /// [`Self::shader_storage_image_array_dynamic_indexing`]
    pub fn shader_storage_image_array_dynamic_indexing_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.shader_storage_image_array_dynamic_indexing as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.shader_storage_image_array_dynamic_indexing as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of [`Self::shader_clip_distance`]
    pub fn shader_clip_distance_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.shader_clip_distance as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.shader_clip_distance as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of [`Self::shader_cull_distance`]
    pub fn shader_cull_distance_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.shader_cull_distance as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.shader_cull_distance as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of [`Self::shader_float_64`]
    pub fn shader_float_64_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.shader_float_64 as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.shader_float_64 as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of [`Self::shader_int_64`]
    pub fn shader_int_64_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.shader_int_64 as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.shader_int_64 as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of [`Self::shader_int_16`]
    pub fn shader_int_16_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.shader_int_16 as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.shader_int_16 as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of [`Self::shader_resource_residency`]
    pub fn shader_resource_residency_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.shader_resource_residency as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.shader_resource_residency as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of [`Self::shader_resource_min_lod`]
    pub fn shader_resource_min_lod_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.shader_resource_min_lod as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.shader_resource_min_lod as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of [`Self::sparse_binding`]
    pub fn sparse_binding_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.sparse_binding as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.sparse_binding as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of [`Self::sparse_residency_buffer`]
    pub fn sparse_residency_buffer_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.sparse_residency_buffer as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.sparse_residency_buffer as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of [`Self::sparse_residency_image_2_d`]
    pub fn sparse_residency_image_2_d_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.sparse_residency_image_2_d as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.sparse_residency_image_2_d as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of [`Self::sparse_residency_image_3_d`]
    pub fn sparse_residency_image_3_d_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.sparse_residency_image_3_d as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.sparse_residency_image_3_d as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of [`Self::sparse_residency_2_samples`]
    pub fn sparse_residency_2_samples_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.sparse_residency_2_samples as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.sparse_residency_2_samples as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of [`Self::sparse_residency_4_samples`]
    pub fn sparse_residency_4_samples_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.sparse_residency_4_samples as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.sparse_residency_4_samples as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of [`Self::sparse_residency_8_samples`]
    pub fn sparse_residency_8_samples_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.sparse_residency_8_samples as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.sparse_residency_8_samples as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of [`Self::sparse_residency_16_samples`]
    pub fn sparse_residency_16_samples_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.sparse_residency_16_samples as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.sparse_residency_16_samples as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of [`Self::sparse_residency_aliased`]
    pub fn sparse_residency_aliased_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.sparse_residency_aliased as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.sparse_residency_aliased as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of [`Self::variable_multisample_rate`]
    pub fn variable_multisample_rate_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.variable_multisample_rate as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.variable_multisample_rate as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of [`Self::inherited_queries`]
    pub fn inherited_queries_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.inherited_queries as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.inherited_queries as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Sets the raw value of [`Self::robust_buffer_access`]
    pub fn set_robust_buffer_access(&mut self, value: bool) -> &mut Self {
        self.robust_buffer_access = value as u8 as u32;
        self
    }
    ///Sets the raw value of [`Self::full_draw_index_uint_32`]
    pub fn set_full_draw_index_uint_32(&mut self, value: bool) -> &mut Self {
        self.full_draw_index_uint_32 = value as u8 as u32;
        self
    }
    ///Sets the raw value of [`Self::image_cube_array`]
    pub fn set_image_cube_array(&mut self, value: bool) -> &mut Self {
        self.image_cube_array = value as u8 as u32;
        self
    }
    ///Sets the raw value of [`Self::independent_blend`]
    pub fn set_independent_blend(&mut self, value: bool) -> &mut Self {
        self.independent_blend = value as u8 as u32;
        self
    }
    ///Sets the raw value of [`Self::geometry_shader`]
    pub fn set_geometry_shader(&mut self, value: bool) -> &mut Self {
        self.geometry_shader = value as u8 as u32;
        self
    }
    ///Sets the raw value of [`Self::tessellation_shader`]
    pub fn set_tessellation_shader(&mut self, value: bool) -> &mut Self {
        self.tessellation_shader = value as u8 as u32;
        self
    }
    ///Sets the raw value of [`Self::sample_rate_shading`]
    pub fn set_sample_rate_shading(&mut self, value: bool) -> &mut Self {
        self.sample_rate_shading = value as u8 as u32;
        self
    }
    ///Sets the raw value of [`Self::dual_src_blend`]
    pub fn set_dual_src_blend(&mut self, value: bool) -> &mut Self {
        self.dual_src_blend = value as u8 as u32;
        self
    }
    ///Sets the raw value of [`Self::logic_op`]
    pub fn set_logic_op(&mut self, value: bool) -> &mut Self {
        self.logic_op = value as u8 as u32;
        self
    }
    ///Sets the raw value of [`Self::multi_draw_indirect`]
    pub fn set_multi_draw_indirect(&mut self, value: bool) -> &mut Self {
        self.multi_draw_indirect = value as u8 as u32;
        self
    }
    ///Sets the raw value of [`Self::draw_indirect_first_instance`]
    pub fn set_draw_indirect_first_instance(&mut self, value: bool) -> &mut Self {
        self.draw_indirect_first_instance = value as u8 as u32;
        self
    }
    ///Sets the raw value of [`Self::depth_clamp`]
    pub fn set_depth_clamp(&mut self, value: bool) -> &mut Self {
        self.depth_clamp = value as u8 as u32;
        self
    }
    ///Sets the raw value of [`Self::depth_bias_clamp`]
    pub fn set_depth_bias_clamp(&mut self, value: bool) -> &mut Self {
        self.depth_bias_clamp = value as u8 as u32;
        self
    }
    ///Sets the raw value of [`Self::fill_mode_non_solid`]
    pub fn set_fill_mode_non_solid(&mut self, value: bool) -> &mut Self {
        self.fill_mode_non_solid = value as u8 as u32;
        self
    }
    ///Sets the raw value of [`Self::depth_bounds`]
    pub fn set_depth_bounds(&mut self, value: bool) -> &mut Self {
        self.depth_bounds = value as u8 as u32;
        self
    }
    ///Sets the raw value of [`Self::wide_lines`]
    pub fn set_wide_lines(&mut self, value: bool) -> &mut Self {
        self.wide_lines = value as u8 as u32;
        self
    }
    ///Sets the raw value of [`Self::large_points`]
    pub fn set_large_points(&mut self, value: bool) -> &mut Self {
        self.large_points = value as u8 as u32;
        self
    }
    ///Sets the raw value of [`Self::alpha_to_one`]
    pub fn set_alpha_to_one(&mut self, value: bool) -> &mut Self {
        self.alpha_to_one = value as u8 as u32;
        self
    }
    ///Sets the raw value of [`Self::multi_viewport`]
    pub fn set_multi_viewport(&mut self, value: bool) -> &mut Self {
        self.multi_viewport = value as u8 as u32;
        self
    }
    ///Sets the raw value of [`Self::sampler_anisotropy`]
    pub fn set_sampler_anisotropy(&mut self, value: bool) -> &mut Self {
        self.sampler_anisotropy = value as u8 as u32;
        self
    }
    ///Sets the raw value of [`Self::texture_compression_etc_2`]
    pub fn set_texture_compression_etc_2(&mut self, value: bool) -> &mut Self {
        self.texture_compression_etc_2 = value as u8 as u32;
        self
    }
    ///Sets the raw value of [`Self::texture_compression_astc_ldr`]
    pub fn set_texture_compression_astc_ldr(&mut self, value: bool) -> &mut Self {
        self.texture_compression_astc_ldr = value as u8 as u32;
        self
    }
    ///Sets the raw value of [`Self::texture_compression_bc`]
    pub fn set_texture_compression_bc(&mut self, value: bool) -> &mut Self {
        self.texture_compression_bc = value as u8 as u32;
        self
    }
    ///Sets the raw value of [`Self::occlusion_query_precise`]
    pub fn set_occlusion_query_precise(&mut self, value: bool) -> &mut Self {
        self.occlusion_query_precise = value as u8 as u32;
        self
    }
    ///Sets the raw value of [`Self::pipeline_statistics_query`]
    pub fn set_pipeline_statistics_query(&mut self, value: bool) -> &mut Self {
        self.pipeline_statistics_query = value as u8 as u32;
        self
    }
    ///Sets the raw value of [`Self::vertex_pipeline_stores_and_atomics`]
    pub fn set_vertex_pipeline_stores_and_atomics(&mut self, value: bool) -> &mut Self {
        self.vertex_pipeline_stores_and_atomics = value as u8 as u32;
        self
    }
    ///Sets the raw value of [`Self::fragment_stores_and_atomics`]
    pub fn set_fragment_stores_and_atomics(&mut self, value: bool) -> &mut Self {
        self.fragment_stores_and_atomics = value as u8 as u32;
        self
    }
    ///Sets the raw value of [`Self::shader_tessellation_and_geometry_point_size`]
    pub fn set_shader_tessellation_and_geometry_point_size(&mut self, value: bool) -> &mut Self {
        self.shader_tessellation_and_geometry_point_size = value as u8 as u32;
        self
    }
    ///Sets the raw value of [`Self::shader_image_gather_extended`]
    pub fn set_shader_image_gather_extended(&mut self, value: bool) -> &mut Self {
        self.shader_image_gather_extended = value as u8 as u32;
        self
    }
    ///Sets the raw value of [`Self::shader_storage_image_extended_formats`]
    pub fn set_shader_storage_image_extended_formats(&mut self, value: bool) -> &mut Self {
        self.shader_storage_image_extended_formats = value as u8 as u32;
        self
    }
    ///Sets the raw value of [`Self::shader_storage_image_multisample`]
    pub fn set_shader_storage_image_multisample(&mut self, value: bool) -> &mut Self {
        self.shader_storage_image_multisample = value as u8 as u32;
        self
    }
    ///Sets the raw value of [`Self::shader_storage_image_read_without_format`]
    pub fn set_shader_storage_image_read_without_format(&mut self, value: bool) -> &mut Self {
        self.shader_storage_image_read_without_format = value as u8 as u32;
        self
    }
    ///Sets the raw value of [`Self::shader_storage_image_write_without_format`]
    pub fn set_shader_storage_image_write_without_format(&mut self, value: bool) -> &mut Self {
        self.shader_storage_image_write_without_format = value as u8 as u32;
        self
    }
    ///Sets the raw value of [`Self::shader_uniform_buffer_array_dynamic_indexing`]
    pub fn set_shader_uniform_buffer_array_dynamic_indexing(&mut self, value: bool) -> &mut Self {
        self.shader_uniform_buffer_array_dynamic_indexing = value as u8 as u32;
        self
    }
    ///Sets the raw value of [`Self::shader_sampled_image_array_dynamic_indexing`]
    pub fn set_shader_sampled_image_array_dynamic_indexing(&mut self, value: bool) -> &mut Self {
        self.shader_sampled_image_array_dynamic_indexing = value as u8 as u32;
        self
    }
    ///Sets the raw value of [`Self::shader_storage_buffer_array_dynamic_indexing`]
    pub fn set_shader_storage_buffer_array_dynamic_indexing(&mut self, value: bool) -> &mut Self {
        self.shader_storage_buffer_array_dynamic_indexing = value as u8 as u32;
        self
    }
    ///Sets the raw value of [`Self::shader_storage_image_array_dynamic_indexing`]
    pub fn set_shader_storage_image_array_dynamic_indexing(&mut self, value: bool) -> &mut Self {
        self.shader_storage_image_array_dynamic_indexing = value as u8 as u32;
        self
    }
    ///Sets the raw value of [`Self::shader_clip_distance`]
    pub fn set_shader_clip_distance(&mut self, value: bool) -> &mut Self {
        self.shader_clip_distance = value as u8 as u32;
        self
    }
    ///Sets the raw value of [`Self::shader_cull_distance`]
    pub fn set_shader_cull_distance(&mut self, value: bool) -> &mut Self {
        self.shader_cull_distance = value as u8 as u32;
        self
    }
    ///Sets the raw value of [`Self::shader_float_64`]
    pub fn set_shader_float_64(&mut self, value: bool) -> &mut Self {
        self.shader_float_64 = value as u8 as u32;
        self
    }
    ///Sets the raw value of [`Self::shader_int_64`]
    pub fn set_shader_int_64(&mut self, value: bool) -> &mut Self {
        self.shader_int_64 = value as u8 as u32;
        self
    }
    ///Sets the raw value of [`Self::shader_int_16`]
    pub fn set_shader_int_16(&mut self, value: bool) -> &mut Self {
        self.shader_int_16 = value as u8 as u32;
        self
    }
    ///Sets the raw value of [`Self::shader_resource_residency`]
    pub fn set_shader_resource_residency(&mut self, value: bool) -> &mut Self {
        self.shader_resource_residency = value as u8 as u32;
        self
    }
    ///Sets the raw value of [`Self::shader_resource_min_lod`]
    pub fn set_shader_resource_min_lod(&mut self, value: bool) -> &mut Self {
        self.shader_resource_min_lod = value as u8 as u32;
        self
    }
    ///Sets the raw value of [`Self::sparse_binding`]
    pub fn set_sparse_binding(&mut self, value: bool) -> &mut Self {
        self.sparse_binding = value as u8 as u32;
        self
    }
    ///Sets the raw value of [`Self::sparse_residency_buffer`]
    pub fn set_sparse_residency_buffer(&mut self, value: bool) -> &mut Self {
        self.sparse_residency_buffer = value as u8 as u32;
        self
    }
    ///Sets the raw value of [`Self::sparse_residency_image_2_d`]
    pub fn set_sparse_residency_image_2_d(&mut self, value: bool) -> &mut Self {
        self.sparse_residency_image_2_d = value as u8 as u32;
        self
    }
    ///Sets the raw value of [`Self::sparse_residency_image_3_d`]
    pub fn set_sparse_residency_image_3_d(&mut self, value: bool) -> &mut Self {
        self.sparse_residency_image_3_d = value as u8 as u32;
        self
    }
    ///Sets the raw value of [`Self::sparse_residency_2_samples`]
    pub fn set_sparse_residency_2_samples(&mut self, value: bool) -> &mut Self {
        self.sparse_residency_2_samples = value as u8 as u32;
        self
    }
    ///Sets the raw value of [`Self::sparse_residency_4_samples`]
    pub fn set_sparse_residency_4_samples(&mut self, value: bool) -> &mut Self {
        self.sparse_residency_4_samples = value as u8 as u32;
        self
    }
    ///Sets the raw value of [`Self::sparse_residency_8_samples`]
    pub fn set_sparse_residency_8_samples(&mut self, value: bool) -> &mut Self {
        self.sparse_residency_8_samples = value as u8 as u32;
        self
    }
    ///Sets the raw value of [`Self::sparse_residency_16_samples`]
    pub fn set_sparse_residency_16_samples(&mut self, value: bool) -> &mut Self {
        self.sparse_residency_16_samples = value as u8 as u32;
        self
    }
    ///Sets the raw value of [`Self::sparse_residency_aliased`]
    pub fn set_sparse_residency_aliased(&mut self, value: bool) -> &mut Self {
        self.sparse_residency_aliased = value as u8 as u32;
        self
    }
    ///Sets the raw value of [`Self::variable_multisample_rate`]
    pub fn set_variable_multisample_rate(&mut self, value: bool) -> &mut Self {
        self.variable_multisample_rate = value as u8 as u32;
        self
    }
    ///Sets the raw value of [`Self::inherited_queries`]
    pub fn set_inherited_queries(&mut self, value: bool) -> &mut Self {
        self.inherited_queries = value as u8 as u32;
        self
    }
}
///[VkPhysicalDeviceSparseProperties](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceSparseProperties.html) - Structure specifying physical device sparse memory properties
///# C Specifications
///The [`PhysicalDeviceSparseProperties`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkPhysicalDeviceSparseProperties {
///    VkBool32    residencyStandard2DBlockShape;
///    VkBool32    residencyStandard2DMultisampleBlockShape;
///    VkBool32    residencyStandard3DBlockShape;
///    VkBool32    residencyAlignedMipSize;
///    VkBool32    residencyNonResidentStrict;
///} VkPhysicalDeviceSparseProperties;
///```
///# Members
/// - [`residency_standard_2_d_block_shape`] is [`TRUE`] if the physical device will access all single-sample 2D sparse resources using the standard sparse image block shapes (based on image format), as described in the [Standard Sparse Image Block Shapes (Single Sample)](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#sparsememory-sparseblockshapessingle) table. If this property is not supported the value returned in the `imageGranularity` member of the [`SparseImageFormatProperties`] structure for single-sample 2D images is not  **required**  to match the standard sparse image block dimensions listed in the table.
/// - [`residency_standard_2_d_multisample_block_shape`] is [`TRUE`] if the physical device will access all multisample 2D sparse resources using the standard sparse image block shapes (based on image format), as described in the [Standard Sparse Image Block Shapes (MSAA)](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#sparsememory-sparseblockshapesmsaa) table. If this property is not supported, the value returned in the `imageGranularity` member of the [`SparseImageFormatProperties`] structure for multisample 2D images is not  **required**  to match the standard sparse image block dimensions listed in the table.
/// - [`residency_standard_3_d_block_shape`] is [`TRUE`] if the physical device will access all 3D sparse resources using the standard sparse image block shapes (based on image format), as described in the [Standard Sparse Image Block Shapes (Single Sample)](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#sparsememory-sparseblockshapessingle) table. If this property is not supported, the value returned in the `imageGranularity` member of the [`SparseImageFormatProperties`] structure for 3D images is not  **required**  to match the standard sparse image block dimensions listed in the table.
/// - [`residency_aligned_mip_size`] is [`TRUE`] if images with mip level dimensions that are not
///   integer multiples of the corresponding dimensions of the sparse image block  **may**  be
///   placed in the mip tail. If this property is not reported, only mip levels with dimensions
///   smaller than the `imageGranularity` member of the [`SparseImageFormatProperties`] structure
///   will be placed in the mip tail. If this property is reported the implementation is allowed to
///   return `VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT` in the `flags` member of
///   [`SparseImageFormatProperties`], indicating that mip level dimensions that are not integer
///   multiples of the corresponding dimensions of the sparse image block will be placed in the mip
///   tail.
/// - [`residency_non_resident_strict`] specifies whether the physical device  **can**  consistently
///   access non-resident regions of a resource. If this property is [`TRUE`], access to
///   non-resident regions of resources will be guaranteed to return values as if the resource was
///   populated with 0; writes to non-resident regions will be discarded.
///# Related
/// - [`crate::vulkan1_0`]
/// - [`Bool32`]
/// - [`PhysicalDeviceProperties`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct PhysicalDeviceSparseProperties {
    ///[`residency_standard_2_d_block_shape`] is [`TRUE`] if the physical
    ///device will access all single-sample 2D sparse resources using the
    ///standard sparse image block shapes (based on image format), as described
    ///in the [Standard Sparse Image
    ///Block Shapes (Single Sample)](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#sparsememory-sparseblockshapessingle) table.
    ///If this property is not supported the value returned in the
    ///`imageGranularity` member of the [`SparseImageFormatProperties`]
    ///structure for single-sample 2D images is not  **required**  to match the
    ///standard sparse image block dimensions listed in the table.
    residency_standard_2_d_block_shape: Bool32,
    ///[`residency_standard_2_d_multisample_block_shape`] is [`TRUE`] if the
    ///physical device will access all multisample 2D sparse resources using
    ///the standard sparse image block shapes (based on image format), as
    ///described in the [Standard Sparse
    ///Image Block Shapes (MSAA)](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#sparsememory-sparseblockshapesmsaa) table.
    ///If this property is not supported, the value returned in the
    ///`imageGranularity` member of the [`SparseImageFormatProperties`]
    ///structure for multisample 2D images is not  **required**  to match the
    ///standard sparse image block dimensions listed in the table.
    residency_standard_2_d_multisample_block_shape: Bool32,
    ///[`residency_standard_3_d_block_shape`] is [`TRUE`] if the physical
    ///device will access all 3D sparse resources using the standard sparse
    ///image block shapes (based on image format), as described in the
    ///[Standard Sparse Image Block
    ///Shapes (Single Sample)](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#sparsememory-sparseblockshapessingle) table.
    ///If this property is not supported, the value returned in the
    ///`imageGranularity` member of the [`SparseImageFormatProperties`]
    ///structure for 3D images is not  **required**  to match the standard sparse
    ///image block dimensions listed in the table.
    residency_standard_3_d_block_shape: Bool32,
    ///[`residency_aligned_mip_size`] is [`TRUE`] if images with mip level
    ///dimensions that are not integer multiples of the corresponding
    ///dimensions of the sparse image block  **may**  be placed in the mip tail.
    ///If this property is not reported, only mip levels with dimensions
    ///smaller than the `imageGranularity` member of the
    ///[`SparseImageFormatProperties`] structure will be placed in the mip
    ///tail.
    ///If this property is reported the implementation is allowed to return
    ///`VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT` in the `flags`
    ///member of [`SparseImageFormatProperties`], indicating that mip level
    ///dimensions that are not integer multiples of the corresponding
    ///dimensions of the sparse image block will be placed in the mip tail.
    residency_aligned_mip_size: Bool32,
    ///[`residency_non_resident_strict`] specifies whether the physical device
    /// **can**  consistently access non-resident regions of a resource.
    ///If this property is [`TRUE`], access to non-resident regions of
    ///resources will be guaranteed to return values as if the resource was
    ///populated with 0; writes to non-resident regions will be discarded.
    residency_non_resident_strict: Bool32,
}
impl Default for PhysicalDeviceSparseProperties {
    fn default() -> Self {
        Self {
            residency_standard_2_d_block_shape: 0,
            residency_standard_2_d_multisample_block_shape: 0,
            residency_standard_3_d_block_shape: 0,
            residency_aligned_mip_size: 0,
            residency_non_resident_strict: 0,
        }
    }
}
impl PhysicalDeviceSparseProperties {
    ///Gets the raw value of [`Self::residency_standard_2_d_block_shape`]
    pub fn residency_standard_2_d_block_shape_raw(&self) -> Bool32 {
        self.residency_standard_2_d_block_shape
    }
    ///Gets the raw value of [`Self::residency_standard_2_d_multisample_block_shape`]
    pub fn residency_standard_2_d_multisample_block_shape_raw(&self) -> Bool32 {
        self.residency_standard_2_d_multisample_block_shape
    }
    ///Gets the raw value of [`Self::residency_standard_3_d_block_shape`]
    pub fn residency_standard_3_d_block_shape_raw(&self) -> Bool32 {
        self.residency_standard_3_d_block_shape
    }
    ///Gets the raw value of [`Self::residency_aligned_mip_size`]
    pub fn residency_aligned_mip_size_raw(&self) -> Bool32 {
        self.residency_aligned_mip_size
    }
    ///Gets the raw value of [`Self::residency_non_resident_strict`]
    pub fn residency_non_resident_strict_raw(&self) -> Bool32 {
        self.residency_non_resident_strict
    }
    ///Sets the raw value of [`Self::residency_standard_2_d_block_shape`]
    pub fn set_residency_standard_2_d_block_shape_raw(&mut self, value: Bool32) -> &mut Self {
        self.residency_standard_2_d_block_shape = value;
        self
    }
    ///Sets the raw value of [`Self::residency_standard_2_d_multisample_block_shape`]
    pub fn set_residency_standard_2_d_multisample_block_shape_raw(&mut self, value: Bool32) -> &mut Self {
        self.residency_standard_2_d_multisample_block_shape = value;
        self
    }
    ///Sets the raw value of [`Self::residency_standard_3_d_block_shape`]
    pub fn set_residency_standard_3_d_block_shape_raw(&mut self, value: Bool32) -> &mut Self {
        self.residency_standard_3_d_block_shape = value;
        self
    }
    ///Sets the raw value of [`Self::residency_aligned_mip_size`]
    pub fn set_residency_aligned_mip_size_raw(&mut self, value: Bool32) -> &mut Self {
        self.residency_aligned_mip_size = value;
        self
    }
    ///Sets the raw value of [`Self::residency_non_resident_strict`]
    pub fn set_residency_non_resident_strict_raw(&mut self, value: Bool32) -> &mut Self {
        self.residency_non_resident_strict = value;
        self
    }
    ///Gets the value of [`Self::residency_standard_2_d_block_shape`]
    pub fn residency_standard_2_d_block_shape(&self) -> bool {
        unsafe { std::mem::transmute(self.residency_standard_2_d_block_shape as u8) }
    }
    ///Gets the value of [`Self::residency_standard_2_d_multisample_block_shape`]
    pub fn residency_standard_2_d_multisample_block_shape(&self) -> bool {
        unsafe { std::mem::transmute(self.residency_standard_2_d_multisample_block_shape as u8) }
    }
    ///Gets the value of [`Self::residency_standard_3_d_block_shape`]
    pub fn residency_standard_3_d_block_shape(&self) -> bool {
        unsafe { std::mem::transmute(self.residency_standard_3_d_block_shape as u8) }
    }
    ///Gets the value of [`Self::residency_aligned_mip_size`]
    pub fn residency_aligned_mip_size(&self) -> bool {
        unsafe { std::mem::transmute(self.residency_aligned_mip_size as u8) }
    }
    ///Gets the value of [`Self::residency_non_resident_strict`]
    pub fn residency_non_resident_strict(&self) -> bool {
        unsafe { std::mem::transmute(self.residency_non_resident_strict as u8) }
    }
    ///Gets a mutable reference to the value of [`Self::residency_standard_2_d_block_shape`]
    pub fn residency_standard_2_d_block_shape_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.residency_standard_2_d_block_shape as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.residency_standard_2_d_block_shape as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of
    /// [`Self::residency_standard_2_d_multisample_block_shape`]
    pub fn residency_standard_2_d_multisample_block_shape_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.residency_standard_2_d_multisample_block_shape as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.residency_standard_2_d_multisample_block_shape as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of [`Self::residency_standard_3_d_block_shape`]
    pub fn residency_standard_3_d_block_shape_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.residency_standard_3_d_block_shape as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.residency_standard_3_d_block_shape as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of [`Self::residency_aligned_mip_size`]
    pub fn residency_aligned_mip_size_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.residency_aligned_mip_size as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.residency_aligned_mip_size as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of [`Self::residency_non_resident_strict`]
    pub fn residency_non_resident_strict_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.residency_non_resident_strict as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.residency_non_resident_strict as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Sets the raw value of [`Self::residency_standard_2_d_block_shape`]
    pub fn set_residency_standard_2_d_block_shape(&mut self, value: bool) -> &mut Self {
        self.residency_standard_2_d_block_shape = value as u8 as u32;
        self
    }
    ///Sets the raw value of [`Self::residency_standard_2_d_multisample_block_shape`]
    pub fn set_residency_standard_2_d_multisample_block_shape(&mut self, value: bool) -> &mut Self {
        self.residency_standard_2_d_multisample_block_shape = value as u8 as u32;
        self
    }
    ///Sets the raw value of [`Self::residency_standard_3_d_block_shape`]
    pub fn set_residency_standard_3_d_block_shape(&mut self, value: bool) -> &mut Self {
        self.residency_standard_3_d_block_shape = value as u8 as u32;
        self
    }
    ///Sets the raw value of [`Self::residency_aligned_mip_size`]
    pub fn set_residency_aligned_mip_size(&mut self, value: bool) -> &mut Self {
        self.residency_aligned_mip_size = value as u8 as u32;
        self
    }
    ///Sets the raw value of [`Self::residency_non_resident_strict`]
    pub fn set_residency_non_resident_strict(&mut self, value: bool) -> &mut Self {
        self.residency_non_resident_strict = value as u8 as u32;
        self
    }
}
///[VkPhysicalDeviceLimits](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceLimits.html) - Structure reporting implementation-dependent physical device limits
///# C Specifications
///The [`PhysicalDeviceLimits`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkPhysicalDeviceLimits {
///    uint32_t              maxImageDimension1D;
///    uint32_t              maxImageDimension2D;
///    uint32_t              maxImageDimension3D;
///    uint32_t              maxImageDimensionCube;
///    uint32_t              maxImageArrayLayers;
///    uint32_t              maxTexelBufferElements;
///    uint32_t              maxUniformBufferRange;
///    uint32_t              maxStorageBufferRange;
///    uint32_t              maxPushConstantsSize;
///    uint32_t              maxMemoryAllocationCount;
///    uint32_t              maxSamplerAllocationCount;
///    VkDeviceSize          bufferImageGranularity;
///    VkDeviceSize          sparseAddressSpaceSize;
///    uint32_t              maxBoundDescriptorSets;
///    uint32_t              maxPerStageDescriptorSamplers;
///    uint32_t              maxPerStageDescriptorUniformBuffers;
///    uint32_t              maxPerStageDescriptorStorageBuffers;
///    uint32_t              maxPerStageDescriptorSampledImages;
///    uint32_t              maxPerStageDescriptorStorageImages;
///    uint32_t              maxPerStageDescriptorInputAttachments;
///    uint32_t              maxPerStageResources;
///    uint32_t              maxDescriptorSetSamplers;
///    uint32_t              maxDescriptorSetUniformBuffers;
///    uint32_t              maxDescriptorSetUniformBuffersDynamic;
///    uint32_t              maxDescriptorSetStorageBuffers;
///    uint32_t              maxDescriptorSetStorageBuffersDynamic;
///    uint32_t              maxDescriptorSetSampledImages;
///    uint32_t              maxDescriptorSetStorageImages;
///    uint32_t              maxDescriptorSetInputAttachments;
///    uint32_t              maxVertexInputAttributes;
///    uint32_t              maxVertexInputBindings;
///    uint32_t              maxVertexInputAttributeOffset;
///    uint32_t              maxVertexInputBindingStride;
///    uint32_t              maxVertexOutputComponents;
///    uint32_t              maxTessellationGenerationLevel;
///    uint32_t              maxTessellationPatchSize;
///    uint32_t              maxTessellationControlPerVertexInputComponents;
///    uint32_t              maxTessellationControlPerVertexOutputComponents;
///    uint32_t              maxTessellationControlPerPatchOutputComponents;
///    uint32_t              maxTessellationControlTotalOutputComponents;
///    uint32_t              maxTessellationEvaluationInputComponents;
///    uint32_t              maxTessellationEvaluationOutputComponents;
///    uint32_t              maxGeometryShaderInvocations;
///    uint32_t              maxGeometryInputComponents;
///    uint32_t              maxGeometryOutputComponents;
///    uint32_t              maxGeometryOutputVertices;
///    uint32_t              maxGeometryTotalOutputComponents;
///    uint32_t              maxFragmentInputComponents;
///    uint32_t              maxFragmentOutputAttachments;
///    uint32_t              maxFragmentDualSrcAttachments;
///    uint32_t              maxFragmentCombinedOutputResources;
///    uint32_t              maxComputeSharedMemorySize;
///    uint32_t              maxComputeWorkGroupCount[3];
///    uint32_t              maxComputeWorkGroupInvocations;
///    uint32_t              maxComputeWorkGroupSize[3];
///    uint32_t              subPixelPrecisionBits;
///    uint32_t              subTexelPrecisionBits;
///    uint32_t              mipmapPrecisionBits;
///    uint32_t              maxDrawIndexedIndexValue;
///    uint32_t              maxDrawIndirectCount;
///    float                 maxSamplerLodBias;
///    float                 maxSamplerAnisotropy;
///    uint32_t              maxViewports;
///    uint32_t              maxViewportDimensions[2];
///    float                 viewportBoundsRange[2];
///    uint32_t              viewportSubPixelBits;
///    size_t                minMemoryMapAlignment;
///    VkDeviceSize          minTexelBufferOffsetAlignment;
///    VkDeviceSize          minUniformBufferOffsetAlignment;
///    VkDeviceSize          minStorageBufferOffsetAlignment;
///    int32_t               minTexelOffset;
///    uint32_t              maxTexelOffset;
///    int32_t               minTexelGatherOffset;
///    uint32_t              maxTexelGatherOffset;
///    float                 minInterpolationOffset;
///    float                 maxInterpolationOffset;
///    uint32_t              subPixelInterpolationOffsetBits;
///    uint32_t              maxFramebufferWidth;
///    uint32_t              maxFramebufferHeight;
///    uint32_t              maxFramebufferLayers;
///    VkSampleCountFlags    framebufferColorSampleCounts;
///    VkSampleCountFlags    framebufferDepthSampleCounts;
///    VkSampleCountFlags    framebufferStencilSampleCounts;
///    VkSampleCountFlags    framebufferNoAttachmentsSampleCounts;
///    uint32_t              maxColorAttachments;
///    VkSampleCountFlags    sampledImageColorSampleCounts;
///    VkSampleCountFlags    sampledImageIntegerSampleCounts;
///    VkSampleCountFlags    sampledImageDepthSampleCounts;
///    VkSampleCountFlags    sampledImageStencilSampleCounts;
///    VkSampleCountFlags    storageImageSampleCounts;
///    uint32_t              maxSampleMaskWords;
///    VkBool32              timestampComputeAndGraphics;
///    float                 timestampPeriod;
///    uint32_t              maxClipDistances;
///    uint32_t              maxCullDistances;
///    uint32_t              maxCombinedClipAndCullDistances;
///    uint32_t              discreteQueuePriorities;
///    float                 pointSizeRange[2];
///    float                 lineWidthRange[2];
///    float                 pointSizeGranularity;
///    float                 lineWidthGranularity;
///    VkBool32              strictLines;
///    VkBool32              standardSampleLocations;
///    VkDeviceSize          optimalBufferCopyOffsetAlignment;
///    VkDeviceSize          optimalBufferCopyRowPitchAlignment;
///    VkDeviceSize          nonCoherentAtomSize;
///} VkPhysicalDeviceLimits;
///```
///# Members
///The [`PhysicalDeviceLimits`] are properties of the physical device.
///These are available in the `limits` member of the
///[`PhysicalDeviceProperties`] structure which is returned from
///[`GetPhysicalDeviceProperties`].
///# Description
/// - [`max_image_dimension_1_d`] is the largest dimension (`width`) that is guaranteed to be
///   supported for all images created with an `imageType` of `VK_IMAGE_TYPE_1D`. Some combinations
///   of image parameters (format, usage, etc.)  **may**  allow support for larger dimensions, which
///   **can**  be queried using [`GetPhysicalDeviceImageFormatProperties`].
/// - [`max_image_dimension_2_d`] is the largest dimension (`width` or `height`) that is guaranteed
///   to be supported for all images created with an `imageType` of `VK_IMAGE_TYPE_2D` and without
///   `VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT` set in `flags`. Some combinations of image parameters
///   (format, usage, etc.)  **may**  allow support for larger dimensions, which  **can**  be
///   queried using [`GetPhysicalDeviceImageFormatProperties`].
/// - [`max_image_dimension_3_d`] is the largest dimension (`width`, `height`, or `depth`) that is
///   guaranteed to be supported for all images created with an `imageType` of `VK_IMAGE_TYPE_3D`.
///   Some combinations of image parameters (format, usage, etc.)  **may**  allow support for larger
///   dimensions, which  **can**  be queried using [`GetPhysicalDeviceImageFormatProperties`].
/// - [`max_image_dimension_cube`] is the largest dimension (`width` or `height`) that is guaranteed
///   to be supported for all images created with an `imageType` of `VK_IMAGE_TYPE_2D` and with
///   `VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT` set in `flags`. Some combinations of image parameters
///   (format, usage, etc.)  **may**  allow support for larger dimensions, which  **can**  be
///   queried using [`GetPhysicalDeviceImageFormatProperties`].
/// - [`max_image_array_layers`] is the maximum number of layers (`arrayLayers`) for an image.
/// - [`max_texel_buffer_elements`] is the maximum number of addressable texels for a buffer view
///   created on a buffer which was created with the `VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT` or
///   `VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT` set in the `usage` member of the
///   [`BufferCreateInfo`] structure.
/// - [`max_uniform_buffer_range`] is the maximum value that  **can**  be specified in the `range`
///   member of a [`DescriptorBufferInfo`] structure passed to [`UpdateDescriptorSets`] for
///   descriptors of type `VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER` or
///   `VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC`.
/// - [`max_storage_buffer_range`] is the maximum value that  **can**  be specified in the `range`
///   member of a [`DescriptorBufferInfo`] structure passed to [`UpdateDescriptorSets`] for
///   descriptors of type `VK_DESCRIPTOR_TYPE_STORAGE_BUFFER` or
///   `VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC`.
/// - [`max_push_constants_size`] is the maximum size, in bytes, of the pool of push constant
///   memory. For each of the push constant ranges indicated by the `pPushConstantRanges` member of
///   the [`PipelineLayoutCreateInfo`] structure, (`offset` +  `size`) **must**  be less than or
///   equal to this limit.
/// - [`max_memory_allocation_count`] is the maximum number of device memory allocations, as created
///   by [`AllocateMemory`], which  **can**  simultaneously exist.
/// - [`max_sampler_allocation_count`] is the maximum number of sampler objects, as created by
///   [`CreateSampler`], which  **can**  simultaneously exist on a device.
/// - [`buffer_image_granularity`] is the granularity, in bytes, at which buffer or linear image resources, and optimal image resources  **can**  be bound to adjacent offsets in the same [`DeviceMemory`] object without aliasing. See [Buffer-Image Granularity](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#resources-bufferimagegranularity) for more details.
/// - [`sparse_address_space_size`] is the total amount of address space available, in bytes, for
///   sparse memory resources. This is an upper bound on the sum of the sizes of all sparse
///   resources, regardless of whether any memory is bound to them.
/// - [`max_bound_descriptor_sets`] is the maximum number of descriptor sets that  **can**  be simultaneously used by a pipeline. All [`DescriptorSet`] decorations in shader modules  **must**  have a value less than [`max_bound_descriptor_sets`]. See [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-sets](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-sets).
/// - [`max_per_stage_descriptor_samplers`] is the maximum number of samplers that  **can**  be accessible to a single shader stage in a pipeline layout. Descriptors with a type of `VK_DESCRIPTOR_TYPE_SAMPLER` or `VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER` count against this limit. Only descriptors in descriptor set layouts created without the `VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT` bit set count against this limit. A descriptor is accessible to a shader stage when the `stageFlags` member of the [`DescriptorSetLayoutBinding`] structure has the bit for that shader stage set. See [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-sampler](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-sampler) and [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-combinedimagesampler](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-combinedimagesampler).
/// - [`max_per_stage_descriptor_uniform_buffers`] is the maximum number of uniform buffers that  **can**  be accessible to a single shader stage in a pipeline layout. Descriptors with a type of `VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER` or `VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC` count against this limit. Only descriptors in descriptor set layouts created without the `VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT` bit set count against this limit. A descriptor is accessible to a shader stage when the `stageFlags` member of the [`DescriptorSetLayoutBinding`] structure has the bit for that shader stage set. See [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-uniformbuffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-uniformbuffer) and [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-uniformbufferdynamic](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-uniformbufferdynamic).
/// - [`max_per_stage_descriptor_storage_buffers`] is the maximum number of storage buffers that  **can**  be accessible to a single shader stage in a pipeline layout. Descriptors with a type of `VK_DESCRIPTOR_TYPE_STORAGE_BUFFER` or `VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC` count against this limit. Only descriptors in descriptor set layouts created without the `VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT` bit set count against this limit. A descriptor is accessible to a pipeline shader stage when the `stageFlags` member of the [`DescriptorSetLayoutBinding`] structure has the bit for that shader stage set. See [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storagebuffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storagebuffer) and [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storagebufferdynamic](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storagebufferdynamic).
/// - [`max_per_stage_descriptor_sampled_images`] is the maximum number of sampled images that  **can**  be accessible to a single shader stage in a pipeline layout. Descriptors with a type of `VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER`, `VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE`, or `VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER` count against this limit. Only descriptors in descriptor set layouts created without the `VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT` bit set count against this limit. A descriptor is accessible to a pipeline shader stage when the `stageFlags` member of the [`DescriptorSetLayoutBinding`] structure has the bit for that shader stage set. See [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-combinedimagesampler](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-combinedimagesampler), [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-sampledimage](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-sampledimage), and [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-uniformtexelbuffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-uniformtexelbuffer).
/// - [`max_per_stage_descriptor_storage_images`] is the maximum number of storage images that  **can**  be accessible to a single shader stage in a pipeline layout. Descriptors with a type of `VK_DESCRIPTOR_TYPE_STORAGE_IMAGE`, or `VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER` count against this limit. Only descriptors in descriptor set layouts created without the `VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT` bit set count against this limit. A descriptor is accessible to a pipeline shader stage when the `stageFlags` member of the [`DescriptorSetLayoutBinding`] structure has the bit for that shader stage set. See [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storageimage](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storageimage), and [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storagetexelbuffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storagetexelbuffer).
/// - [`max_per_stage_descriptor_input_attachments`] is the maximum number of input attachments that
///   **can**  be accessible to a single shader stage in a pipeline layout. Descriptors with a type of
///   `VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT` count against this limit. Only descriptors in descriptor
///   set layouts created without the `VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT` bit
///   set count against this limit. A descriptor is accessible to a pipeline shader stage when the `stageFlags`
///   member of the [`DescriptorSetLayoutBinding`] structure has the bit for that shader stage set. These
///   are only supported for the fragment stage. See [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-inputattachment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-inputattachment).
/// - [`max_per_stage_resources`] is the maximum number of resources that  **can**  be accessible to
///   a single shader stage in a pipeline layout. Descriptors with a type of
///   `VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER`, `VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE`,
///   `VK_DESCRIPTOR_TYPE_STORAGE_IMAGE`, `VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER`,
///   `VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER`, `VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER`,
///   `VK_DESCRIPTOR_TYPE_STORAGE_BUFFER`, `VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC`,
///   `VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC`, or `VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT` count
///   against this limit. Only descriptors in descriptor set layouts created without the
///   `VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT` bit set count against this limit.
///   For the fragment shader stage the framebuffer color attachments also count against this limit.
/// - [`max_descriptor_set_samplers`] is the maximum number of samplers that  **can**  be included in a pipeline layout. Descriptors with a type of `VK_DESCRIPTOR_TYPE_SAMPLER` or `VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER` count against this limit. Only descriptors in descriptor set layouts created without the `VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT` bit set count against this limit. See [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-sampler](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-sampler) and [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-combinedimagesampler](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-combinedimagesampler).
/// - [`max_descriptor_set_uniform_buffers`] is the maximum number of uniform buffers that  **can** 
///   be included in a pipeline layout. Descriptors with a type of `VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER`
///   or `VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC` count against this limit. Only descriptors in descriptor
///   set layouts created without the `VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT` bit
///   set count against this limit. See [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-uniformbuffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-uniformbuffer)
///   and [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-uniformbufferdynamic](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-uniformbufferdynamic).
/// - [`max_descriptor_set_uniform_buffers_dynamic`] is the maximum number of dynamic uniform buffers that  **can**  be included in a pipeline layout. Descriptors with a type of `VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC` count against this limit. Only descriptors in descriptor set layouts created without the `VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT` bit set count against this limit. See [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-uniformbufferdynamic](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-uniformbufferdynamic).
/// - [`max_descriptor_set_storage_buffers`] is the maximum number of storage buffers that  **can** 
///   be included in a pipeline layout. Descriptors with a type of `VK_DESCRIPTOR_TYPE_STORAGE_BUFFER`
///   or `VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC` count against this limit. Only descriptors in descriptor
///   set layouts created without the `VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT` bit
///   set count against this limit. See [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storagebuffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storagebuffer)
///   and [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storagebufferdynamic](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storagebufferdynamic).
/// - [`max_descriptor_set_storage_buffers_dynamic`] is the maximum number of dynamic storage buffers that  **can**  be included in a pipeline layout. Descriptors with a type of `VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC` count against this limit. Only descriptors in descriptor set layouts created without the `VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT` bit set count against this limit. See [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storagebufferdynamic](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storagebufferdynamic).
/// - [`max_descriptor_set_sampled_images`] is the maximum number of sampled images that  **can**  be included in a pipeline layout. Descriptors with a type of `VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER`, `VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE`, or `VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER` count against this limit. Only descriptors in descriptor set layouts created without the `VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT` bit set count against this limit. See [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-combinedimagesampler](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-combinedimagesampler), [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-sampledimage](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-sampledimage), and [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-uniformtexelbuffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-uniformtexelbuffer).
/// - [`max_descriptor_set_storage_images`] is the maximum number of storage images that  **can**  be included in a pipeline layout. Descriptors with a type of `VK_DESCRIPTOR_TYPE_STORAGE_IMAGE`, or `VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER` count against this limit. Only descriptors in descriptor set layouts created without the `VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT` bit set count against this limit. See [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storageimage](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storageimage), and [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storagetexelbuffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storagetexelbuffer).
/// - [`max_descriptor_set_input_attachments`] is the maximum number of input attachments that  **can**  be included in a pipeline layout. Descriptors with a type of `VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT` count against this limit. Only descriptors in descriptor set layouts created without the `VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT` bit set count against this limit. See [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-inputattachment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-inputattachment).
/// - [`max_vertex_input_attributes`] is the maximum number of vertex input attributes that  **can**
///   be specified for a graphics pipeline. These are described in the array of [`VertexInputAttributeDescription`]
///   structures that are provided at graphics pipeline creation time via the `pVertexAttributeDescriptions`
///   member of the [`PipelineVertexInputStateCreateInfo`] structure. See [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fxvertex-attrib](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fxvertex-attrib)
///   and [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fxvertex-input](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fxvertex-input).
/// - [`max_vertex_input_bindings`] is the maximum number of vertex buffers that  **can**  be specified for providing vertex attributes to a graphics pipeline. These are described in the array of [`VertexInputBindingDescription`] structures that are provided at graphics pipeline creation time via the `pVertexBindingDescriptions` member of the [`PipelineVertexInputStateCreateInfo`] structure. The `binding` member of [`VertexInputBindingDescription`] **must**  be less than this limit. See [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fxvertex-input](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fxvertex-input).
/// - [`max_vertex_input_attribute_offset`] is the maximum vertex input attribute offset that  **can**  be added to the vertex input binding stride. The `offset` member of the [`VertexInputAttributeDescription`] structure  **must**  be less than or equal to this limit. See [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fxvertex-input](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fxvertex-input).
/// - [`max_vertex_input_binding_stride`] is the maximum vertex input binding stride that  **can**  be specified in a vertex input binding. The `stride` member of the [`VertexInputBindingDescription`] structure  **must**  be less than or equal to this limit. See [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fxvertex-input](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fxvertex-input).
/// - [`max_vertex_output_components`] is the maximum number of components of output variables which
///   **can**  be output by a vertex shader. See [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#shaders-vertex](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#shaders-vertex).
/// - [`max_tessellation_generation_level`] is the maximum tessellation generation level supported by the fixed-function tessellation primitive generator. See [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#tessellation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#tessellation).
/// - [`max_tessellation_patch_size`] is the maximum patch size, in vertices, of patches that  **can**  be processed by the tessellation control shader and tessellation primitive generator. The `patchControlPoints` member of the [`PipelineTessellationStateCreateInfo`] structure specified at pipeline creation time and the value provided in the `OutputVertices` execution mode of shader modules  **must**  be less than or equal to this limit. See [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#tessellation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#tessellation).
/// - [`max_tessellation_control_per_vertex_input_components`] is the maximum number of components
///   of input variables which  **can**  be provided as per-vertex inputs to the tessellation
///   control shader stage.
/// - [`max_tessellation_control_per_vertex_output_components`] is the maximum number of components
///   of per-vertex output variables which  **can**  be output from the tessellation control shader
///   stage.
/// - [`max_tessellation_control_per_patch_output_components`] is the maximum number of components
///   of per-patch output variables which  **can**  be output from the tessellation control shader
///   stage.
/// - [`max_tessellation_control_total_output_components`] is the maximum total number of components
///   of per-vertex and per-patch output variables which  **can**  be output from the tessellation
///   control shader stage.
/// - [`max_tessellation_evaluation_input_components`] is the maximum number of components of input
///   variables which  **can**  be provided as per-vertex inputs to the tessellation evaluation
///   shader stage.
/// - [`max_tessellation_evaluation_output_components`] is the maximum number of components of
///   per-vertex output variables which  **can**  be output from the tessellation evaluation shader
///   stage.
/// - [`max_geometry_shader_invocations`] is the maximum invocation count supported for instanced geometry shaders. The value provided in the `Invocations` execution mode of shader modules  **must**  be less than or equal to this limit. See [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#geometry](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#geometry).
/// - [`max_geometry_input_components`] is the maximum number of components of input variables which
///   **can**  be provided as inputs to the geometry shader stage.
/// - [`max_geometry_output_components`] is the maximum number of components of output variables
///   which  **can**  be output from the geometry shader stage.
/// - [`max_geometry_output_vertices`] is the maximum number of vertices which  **can**  be emitted
///   by any geometry shader.
/// - [`max_geometry_total_output_components`] is the maximum total number of components of output
///   variables, across all emitted vertices, which  **can**  be output from the geometry shader
///   stage.
/// - [`max_fragment_input_components`] is the maximum number of components of input variables which
///   **can**  be provided as inputs to the fragment shader stage.
/// - [`max_fragment_output_attachments`] is the maximum number of output attachments which  **can**
///   be written to by the fragment shader stage.
/// - [`max_fragment_dual_src_attachments`] is the maximum number of output attachments which  **can**  be written to by the fragment shader stage when blending is enabled and one of the dual source blend modes is in use. See [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#framebuffer-dsb](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#framebuffer-dsb) and [dualSrcBlend](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-dualSrcBlend).
/// - [`max_fragment_combined_output_resources`] is the total number of storage buffers, storage images, and output `Location` decorated color attachments (described in [Fragment Output Interface](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#interfaces-fragmentoutput)) which  **can**  be used in the fragment shader stage.
/// - [`max_compute_shared_memory_size`] is the maximum total storage size, in bytes, available for variables declared with the `Workgroup` storage class in shader modules (or with the `shared` storage qualifier in GLSL) in the compute shader stage. When variables declared with the `Workgroup` storage class are explicitly laid out (hence they are also decorated with `Block`), the amount of storage consumed is the size of the largest Block variable, not counting any padding at the end. The amount of storage consumed by the non-Block variables declared with the `Workgroup` storage class is implementation-dependent. However, the amount of storage consumed may not exceed the largest block size that would be obtained if all active non-Block variables declared with `Workgroup` storage class were assigned offsets in an arbitrary order by successively taking the smallest valid offset according to the [Standard Storage Buffer Layout](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#interfaces-resources-standard-layout) rules. (This is equivalent to using the GLSL std430 layout rules.)
/// - [`max_compute_work_group_count`][3] is the maximum number of local workgroups that  **can**  be dispatched by a single dispatching command. These three values represent the maximum number of local workgroups for the X, Y, and Z dimensions, respectively. The workgroup count parameters to the dispatching commands  **must**  be less than or equal to the corresponding limit. See [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#dispatch](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#dispatch).
/// - [`max_compute_work_group_invocations`] is the maximum total number of     compute shader
///   invocations in a single local workgroup.     The product of the X, Y, and Z sizes, as
///   specified by the `LocalSize` or `LocalSizeId`     execution mode in shader modules or by the
///   object decorated by the     `WorkgroupSize` decoration,  **must**  be less than or equal to
///   this     limit.
/// - [`max_compute_work_group_size`][3] is     the maximum size of a local compute workgroup, per
///   dimension.     These three values represent the maximum local workgroup size in the X,     Y,
///   and Z dimensions, respectively.     The `x`, `y`, and `z` sizes, as specified by the
///   `LocalSize` or `LocalSizeId`     execution mode or by the object decorated by the
///   `WorkgroupSize`     decoration in shader modules,  **must**  be less than or equal to the
///   corresponding limit.
/// - [`sub_pixel_precision_bits`] is the number of bits of subpixel precision in framebuffer coordinates x<sub>f</sub> and y<sub>f</sub>. See [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#primsrast](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#primsrast).
/// - [`sub_texel_precision_bits`] is the number of bits of precision in the division along an axis
///   of an image used for minification and magnification filters.
///   2<sup>[`sub_texel_precision_bits`]</sup> is the actual number of divisions along each axis of
///   the image represented. Sub-texel values calculated during image sampling will snap to these
///   locations when generating the filtered results.
/// - [`mipmap_precision_bits`] is the number of bits of division that the LOD calculation for
///   mipmap fetching get snapped to when determining the contribution from each mip level to the
///   mip filtered results. 2<sup>[`mipmap_precision_bits`]</sup> is the actual number of divisions.
/// - [`max_draw_indexed_index_value`] is the maximum index value that  **can**  be used for indexed
///   draw calls when using 32-bit indices. This excludes the primitive restart index value of 0xFFFFFFFF.
///   See [fullDrawIndexUint32](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-fullDrawIndexUint32).
/// - [`max_draw_indirect_count`] is the maximum draw count that is supported for indirect drawing calls. See [multiDrawIndirect](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-multiDrawIndirect).
/// - [`max_sampler_lod_bias`] is the maximum absolute sampler LOD bias. The sum of the `mipLodBias`
///   member of the [`SamplerCreateInfo`] structure and the `Bias` operand of image sampling operations
///   in shader modules (or 0 if no `Bias` operand is provided to an image sampling operation) are clamped
///   to the range [-[`max_sampler_lod_bias`],+[`max_sampler_lod_bias`]]. See [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#samplers-mipLodBias](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#samplers-mipLodBias).
/// - [`max_sampler_anisotropy`] is the maximum degree of sampler anisotropy. The maximum degree of anisotropic filtering used for an image sampling operation is the minimum of the `maxAnisotropy` member of the [`SamplerCreateInfo`] structure and this limit. See [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#samplers-maxAnisotropy](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#samplers-maxAnisotropy).
/// - [`max_viewports`] is the maximum number of active viewports. The `viewportCount` member of the
///   [`PipelineViewportStateCreateInfo`] structure that is provided at pipeline creation  **must**
///   be less than or equal to this limit.
/// - [`max_viewport_dimensions`][2] are the maximum viewport dimensions in the X (width) and Y (height) dimensions, respectively. The maximum viewport dimensions  **must**  be greater than or equal to the largest image which  **can**  be created and used as a framebuffer attachment. See [Controlling the Viewport](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#vertexpostproc-viewport).
/// - [`viewport_bounds_range`][2] is the [minimum, maximum] range that the corners of a viewport  **must**  be contained in. This range  **must**  be at least [-2 × `size`, 2 × `size` - 1], where `size` = max([`max_viewport_dimensions`][0], [`max_viewport_dimensions`][1]). See [Controlling the Viewport](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#vertexpostproc-viewport).
/// - [`viewport_sub_pixel_bits`] is the number of bits of subpixel precision for viewport bounds.
///   The subpixel precision that floating-point viewport bounds are interpreted at is given by this
///   limit.
/// - [`min_memory_map_alignment`] is the minimum  **required**  alignment, in bytes, of host visible memory allocations within the host address space. When mapping a memory allocation with [`MapMemory`], subtracting `offset` bytes from the returned pointer will always produce an integer multiple of this limit. See [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#memory-device-hostaccess](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#memory-device-hostaccess). The value  **must**  be a power of two.
/// - [`min_texel_buffer_offset_alignment`] is the minimum  **required**  alignment, in bytes, for the `offset` member of the [`BufferViewCreateInfo`] structure for texel buffers. The value  **must**  be a power of two. If [texelBufferAlignment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-texelBufferAlignment) is enabled, this limit is equivalent to the maximum of the [`uniformTexelBufferOffsetAlignmentBytes`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#limits-uniformTexelBufferOffsetAlignmentBytes) and [`storageTexelBufferOffsetAlignmentBytes`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#limits-storageTexelBufferOffsetAlignmentBytes) members of [`PhysicalDeviceTexelBufferAlignmentProperties`], but smaller alignment is  **optionally**  allowed by [`storageTexelBufferOffsetSingleTexelAlignment`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#limits-storageTexelBufferOffsetSingleTexelAlignment) and [`uniformTexelBufferOffsetSingleTexelAlignment`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#limits-uniformTexelBufferOffsetSingleTexelAlignment). If [texelBufferAlignment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-texelBufferAlignment) is not enabled, [`BufferViewCreateInfo::offset`] **must**  be a multiple of this value.
/// - [`min_uniform_buffer_offset_alignment`] is the minimum  **required**  alignment, in bytes, for
///   the `offset` member of the [`DescriptorBufferInfo`] structure for uniform buffers. When a
///   descriptor of type `VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER` or
///   `VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC` is updated, the `offset` **must**  be an integer
///   multiple of this limit. Similarly, dynamic offsets for uniform buffers  **must**  be multiples
///   of this limit. The value  **must**  be a power of two.
/// - [`min_storage_buffer_offset_alignment`] is the minimum  **required**  alignment, in bytes, for
///   the `offset` member of the [`DescriptorBufferInfo`] structure for storage buffers. When a
///   descriptor of type `VK_DESCRIPTOR_TYPE_STORAGE_BUFFER` or
///   `VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC` is updated, the `offset` **must**  be an integer
///   multiple of this limit. Similarly, dynamic offsets for storage buffers  **must**  be multiples
///   of this limit. The value  **must**  be a power of two.
/// - [`min_texel_offset`] is the minimum offset value for the `ConstOffset` image operand of any of
///   the `OpImageSample*` or `OpImageFetch*` image instructions.
/// - [`max_texel_offset`] is the maximum offset value for the `ConstOffset` image operand of any of
///   the `OpImageSample*` or `OpImageFetch*` image instructions.
/// - [`min_texel_gather_offset`] is the minimum offset value for the `Offset`, `ConstOffset`, or
///   `ConstOffsets` image operands of any of the `OpImage*Gather` image instructions.
/// - [`max_texel_gather_offset`] is the maximum offset value for the `Offset`, `ConstOffset`, or
///   `ConstOffsets` image operands of any of the `OpImage*Gather` image instructions.
/// - [`min_interpolation_offset`] is the base minimum (inclusive) negative offset value for the
///   `Offset` operand of the `InterpolateAtOffset` extended instruction.
/// - [`max_interpolation_offset`] is the base maximum (inclusive) positive offset value for the
///   `Offset` operand of the `InterpolateAtOffset` extended instruction.
/// - [`sub_pixel_interpolation_offset_bits`] is the number of fractional bits that the `x` and `y`
///   offsets to the `InterpolateAtOffset` extended instruction  **may**  be rounded to as
///   fixed-point values.
/// - [`max_framebuffer_width`] is the maximum width for a framebuffer. The `width` member of the
///   [`FramebufferCreateInfo`] structure  **must**  be less than or equal to this limit.
/// - [`max_framebuffer_height`] is the maximum height for a framebuffer. The `height` member of the
///   [`FramebufferCreateInfo`] structure  **must**  be less than or equal to this limit.
/// - [`max_framebuffer_layers`] is the maximum layer count for a layered framebuffer. The `layers`
///   member of the [`FramebufferCreateInfo`] structure  **must**  be less than or equal to this
///   limit.
/// - [`framebuffer_color_sample_counts`] is a bitmask<sup>1</sup> of [`SampleCountFlagBits`] indicating the color sample counts that are supported for all framebuffer color attachments with floating- or fixed-point formats. For color attachments with integer formats, see [`framebufferIntegerColorSampleCounts`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#limits-framebufferIntegerColorSampleCounts).
/// - [`framebuffer_depth_sample_counts`] is a bitmask<sup>1</sup> of [`SampleCountFlagBits`]
///   indicating the supported depth sample counts for all framebuffer depth/stencil attachments,
///   when the format includes a depth component.
/// - [`framebuffer_stencil_sample_counts`] is a bitmask<sup>1</sup> of [`SampleCountFlagBits`]
///   indicating the supported stencil sample counts for all framebuffer depth/stencil attachments,
///   when the format includes a stencil component.
/// - [`framebuffer_no_attachments_sample_counts`] is a bitmask<sup>1</sup> of [`SampleCountFlagBits`] indicating the supported sample counts for a [subpass which uses no attachments](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-noattachments).
/// - [`max_color_attachments`] is the maximum number of color attachments that  **can**  be used by
///   a subpass in a render pass. The `colorAttachmentCount` member of the [`SubpassDescription`] or
///   [`SubpassDescription2`] structure  **must**  be less than or equal to this limit.
/// - [`sampled_image_color_sample_counts`] is a bitmask<sup>1</sup> of [`SampleCountFlagBits`]
///   indicating the sample counts supported for all 2D images created with
///   `VK_IMAGE_TILING_OPTIMAL`, `usage` containing `VK_IMAGE_USAGE_SAMPLED_BIT`, and a non-integer
///   color format.
/// - [`sampled_image_integer_sample_counts`] is a bitmask<sup>1</sup> of [`SampleCountFlagBits`]
///   indicating the sample counts supported for all 2D images created with
///   `VK_IMAGE_TILING_OPTIMAL`, `usage` containing `VK_IMAGE_USAGE_SAMPLED_BIT`, and an integer
///   color format.
/// - [`sampled_image_depth_sample_counts`] is a bitmask<sup>1</sup> of [`SampleCountFlagBits`]
///   indicating the sample counts supported for all 2D images created with
///   `VK_IMAGE_TILING_OPTIMAL`, `usage` containing `VK_IMAGE_USAGE_SAMPLED_BIT`, and a depth
///   format.
/// - [`sampled_image_stencil_sample_counts`] is a bitmask<sup>1</sup> of [`SampleCountFlagBits`]
///   indicating the sample counts supported for all 2D images created with
///   `VK_IMAGE_TILING_OPTIMAL`, `usage` containing `VK_IMAGE_USAGE_SAMPLED_BIT`, and a stencil
///   format.
/// - [`storage_image_sample_counts`] is a bitmask<sup>1</sup> of [`SampleCountFlagBits`] indicating
///   the sample counts supported for all 2D images created with `VK_IMAGE_TILING_OPTIMAL`, and
///   `usage` containing `VK_IMAGE_USAGE_STORAGE_BIT`.
/// - [`max_sample_mask_words`] is the maximum number of array elements of a variable decorated with
///   the [`SampleMask`] built-in decoration.
/// - [`timestamp_compute_and_graphics`] specifies support for timestamps on all graphics and compute queues. If this limit is set to [`TRUE`], all queues that advertise the `VK_QUEUE_GRAPHICS_BIT` or `VK_QUEUE_COMPUTE_BIT` in the [`QueueFamilyProperties::queue_flags`] support [`QueueFamilyProperties::timestamp_valid_bits`] of at least 36. See [Timestamp Queries](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#queries-timestamps).
/// - [`timestamp_period`] is the number of nanoseconds  **required**  for a timestamp query to be incremented by 1. See [Timestamp Queries](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#queries-timestamps).
/// - [`max_clip_distances`] is the maximum number of clip distances that  **can**  be used in a
///   single shader stage. The size of any array declared with the `ClipDistance` built-in
///   decoration in a shader module  **must**  be less than or equal to this limit.
/// - [`max_cull_distances`] is the maximum number of cull distances that  **can**  be used in a
///   single shader stage. The size of any array declared with the `CullDistance` built-in
///   decoration in a shader module  **must**  be less than or equal to this limit.
/// - [`max_combined_clip_and_cull_distances`] is the maximum combined number of clip and cull
///   distances that  **can**  be used in a single shader stage. The sum of the sizes of any pair of
///   arrays declared with the `ClipDistance` and `CullDistance` built-in decoration used by a
///   single shader stage in a shader module  **must**  be less than or equal to this limit.
/// - [`discrete_queue_priorities`] is the number of discrete priorities that  **can**  be assigned to a queue based on the value of each member of [`DeviceQueueCreateInfo::queue_priorities`]. This  **must**  be at least 2, and levels  **must**  be spread evenly over the range, with at least one level at 1.0, and another at 0.0. See [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#devsandqueues-priority](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#devsandqueues-priority).
/// - [`point_size_range`][2] is the range [`minimum`,`maximum`] of supported sizes for points.
///   Values written to variables decorated with the `PointSize` built-in decoration are clamped to
///   this range.
/// - [`line_width_range`][2] is the range [`minimum`,`maximum`] of supported widths for lines.
///   Values specified by the `lineWidth` member of the [`PipelineRasterizationStateCreateInfo`] or
///   the `lineWidth` parameter to [`CmdSetLineWidth`] are clamped to this range.
/// - [`point_size_granularity`] is the granularity of supported point sizes. Not all point sizes in
///   the range defined by [`point_size_range`] are supported. This limit specifies the granularity
///   (or increment) between successive supported point sizes.
/// - [`line_width_granularity`] is the granularity of supported line widths. Not all line widths in
///   the range defined by [`line_width_range`] are supported. This limit specifies the granularity
///   (or increment) between successive supported line widths.
/// - [`strict_lines`] specifies whether lines are rasterized according to the preferred method of rasterization. If set to [`FALSE`], lines  **may**  be rasterized under a relaxed set of rules. If set to [`TRUE`], lines are rasterized as per the strict definition. See [Basic Line Segment Rasterization](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#primsrast-lines-basic).
/// - [`standard_sample_locations`] specifies whether rasterization uses the standard sample locations as documented in [Multisampling](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#primsrast-multisampling). If set to [`TRUE`], the implementation uses the documented sample locations. If set to [`FALSE`], the implementation  **may**  use different sample locations.
/// - [`optimal_buffer_copy_offset_alignment`] is the optimal buffer offset alignment in bytes for
///   [`CmdCopyBufferToImage2`], [`CmdCopyBufferToImage`], [`CmdCopyImageToBuffer2`], and
///   [`CmdCopyImageToBuffer`]. The per texel alignment requirements are enforced, but applications
///   **should**  use the optimal alignment for optimal performance and power use. The value
///   **must**  be a power of two.
/// - [`optimal_buffer_copy_row_pitch_alignment`] is the optimal buffer row pitch alignment in bytes
///   for [`CmdCopyBufferToImage2`], [`CmdCopyBufferToImage`], [`CmdCopyImageToBuffer2`], and
///   [`CmdCopyImageToBuffer`]. Row pitch is the number of bytes between texels with the same X
///   coordinate in adjacent rows (Y coordinates differ by one). The per texel alignment
///   requirements are enforced, but applications  **should**  use the optimal alignment for optimal
///   performance and power use. The value  **must**  be a power of two.
/// - [`non_coherent_atom_size`] is the size and alignment in bytes that bounds concurrent access to
///   [host-mapped device memory](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#memory-device-hostaccess).
///   The value  **must**  be a power of two.  * For all bitmasks of [`SampleCountFlagBits`], the sample
///   count limits defined above represent the minimum supported sample counts for each image type. Individual
///   images  **may**  support additional sample counts, which are queried using [`GetPhysicalDeviceImageFormatProperties`]
///   as described in [Supported Sample Counts](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-supported-sample-counts).
///# Related
/// - [`crate::vulkan1_0`]
/// - [`Bool32`]
/// - [`DeviceSize`]
/// - [`PhysicalDeviceProperties`]
/// - [`SampleCountFlags`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, PartialEq, PartialOrd)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct PhysicalDeviceLimits {
    ///[`max_image_dimension_1_d`] is the largest
    ///dimension (`width`) that is guaranteed to be supported for all
    ///images created with an `imageType` of `VK_IMAGE_TYPE_1D`.
    ///Some combinations of image parameters (format, usage, etc.)  **may**  allow
    ///support for larger dimensions, which  **can**  be queried using
    ///[`GetPhysicalDeviceImageFormatProperties`].
    max_image_dimension_1_d: u32,
    ///[`max_image_dimension_2_d`] is the largest
    ///dimension (`width` or `height`) that is guaranteed to be
    ///supported for all images created with an `imageType` of
    ///`VK_IMAGE_TYPE_2D` and without
    ///`VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT` set in `flags`.
    ///Some combinations of image parameters (format, usage, etc.)  **may**  allow
    ///support for larger dimensions, which  **can**  be queried using
    ///[`GetPhysicalDeviceImageFormatProperties`].
    max_image_dimension_2_d: u32,
    ///[`max_image_dimension_3_d`] is the largest
    ///dimension (`width`, `height`, or `depth`) that is guaranteed
    ///to be supported for all images created with an `imageType` of
    ///`VK_IMAGE_TYPE_3D`.
    ///Some combinations of image parameters (format, usage, etc.)  **may**  allow
    ///support for larger dimensions, which  **can**  be queried using
    ///[`GetPhysicalDeviceImageFormatProperties`].
    max_image_dimension_3_d: u32,
    ///[`max_image_dimension_cube`] is the
    ///largest dimension (`width` or `height`) that is guaranteed to be
    ///supported for all images created with an `imageType` of
    ///`VK_IMAGE_TYPE_2D` and with
    ///`VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT` set in `flags`.
    ///Some combinations of image parameters (format, usage, etc.)  **may**  allow
    ///support for larger dimensions, which  **can**  be queried using
    ///[`GetPhysicalDeviceImageFormatProperties`].
    max_image_dimension_cube: u32,
    ///[`max_image_array_layers`] is the maximum
    ///number of layers (`arrayLayers`) for an image.
    max_image_array_layers: u32,
    ///[`max_texel_buffer_elements`] is the
    ///maximum number of addressable texels for a buffer view created on a
    ///buffer which was created with the
    ///`VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT` or
    ///`VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT` set in the `usage`
    ///member of the [`BufferCreateInfo`] structure.
    max_texel_buffer_elements: u32,
    ///[`max_uniform_buffer_range`] is the
    ///maximum value that  **can**  be specified in the `range` member of a
    ///[`DescriptorBufferInfo`] structure passed to
    ///[`UpdateDescriptorSets`] for descriptors of type
    ///`VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER` or
    ///`VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC`.
    max_uniform_buffer_range: u32,
    ///[`max_storage_buffer_range`] is the
    ///maximum value that  **can**  be specified in the `range` member of a
    ///[`DescriptorBufferInfo`] structure passed to
    ///[`UpdateDescriptorSets`] for descriptors of type
    ///`VK_DESCRIPTOR_TYPE_STORAGE_BUFFER` or
    ///`VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC`.
    max_storage_buffer_range: u32,
    ///[`max_push_constants_size`] is the
    ///maximum size, in bytes, of the pool of push constant memory.
    ///For each of the push constant ranges indicated by the
    ///`pPushConstantRanges` member of the [`PipelineLayoutCreateInfo`]
    ///structure, (`offset` +  `size`) **must**  be less than or
    ///equal to this limit.
    max_push_constants_size: u32,
    ///[`max_memory_allocation_count`] is
    ///the maximum number of device memory allocations, as created by
    ///[`AllocateMemory`], which  **can**  simultaneously exist.
    max_memory_allocation_count: u32,
    ///[`max_sampler_allocation_count`] is
    ///the maximum number of sampler objects, as created by
    ///[`CreateSampler`], which  **can**  simultaneously exist on a device.
    max_sampler_allocation_count: u32,
    ///[`buffer_image_granularity`] is the
    ///granularity, in bytes, at which buffer or linear image resources, and
    ///optimal image resources  **can**  be bound to adjacent offsets in the same
    ///[`DeviceMemory`] object without aliasing.
    ///See [Buffer-Image Granularity](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#resources-bufferimagegranularity) for
    ///more details.
    buffer_image_granularity: DeviceSize,
    ///[`sparse_address_space_size`] is the
    ///total amount of address space available, in bytes, for sparse memory
    ///resources.
    ///This is an upper bound on the sum of the sizes of all sparse resources,
    ///regardless of whether any memory is bound to them.
    sparse_address_space_size: DeviceSize,
    ///[`max_bound_descriptor_sets`] is the
    ///maximum number of descriptor sets that  **can**  be simultaneously used by a
    ///pipeline.
    ///All [`DescriptorSet`] decorations in shader modules  **must**  have a value
    ///less than [`max_bound_descriptor_sets`].
    ///See [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-sets](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-sets).
    max_bound_descriptor_sets: u32,
    ///[`max_per_stage_descriptor_samplers`] is the maximum number of samplers
    ///that  **can**  be accessible to a single shader stage in a pipeline layout.
    ///Descriptors with a type of `VK_DESCRIPTOR_TYPE_SAMPLER` or
    ///`VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER` count against this
    ///limit.
    ///Only descriptors in descriptor set layouts created without the
    ///`VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT` bit set
    ///count against this limit.
    ///A descriptor is accessible to a shader stage when the `stageFlags`
    ///member of the [`DescriptorSetLayoutBinding`] structure has the bit
    ///for that shader stage set.
    ///See [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-sampler](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-sampler) and
    ///[https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-combinedimagesampler](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-combinedimagesampler).
    max_per_stage_descriptor_samplers: u32,
    ///[`max_per_stage_descriptor_uniform_buffers`] is the maximum number of
    ///uniform buffers that  **can**  be accessible to a single shader stage in a
    ///pipeline layout.
    ///Descriptors with a type of `VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER` or
    ///`VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC` count against this
    ///limit.
    ///Only descriptors in descriptor set layouts created without the
    ///`VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT` bit set
    ///count against this limit.
    ///A descriptor is accessible to a shader stage when the `stageFlags`
    ///member of the [`DescriptorSetLayoutBinding`] structure has the bit
    ///for that shader stage set.
    ///See [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-uniformbuffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-uniformbuffer) and
    ///[https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-uniformbufferdynamic](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-uniformbufferdynamic).
    max_per_stage_descriptor_uniform_buffers: u32,
    ///[`max_per_stage_descriptor_storage_buffers`] is the maximum number of
    ///storage buffers that  **can**  be accessible to a single shader stage in a
    ///pipeline layout.
    ///Descriptors with a type of `VK_DESCRIPTOR_TYPE_STORAGE_BUFFER` or
    ///`VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC` count against this
    ///limit.
    ///Only descriptors in descriptor set layouts created without the
    ///`VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT` bit set
    ///count against this limit.
    ///A descriptor is accessible to a pipeline shader stage when the
    ///`stageFlags` member of the [`DescriptorSetLayoutBinding`]
    ///structure has the bit for that shader stage set.
    ///See [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storagebuffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storagebuffer) and
    ///[https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storagebufferdynamic](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storagebufferdynamic).
    max_per_stage_descriptor_storage_buffers: u32,
    ///[`max_per_stage_descriptor_sampled_images`] is the maximum number of
    ///sampled images that  **can**  be accessible to a single shader stage in a
    ///pipeline layout.
    ///Descriptors with a type of
    ///`VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER`,
    ///`VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE`, or
    ///`VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER` count against this limit.
    ///Only descriptors in descriptor set layouts created without the
    ///`VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT` bit set
    ///count against this limit.
    ///A descriptor is accessible to a pipeline shader stage when the
    ///`stageFlags` member of the [`DescriptorSetLayoutBinding`]
    ///structure has the bit for that shader stage set.
    ///See [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-combinedimagesampler](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-combinedimagesampler),
    ///[https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-sampledimage](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-sampledimage), and
    ///[https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-uniformtexelbuffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-uniformtexelbuffer).
    max_per_stage_descriptor_sampled_images: u32,
    ///[`max_per_stage_descriptor_storage_images`] is the maximum number of
    ///storage images that  **can**  be accessible to a single shader stage in a
    ///pipeline layout.
    ///Descriptors with a type of `VK_DESCRIPTOR_TYPE_STORAGE_IMAGE`, or
    ///`VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER` count against this limit.
    ///Only descriptors in descriptor set layouts created without the
    ///`VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT` bit set
    ///count against this limit.
    ///A descriptor is accessible to a pipeline shader stage when the
    ///`stageFlags` member of the [`DescriptorSetLayoutBinding`]
    ///structure has the bit for that shader stage set.
    ///See [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storageimage](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storageimage), and
    ///[https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storagetexelbuffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storagetexelbuffer).
    max_per_stage_descriptor_storage_images: u32,
    ///[`max_per_stage_descriptor_input_attachments`] is the maximum number of
    ///input attachments that  **can**  be accessible to a single shader stage in a
    ///pipeline layout.
    ///Descriptors with a type of `VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT`
    ///count against this limit.
    ///Only descriptors in descriptor set layouts created without the
    ///`VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT` bit set
    ///count against this limit.
    ///A descriptor is accessible to a pipeline shader stage when the
    ///`stageFlags` member of the [`DescriptorSetLayoutBinding`]
    ///structure has the bit for that shader stage set.
    ///These are only supported for the fragment stage.
    ///See [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-inputattachment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-inputattachment).
    max_per_stage_descriptor_input_attachments: u32,
    ///[`max_per_stage_resources`] is the
    ///maximum number of resources that  **can**  be accessible to a single shader
    ///stage in a pipeline layout.
    ///Descriptors with a type of
    ///`VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER`,
    ///`VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE`,
    ///`VK_DESCRIPTOR_TYPE_STORAGE_IMAGE`,
    ///`VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER`,
    ///`VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER`,
    ///`VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER`,
    ///`VK_DESCRIPTOR_TYPE_STORAGE_BUFFER`,
    ///`VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC`,
    ///`VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC`, or
    ///`VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT` count against this limit.
    ///Only descriptors in descriptor set layouts created without the
    ///`VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT` bit set
    ///count against this limit.
    ///For the fragment shader stage the framebuffer color attachments also
    ///count against this limit.
    max_per_stage_resources: u32,
    ///[`max_descriptor_set_samplers`] is
    ///the maximum number of samplers that  **can**  be included in a pipeline
    ///layout.
    ///Descriptors with a type of `VK_DESCRIPTOR_TYPE_SAMPLER` or
    ///`VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER` count against this
    ///limit.
    ///Only descriptors in descriptor set layouts created without the
    ///`VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT` bit set
    ///count against this limit.
    ///See [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-sampler](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-sampler) and
    ///[https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-combinedimagesampler](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-combinedimagesampler).
    max_descriptor_set_samplers: u32,
    ///[`max_descriptor_set_uniform_buffers`] is the maximum number of uniform
    ///buffers that  **can**  be included in a pipeline layout.
    ///Descriptors with a type of `VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER` or
    ///`VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC` count against this
    ///limit.
    ///Only descriptors in descriptor set layouts created without the
    ///`VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT` bit set
    ///count against this limit.
    ///See [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-uniformbuffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-uniformbuffer) and
    ///[https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-uniformbufferdynamic](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-uniformbufferdynamic).
    max_descriptor_set_uniform_buffers: u32,
    ///[`max_descriptor_set_uniform_buffers_dynamic`] is the maximum number of
    ///dynamic uniform buffers that  **can**  be included in a pipeline layout.
    ///Descriptors with a type of
    ///`VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC` count against this
    ///limit.
    ///Only descriptors in descriptor set layouts created without the
    ///`VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT` bit set
    ///count against this limit.
    ///See [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-uniformbufferdynamic](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-uniformbufferdynamic).
    max_descriptor_set_uniform_buffers_dynamic: u32,
    ///[`max_descriptor_set_storage_buffers`] is the maximum number of storage
    ///buffers that  **can**  be included in a pipeline layout.
    ///Descriptors with a type of `VK_DESCRIPTOR_TYPE_STORAGE_BUFFER` or
    ///`VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC` count against this
    ///limit.
    ///Only descriptors in descriptor set layouts created without the
    ///`VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT` bit set
    ///count against this limit.
    ///See [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storagebuffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storagebuffer) and
    ///[https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storagebufferdynamic](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storagebufferdynamic).
    max_descriptor_set_storage_buffers: u32,
    ///[`max_descriptor_set_storage_buffers_dynamic`] is the maximum number of
    ///dynamic storage buffers that  **can**  be included in a pipeline layout.
    ///Descriptors with a type of
    ///`VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC` count against this
    ///limit.
    ///Only descriptors in descriptor set layouts created without the
    ///`VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT` bit set
    ///count against this limit.
    ///See [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storagebufferdynamic](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storagebufferdynamic).
    max_descriptor_set_storage_buffers_dynamic: u32,
    ///[`max_descriptor_set_sampled_images`] is the maximum number of sampled
    ///images that  **can**  be included in a pipeline layout.
    ///Descriptors with a type of
    ///`VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER`,
    ///`VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE`, or
    ///`VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER` count against this limit.
    ///Only descriptors in descriptor set layouts created without the
    ///`VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT` bit set
    ///count against this limit.
    ///See [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-combinedimagesampler](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-combinedimagesampler),
    ///[https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-sampledimage](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-sampledimage), and
    ///[https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-uniformtexelbuffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-uniformtexelbuffer).
    max_descriptor_set_sampled_images: u32,
    ///[`max_descriptor_set_storage_images`] is the maximum number of storage
    ///images that  **can**  be included in a pipeline layout.
    ///Descriptors with a type of `VK_DESCRIPTOR_TYPE_STORAGE_IMAGE`, or
    ///`VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER` count against this limit.
    ///Only descriptors in descriptor set layouts created without the
    ///`VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT` bit set
    ///count against this limit.
    ///See [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storageimage](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storageimage), and
    ///[https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storagetexelbuffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storagetexelbuffer).
    max_descriptor_set_storage_images: u32,
    ///[`max_descriptor_set_input_attachments`] is the maximum number of input
    ///attachments that  **can**  be included in a pipeline layout.
    ///Descriptors with a type of `VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT`
    ///count against this limit.
    ///Only descriptors in descriptor set layouts created without the
    ///`VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT` bit set
    ///count against this limit.
    ///See [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-inputattachment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-inputattachment).
    max_descriptor_set_input_attachments: u32,
    ///[`max_vertex_input_attributes`] is
    ///the maximum number of vertex input attributes that  **can**  be specified for
    ///a graphics pipeline.
    ///These are described in the array of
    ///[`VertexInputAttributeDescription`] structures that are provided at
    ///graphics pipeline creation time via the
    ///`pVertexAttributeDescriptions` member of the
    ///[`PipelineVertexInputStateCreateInfo`] structure.
    ///See [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fxvertex-attrib](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fxvertex-attrib) and [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fxvertex-input](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fxvertex-input).
    max_vertex_input_attributes: u32,
    ///[`max_vertex_input_bindings`] is the
    ///maximum number of vertex buffers that  **can**  be specified for providing
    ///vertex attributes to a graphics pipeline.
    ///These are described in the array of
    ///[`VertexInputBindingDescription`] structures that are provided at
    ///graphics pipeline creation time via the `pVertexBindingDescriptions`
    ///member of the [`PipelineVertexInputStateCreateInfo`] structure.
    ///The `binding` member of [`VertexInputBindingDescription`] **must**
    ///be less than this limit.
    ///See [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fxvertex-input](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fxvertex-input).
    max_vertex_input_bindings: u32,
    ///[`max_vertex_input_attribute_offset`] is the maximum vertex input
    ///attribute offset that  **can**  be added to the vertex input binding stride.
    ///The `offset` member of the [`VertexInputAttributeDescription`]
    ///structure  **must**  be less than or equal to this limit.
    ///See [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fxvertex-input](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fxvertex-input).
    max_vertex_input_attribute_offset: u32,
    ///[`max_vertex_input_binding_stride`]
    ///is the maximum vertex input binding stride that  **can**  be specified in a
    ///vertex input binding.
    ///The `stride` member of the [`VertexInputBindingDescription`]
    ///structure  **must**  be less than or equal to this limit.
    ///See [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fxvertex-input](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fxvertex-input).
    max_vertex_input_binding_stride: u32,
    ///[`max_vertex_output_components`] is
    ///the maximum number of components of output variables which  **can**  be
    ///output by a vertex shader.
    ///See [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#shaders-vertex](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#shaders-vertex).
    max_vertex_output_components: u32,
    ///[`max_tessellation_generation_level`] is the maximum tessellation
    ///generation level supported by the fixed-function tessellation primitive
    ///generator.
    ///See [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#tessellation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#tessellation).
    max_tessellation_generation_level: u32,
    ///[`max_tessellation_patch_size`] is
    ///the maximum patch size, in vertices, of patches that  **can**  be processed
    ///by the tessellation control shader and tessellation primitive generator.
    ///The `patchControlPoints` member of the
    ///[`PipelineTessellationStateCreateInfo`] structure specified at
    ///pipeline creation time and the value provided in the `OutputVertices`
    ///execution mode of shader modules  **must**  be less than or equal to this
    ///limit.
    ///See [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#tessellation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#tessellation).
    max_tessellation_patch_size: u32,
    ///[`max_tessellation_control_per_vertex_input_components`] is the maximum
    ///number of components of input variables which  **can**  be provided as
    ///per-vertex inputs to the tessellation control shader stage.
    max_tessellation_control_per_vertex_input_components: u32,
    ///[`max_tessellation_control_per_vertex_output_components`] is the maximum
    ///number of components of per-vertex output variables which  **can**  be output
    ///from the tessellation control shader stage.
    max_tessellation_control_per_vertex_output_components: u32,
    ///[`max_tessellation_control_per_patch_output_components`] is the maximum
    ///number of components of per-patch output variables which  **can**  be output
    ///from the tessellation control shader stage.
    max_tessellation_control_per_patch_output_components: u32,
    ///[`max_tessellation_control_total_output_components`] is the maximum total
    ///number of components of per-vertex and per-patch output variables which
    /// **can**  be output from the tessellation control shader stage.
    max_tessellation_control_total_output_components: u32,
    ///[`max_tessellation_evaluation_input_components`] is the maximum number of
    ///components of input variables which  **can**  be provided as per-vertex
    ///inputs to the tessellation evaluation shader stage.
    max_tessellation_evaluation_input_components: u32,
    ///[`max_tessellation_evaluation_output_components`] is the maximum number of
    ///components of per-vertex output variables which  **can**  be output from the
    ///tessellation evaluation shader stage.
    max_tessellation_evaluation_output_components: u32,
    ///[`max_geometry_shader_invocations`] is the maximum invocation count
    ///supported for instanced geometry shaders.
    ///The value provided in the `Invocations` execution mode of shader
    ///modules  **must**  be less than or equal to this limit.
    ///See [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#geometry](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#geometry).
    max_geometry_shader_invocations: u32,
    ///[`max_geometry_input_components`]
    ///is the maximum number of components of input variables which  **can**  be
    ///provided as inputs to the geometry shader stage.
    max_geometry_input_components: u32,
    ///[`max_geometry_output_components`]
    ///is the maximum number of components of output variables which  **can**  be
    ///output from the geometry shader stage.
    max_geometry_output_components: u32,
    ///[`max_geometry_output_vertices`] is
    ///the maximum number of vertices which  **can**  be emitted by any geometry
    ///shader.
    max_geometry_output_vertices: u32,
    ///[`max_geometry_total_output_components`] is the maximum total number of
    ///components of output variables, across all emitted vertices, which  **can**
    ///be output from the geometry shader stage.
    max_geometry_total_output_components: u32,
    ///[`max_fragment_input_components`]
    ///is the maximum number of components of input variables which  **can**  be
    ///provided as inputs to the fragment shader stage.
    max_fragment_input_components: u32,
    ///[`max_fragment_output_attachments`] is the maximum number of output
    ///attachments which  **can**  be written to by the fragment shader stage.
    max_fragment_output_attachments: u32,
    ///[`max_fragment_dual_src_attachments`] is the maximum number of output
    ///attachments which  **can**  be written to by the fragment shader stage when
    ///blending is enabled and one of the dual source blend modes is in use.
    ///See [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#framebuffer-dsb](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#framebuffer-dsb) and [dualSrcBlend](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-dualSrcBlend).
    max_fragment_dual_src_attachments: u32,
    ///[`max_fragment_combined_output_resources`] is the total number of storage
    ///buffers, storage images, and output `Location` decorated color
    ///attachments (described in [Fragment Output
    ///Interface](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#interfaces-fragmentoutput)) which  **can**  be used in the fragment shader stage.
    max_fragment_combined_output_resources: u32,
    ///[`max_compute_shared_memory_size`]
    ///is the maximum total storage size, in bytes, available for variables
    ///declared with the `Workgroup` storage class in shader modules (or
    ///with the `shared` storage qualifier in GLSL) in the compute shader
    ///stage.
    ///When variables declared with the `Workgroup` storage class are
    ///explicitly laid out (hence they are also decorated with `Block`), the
    ///amount of storage consumed is the size of the largest Block variable,
    ///not counting any padding at the end.
    ///The amount of storage consumed by the
    ///non-Block
    ///variables declared with the `Workgroup` storage class is
    ///implementation-dependent.
    ///However, the amount of storage consumed may not exceed the largest block
    ///size that would be obtained if all active
    ///non-Block
    ///variables declared with `Workgroup` storage class were assigned
    ///offsets in an arbitrary order by successively taking the smallest valid
    ///offset according to the [Standard
    ///Storage Buffer Layout](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#interfaces-resources-standard-layout) rules.
    ///(This is equivalent to using the GLSL std430 layout rules.)
    max_compute_shared_memory_size: u32,
    ///[`max_compute_work_group_count`][3] is
    ///the maximum number of local workgroups that  **can**  be dispatched by a
    ///single dispatching command.
    ///These three values represent the maximum number of local workgroups for
    ///the X, Y, and Z dimensions, respectively.
    ///The workgroup count parameters to the dispatching commands  **must**  be less
    ///than or equal to the corresponding limit.
    ///See [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#dispatch](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#dispatch).
    max_compute_work_group_count: [u32; 3],
    ///[`max_compute_work_group_invocations`] is the maximum total number of
    ///    compute shader invocations in a single local workgroup.
    ///    The product of the X, Y, and Z sizes, as specified by the `LocalSize`
    ///or `LocalSizeId`
    ///    execution mode in shader modules or by the object decorated by the
    ///    `WorkgroupSize` decoration,  **must**  be less than or equal to this
    ///    limit.
    max_compute_work_group_invocations: u32,
    ///[`max_compute_work_group_size`][3] is
    ///    the maximum size of a local compute workgroup, per dimension.
    ///    These three values represent the maximum local workgroup size in the X,
    ///    Y, and Z dimensions, respectively.
    ///    The `x`, `y`, and `z` sizes, as specified by the
    ///    `LocalSize`
    ///or `LocalSizeId`
    ///    execution mode or by the object decorated by the `WorkgroupSize`
    ///    decoration in shader modules,  **must**  be less than or equal to the
    ///    corresponding limit.
    max_compute_work_group_size: [u32; 3],
    ///[`sub_pixel_precision_bits`] is the
    ///number of bits of subpixel precision in framebuffer coordinates
    ///x<sub>f</sub> and y<sub>f</sub>.
    ///See [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#primsrast](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#primsrast).
    sub_pixel_precision_bits: u32,
    ///[`sub_texel_precision_bits`] is the
    ///number of bits of precision in the division along an axis of an image
    ///used for minification and magnification filters.
    ///2<sup>[`sub_texel_precision_bits`]</sup> is the actual number of divisions
    ///along each axis of the image represented.
    ///Sub-texel values calculated during image sampling will snap to these
    ///locations when generating the filtered results.
    sub_texel_precision_bits: u32,
    ///[`mipmap_precision_bits`] is the number
    ///of bits of division that the LOD calculation for mipmap fetching get
    ///snapped to when determining the contribution from each mip level to the
    ///mip filtered results.
    ///2<sup>[`mipmap_precision_bits`]</sup> is the actual number of divisions.
    mipmap_precision_bits: u32,
    ///[`max_draw_indexed_index_value`] is
    ///the maximum index value that  **can**  be used for indexed draw calls when
    ///using 32-bit indices.
    ///This excludes the primitive restart index value of 0xFFFFFFFF.
    ///See [fullDrawIndexUint32](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-fullDrawIndexUint32).
    max_draw_indexed_index_value: u32,
    ///[`max_draw_indirect_count`] is the
    ///maximum draw count that is supported for indirect drawing calls.
    ///See [multiDrawIndirect](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-multiDrawIndirect).
    max_draw_indirect_count: u32,
    ///[`max_sampler_lod_bias`] is the maximum
    ///absolute sampler LOD bias.
    ///The sum of the `mipLodBias` member of the [`SamplerCreateInfo`]
    ///structure and the `Bias` operand of image sampling operations in
    ///shader modules (or 0 if no `Bias` operand is provided to an image
    ///sampling operation) are clamped to the range
    ///[-[`max_sampler_lod_bias`],+[`max_sampler_lod_bias`]].
    ///See [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#samplers-mipLodBias](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#samplers-mipLodBias).
    max_sampler_lod_bias: f32,
    ///[`max_sampler_anisotropy`] is the
    ///maximum degree of sampler anisotropy.
    ///The maximum degree of anisotropic filtering used for an image sampling
    ///operation is the minimum of the `maxAnisotropy` member of the
    ///[`SamplerCreateInfo`] structure and this limit.
    ///See [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#samplers-maxAnisotropy](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#samplers-maxAnisotropy).
    max_sampler_anisotropy: f32,
    ///[`max_viewports`] is the maximum number of
    ///active viewports.
    ///The `viewportCount` member of the
    ///[`PipelineViewportStateCreateInfo`] structure that is provided at
    ///pipeline creation  **must**  be less than or equal to this limit.
    max_viewports: u32,
    ///[`max_viewport_dimensions`][2] are the
    ///maximum viewport dimensions in the X (width) and Y (height) dimensions,
    ///respectively.
    ///The maximum viewport dimensions  **must**  be greater than or equal to the
    ///largest image which  **can**  be created and used as a framebuffer
    ///attachment.
    ///See [Controlling the Viewport](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#vertexpostproc-viewport).
    max_viewport_dimensions: [u32; 2],
    ///[`viewport_bounds_range`][2] is the
    ///[minimum, maximum] range that the corners of a viewport  **must**  be
    ///contained in.
    ///This range  **must**  be at least [-2 × `size`, 2 ×
    ///`size` - 1], where `size` =
    ///max([`max_viewport_dimensions`][0], [`max_viewport_dimensions`][1]).
    ///See [Controlling the Viewport](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#vertexpostproc-viewport).
    viewport_bounds_range: [f32; 2],
    ///[`viewport_sub_pixel_bits`] is the number
    ///of bits of subpixel precision for viewport bounds.
    ///The subpixel precision that floating-point viewport bounds are
    ///interpreted at is given by this limit.
    viewport_sub_pixel_bits: u32,
    ///[`min_memory_map_alignment`] is the
    ///minimum  **required**  alignment, in bytes, of host visible memory
    ///allocations within the host address space.
    ///When mapping a memory allocation with [`MapMemory`], subtracting
    ///`offset` bytes from the returned pointer will always produce an
    ///integer multiple of this limit.
    ///See [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#memory-device-hostaccess](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#memory-device-hostaccess).
    ///The value  **must**  be a power of two.
    min_memory_map_alignment: usize,
    ///[`min_texel_buffer_offset_alignment`] is the minimum  **required**  alignment,
    ///in bytes, for the `offset` member of the
    ///[`BufferViewCreateInfo`] structure for texel buffers.
    ///The value  **must**  be a power of two.
    ///If [texelBufferAlignment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-texelBufferAlignment) is enabled,
    ///this limit is equivalent to the maximum of the
    ///[`uniformTexelBufferOffsetAlignmentBytes`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#limits-uniformTexelBufferOffsetAlignmentBytes) and
    ///[`storageTexelBufferOffsetAlignmentBytes`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#limits-storageTexelBufferOffsetAlignmentBytes) members of
    ///[`PhysicalDeviceTexelBufferAlignmentProperties`], but smaller
    ///alignment is  **optionally**  allowed by
    ///[`storageTexelBufferOffsetSingleTexelAlignment`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#limits-storageTexelBufferOffsetSingleTexelAlignment) and
    ///[`uniformTexelBufferOffsetSingleTexelAlignment`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#limits-uniformTexelBufferOffsetSingleTexelAlignment).
    ///If [texelBufferAlignment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-texelBufferAlignment) is not
    ///enabled,
    ///[`BufferViewCreateInfo`]::`offset` **must**  be a multiple of this
    ///value.
    min_texel_buffer_offset_alignment: DeviceSize,
    ///[`min_uniform_buffer_offset_alignment`] is the minimum  **required**
    ///alignment, in bytes, for the `offset` member of the
    ///[`DescriptorBufferInfo`] structure for uniform buffers.
    ///When a descriptor of type `VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER` or
    ///`VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC` is updated, the
    ///`offset` **must**  be an integer multiple of this limit.
    ///Similarly, dynamic offsets for uniform buffers  **must**  be multiples of
    ///this limit.
    ///The value  **must**  be a power of two.
    min_uniform_buffer_offset_alignment: DeviceSize,
    ///[`min_storage_buffer_offset_alignment`] is the minimum  **required**
    ///alignment, in bytes, for the `offset` member of the
    ///[`DescriptorBufferInfo`] structure for storage buffers.
    ///When a descriptor of type `VK_DESCRIPTOR_TYPE_STORAGE_BUFFER` or
    ///`VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC` is updated, the
    ///`offset` **must**  be an integer multiple of this limit.
    ///Similarly, dynamic offsets for storage buffers  **must**  be multiples of
    ///this limit.
    ///The value  **must**  be a power of two.
    min_storage_buffer_offset_alignment: DeviceSize,
    ///[`min_texel_offset`] is the minimum offset
    ///value for the `ConstOffset` image operand of any of the
    ///`OpImageSample*` or `OpImageFetch*` image instructions.
    min_texel_offset: i32,
    ///[`max_texel_offset`] is the maximum offset
    ///value for the `ConstOffset` image operand of any of the
    ///`OpImageSample*` or `OpImageFetch*` image instructions.
    max_texel_offset: u32,
    ///[`min_texel_gather_offset`] is the
    ///minimum offset value for the `Offset`, `ConstOffset`, or
    ///`ConstOffsets` image operands of any of the `OpImage*Gather` image
    ///instructions.
    min_texel_gather_offset: i32,
    ///[`max_texel_gather_offset`] is the
    ///maximum offset value for the `Offset`, `ConstOffset`, or
    ///`ConstOffsets` image operands of any of the `OpImage*Gather` image
    ///instructions.
    max_texel_gather_offset: u32,
    ///[`min_interpolation_offset`] is the
    ///base minimum (inclusive) negative offset value for the `Offset`
    ///operand of the `InterpolateAtOffset` extended instruction.
    min_interpolation_offset: f32,
    ///[`max_interpolation_offset`] is the
    ///base maximum (inclusive) positive offset value for the `Offset`
    ///operand of the `InterpolateAtOffset` extended instruction.
    max_interpolation_offset: f32,
    ///[`sub_pixel_interpolation_offset_bits`] is the number of fractional bits
    ///that the `x` and `y` offsets to the `InterpolateAtOffset`
    ///extended instruction  **may**  be rounded to as fixed-point values.
    sub_pixel_interpolation_offset_bits: u32,
    ///[`max_framebuffer_width`] is the maximum
    ///width for a framebuffer.
    ///The `width` member of the [`FramebufferCreateInfo`] structure
    /// **must**  be less than or equal to this limit.
    max_framebuffer_width: u32,
    ///[`max_framebuffer_height`] is the
    ///maximum height for a framebuffer.
    ///The `height` member of the [`FramebufferCreateInfo`] structure
    /// **must**  be less than or equal to this limit.
    max_framebuffer_height: u32,
    ///[`max_framebuffer_layers`] is the
    ///maximum layer count for a layered framebuffer.
    ///The `layers` member of the [`FramebufferCreateInfo`] structure
    /// **must**  be less than or equal to this limit.
    max_framebuffer_layers: u32,
    ///[`framebuffer_color_sample_counts`] is a bitmask<sup>1</sup> of
    ///[`SampleCountFlagBits`] indicating the color sample counts that are
    ///supported for all framebuffer color attachments with floating- or
    ///fixed-point formats.
    ///For color attachments with integer formats, see
    ///[`framebufferIntegerColorSampleCounts`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#limits-framebufferIntegerColorSampleCounts).
    framebuffer_color_sample_counts: SampleCountFlags,
    ///[`framebuffer_depth_sample_counts`] is a bitmask<sup>1</sup> of
    ///[`SampleCountFlagBits`] indicating the supported depth sample counts
    ///for all framebuffer depth/stencil attachments, when the format includes
    ///a depth component.
    framebuffer_depth_sample_counts: SampleCountFlags,
    ///[`framebuffer_stencil_sample_counts`] is a bitmask<sup>1</sup> of
    ///[`SampleCountFlagBits`] indicating the supported stencil sample
    ///counts for all framebuffer depth/stencil attachments, when the format
    ///includes a stencil component.
    framebuffer_stencil_sample_counts: SampleCountFlags,
    ///[`framebuffer_no_attachments_sample_counts`] is a bitmask<sup>1</sup> of
    ///[`SampleCountFlagBits`] indicating the supported sample counts for a
    ///[subpass which uses no attachments](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-noattachments).
    framebuffer_no_attachments_sample_counts: SampleCountFlags,
    ///[`max_color_attachments`] is the maximum
    ///number of color attachments that  **can**  be used by a subpass in a render
    ///pass.
    ///The `colorAttachmentCount` member of the [`SubpassDescription`]
    ///or [`SubpassDescription2`]
    ///structure  **must**  be less than or equal to this limit.
    max_color_attachments: u32,
    ///[`sampled_image_color_sample_counts`] is a bitmask<sup>1</sup> of
    ///[`SampleCountFlagBits`] indicating the sample counts supported for
    ///all 2D images created with `VK_IMAGE_TILING_OPTIMAL`, `usage`
    ///containing `VK_IMAGE_USAGE_SAMPLED_BIT`, and a non-integer color
    ///format.
    sampled_image_color_sample_counts: SampleCountFlags,
    ///[`sampled_image_integer_sample_counts`] is a bitmask<sup>1</sup> of
    ///[`SampleCountFlagBits`] indicating the sample counts supported for
    ///all 2D images created with `VK_IMAGE_TILING_OPTIMAL`, `usage`
    ///containing `VK_IMAGE_USAGE_SAMPLED_BIT`, and an integer color
    ///format.
    sampled_image_integer_sample_counts: SampleCountFlags,
    ///[`sampled_image_depth_sample_counts`] is a bitmask<sup>1</sup> of
    ///[`SampleCountFlagBits`] indicating the sample counts supported for
    ///all 2D images created with `VK_IMAGE_TILING_OPTIMAL`, `usage`
    ///containing `VK_IMAGE_USAGE_SAMPLED_BIT`, and a depth format.
    sampled_image_depth_sample_counts: SampleCountFlags,
    ///[`sampled_image_stencil_sample_counts`] is a bitmask<sup>1</sup> of
    ///[`SampleCountFlagBits`] indicating the sample counts supported for
    ///all 2D images created with `VK_IMAGE_TILING_OPTIMAL`, `usage`
    ///containing `VK_IMAGE_USAGE_SAMPLED_BIT`, and a stencil format.
    sampled_image_stencil_sample_counts: SampleCountFlags,
    ///[`storage_image_sample_counts`] is a
    ///bitmask<sup>1</sup> of [`SampleCountFlagBits`] indicating the sample counts
    ///supported for all 2D images created with `VK_IMAGE_TILING_OPTIMAL`,
    ///and `usage` containing `VK_IMAGE_USAGE_STORAGE_BIT`.
    storage_image_sample_counts: SampleCountFlags,
    ///[`max_sample_mask_words`] is the maximum
    ///number of array elements of a variable decorated with the
    ///[`SampleMask`] built-in decoration.
    max_sample_mask_words: u32,
    ///[`timestamp_compute_and_graphics`]
    ///specifies support for timestamps on all graphics and compute queues.
    ///If this limit is set to [`TRUE`], all queues that advertise the
    ///`VK_QUEUE_GRAPHICS_BIT` or `VK_QUEUE_COMPUTE_BIT` in the
    ///[`QueueFamilyProperties`]::`queueFlags` support
    ///[`QueueFamilyProperties`]::`timestampValidBits` of at least 36.
    ///See [Timestamp Queries](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#queries-timestamps).
    timestamp_compute_and_graphics: Bool32,
    ///[`timestamp_period`] is the number of
    ///nanoseconds  **required**  for a timestamp query to be incremented by 1.
    ///See [Timestamp Queries](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#queries-timestamps).
    timestamp_period: f32,
    ///[`max_clip_distances`] is the maximum number
    ///of clip distances that  **can**  be used in a single shader stage.
    ///The size of any array declared with the `ClipDistance` built-in
    ///decoration in a shader module  **must**  be less than or equal to this limit.
    max_clip_distances: u32,
    ///[`max_cull_distances`] is the maximum number
    ///of cull distances that  **can**  be used in a single shader stage.
    ///The size of any array declared with the `CullDistance` built-in
    ///decoration in a shader module  **must**  be less than or equal to this limit.
    max_cull_distances: u32,
    ///[`max_combined_clip_and_cull_distances`] is the maximum combined number of
    ///clip and cull distances that  **can**  be used in a single shader stage.
    ///The sum of the sizes of any pair of arrays declared with the
    ///`ClipDistance` and `CullDistance` built-in decoration used by a
    ///single shader stage in a shader module  **must**  be less than or equal to
    ///this limit.
    max_combined_clip_and_cull_distances: u32,
    ///[`discrete_queue_priorities`] is the
    ///number of discrete priorities that  **can**  be assigned to a queue based on
    ///the value of each member of
    ///[`DeviceQueueCreateInfo`]::`pQueuePriorities`.
    ///This  **must**  be at least 2, and levels  **must**  be spread evenly over the
    ///range, with at least one level at 1.0, and another at 0.0.
    ///See [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#devsandqueues-priority](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#devsandqueues-priority).
    discrete_queue_priorities: u32,
    ///[`point_size_range`][2] is the range
    ///[`minimum`,`maximum`] of supported sizes for points.
    ///Values written to variables decorated with the `PointSize` built-in
    ///decoration are clamped to this range.
    point_size_range: [f32; 2],
    ///[`line_width_range`][2] is the range
    ///[`minimum`,`maximum`] of supported widths for lines.
    ///Values specified by the `lineWidth` member of the
    ///[`PipelineRasterizationStateCreateInfo`] or the `lineWidth`
    ///parameter to [`CmdSetLineWidth`] are clamped to this range.
    line_width_range: [f32; 2],
    ///[`point_size_granularity`] is the
    ///granularity of supported point sizes.
    ///Not all point sizes in the range defined by [`point_size_range`] are
    ///supported.
    ///This limit specifies the granularity (or increment) between successive
    ///supported point sizes.
    point_size_granularity: f32,
    ///[`line_width_granularity`] is the
    ///granularity of supported line widths.
    ///Not all line widths in the range defined by [`line_width_range`] are
    ///supported.
    ///This limit specifies the granularity (or increment) between successive
    ///supported line widths.
    line_width_granularity: f32,
    ///[`strict_lines`] specifies whether lines are
    ///rasterized according to the preferred method of rasterization.
    ///If set to [`FALSE`], lines  **may**  be rasterized under a relaxed set
    ///of rules.
    ///If set to [`TRUE`], lines are rasterized as per the strict
    ///definition.
    ///See [Basic Line Segment Rasterization](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#primsrast-lines-basic).
    strict_lines: Bool32,
    ///[`standard_sample_locations`]
    ///specifies whether rasterization uses the standard sample locations as
    ///documented in [Multisampling](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#primsrast-multisampling).
    ///If set to [`TRUE`], the implementation uses the documented sample
    ///locations.
    ///If set to [`FALSE`], the implementation  **may**  use different sample
    ///locations.
    standard_sample_locations: Bool32,
    ///[`optimal_buffer_copy_offset_alignment`] is the optimal buffer offset
    ///alignment in bytes for
    ///[`CmdCopyBufferToImage2`], [`CmdCopyBufferToImage`],
    ///[`CmdCopyImageToBuffer2`], and [`CmdCopyImageToBuffer`].
    ///The per texel alignment requirements are enforced, but applications
    /// **should**  use the optimal alignment for optimal performance and power use.
    ///The value  **must**  be a power of two.
    optimal_buffer_copy_offset_alignment: DeviceSize,
    ///[`optimal_buffer_copy_row_pitch_alignment`] is the optimal buffer row pitch
    ///alignment in bytes for
    ///[`CmdCopyBufferToImage2`], [`CmdCopyBufferToImage`],
    ///[`CmdCopyImageToBuffer2`], and [`CmdCopyImageToBuffer`].
    ///Row pitch is the number of bytes between texels with the same X
    ///coordinate in adjacent rows (Y coordinates differ by one).
    ///The per texel alignment requirements are enforced, but applications
    /// **should**  use the optimal alignment for optimal performance and power use.
    ///The value  **must**  be a power of two.
    optimal_buffer_copy_row_pitch_alignment: DeviceSize,
    ///[`non_coherent_atom_size`] is the size and
    ///alignment in bytes that bounds concurrent access to
    ///[host-mapped device memory](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#memory-device-hostaccess).
    ///The value  **must**  be a power of two.
    /// * For all bitmasks of [`SampleCountFlagBits`], the sample count limits defined above represent the minimum supported sample counts for each image type. Individual images  **may**  support additional sample counts, which are queried using [`GetPhysicalDeviceImageFormatProperties`] as described in [Supported Sample Counts](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-supported-sample-counts).
    non_coherent_atom_size: DeviceSize,
}
impl Default for PhysicalDeviceLimits {
    fn default() -> Self {
        Self {
            max_image_dimension_1_d: 0,
            max_image_dimension_2_d: 0,
            max_image_dimension_3_d: 0,
            max_image_dimension_cube: 0,
            max_image_array_layers: 0,
            max_texel_buffer_elements: 0,
            max_uniform_buffer_range: 0,
            max_storage_buffer_range: 0,
            max_push_constants_size: 0,
            max_memory_allocation_count: 0,
            max_sampler_allocation_count: 0,
            buffer_image_granularity: Default::default(),
            sparse_address_space_size: Default::default(),
            max_bound_descriptor_sets: 0,
            max_per_stage_descriptor_samplers: 0,
            max_per_stage_descriptor_uniform_buffers: 0,
            max_per_stage_descriptor_storage_buffers: 0,
            max_per_stage_descriptor_sampled_images: 0,
            max_per_stage_descriptor_storage_images: 0,
            max_per_stage_descriptor_input_attachments: 0,
            max_per_stage_resources: 0,
            max_descriptor_set_samplers: 0,
            max_descriptor_set_uniform_buffers: 0,
            max_descriptor_set_uniform_buffers_dynamic: 0,
            max_descriptor_set_storage_buffers: 0,
            max_descriptor_set_storage_buffers_dynamic: 0,
            max_descriptor_set_sampled_images: 0,
            max_descriptor_set_storage_images: 0,
            max_descriptor_set_input_attachments: 0,
            max_vertex_input_attributes: 0,
            max_vertex_input_bindings: 0,
            max_vertex_input_attribute_offset: 0,
            max_vertex_input_binding_stride: 0,
            max_vertex_output_components: 0,
            max_tessellation_generation_level: 0,
            max_tessellation_patch_size: 0,
            max_tessellation_control_per_vertex_input_components: 0,
            max_tessellation_control_per_vertex_output_components: 0,
            max_tessellation_control_per_patch_output_components: 0,
            max_tessellation_control_total_output_components: 0,
            max_tessellation_evaluation_input_components: 0,
            max_tessellation_evaluation_output_components: 0,
            max_geometry_shader_invocations: 0,
            max_geometry_input_components: 0,
            max_geometry_output_components: 0,
            max_geometry_output_vertices: 0,
            max_geometry_total_output_components: 0,
            max_fragment_input_components: 0,
            max_fragment_output_attachments: 0,
            max_fragment_dual_src_attachments: 0,
            max_fragment_combined_output_resources: 0,
            max_compute_shared_memory_size: 0,
            max_compute_work_group_count: [0; 3],
            max_compute_work_group_invocations: 0,
            max_compute_work_group_size: [0; 3],
            sub_pixel_precision_bits: 0,
            sub_texel_precision_bits: 0,
            mipmap_precision_bits: 0,
            max_draw_indexed_index_value: 0,
            max_draw_indirect_count: 0,
            max_sampler_lod_bias: 0.0,
            max_sampler_anisotropy: 0.0,
            max_viewports: 0,
            max_viewport_dimensions: [0; 2],
            viewport_bounds_range: [0.0; 2],
            viewport_sub_pixel_bits: 0,
            min_memory_map_alignment: 0,
            min_texel_buffer_offset_alignment: Default::default(),
            min_uniform_buffer_offset_alignment: Default::default(),
            min_storage_buffer_offset_alignment: Default::default(),
            min_texel_offset: 0,
            max_texel_offset: 0,
            min_texel_gather_offset: 0,
            max_texel_gather_offset: 0,
            min_interpolation_offset: 0.0,
            max_interpolation_offset: 0.0,
            sub_pixel_interpolation_offset_bits: 0,
            max_framebuffer_width: 0,
            max_framebuffer_height: 0,
            max_framebuffer_layers: 0,
            framebuffer_color_sample_counts: Default::default(),
            framebuffer_depth_sample_counts: Default::default(),
            framebuffer_stencil_sample_counts: Default::default(),
            framebuffer_no_attachments_sample_counts: Default::default(),
            max_color_attachments: 0,
            sampled_image_color_sample_counts: Default::default(),
            sampled_image_integer_sample_counts: Default::default(),
            sampled_image_depth_sample_counts: Default::default(),
            sampled_image_stencil_sample_counts: Default::default(),
            storage_image_sample_counts: Default::default(),
            max_sample_mask_words: 0,
            timestamp_compute_and_graphics: 0,
            timestamp_period: 0.0,
            max_clip_distances: 0,
            max_cull_distances: 0,
            max_combined_clip_and_cull_distances: 0,
            discrete_queue_priorities: 0,
            point_size_range: [0.0; 2],
            line_width_range: [0.0; 2],
            point_size_granularity: 0.0,
            line_width_granularity: 0.0,
            strict_lines: 0,
            standard_sample_locations: 0,
            optimal_buffer_copy_offset_alignment: Default::default(),
            optimal_buffer_copy_row_pitch_alignment: Default::default(),
            non_coherent_atom_size: Default::default(),
        }
    }
}
impl PhysicalDeviceLimits {
    ///Gets the raw value of [`Self::timestamp_compute_and_graphics`]
    pub fn timestamp_compute_and_graphics_raw(&self) -> Bool32 {
        self.timestamp_compute_and_graphics
    }
    ///Gets the raw value of [`Self::strict_lines`]
    pub fn strict_lines_raw(&self) -> Bool32 {
        self.strict_lines
    }
    ///Gets the raw value of [`Self::standard_sample_locations`]
    pub fn standard_sample_locations_raw(&self) -> Bool32 {
        self.standard_sample_locations
    }
    ///Sets the raw value of [`Self::timestamp_compute_and_graphics`]
    pub fn set_timestamp_compute_and_graphics_raw(&mut self, value: Bool32) -> &mut Self {
        self.timestamp_compute_and_graphics = value;
        self
    }
    ///Sets the raw value of [`Self::strict_lines`]
    pub fn set_strict_lines_raw(&mut self, value: Bool32) -> &mut Self {
        self.strict_lines = value;
        self
    }
    ///Sets the raw value of [`Self::standard_sample_locations`]
    pub fn set_standard_sample_locations_raw(&mut self, value: Bool32) -> &mut Self {
        self.standard_sample_locations = value;
        self
    }
    ///Gets the value of [`Self::max_image_dimension_1_d`]
    pub fn max_image_dimension_1_d(&self) -> u32 {
        self.max_image_dimension_1_d
    }
    ///Gets the value of [`Self::max_image_dimension_2_d`]
    pub fn max_image_dimension_2_d(&self) -> u32 {
        self.max_image_dimension_2_d
    }
    ///Gets the value of [`Self::max_image_dimension_3_d`]
    pub fn max_image_dimension_3_d(&self) -> u32 {
        self.max_image_dimension_3_d
    }
    ///Gets the value of [`Self::max_image_dimension_cube`]
    pub fn max_image_dimension_cube(&self) -> u32 {
        self.max_image_dimension_cube
    }
    ///Gets the value of [`Self::max_image_array_layers`]
    pub fn max_image_array_layers(&self) -> u32 {
        self.max_image_array_layers
    }
    ///Gets the value of [`Self::max_texel_buffer_elements`]
    pub fn max_texel_buffer_elements(&self) -> u32 {
        self.max_texel_buffer_elements
    }
    ///Gets the value of [`Self::max_uniform_buffer_range`]
    pub fn max_uniform_buffer_range(&self) -> u32 {
        self.max_uniform_buffer_range
    }
    ///Gets the value of [`Self::max_storage_buffer_range`]
    pub fn max_storage_buffer_range(&self) -> u32 {
        self.max_storage_buffer_range
    }
    ///Gets the value of [`Self::max_push_constants_size`]
    pub fn max_push_constants_size(&self) -> u32 {
        self.max_push_constants_size
    }
    ///Gets the value of [`Self::max_memory_allocation_count`]
    pub fn max_memory_allocation_count(&self) -> u32 {
        self.max_memory_allocation_count
    }
    ///Gets the value of [`Self::max_sampler_allocation_count`]
    pub fn max_sampler_allocation_count(&self) -> u32 {
        self.max_sampler_allocation_count
    }
    ///Gets the value of [`Self::buffer_image_granularity`]
    pub fn buffer_image_granularity(&self) -> DeviceSize {
        self.buffer_image_granularity
    }
    ///Gets the value of [`Self::sparse_address_space_size`]
    pub fn sparse_address_space_size(&self) -> DeviceSize {
        self.sparse_address_space_size
    }
    ///Gets the value of [`Self::max_bound_descriptor_sets`]
    pub fn max_bound_descriptor_sets(&self) -> u32 {
        self.max_bound_descriptor_sets
    }
    ///Gets the value of [`Self::max_per_stage_descriptor_samplers`]
    pub fn max_per_stage_descriptor_samplers(&self) -> u32 {
        self.max_per_stage_descriptor_samplers
    }
    ///Gets the value of [`Self::max_per_stage_descriptor_uniform_buffers`]
    pub fn max_per_stage_descriptor_uniform_buffers(&self) -> u32 {
        self.max_per_stage_descriptor_uniform_buffers
    }
    ///Gets the value of [`Self::max_per_stage_descriptor_storage_buffers`]
    pub fn max_per_stage_descriptor_storage_buffers(&self) -> u32 {
        self.max_per_stage_descriptor_storage_buffers
    }
    ///Gets the value of [`Self::max_per_stage_descriptor_sampled_images`]
    pub fn max_per_stage_descriptor_sampled_images(&self) -> u32 {
        self.max_per_stage_descriptor_sampled_images
    }
    ///Gets the value of [`Self::max_per_stage_descriptor_storage_images`]
    pub fn max_per_stage_descriptor_storage_images(&self) -> u32 {
        self.max_per_stage_descriptor_storage_images
    }
    ///Gets the value of [`Self::max_per_stage_descriptor_input_attachments`]
    pub fn max_per_stage_descriptor_input_attachments(&self) -> u32 {
        self.max_per_stage_descriptor_input_attachments
    }
    ///Gets the value of [`Self::max_per_stage_resources`]
    pub fn max_per_stage_resources(&self) -> u32 {
        self.max_per_stage_resources
    }
    ///Gets the value of [`Self::max_descriptor_set_samplers`]
    pub fn max_descriptor_set_samplers(&self) -> u32 {
        self.max_descriptor_set_samplers
    }
    ///Gets the value of [`Self::max_descriptor_set_uniform_buffers`]
    pub fn max_descriptor_set_uniform_buffers(&self) -> u32 {
        self.max_descriptor_set_uniform_buffers
    }
    ///Gets the value of [`Self::max_descriptor_set_uniform_buffers_dynamic`]
    pub fn max_descriptor_set_uniform_buffers_dynamic(&self) -> u32 {
        self.max_descriptor_set_uniform_buffers_dynamic
    }
    ///Gets the value of [`Self::max_descriptor_set_storage_buffers`]
    pub fn max_descriptor_set_storage_buffers(&self) -> u32 {
        self.max_descriptor_set_storage_buffers
    }
    ///Gets the value of [`Self::max_descriptor_set_storage_buffers_dynamic`]
    pub fn max_descriptor_set_storage_buffers_dynamic(&self) -> u32 {
        self.max_descriptor_set_storage_buffers_dynamic
    }
    ///Gets the value of [`Self::max_descriptor_set_sampled_images`]
    pub fn max_descriptor_set_sampled_images(&self) -> u32 {
        self.max_descriptor_set_sampled_images
    }
    ///Gets the value of [`Self::max_descriptor_set_storage_images`]
    pub fn max_descriptor_set_storage_images(&self) -> u32 {
        self.max_descriptor_set_storage_images
    }
    ///Gets the value of [`Self::max_descriptor_set_input_attachments`]
    pub fn max_descriptor_set_input_attachments(&self) -> u32 {
        self.max_descriptor_set_input_attachments
    }
    ///Gets the value of [`Self::max_vertex_input_attributes`]
    pub fn max_vertex_input_attributes(&self) -> u32 {
        self.max_vertex_input_attributes
    }
    ///Gets the value of [`Self::max_vertex_input_bindings`]
    pub fn max_vertex_input_bindings(&self) -> u32 {
        self.max_vertex_input_bindings
    }
    ///Gets the value of [`Self::max_vertex_input_attribute_offset`]
    pub fn max_vertex_input_attribute_offset(&self) -> u32 {
        self.max_vertex_input_attribute_offset
    }
    ///Gets the value of [`Self::max_vertex_input_binding_stride`]
    pub fn max_vertex_input_binding_stride(&self) -> u32 {
        self.max_vertex_input_binding_stride
    }
    ///Gets the value of [`Self::max_vertex_output_components`]
    pub fn max_vertex_output_components(&self) -> u32 {
        self.max_vertex_output_components
    }
    ///Gets the value of [`Self::max_tessellation_generation_level`]
    pub fn max_tessellation_generation_level(&self) -> u32 {
        self.max_tessellation_generation_level
    }
    ///Gets the value of [`Self::max_tessellation_patch_size`]
    pub fn max_tessellation_patch_size(&self) -> u32 {
        self.max_tessellation_patch_size
    }
    ///Gets the value of [`Self::max_tessellation_control_per_vertex_input_components`]
    pub fn max_tessellation_control_per_vertex_input_components(&self) -> u32 {
        self.max_tessellation_control_per_vertex_input_components
    }
    ///Gets the value of [`Self::max_tessellation_control_per_vertex_output_components`]
    pub fn max_tessellation_control_per_vertex_output_components(&self) -> u32 {
        self.max_tessellation_control_per_vertex_output_components
    }
    ///Gets the value of [`Self::max_tessellation_control_per_patch_output_components`]
    pub fn max_tessellation_control_per_patch_output_components(&self) -> u32 {
        self.max_tessellation_control_per_patch_output_components
    }
    ///Gets the value of [`Self::max_tessellation_control_total_output_components`]
    pub fn max_tessellation_control_total_output_components(&self) -> u32 {
        self.max_tessellation_control_total_output_components
    }
    ///Gets the value of [`Self::max_tessellation_evaluation_input_components`]
    pub fn max_tessellation_evaluation_input_components(&self) -> u32 {
        self.max_tessellation_evaluation_input_components
    }
    ///Gets the value of [`Self::max_tessellation_evaluation_output_components`]
    pub fn max_tessellation_evaluation_output_components(&self) -> u32 {
        self.max_tessellation_evaluation_output_components
    }
    ///Gets the value of [`Self::max_geometry_shader_invocations`]
    pub fn max_geometry_shader_invocations(&self) -> u32 {
        self.max_geometry_shader_invocations
    }
    ///Gets the value of [`Self::max_geometry_input_components`]
    pub fn max_geometry_input_components(&self) -> u32 {
        self.max_geometry_input_components
    }
    ///Gets the value of [`Self::max_geometry_output_components`]
    pub fn max_geometry_output_components(&self) -> u32 {
        self.max_geometry_output_components
    }
    ///Gets the value of [`Self::max_geometry_output_vertices`]
    pub fn max_geometry_output_vertices(&self) -> u32 {
        self.max_geometry_output_vertices
    }
    ///Gets the value of [`Self::max_geometry_total_output_components`]
    pub fn max_geometry_total_output_components(&self) -> u32 {
        self.max_geometry_total_output_components
    }
    ///Gets the value of [`Self::max_fragment_input_components`]
    pub fn max_fragment_input_components(&self) -> u32 {
        self.max_fragment_input_components
    }
    ///Gets the value of [`Self::max_fragment_output_attachments`]
    pub fn max_fragment_output_attachments(&self) -> u32 {
        self.max_fragment_output_attachments
    }
    ///Gets the value of [`Self::max_fragment_dual_src_attachments`]
    pub fn max_fragment_dual_src_attachments(&self) -> u32 {
        self.max_fragment_dual_src_attachments
    }
    ///Gets the value of [`Self::max_fragment_combined_output_resources`]
    pub fn max_fragment_combined_output_resources(&self) -> u32 {
        self.max_fragment_combined_output_resources
    }
    ///Gets the value of [`Self::max_compute_shared_memory_size`]
    pub fn max_compute_shared_memory_size(&self) -> u32 {
        self.max_compute_shared_memory_size
    }
    ///Gets the value of [`Self::max_compute_work_group_count`]
    pub fn max_compute_work_group_count(&self) -> &[u32; 3] {
        &getter
    }
    ///Gets the value of [`Self::max_compute_work_group_invocations`]
    pub fn max_compute_work_group_invocations(&self) -> u32 {
        self.max_compute_work_group_invocations
    }
    ///Gets the value of [`Self::max_compute_work_group_size`]
    pub fn max_compute_work_group_size(&self) -> &[u32; 3] {
        &getter
    }
    ///Gets the value of [`Self::sub_pixel_precision_bits`]
    pub fn sub_pixel_precision_bits(&self) -> u32 {
        self.sub_pixel_precision_bits
    }
    ///Gets the value of [`Self::sub_texel_precision_bits`]
    pub fn sub_texel_precision_bits(&self) -> u32 {
        self.sub_texel_precision_bits
    }
    ///Gets the value of [`Self::mipmap_precision_bits`]
    pub fn mipmap_precision_bits(&self) -> u32 {
        self.mipmap_precision_bits
    }
    ///Gets the value of [`Self::max_draw_indexed_index_value`]
    pub fn max_draw_indexed_index_value(&self) -> u32 {
        self.max_draw_indexed_index_value
    }
    ///Gets the value of [`Self::max_draw_indirect_count`]
    pub fn max_draw_indirect_count(&self) -> u32 {
        self.max_draw_indirect_count
    }
    ///Gets the value of [`Self::max_sampler_lod_bias`]
    pub fn max_sampler_lod_bias(&self) -> f32 {
        self.max_sampler_lod_bias
    }
    ///Gets the value of [`Self::max_sampler_anisotropy`]
    pub fn max_sampler_anisotropy(&self) -> f32 {
        self.max_sampler_anisotropy
    }
    ///Gets the value of [`Self::max_viewports`]
    pub fn max_viewports(&self) -> u32 {
        self.max_viewports
    }
    ///Gets the value of [`Self::max_viewport_dimensions`]
    pub fn max_viewport_dimensions(&self) -> &[u32; 2] {
        &getter
    }
    ///Gets the value of [`Self::viewport_bounds_range`]
    pub fn viewport_bounds_range(&self) -> &[f32; 2] {
        &getter
    }
    ///Gets the value of [`Self::viewport_sub_pixel_bits`]
    pub fn viewport_sub_pixel_bits(&self) -> u32 {
        self.viewport_sub_pixel_bits
    }
    ///Gets the value of [`Self::min_memory_map_alignment`]
    pub fn min_memory_map_alignment(&self) -> usize {
        self.min_memory_map_alignment
    }
    ///Gets the value of [`Self::min_texel_buffer_offset_alignment`]
    pub fn min_texel_buffer_offset_alignment(&self) -> DeviceSize {
        self.min_texel_buffer_offset_alignment
    }
    ///Gets the value of [`Self::min_uniform_buffer_offset_alignment`]
    pub fn min_uniform_buffer_offset_alignment(&self) -> DeviceSize {
        self.min_uniform_buffer_offset_alignment
    }
    ///Gets the value of [`Self::min_storage_buffer_offset_alignment`]
    pub fn min_storage_buffer_offset_alignment(&self) -> DeviceSize {
        self.min_storage_buffer_offset_alignment
    }
    ///Gets the value of [`Self::min_texel_offset`]
    pub fn min_texel_offset(&self) -> i32 {
        self.min_texel_offset
    }
    ///Gets the value of [`Self::max_texel_offset`]
    pub fn max_texel_offset(&self) -> u32 {
        self.max_texel_offset
    }
    ///Gets the value of [`Self::min_texel_gather_offset`]
    pub fn min_texel_gather_offset(&self) -> i32 {
        self.min_texel_gather_offset
    }
    ///Gets the value of [`Self::max_texel_gather_offset`]
    pub fn max_texel_gather_offset(&self) -> u32 {
        self.max_texel_gather_offset
    }
    ///Gets the value of [`Self::min_interpolation_offset`]
    pub fn min_interpolation_offset(&self) -> f32 {
        self.min_interpolation_offset
    }
    ///Gets the value of [`Self::max_interpolation_offset`]
    pub fn max_interpolation_offset(&self) -> f32 {
        self.max_interpolation_offset
    }
    ///Gets the value of [`Self::sub_pixel_interpolation_offset_bits`]
    pub fn sub_pixel_interpolation_offset_bits(&self) -> u32 {
        self.sub_pixel_interpolation_offset_bits
    }
    ///Gets the value of [`Self::max_framebuffer_width`]
    pub fn max_framebuffer_width(&self) -> u32 {
        self.max_framebuffer_width
    }
    ///Gets the value of [`Self::max_framebuffer_height`]
    pub fn max_framebuffer_height(&self) -> u32 {
        self.max_framebuffer_height
    }
    ///Gets the value of [`Self::max_framebuffer_layers`]
    pub fn max_framebuffer_layers(&self) -> u32 {
        self.max_framebuffer_layers
    }
    ///Gets the value of [`Self::framebuffer_color_sample_counts`]
    pub fn framebuffer_color_sample_counts(&self) -> SampleCountFlags {
        self.framebuffer_color_sample_counts
    }
    ///Gets the value of [`Self::framebuffer_depth_sample_counts`]
    pub fn framebuffer_depth_sample_counts(&self) -> SampleCountFlags {
        self.framebuffer_depth_sample_counts
    }
    ///Gets the value of [`Self::framebuffer_stencil_sample_counts`]
    pub fn framebuffer_stencil_sample_counts(&self) -> SampleCountFlags {
        self.framebuffer_stencil_sample_counts
    }
    ///Gets the value of [`Self::framebuffer_no_attachments_sample_counts`]
    pub fn framebuffer_no_attachments_sample_counts(&self) -> SampleCountFlags {
        self.framebuffer_no_attachments_sample_counts
    }
    ///Gets the value of [`Self::max_color_attachments`]
    pub fn max_color_attachments(&self) -> u32 {
        self.max_color_attachments
    }
    ///Gets the value of [`Self::sampled_image_color_sample_counts`]
    pub fn sampled_image_color_sample_counts(&self) -> SampleCountFlags {
        self.sampled_image_color_sample_counts
    }
    ///Gets the value of [`Self::sampled_image_integer_sample_counts`]
    pub fn sampled_image_integer_sample_counts(&self) -> SampleCountFlags {
        self.sampled_image_integer_sample_counts
    }
    ///Gets the value of [`Self::sampled_image_depth_sample_counts`]
    pub fn sampled_image_depth_sample_counts(&self) -> SampleCountFlags {
        self.sampled_image_depth_sample_counts
    }
    ///Gets the value of [`Self::sampled_image_stencil_sample_counts`]
    pub fn sampled_image_stencil_sample_counts(&self) -> SampleCountFlags {
        self.sampled_image_stencil_sample_counts
    }
    ///Gets the value of [`Self::storage_image_sample_counts`]
    pub fn storage_image_sample_counts(&self) -> SampleCountFlags {
        self.storage_image_sample_counts
    }
    ///Gets the value of [`Self::max_sample_mask_words`]
    pub fn max_sample_mask_words(&self) -> u32 {
        self.max_sample_mask_words
    }
    ///Gets the value of [`Self::timestamp_compute_and_graphics`]
    pub fn timestamp_compute_and_graphics(&self) -> bool {
        unsafe { std::mem::transmute(self.timestamp_compute_and_graphics as u8) }
    }
    ///Gets the value of [`Self::timestamp_period`]
    pub fn timestamp_period(&self) -> f32 {
        self.timestamp_period
    }
    ///Gets the value of [`Self::max_clip_distances`]
    pub fn max_clip_distances(&self) -> u32 {
        self.max_clip_distances
    }
    ///Gets the value of [`Self::max_cull_distances`]
    pub fn max_cull_distances(&self) -> u32 {
        self.max_cull_distances
    }
    ///Gets the value of [`Self::max_combined_clip_and_cull_distances`]
    pub fn max_combined_clip_and_cull_distances(&self) -> u32 {
        self.max_combined_clip_and_cull_distances
    }
    ///Gets the value of [`Self::discrete_queue_priorities`]
    pub fn discrete_queue_priorities(&self) -> u32 {
        self.discrete_queue_priorities
    }
    ///Gets the value of [`Self::point_size_range`]
    pub fn point_size_range(&self) -> &[f32; 2] {
        &getter
    }
    ///Gets the value of [`Self::line_width_range`]
    pub fn line_width_range(&self) -> &[f32; 2] {
        &getter
    }
    ///Gets the value of [`Self::point_size_granularity`]
    pub fn point_size_granularity(&self) -> f32 {
        self.point_size_granularity
    }
    ///Gets the value of [`Self::line_width_granularity`]
    pub fn line_width_granularity(&self) -> f32 {
        self.line_width_granularity
    }
    ///Gets the value of [`Self::strict_lines`]
    pub fn strict_lines(&self) -> bool {
        unsafe { std::mem::transmute(self.strict_lines as u8) }
    }
    ///Gets the value of [`Self::standard_sample_locations`]
    pub fn standard_sample_locations(&self) -> bool {
        unsafe { std::mem::transmute(self.standard_sample_locations as u8) }
    }
    ///Gets the value of [`Self::optimal_buffer_copy_offset_alignment`]
    pub fn optimal_buffer_copy_offset_alignment(&self) -> DeviceSize {
        self.optimal_buffer_copy_offset_alignment
    }
    ///Gets the value of [`Self::optimal_buffer_copy_row_pitch_alignment`]
    pub fn optimal_buffer_copy_row_pitch_alignment(&self) -> DeviceSize {
        self.optimal_buffer_copy_row_pitch_alignment
    }
    ///Gets the value of [`Self::non_coherent_atom_size`]
    pub fn non_coherent_atom_size(&self) -> DeviceSize {
        self.non_coherent_atom_size
    }
    ///Gets a mutable reference to the value of [`Self::max_image_dimension_1_d`]
    pub fn max_image_dimension_1_d_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::max_image_dimension_2_d`]
    pub fn max_image_dimension_2_d_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::max_image_dimension_3_d`]
    pub fn max_image_dimension_3_d_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::max_image_dimension_cube`]
    pub fn max_image_dimension_cube_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::max_image_array_layers`]
    pub fn max_image_array_layers_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::max_texel_buffer_elements`]
    pub fn max_texel_buffer_elements_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::max_uniform_buffer_range`]
    pub fn max_uniform_buffer_range_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::max_storage_buffer_range`]
    pub fn max_storage_buffer_range_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::max_push_constants_size`]
    pub fn max_push_constants_size_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::max_memory_allocation_count`]
    pub fn max_memory_allocation_count_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::max_sampler_allocation_count`]
    pub fn max_sampler_allocation_count_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::buffer_image_granularity`]
    pub fn buffer_image_granularity_mut(&mut self) -> &mut DeviceSize {
        &mut self.buffer_image_granularity
    }
    ///Gets a mutable reference to the value of [`Self::sparse_address_space_size`]
    pub fn sparse_address_space_size_mut(&mut self) -> &mut DeviceSize {
        &mut self.sparse_address_space_size
    }
    ///Gets a mutable reference to the value of [`Self::max_bound_descriptor_sets`]
    pub fn max_bound_descriptor_sets_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::max_per_stage_descriptor_samplers`]
    pub fn max_per_stage_descriptor_samplers_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::max_per_stage_descriptor_uniform_buffers`]
    pub fn max_per_stage_descriptor_uniform_buffers_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::max_per_stage_descriptor_storage_buffers`]
    pub fn max_per_stage_descriptor_storage_buffers_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::max_per_stage_descriptor_sampled_images`]
    pub fn max_per_stage_descriptor_sampled_images_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::max_per_stage_descriptor_storage_images`]
    pub fn max_per_stage_descriptor_storage_images_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of
    /// [`Self::max_per_stage_descriptor_input_attachments`]
    pub fn max_per_stage_descriptor_input_attachments_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::max_per_stage_resources`]
    pub fn max_per_stage_resources_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::max_descriptor_set_samplers`]
    pub fn max_descriptor_set_samplers_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::max_descriptor_set_uniform_buffers`]
    pub fn max_descriptor_set_uniform_buffers_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of
    /// [`Self::max_descriptor_set_uniform_buffers_dynamic`]
    pub fn max_descriptor_set_uniform_buffers_dynamic_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::max_descriptor_set_storage_buffers`]
    pub fn max_descriptor_set_storage_buffers_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of
    /// [`Self::max_descriptor_set_storage_buffers_dynamic`]
    pub fn max_descriptor_set_storage_buffers_dynamic_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::max_descriptor_set_sampled_images`]
    pub fn max_descriptor_set_sampled_images_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::max_descriptor_set_storage_images`]
    pub fn max_descriptor_set_storage_images_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::max_descriptor_set_input_attachments`]
    pub fn max_descriptor_set_input_attachments_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::max_vertex_input_attributes`]
    pub fn max_vertex_input_attributes_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::max_vertex_input_bindings`]
    pub fn max_vertex_input_bindings_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::max_vertex_input_attribute_offset`]
    pub fn max_vertex_input_attribute_offset_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::max_vertex_input_binding_stride`]
    pub fn max_vertex_input_binding_stride_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::max_vertex_output_components`]
    pub fn max_vertex_output_components_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::max_tessellation_generation_level`]
    pub fn max_tessellation_generation_level_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::max_tessellation_patch_size`]
    pub fn max_tessellation_patch_size_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of
    /// [`Self::max_tessellation_control_per_vertex_input_components`]
    pub fn max_tessellation_control_per_vertex_input_components_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of
    /// [`Self::max_tessellation_control_per_vertex_output_components`]
    pub fn max_tessellation_control_per_vertex_output_components_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of
    /// [`Self::max_tessellation_control_per_patch_output_components`]
    pub fn max_tessellation_control_per_patch_output_components_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of
    /// [`Self::max_tessellation_control_total_output_components`]
    pub fn max_tessellation_control_total_output_components_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of
    /// [`Self::max_tessellation_evaluation_input_components`]
    pub fn max_tessellation_evaluation_input_components_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of
    /// [`Self::max_tessellation_evaluation_output_components`]
    pub fn max_tessellation_evaluation_output_components_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::max_geometry_shader_invocations`]
    pub fn max_geometry_shader_invocations_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::max_geometry_input_components`]
    pub fn max_geometry_input_components_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::max_geometry_output_components`]
    pub fn max_geometry_output_components_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::max_geometry_output_vertices`]
    pub fn max_geometry_output_vertices_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::max_geometry_total_output_components`]
    pub fn max_geometry_total_output_components_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::max_fragment_input_components`]
    pub fn max_fragment_input_components_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::max_fragment_output_attachments`]
    pub fn max_fragment_output_attachments_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::max_fragment_dual_src_attachments`]
    pub fn max_fragment_dual_src_attachments_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::max_fragment_combined_output_resources`]
    pub fn max_fragment_combined_output_resources_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::max_compute_shared_memory_size`]
    pub fn max_compute_shared_memory_size_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::max_compute_work_group_count`]
    pub fn max_compute_work_group_count_mut(&mut self) -> &mut [u32; 3] {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::max_compute_work_group_invocations`]
    pub fn max_compute_work_group_invocations_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::max_compute_work_group_size`]
    pub fn max_compute_work_group_size_mut(&mut self) -> &mut [u32; 3] {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::sub_pixel_precision_bits`]
    pub fn sub_pixel_precision_bits_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::sub_texel_precision_bits`]
    pub fn sub_texel_precision_bits_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::mipmap_precision_bits`]
    pub fn mipmap_precision_bits_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::max_draw_indexed_index_value`]
    pub fn max_draw_indexed_index_value_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::max_draw_indirect_count`]
    pub fn max_draw_indirect_count_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::max_sampler_lod_bias`]
    pub fn max_sampler_lod_bias_mut(&mut self) -> &mut f32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::max_sampler_anisotropy`]
    pub fn max_sampler_anisotropy_mut(&mut self) -> &mut f32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::max_viewports`]
    pub fn max_viewports_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::max_viewport_dimensions`]
    pub fn max_viewport_dimensions_mut(&mut self) -> &mut [u32; 2] {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::viewport_bounds_range`]
    pub fn viewport_bounds_range_mut(&mut self) -> &mut [f32; 2] {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::viewport_sub_pixel_bits`]
    pub fn viewport_sub_pixel_bits_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::min_memory_map_alignment`]
    pub fn min_memory_map_alignment_mut(&mut self) -> &mut usize {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::min_texel_buffer_offset_alignment`]
    pub fn min_texel_buffer_offset_alignment_mut(&mut self) -> &mut DeviceSize {
        &mut self.min_texel_buffer_offset_alignment
    }
    ///Gets a mutable reference to the value of [`Self::min_uniform_buffer_offset_alignment`]
    pub fn min_uniform_buffer_offset_alignment_mut(&mut self) -> &mut DeviceSize {
        &mut self.min_uniform_buffer_offset_alignment
    }
    ///Gets a mutable reference to the value of [`Self::min_storage_buffer_offset_alignment`]
    pub fn min_storage_buffer_offset_alignment_mut(&mut self) -> &mut DeviceSize {
        &mut self.min_storage_buffer_offset_alignment
    }
    ///Gets a mutable reference to the value of [`Self::min_texel_offset`]
    pub fn min_texel_offset_mut(&mut self) -> &mut i32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::max_texel_offset`]
    pub fn max_texel_offset_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::min_texel_gather_offset`]
    pub fn min_texel_gather_offset_mut(&mut self) -> &mut i32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::max_texel_gather_offset`]
    pub fn max_texel_gather_offset_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::min_interpolation_offset`]
    pub fn min_interpolation_offset_mut(&mut self) -> &mut f32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::max_interpolation_offset`]
    pub fn max_interpolation_offset_mut(&mut self) -> &mut f32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::sub_pixel_interpolation_offset_bits`]
    pub fn sub_pixel_interpolation_offset_bits_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::max_framebuffer_width`]
    pub fn max_framebuffer_width_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::max_framebuffer_height`]
    pub fn max_framebuffer_height_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::max_framebuffer_layers`]
    pub fn max_framebuffer_layers_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::framebuffer_color_sample_counts`]
    pub fn framebuffer_color_sample_counts_mut(&mut self) -> &mut SampleCountFlags {
        &mut self.framebuffer_color_sample_counts
    }
    ///Gets a mutable reference to the value of [`Self::framebuffer_depth_sample_counts`]
    pub fn framebuffer_depth_sample_counts_mut(&mut self) -> &mut SampleCountFlags {
        &mut self.framebuffer_depth_sample_counts
    }
    ///Gets a mutable reference to the value of [`Self::framebuffer_stencil_sample_counts`]
    pub fn framebuffer_stencil_sample_counts_mut(&mut self) -> &mut SampleCountFlags {
        &mut self.framebuffer_stencil_sample_counts
    }
    ///Gets a mutable reference to the value of [`Self::framebuffer_no_attachments_sample_counts`]
    pub fn framebuffer_no_attachments_sample_counts_mut(&mut self) -> &mut SampleCountFlags {
        &mut self.framebuffer_no_attachments_sample_counts
    }
    ///Gets a mutable reference to the value of [`Self::max_color_attachments`]
    pub fn max_color_attachments_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::sampled_image_color_sample_counts`]
    pub fn sampled_image_color_sample_counts_mut(&mut self) -> &mut SampleCountFlags {
        &mut self.sampled_image_color_sample_counts
    }
    ///Gets a mutable reference to the value of [`Self::sampled_image_integer_sample_counts`]
    pub fn sampled_image_integer_sample_counts_mut(&mut self) -> &mut SampleCountFlags {
        &mut self.sampled_image_integer_sample_counts
    }
    ///Gets a mutable reference to the value of [`Self::sampled_image_depth_sample_counts`]
    pub fn sampled_image_depth_sample_counts_mut(&mut self) -> &mut SampleCountFlags {
        &mut self.sampled_image_depth_sample_counts
    }
    ///Gets a mutable reference to the value of [`Self::sampled_image_stencil_sample_counts`]
    pub fn sampled_image_stencil_sample_counts_mut(&mut self) -> &mut SampleCountFlags {
        &mut self.sampled_image_stencil_sample_counts
    }
    ///Gets a mutable reference to the value of [`Self::storage_image_sample_counts`]
    pub fn storage_image_sample_counts_mut(&mut self) -> &mut SampleCountFlags {
        &mut self.storage_image_sample_counts
    }
    ///Gets a mutable reference to the value of [`Self::max_sample_mask_words`]
    pub fn max_sample_mask_words_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::timestamp_compute_and_graphics`]
    pub fn timestamp_compute_and_graphics_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.timestamp_compute_and_graphics as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.timestamp_compute_and_graphics as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of [`Self::timestamp_period`]
    pub fn timestamp_period_mut(&mut self) -> &mut f32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::max_clip_distances`]
    pub fn max_clip_distances_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::max_cull_distances`]
    pub fn max_cull_distances_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::max_combined_clip_and_cull_distances`]
    pub fn max_combined_clip_and_cull_distances_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::discrete_queue_priorities`]
    pub fn discrete_queue_priorities_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::point_size_range`]
    pub fn point_size_range_mut(&mut self) -> &mut [f32; 2] {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::line_width_range`]
    pub fn line_width_range_mut(&mut self) -> &mut [f32; 2] {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::point_size_granularity`]
    pub fn point_size_granularity_mut(&mut self) -> &mut f32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::line_width_granularity`]
    pub fn line_width_granularity_mut(&mut self) -> &mut f32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::strict_lines`]
    pub fn strict_lines_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.strict_lines as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.strict_lines as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of [`Self::standard_sample_locations`]
    pub fn standard_sample_locations_mut(&mut self) -> &mut bool {
        unsafe {
            if cfg!(target_endian = "little") {
                &mut *(self.standard_sample_locations as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .cast::<bool>()
            } else {
                eprintln!("Big-endianess has not been tested!");
                &mut *(self.standard_sample_locations as *mut Bool32)
                    .cast::<u32>()
                    .cast::<u8>()
                    .add(3)
                    .cast::<bool>()
            }
        }
    }
    ///Gets a mutable reference to the value of [`Self::optimal_buffer_copy_offset_alignment`]
    pub fn optimal_buffer_copy_offset_alignment_mut(&mut self) -> &mut DeviceSize {
        &mut self.optimal_buffer_copy_offset_alignment
    }
    ///Gets a mutable reference to the value of [`Self::optimal_buffer_copy_row_pitch_alignment`]
    pub fn optimal_buffer_copy_row_pitch_alignment_mut(&mut self) -> &mut DeviceSize {
        &mut self.optimal_buffer_copy_row_pitch_alignment
    }
    ///Gets a mutable reference to the value of [`Self::non_coherent_atom_size`]
    pub fn non_coherent_atom_size_mut(&mut self) -> &mut DeviceSize {
        &mut self.non_coherent_atom_size
    }
    ///Sets the raw value of [`Self::max_image_dimension_1_d`]
    pub fn set_max_image_dimension_1_d(&mut self, value: u32) -> &mut Self {
        self.max_image_dimension_1_d = value;
        self
    }
    ///Sets the raw value of [`Self::max_image_dimension_2_d`]
    pub fn set_max_image_dimension_2_d(&mut self, value: u32) -> &mut Self {
        self.max_image_dimension_2_d = value;
        self
    }
    ///Sets the raw value of [`Self::max_image_dimension_3_d`]
    pub fn set_max_image_dimension_3_d(&mut self, value: u32) -> &mut Self {
        self.max_image_dimension_3_d = value;
        self
    }
    ///Sets the raw value of [`Self::max_image_dimension_cube`]
    pub fn set_max_image_dimension_cube(&mut self, value: u32) -> &mut Self {
        self.max_image_dimension_cube = value;
        self
    }
    ///Sets the raw value of [`Self::max_image_array_layers`]
    pub fn set_max_image_array_layers(&mut self, value: u32) -> &mut Self {
        self.max_image_array_layers = value;
        self
    }
    ///Sets the raw value of [`Self::max_texel_buffer_elements`]
    pub fn set_max_texel_buffer_elements(&mut self, value: u32) -> &mut Self {
        self.max_texel_buffer_elements = value;
        self
    }
    ///Sets the raw value of [`Self::max_uniform_buffer_range`]
    pub fn set_max_uniform_buffer_range(&mut self, value: u32) -> &mut Self {
        self.max_uniform_buffer_range = value;
        self
    }
    ///Sets the raw value of [`Self::max_storage_buffer_range`]
    pub fn set_max_storage_buffer_range(&mut self, value: u32) -> &mut Self {
        self.max_storage_buffer_range = value;
        self
    }
    ///Sets the raw value of [`Self::max_push_constants_size`]
    pub fn set_max_push_constants_size(&mut self, value: u32) -> &mut Self {
        self.max_push_constants_size = value;
        self
    }
    ///Sets the raw value of [`Self::max_memory_allocation_count`]
    pub fn set_max_memory_allocation_count(&mut self, value: u32) -> &mut Self {
        self.max_memory_allocation_count = value;
        self
    }
    ///Sets the raw value of [`Self::max_sampler_allocation_count`]
    pub fn set_max_sampler_allocation_count(&mut self, value: u32) -> &mut Self {
        self.max_sampler_allocation_count = value;
        self
    }
    ///Sets the raw value of [`Self::buffer_image_granularity`]
    pub fn set_buffer_image_granularity(&mut self, value: crate::vulkan1_0::DeviceSize) -> &mut Self {
        self.buffer_image_granularity = value;
        self
    }
    ///Sets the raw value of [`Self::sparse_address_space_size`]
    pub fn set_sparse_address_space_size(&mut self, value: crate::vulkan1_0::DeviceSize) -> &mut Self {
        self.sparse_address_space_size = value;
        self
    }
    ///Sets the raw value of [`Self::max_bound_descriptor_sets`]
    pub fn set_max_bound_descriptor_sets(&mut self, value: u32) -> &mut Self {
        self.max_bound_descriptor_sets = value;
        self
    }
    ///Sets the raw value of [`Self::max_per_stage_descriptor_samplers`]
    pub fn set_max_per_stage_descriptor_samplers(&mut self, value: u32) -> &mut Self {
        self.max_per_stage_descriptor_samplers = value;
        self
    }
    ///Sets the raw value of [`Self::max_per_stage_descriptor_uniform_buffers`]
    pub fn set_max_per_stage_descriptor_uniform_buffers(&mut self, value: u32) -> &mut Self {
        self.max_per_stage_descriptor_uniform_buffers = value;
        self
    }
    ///Sets the raw value of [`Self::max_per_stage_descriptor_storage_buffers`]
    pub fn set_max_per_stage_descriptor_storage_buffers(&mut self, value: u32) -> &mut Self {
        self.max_per_stage_descriptor_storage_buffers = value;
        self
    }
    ///Sets the raw value of [`Self::max_per_stage_descriptor_sampled_images`]
    pub fn set_max_per_stage_descriptor_sampled_images(&mut self, value: u32) -> &mut Self {
        self.max_per_stage_descriptor_sampled_images = value;
        self
    }
    ///Sets the raw value of [`Self::max_per_stage_descriptor_storage_images`]
    pub fn set_max_per_stage_descriptor_storage_images(&mut self, value: u32) -> &mut Self {
        self.max_per_stage_descriptor_storage_images = value;
        self
    }
    ///Sets the raw value of [`Self::max_per_stage_descriptor_input_attachments`]
    pub fn set_max_per_stage_descriptor_input_attachments(&mut self, value: u32) -> &mut Self {
        self.max_per_stage_descriptor_input_attachments = value;
        self
    }
    ///Sets the raw value of [`Self::max_per_stage_resources`]
    pub fn set_max_per_stage_resources(&mut self, value: u32) -> &mut Self {
        self.max_per_stage_resources = value;
        self
    }
    ///Sets the raw value of [`Self::max_descriptor_set_samplers`]
    pub fn set_max_descriptor_set_samplers(&mut self, value: u32) -> &mut Self {
        self.max_descriptor_set_samplers = value;
        self
    }
    ///Sets the raw value of [`Self::max_descriptor_set_uniform_buffers`]
    pub fn set_max_descriptor_set_uniform_buffers(&mut self, value: u32) -> &mut Self {
        self.max_descriptor_set_uniform_buffers = value;
        self
    }
    ///Sets the raw value of [`Self::max_descriptor_set_uniform_buffers_dynamic`]
    pub fn set_max_descriptor_set_uniform_buffers_dynamic(&mut self, value: u32) -> &mut Self {
        self.max_descriptor_set_uniform_buffers_dynamic = value;
        self
    }
    ///Sets the raw value of [`Self::max_descriptor_set_storage_buffers`]
    pub fn set_max_descriptor_set_storage_buffers(&mut self, value: u32) -> &mut Self {
        self.max_descriptor_set_storage_buffers = value;
        self
    }
    ///Sets the raw value of [`Self::max_descriptor_set_storage_buffers_dynamic`]
    pub fn set_max_descriptor_set_storage_buffers_dynamic(&mut self, value: u32) -> &mut Self {
        self.max_descriptor_set_storage_buffers_dynamic = value;
        self
    }
    ///Sets the raw value of [`Self::max_descriptor_set_sampled_images`]
    pub fn set_max_descriptor_set_sampled_images(&mut self, value: u32) -> &mut Self {
        self.max_descriptor_set_sampled_images = value;
        self
    }
    ///Sets the raw value of [`Self::max_descriptor_set_storage_images`]
    pub fn set_max_descriptor_set_storage_images(&mut self, value: u32) -> &mut Self {
        self.max_descriptor_set_storage_images = value;
        self
    }
    ///Sets the raw value of [`Self::max_descriptor_set_input_attachments`]
    pub fn set_max_descriptor_set_input_attachments(&mut self, value: u32) -> &mut Self {
        self.max_descriptor_set_input_attachments = value;
        self
    }
    ///Sets the raw value of [`Self::max_vertex_input_attributes`]
    pub fn set_max_vertex_input_attributes(&mut self, value: u32) -> &mut Self {
        self.max_vertex_input_attributes = value;
        self
    }
    ///Sets the raw value of [`Self::max_vertex_input_bindings`]
    pub fn set_max_vertex_input_bindings(&mut self, value: u32) -> &mut Self {
        self.max_vertex_input_bindings = value;
        self
    }
    ///Sets the raw value of [`Self::max_vertex_input_attribute_offset`]
    pub fn set_max_vertex_input_attribute_offset(&mut self, value: u32) -> &mut Self {
        self.max_vertex_input_attribute_offset = value;
        self
    }
    ///Sets the raw value of [`Self::max_vertex_input_binding_stride`]
    pub fn set_max_vertex_input_binding_stride(&mut self, value: u32) -> &mut Self {
        self.max_vertex_input_binding_stride = value;
        self
    }
    ///Sets the raw value of [`Self::max_vertex_output_components`]
    pub fn set_max_vertex_output_components(&mut self, value: u32) -> &mut Self {
        self.max_vertex_output_components = value;
        self
    }
    ///Sets the raw value of [`Self::max_tessellation_generation_level`]
    pub fn set_max_tessellation_generation_level(&mut self, value: u32) -> &mut Self {
        self.max_tessellation_generation_level = value;
        self
    }
    ///Sets the raw value of [`Self::max_tessellation_patch_size`]
    pub fn set_max_tessellation_patch_size(&mut self, value: u32) -> &mut Self {
        self.max_tessellation_patch_size = value;
        self
    }
    ///Sets the raw value of [`Self::max_tessellation_control_per_vertex_input_components`]
    pub fn set_max_tessellation_control_per_vertex_input_components(&mut self, value: u32) -> &mut Self {
        self.max_tessellation_control_per_vertex_input_components = value;
        self
    }
    ///Sets the raw value of [`Self::max_tessellation_control_per_vertex_output_components`]
    pub fn set_max_tessellation_control_per_vertex_output_components(&mut self, value: u32) -> &mut Self {
        self.max_tessellation_control_per_vertex_output_components = value;
        self
    }
    ///Sets the raw value of [`Self::max_tessellation_control_per_patch_output_components`]
    pub fn set_max_tessellation_control_per_patch_output_components(&mut self, value: u32) -> &mut Self {
        self.max_tessellation_control_per_patch_output_components = value;
        self
    }
    ///Sets the raw value of [`Self::max_tessellation_control_total_output_components`]
    pub fn set_max_tessellation_control_total_output_components(&mut self, value: u32) -> &mut Self {
        self.max_tessellation_control_total_output_components = value;
        self
    }
    ///Sets the raw value of [`Self::max_tessellation_evaluation_input_components`]
    pub fn set_max_tessellation_evaluation_input_components(&mut self, value: u32) -> &mut Self {
        self.max_tessellation_evaluation_input_components = value;
        self
    }
    ///Sets the raw value of [`Self::max_tessellation_evaluation_output_components`]
    pub fn set_max_tessellation_evaluation_output_components(&mut self, value: u32) -> &mut Self {
        self.max_tessellation_evaluation_output_components = value;
        self
    }
    ///Sets the raw value of [`Self::max_geometry_shader_invocations`]
    pub fn set_max_geometry_shader_invocations(&mut self, value: u32) -> &mut Self {
        self.max_geometry_shader_invocations = value;
        self
    }
    ///Sets the raw value of [`Self::max_geometry_input_components`]
    pub fn set_max_geometry_input_components(&mut self, value: u32) -> &mut Self {
        self.max_geometry_input_components = value;
        self
    }
    ///Sets the raw value of [`Self::max_geometry_output_components`]
    pub fn set_max_geometry_output_components(&mut self, value: u32) -> &mut Self {
        self.max_geometry_output_components = value;
        self
    }
    ///Sets the raw value of [`Self::max_geometry_output_vertices`]
    pub fn set_max_geometry_output_vertices(&mut self, value: u32) -> &mut Self {
        self.max_geometry_output_vertices = value;
        self
    }
    ///Sets the raw value of [`Self::max_geometry_total_output_components`]
    pub fn set_max_geometry_total_output_components(&mut self, value: u32) -> &mut Self {
        self.max_geometry_total_output_components = value;
        self
    }
    ///Sets the raw value of [`Self::max_fragment_input_components`]
    pub fn set_max_fragment_input_components(&mut self, value: u32) -> &mut Self {
        self.max_fragment_input_components = value;
        self
    }
    ///Sets the raw value of [`Self::max_fragment_output_attachments`]
    pub fn set_max_fragment_output_attachments(&mut self, value: u32) -> &mut Self {
        self.max_fragment_output_attachments = value;
        self
    }
    ///Sets the raw value of [`Self::max_fragment_dual_src_attachments`]
    pub fn set_max_fragment_dual_src_attachments(&mut self, value: u32) -> &mut Self {
        self.max_fragment_dual_src_attachments = value;
        self
    }
    ///Sets the raw value of [`Self::max_fragment_combined_output_resources`]
    pub fn set_max_fragment_combined_output_resources(&mut self, value: u32) -> &mut Self {
        self.max_fragment_combined_output_resources = value;
        self
    }
    ///Sets the raw value of [`Self::max_compute_shared_memory_size`]
    pub fn set_max_compute_shared_memory_size(&mut self, value: u32) -> &mut Self {
        self.max_compute_shared_memory_size = value;
        self
    }
    ///Sets the raw value of [`Self::max_compute_work_group_count`]
    pub fn set_max_compute_work_group_count(&mut self, value: [u32; 3]) -> &mut Self {
        self.max_compute_work_group_count = value;
        self
    }
    ///Sets the raw value of [`Self::max_compute_work_group_invocations`]
    pub fn set_max_compute_work_group_invocations(&mut self, value: u32) -> &mut Self {
        self.max_compute_work_group_invocations = value;
        self
    }
    ///Sets the raw value of [`Self::max_compute_work_group_size`]
    pub fn set_max_compute_work_group_size(&mut self, value: [u32; 3]) -> &mut Self {
        self.max_compute_work_group_size = value;
        self
    }
    ///Sets the raw value of [`Self::sub_pixel_precision_bits`]
    pub fn set_sub_pixel_precision_bits(&mut self, value: u32) -> &mut Self {
        self.sub_pixel_precision_bits = value;
        self
    }
    ///Sets the raw value of [`Self::sub_texel_precision_bits`]
    pub fn set_sub_texel_precision_bits(&mut self, value: u32) -> &mut Self {
        self.sub_texel_precision_bits = value;
        self
    }
    ///Sets the raw value of [`Self::mipmap_precision_bits`]
    pub fn set_mipmap_precision_bits(&mut self, value: u32) -> &mut Self {
        self.mipmap_precision_bits = value;
        self
    }
    ///Sets the raw value of [`Self::max_draw_indexed_index_value`]
    pub fn set_max_draw_indexed_index_value(&mut self, value: u32) -> &mut Self {
        self.max_draw_indexed_index_value = value;
        self
    }
    ///Sets the raw value of [`Self::max_draw_indirect_count`]
    pub fn set_max_draw_indirect_count(&mut self, value: u32) -> &mut Self {
        self.max_draw_indirect_count = value;
        self
    }
    ///Sets the raw value of [`Self::max_sampler_lod_bias`]
    pub fn set_max_sampler_lod_bias(&mut self, value: f32) -> &mut Self {
        self.max_sampler_lod_bias = value;
        self
    }
    ///Sets the raw value of [`Self::max_sampler_anisotropy`]
    pub fn set_max_sampler_anisotropy(&mut self, value: f32) -> &mut Self {
        self.max_sampler_anisotropy = value;
        self
    }
    ///Sets the raw value of [`Self::max_viewports`]
    pub fn set_max_viewports(&mut self, value: u32) -> &mut Self {
        self.max_viewports = value;
        self
    }
    ///Sets the raw value of [`Self::max_viewport_dimensions`]
    pub fn set_max_viewport_dimensions(&mut self, value: [u32; 2]) -> &mut Self {
        self.max_viewport_dimensions = value;
        self
    }
    ///Sets the raw value of [`Self::viewport_bounds_range`]
    pub fn set_viewport_bounds_range(&mut self, value: [f32; 2]) -> &mut Self {
        self.viewport_bounds_range = value;
        self
    }
    ///Sets the raw value of [`Self::viewport_sub_pixel_bits`]
    pub fn set_viewport_sub_pixel_bits(&mut self, value: u32) -> &mut Self {
        self.viewport_sub_pixel_bits = value;
        self
    }
    ///Sets the raw value of [`Self::min_memory_map_alignment`]
    pub fn set_min_memory_map_alignment(&mut self, value: usize) -> &mut Self {
        self.min_memory_map_alignment = value;
        self
    }
    ///Sets the raw value of [`Self::min_texel_buffer_offset_alignment`]
    pub fn set_min_texel_buffer_offset_alignment(&mut self, value: crate::vulkan1_0::DeviceSize) -> &mut Self {
        self.min_texel_buffer_offset_alignment = value;
        self
    }
    ///Sets the raw value of [`Self::min_uniform_buffer_offset_alignment`]
    pub fn set_min_uniform_buffer_offset_alignment(&mut self, value: crate::vulkan1_0::DeviceSize) -> &mut Self {
        self.min_uniform_buffer_offset_alignment = value;
        self
    }
    ///Sets the raw value of [`Self::min_storage_buffer_offset_alignment`]
    pub fn set_min_storage_buffer_offset_alignment(&mut self, value: crate::vulkan1_0::DeviceSize) -> &mut Self {
        self.min_storage_buffer_offset_alignment = value;
        self
    }
    ///Sets the raw value of [`Self::min_texel_offset`]
    pub fn set_min_texel_offset(&mut self, value: i32) -> &mut Self {
        self.min_texel_offset = value;
        self
    }
    ///Sets the raw value of [`Self::max_texel_offset`]
    pub fn set_max_texel_offset(&mut self, value: u32) -> &mut Self {
        self.max_texel_offset = value;
        self
    }
    ///Sets the raw value of [`Self::min_texel_gather_offset`]
    pub fn set_min_texel_gather_offset(&mut self, value: i32) -> &mut Self {
        self.min_texel_gather_offset = value;
        self
    }
    ///Sets the raw value of [`Self::max_texel_gather_offset`]
    pub fn set_max_texel_gather_offset(&mut self, value: u32) -> &mut Self {
        self.max_texel_gather_offset = value;
        self
    }
    ///Sets the raw value of [`Self::min_interpolation_offset`]
    pub fn set_min_interpolation_offset(&mut self, value: f32) -> &mut Self {
        self.min_interpolation_offset = value;
        self
    }
    ///Sets the raw value of [`Self::max_interpolation_offset`]
    pub fn set_max_interpolation_offset(&mut self, value: f32) -> &mut Self {
        self.max_interpolation_offset = value;
        self
    }
    ///Sets the raw value of [`Self::sub_pixel_interpolation_offset_bits`]
    pub fn set_sub_pixel_interpolation_offset_bits(&mut self, value: u32) -> &mut Self {
        self.sub_pixel_interpolation_offset_bits = value;
        self
    }
    ///Sets the raw value of [`Self::max_framebuffer_width`]
    pub fn set_max_framebuffer_width(&mut self, value: u32) -> &mut Self {
        self.max_framebuffer_width = value;
        self
    }
    ///Sets the raw value of [`Self::max_framebuffer_height`]
    pub fn set_max_framebuffer_height(&mut self, value: u32) -> &mut Self {
        self.max_framebuffer_height = value;
        self
    }
    ///Sets the raw value of [`Self::max_framebuffer_layers`]
    pub fn set_max_framebuffer_layers(&mut self, value: u32) -> &mut Self {
        self.max_framebuffer_layers = value;
        self
    }
    ///Sets the raw value of [`Self::framebuffer_color_sample_counts`]
    pub fn set_framebuffer_color_sample_counts(&mut self, value: crate::vulkan1_0::SampleCountFlags) -> &mut Self {
        self.framebuffer_color_sample_counts = value;
        self
    }
    ///Sets the raw value of [`Self::framebuffer_depth_sample_counts`]
    pub fn set_framebuffer_depth_sample_counts(&mut self, value: crate::vulkan1_0::SampleCountFlags) -> &mut Self {
        self.framebuffer_depth_sample_counts = value;
        self
    }
    ///Sets the raw value of [`Self::framebuffer_stencil_sample_counts`]
    pub fn set_framebuffer_stencil_sample_counts(&mut self, value: crate::vulkan1_0::SampleCountFlags) -> &mut Self {
        self.framebuffer_stencil_sample_counts = value;
        self
    }
    ///Sets the raw value of [`Self::framebuffer_no_attachments_sample_counts`]
    pub fn set_framebuffer_no_attachments_sample_counts(
        &mut self,
        value: crate::vulkan1_0::SampleCountFlags,
    ) -> &mut Self {
        self.framebuffer_no_attachments_sample_counts = value;
        self
    }
    ///Sets the raw value of [`Self::max_color_attachments`]
    pub fn set_max_color_attachments(&mut self, value: u32) -> &mut Self {
        self.max_color_attachments = value;
        self
    }
    ///Sets the raw value of [`Self::sampled_image_color_sample_counts`]
    pub fn set_sampled_image_color_sample_counts(&mut self, value: crate::vulkan1_0::SampleCountFlags) -> &mut Self {
        self.sampled_image_color_sample_counts = value;
        self
    }
    ///Sets the raw value of [`Self::sampled_image_integer_sample_counts`]
    pub fn set_sampled_image_integer_sample_counts(&mut self, value: crate::vulkan1_0::SampleCountFlags) -> &mut Self {
        self.sampled_image_integer_sample_counts = value;
        self
    }
    ///Sets the raw value of [`Self::sampled_image_depth_sample_counts`]
    pub fn set_sampled_image_depth_sample_counts(&mut self, value: crate::vulkan1_0::SampleCountFlags) -> &mut Self {
        self.sampled_image_depth_sample_counts = value;
        self
    }
    ///Sets the raw value of [`Self::sampled_image_stencil_sample_counts`]
    pub fn set_sampled_image_stencil_sample_counts(&mut self, value: crate::vulkan1_0::SampleCountFlags) -> &mut Self {
        self.sampled_image_stencil_sample_counts = value;
        self
    }
    ///Sets the raw value of [`Self::storage_image_sample_counts`]
    pub fn set_storage_image_sample_counts(&mut self, value: crate::vulkan1_0::SampleCountFlags) -> &mut Self {
        self.storage_image_sample_counts = value;
        self
    }
    ///Sets the raw value of [`Self::max_sample_mask_words`]
    pub fn set_max_sample_mask_words(&mut self, value: u32) -> &mut Self {
        self.max_sample_mask_words = value;
        self
    }
    ///Sets the raw value of [`Self::timestamp_compute_and_graphics`]
    pub fn set_timestamp_compute_and_graphics(&mut self, value: bool) -> &mut Self {
        self.timestamp_compute_and_graphics = value as u8 as u32;
        self
    }
    ///Sets the raw value of [`Self::timestamp_period`]
    pub fn set_timestamp_period(&mut self, value: f32) -> &mut Self {
        self.timestamp_period = value;
        self
    }
    ///Sets the raw value of [`Self::max_clip_distances`]
    pub fn set_max_clip_distances(&mut self, value: u32) -> &mut Self {
        self.max_clip_distances = value;
        self
    }
    ///Sets the raw value of [`Self::max_cull_distances`]
    pub fn set_max_cull_distances(&mut self, value: u32) -> &mut Self {
        self.max_cull_distances = value;
        self
    }
    ///Sets the raw value of [`Self::max_combined_clip_and_cull_distances`]
    pub fn set_max_combined_clip_and_cull_distances(&mut self, value: u32) -> &mut Self {
        self.max_combined_clip_and_cull_distances = value;
        self
    }
    ///Sets the raw value of [`Self::discrete_queue_priorities`]
    pub fn set_discrete_queue_priorities(&mut self, value: u32) -> &mut Self {
        self.discrete_queue_priorities = value;
        self
    }
    ///Sets the raw value of [`Self::point_size_range`]
    pub fn set_point_size_range(&mut self, value: [f32; 2]) -> &mut Self {
        self.point_size_range = value;
        self
    }
    ///Sets the raw value of [`Self::line_width_range`]
    pub fn set_line_width_range(&mut self, value: [f32; 2]) -> &mut Self {
        self.line_width_range = value;
        self
    }
    ///Sets the raw value of [`Self::point_size_granularity`]
    pub fn set_point_size_granularity(&mut self, value: f32) -> &mut Self {
        self.point_size_granularity = value;
        self
    }
    ///Sets the raw value of [`Self::line_width_granularity`]
    pub fn set_line_width_granularity(&mut self, value: f32) -> &mut Self {
        self.line_width_granularity = value;
        self
    }
    ///Sets the raw value of [`Self::strict_lines`]
    pub fn set_strict_lines(&mut self, value: bool) -> &mut Self {
        self.strict_lines = value as u8 as u32;
        self
    }
    ///Sets the raw value of [`Self::standard_sample_locations`]
    pub fn set_standard_sample_locations(&mut self, value: bool) -> &mut Self {
        self.standard_sample_locations = value as u8 as u32;
        self
    }
    ///Sets the raw value of [`Self::optimal_buffer_copy_offset_alignment`]
    pub fn set_optimal_buffer_copy_offset_alignment(&mut self, value: crate::vulkan1_0::DeviceSize) -> &mut Self {
        self.optimal_buffer_copy_offset_alignment = value;
        self
    }
    ///Sets the raw value of [`Self::optimal_buffer_copy_row_pitch_alignment`]
    pub fn set_optimal_buffer_copy_row_pitch_alignment(&mut self, value: crate::vulkan1_0::DeviceSize) -> &mut Self {
        self.optimal_buffer_copy_row_pitch_alignment = value;
        self
    }
    ///Sets the raw value of [`Self::non_coherent_atom_size`]
    pub fn set_non_coherent_atom_size(&mut self, value: crate::vulkan1_0::DeviceSize) -> &mut Self {
        self.non_coherent_atom_size = value;
        self
    }
}
///[VkSemaphoreCreateInfo](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSemaphoreCreateInfo.html) - Structure specifying parameters of a newly created semaphore
///# C Specifications
///The [`SemaphoreCreateInfo`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkSemaphoreCreateInfo {
///    VkStructureType           sType;
///    const void*               pNext;
///    VkSemaphoreCreateFlags    flags;
///} VkSemaphoreCreateInfo;
///```
///# Members
/// - [`s_type`] is the type of this structure.
/// - [`p_next`] is `NULL` or a pointer to a structure extending this structure.
/// - [`flags`] is reserved for future use.
///# Description
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be `VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO`
/// - Each [`p_next`] member of any structure (including this one) in the [`p_next`] chain  **must**
///   be either `NULL` or a pointer to a valid instance of [`ExportSemaphoreCreateInfo`],
///   [`ExportSemaphoreWin32HandleInfoKHR`], or [`SemaphoreTypeCreateInfo`]
/// - The [`s_type`] value of each struct in the [`p_next`] chain  **must**  be unique
/// - [`flags`] **must**  be `0`
///# Related
/// - [`crate::vulkan1_0`]
/// - [`SemaphoreCreateFlags`]
/// - [`StructureType`]
/// - [`CreateSemaphore`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[repr(C)]
pub struct SemaphoreCreateInfo<'lt> {
    _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] is the type of this structure.
    s_type: StructureType,
    ///[`p_next`] is `NULL` or a pointer to a structure extending this
    ///structure.
    p_next: *const BaseInStructure<'lt>,
    ///[`flags`] is reserved for future use.
    flags: SemaphoreCreateFlags,
}
impl<'lt> Default for SemaphoreCreateInfo<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: Default::default(),
            p_next: std::ptr::null(),
            flags: Default::default(),
        }
    }
}
impl<'lt> SemaphoreCreateInfo<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *const BaseInStructure<'lt> {
        self.p_next
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *const BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseInStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::flags`]
    pub fn flags(&self) -> SemaphoreCreateFlags {
        self.flags
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::flags`]
    pub fn flags_mut(&mut self) -> &mut SemaphoreCreateFlags {
        &mut self.flags
    }
    ///Sets the raw value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the raw value of [`Self::flags`]
    pub fn set_flags(&mut self, value: crate::vulkan1_0::SemaphoreCreateFlags) -> &mut Self {
        self.flags = value;
        self
    }
}
///[VkQueryPoolCreateInfo](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkQueryPoolCreateInfo.html) - Structure specifying parameters of a newly created query pool
///# C Specifications
///The [`QueryPoolCreateInfo`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkQueryPoolCreateInfo {
///    VkStructureType                  sType;
///    const void*                      pNext;
///    VkQueryPoolCreateFlags           flags;
///    VkQueryType                      queryType;
///    uint32_t                         queryCount;
///    VkQueryPipelineStatisticFlags    pipelineStatistics;
///} VkQueryPoolCreateInfo;
///```
///# Members
/// - [`s_type`] is the type of this structure.
/// - [`p_next`] is `NULL` or a pointer to a structure extending this structure.
/// - [`flags`] is reserved for future use.
/// - [`query_type`] is a [`QueryType`] value specifying the type of queries managed by the pool.
/// - [`query_count`] is the number of queries managed by the pool.
/// - [`pipeline_statistics`] is a bitmask of [`QueryPipelineStatisticFlagBits`] specifying which counters will be returned in queries on the new pool, as described below in [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#queries-pipestats](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#queries-pipestats).
///# Description
///[`pipeline_statistics`] is ignored if [`query_type`] is not
///`VK_QUERY_TYPE_PIPELINE_STATISTICS`.
///## Valid Usage
/// - If the [pipeline statistics queries](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-pipelineStatisticsQuery)
///   feature is not enabled, [`query_type`] **must**  not be `VK_QUERY_TYPE_PIPELINE_STATISTICS`
/// - If [`query_type`] is `VK_QUERY_TYPE_PIPELINE_STATISTICS`, [`pipeline_statistics`] **must**  be
///   a valid combination of [`QueryPipelineStatisticFlagBits`] values
/// - If [`query_type`] is `VK_QUERY_TYPE_PERFORMANCE_QUERY_KHR`, the [`p_next`] chain  **must**
///   include a [`QueryPoolPerformanceCreateInfoKHR`] structure
/// - [`query_count`] **must**  be greater than 0
///
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be `VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO`
/// - Each [`p_next`] member of any structure (including this one) in the [`p_next`] chain  **must**
///   be either `NULL` or a pointer to a valid instance of [`QueryPoolPerformanceCreateInfoKHR`],
///   [`QueryPoolPerformanceQueryCreateInfoINTEL`], [`VideoDecodeH264ProfileEXT`],
///   [`VideoDecodeH265ProfileEXT`], [`VideoEncodeH264ProfileEXT`], [`VideoEncodeH265ProfileEXT`],
///   or [`VideoProfileKHR`]
/// - The [`s_type`] value of each struct in the [`p_next`] chain  **must**  be unique
/// - [`flags`] **must**  be `0`
/// - [`query_type`] **must**  be a valid [`QueryType`] value
///# Related
/// - [`crate::vulkan1_0`]
/// - [`QueryPipelineStatisticFlags`]
/// - [`QueryPoolCreateFlags`]
/// - [`QueryType`]
/// - [`StructureType`]
/// - [`CreateQueryPool`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[repr(C)]
pub struct QueryPoolCreateInfo<'lt> {
    _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] is the type of this structure.
    s_type: StructureType,
    ///[`p_next`] is `NULL` or a pointer to a structure extending this
    ///structure.
    p_next: *const BaseInStructure<'lt>,
    ///[`flags`] is reserved for future use.
    flags: QueryPoolCreateFlags,
    ///[`query_type`] is a [`QueryType`] value specifying the type of
    ///queries managed by the pool.
    query_type: QueryType,
    ///[`query_count`] is the number of queries managed by the pool.
    query_count: u32,
    ///[`pipeline_statistics`] is a bitmask of
    ///[`QueryPipelineStatisticFlagBits`] specifying which counters will be
    ///returned in queries on the new pool, as described below in
    ///[https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#queries-pipestats](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#queries-pipestats).
    pipeline_statistics: QueryPipelineStatisticFlags,
}
impl<'lt> Default for QueryPoolCreateInfo<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: Default::default(),
            p_next: std::ptr::null(),
            flags: Default::default(),
            query_type: Default::default(),
            query_count: 0,
            pipeline_statistics: Default::default(),
        }
    }
}
impl<'lt> QueryPoolCreateInfo<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *const BaseInStructure<'lt> {
        self.p_next
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *const BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseInStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::flags`]
    pub fn flags(&self) -> QueryPoolCreateFlags {
        self.flags
    }
    ///Gets the value of [`Self::query_type`]
    pub fn query_type(&self) -> QueryType {
        self.query_type
    }
    ///Gets the value of [`Self::query_count`]
    pub fn query_count(&self) -> u32 {
        self.query_count
    }
    ///Gets the value of [`Self::pipeline_statistics`]
    pub fn pipeline_statistics(&self) -> QueryPipelineStatisticFlags {
        self.pipeline_statistics
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::flags`]
    pub fn flags_mut(&mut self) -> &mut QueryPoolCreateFlags {
        &mut self.flags
    }
    ///Gets a mutable reference to the value of [`Self::query_type`]
    pub fn query_type_mut(&mut self) -> &mut QueryType {
        &mut self.query_type
    }
    ///Gets a mutable reference to the value of [`Self::query_count`]
    pub fn query_count_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::pipeline_statistics`]
    pub fn pipeline_statistics_mut(&mut self) -> &mut QueryPipelineStatisticFlags {
        &mut self.pipeline_statistics
    }
    ///Sets the raw value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the raw value of [`Self::flags`]
    pub fn set_flags(&mut self, value: crate::vulkan1_0::QueryPoolCreateFlags) -> &mut Self {
        self.flags = value;
        self
    }
    ///Sets the raw value of [`Self::query_type`]
    pub fn set_query_type(&mut self, value: crate::vulkan1_0::QueryType) -> &mut Self {
        self.query_type = value;
        self
    }
    ///Sets the raw value of [`Self::query_count`]
    pub fn set_query_count(&mut self, value: u32) -> &mut Self {
        self.query_count = value;
        self
    }
    ///Sets the raw value of [`Self::pipeline_statistics`]
    pub fn set_pipeline_statistics(&mut self, value: crate::vulkan1_0::QueryPipelineStatisticFlags) -> &mut Self {
        self.pipeline_statistics = value;
        self
    }
}
///[VkFramebufferCreateInfo](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFramebufferCreateInfo.html) - Structure specifying parameters of a newly created framebuffer
///# C Specifications
///The [`FramebufferCreateInfo`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkFramebufferCreateInfo {
///    VkStructureType             sType;
///    const void*                 pNext;
///    VkFramebufferCreateFlags    flags;
///    VkRenderPass                renderPass;
///    uint32_t                    attachmentCount;
///    const VkImageView*          pAttachments;
///    uint32_t                    width;
///    uint32_t                    height;
///    uint32_t                    layers;
///} VkFramebufferCreateInfo;
///```
///# Members
/// - [`s_type`] is the type of this structure.
/// - [`p_next`] is `NULL` or a pointer to a structure extending this structure.
/// - [`flags`] is a bitmask of [`FramebufferCreateFlagBits`]
/// - [`render_pass`] is a render pass defining what render passes the framebuffer will be compatible with. See [Render Pass Compatibility](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-compatibility) for details.
/// - [`attachment_count`] is the number of attachments.
/// - [`attachments`] is a pointer to an array of [`ImageView`] handles, each of which will be used
///   as the corresponding attachment in a render pass instance. If [`flags`] includes
///   `VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT`, this parameter is ignored.
/// - [`width`], [`height`] and [`layers`] define the dimensions of the framebuffer. If the render
///   pass uses multiview, then [`layers`] **must**  be one and each attachment requires a number of
///   layers that is greater than the maximum bit index set in the view mask in the subpasses in
///   which it is used.
///# Description
///Applications **must**  ensure that all non-attachment writes to memory backing
///image subresources that are used as attachments in a render pass instance
///happen-before or happen-after the render pass instance.
///If an image subresource is written during a render pass instance by anything
///other than load operations, store operations, and layout transitions,
///applications  **must**  ensure that all non-attachment reads from memory backing
///that image subresource happen-before or happen-after the render pass
///instance.
///For depth/stencil images, the aspects are not treated independently for the
///above guarantees - writes to either aspect  **must**  be synchronized with
///accesses to the other aspect.It is legal for a subpass to use no color or depth/stencil
/// attachments,
///either because it has no attachment references or because all of them are
///[`ATTACHMENT_UNUSED`].
///This kind of subpass  **can**  use shader side effects such as image stores and
///atomics to produce an output.
///In this case, the subpass continues to use the [`width`], [`height`],
///and [`layers`] of the framebuffer to define the dimensions of the
///rendering area, and the `rasterizationSamples` from each pipeline’s
///[`PipelineMultisampleStateCreateInfo`] to define the number of samples
///used in rasterization; however, if
///[`PhysicalDeviceFeatures::variable_multisample_rate`] is
///[`FALSE`], then all pipelines to be bound with the subpass  **must**  have
///the same value for
///[`PipelineMultisampleStateCreateInfo::rasterization_samples`].
///## Valid Usage
/// - If `renderpass` is not [`crate::utils::Handle::null`], [`attachment_count`] **must**  be equal
///   to the attachment count specified in [`render_pass`]
/// - If `renderpass` is not [`crate::utils::Handle::null`], [`flags`] does not include
///   `VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT`, and [`attachment_count`] is not `0`, [`attachments`]
///   **must**  be a valid pointer to an array of [`attachment_count`] valid [`ImageView`] handles
/// - If `renderpass` is not [`crate::utils::Handle::null`] and [`flags`] does not include
///   `VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT`, each element of [`attachments`] that is used as a color
///   attachment or resolve attachment by [`render_pass`] **must**  have been created with a `usage`
///   value including `VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT`
/// - If `renderpass` is not [`crate::utils::Handle::null`] and [`flags`] does not include
///   `VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT`, each element of [`attachments`] that is used as a
///   depth/stencil attachment by [`render_pass`] **must**  have been created with a `usage` value
///   including `VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT`
/// - If `renderpass` is not [`crate::utils::Handle::null`] and [`flags`] does not include
///   `VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT`, each element of [`attachments`] that is used as a
///   depth/stencil resolve attachment by [`render_pass`] **must**  have been created with a `usage`
///   value including `VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT`
/// - If `renderpass` is not [`crate::utils::Handle::null`] and `renderpass` is not
///   [`crate::utils::Handle::null`], [`flags`] does not include
///   `VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT`, each element of [`attachments`] that is used as an
///   input attachment by [`render_pass`] **must**  have been created with a `usage` value including
///   `VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT`
/// - If `renderpass` is not [`crate::utils::Handle::null`], each element of [`attachments`] that is
///   used as a fragment density map attachment by [`render_pass`] **must**  not have been created
///   with a [`flags`] value including `VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT`
/// -    If `renderpass` is not [`crate::utils::Handle::null`], [`render_pass`] has a fragment density map attachment, and [non-subsample image feature](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-fragmentDensityMapNonSubsampledImages) is not enabled, each element of [`attachments`] **must**  have been created with a [`flags`] value including `VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT` unless that element is the fragment density map attachment
/// - If [`render_pass`] was created with [fragment density map offsets](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-fragmentdensitymapoffsets)
///   other than (0,0), each element of [`attachments`] **must**  have been created with a [`flags`]
///   value including `VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_QCOM`.
/// - If `renderpass` is not [`crate::utils::Handle::null`] and [`flags`] does not include
///   `VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT`, each element of [`attachments`] **must**  have been
///   created with a [`Format`] value that matches the [`Format`] specified by the corresponding
///   [`AttachmentDescription`] in [`render_pass`]
/// - If `renderpass` is not [`crate::utils::Handle::null`] and [`flags`] does not include
///   `VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT`, each element of [`attachments`] **must**  have been
///   created with a `samples` value that matches the `samples` value specified by the corresponding
///   [`AttachmentDescription`] in [`render_pass`]
/// - If `renderpass` is not [`crate::utils::Handle::null`] and [`flags`] does not include
///   `VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT`, each element of [`attachments`] that is used as an
///   input, color, resolve, or depth/stencil attachment by [`render_pass`] **must**  have been
///   created with a [`ImageCreateInfo`]::[`width`] greater than or equal to [`width`]
/// - If `renderpass` is not [`crate::utils::Handle::null`] and [`flags`] does not include
///   `VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT`, each element of [`attachments`] that is used as an
///   input, color, resolve, or depth/stencil attachment by [`render_pass`] **must**  have been
///   created with a [`ImageCreateInfo`]::[`height`] greater than or equal to [`height`]
/// - If `renderpass` is not [`crate::utils::Handle::null`] and [`flags`] does not include
///   `VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT`, each element of [`attachments`] that is used as an
///   input, color, resolve, or depth/stencil attachment by [`render_pass`] **must**  have been
///   created with a [`ImageViewCreateInfo`]::`subresourceRange.layerCount` greater than or equal to
///   [`layers`]
/// - If `renderpass` is not [`crate::utils::Handle::null`] and [`render_pass`] was specified with
///   non-zero view masks, each element of [`attachments`] that is used as an input, color, resolve,
///   or depth/stencil attachment by [`render_pass`] **must**  have a `layerCount` greater than the
///   index of the most significant bit set in any of those view masks
/// - If `renderpass` is not [`crate::utils::Handle::null`] and [`render_pass`] was specified with
///   non-zero view masks, each element of [`attachments`] that is referenced by
///   `fragmentDensityMapAttachment` **must**  have a `layerCount` equal to `1` or greater than the
///   index of the most significant bit set in any of those view masks
/// - If `renderpass` is not [`crate::utils::Handle::null`] and [`render_pass`] was not specified
///   with non-zero view masks, each element of [`attachments`] that is referenced by
///   `fragmentDensityMapAttachment` **must**  have a `layerCount` equal to `1`
/// - If `renderpass` is not [`crate::utils::Handle::null`] and [`flags`] does not include
///   `VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT`, an element of [`attachments`] that is referenced by
///   `fragmentDensityMapAttachment` **must**  have a width at least as large as <span
///   class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span
///   class="strut" style="height:1.80002em;vertical-align:-0.65002em;"></span><span
///   class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing
///   size2">⌈</span></span><span class="mord"><span class="mord"><span class="mopen
///   nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span
///   class="vlist-r"><span style="height:0.8801079999999999em;" class="vlist"><span
///   style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span
///   class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord
///   mathdefault mtight">m</span><span class="mord mathdefault mtight">a</span><span class="mord
///   mathdefault mtight">x</span><span style="margin-right:0.13889em;" class="mord mathdefault
///   mtight">F</span><span style="margin-right:0.02778em;" class="mord mathdefault
///   mtight">r</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault
///   mtight" style="margin-right:0.03588em;">g</span><span class="mord mathdefault
///   mtight">m</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault
///   mtight">n</span><span class="mord mathdefault mtight">t</span><span class="mord mathdefault
///   mtight" style="margin-right:0.02778em;">D</span><span class="mord mathdefault
///   mtight">e</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault
///   mtight">s</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault
///   mtight">t</span><span style="margin-right:0.03588em;" class="mord mathdefault
///   mtight">y</span><span class="mord mathdefault mtight"
///   style="margin-right:0.13889em;">T</span><span class="mord mathdefault mtight">e</span><span
///   class="mord mathdefault mtight">x</span><span class="mord mathdefault mtight">e</span><span
///   class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord
///   mathdefault mtight" style="margin-right:0.05764em;">S</span><span class="mord mathdefault
///   mtight">i</span><span style="margin-right:0.04398em;" class="mord mathdefault
///   mtight">z</span><span class="mord mtight"><span class="mord mathdefault mtight">e</span><span
///   class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span
///   style="height:0.3448em;" class="vlist"><span
///   style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span
///   class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1
///   mtight"><span class="mord mtight"><span class="mord mathdefault mtight"
///   style="margin-right:0.02691em;">w</span><span class="mord mathdefault mtight">i</span><span
///   class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">t</span><span
///   class="mord mathdefault mtight">h</span></span></span></span></span><span
///   class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist"
///   style="height:0.15122857142857138em;"><span></span></span></span></span></span></span></
///   span></span></span><span style="top:-3.23em;"><span class="pstrut"
///   style="height:3em;"></span><span style="border-bottom-width:0.04em;"
///   class="frac-line"></span></span><span style="top:-3.394em;"><span style="height:3em;"
///   class="pstrut"></span><span class="sizing reset-size6 size3 mtight"><span class="mord
///   mtight"><span style="margin-right:0.02691em;" class="mord mathdefault mtight">w</span><span
///   class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">d</span><span
///   class="mord mathdefault mtight">t</span><span class="mord mathdefault
///   mtight">h</span></span></span></span></span><span class="vlist-s">​</span></span><span
///   class="vlist-r"><span class="vlist"
///   style="height:0.481108em;"><span></span></span></span></span></span><span class="mclose
///   nulldelimiter"></span></span></span><span class="mclose delimcenter" style="top:0em;"><span
///   class="delimsizing size2">⌉</span></span></span></span></span></span>
/// - If `renderpass` is not [`crate::utils::Handle::null`] and [`flags`] does not include
///   `VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT`, an element of [`attachments`] that is referenced by
///   `fragmentDensityMapAttachment` **must**  have a height at least as large as <span
///   class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span
///   style="height:1.80002em;vertical-align:-0.65002em;" class="strut"></span><span
///   class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing
///   size2">⌈</span></span><span class="mord"><span class="mord"><span class="mopen
///   nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span
///   class="vlist-r"><span class="vlist" style="height:0.9322159999999999em;"><span
///   style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span
///   class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord
///   mathdefault mtight">m</span><span class="mord mathdefault mtight">a</span><span class="mord
///   mathdefault mtight">x</span><span style="margin-right:0.13889em;" class="mord mathdefault
///   mtight">F</span><span class="mord mathdefault mtight"
///   style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">a</span><span
///   class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mord
///   mathdefault mtight">m</span><span class="mord mathdefault mtight">e</span><span class="mord
///   mathdefault mtight">n</span><span class="mord mathdefault mtight">t</span><span
///   style="margin-right:0.02778em;" class="mord mathdefault mtight">D</span><span class="mord
///   mathdefault mtight">e</span><span class="mord mathdefault mtight">n</span><span class="mord
///   mathdefault mtight">s</span><span class="mord mathdefault mtight">i</span><span class="mord
///   mathdefault mtight">t</span><span class="mord mathdefault mtight"
///   style="margin-right:0.03588em;">y</span><span style="margin-right:0.13889em;" class="mord
///   mathdefault mtight">T</span><span class="mord mathdefault mtight">e</span><span class="mord
///   mathdefault mtight">x</span><span class="mord mathdefault mtight">e</span><span class="mord
///   mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault
///   mtight" style="margin-right:0.05764em;">S</span><span class="mord mathdefault
///   mtight">i</span><span class="mord mathdefault mtight"
///   style="margin-right:0.04398em;">z</span><span class="mord mtight"><span class="mord
///   mathdefault mtight">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span
///   class="vlist-r"><span class="vlist" style="height:0.3448em;"><span
///   style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span
///   style="height:2.5em;" class="pstrut"></span><span class="sizing reset-size3 size1
///   mtight"><span class="mord mtight"><span class="mord mathdefault mtight">h</span><span
///   class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">i</span><span
///   class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mord
///   mathdefault mtight">h</span><span class="mord mathdefault
///   mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span
///   class="vlist-r"><span class="vlist"
///   style="height:0.29011428571428566em;"><span></span></span></span></span></span></span></
///   span></span></span><span style="top:-3.23em;"><span class="pstrut"
///   style="height:3em;"></span><span style="border-bottom-width:0.04em;"
///   class="frac-line"></span></span><span style="top:-3.446108em;"><span class="pstrut"
///   style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord
///   mtight"><span class="mord mathdefault mtight">h</span><span class="mord mathdefault
///   mtight">e</span><span class="mord mathdefault mtight">i</span><span
///   style="margin-right:0.03588em;" class="mord mathdefault mtight">g</span><span class="mord
///   mathdefault mtight">h</span><span class="mord mathdefault
///   mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span
///   class="vlist-r"><span class="vlist"
///   style="height:0.5480799999999999em;"><span></span></span></span></span></span><span
///   class="mclose nulldelimiter"></span></span></span><span style="top:0em;" class="mclose
///   delimcenter"><span class="delimsizing size2">⌉</span></span></span></span></span></span>
/// -    If `renderpass` is not [`crate::utils::Handle::null`] and [`flags`] does not include `VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT`, and [`render_pass`] was specified with non-zero view masks, each element of [`attachments`] that is used as a [fragment shading rate attachment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#primsrast-fragment-shading-rate-attachment) by [`render_pass`] **must**  have a `layerCount` that is either `1`, or greater than the index of the most significant bit set in any of those view masks
/// -    If `renderpass` is not [`crate::utils::Handle::null`] and [`flags`] does not include `VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT`, and [`render_pass`] was not specified with non-zero view masks, each element of [`attachments`] that is used as a [fragment shading rate attachment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#primsrast-fragment-shading-rate-attachment) by [`render_pass`] **must**  have a `layerCount` that is either `1`, or greater than [`layers`]
/// -    If `renderpass` is not [`crate::utils::Handle::null`] and [`flags`] does not include `VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT`, an element of [`attachments`] that is used as a [fragment shading rate attachment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#primsrast-fragment-shading-rate-attachment) **must**  have a width at least as large as ⌈[`width`] / `texelWidth`⌉, where `texelWidth` is the largest value of `shadingRateAttachmentTexelSize.width` in a [`FragmentShadingRateAttachmentInfoKHR`] which references that attachment
/// -    If `renderpass` is not [`crate::utils::Handle::null`] and [`flags`] does not include `VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT`, an element of [`attachments`] that is used as a [fragment shading rate attachment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#primsrast-fragment-shading-rate-attachment) **must**  have a height at least as large as ⌈[`height`] / `texelHeight`⌉, where `texelHeight` is the largest value of `shadingRateAttachmentTexelSize.height` in a [`FragmentShadingRateAttachmentInfoKHR`] which references that attachment
/// - If [`flags`] does not include `VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT`, each element of
///   [`attachments`] **must**  only specify a single mip level
/// - If [`flags`] does not include `VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT`, each element of
///   [`attachments`] **must**  have been created with the identity swizzle
/// - [`width`] **must**  be greater than `0`
/// - [`width`] **must**  be less than or equal to [`maxFramebufferWidth`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#limits-maxFramebufferWidth)
/// - [`height`] **must**  be greater than `0`
/// - [`height`] **must**  be less than or equal to [`maxFramebufferHeight`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#limits-maxFramebufferHeight)
/// - [`layers`] **must**  be greater than `0`
/// - [`layers`] **must**  be less than or equal to [`maxFramebufferLayers`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#limits-maxFramebufferLayers)
/// - If `renderpass` is not [`crate::utils::Handle::null`] and [`render_pass`] was specified with
///   non-zero view masks, [`layers`] **must**  be `1`
/// - If [`flags`] does not include `VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT`, each element of
///   [`attachments`] that is a 2D or 2D array image view taken from a 3D image  **must**  not be a
///   depth/stencil format
/// - If the [imageless framebuffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-imagelessFramebuffer)
///   feature is not enabled, [`flags`] **must**  not include `VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT`
/// - If [`flags`] includes `VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT`, the [`p_next`] chain  **must**
///   include a [`FramebufferAttachmentsCreateInfo`] structure
/// - If [`flags`] includes `VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT`, the `attachmentImageInfoCount`
///   member of a [`FramebufferAttachmentsCreateInfo`] structure in the [`p_next`] chain  **must**
///   be equal to either zero or [`attachment_count`]
/// - If `renderpass` is not [`crate::utils::Handle::null`] and [`flags`] includes
///   `VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT`, the [`width`] member of any element of the
///   `pAttachmentImageInfos` member of a [`FramebufferAttachmentsCreateInfo`] structure in the
///   [`p_next`] chain that is used as an input, color, resolve or depth/stencil attachment in
///   [`render_pass`] **must**  be greater than or equal to [`width`]
/// - If `renderpass` is not [`crate::utils::Handle::null`] and [`flags`] includes
///   `VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT`, the [`height`] member of any element of the
///   `pAttachmentImageInfos` member of a [`FramebufferAttachmentsCreateInfo`] structure in the
///   [`p_next`] chain that is used as an input, color, resolve or depth/stencil attachment in
///   [`render_pass`] **must**  be greater than or equal to [`height`]
/// - If `renderpass` is not [`crate::utils::Handle::null`] and [`flags`] includes
///   `VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT`, the [`width`] member of any element of the
///   `pAttachmentImageInfos` member of a [`FramebufferAttachmentsCreateInfo`] structure in the
///   [`p_next`] chain that is referenced by
///   [`RenderPassFragmentDensityMapCreateInfoEXT::fragment_density_map_attachment`] in
///   [`render_pass`] **must**  be greater than or equal to <span class="katex"><span
///   class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
///   style="height:1.80002em;vertical-align:-0.65002em;"></span><span class="minner"><span
///   style="top:0em;" class="mopen delimcenter"><span class="delimsizing
///   size2">⌈</span></span><span class="mord"><span class="mord"><span class="mopen
///   nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span
///   class="vlist-r"><span style="height:0.8801079999999999em;" class="vlist"><span
///   style="top:-2.6550000000000002em;"><span style="height:3em;" class="pstrut"></span><span
///   class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord
///   mathdefault mtight">m</span><span class="mord mathdefault mtight">a</span><span class="mord
///   mathdefault mtight">x</span><span class="mord mathdefault mtight"
///   style="margin-right:0.13889em;">F</span><span style="margin-right:0.02778em;" class="mord
///   mathdefault mtight">r</span><span class="mord mathdefault mtight">a</span><span class="mord
///   mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mord mathdefault
///   mtight">m</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault
///   mtight">n</span><span class="mord mathdefault mtight">t</span><span class="mord mathdefault
///   mtight" style="margin-right:0.02778em;">D</span><span class="mord mathdefault
///   mtight">e</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault
///   mtight">s</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault
///   mtight">t</span><span class="mord mathdefault mtight"
///   style="margin-right:0.03588em;">y</span><span class="mord mathdefault mtight"
///   style="margin-right:0.13889em;">T</span><span class="mord mathdefault mtight">e</span><span
///   class="mord mathdefault mtight">x</span><span class="mord mathdefault mtight">e</span><span
///   class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord
///   mathdefault mtight" style="margin-right:0.05764em;">S</span><span class="mord mathdefault
///   mtight">i</span><span class="mord mathdefault mtight"
///   style="margin-right:0.04398em;">z</span><span class="mord mtight"><span class="mord
///   mathdefault mtight">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span
///   class="vlist-r"><span class="vlist" style="height:0.3448em;"><span
///   style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span
///   class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1
///   mtight"><span class="mord mtight"><span style="margin-right:0.02691em;" class="mord
///   mathdefault mtight">w</span><span class="mord mathdefault mtight">i</span><span class="mord
///   mathdefault mtight">d</span><span class="mord mathdefault mtight">t</span><span class="mord
///   mathdefault mtight">h</span></span></span></span></span><span
///   class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist"
///   style="height:0.15122857142857138em;"><span></span></span></span></span></span></span></
///   span></span></span><span style="top:-3.23em;"><span class="pstrut"
///   style="height:3em;"></span><span class="frac-line"
///   style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span
///   style="height:3em;" class="pstrut"></span><span class="sizing reset-size6 size3 mtight"><span
///   class="mord mtight"><span class="mord mathdefault mtight"
///   style="margin-right:0.02691em;">w</span><span class="mord mathdefault mtight">i</span><span
///   class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">t</span><span
///   class="mord mathdefault mtight">h</span></span></span></span></span><span
///   class="vlist-s">​</span></span><span class="vlist-r"><span style="height:0.481108em;"
///   class="vlist"><span></span></span></span></span></span><span class="mclose
///   nulldelimiter"></span></span></span><span style="top:0em;" class="mclose delimcenter"><span
///   class="delimsizing size2">⌉</span></span></span></span></span></span>
/// - If `renderpass` is not [`crate::utils::Handle::null`] and [`flags`] includes
///   `VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT`, the [`height`] member of any element of the
///   `pAttachmentImageInfos` member of a [`FramebufferAttachmentsCreateInfo`] structure included in
///   the [`p_next`] chain that is referenced by
///   [`RenderPassFragmentDensityMapCreateInfoEXT::fragment_density_map_attachment`] in
///   [`render_pass`] **must**  be greater than or equal to <span class="katex"><span
///   class="katex-html" aria-hidden="true"><span class="base"><span
///   style="height:1.80002em;vertical-align:-0.65002em;" class="strut"></span><span
///   class="minner"><span style="top:0em;" class="mopen delimcenter"><span class="delimsizing
///   size2">⌈</span></span><span class="mord"><span class="mord"><span class="mopen
///   nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span
///   class="vlist-r"><span class="vlist" style="height:0.9322159999999999em;"><span
///   style="top:-2.6550000000000002em;"><span style="height:3em;" class="pstrut"></span><span
///   class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord
///   mathdefault mtight">m</span><span class="mord mathdefault mtight">a</span><span class="mord
///   mathdefault mtight">x</span><span class="mord mathdefault mtight"
///   style="margin-right:0.13889em;">F</span><span class="mord mathdefault mtight"
///   style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">a</span><span
///   class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mord
///   mathdefault mtight">m</span><span class="mord mathdefault mtight">e</span><span class="mord
///   mathdefault mtight">n</span><span class="mord mathdefault mtight">t</span><span class="mord
///   mathdefault mtight" style="margin-right:0.02778em;">D</span><span class="mord mathdefault
///   mtight">e</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault
///   mtight">s</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault
///   mtight">t</span><span style="margin-right:0.03588em;" class="mord mathdefault
///   mtight">y</span><span style="margin-right:0.13889em;" class="mord mathdefault
///   mtight">T</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault
///   mtight">x</span><span class="mord mathdefault mtight">e</span><span
///   style="margin-right:0.01968em;" class="mord mathdefault mtight">l</span><span
///   style="margin-right:0.05764em;" class="mord mathdefault mtight">S</span><span class="mord
///   mathdefault mtight">i</span><span style="margin-right:0.04398em;" class="mord mathdefault
///   mtight">z</span><span class="mord mtight"><span class="mord mathdefault mtight">e</span><span
///   class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span
///   style="height:0.3448em;" class="vlist"><span
///   style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span
///   class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1
///   mtight"><span class="mord mtight"><span class="mord mathdefault mtight">h</span><span
///   class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">i</span><span
///   class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mord
///   mathdefault mtight">h</span><span class="mord mathdefault
///   mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span
///   class="vlist-r"><span style="height:0.29011428571428566em;"
///   class="vlist"><span></span></span></span></span></span></span></span></span></span><span
///   style="top:-3.23em;"><span style="height:3em;" class="pstrut"></span><span
///   style="border-bottom-width:0.04em;" class="frac-line"></span></span><span
///   style="top:-3.446108em;"><span class="pstrut" style="height:3em;"></span><span class="sizing
///   reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault
///   mtight">h</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault
///   mtight">i</span><span style="margin-right:0.03588em;" class="mord mathdefault
///   mtight">g</span><span class="mord mathdefault mtight">h</span><span class="mord mathdefault
///   mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span
///   class="vlist-r"><span class="vlist"
///   style="height:0.5480799999999999em;"><span></span></span></span></span></span><span
///   class="mclose nulldelimiter"></span></span></span><span style="top:0em;" class="mclose
///   delimcenter"><span class="delimsizing size2">⌉</span></span></span></span></span></span>
/// -    If `renderpass` is not [`crate::utils::Handle::null`] and [`flags`] includes `VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT`, the [`width`] member of any element of the `pAttachmentImageInfos` member of a [`FramebufferAttachmentsCreateInfo`] structure in the [`p_next`] chain that is used as a [fragment shading rate attachment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#primsrast-fragment-shading-rate-attachment) **must**  be greater than or equal to ⌈[`width`] / `texelWidth`⌉, where `texelWidth` is the largest value of `shadingRateAttachmentTexelSize.width` in a [`FragmentShadingRateAttachmentInfoKHR`] which references that attachment
/// -    If `renderpass` is not [`crate::utils::Handle::null`] and [`flags`] includes `VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT`, the [`height`] member of any element of the `pAttachmentImageInfos` member of a [`FramebufferAttachmentsCreateInfo`] structure in the [`p_next`] chain that is used as a [fragment shading rate attachment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#primsrast-fragment-shading-rate-attachment) **must**  be greater than or equal to ⌈[`height`] / `texelHeight`⌉, where `texelHeight` is the largest value of `shadingRateAttachmentTexelSize.height` in a [`FragmentShadingRateAttachmentInfoKHR`] which references that attachment
/// -    If `renderpass` is not [`crate::utils::Handle::null`] and [`flags`] includes `VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT`, the `layerCount` member of any element of the `pAttachmentImageInfos` member of a [`FramebufferAttachmentsCreateInfo`] structure in the [`p_next`] chain that is used as a [fragment shading rate attachment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#primsrast-fragment-shading-rate-attachment) **must**  be either `1`, or greater than or equal to [`layers`]
/// -    If `renderpass` is not [`crate::utils::Handle::null`], [`flags`] includes `VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT`, and [`render_pass`] was specified with non-zero view masks, each element of [`attachments`] that is used as a [fragment shading rate attachment](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#primsrast-fragment-shading-rate-attachment) by [`render_pass`] **must**  have a `layerCount` that is either `1`, or greater than the index of the most significant bit set in any of those view masks
/// - If `renderpass` is not [`crate::utils::Handle::null`], multiview is enabled for
///   [`render_pass`], and [`flags`] includes `VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT`, the
///   `layerCount` member of any element of the `pAttachmentImageInfos` member of a
///   [`FramebufferAttachmentsCreateInfo`] structure included in the [`p_next`] chain used as an
///   input, color, resolve, or depth/stencil attachment in [`render_pass`] **must**  be greater
///   than the maximum bit index set in the view mask in the subpasses in which it is used in
///   [`render_pass`]
/// - If `renderpass` is not [`crate::utils::Handle::null`], multiview is not enabled for
///   [`render_pass`], and [`flags`] includes `VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT`, the
///   `layerCount` member of any element of the `pAttachmentImageInfos` member of a
///   [`FramebufferAttachmentsCreateInfo`] structure included in the [`p_next`] chain used as an
///   input, color, resolve, or depth/stencil attachment in [`render_pass`] **must**  be greater
///   than or equal to [`layers`]
/// - If `renderpass` is not [`crate::utils::Handle::null`] and [`flags`] includes
///   `VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT`, the `usage` member of any element of the
///   `pAttachmentImageInfos` member of a [`FramebufferAttachmentsCreateInfo`] structure included in
///   the [`p_next`] chain that refers to an attachment used as a color attachment or resolve
///   attachment by [`render_pass`] **must**  include `VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT`
/// - If `renderpass` is not [`crate::utils::Handle::null`] and [`flags`] includes
///   `VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT`, the `usage` member of any element of the
///   `pAttachmentImageInfos` member of a [`FramebufferAttachmentsCreateInfo`] structure included in
///   the [`p_next`] chain that refers to an attachment used as a depth/stencil attachment by
///   [`render_pass`] **must**  include `VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT`
/// - If `renderpass` is not [`crate::utils::Handle::null`] and [`flags`] includes
///   `VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT`, the `usage` member of any element of the
///   `pAttachmentImageInfos` member of a [`FramebufferAttachmentsCreateInfo`] structure included in
///   the [`p_next`] chain that refers to an attachment used as a depth/stencil resolve attachment
///   by [`render_pass`] **must**  include `VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT`
/// - If `renderpass` is not [`crate::utils::Handle::null`] and [`flags`] includes
///   `VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT`, the `usage` member of any element of the
///   `pAttachmentImageInfos` member of a [`FramebufferAttachmentsCreateInfo`] structure included in
///   the [`p_next`] chain that refers to an attachment used as an input attachment by
///   [`render_pass`] **must**  include `VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT`
/// - If `renderpass` is not [`crate::utils::Handle::null`] and [`flags`] includes
///   `VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT`, at least one element of the `pViewFormats` member of
///   any element of the `pAttachmentImageInfos` member of a [`FramebufferAttachmentsCreateInfo`]
///   structure included in the [`p_next`] chain  **must**  be equal to the corresponding value of
///   [`AttachmentDescription::format`] used to create [`render_pass`]
/// - If [`flags`] does not include `VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT`, each element of
///   [`attachments`] **must**  have been created with [`ImageViewCreateInfo::view_type`] not equal
///   to `VK_IMAGE_VIEW_TYPE_3D`
/// - If `renderpass` is not [`crate::utils::Handle::null`] and [`flags`] does not include
///   `VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT`, each element of [`attachments`] that is used as a
///   fragment shading rate attachment by [`render_pass`] **must**  have been created with a `usage`
///   value including `VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR`
/// - If `renderpass` is not [`crate::utils::Handle::null`] and [`flags`] includes
///   `VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT`, the `usage` member of any element of the
///   `pAttachmentImageInfos` member of a [`FramebufferAttachmentsCreateInfo`] structure included in
///   the [`p_next`] chain that refers to an attachment used as a fragment shading rate attachment
///   by [`render_pass`] **must**  include `VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR`
///
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be `VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO`
/// - [`p_next`] **must**  be `NULL` or a pointer to a valid instance of
///   [`FramebufferAttachmentsCreateInfo`]
/// - The [`s_type`] value of each struct in the [`p_next`] chain  **must**  be unique
/// - [`flags`] **must**  be a valid combination of [`FramebufferCreateFlagBits`] values
/// - [`render_pass`] **must**  be a valid [`RenderPass`] handle
/// - Both of [`render_pass`], and the elements of [`attachments`] that are valid handles of
///   non-ignored parameters  **must**  have been created, allocated, or retrieved from the same
///   [`Device`]
///# Related
/// - [`crate::vulkan1_0`]
/// - [`FramebufferCreateFlags`]
/// - [`ImageView`]
/// - [`RenderPass`]
/// - [`StructureType`]
/// - [`CreateFramebuffer`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[repr(C)]
pub struct FramebufferCreateInfo<'lt> {
    _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] is the type of this structure.
    s_type: StructureType,
    ///[`p_next`] is `NULL` or a pointer to a structure extending this
    ///structure.
    p_next: *const BaseInStructure<'lt>,
    ///[`flags`] is a bitmask of [`FramebufferCreateFlagBits`]
    flags: FramebufferCreateFlags,
    ///[`render_pass`] is a render pass defining what render passes the
    ///framebuffer will be compatible with.
    ///See [Render Pass Compatibility](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-compatibility) for details.
    render_pass: RenderPass,
    ///[`attachment_count`] is the number of attachments.
    attachment_count: u32,
    ///[`attachments`] is a pointer to an array of [`ImageView`]
    ///handles, each of which will be used as the corresponding attachment in a
    ///render pass instance.
    ///If [`flags`] includes `VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT`, this
    ///parameter is ignored.
    attachments: *const ImageView,
    ///[`width`], [`height`] and [`layers`] define the dimensions of the
    ///framebuffer.
    ///If the render pass uses multiview, then [`layers`] **must**  be one and
    ///each attachment requires a number of layers that is greater than the
    ///maximum bit index set in the view mask in the subpasses in which it is
    ///used.
    width: u32,
    ///No documentation found
    height: u32,
    ///No documentation found
    layers: u32,
}
impl<'lt> Default for FramebufferCreateInfo<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: Default::default(),
            p_next: std::ptr::null(),
            flags: Default::default(),
            render_pass: Default::default(),
            attachment_count: 0,
            attachments: std::ptr::null(),
            width: 0,
            height: 0,
            layers: 0,
        }
    }
}
impl<'lt> FramebufferCreateInfo<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *const BaseInStructure<'lt> {
        self.p_next
    }
    ///Gets the raw value of [`Self::attachments`]
    pub fn attachments_raw(&self) -> *const ImageView {
        self.attachments
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *const BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::attachments`]
    pub fn set_attachments_raw(&mut self, value: *const ImageView) -> &mut Self {
        self.attachments = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseInStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::flags`]
    pub fn flags(&self) -> FramebufferCreateFlags {
        self.flags
    }
    ///Gets the value of [`Self::render_pass`]
    pub fn render_pass(&self) -> RenderPass {
        self.render_pass
    }
    ///Gets the value of [`Self::attachment_count`]
    pub fn attachment_count(&self) -> u32 {
        self.attachment_count
    }
    ///Gets the value of [`Self::attachments`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn attachments(&self) -> &[ImageView] {
        std::slice::from_raw_parts(self.attachments, self.attachment_count as usize)
    }
    ///Gets the value of [`Self::width`]
    pub fn width(&self) -> u32 {
        self.width
    }
    ///Gets the value of [`Self::height`]
    pub fn height(&self) -> u32 {
        self.height
    }
    ///Gets the value of [`Self::layers`]
    pub fn layers(&self) -> u32 {
        self.layers
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::flags`]
    pub fn flags_mut(&mut self) -> &mut FramebufferCreateFlags {
        &mut self.flags
    }
    ///Gets a mutable reference to the value of [`Self::render_pass`]
    pub fn render_pass_mut(&mut self) -> &mut RenderPass {
        &mut self.render_pass
    }
    ///Gets a mutable reference to the value of [`Self::attachment_count`]
    pub fn attachment_count_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::width`]
    pub fn width_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::height`]
    pub fn height_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::layers`]
    pub fn layers_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Sets the raw value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the raw value of [`Self::flags`]
    pub fn set_flags(&mut self, value: crate::vulkan1_0::FramebufferCreateFlags) -> &mut Self {
        self.flags = value;
        self
    }
    ///Sets the raw value of [`Self::render_pass`]
    pub fn set_render_pass(&mut self, value: crate::vulkan1_0::RenderPass) -> &mut Self {
        self.render_pass = value;
        self
    }
    ///Sets the raw value of [`Self::attachment_count`]
    pub fn set_attachment_count(&mut self, value: u32) -> &mut Self {
        self.attachment_count = value;
        self
    }
    ///Sets the raw value of [`Self::attachments`]
    pub fn set_attachments(&mut self, value: &'lt [crate::vulkan1_0::ImageView]) -> &mut Self {
        let len_ = value.len() as u32;
        let len_ = len_;
        self.attachments = value.as_ptr();
        self.attachment_count = len_;
        self
    }
    ///Sets the raw value of [`Self::width`]
    pub fn set_width(&mut self, value: u32) -> &mut Self {
        self.width = value;
        self
    }
    ///Sets the raw value of [`Self::height`]
    pub fn set_height(&mut self, value: u32) -> &mut Self {
        self.height = value;
        self
    }
    ///Sets the raw value of [`Self::layers`]
    pub fn set_layers(&mut self, value: u32) -> &mut Self {
        self.layers = value;
        self
    }
}
///[VkDrawIndirectCommand](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDrawIndirectCommand.html) - Structure specifying a indirect drawing command
///# C Specifications
///The [`DrawIndirectCommand`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkDrawIndirectCommand {
///    uint32_t    vertexCount;
///    uint32_t    instanceCount;
///    uint32_t    firstVertex;
///    uint32_t    firstInstance;
///} VkDrawIndirectCommand;
///```
///# Members
/// - [`vertex_count`] is the number of vertices to draw.
/// - [`instance_count`] is the number of instances to draw.
/// - [`first_vertex`] is the index of the first vertex to draw.
/// - [`first_instance`] is the instance ID of the first instance to draw.
///# Description
///The members of [`DrawIndirectCommand`] have the same meaning as the
///similarly named parameters of [`CmdDraw`].
///## Valid Usage
/// - For a given vertex buffer binding, any attribute data fetched  **must**  be entirely contained
///   within the corresponding vertex buffer binding, as described in [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fxvertex-input](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fxvertex-input)
/// - If the [drawIndirectFirstInstance](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-drawIndirectFirstInstance)
///   feature is not enabled, [`first_instance`] **must**  be `0`
///# Related
/// - [`crate::vulkan1_0`]
/// - [`CmdDrawIndirect`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct DrawIndirectCommand {
    ///[`vertex_count`] is the number of vertices to draw.
    vertex_count: u32,
    ///[`instance_count`] is the number of instances to draw.
    instance_count: u32,
    ///[`first_vertex`] is the index of the first vertex to draw.
    first_vertex: u32,
    ///[`first_instance`] is the instance ID of the first instance to draw.
    first_instance: u32,
}
impl Default for DrawIndirectCommand {
    fn default() -> Self {
        Self {
            vertex_count: 0,
            instance_count: 0,
            first_vertex: 0,
            first_instance: 0,
        }
    }
}
impl DrawIndirectCommand {
    ///Gets the value of [`Self::vertex_count`]
    pub fn vertex_count(&self) -> u32 {
        self.vertex_count
    }
    ///Gets the value of [`Self::instance_count`]
    pub fn instance_count(&self) -> u32 {
        self.instance_count
    }
    ///Gets the value of [`Self::first_vertex`]
    pub fn first_vertex(&self) -> u32 {
        self.first_vertex
    }
    ///Gets the value of [`Self::first_instance`]
    pub fn first_instance(&self) -> u32 {
        self.first_instance
    }
    ///Gets a mutable reference to the value of [`Self::vertex_count`]
    pub fn vertex_count_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::instance_count`]
    pub fn instance_count_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::first_vertex`]
    pub fn first_vertex_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::first_instance`]
    pub fn first_instance_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Sets the raw value of [`Self::vertex_count`]
    pub fn set_vertex_count(&mut self, value: u32) -> &mut Self {
        self.vertex_count = value;
        self
    }
    ///Sets the raw value of [`Self::instance_count`]
    pub fn set_instance_count(&mut self, value: u32) -> &mut Self {
        self.instance_count = value;
        self
    }
    ///Sets the raw value of [`Self::first_vertex`]
    pub fn set_first_vertex(&mut self, value: u32) -> &mut Self {
        self.first_vertex = value;
        self
    }
    ///Sets the raw value of [`Self::first_instance`]
    pub fn set_first_instance(&mut self, value: u32) -> &mut Self {
        self.first_instance = value;
        self
    }
}
///[VkDrawIndexedIndirectCommand](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDrawIndexedIndirectCommand.html) - Structure specifying a indexed indirect drawing command
///# C Specifications
///The [`DrawIndexedIndirectCommand`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkDrawIndexedIndirectCommand {
///    uint32_t    indexCount;
///    uint32_t    instanceCount;
///    uint32_t    firstIndex;
///    int32_t     vertexOffset;
///    uint32_t    firstInstance;
///} VkDrawIndexedIndirectCommand;
///```
///# Members
/// - [`index_count`] is the number of vertices to draw.
/// - [`instance_count`] is the number of instances to draw.
/// - [`first_index`] is the base index within the index buffer.
/// - [`vertex_offset`] is the value added to the vertex index before indexing into the vertex
///   buffer.
/// - [`first_instance`] is the instance ID of the first instance to draw.
///# Description
///The members of [`DrawIndexedIndirectCommand`] have the same meaning as
///the similarly named parameters of [`CmdDrawIndexed`].
///## Valid Usage
/// - For a given vertex buffer binding, any attribute data fetched  **must**  be entirely contained
///   within the corresponding vertex buffer binding, as described in [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fxvertex-input](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#fxvertex-input)
/// - (`indexSize` × ([`first_index`] +  [`index_count`]) +  `offset`) **must**  be less than or
///   equal to the size of the bound index buffer, with `indexSize` being based on the type
///   specified by `indexType`, where the index buffer, `indexType`, and `offset` are specified via
///   [`CmdBindIndexBuffer`]
/// - If the [drawIndirectFirstInstance](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#features-drawIndirectFirstInstance)
///   feature is not enabled, [`first_instance`] **must**  be `0`
///# Related
/// - [`crate::vulkan1_0`]
/// - [`CmdDrawIndexedIndirect`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct DrawIndexedIndirectCommand {
    ///[`index_count`] is the number of vertices to draw.
    index_count: u32,
    ///[`instance_count`] is the number of instances to draw.
    instance_count: u32,
    ///[`first_index`] is the base index within the index buffer.
    first_index: u32,
    ///[`vertex_offset`] is the value added to the vertex index before
    ///indexing into the vertex buffer.
    vertex_offset: i32,
    ///[`first_instance`] is the instance ID of the first instance to draw.
    first_instance: u32,
}
impl Default for DrawIndexedIndirectCommand {
    fn default() -> Self {
        Self {
            index_count: 0,
            instance_count: 0,
            first_index: 0,
            vertex_offset: 0,
            first_instance: 0,
        }
    }
}
impl DrawIndexedIndirectCommand {
    ///Gets the value of [`Self::index_count`]
    pub fn index_count(&self) -> u32 {
        self.index_count
    }
    ///Gets the value of [`Self::instance_count`]
    pub fn instance_count(&self) -> u32 {
        self.instance_count
    }
    ///Gets the value of [`Self::first_index`]
    pub fn first_index(&self) -> u32 {
        self.first_index
    }
    ///Gets the value of [`Self::vertex_offset`]
    pub fn vertex_offset(&self) -> i32 {
        self.vertex_offset
    }
    ///Gets the value of [`Self::first_instance`]
    pub fn first_instance(&self) -> u32 {
        self.first_instance
    }
    ///Gets a mutable reference to the value of [`Self::index_count`]
    pub fn index_count_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::instance_count`]
    pub fn instance_count_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::first_index`]
    pub fn first_index_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::vertex_offset`]
    pub fn vertex_offset_mut(&mut self) -> &mut i32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::first_instance`]
    pub fn first_instance_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Sets the raw value of [`Self::index_count`]
    pub fn set_index_count(&mut self, value: u32) -> &mut Self {
        self.index_count = value;
        self
    }
    ///Sets the raw value of [`Self::instance_count`]
    pub fn set_instance_count(&mut self, value: u32) -> &mut Self {
        self.instance_count = value;
        self
    }
    ///Sets the raw value of [`Self::first_index`]
    pub fn set_first_index(&mut self, value: u32) -> &mut Self {
        self.first_index = value;
        self
    }
    ///Sets the raw value of [`Self::vertex_offset`]
    pub fn set_vertex_offset(&mut self, value: i32) -> &mut Self {
        self.vertex_offset = value;
        self
    }
    ///Sets the raw value of [`Self::first_instance`]
    pub fn set_first_instance(&mut self, value: u32) -> &mut Self {
        self.first_instance = value;
        self
    }
}
///[VkDispatchIndirectCommand](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDispatchIndirectCommand.html) - Structure specifying a indirect dispatching command
///# C Specifications
///The [`DispatchIndirectCommand`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkDispatchIndirectCommand {
///    uint32_t    x;
///    uint32_t    y;
///    uint32_t    z;
///} VkDispatchIndirectCommand;
///```
///# Members
/// - [`x`] is the number of local workgroups to dispatch in the X dimension.
/// - [`y`] is the number of local workgroups to dispatch in the Y dimension.
/// - [`z`] is the number of local workgroups to dispatch in the Z dimension.
///# Description
///The members of [`DispatchIndirectCommand`] have the same meaning as the
///corresponding parameters of [`CmdDispatch`].
///## Valid Usage
/// - [`x`] **must**  be less than or equal to
///   [`PhysicalDeviceLimits::max_compute_work_group_count`][0]
/// - [`y`] **must**  be less than or equal to
///   [`PhysicalDeviceLimits::max_compute_work_group_count`][1]
/// - [`z`] **must**  be less than or equal to
///   [`PhysicalDeviceLimits::max_compute_work_group_count`][2]
///# Related
/// - [`crate::vulkan1_0`]
/// - [`CmdDispatchIndirect`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct DispatchIndirectCommand {
    ///[`x`] is the number of local workgroups to dispatch in the X
    ///dimension.
    x: u32,
    ///[`y`] is the number of local workgroups to dispatch in the Y
    ///dimension.
    y: u32,
    ///[`z`] is the number of local workgroups to dispatch in the Z
    ///dimension.
    z: u32,
}
impl Default for DispatchIndirectCommand {
    fn default() -> Self {
        Self { x: 0, y: 0, z: 0 }
    }
}
impl DispatchIndirectCommand {
    ///Gets the value of [`Self::x`]
    pub fn x(&self) -> u32 {
        self.x
    }
    ///Gets the value of [`Self::y`]
    pub fn y(&self) -> u32 {
        self.y
    }
    ///Gets the value of [`Self::z`]
    pub fn z(&self) -> u32 {
        self.z
    }
    ///Gets a mutable reference to the value of [`Self::x`]
    pub fn x_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::y`]
    pub fn y_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::z`]
    pub fn z_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Sets the raw value of [`Self::x`]
    pub fn set_x(&mut self, value: u32) -> &mut Self {
        self.x = value;
        self
    }
    ///Sets the raw value of [`Self::y`]
    pub fn set_y(&mut self, value: u32) -> &mut Self {
        self.y = value;
        self
    }
    ///Sets the raw value of [`Self::z`]
    pub fn set_z(&mut self, value: u32) -> &mut Self {
        self.z = value;
        self
    }
}
///[VkSubmitInfo](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSubmitInfo.html) - Structure specifying a queue submit operation
///# C Specifications
///The [`SubmitInfo`] structure is defined as:
///```c
///// Provided by VK_VERSION_1_0
///typedef struct VkSubmitInfo {
///    VkStructureType                sType;
///    const void*                    pNext;
///    uint32_t                       waitSemaphoreCount;
///    const VkSemaphore*             pWaitSemaphores;
///    const VkPipelineStageFlags*    pWaitDstStageMask;
///    uint32_t                       commandBufferCount;
///    const VkCommandBuffer*         pCommandBuffers;
///    uint32_t                       signalSemaphoreCount;
///    const VkSemaphore*             pSignalSemaphores;
///} VkSubmitInfo;
///```
///# Members
/// - [`s_type`] is the type of this structure.
/// - [`p_next`] is `NULL` or a pointer to a structure extending this structure.
/// - [`wait_semaphore_count`] is the number of semaphores upon which to wait before executing the
///   command buffers for the batch.
/// - [`wait_semaphores`] is a pointer to an array of [`Semaphore`] handles upon which to wait before the command buffers for this batch begin execution. If semaphores to wait on are provided, they define a [semaphore wait operation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-semaphores-waiting).
/// - [`wait_dst_stage_mask`] is a pointer to an array of pipeline stages at which each
///   corresponding semaphore wait will occur.
/// - [`command_buffer_count`] is the number of command buffers to execute in the batch.
/// - [`command_buffers`] is a pointer to an array of [`CommandBuffer`] handles to execute in the
///   batch.
/// - [`signal_semaphore_count`] is the number of semaphores to be signaled once the commands
///   specified in [`command_buffers`] have completed execution.
/// - [`signal_semaphores`] is a pointer to an array of [`Semaphore`] handles which will be signaled
///   when the command buffers for this batch have completed execution. If semaphores to be signaled
///   are provided, they define a [semaphore signal operation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-semaphores-signaling).
///# Description
///The order that command buffers appear in [`command_buffers`] is used to
///determine [submission order](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-submission-order), and thus
///all the [implicit ordering guarantees](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-implicit) that
///respect it.
///Other than these implicit ordering guarantees and any [explicit synchronization primitives](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization), these command buffers  **may**  overlap or
///otherwise execute out of order.
///## Valid Usage
/// - If the [geometry shaders](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-geometryShader)
///   feature is not enabled, [`wait_dst_stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT`
/// - If the [tessellation shaders](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-tessellationShader)
///   feature is not enabled, [`wait_dst_stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT` or
///   `VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT`
/// - If the [conditional rendering](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-conditionalRendering)
///   feature is not enabled, [`wait_dst_stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT`
/// - If the [fragment density map](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-fragmentDensityMap)
///   feature is not enabled, [`wait_dst_stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT`
/// - If the [transform feedback](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-transformFeedback)
///   feature is not enabled, [`wait_dst_stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT`
/// - If the [mesh shaders](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-meshShader)
///   feature is not enabled, [`wait_dst_stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV`
/// - If the [task shaders](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-taskShader)
///   feature is not enabled, [`wait_dst_stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV`
/// - If the [shading rate image](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-shadingRateImage)
///   feature is not enabled, [`wait_dst_stage_mask`] **must**  not contain
///   `VK_PIPELINE_STAGE_SHADING_RATE_IMAGE_BIT_NV`
/// - If the [`synchronization2`](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#features-synchronization2)
///   feature is not enabled, [`wait_dst_stage_mask`] **must**  not be `0`
/// - Each element of [`command_buffers`] **must**  not have been allocated with
///   `VK_COMMAND_BUFFER_LEVEL_SECONDARY`
/// - Each element of [`wait_dst_stage_mask`] **must**  not include `VK_PIPELINE_STAGE_HOST_BIT`
/// - If any element of [`wait_semaphores`] or [`signal_semaphores`] was created with a
///   [`SemaphoreType`] of `VK_SEMAPHORE_TYPE_TIMELINE`, then the [`p_next`] chain  **must**
///   include a [`TimelineSemaphoreSubmitInfo`] structure
/// - If the [`p_next`] chain of this structure includes a [`TimelineSemaphoreSubmitInfo`] structure
///   and any element of [`wait_semaphores`] was created with a [`SemaphoreType`] of
///   `VK_SEMAPHORE_TYPE_TIMELINE`, then its `waitSemaphoreValueCount` member  **must**  equal
///   [`wait_semaphore_count`]
/// - If the [`p_next`] chain of this structure includes a [`TimelineSemaphoreSubmitInfo`] structure
///   and any element of [`signal_semaphores`] was created with a [`SemaphoreType`] of
///   `VK_SEMAPHORE_TYPE_TIMELINE`, then its `signalSemaphoreValueCount` member  **must**  equal
///   [`signal_semaphore_count`]
/// -    For each element of [`signal_semaphores`] created with a [`SemaphoreType`] of `VK_SEMAPHORE_TYPE_TIMELINE` the corresponding element of [`TimelineSemaphoreSubmitInfo::signal_semaphore_values`] **must**  have a value greater than the current value of the semaphore when the [semaphore signal operation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-semaphores-signaling) is executed
/// -    For each element of [`wait_semaphores`] created with a [`SemaphoreType`] of `VK_SEMAPHORE_TYPE_TIMELINE` the corresponding element of [`TimelineSemaphoreSubmitInfo::wait_semaphore_values`] **must**  have a value which does not differ from the current value of the semaphore or the value of any outstanding semaphore wait or signal operation on that semaphore by more than [`maxTimelineSemaphoreValueDifference`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#limits-maxTimelineSemaphoreValueDifference)
/// -    For each element of [`signal_semaphores`] created with a [`SemaphoreType`] of `VK_SEMAPHORE_TYPE_TIMELINE` the corresponding element of [`TimelineSemaphoreSubmitInfo::signal_semaphore_values`] **must**  have a value which does not differ from the current value of the semaphore or the value of any outstanding semaphore wait or signal operation on that semaphore by more than [`maxTimelineSemaphoreValueDifference`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#limits-maxTimelineSemaphoreValueDifference)
/// - If the [`p_next`] chain of this structure does not include a [`ProtectedSubmitInfo`] structure
///   with `protectedSubmit` set to [`TRUE`], then each element of the [`command_buffers`] array
///   **must**  be an unprotected command buffer
/// - If the [`p_next`] chain of this structure includes a [`ProtectedSubmitInfo`] structure with
///   `protectedSubmit` set to [`TRUE`], then each element of the [`command_buffers`] array
///   **must**  be a protected command buffer
/// - If [`command_buffers`] contains any [resumed render pass instances](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-suspension),
///   they  **must**  be suspended by a render pass instance earlier in submission order within
///   [`command_buffers`]
/// - If [`command_buffers`] contains any [suspended render pass instances](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-suspension),
///   they  **must**  be resumed by a render pass instance later in submission order within
///   [`command_buffers`]
/// - If [`command_buffers`] contains any [suspended render pass instances](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-suspension),
///   there  **must**  be no action or synchronization commands between that render pass instance
///   and the render pass instance that resumes it
/// - If [`command_buffers`] contains any [suspended render pass instances](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-suspension),
///   there  **must**  be no render pass instances between that render pass instance and the render
///   pass instance that resumes it
/// -    If the [`variableSampleLocations`](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#limits-variableSampleLocations) limit is not supported, and any element of [`command_buffers`] contains any [suspended render pass instances](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#renderpass-suspension), where a graphics pipeline has been bound, any pipelines bound in the render pass instance that resumes it, or any subsequent render pass instances that resume from that one and so on,  **must**  use the same sample locations
///
///## Valid Usage (Implicit)
/// - [`s_type`] **must**  be `VK_STRUCTURE_TYPE_SUBMIT_INFO`
/// - Each [`p_next`] member of any structure (including this one) in the [`p_next`] chain  **must**
///   be either `NULL` or a pointer to a valid instance of [`D3D12FenceSubmitInfoKHR`],
///   [`DeviceGroupSubmitInfo`], [`PerformanceQuerySubmitInfoKHR`], [`ProtectedSubmitInfo`],
///   [`TimelineSemaphoreSubmitInfo`], [`Win32KeyedMutexAcquireReleaseInfoKHR`], or
///   [`Win32KeyedMutexAcquireReleaseInfoNV`]
/// - The [`s_type`] value of each struct in the [`p_next`] chain  **must**  be unique
/// - If [`wait_semaphore_count`] is not `0`, [`wait_semaphores`] **must**  be a valid pointer to an
///   array of [`wait_semaphore_count`] valid [`Semaphore`] handles
/// - If [`wait_semaphore_count`] is not `0`, [`wait_dst_stage_mask`] **must**  be a valid pointer
///   to an array of [`wait_semaphore_count`] valid combinations of [`PipelineStageFlagBits`] values
/// - Each element of [`wait_dst_stage_mask`] **must**  not be `0`
/// - If [`command_buffer_count`] is not `0`, [`command_buffers`] **must**  be a valid pointer to an
///   array of [`command_buffer_count`] valid [`CommandBuffer`] handles
/// - If [`signal_semaphore_count`] is not `0`, [`signal_semaphores`] **must**  be a valid pointer
///   to an array of [`signal_semaphore_count`] valid [`Semaphore`] handles
/// - Each of the elements of [`command_buffers`], the elements of [`signal_semaphores`], and the
///   elements of [`wait_semaphores`] that are valid handles of non-ignored parameters  **must**
///   have been created, allocated, or retrieved from the same [`Device`]
///# Related
/// - [`crate::vulkan1_0`]
/// - [`CommandBuffer`]
/// - [`PipelineStageFlags`]
/// - [`Semaphore`]
/// - [`StructureType`]
/// - [`QueueSubmit`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[repr(C)]
pub struct SubmitInfo<'lt> {
    _lifetime: PhantomData<&'lt ()>,
    ///[`s_type`] is the type of this structure.
    s_type: StructureType,
    ///[`p_next`] is `NULL` or a pointer to a structure extending this
    ///structure.
    p_next: *const BaseInStructure<'lt>,
    ///[`wait_semaphore_count`] is the number of semaphores upon which to wait
    ///before executing the command buffers for the batch.
    wait_semaphore_count: u32,
    ///[`wait_semaphores`] is a pointer to an array of [`Semaphore`]
    ///handles upon which to wait before the command buffers for this batch
    ///begin execution.
    ///If semaphores to wait on are provided, they define a
    ///[semaphore wait operation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-semaphores-waiting).
    wait_semaphores: *const Semaphore,
    ///[`wait_dst_stage_mask`] is a pointer to an array of pipeline stages at
    ///which each corresponding semaphore wait will occur.
    wait_dst_stage_mask: *const PipelineStageFlags,
    ///[`command_buffer_count`] is the number of command buffers to execute in
    ///the batch.
    command_buffer_count: u32,
    ///[`command_buffers`] is a pointer to an array of [`CommandBuffer`]
    ///handles to execute in the batch.
    command_buffers: *const CommandBuffer,
    ///[`signal_semaphore_count`] is the number of semaphores to be signaled
    ///once the commands specified in [`command_buffers`] have completed
    ///execution.
    signal_semaphore_count: u32,
    ///[`signal_semaphores`] is a pointer to an array of [`Semaphore`]
    ///handles which will be signaled when the command buffers for this batch
    ///have completed execution.
    ///If semaphores to be signaled are provided, they define a
    ///[semaphore signal operation](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-semaphores-signaling).
    signal_semaphores: *const Semaphore,
}
impl<'lt> Default for SubmitInfo<'lt> {
    fn default() -> Self {
        Self {
            _lifetime: PhantomData,
            s_type: Default::default(),
            p_next: std::ptr::null(),
            wait_semaphore_count: 0,
            wait_semaphores: std::ptr::null(),
            wait_dst_stage_mask: std::ptr::null(),
            command_buffer_count: 0,
            command_buffers: std::ptr::null(),
            signal_semaphore_count: 0,
            signal_semaphores: std::ptr::null(),
        }
    }
}
impl<'lt> SubmitInfo<'lt> {
    ///Gets the raw value of [`Self::p_next`]
    pub fn p_next_raw(&self) -> *const BaseInStructure<'lt> {
        self.p_next
    }
    ///Gets the raw value of [`Self::wait_semaphores`]
    pub fn wait_semaphores_raw(&self) -> *const Semaphore {
        self.wait_semaphores
    }
    ///Gets the raw value of [`Self::wait_dst_stage_mask`]
    pub fn wait_dst_stage_mask_raw(&self) -> *const PipelineStageFlags {
        self.wait_dst_stage_mask
    }
    ///Gets the raw value of [`Self::command_buffers`]
    pub fn command_buffers_raw(&self) -> *const CommandBuffer {
        self.command_buffers
    }
    ///Gets the raw value of [`Self::signal_semaphores`]
    pub fn signal_semaphores_raw(&self) -> *const Semaphore {
        self.signal_semaphores
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next_raw(&mut self, value: *const BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value;
        self
    }
    ///Sets the raw value of [`Self::wait_semaphores`]
    pub fn set_wait_semaphores_raw(&mut self, value: *const Semaphore) -> &mut Self {
        self.wait_semaphores = value;
        self
    }
    ///Sets the raw value of [`Self::wait_dst_stage_mask`]
    pub fn set_wait_dst_stage_mask_raw(&mut self, value: *const PipelineStageFlags) -> &mut Self {
        self.wait_dst_stage_mask = value;
        self
    }
    ///Sets the raw value of [`Self::command_buffers`]
    pub fn set_command_buffers_raw(&mut self, value: *const CommandBuffer) -> &mut Self {
        self.command_buffers = value;
        self
    }
    ///Sets the raw value of [`Self::signal_semaphores`]
    pub fn set_signal_semaphores_raw(&mut self, value: *const Semaphore) -> &mut Self {
        self.signal_semaphores = value;
        self
    }
    ///Gets the value of [`Self::s_type`]
    pub fn s_type(&self) -> StructureType {
        self.s_type
    }
    ///Gets the value of [`Self::p_next`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn p_next(&self) -> &BaseInStructure<'lt> {
        &*self.p_next
    }
    ///Gets the value of [`Self::wait_semaphore_count`]
    pub fn wait_semaphore_count(&self) -> u32 {
        self.wait_semaphore_count
    }
    ///Gets the value of [`Self::wait_semaphores`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn wait_semaphores(&self) -> &[Semaphore] {
        std::slice::from_raw_parts(self.wait_semaphores, self.wait_semaphore_count as usize)
    }
    ///Gets the value of [`Self::wait_dst_stage_mask`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn wait_dst_stage_mask(&self) -> &[PipelineStageFlags] {
        std::slice::from_raw_parts(self.wait_dst_stage_mask, self.wait_semaphore_count as usize)
    }
    ///Gets the value of [`Self::command_buffer_count`]
    pub fn command_buffer_count(&self) -> u32 {
        self.command_buffer_count
    }
    ///Gets the value of [`Self::command_buffers`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn command_buffers(&self) -> &[CommandBuffer] {
        std::slice::from_raw_parts(self.command_buffers, self.command_buffer_count as usize)
    }
    ///Gets the value of [`Self::signal_semaphore_count`]
    pub fn signal_semaphore_count(&self) -> u32 {
        self.signal_semaphore_count
    }
    ///Gets the value of [`Self::signal_semaphores`]
    ///# Safety
    ///This function converts a pointer into a value which may be invalid, make sure
    ///that the pointer is valid before dereferencing.
    pub unsafe fn signal_semaphores(&self) -> &[Semaphore] {
        std::slice::from_raw_parts(self.signal_semaphores, self.signal_semaphore_count as usize)
    }
    ///Gets a mutable reference to the value of [`Self::s_type`]
    pub fn s_type_mut(&mut self) -> &mut StructureType {
        &mut self.s_type
    }
    ///Gets a mutable reference to the value of [`Self::wait_semaphore_count`]
    pub fn wait_semaphore_count_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::command_buffer_count`]
    pub fn command_buffer_count_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Gets a mutable reference to the value of [`Self::signal_semaphore_count`]
    pub fn signal_semaphore_count_mut(&mut self) -> &mut u32 {
        &mut getter
    }
    ///Sets the raw value of [`Self::s_type`]
    pub fn set_s_type(&mut self, value: crate::vulkan1_0::StructureType) -> &mut Self {
        self.s_type = value;
        self
    }
    ///Sets the raw value of [`Self::p_next`]
    pub fn set_p_next(&mut self, value: &'lt crate::vulkan1_0::BaseInStructure<'lt>) -> &mut Self {
        self.p_next = value as *const _;
        self
    }
    ///Sets the raw value of [`Self::wait_semaphore_count`]
    pub fn set_wait_semaphore_count(&mut self, value: u32) -> &mut Self {
        self.wait_semaphore_count = value;
        self
    }
    ///Sets the raw value of [`Self::wait_semaphores`]
    pub fn set_wait_semaphores(&mut self, value: &'lt [crate::vulkan1_0::Semaphore]) -> &mut Self {
        let len_ = value.len() as u32;
        let len_ = len_;
        self.wait_semaphores = value.as_ptr();
        self.wait_semaphore_count = len_;
        self
    }
    ///Sets the raw value of [`Self::wait_dst_stage_mask`]
    pub fn set_wait_dst_stage_mask(&mut self, value: &'lt [crate::vulkan1_0::PipelineStageFlags]) -> &mut Self {
        let len_ = value.len() as u32;
        let len_ = len_;
        self.wait_dst_stage_mask = value.as_ptr();
        self.wait_semaphore_count = len_;
        self
    }
    ///Sets the raw value of [`Self::command_buffer_count`]
    pub fn set_command_buffer_count(&mut self, value: u32) -> &mut Self {
        self.command_buffer_count = value;
        self
    }
    ///Sets the raw value of [`Self::command_buffers`]
    pub fn set_command_buffers(&mut self, value: &'lt [crate::vulkan1_0::CommandBuffer]) -> &mut Self {
        let len_ = value.len() as u32;
        let len_ = len_;
        self.command_buffers = value.as_ptr();
        self.command_buffer_count = len_;
        self
    }
    ///Sets the raw value of [`Self::signal_semaphore_count`]
    pub fn set_signal_semaphore_count(&mut self, value: u32) -> &mut Self {
        self.signal_semaphore_count = value;
        self
    }
    ///Sets the raw value of [`Self::signal_semaphores`]
    pub fn set_signal_semaphores(&mut self, value: &'lt [crate::vulkan1_0::Semaphore]) -> &mut Self {
        let len_ = value.len() as u32;
        let len_ = len_;
        self.signal_semaphores = value.as_ptr();
        self.signal_semaphore_count = len_;
        self
    }
}
///[VkInstance](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkInstance.html) - Opaque handle to an instance object
///# C Specifications
///There is no global state in Vulkan and all per-application state is stored
///in a [`Instance`] object.
///Creating a [`Instance`] object initializes the Vulkan library and allows
///the application to pass information about itself to the implementation.Instances are represented
/// by [`Instance`] handles:
///```c
///// Provided by VK_VERSION_1_0
///VK_DEFINE_HANDLE(VkInstance)
///```
///# Related
/// - [`crate::vulkan1_0`]
/// - [`CreateAndroidSurfaceKHR`]
/// - [`CreateDebugReportCallbackEXT`]
/// - [`CreateDebugUtilsMessengerEXT`]
/// - [`CreateDirectFBSurfaceEXT`]
/// - [`CreateDisplayPlaneSurfaceKHR`]
/// - [`CreateHeadlessSurfaceEXT`]
/// - [`CreateIosSurfaceMVK`]
/// - [`CreateImagePipeSurfaceFUCHSIA`]
/// - [`CreateInstance`]
/// - [`CreateMacOsSurfaceMVK`]
/// - [`CreateMetalSurfaceEXT`]
/// - [`CreateScreenSurfaceQNX`]
/// - [`CreateStreamDescriptorSurfaceGGP`]
/// - [`CreateViSurfaceNN`]
/// - [`CreateWaylandSurfaceKHR`]
/// - [`CreateWin32SurfaceKHR`]
/// - [`CreateXcbSurfaceKHR`]
/// - [`CreateXlibSurfaceKHR`]
/// - [`DebugReportMessageEXT`]
/// - [`DestroyDebugReportCallbackEXT`]
/// - [`DestroyDebugUtilsMessengerEXT`]
/// - [`DestroyInstance`]
/// - [`DestroySurfaceKHR`]
/// - [`EnumeratePhysicalDeviceGroups`]
/// - [`EnumeratePhysicalDeviceGroupsKHR`]
/// - [`EnumeratePhysicalDevices`]
/// - [`GetInstanceProcAddr`]
/// - [`SubmitDebugUtilsMessageEXT`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[repr(transparent)]
pub struct Instance(pub *mut ());
impl Instance {
    ///Creates a new null handle
    #[inline]
    pub const fn null() -> Self {
        Self(std::ptr::null_mut())
    }
    ///Checks if this is a null handle
    #[inline]
    pub const fn is_null(&self) -> bool {
        self == &Self::null()
    }
    ///Gets the raw value
    #[inline]
    pub fn raw(&self) -> *mut () {
        self.0
    }
}
unsafe impl Send for Instance {}
impl Default for Instance {
    fn default() -> Self {
        Self::default()
    }
}
impl std::fmt::Pointer for Instance {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "0x{:x}", self.0)
    }
}
impl std::fmt::Debug for Instance {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "0x{:x}", self.0)
    }
}
///[VkPhysicalDevice](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevice.html) - Opaque handle to a physical device object
///# C Specifications
///Vulkan separates the concept of *physical* and *logical* devices.
///A physical device usually represents a single complete implementation of
///Vulkan (excluding instance-level functionality) available to the host, of
///which there are a finite number.
///A logical device represents an instance of that implementation with its own
///state and resources independent of other logical devices.Physical devices are represented by
/// [`PhysicalDevice`] handles:
///```c
///// Provided by VK_VERSION_1_0
///VK_DEFINE_HANDLE(VkPhysicalDevice)
///```
///# Related
/// - [`crate::vulkan1_0`]
/// - [`DeviceGroupDeviceCreateInfo`]
/// - [`PhysicalDeviceGroupProperties`]
/// - [`AcquireDrmDisplayEXT`]
/// - [`AcquireWinrtDisplayNV`]
/// - [`AcquireXlibDisplayEXT`]
/// - [`CreateDevice`]
/// - [`CreateDisplayModeKHR`]
/// - [`EnumerateDeviceExtensionProperties`]
/// - [`EnumerateDeviceLayerProperties`]
/// - [`EnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR`]
/// - [`EnumeratePhysicalDevices`]
/// - [`GetDisplayModeProperties2KHR`]
/// - [`GetDisplayModePropertiesKHR`]
/// - [`GetDisplayPlaneCapabilities2KHR`]
/// - [`GetDisplayPlaneCapabilitiesKHR`]
/// - [`GetDisplayPlaneSupportedDisplaysKHR`]
/// - [`GetDrmDisplayEXT`]
/// - [`GetPhysicalDeviceCalibrateableTimeDomainsEXT`]
/// - [`GetPhysicalDeviceCooperativeMatrixPropertiesNV`]
/// - [`GetPhysicalDeviceDirectFBPresentationSupportEXT`]
/// - [`GetPhysicalDeviceDisplayPlaneProperties2KHR`]
/// - [`GetPhysicalDeviceDisplayPlanePropertiesKHR`]
/// - [`GetPhysicalDeviceDisplayProperties2KHR`]
/// - [`GetPhysicalDeviceDisplayPropertiesKHR`]
/// - [`GetPhysicalDeviceExternalBufferProperties`]
/// - [`GetPhysicalDeviceExternalBufferPropertiesKHR`]
/// - [`GetPhysicalDeviceExternalFenceProperties`]
/// - [`GetPhysicalDeviceExternalFencePropertiesKHR`]
/// - [`GetPhysicalDeviceExternalImageFormatPropertiesNV`]
/// - [`GetPhysicalDeviceExternalSemaphoreProperties`]
/// - [`GetPhysicalDeviceExternalSemaphorePropertiesKHR`]
/// - [`GetPhysicalDeviceFeatures`]
/// - [`GetPhysicalDeviceFeatures2`]
/// - [`GetPhysicalDeviceFeatures2KHR`]
/// - [`GetPhysicalDeviceFormatProperties`]
/// - [`GetPhysicalDeviceFormatProperties2`]
/// - [`GetPhysicalDeviceFormatProperties2KHR`]
/// - [`GetPhysicalDeviceFragmentShadingRatesKHR`]
/// - [`GetPhysicalDeviceImageFormatProperties`]
/// - [`GetPhysicalDeviceImageFormatProperties2`]
/// - [`GetPhysicalDeviceImageFormatProperties2KHR`]
/// - [`GetPhysicalDeviceMemoryProperties`]
/// - [`GetPhysicalDeviceMemoryProperties2`]
/// - [`GetPhysicalDeviceMemoryProperties2KHR`]
/// - [`GetPhysicalDeviceMultisamplePropertiesEXT`]
/// - [`GetPhysicalDevicePresentRectanglesKHR`]
/// - [`GetPhysicalDeviceProperties`]
/// - [`GetPhysicalDeviceProperties2`]
/// - [`GetPhysicalDeviceProperties2KHR`]
/// - [`GetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR`]
/// - [`GetPhysicalDeviceQueueFamilyProperties`]
/// - [`GetPhysicalDeviceQueueFamilyProperties2`]
/// - [`GetPhysicalDeviceQueueFamilyProperties2KHR`]
/// - [`GetPhysicalDeviceScreenPresentationSupportQNX`]
/// - [`GetPhysicalDeviceSparseImageFormatProperties`]
/// - [`GetPhysicalDeviceSparseImageFormatProperties2`]
/// - [`GetPhysicalDeviceSparseImageFormatProperties2KHR`]
/// - [`GetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV`]
/// - [`GetPhysicalDeviceSurfaceCapabilities2EXT`]
/// - [`GetPhysicalDeviceSurfaceCapabilities2KHR`]
/// - [`GetPhysicalDeviceSurfaceCapabilitiesKHR`]
/// - [`GetPhysicalDeviceSurfaceFormats2KHR`]
/// - [`GetPhysicalDeviceSurfaceFormatsKHR`]
/// - [`GetPhysicalDeviceSurfacePresentModes2EXT`]
/// - [`GetPhysicalDeviceSurfacePresentModesKHR`]
/// - [`GetPhysicalDeviceSurfaceSupportKHR`]
/// - [`GetPhysicalDeviceToolProperties`]
/// - [`GetPhysicalDeviceToolPropertiesEXT`]
/// - [`GetPhysicalDeviceVideoCapabilitiesKHR`]
/// - [`GetPhysicalDeviceVideoFormatPropertiesKHR`]
/// - [`GetPhysicalDeviceWaylandPresentationSupportKHR`]
/// - [`GetPhysicalDeviceWin32PresentationSupportKHR`]
/// - [`GetPhysicalDeviceXcbPresentationSupportKHR`]
/// - [`GetPhysicalDeviceXlibPresentationSupportKHR`]
/// - [`GetRandROutputDisplayEXT`]
/// - [`GetWinrtDisplayNV`]
/// - [`ReleaseDisplayEXT`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[repr(transparent)]
pub struct PhysicalDevice(pub *mut ());
impl PhysicalDevice {
    ///Creates a new null handle
    #[inline]
    pub const fn null() -> Self {
        Self(std::ptr::null_mut())
    }
    ///Checks if this is a null handle
    #[inline]
    pub const fn is_null(&self) -> bool {
        self == &Self::null()
    }
    ///Gets the raw value
    #[inline]
    pub fn raw(&self) -> *mut () {
        self.0
    }
}
unsafe impl Send for PhysicalDevice {}
impl Default for PhysicalDevice {
    fn default() -> Self {
        Self::default()
    }
}
impl std::fmt::Pointer for PhysicalDevice {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "0x{:x}", self.0)
    }
}
impl std::fmt::Debug for PhysicalDevice {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "0x{:x}", self.0)
    }
}
///[VkDevice](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDevice.html) - Opaque handle to a device object
///# C Specifications
///Logical devices are represented by [`Device`] handles:
///```c
///// Provided by VK_VERSION_1_0
///VK_DEFINE_HANDLE(VkDevice)
///```
///# Related
/// - [`crate::vulkan1_0`]
/// - [`AcquireFullScreenExclusiveModeEXT`]
/// - [`AcquireNextImage2KHR`]
/// - [`AcquireNextImageKHR`]
/// - [`AcquirePerformanceConfigurationINTEL`]
/// - [`AcquireProfilingLockKHR`]
/// - [`AllocateCommandBuffers`]
/// - [`AllocateDescriptorSets`]
/// - [`AllocateMemory`]
/// - [`BindAccelerationStructureMemoryNV`]
/// - [`BindBufferMemory`]
/// - [`BindBufferMemory2`]
/// - [`BindBufferMemory2KHR`]
/// - [`BindImageMemory`]
/// - [`BindImageMemory2`]
/// - [`BindImageMemory2KHR`]
/// - [`BindVideoSessionMemoryKHR`]
/// - [`BuildAccelerationStructuresKHR`]
/// - [`CompileDeferredNV`]
/// - [`CopyAccelerationStructureKHR`]
/// - [`CopyAccelerationStructureToMemoryKHR`]
/// - [`CopyMemoryToAccelerationStructureKHR`]
/// - [`CreateAccelerationStructureKHR`]
/// - [`CreateAccelerationStructureNV`]
/// - [`CreateBuffer`]
/// - [`CreateBufferCollectionFUCHSIA`]
/// - [`CreateBufferView`]
/// - [`CreateCommandPool`]
/// - [`CreateComputePipelines`]
/// - [`CreateCuFunctionNVX`]
/// - [`CreateCuModuleNVX`]
/// - [`CreateDeferredOperationKHR`]
/// - [`CreateDescriptorPool`]
/// - [`CreateDescriptorSetLayout`]
/// - [`CreateDescriptorUpdateTemplate`]
/// - [`CreateDescriptorUpdateTemplateKHR`]
/// - [`CreateDevice`]
/// - [`CreateEvent`]
/// - [`CreateFence`]
/// - [`CreateFramebuffer`]
/// - [`CreateGraphicsPipelines`]
/// - [`CreateImage`]
/// - [`CreateImageView`]
/// - [`CreateIndirectCommandsLayoutNV`]
/// - [`CreatePipelineCache`]
/// - [`CreatePipelineLayout`]
/// - [`CreatePrivateDataSlot`]
/// - [`CreatePrivateDataSlotEXT`]
/// - [`CreateQueryPool`]
/// - [`CreateRayTracingPipelinesKHR`]
/// - [`CreateRayTracingPipelinesNV`]
/// - [`CreateRenderPass`]
/// - [`CreateRenderPass2`]
/// - [`CreateRenderPass2KHR`]
/// - [`CreateSampler`]
/// - [`CreateSamplerYcbcrConversion`]
/// - [`CreateSamplerYcbcrConversionKHR`]
/// - [`CreateSemaphore`]
/// - [`CreateShaderModule`]
/// - [`CreateSharedSwapchainsKHR`]
/// - [`CreateSwapchainKHR`]
/// - [`CreateValidationCacheEXT`]
/// - [`CreateVideoSessionKHR`]
/// - [`CreateVideoSessionParametersKHR`]
/// - [`DebugMarkerSetObjectNameEXT`]
/// - [`DebugMarkerSetObjectTagEXT`]
/// - [`DeferredOperationJoinKHR`]
/// - [`DestroyAccelerationStructureKHR`]
/// - [`DestroyAccelerationStructureNV`]
/// - [`DestroyBuffer`]
/// - [`DestroyBufferCollectionFUCHSIA`]
/// - [`DestroyBufferView`]
/// - [`DestroyCommandPool`]
/// - [`DestroyCuFunctionNVX`]
/// - [`DestroyCuModuleNVX`]
/// - [`DestroyDeferredOperationKHR`]
/// - [`DestroyDescriptorPool`]
/// - [`DestroyDescriptorSetLayout`]
/// - [`DestroyDescriptorUpdateTemplate`]
/// - [`DestroyDescriptorUpdateTemplateKHR`]
/// - [`DestroyDevice`]
/// - [`DestroyEvent`]
/// - [`DestroyFence`]
/// - [`DestroyFramebuffer`]
/// - [`DestroyImage`]
/// - [`DestroyImageView`]
/// - [`DestroyIndirectCommandsLayoutNV`]
/// - [`DestroyPipeline`]
/// - [`DestroyPipelineCache`]
/// - [`DestroyPipelineLayout`]
/// - [`DestroyPrivateDataSlot`]
/// - [`DestroyPrivateDataSlotEXT`]
/// - [`DestroyQueryPool`]
/// - [`DestroyRenderPass`]
/// - [`DestroySampler`]
/// - [`DestroySamplerYcbcrConversion`]
/// - [`DestroySamplerYcbcrConversionKHR`]
/// - [`DestroySemaphore`]
/// - [`DestroyShaderModule`]
/// - [`DestroySwapchainKHR`]
/// - [`DestroyValidationCacheEXT`]
/// - [`DestroyVideoSessionKHR`]
/// - [`DestroyVideoSessionParametersKHR`]
/// - [`DeviceWaitIdle`]
/// - [`DisplayPowerControlEXT`]
/// - [`FlushMappedMemoryRanges`]
/// - [`FreeCommandBuffers`]
/// - [`FreeDescriptorSets`]
/// - [`FreeMemory`]
/// - [`GetAccelerationStructureBuildSizesKHR`]
/// - [`GetAccelerationStructureDeviceAddressKHR`]
/// - [`GetAccelerationStructureHandleNV`]
/// - [`GetAccelerationStructureMemoryRequirementsNV`]
/// - [`GetAndroidHardwareBufferPropertiesANDROID`]
/// - [`GetBufferCollectionPropertiesFUCHSIA`]
/// - [`GetBufferDeviceAddress`]
/// - [`GetBufferDeviceAddressEXT`]
/// - [`GetBufferDeviceAddressKHR`]
/// - [`GetBufferMemoryRequirements`]
/// - [`GetBufferMemoryRequirements2`]
/// - [`GetBufferMemoryRequirements2KHR`]
/// - [`GetBufferOpaqueCaptureAddress`]
/// - [`GetBufferOpaqueCaptureAddressKHR`]
/// - [`GetCalibratedTimestampsEXT`]
/// - [`GetDeferredOperationMaxConcurrencyKHR`]
/// - [`GetDeferredOperationResultKHR`]
/// - [`GetDescriptorSetHostMappingVALVE`]
/// - [`GetDescriptorSetLayoutHostMappingInfoVALVE`]
/// - [`GetDescriptorSetLayoutSupport`]
/// - [`GetDescriptorSetLayoutSupportKHR`]
/// - [`GetDeviceAccelerationStructureCompatibilityKHR`]
/// - [`GetDeviceBufferMemoryRequirements`]
/// - [`GetDeviceBufferMemoryRequirementsKHR`]
/// - [`GetDeviceGroupPeerMemoryFeatures`]
/// - [`GetDeviceGroupPeerMemoryFeaturesKHR`]
/// - [`GetDeviceGroupPresentCapabilitiesKHR`]
/// - [`GetDeviceGroupSurfacePresentModes2EXT`]
/// - [`GetDeviceGroupSurfacePresentModesKHR`]
/// - [`GetDeviceImageMemoryRequirements`]
/// - [`GetDeviceImageMemoryRequirementsKHR`]
/// - [`GetDeviceImageSparseMemoryRequirements`]
/// - [`GetDeviceImageSparseMemoryRequirementsKHR`]
/// - [`GetDeviceMemoryCommitment`]
/// - [`GetDeviceMemoryOpaqueCaptureAddress`]
/// - [`GetDeviceMemoryOpaqueCaptureAddressKHR`]
/// - [`GetDeviceProcAddr`]
/// - [`GetDeviceQueue`]
/// - [`GetDeviceQueue2`]
/// - [`GetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI`]
/// - [`GetEventStatus`]
/// - [`GetFenceFdKHR`]
/// - [`GetFenceStatus`]
/// - [`GetFenceWin32HandleKHR`]
/// - [`GetGeneratedCommandsMemoryRequirementsNV`]
/// - [`GetImageDrmFormatModifierPropertiesEXT`]
/// - [`GetImageMemoryRequirements`]
/// - [`GetImageMemoryRequirements2`]
/// - [`GetImageMemoryRequirements2KHR`]
/// - [`GetImageSparseMemoryRequirements`]
/// - [`GetImageSparseMemoryRequirements2`]
/// - [`GetImageSparseMemoryRequirements2KHR`]
/// - [`GetImageSubresourceLayout`]
/// - [`GetImageViewAddressNVX`]
/// - [`GetImageViewHandleNVX`]
/// - [`GetMemoryAndroidHardwareBufferANDROID`]
/// - [`GetMemoryFdKHR`]
/// - [`GetMemoryFdPropertiesKHR`]
/// - [`GetMemoryHostPointerPropertiesEXT`]
/// - [`GetMemoryRemoteAddressNV`]
/// - [`GetMemoryWin32HandleKHR`]
/// - [`GetMemoryWin32HandleNV`]
/// - [`GetMemoryWin32HandlePropertiesKHR`]
/// - [`GetMemoryZirconHandleFUCHSIA`]
/// - [`GetMemoryZirconHandlePropertiesFUCHSIA`]
/// - [`GetPastPresentationTimingGOOGLE`]
/// - [`GetPerformanceParameterINTEL`]
/// - [`GetPipelineCacheData`]
/// - [`GetPipelineExecutableInternalRepresentationsKHR`]
/// - [`GetPipelineExecutablePropertiesKHR`]
/// - [`GetPipelineExecutableStatisticsKHR`]
/// - [`GetPrivateData`]
/// - [`GetPrivateDataEXT`]
/// - [`GetQueryPoolResults`]
/// - [`GetRayTracingCaptureReplayShaderGroupHandlesKHR`]
/// - [`GetRayTracingShaderGroupHandlesKHR`]
/// - [`GetRayTracingShaderGroupHandlesNV`]
/// - [`GetRayTracingShaderGroupStackSizeKHR`]
/// - [`GetRefreshCycleDurationGOOGLE`]
/// - [`GetRenderAreaGranularity`]
/// - [`GetSemaphoreCounterValue`]
/// - [`GetSemaphoreCounterValueKHR`]
/// - [`GetSemaphoreFdKHR`]
/// - [`GetSemaphoreWin32HandleKHR`]
/// - [`GetSemaphoreZirconHandleFUCHSIA`]
/// - [`GetShaderInfoAMD`]
/// - [`GetSwapchainCounterEXT`]
/// - [`GetSwapchainImagesKHR`]
/// - [`GetSwapchainStatusKHR`]
/// - [`GetValidationCacheDataEXT`]
/// - [`GetVideoSessionMemoryRequirementsKHR`]
/// - [`ImportFenceFdKHR`]
/// - [`ImportFenceWin32HandleKHR`]
/// - [`ImportSemaphoreFdKHR`]
/// - [`ImportSemaphoreWin32HandleKHR`]
/// - [`ImportSemaphoreZirconHandleFUCHSIA`]
/// - [`InitializePerformanceApiINTEL`]
/// - [`InvalidateMappedMemoryRanges`]
/// - [`MapMemory`]
/// - [`MergePipelineCaches`]
/// - [`MergeValidationCachesEXT`]
/// - [`RegisterDeviceEventEXT`]
/// - [`RegisterDisplayEventEXT`]
/// - [`ReleaseFullScreenExclusiveModeEXT`]
/// - [`ReleasePerformanceConfigurationINTEL`]
/// - [`ReleaseProfilingLockKHR`]
/// - [`ResetCommandPool`]
/// - [`ResetDescriptorPool`]
/// - [`ResetEvent`]
/// - [`ResetFences`]
/// - [`ResetQueryPool`]
/// - [`ResetQueryPoolEXT`]
/// - [`SetBufferCollectionBufferConstraintsFUCHSIA`]
/// - [`SetBufferCollectionImageConstraintsFUCHSIA`]
/// - [`SetDebugUtilsObjectNameEXT`]
/// - [`SetDebugUtilsObjectTagEXT`]
/// - [`SetDeviceMemoryPriorityEXT`]
/// - [`SetEvent`]
/// - [`SetHdrMetadataEXT`]
/// - [`SetLocalDimmingAMD`]
/// - [`SetPrivateData`]
/// - [`SetPrivateDataEXT`]
/// - [`SignalSemaphore`]
/// - [`SignalSemaphoreKHR`]
/// - [`TrimCommandPool`]
/// - [`TrimCommandPoolKHR`]
/// - [`UninitializePerformanceApiINTEL`]
/// - [`UnmapMemory`]
/// - [`UpdateDescriptorSetWithTemplate`]
/// - [`UpdateDescriptorSetWithTemplateKHR`]
/// - [`UpdateDescriptorSets`]
/// - [`UpdateVideoSessionParametersKHR`]
/// - [`WaitForFences`]
/// - [`WaitForPresentKHR`]
/// - [`WaitSemaphores`]
/// - [`WaitSemaphoresKHR`]
/// - [`WriteAccelerationStructuresPropertiesKHR`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[repr(transparent)]
pub struct Device(pub *mut ());
impl Device {
    ///Creates a new null handle
    #[inline]
    pub const fn null() -> Self {
        Self(std::ptr::null_mut())
    }
    ///Checks if this is a null handle
    #[inline]
    pub const fn is_null(&self) -> bool {
        self == &Self::null()
    }
    ///Gets the raw value
    #[inline]
    pub fn raw(&self) -> *mut () {
        self.0
    }
}
unsafe impl Send for Device {}
impl Default for Device {
    fn default() -> Self {
        Self::default()
    }
}
impl std::fmt::Pointer for Device {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "0x{:x}", self.0)
    }
}
impl std::fmt::Debug for Device {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "0x{:x}", self.0)
    }
}
///[VkQueue](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkQueue.html) - Opaque handle to a queue object
///# C Specifications
///Creating a logical device also creates the queues associated with that
///device.
///The queues to create are described by a set of [`DeviceQueueCreateInfo`]
///structures that are passed to [`CreateDevice`] in
///`pQueueCreateInfos`.Queues are represented by [`Queue`] handles:
///```c
///// Provided by VK_VERSION_1_0
///VK_DEFINE_HANDLE(VkQueue)
///```
///# Related
/// - [`crate::vulkan1_0`]
/// - [`GetDeviceQueue`]
/// - [`GetDeviceQueue2`]
/// - [`GetQueueCheckpointData2NV`]
/// - [`GetQueueCheckpointDataNV`]
/// - [`QueueBeginDebugUtilsLabelEXT`]
/// - [`QueueBindSparse`]
/// - [`QueueEndDebugUtilsLabelEXT`]
/// - [`QueueInsertDebugUtilsLabelEXT`]
/// - [`QueuePresentKHR`]
/// - [`QueueSetPerformanceConfigurationINTEL`]
/// - [`QueueSubmit`]
/// - [`QueueSubmit2`]
/// - [`QueueSubmit2KHR`]
/// - [`QueueWaitIdle`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[repr(transparent)]
pub struct Queue(pub *mut ());
impl Queue {
    ///Creates a new null handle
    #[inline]
    pub const fn null() -> Self {
        Self(std::ptr::null_mut())
    }
    ///Checks if this is a null handle
    #[inline]
    pub const fn is_null(&self) -> bool {
        self == &Self::null()
    }
    ///Gets the raw value
    #[inline]
    pub fn raw(&self) -> *mut () {
        self.0
    }
}
unsafe impl Send for Queue {}
impl Default for Queue {
    fn default() -> Self {
        Self::default()
    }
}
impl std::fmt::Pointer for Queue {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "0x{:x}", self.0)
    }
}
impl std::fmt::Debug for Queue {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "0x{:x}", self.0)
    }
}
///[VkCommandBuffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandBuffer.html) - Opaque handle to a command buffer object
///# C Specifications
///Command buffers are objects used to record commands which  **can**  be
///subsequently submitted to a device queue for execution.
///There are two levels of command buffers - *primary command buffers*, which
/// **can**  execute secondary command buffers, and which are submitted to queues,
///and *secondary command buffers*, which  **can**  be executed by primary command
///buffers, and which are not directly submitted to queues.Command buffers are represented by
/// [`CommandBuffer`] handles:
///```c
///// Provided by VK_VERSION_1_0
///VK_DEFINE_HANDLE(VkCommandBuffer)
///```
///# Related
/// - [`crate::vulkan1_0`]
/// - [`CommandBufferSubmitInfo`]
/// - [`SubmitInfo`]
/// - [`AllocateCommandBuffers`]
/// - [`BeginCommandBuffer`]
/// - [`CmdBeginConditionalRenderingEXT`]
/// - [`CmdBeginDebugUtilsLabelEXT`]
/// - [`CmdBeginQuery`]
/// - [`CmdBeginQueryIndexedEXT`]
/// - [`CmdBeginRenderPass`]
/// - [`CmdBeginRenderPass2`]
/// - [`CmdBeginRenderPass2KHR`]
/// - [`CmdBeginRendering`]
/// - [`CmdBeginRenderingKHR`]
/// - [`CmdBeginTransformFeedbackEXT`]
/// - [`CmdBeginVideoCodingKHR`]
/// - [`CmdBindDescriptorSets`]
/// - [`CmdBindIndexBuffer`]
/// - [`CmdBindInvocationMaskHUAWEI`]
/// - [`CmdBindPipeline`]
/// - [`CmdBindPipelineShaderGroupNV`]
/// - [`CmdBindShadingRateImageNV`]
/// - [`CmdBindTransformFeedbackBuffersEXT`]
/// - [`CmdBindVertexBuffers`]
/// - [`CmdBindVertexBuffers2`]
/// - [`CmdBindVertexBuffers2EXT`]
/// - [`CmdBlitImage`]
/// - [`CmdBlitImage2`]
/// - [`CmdBlitImage2KHR`]
/// - [`CmdBuildAccelerationStructureNV`]
/// - [`CmdBuildAccelerationStructuresIndirectKHR`]
/// - [`CmdBuildAccelerationStructuresKHR`]
/// - [`CmdClearAttachments`]
/// - [`CmdClearColorImage`]
/// - [`CmdClearDepthStencilImage`]
/// - [`CmdControlVideoCodingKHR`]
/// - [`CmdCopyAccelerationStructureKHR`]
/// - [`CmdCopyAccelerationStructureNV`]
/// - [`CmdCopyAccelerationStructureToMemoryKHR`]
/// - [`CmdCopyBuffer`]
/// - [`CmdCopyBuffer2`]
/// - [`CmdCopyBuffer2KHR`]
/// - [`CmdCopyBufferToImage`]
/// - [`CmdCopyBufferToImage2`]
/// - [`CmdCopyBufferToImage2KHR`]
/// - [`CmdCopyImage`]
/// - [`CmdCopyImage2`]
/// - [`CmdCopyImage2KHR`]
/// - [`CmdCopyImageToBuffer`]
/// - [`CmdCopyImageToBuffer2`]
/// - [`CmdCopyImageToBuffer2KHR`]
/// - [`CmdCopyMemoryToAccelerationStructureKHR`]
/// - [`CmdCopyQueryPoolResults`]
/// - [`CmdCuLaunchKernelNVX`]
/// - [`CmdDebugMarkerBeginEXT`]
/// - [`CmdDebugMarkerEndEXT`]
/// - [`CmdDebugMarkerInsertEXT`]
/// - [`CmdDecodeVideoKHR`]
/// - [`CmdDispatch`]
/// - [`CmdDispatchBase`]
/// - [`CmdDispatchBaseKHR`]
/// - [`CmdDispatchIndirect`]
/// - [`CmdDraw`]
/// - [`CmdDrawIndexed`]
/// - [`CmdDrawIndexedIndirect`]
/// - [`CmdDrawIndexedIndirectCount`]
/// - [`CmdDrawIndexedIndirectCountAMD`]
/// - [`CmdDrawIndexedIndirectCountKHR`]
/// - [`CmdDrawIndirect`]
/// - [`CmdDrawIndirectByteCountEXT`]
/// - [`CmdDrawIndirectCount`]
/// - [`CmdDrawIndirectCountAMD`]
/// - [`CmdDrawIndirectCountKHR`]
/// - [`CmdDrawMeshTasksIndirectCountNV`]
/// - [`CmdDrawMeshTasksIndirectNV`]
/// - [`CmdDrawMeshTasksNV`]
/// - [`CmdDrawMultiEXT`]
/// - [`CmdDrawMultiIndexedEXT`]
/// - [`CmdEncodeVideoKHR`]
/// - [`CmdEndConditionalRenderingEXT`]
/// - [`CmdEndDebugUtilsLabelEXT`]
/// - [`CmdEndQuery`]
/// - [`CmdEndQueryIndexedEXT`]
/// - [`CmdEndRenderPass`]
/// - [`CmdEndRenderPass2`]
/// - [`CmdEndRenderPass2KHR`]
/// - [`CmdEndRendering`]
/// - [`CmdEndRenderingKHR`]
/// - [`CmdEndTransformFeedbackEXT`]
/// - [`CmdEndVideoCodingKHR`]
/// - [`CmdExecuteCommands`]
/// - [`CmdExecuteGeneratedCommandsNV`]
/// - [`CmdFillBuffer`]
/// - [`CmdInsertDebugUtilsLabelEXT`]
/// - [`CmdNextSubpass`]
/// - [`CmdNextSubpass2`]
/// - [`CmdNextSubpass2KHR`]
/// - [`CmdPipelineBarrier`]
/// - [`CmdPipelineBarrier2`]
/// - [`CmdPipelineBarrier2KHR`]
/// - [`CmdPreprocessGeneratedCommandsNV`]
/// - [`CmdPushConstants`]
/// - [`CmdPushDescriptorSetKHR`]
/// - [`CmdPushDescriptorSetWithTemplateKHR`]
/// - [`CmdResetEvent`]
/// - [`CmdResetEvent2`]
/// - [`CmdResetEvent2KHR`]
/// - [`CmdResetQueryPool`]
/// - [`CmdResolveImage`]
/// - [`CmdResolveImage2`]
/// - [`CmdResolveImage2KHR`]
/// - [`CmdSetBlendConstants`]
/// - [`CmdSetCheckpointNV`]
/// - [`CmdSetCoarseSampleOrderNV`]
/// - [`CmdSetColorWriteEnableEXT`]
/// - [`CmdSetCullMode`]
/// - [`CmdSetCullModeEXT`]
/// - [`CmdSetDepthBias`]
/// - [`CmdSetDepthBiasEnable`]
/// - [`CmdSetDepthBiasEnableEXT`]
/// - [`CmdSetDepthBounds`]
/// - [`CmdSetDepthBoundsTestEnable`]
/// - [`CmdSetDepthBoundsTestEnableEXT`]
/// - [`CmdSetDepthCompareOp`]
/// - [`CmdSetDepthCompareOpEXT`]
/// - [`CmdSetDepthTestEnable`]
/// - [`CmdSetDepthTestEnableEXT`]
/// - [`CmdSetDepthWriteEnable`]
/// - [`CmdSetDepthWriteEnableEXT`]
/// - [`CmdSetDeviceMask`]
/// - [`CmdSetDeviceMaskKHR`]
/// - [`CmdSetDiscardRectangleEXT`]
/// - [`CmdSetEvent`]
/// - [`CmdSetEvent2`]
/// - [`CmdSetEvent2KHR`]
/// - [`CmdSetExclusiveScissorNV`]
/// - [`CmdSetFragmentShadingRateEnumNV`]
/// - [`CmdSetFragmentShadingRateKHR`]
/// - [`CmdSetFrontFace`]
/// - [`CmdSetFrontFaceEXT`]
/// - [`CmdSetLineStippleEXT`]
/// - [`CmdSetLineWidth`]
/// - [`CmdSetLogicOpEXT`]
/// - [`CmdSetPatchControlPointsEXT`]
/// - [`CmdSetPerformanceMarkerINTEL`]
/// - [`CmdSetPerformanceOverrideINTEL`]
/// - [`CmdSetPerformanceStreamMarkerINTEL`]
/// - [`CmdSetPrimitiveRestartEnable`]
/// - [`CmdSetPrimitiveRestartEnableEXT`]
/// - [`CmdSetPrimitiveTopology`]
/// - [`CmdSetPrimitiveTopologyEXT`]
/// - [`CmdSetRasterizerDiscardEnable`]
/// - [`CmdSetRasterizerDiscardEnableEXT`]
/// - [`CmdSetRayTracingPipelineStackSizeKHR`]
/// - [`CmdSetSampleLocationsEXT`]
/// - [`CmdSetScissor`]
/// - [`CmdSetScissorWithCount`]
/// - [`CmdSetScissorWithCountEXT`]
/// - [`CmdSetStencilCompareMask`]
/// - [`CmdSetStencilOp`]
/// - [`CmdSetStencilOpEXT`]
/// - [`CmdSetStencilReference`]
/// - [`CmdSetStencilTestEnable`]
/// - [`CmdSetStencilTestEnableEXT`]
/// - [`CmdSetStencilWriteMask`]
/// - [`CmdSetVertexInputEXT`]
/// - [`CmdSetViewport`]
/// - [`CmdSetViewportShadingRatePaletteNV`]
/// - [`CmdSetViewportWScalingNV`]
/// - [`CmdSetViewportWithCount`]
/// - [`CmdSetViewportWithCountEXT`]
/// - [`CmdSubpassShadingHUAWEI`]
/// - [`CmdTraceRaysIndirectKHR`]
/// - [`CmdTraceRaysKHR`]
/// - [`CmdTraceRaysNV`]
/// - [`CmdUpdateBuffer`]
/// - [`CmdWaitEvents`]
/// - [`CmdWaitEvents2`]
/// - [`CmdWaitEvents2KHR`]
/// - [`CmdWriteAccelerationStructuresPropertiesKHR`]
/// - [`CmdWriteAccelerationStructuresPropertiesNV`]
/// - [`CmdWriteBufferMarker2AMD`]
/// - [`CmdWriteBufferMarkerAMD`]
/// - [`CmdWriteTimestamp`]
/// - [`CmdWriteTimestamp2`]
/// - [`CmdWriteTimestamp2KHR`]
/// - [`EndCommandBuffer`]
/// - [`FreeCommandBuffers`]
/// - [`ResetCommandBuffer`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[repr(transparent)]
pub struct CommandBuffer(pub *mut ());
impl CommandBuffer {
    ///Creates a new null handle
    #[inline]
    pub const fn null() -> Self {
        Self(std::ptr::null_mut())
    }
    ///Checks if this is a null handle
    #[inline]
    pub const fn is_null(&self) -> bool {
        self == &Self::null()
    }
    ///Gets the raw value
    #[inline]
    pub fn raw(&self) -> *mut () {
        self.0
    }
}
unsafe impl Send for CommandBuffer {}
impl Default for CommandBuffer {
    fn default() -> Self {
        Self::default()
    }
}
impl std::fmt::Pointer for CommandBuffer {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "0x{:x}", self.0)
    }
}
impl std::fmt::Debug for CommandBuffer {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "0x{:x}", self.0)
    }
}
///[VkDeviceMemory](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceMemory.html) - Opaque handle to a device memory object
///# C Specifications
///A Vulkan device operates on data in device memory via memory objects that
///are represented in the API by a [`DeviceMemory`] handle:
///```c
///// Provided by VK_VERSION_1_0
///VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDeviceMemory)
///```
///# Related
/// - [`crate::vulkan1_0`]
/// - [`BindAccelerationStructureMemoryInfoNV`]
/// - [`BindBufferMemoryInfo`]
/// - [`BindImageMemoryInfo`]
/// - [`DeviceMemoryOpaqueCaptureAddressInfo`]
/// - [`MappedMemoryRange`]
/// - [`MemoryGetAndroidHardwareBufferInfoANDROID`]
/// - [`MemoryGetFdInfoKHR`]
/// - [`MemoryGetRemoteAddressInfoNV`]
/// - [`MemoryGetWin32HandleInfoKHR`]
/// - [`MemoryGetZirconHandleInfoFUCHSIA`]
/// - [`SparseImageMemoryBind`]
/// - [`SparseMemoryBind`]
/// - [`VideoBindMemoryKHR`]
/// - [`Win32KeyedMutexAcquireReleaseInfoKHR`]
/// - [`Win32KeyedMutexAcquireReleaseInfoNV`]
/// - [`AllocateMemory`]
/// - [`BindBufferMemory`]
/// - [`BindImageMemory`]
/// - [`FreeMemory`]
/// - [`GetDeviceMemoryCommitment`]
/// - [`GetMemoryWin32HandleNV`]
/// - [`MapMemory`]
/// - [`SetDeviceMemoryPriorityEXT`]
/// - [`UnmapMemory`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[repr(transparent)]
pub struct DeviceMemory(pub u64);
impl DeviceMemory {
    ///Creates a new null handle
    #[inline]
    pub const fn null() -> Self {
        Self(0)
    }
    ///Checks if this is a null handle
    #[inline]
    pub const fn is_null(&self) -> bool {
        self == &Self::null()
    }
    ///Gets the raw value
    #[inline]
    pub fn raw(&self) -> u64 {
        self.0
    }
}
unsafe impl Send for DeviceMemory {}
impl Default for DeviceMemory {
    fn default() -> Self {
        Self::default()
    }
}
impl std::fmt::Pointer for DeviceMemory {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "0x{:x}", self.0)
    }
}
impl std::fmt::Debug for DeviceMemory {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "0x{:x}", self.0)
    }
}
///[VkCommandPool](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandPool.html) - Opaque handle to a command pool object
///# C Specifications
///Command pools are opaque objects that command buffer memory is allocated
///from, and which allow the implementation to amortize the cost of resource
///creation across multiple command buffers.
///Command pools are externally synchronized, meaning that a command pool  **must**
///not be used concurrently in multiple threads.
///That includes use via recording commands on any command buffers allocated
///from the pool, as well as operations that allocate, free, and reset command
///buffers or the pool itself.Command pools are represented by [`CommandPool`] handles:
///```c
///// Provided by VK_VERSION_1_0
///VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkCommandPool)
///```
///# Related
/// - [`crate::vulkan1_0`]
/// - [`CommandBufferAllocateInfo`]
/// - [`CreateCommandPool`]
/// - [`DestroyCommandPool`]
/// - [`FreeCommandBuffers`]
/// - [`ResetCommandPool`]
/// - [`TrimCommandPool`]
/// - [`TrimCommandPoolKHR`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[repr(transparent)]
pub struct CommandPool(pub u64);
impl CommandPool {
    ///Creates a new null handle
    #[inline]
    pub const fn null() -> Self {
        Self(0)
    }
    ///Checks if this is a null handle
    #[inline]
    pub const fn is_null(&self) -> bool {
        self == &Self::null()
    }
    ///Gets the raw value
    #[inline]
    pub fn raw(&self) -> u64 {
        self.0
    }
}
unsafe impl Send for CommandPool {}
impl Default for CommandPool {
    fn default() -> Self {
        Self::default()
    }
}
impl std::fmt::Pointer for CommandPool {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "0x{:x}", self.0)
    }
}
impl std::fmt::Debug for CommandPool {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "0x{:x}", self.0)
    }
}
///[VkBuffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBuffer.html) - Opaque handle to a buffer object
///# C Specifications
///Buffers represent linear arrays of data which are used for various purposes
///by binding them to a graphics or compute pipeline via descriptor sets or via
///certain commands, or by directly specifying them as parameters to certain
///commands.Buffers are represented by [`Buffer`] handles:
///```c
///// Provided by VK_VERSION_1_0
///VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkBuffer)
///```
///# Related
/// - [`crate::vulkan1_0`]
/// - [`AccelerationStructureCreateInfoKHR`]
/// - [`BindBufferMemoryInfo`]
/// - [`BufferDeviceAddressInfo`]
/// - [`BufferMemoryBarrier`]
/// - [`BufferMemoryBarrier2`]
/// - [`BufferMemoryRequirementsInfo2`]
/// - [`BufferViewCreateInfo`]
/// - [`ConditionalRenderingBeginInfoEXT`]
/// - [`CopyBufferInfo2`]
/// - [`CopyBufferToImageInfo2`]
/// - [`CopyImageToBufferInfo2`]
/// - [`DedicatedAllocationMemoryAllocateInfoNV`]
/// - [`DescriptorBufferInfo`]
/// - [`GeneratedCommandsInfoNV`]
/// - [`GeometryAabbNV`]
/// - [`GeometryTrianglesNV`]
/// - [`IndirectCommandsStreamNV`]
/// - [`MemoryDedicatedAllocateInfo`]
/// - [`SparseBufferMemoryBindInfo`]
/// - [`VideoDecodeInfoKHR`]
/// - [`VideoEncodeInfoKHR`]
/// - [`BindBufferMemory`]
/// - [`CmdBeginTransformFeedbackEXT`]
/// - [`CmdBindIndexBuffer`]
/// - [`CmdBindTransformFeedbackBuffersEXT`]
/// - [`CmdBindVertexBuffers`]
/// - [`CmdBindVertexBuffers2`]
/// - [`CmdBindVertexBuffers2EXT`]
/// - [`CmdBuildAccelerationStructureNV`]
/// - [`CmdCopyBuffer`]
/// - [`CmdCopyBufferToImage`]
/// - [`CmdCopyImageToBuffer`]
/// - [`CmdCopyQueryPoolResults`]
/// - [`CmdDispatchIndirect`]
/// - [`CmdDrawIndexedIndirect`]
/// - [`CmdDrawIndexedIndirectCount`]
/// - [`CmdDrawIndexedIndirectCountAMD`]
/// - [`CmdDrawIndexedIndirectCountKHR`]
/// - [`CmdDrawIndirect`]
/// - [`CmdDrawIndirectByteCountEXT`]
/// - [`CmdDrawIndirectCount`]
/// - [`CmdDrawIndirectCountAMD`]
/// - [`CmdDrawIndirectCountKHR`]
/// - [`CmdDrawMeshTasksIndirectCountNV`]
/// - [`CmdDrawMeshTasksIndirectNV`]
/// - [`CmdEndTransformFeedbackEXT`]
/// - [`CmdFillBuffer`]
/// - [`CmdTraceRaysNV`]
/// - [`CmdUpdateBuffer`]
/// - [`CmdWriteBufferMarker2AMD`]
/// - [`CmdWriteBufferMarkerAMD`]
/// - [`CreateBuffer`]
/// - [`DestroyBuffer`]
/// - [`GetBufferMemoryRequirements`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[repr(transparent)]
pub struct Buffer(pub u64);
impl Buffer {
    ///Creates a new null handle
    #[inline]
    pub const fn null() -> Self {
        Self(0)
    }
    ///Checks if this is a null handle
    #[inline]
    pub const fn is_null(&self) -> bool {
        self == &Self::null()
    }
    ///Gets the raw value
    #[inline]
    pub fn raw(&self) -> u64 {
        self.0
    }
}
unsafe impl Send for Buffer {}
impl Default for Buffer {
    fn default() -> Self {
        Self::default()
    }
}
impl std::fmt::Pointer for Buffer {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "0x{:x}", self.0)
    }
}
impl std::fmt::Debug for Buffer {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "0x{:x}", self.0)
    }
}
///[VkBufferView](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferView.html) - Opaque handle to a buffer view object
///# C Specifications
///A *buffer view* represents a contiguous range of a buffer and a specific
///format to be used to interpret the data.
///Buffer views are used to enable shaders to access buffer contents
///interpreted as formatted data.
///In order to create a valid buffer view, the buffer  **must**  have been created
///with at least one of the following usage flags:
/// - `VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT`
/// - `VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT`
///Buffer views are represented by [`BufferView`] handles:
///```c
///// Provided by VK_VERSION_1_0
///VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkBufferView)
///```
///# Related
/// - [`crate::vulkan1_0`]
/// - [`WriteDescriptorSet`]
/// - [`CreateBufferView`]
/// - [`DestroyBufferView`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[repr(transparent)]
pub struct BufferView(pub u64);
impl BufferView {
    ///Creates a new null handle
    #[inline]
    pub const fn null() -> Self {
        Self(0)
    }
    ///Checks if this is a null handle
    #[inline]
    pub const fn is_null(&self) -> bool {
        self == &Self::null()
    }
    ///Gets the raw value
    #[inline]
    pub fn raw(&self) -> u64 {
        self.0
    }
}
unsafe impl Send for BufferView {}
impl Default for BufferView {
    fn default() -> Self {
        Self::default()
    }
}
impl std::fmt::Pointer for BufferView {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "0x{:x}", self.0)
    }
}
impl std::fmt::Debug for BufferView {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "0x{:x}", self.0)
    }
}
///[VkImage](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImage.html) - Opaque handle to an image object
///# C Specifications
///Images represent multidimensional - up to 3 - arrays of data which  **can**  be
///used for various purposes (e.g. attachments, textures), by binding them to a
///graphics or compute pipeline via descriptor sets, or by directly specifying
///them as parameters to certain commands.Images are represented by [`Image`] handles:
///```c
///// Provided by VK_VERSION_1_0
///VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkImage)
///```
///# Related
/// - [`crate::vulkan1_0`]
/// - [`BindImageMemoryInfo`]
/// - [`BlitImageInfo2`]
/// - [`CopyBufferToImageInfo2`]
/// - [`CopyImageInfo2`]
/// - [`CopyImageToBufferInfo2`]
/// - [`DedicatedAllocationMemoryAllocateInfoNV`]
/// - [`ImageMemoryBarrier`]
/// - [`ImageMemoryBarrier2`]
/// - [`ImageMemoryRequirementsInfo2`]
/// - [`ImageSparseMemoryRequirementsInfo2`]
/// - [`ImageViewCreateInfo`]
/// - [`MemoryDedicatedAllocateInfo`]
/// - [`ResolveImageInfo2`]
/// - [`SparseImageMemoryBindInfo`]
/// - [`SparseImageOpaqueMemoryBindInfo`]
/// - [`BindImageMemory`]
/// - [`CmdBlitImage`]
/// - [`CmdClearColorImage`]
/// - [`CmdClearDepthStencilImage`]
/// - [`CmdCopyBufferToImage`]
/// - [`CmdCopyImage`]
/// - [`CmdCopyImageToBuffer`]
/// - [`CmdResolveImage`]
/// - [`CreateImage`]
/// - [`DestroyImage`]
/// - [`GetImageDrmFormatModifierPropertiesEXT`]
/// - [`GetImageMemoryRequirements`]
/// - [`GetImageSparseMemoryRequirements`]
/// - [`GetImageSubresourceLayout`]
/// - [`GetSwapchainImagesKHR`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[repr(transparent)]
pub struct Image(pub u64);
impl Image {
    ///Creates a new null handle
    #[inline]
    pub const fn null() -> Self {
        Self(0)
    }
    ///Checks if this is a null handle
    #[inline]
    pub const fn is_null(&self) -> bool {
        self == &Self::null()
    }
    ///Gets the raw value
    #[inline]
    pub fn raw(&self) -> u64 {
        self.0
    }
}
unsafe impl Send for Image {}
impl Default for Image {
    fn default() -> Self {
        Self::default()
    }
}
impl std::fmt::Pointer for Image {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "0x{:x}", self.0)
    }
}
impl std::fmt::Debug for Image {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "0x{:x}", self.0)
    }
}
///[VkImageView](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageView.html) - Opaque handle to an image view object
///# C Specifications
///Image objects are not directly accessed by pipeline shaders for reading or
///writing image data.
///Instead, *image views* representing contiguous ranges of the image
///subresources and containing additional metadata are used for that purpose.
///Views  **must**  be created on images of compatible types, and  **must**  represent a
///valid subset of image subresources.Image views are represented by [`ImageView`] handles:
///```c
///// Provided by VK_VERSION_1_0
///VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkImageView)
///```
///# Related
/// - [`crate::vulkan1_0`]
/// - [`DescriptorImageInfo`]
/// - [`FramebufferCreateInfo`]
/// - [`ImageViewHandleInfoNVX`]
/// - [`RenderPassAttachmentBeginInfo`]
/// - [`RenderingAttachmentInfo`]
/// - [`RenderingFragmentDensityMapAttachmentInfoEXT`]
/// - [`RenderingFragmentShadingRateAttachmentInfoKHR`]
/// - [`VideoPictureResourceKHR`]
/// - [`CmdBindInvocationMaskHUAWEI`]
/// - [`CmdBindShadingRateImageNV`]
/// - [`CreateImageView`]
/// - [`DestroyImageView`]
/// - [`GetImageViewAddressNVX`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[repr(transparent)]
pub struct ImageView(pub u64);
impl ImageView {
    ///Creates a new null handle
    #[inline]
    pub const fn null() -> Self {
        Self(0)
    }
    ///Checks if this is a null handle
    #[inline]
    pub const fn is_null(&self) -> bool {
        self == &Self::null()
    }
    ///Gets the raw value
    #[inline]
    pub fn raw(&self) -> u64 {
        self.0
    }
}
unsafe impl Send for ImageView {}
impl Default for ImageView {
    fn default() -> Self {
        Self::default()
    }
}
impl std::fmt::Pointer for ImageView {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "0x{:x}", self.0)
    }
}
impl std::fmt::Debug for ImageView {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "0x{:x}", self.0)
    }
}
///[VkShaderModule](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkShaderModule.html) - Opaque handle to a shader module object
///# C Specifications
///*Shader modules* contain *shader code* and one or more entry points.
///Shaders are selected from a shader module by specifying an entry point as
///part of [pipeline](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#pipelines) creation.
///The stages of a pipeline  **can**  use shaders that come from different modules.
///The shader code defining a shader module  **must**  be in the SPIR-V format, as
///described by the [Vulkan Environment for SPIR-V](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#spirvenv) appendix.Shader modules are represented by [`ShaderModule`] handles:
///```c
///// Provided by VK_VERSION_1_0
///VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkShaderModule)
///```
///# Related
/// - [`crate::vulkan1_0`]
/// - [`PipelineShaderStageCreateInfo`]
/// - [`CreateShaderModule`]
/// - [`DestroyShaderModule`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[repr(transparent)]
pub struct ShaderModule(pub u64);
impl ShaderModule {
    ///Creates a new null handle
    #[inline]
    pub const fn null() -> Self {
        Self(0)
    }
    ///Checks if this is a null handle
    #[inline]
    pub const fn is_null(&self) -> bool {
        self == &Self::null()
    }
    ///Gets the raw value
    #[inline]
    pub fn raw(&self) -> u64 {
        self.0
    }
}
unsafe impl Send for ShaderModule {}
impl Default for ShaderModule {
    fn default() -> Self {
        Self::default()
    }
}
impl std::fmt::Pointer for ShaderModule {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "0x{:x}", self.0)
    }
}
impl std::fmt::Debug for ShaderModule {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "0x{:x}", self.0)
    }
}
///[VkPipeline](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipeline.html) - Opaque handle to a pipeline object
///# C Specifications
///Compute,
///ray tracing,
///and graphics pipelines are each represented by [`Pipeline`] handles:
///```c
///// Provided by VK_VERSION_1_0
///VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkPipeline)
///```
///# Related
/// - [`crate::vulkan1_0`]
/// - [`ComputePipelineCreateInfo`]
/// - [`GeneratedCommandsInfoNV`]
/// - [`GeneratedCommandsMemoryRequirementsInfoNV`]
/// - [`GraphicsPipelineCreateInfo`]
/// - [`GraphicsPipelineShaderGroupsCreateInfoNV`]
/// - [`PipelineExecutableInfoKHR`]
/// - [`PipelineInfoKHR`]
/// - [`PipelineLibraryCreateInfoKHR`]
/// - [`RayTracingPipelineCreateInfoKHR`]
/// - [`RayTracingPipelineCreateInfoNV`]
/// - [`CmdBindPipeline`]
/// - [`CmdBindPipelineShaderGroupNV`]
/// - [`CompileDeferredNV`]
/// - [`CreateComputePipelines`]
/// - [`CreateGraphicsPipelines`]
/// - [`CreateRayTracingPipelinesKHR`]
/// - [`CreateRayTracingPipelinesNV`]
/// - [`DestroyPipeline`]
/// - [`GetRayTracingCaptureReplayShaderGroupHandlesKHR`]
/// - [`GetRayTracingShaderGroupHandlesKHR`]
/// - [`GetRayTracingShaderGroupHandlesNV`]
/// - [`GetRayTracingShaderGroupStackSizeKHR`]
/// - [`GetShaderInfoAMD`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[repr(transparent)]
pub struct Pipeline(pub u64);
impl Pipeline {
    ///Creates a new null handle
    #[inline]
    pub const fn null() -> Self {
        Self(0)
    }
    ///Checks if this is a null handle
    #[inline]
    pub const fn is_null(&self) -> bool {
        self == &Self::null()
    }
    ///Gets the raw value
    #[inline]
    pub fn raw(&self) -> u64 {
        self.0
    }
}
unsafe impl Send for Pipeline {}
impl Default for Pipeline {
    fn default() -> Self {
        Self::default()
    }
}
impl std::fmt::Pointer for Pipeline {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "0x{:x}", self.0)
    }
}
impl std::fmt::Debug for Pipeline {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "0x{:x}", self.0)
    }
}
///[VkPipelineLayout](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineLayout.html) - Opaque handle to a pipeline layout object
///# C Specifications
///Access to descriptor sets from a pipeline is accomplished through a
///*pipeline layout*.
///Zero or more descriptor set layouts and zero or more push constant ranges
///are combined to form a pipeline layout object describing the complete set of
///resources that  **can**  be accessed by a pipeline.
///The pipeline layout represents a sequence of descriptor sets with each
///having a specific layout.
///This sequence of layouts is used to determine the interface between shader
///stages and shader resources.
///Each pipeline is created using a pipeline layout.Pipeline layout objects are represented by
/// [`PipelineLayout`] handles:
///```c
///// Provided by VK_VERSION_1_0
///VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkPipelineLayout)
///```
///# Related
/// - [`crate::vulkan1_0`]
/// - [`ComputePipelineCreateInfo`]
/// - [`DescriptorUpdateTemplateCreateInfo`]
/// - [`GraphicsPipelineCreateInfo`]
/// - [`IndirectCommandsLayoutTokenNV`]
/// - [`RayTracingPipelineCreateInfoKHR`]
/// - [`RayTracingPipelineCreateInfoNV`]
/// - [`CmdBindDescriptorSets`]
/// - [`CmdPushConstants`]
/// - [`CmdPushDescriptorSetKHR`]
/// - [`CmdPushDescriptorSetWithTemplateKHR`]
/// - [`CreatePipelineLayout`]
/// - [`DestroyPipelineLayout`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[repr(transparent)]
pub struct PipelineLayout(pub u64);
impl PipelineLayout {
    ///Creates a new null handle
    #[inline]
    pub const fn null() -> Self {
        Self(0)
    }
    ///Checks if this is a null handle
    #[inline]
    pub const fn is_null(&self) -> bool {
        self == &Self::null()
    }
    ///Gets the raw value
    #[inline]
    pub fn raw(&self) -> u64 {
        self.0
    }
}
unsafe impl Send for PipelineLayout {}
impl Default for PipelineLayout {
    fn default() -> Self {
        Self::default()
    }
}
impl std::fmt::Pointer for PipelineLayout {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "0x{:x}", self.0)
    }
}
impl std::fmt::Debug for PipelineLayout {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "0x{:x}", self.0)
    }
}
///[VkSampler](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSampler.html) - Opaque handle to a sampler object
///# C Specifications
///[`Sampler`] objects represent the state of an image sampler which is
///used by the implementation to read image data and apply filtering and other
///transformations for the shader.Samplers are represented by [`Sampler`] handles:
///```c
///// Provided by VK_VERSION_1_0
///VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkSampler)
///```
///# Related
/// - [`crate::vulkan1_0`]
/// - [`DescriptorImageInfo`]
/// - [`DescriptorSetLayoutBinding`]
/// - [`ImageViewHandleInfoNVX`]
/// - [`CreateSampler`]
/// - [`DestroySampler`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[repr(transparent)]
pub struct Sampler(pub u64);
impl Sampler {
    ///Creates a new null handle
    #[inline]
    pub const fn null() -> Self {
        Self(0)
    }
    ///Checks if this is a null handle
    #[inline]
    pub const fn is_null(&self) -> bool {
        self == &Self::null()
    }
    ///Gets the raw value
    #[inline]
    pub fn raw(&self) -> u64 {
        self.0
    }
}
unsafe impl Send for Sampler {}
impl Default for Sampler {
    fn default() -> Self {
        Self::default()
    }
}
impl std::fmt::Pointer for Sampler {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "0x{:x}", self.0)
    }
}
impl std::fmt::Debug for Sampler {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "0x{:x}", self.0)
    }
}
///[VkDescriptorSet](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorSet.html) - Opaque handle to a descriptor set object
///# C Specifications
///Descriptor sets are allocated from descriptor pool objects, and are
///represented by [`DescriptorSet`] handles:
///```c
///// Provided by VK_VERSION_1_0
///VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDescriptorSet)
///```
///# Related
/// - [`crate::vulkan1_0`]
/// - [`CopyDescriptorSet`]
/// - [`WriteDescriptorSet`]
/// - [`AllocateDescriptorSets`]
/// - [`CmdBindDescriptorSets`]
/// - [`FreeDescriptorSets`]
/// - [`GetDescriptorSetHostMappingVALVE`]
/// - [`UpdateDescriptorSetWithTemplate`]
/// - [`UpdateDescriptorSetWithTemplateKHR`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[repr(transparent)]
pub struct DescriptorSet(pub u64);
impl DescriptorSet {
    ///Creates a new null handle
    #[inline]
    pub const fn null() -> Self {
        Self(0)
    }
    ///Checks if this is a null handle
    #[inline]
    pub const fn is_null(&self) -> bool {
        self == &Self::null()
    }
    ///Gets the raw value
    #[inline]
    pub fn raw(&self) -> u64 {
        self.0
    }
}
unsafe impl Send for DescriptorSet {}
impl Default for DescriptorSet {
    fn default() -> Self {
        Self::default()
    }
}
impl std::fmt::Pointer for DescriptorSet {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "0x{:x}", self.0)
    }
}
impl std::fmt::Debug for DescriptorSet {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "0x{:x}", self.0)
    }
}
///[VkDescriptorSetLayout](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorSetLayout.html) - Opaque handle to a descriptor set layout object
///# C Specifications
///A descriptor set layout object is defined by an array of zero or more
///descriptor bindings.
///Each individual descriptor binding is specified by a descriptor type, a
///count (array size) of the number of descriptors in the binding, a set of
///shader stages that  **can**  access the binding, and (if using immutable
///samplers) an array of sampler descriptors.Descriptor set layout objects are represented by
/// [`DescriptorSetLayout`]
///handles:
///```c
///// Provided by VK_VERSION_1_0
///VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDescriptorSetLayout)
///```
///# Related
/// - [`crate::vulkan1_0`]
/// - [`DescriptorSetAllocateInfo`]
/// - [`DescriptorSetBindingReferenceVALVE`]
/// - [`DescriptorUpdateTemplateCreateInfo`]
/// - [`PipelineLayoutCreateInfo`]
/// - [`CreateDescriptorSetLayout`]
/// - [`DestroyDescriptorSetLayout`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[repr(transparent)]
pub struct DescriptorSetLayout(pub u64);
impl DescriptorSetLayout {
    ///Creates a new null handle
    #[inline]
    pub const fn null() -> Self {
        Self(0)
    }
    ///Checks if this is a null handle
    #[inline]
    pub const fn is_null(&self) -> bool {
        self == &Self::null()
    }
    ///Gets the raw value
    #[inline]
    pub fn raw(&self) -> u64 {
        self.0
    }
}
unsafe impl Send for DescriptorSetLayout {}
impl Default for DescriptorSetLayout {
    fn default() -> Self {
        Self::default()
    }
}
impl std::fmt::Pointer for DescriptorSetLayout {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "0x{:x}", self.0)
    }
}
impl std::fmt::Debug for DescriptorSetLayout {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "0x{:x}", self.0)
    }
}
///[VkDescriptorPool](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorPool.html) - Opaque handle to a descriptor pool object
///# C Specifications
///A *descriptor pool* maintains a pool of descriptors, from which descriptor
///sets are allocated.
///Descriptor pools are externally synchronized, meaning that the application
/// **must**  not allocate and/or free descriptor sets from the same pool in
///multiple threads simultaneously.Descriptor pools are represented by [`DescriptorPool`] handles:
///```c
///// Provided by VK_VERSION_1_0
///VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDescriptorPool)
///```
///# Related
/// - [`crate::vulkan1_0`]
/// - [`DescriptorSetAllocateInfo`]
/// - [`CreateDescriptorPool`]
/// - [`DestroyDescriptorPool`]
/// - [`FreeDescriptorSets`]
/// - [`ResetDescriptorPool`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[repr(transparent)]
pub struct DescriptorPool(pub u64);
impl DescriptorPool {
    ///Creates a new null handle
    #[inline]
    pub const fn null() -> Self {
        Self(0)
    }
    ///Checks if this is a null handle
    #[inline]
    pub const fn is_null(&self) -> bool {
        self == &Self::null()
    }
    ///Gets the raw value
    #[inline]
    pub fn raw(&self) -> u64 {
        self.0
    }
}
unsafe impl Send for DescriptorPool {}
impl Default for DescriptorPool {
    fn default() -> Self {
        Self::default()
    }
}
impl std::fmt::Pointer for DescriptorPool {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "0x{:x}", self.0)
    }
}
impl std::fmt::Debug for DescriptorPool {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "0x{:x}", self.0)
    }
}
///[VkFence](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFence.html) - Opaque handle to a fence object
///# C Specifications
///Fences are a synchronization primitive that  **can**  be used to insert a
///dependency from a queue to the host.
///Fences have two states - signaled and unsignaled.
///A fence  **can**  be signaled as part of the execution of a
///[queue submission](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#devsandqueues-submission) command.
///Fences  **can**  be unsignaled on the host with [`ResetFences`].
///Fences  **can**  be waited on by the host with the [`WaitForFences`] command,
///and the current state  **can**  be queried with [`GetFenceStatus`].The internal data of a fence
/// **may**  include a reference to any resources and
///pending work associated with signal or unsignal operations performed on that
///fence object, collectively referred to as the fence’s *payload*.
///Mechanisms to import and export that internal data to and from fences are
///provided [`ExportFenceCreateInfo`].
///These mechanisms indirectly enable applications to share fence state between
///two or more fences and other synchronization primitives across process and
///API boundaries.Fences are represented by [`Fence`] handles:
///```c
///// Provided by VK_VERSION_1_0
///VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkFence)
///```
///# Related
/// - [`crate::vulkan1_0`]
/// - [`AcquireNextImageInfoKHR`]
/// - [`FenceGetFdInfoKHR`]
/// - [`FenceGetWin32HandleInfoKHR`]
/// - [`ImportFenceFdInfoKHR`]
/// - [`ImportFenceWin32HandleInfoKHR`]
/// - [`AcquireNextImageKHR`]
/// - [`CreateFence`]
/// - [`DestroyFence`]
/// - [`GetFenceStatus`]
/// - [`QueueBindSparse`]
/// - [`QueueSubmit`]
/// - [`QueueSubmit2`]
/// - [`QueueSubmit2KHR`]
/// - [`RegisterDeviceEventEXT`]
/// - [`RegisterDisplayEventEXT`]
/// - [`ResetFences`]
/// - [`WaitForFences`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[repr(transparent)]
pub struct Fence(pub u64);
impl Fence {
    ///Creates a new null handle
    #[inline]
    pub const fn null() -> Self {
        Self(0)
    }
    ///Checks if this is a null handle
    #[inline]
    pub const fn is_null(&self) -> bool {
        self == &Self::null()
    }
    ///Gets the raw value
    #[inline]
    pub fn raw(&self) -> u64 {
        self.0
    }
}
unsafe impl Send for Fence {}
impl Default for Fence {
    fn default() -> Self {
        Self::default()
    }
}
impl std::fmt::Pointer for Fence {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "0x{:x}", self.0)
    }
}
impl std::fmt::Debug for Fence {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "0x{:x}", self.0)
    }
}
///[VkSemaphore](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSemaphore.html) - Opaque handle to a semaphore object
///# C Specifications
///Semaphores are a synchronization primitive that  **can**  be used to insert a
///dependency
///between queue operations or between a queue operation and the host.
///[Binary semaphores](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#glossary) have two states - signaled and unsignaled.
///[Timeline semaphores](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#glossary) have a strictly increasing 64-bit unsigned
///integer payload and are signaled with respect to a particular reference
///value.
///A semaphore  **can**  be signaled after execution of a queue operation is
///completed, and a queue operation  **can**  wait for a semaphore to become
///signaled before it begins execution.
///A timeline semaphore  **can**  additionally be signaled from the host with the
///[`SignalSemaphore`] command and waited on from the host with the
///[`WaitSemaphores`] command.The internal data of a semaphore  **may**  include a reference to any
/// resources
///and pending work associated with signal or unsignal operations performed on
///that semaphore object, collectively referred to as the semaphore’s
///*payload*.
///Mechanisms to import and export that internal data to and from semaphores
///are provided [`ExportSemaphoreCreateInfo`].
///These mechanisms indirectly enable applications to share semaphore state
///between two or more semaphores and other synchronization primitives across
///process and API boundaries.Semaphores are represented by [`Semaphore`] handles:
///```c
///// Provided by VK_VERSION_1_0
///VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkSemaphore)
///```
///# Related
/// - [`crate::vulkan1_0`]
/// - [`AcquireNextImageInfoKHR`]
/// - [`BindSparseInfo`]
/// - [`ImportSemaphoreFdInfoKHR`]
/// - [`ImportSemaphoreWin32HandleInfoKHR`]
/// - [`ImportSemaphoreZirconHandleInfoFUCHSIA`]
/// - [`PresentInfoKHR`]
/// - [`SemaphoreGetFdInfoKHR`]
/// - [`SemaphoreGetWin32HandleInfoKHR`]
/// - [`SemaphoreGetZirconHandleInfoFUCHSIA`]
/// - [`SemaphoreSignalInfo`]
/// - [`SemaphoreSubmitInfo`]
/// - [`SemaphoreWaitInfo`]
/// - [`SubmitInfo`]
/// - [`AcquireNextImageKHR`]
/// - [`CreateSemaphore`]
/// - [`DestroySemaphore`]
/// - [`GetSemaphoreCounterValue`]
/// - [`GetSemaphoreCounterValueKHR`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[repr(transparent)]
pub struct Semaphore(pub u64);
impl Semaphore {
    ///Creates a new null handle
    #[inline]
    pub const fn null() -> Self {
        Self(0)
    }
    ///Checks if this is a null handle
    #[inline]
    pub const fn is_null(&self) -> bool {
        self == &Self::null()
    }
    ///Gets the raw value
    #[inline]
    pub fn raw(&self) -> u64 {
        self.0
    }
}
unsafe impl Send for Semaphore {}
impl Default for Semaphore {
    fn default() -> Self {
        Self::default()
    }
}
impl std::fmt::Pointer for Semaphore {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "0x{:x}", self.0)
    }
}
impl std::fmt::Debug for Semaphore {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "0x{:x}", self.0)
    }
}
///[VkEvent](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkEvent.html) - Opaque handle to an event object
///# C Specifications
///Events are a synchronization primitive that  **can**  be used to insert a
///fine-grained dependency between commands submitted to the same queue, or
///between the host and a queue.
///Events  **must**  not be used to insert a dependency between commands submitted
///to different queues.
///Events have two states - signaled and unsignaled.
///An application  **can**  signal or unsignal an event either on the host or on the
///device.
///A device  **can**  be made to wait for an event to become signaled before
///executing further operations.
///No command exists to wait for an event to become signaled on the host, but
///the current state of an event  **can**  be queried.Events are represented by [`Event`] handles:
///```c
///// Provided by VK_VERSION_1_0
///VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkEvent)
///```
///# Related
/// - [`crate::vulkan1_0`]
/// - [`CmdResetEvent`]
/// - [`CmdResetEvent2`]
/// - [`CmdResetEvent2KHR`]
/// - [`CmdSetEvent`]
/// - [`CmdSetEvent2`]
/// - [`CmdSetEvent2KHR`]
/// - [`CmdWaitEvents`]
/// - [`CmdWaitEvents2`]
/// - [`CmdWaitEvents2KHR`]
/// - [`CreateEvent`]
/// - [`DestroyEvent`]
/// - [`GetEventStatus`]
/// - [`ResetEvent`]
/// - [`SetEvent`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[repr(transparent)]
pub struct Event(pub u64);
impl Event {
    ///Creates a new null handle
    #[inline]
    pub const fn null() -> Self {
        Self(0)
    }
    ///Checks if this is a null handle
    #[inline]
    pub const fn is_null(&self) -> bool {
        self == &Self::null()
    }
    ///Gets the raw value
    #[inline]
    pub fn raw(&self) -> u64 {
        self.0
    }
}
unsafe impl Send for Event {}
impl Default for Event {
    fn default() -> Self {
        Self::default()
    }
}
impl std::fmt::Pointer for Event {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "0x{:x}", self.0)
    }
}
impl std::fmt::Debug for Event {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "0x{:x}", self.0)
    }
}
///[VkQueryPool](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkQueryPool.html) - Opaque handle to a query pool object
///# C Specifications
///Queries are managed using *query pool* objects.
///Each query pool is a collection of a specific number of queries of a
///particular type.Query pools are represented by [`QueryPool`] handles:
///```c
///// Provided by VK_VERSION_1_0
///VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkQueryPool)
///```
///# Related
/// - [`crate::vulkan1_0`]
/// - [`CmdBeginQuery`]
/// - [`CmdBeginQueryIndexedEXT`]
/// - [`CmdCopyQueryPoolResults`]
/// - [`CmdEndQuery`]
/// - [`CmdEndQueryIndexedEXT`]
/// - [`CmdResetQueryPool`]
/// - [`CmdWriteAccelerationStructuresPropertiesKHR`]
/// - [`CmdWriteAccelerationStructuresPropertiesNV`]
/// - [`CmdWriteTimestamp`]
/// - [`CmdWriteTimestamp2`]
/// - [`CmdWriteTimestamp2KHR`]
/// - [`CreateQueryPool`]
/// - [`DestroyQueryPool`]
/// - [`GetQueryPoolResults`]
/// - [`ResetQueryPool`]
/// - [`ResetQueryPoolEXT`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[repr(transparent)]
pub struct QueryPool(pub u64);
impl QueryPool {
    ///Creates a new null handle
    #[inline]
    pub const fn null() -> Self {
        Self(0)
    }
    ///Checks if this is a null handle
    #[inline]
    pub const fn is_null(&self) -> bool {
        self == &Self::null()
    }
    ///Gets the raw value
    #[inline]
    pub fn raw(&self) -> u64 {
        self.0
    }
}
unsafe impl Send for QueryPool {}
impl Default for QueryPool {
    fn default() -> Self {
        Self::default()
    }
}
impl std::fmt::Pointer for QueryPool {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "0x{:x}", self.0)
    }
}
impl std::fmt::Debug for QueryPool {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "0x{:x}", self.0)
    }
}
///[VkFramebuffer](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFramebuffer.html) - Opaque handle to a framebuffer object
///# C Specifications
///Render passes operate in conjunction with *framebuffers*.
///Framebuffers represent a collection of specific memory attachments that a
///render pass instance uses.Framebuffers are represented by [`Framebuffer`] handles:
///```c
///// Provided by VK_VERSION_1_0
///VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkFramebuffer)
///```
///# Related
/// - [`crate::vulkan1_0`]
/// - [`CommandBufferInheritanceInfo`]
/// - [`RenderPassBeginInfo`]
/// - [`CreateFramebuffer`]
/// - [`DestroyFramebuffer`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[repr(transparent)]
pub struct Framebuffer(pub u64);
impl Framebuffer {
    ///Creates a new null handle
    #[inline]
    pub const fn null() -> Self {
        Self(0)
    }
    ///Checks if this is a null handle
    #[inline]
    pub const fn is_null(&self) -> bool {
        self == &Self::null()
    }
    ///Gets the raw value
    #[inline]
    pub fn raw(&self) -> u64 {
        self.0
    }
}
unsafe impl Send for Framebuffer {}
impl Default for Framebuffer {
    fn default() -> Self {
        Self::default()
    }
}
impl std::fmt::Pointer for Framebuffer {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "0x{:x}", self.0)
    }
}
impl std::fmt::Debug for Framebuffer {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "0x{:x}", self.0)
    }
}
///[VkRenderPass](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderPass.html) - Opaque handle to a render pass object
///# C Specifications
///A render pass object represents a collection of attachments, subpasses, and
///dependencies between the subpasses, and describes how the attachments are
///used over the course of the subpasses.Render passes are represented by [`RenderPass`] handles:
///```c
///// Provided by VK_VERSION_1_0
///VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkRenderPass)
///```
///# Related
/// - [`crate::vulkan1_0`]
/// - [`CommandBufferInheritanceInfo`]
/// - [`FramebufferCreateInfo`]
/// - [`GraphicsPipelineCreateInfo`]
/// - [`RenderPassBeginInfo`]
/// - [`SubpassShadingPipelineCreateInfoHUAWEI`]
/// - [`CreateRenderPass`]
/// - [`CreateRenderPass2`]
/// - [`CreateRenderPass2KHR`]
/// - [`DestroyRenderPass`]
/// - [`GetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI`]
/// - [`GetRenderAreaGranularity`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[repr(transparent)]
pub struct RenderPass(pub u64);
impl RenderPass {
    ///Creates a new null handle
    #[inline]
    pub const fn null() -> Self {
        Self(0)
    }
    ///Checks if this is a null handle
    #[inline]
    pub const fn is_null(&self) -> bool {
        self == &Self::null()
    }
    ///Gets the raw value
    #[inline]
    pub fn raw(&self) -> u64 {
        self.0
    }
}
unsafe impl Send for RenderPass {}
impl Default for RenderPass {
    fn default() -> Self {
        Self::default()
    }
}
impl std::fmt::Pointer for RenderPass {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "0x{:x}", self.0)
    }
}
impl std::fmt::Debug for RenderPass {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "0x{:x}", self.0)
    }
}
///[VkPipelineCache](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineCache.html) - Opaque handle to a pipeline cache object
///# C Specifications
///Pipeline cache objects allow the result of pipeline construction to be
///reused between pipelines and between runs of an application.
///Reuse between pipelines is achieved by passing the same pipeline cache
///object when creating multiple related pipelines.
///Reuse across runs of an application is achieved by retrieving pipeline cache
///contents in one run of an application, saving the contents, and using them
///to preinitialize a pipeline cache on a subsequent run.
///The contents of the pipeline cache objects are managed by the
///implementation.
///Applications  **can**  manage the host memory consumed by a pipeline cache object
///and control the amount of data retrieved from a pipeline cache object.Pipeline cache objects are
/// represented by [`PipelineCache`] handles:
///```c
///// Provided by VK_VERSION_1_0
///VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkPipelineCache)
///```
///# Related
/// - [`crate::vulkan1_0`]
/// - [`CreateComputePipelines`]
/// - [`CreateGraphicsPipelines`]
/// - [`CreatePipelineCache`]
/// - [`CreateRayTracingPipelinesKHR`]
/// - [`CreateRayTracingPipelinesNV`]
/// - [`DestroyPipelineCache`]
/// - [`GetPipelineCacheData`]
/// - [`MergePipelineCaches`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[repr(transparent)]
pub struct PipelineCache(pub u64);
impl PipelineCache {
    ///Creates a new null handle
    #[inline]
    pub const fn null() -> Self {
        Self(0)
    }
    ///Checks if this is a null handle
    #[inline]
    pub const fn is_null(&self) -> bool {
        self == &Self::null()
    }
    ///Gets the raw value
    #[inline]
    pub fn raw(&self) -> u64 {
        self.0
    }
}
unsafe impl Send for PipelineCache {}
impl Default for PipelineCache {
    fn default() -> Self {
        Self::default()
    }
}
impl std::fmt::Pointer for PipelineCache {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "0x{:x}", self.0)
    }
}
impl std::fmt::Debug for PipelineCache {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "0x{:x}", self.0)
    }
}
