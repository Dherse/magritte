//![VK_EXT_display_control](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_display_control.html) - device extension
//!# Description
//!This extension defines a set of utility functions for use with the
//!`[`VK_KHR_display`]` and `[`VK_KHR_display_swapchain`]` extensions.
//!# Revision
//!1
//!# Dependencies
//! - Requires Vulkan 1.0
//! - Requires `[`VK_EXT_display_surface_counter`]`
//! - Requires `[`VK_KHR_swapchain`]`
//!# Contacts
//! - James Jones [cubanismo](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_display_control]
//!   @cubanismo%0A<<Here describe the issue or question you have about the VK_EXT_display_control
//!   extension>>)
//!# New functions & commands
//! - [`DisplayPowerControlEXT`]
//! - [`GetSwapchainCounterEXT`]
//! - [`RegisterDeviceEventEXT`]
//! - [`RegisterDisplayEventEXT`]
//!# New structures
//! - [`DeviceEventInfoEXT`]
//! - [`DisplayEventInfoEXT`]
//! - [`DisplayPowerInfoEXT`]
//! - Extending [`SwapchainCreateInfoKHR`]:
//! - [`SwapchainCounterCreateInfoEXT`]
//!# New enums
//! - [`DeviceEventTypeEXT`]
//! - [`DisplayEventTypeEXT`]
//! - [`DisplayPowerStateEXT`]
//!# New constants
//! - [`EXT_DISPLAY_CONTROL_EXTENSION_NAME`]
//! - [`EXT_DISPLAY_CONTROL_SPEC_VERSION`]
//! - Extending [`StructureType`]:
//! - `VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT`
//! - `VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT`
//! - `VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT`
//! - `VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT`
//!# Known issues & F.A.Q
//!1) Should this extension add an explicit “WaitForVsync” API or a fence
//!signaled at vsync that the application can wait on?**RESOLVED**: A fence.
//!A separate API could later be provided that allows exporting the fence to a
//!native object that could be inserted into standard run loops on POSIX and
//!Windows systems.2) Should callbacks be added for a vsync event, or in general to monitor
//!events in Vulkan?**RESOLVED**: No, fences should be used.
//!Some events are generated by interrupts which are managed in the kernel.
//!In order to use a callback provided by the application, drivers would need
//!to have the userspace driver spawn threads that would wait on the kernel
//!event, and hence the callbacks could be difficult for the application to
//!synchronize with its other work given they would arrive on a foreign thread.3) Should vblank or
//! scanline events be exposed?**RESOLVED**: Vblank events.
//!Scanline events could be added by a separate extension, but the latency of
//!processing an interrupt and waking up a userspace event is high enough that
//!the accuracy of a scanline event would be rather low.
//!Further, per-scanline interrupts are not supported by all hardware.
//!# Version History
//! - Revision 1, 2016-12-13 (James Jones)
//! - Initial draft
//!# Other info
//! * 2016-12-13
//! * No known IP claims.
//!*
//! - Pierre Boudier, NVIDIA
//! - James Jones, NVIDIA
//! - Damien Leone, NVIDIA
//! - Pierre-Loup Griffais, Valve
//! - Daniel Vetter, Intel
//!# Related
//! - [`DeviceEventInfoEXT`]
//! - [`DeviceEventTypeEXT`]
//! - [`DisplayEventInfoEXT`]
//! - [`DisplayEventTypeEXT`]
//! - [`DisplayPowerInfoEXT`]
//! - [`DisplayPowerStateEXT`]
//! - [`SwapchainCounterCreateInfoEXT`]
//! - [`DisplayPowerControlEXT`]
//! - [`GetSwapchainCounterEXT`]
//! - [`RegisterDeviceEventEXT`]
//! - [`RegisterDisplayEventEXT`]
//!
//!# Notes and documentation
//!For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
//!
//!This documentation is generated from the Vulkan specification and documentation.
//!The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
//! Commons Attribution 4.0 International*.
//!This license explicitely allows adapting the source material as long as proper credit is given.
#[cfg(feature = "bytemuck")]
use bytemuck::{Pod, Zeroable};
#[cfg(feature = "serde")]
use serde::{Deserialize, Serialize};
use std::ffi::CStr;
///This element is not documented in the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html).
///See the module level documentation where a description may be given.
#[doc(alias = "VK_EXT_DISPLAY_CONTROL_SPEC_VERSION")]
pub const EXT_DISPLAY_CONTROL_SPEC_VERSION: u32 = 1;
///This element is not documented in the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html).
///See the module level documentation where a description may be given.
#[doc(alias = "VK_EXT_DISPLAY_CONTROL_EXTENSION_NAME")]
pub const EXT_DISPLAY_CONTROL_EXTENSION_NAME: &'static CStr = crate::cstr!("VK_EXT_display_control");
///[VkDisplayPowerStateEXT](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDisplayPowerStateEXT.html) - Possible power states for a display
///# C Specifications
///Possible values of [`DisplayPowerInfoEXT::power_state`], specifying
///the new power state of a display, are:
///```c
///// Provided by VK_EXT_display_control
///typedef enum VkDisplayPowerStateEXT {
///    VK_DISPLAY_POWER_STATE_OFF_EXT = 0,
///    VK_DISPLAY_POWER_STATE_SUSPEND_EXT = 1,
///    VK_DISPLAY_POWER_STATE_ON_EXT = 2,
///} VkDisplayPowerStateEXT;
///```
///# Description
/// - [`DISPLAY_POWER_STATE_OFF`] specifies that the display is
///powered down.
/// - [`DISPLAY_POWER_STATE_SUSPEND`] specifies that the display is
///put into a low power mode, from which it **may** be able to transition back
///to [`DISPLAY_POWER_STATE_ON`] more quickly than if it were in
///[`DISPLAY_POWER_STATE_OFF`].
///This state **may** be the same as [`DISPLAY_POWER_STATE_OFF`].
/// - [`DISPLAY_POWER_STATE_ON`] specifies that the display is
///powered on.
///# Related
/// - [`VK_EXT_display_control`]
/// - [`DisplayPowerInfoEXT`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkDisplayPowerStateEXT")]
#[derive(Clone, Copy, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct DisplayPowerStateEXT(i32);
impl const Default for DisplayPowerStateEXT {
    fn default() -> Self {
        Self(0)
    }
}
impl std::fmt::Debug for DisplayPowerStateEXT {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        f.debug_tuple("DisplayPowerStateEXT")
            .field(match *self {
                Self::DISPLAY_POWER_STATE_OFF => &"DISPLAY_POWER_STATE_OFF",
                Self::DISPLAY_POWER_STATE_SUSPEND => &"DISPLAY_POWER_STATE_SUSPEND",
                Self::DISPLAY_POWER_STATE_ON => &"DISPLAY_POWER_STATE_ON",
                other => unreachable!("invalid value for `DisplayPowerStateEXT`: {:?}", other),
            })
            .finish()
    }
}
impl DisplayPowerStateEXT {
    ///[`DISPLAY_POWER_STATE_OFF`] specifies that the display is
    ///powered down.
    pub const DISPLAY_POWER_STATE_OFF: Self = Self(0);
    ///[`DISPLAY_POWER_STATE_SUSPEND`] specifies that the display is
    ///put into a low power mode, from which it **may** be able to transition back
    ///to [`DISPLAY_POWER_STATE_ON`] more quickly than if it were in
    ///[`DISPLAY_POWER_STATE_OFF`].
    ///This state **may** be the same as [`DISPLAY_POWER_STATE_OFF`].
    pub const DISPLAY_POWER_STATE_SUSPEND: Self = Self(1);
    ///[`DISPLAY_POWER_STATE_ON`] specifies that the display is
    ///powered on.
    pub const DISPLAY_POWER_STATE_ON: Self = Self(2);
    ///Default empty value
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Gets the raw underlying value
    #[inline]
    pub const fn bits(&self) -> i32 {
        self.0
    }
}
///[VkDeviceEventTypeEXT](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceEventTypeEXT.html) - Events that can occur on a device object
///# C Specifications
///Possible values of [`DeviceEventInfoEXT`]`::device`, specifying when
///a fence will be signaled, are:
///```c
///// Provided by VK_EXT_display_control
///typedef enum VkDeviceEventTypeEXT {
///    VK_DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT = 0,
///} VkDeviceEventTypeEXT;
///```
///# Description
/// - [`DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG`] specifies that the fence
///is signaled when a display is plugged into or unplugged from the
///specified device.
///Applications **can** use this notification to determine when they need to
///re-enumerate the available displays on a device.
///# Related
/// - [`VK_EXT_display_control`]
/// - [`DeviceEventInfoEXT`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkDeviceEventTypeEXT")]
#[derive(Clone, Copy, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct DeviceEventTypeEXT(i32);
impl const Default for DeviceEventTypeEXT {
    fn default() -> Self {
        Self(0)
    }
}
impl std::fmt::Debug for DeviceEventTypeEXT {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        f.debug_tuple("DeviceEventTypeEXT")
            .field(match *self {
                Self::DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG => &"DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG",
                other => unreachable!("invalid value for `DeviceEventTypeEXT`: {:?}", other),
            })
            .finish()
    }
}
impl DeviceEventTypeEXT {
    ///[`DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG`] specifies that the fence
    ///is signaled when a display is plugged into or unplugged from the
    ///specified device.
    ///Applications **can** use this notification to determine when they need to
    ///re-enumerate the available displays on a device.
    pub const DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG: Self = Self(0);
    ///Default empty value
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Gets the raw underlying value
    #[inline]
    pub const fn bits(&self) -> i32 {
        self.0
    }
}
///[VkDisplayEventTypeEXT](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDisplayEventTypeEXT.html) - Events that can occur on a display object
///# C Specifications
///Possible values of [`DisplayEventInfoEXT::display_event`],
///specifying when a fence will be signaled, are:
///```c
///// Provided by VK_EXT_display_control
///typedef enum VkDisplayEventTypeEXT {
///    VK_DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT = 0,
///} VkDisplayEventTypeEXT;
///```
///# Description
/// - [`DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT`] specifies that the fence
///is signaled when the first pixel of the next display refresh cycle
///leaves the display engine for the display.
///# Related
/// - [`VK_EXT_display_control`]
/// - [`DisplayEventInfoEXT`]
///
///# Notes and documentation
///For more information, see the [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html)
///
///This documentation is generated from the Vulkan specification and documentation.
///The documentation is copyrighted by *The Khronos Group Inc.* and is licensed under *Creative
/// Commons Attribution 4.0 International*.
///This license explicitely allows adapting the source material as long as proper credit is given.
#[doc(alias = "VkDisplayEventTypeEXT")]
#[derive(Clone, Copy, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[cfg_attr(feature = "bytemuck", derive(Pod, Zeroable))]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct DisplayEventTypeEXT(i32);
impl const Default for DisplayEventTypeEXT {
    fn default() -> Self {
        Self(0)
    }
}
impl std::fmt::Debug for DisplayEventTypeEXT {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        f.debug_tuple("DisplayEventTypeEXT")
            .field(match *self {
                Self::DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT => &"DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT",
                other => unreachable!("invalid value for `DisplayEventTypeEXT`: {:?}", other),
            })
            .finish()
    }
}
impl DisplayEventTypeEXT {
    ///[`DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT`] specifies that the fence
    ///is signaled when the first pixel of the next display refresh cycle
    ///leaves the display engine for the display.
    pub const DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT: Self = Self(0);
    ///Default empty value
    #[inline]
    pub const fn empty() -> Self {
        Self::default()
    }
    ///Gets the raw underlying value
    #[inline]
    pub const fn bits(&self) -> i32 {
        self.0
    }
}
